
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for farcaster/build/server/vendor-chunks/@neynar.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../index.html">All files</a> / <a href="index.html">farcaster/build/server/vendor-chunks</a> @neynar.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/21</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/21</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a>
<a name='L4'></a><a href='#L4'>4</a>
<a name='L5'></a><a href='#L5'>5</a>
<a name='L6'></a><a href='#L6'>6</a>
<a name='L7'></a><a href='#L7'>7</a>
<a name='L8'></a><a href='#L8'>8</a>
<a name='L9'></a><a href='#L9'>9</a>
<a name='L10'></a><a href='#L10'>10</a>
<a name='L11'></a><a href='#L11'>11</a>
<a name='L12'></a><a href='#L12'>12</a>
<a name='L13'></a><a href='#L13'>13</a>
<a name='L14'></a><a href='#L14'>14</a>
<a name='L15'></a><a href='#L15'>15</a>
<a name='L16'></a><a href='#L16'>16</a>
<a name='L17'></a><a href='#L17'>17</a>
<a name='L18'></a><a href='#L18'>18</a>
<a name='L19'></a><a href='#L19'>19</a>
<a name='L20'></a><a href='#L20'>20</a>
<a name='L21'></a><a href='#L21'>21</a>
<a name='L22'></a><a href='#L22'>22</a>
<a name='L23'></a><a href='#L23'>23</a>
<a name='L24'></a><a href='#L24'>24</a>
<a name='L25'></a><a href='#L25'>25</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span>
<span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js"><span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >"use strict";</span></span></span>
<span class="cstat-no" title="statement not covered" >/*</span>
<span class="cstat-no" title="statement not covered" > * ATTENTION: An "eval-source-map" devtool has been used.</span>
<span class="cstat-no" title="statement not covered" > * This devtool is neither made for production nor for readable output files.</span>
<span class="cstat-no" title="statement not covered" > * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.</span>
<span class="cstat-no" title="statement not covered" > * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)</span>
<span class="cstat-no" title="statement not covered" > * or disable the default devtool with "devtool: false".</span>
<span class="cstat-no" title="statement not covered" > * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).</span>
<span class="cstat-no" title="statement not covered" > */</span>
<span class="cstat-no" title="statement not covered" >exports.id = "vendor-chunks/@neynar";</span>
<span class="cstat-no" title="statement not covered" >exports.ids = ["vendor-chunks/@neynar"];</span>
<span class="cstat-no" title="statement not covered" >exports.modules = {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ "(ssr)/./node_modules/@neynar/react/dist/bundle.es.js":</span>
<span class="cstat-no" title="statement not covered" >/*!******************************************************!*\</span>
<span class="cstat-no" title="statement not covered" >  !*** ./node_modules/@neynar/react/dist/bundle.es.js ***!</span>
<span class="cstat-no" title="statement not covered" >  \******************************************************/</span>
<span class="cstat-no" title="statement not covered" >/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) =&gt; {</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CastCard: () =&gt; (/* binding */ oa),\n/* harmony export */   MiniAppProvider: () =&gt; (/* binding */ dR),\n/* harmony export */   NeynarAuthButton: () =&gt; (/* binding */ pS),\n/* harmony export */   NeynarAutoCompleteUser: () =&gt; (/* binding */ xR),\n/* harmony export */   NeynarCastCard: () =&gt; (/* binding */ RA),\n/* harmony export */   NeynarContextProvider: () =&gt; (/* binding */ fR),\n/* harmony export */   NeynarConversationList: () =&gt; (/* binding */ mR),\n/* harmony export */   NeynarFeedList: () =&gt; (/* binding */ yR),\n/* harmony export */   NeynarFrameCard: () =&gt; (/* binding */ aI),\n/* harmony export */   NeynarProfileCard: () =&gt; (/* binding */ vR),\n/* harmony export */   NeynarUserDropdown: () =&gt; (/* binding */ ER),\n/* harmony export */   SIWN_variant: () =&gt; (/* binding */ gs),\n/* harmony export */   Theme: () =&gt; (/* binding */ yg),\n/* harmony export */   useLocalStorage: () =&gt; (/* binding */ du),\n/* harmony export */   useMiniApp: () =&gt; (/* binding */ hR),\n/* harmony export */   useNeynarContext: () =&gt; (/* binding */ ts)\n/* harmony export */ });\n/* harmony import */ var _pigment_css_react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pigment-css/react */ \"(ssr)/./node_modules/@pigment-css/react/build/chunk-AFZBAV6Q.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\nvar ym = Object.defineProperty;\nvar vm = (s, e, t) =&gt; e in s ? ym(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;\nvar Cr = (s, e, t) =&gt; vm(s, typeof e != \"symbol\" ? e + \"\" : e, t);\n\n\nconst Gr = {\n  vars: {\n    colors: {\n      primary: \"var(--colors-primary)\"\n    },\n    typography: {\n      fonts: {\n        base: \"var(--typography-fonts-base)\"\n      },\n      fontWeights: {\n        regular: \"var(--typography-fontWeights-regular)\",\n        bold: \"var(--typography-fontWeights-bold)\"\n      },\n      fontSizes: {\n        large: \"var(--typography-fontSizes-large)\",\n        medium: \"var(--typography-fontSizes-medium)\",\n        small: \"var(--typography-fontSizes-small)\"\n      }\n    },\n    palette: {\n      background: \"var(--palette-background)\",\n      border: \"var(--palette-border)\",\n      text: \"var(--palette-text)\",\n      textMuted: \"var(--palette-textMuted)\"\n    }\n  }\n};\nfunction Fc(s) {\n  return s &amp;&amp; s.__esModule &amp;&amp; Object.prototype.hasOwnProperty.call(s, \"default\") ? s.default : s;\n}\nfunction Nc(s) {\n  if (Object.prototype.hasOwnProperty.call(s, \"__esModule\")) return s;\n  var e = s.default;\n  if (typeof e == \"function\") {\n    var t = function r() {\n      return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments);\n    };\n    t.prototype = e.prototype;\n  } else t = {};\n  return Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  }), Object.keys(s).forEach(function(r) {\n    var n = Object.getOwnPropertyDescriptor(s, r);\n    Object.defineProperty(t, r, n.get ? n : {\n      enumerable: !0,\n      get: function() {\n        return s[r];\n      }\n    });\n  }), t;\n}\nvar Ua = { exports: {} }, Kn = {};\n/**\n * @license React\n * react-jsx-runtime.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Wu;\nfunction Sm() {\n  if (Wu) return Kn;\n  Wu = 1;\n  var s = Symbol.for(\"react.transitional.element\"), e = Symbol.for(\"react.fragment\");\n  function t(r, n, i) {\n    var o = null;\n    if (i !== void 0 &amp;&amp; (o = \"\" + i), n.key !== void 0 &amp;&amp; (o = \"\" + n.key), \"key\" in n) {\n      i = {};\n      for (var a in n)\n        a !== \"key\" &amp;&amp; (i[a] = n[a]);\n    } else i = n;\n    return n = i.ref, {\n      $$typeof: s,\n      type: r,\n      key: o,\n      ref: n !== void 0 ? n : null,\n      props: i\n    };\n  }\n  return Kn.Fragment = e, Kn.jsx = t, Kn.jsxs = t, Kn;\n}\nvar zu;\nfunction bm() {\n  return zu || (zu = 1, Ua.exports = Sm()), Ua.exports;\n}\nvar q = bm();\nlet Un = class extends Error {\n  constructor(t, r = {}) {\n    super(t, r.cause ? { cause: r.cause } : void 0);\n    Cr(this, \"name\", \"BaseError\");\n    Cr(this, \"cause\");\n    this.cause = r.cause;\n  }\n};\nclass Tm extends Un {\n  constructor() {\n    super(\"Invalid domain manifest\");\n    Cr(this, \"name\", \"AddMiniApp.InvalidDomainManifest\");\n  }\n}\nlet wm = class extends Un {\n  constructor() {\n    super(\"Add miniapp rejected by user\");\n    Cr(this, \"name\", \"AddMiniApp.RejectedByUser\");\n  }\n}, Of = class extends Un {\n  constructor() {\n    super(\"Sign in rejected by user\");\n    Cr(this, \"name\", \"SignIn.RejectedByUser\");\n  }\n};\nclass Am extends Un {\n  constructor() {\n    super(\"Sign manifest rejected by user\");\n    Cr(this, \"name\", \"SignManifest.RejectedByUser\");\n  }\n}\nclass Im extends Un {\n  constructor() {\n    super(\"Invalid domain provided\");\n    Cr(this, \"name\", \"SignManifest.InvalidDomain\");\n  }\n}\nclass _m extends Un {\n  constructor(t = \"Manifest signing failed\") {\n    super(t);\n    Cr(this, \"name\", \"SignManifest.GenericError\");\n  }\n}\nvar Ze;\n(function(s) {\n  s.assertEqual = (n) =&gt; {\n  };\n  function e(n) {\n  }\n  s.assertIs = e;\n  function t(n) {\n    throw new Error();\n  }\n  s.assertNever = t, s.arrayToEnum = (n) =&gt; {\n    const i = {};\n    for (const o of n)\n      i[o] = o;\n    return i;\n  }, s.getValidEnumValues = (n) =&gt; {\n    const i = s.objectKeys(n).filter((a) =&gt; typeof n[n[a]] != \"number\"), o = {};\n    for (const a of i)\n      o[a] = n[a];\n    return s.objectValues(o);\n  }, s.objectValues = (n) =&gt; s.objectKeys(n).map(function(i) {\n    return n[i];\n  }), s.objectKeys = typeof Object.keys == \"function\" ? (n) =&gt; Object.keys(n) : (n) =&gt; {\n    const i = [];\n    for (const o in n)\n      Object.prototype.hasOwnProperty.call(n, o) &amp;&amp; i.push(o);\n    return i;\n  }, s.find = (n, i) =&gt; {\n    for (const o of n)\n      if (i(o))\n        return o;\n  }, s.isInteger = typeof Number.isInteger == \"function\" ? (n) =&gt; Number.isInteger(n) : (n) =&gt; typeof n == \"number\" &amp;&amp; Number.isFinite(n) &amp;&amp; Math.floor(n) === n;\n  function r(n, i = \" | \") {\n    return n.map((o) =&gt; typeof o == \"string\" ? `'${o}'` : o).join(i);\n  }\n  s.joinValues = r, s.jsonStringifyReplacer = (n, i) =&gt; typeof i == \"bigint\" ? i.toString() : i;\n})(Ze || (Ze = {}));\nvar Yu;\n(function(s) {\n  s.mergeShapes = (e, t) =&gt; ({\n    ...e,\n    ...t\n    // second overwrites first\n  });\n})(Yu || (Yu = {}));\nconst me = Ze.arrayToEnum([\n  \"string\",\n  \"nan\",\n  \"number\",\n  \"integer\",\n  \"float\",\n  \"boolean\",\n  \"date\",\n  \"bigint\",\n  \"symbol\",\n  \"function\",\n  \"undefined\",\n  \"null\",\n  \"array\",\n  \"object\",\n  \"unknown\",\n  \"promise\",\n  \"void\",\n  \"never\",\n  \"map\",\n  \"set\"\n]), ws = (s) =&gt; {\n  switch (typeof s) {\n    case \"undefined\":\n      return me.undefined;\n    case \"string\":\n      return me.string;\n    case \"number\":\n      return Number.isNaN(s) ? me.nan : me.number;\n    case \"boolean\":\n      return me.boolean;\n    case \"function\":\n      return me.function;\n    case \"bigint\":\n      return me.bigint;\n    case \"symbol\":\n      return me.symbol;\n    case \"object\":\n      return Array.isArray(s) ? me.array : s === null ? me.null : s.then &amp;&amp; typeof s.then == \"function\" &amp;&amp; s.catch &amp;&amp; typeof s.catch == \"function\" ? me.promise : typeof Map &lt; \"u\" &amp;&amp; s instanceof Map ? me.map : typeof Set &lt; \"u\" &amp;&amp; s instanceof Set ? me.set : typeof Date &lt; \"u\" &amp;&amp; s instanceof Date ? me.date : me.object;\n    default:\n      return me.unknown;\n  }\n}, ae = Ze.arrayToEnum([\n  \"invalid_type\",\n  \"invalid_literal\",\n  \"custom\",\n  \"invalid_union\",\n  \"invalid_union_discriminator\",\n  \"invalid_enum_value\",\n  \"unrecognized_keys\",\n  \"invalid_arguments\",\n  \"invalid_return_type\",\n  \"invalid_date\",\n  \"invalid_string\",\n  \"too_small\",\n  \"too_big\",\n  \"invalid_intersection_types\",\n  \"not_multiple_of\",\n  \"not_finite\"\n]);\nclass ps extends Error {\n  get errors() {\n    return this.issues;\n  }\n  constructor(e) {\n    super(), this.issues = [], this.addIssue = (r) =&gt; {\n      this.issues = [...this.issues, r];\n    }, this.addIssues = (r = []) =&gt; {\n      this.issues = [...this.issues, ...r];\n    };\n    const t = new.target.prototype;\n    Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = \"ZodError\", this.issues = e;\n  }\n  format(e) {\n    const t = e || function(i) {\n      return i.message;\n    }, r = { _errors: [] }, n = (i) =&gt; {\n      for (const o of i.issues)\n        if (o.code === \"invalid_union\")\n          o.unionErrors.map(n);\n        else if (o.code === \"invalid_return_type\")\n          n(o.returnTypeError);\n        else if (o.code === \"invalid_arguments\")\n          n(o.argumentsError);\n        else if (o.path.length === 0)\n          r._errors.push(t(o));\n        else {\n          let a = r, l = 0;\n          for (; l &lt; o.path.length; ) {\n            const c = o.path[l];\n            l === o.path.length - 1 ? (a[c] = a[c] || { _errors: [] }, a[c]._errors.push(t(o))) : a[c] = a[c] || { _errors: [] }, a = a[c], l++;\n          }\n        }\n    };\n    return n(this), r;\n  }\n  static assert(e) {\n    if (!(e instanceof ps))\n      throw new Error(`Not a ZodError: ${e}`);\n  }\n  toString() {\n    return this.message;\n  }\n  get message() {\n    return JSON.stringify(this.issues, Ze.jsonStringifyReplacer, 2);\n  }\n  get isEmpty() {\n    return this.issues.length === 0;\n  }\n  flatten(e = (t) =&gt; t.message) {\n    const t = {}, r = [];\n    for (const n of this.issues)\n      if (n.path.length &gt; 0) {\n        const i = n.path[0];\n        t[i] = t[i] || [], t[i].push(e(n));\n      } else\n        r.push(e(n));\n    return { formErrors: r, fieldErrors: t };\n  }\n  get formErrors() {\n    return this.flatten();\n  }\n}\nps.create = (s) =&gt; new ps(s);\nconst Kl = (s, e) =&gt; {\n  let t;\n  switch (s.code) {\n    case ae.invalid_type:\n      s.received === me.undefined ? t = \"Required\" : t = `Expected ${s.expected}, received ${s.received}`;\n      break;\n    case ae.invalid_literal:\n      t = `Invalid literal value, expected ${JSON.stringify(s.expected, Ze.jsonStringifyReplacer)}`;\n      break;\n    case ae.unrecognized_keys:\n      t = `Unrecognized key(s) in object: ${Ze.joinValues(s.keys, \", \")}`;\n      break;\n    case ae.invalid_union:\n      t = \"Invalid input\";\n      break;\n    case ae.invalid_union_discriminator:\n      t = `Invalid discriminator value. Expected ${Ze.joinValues(s.options)}`;\n      break;\n    case ae.invalid_enum_value:\n      t = `Invalid enum value. Expected ${Ze.joinValues(s.options)}, received '${s.received}'`;\n      break;\n    case ae.invalid_arguments:\n      t = \"Invalid function arguments\";\n      break;\n    case ae.invalid_return_type:\n      t = \"Invalid function return type\";\n      break;\n    case ae.invalid_date:\n      t = \"Invalid date\";\n      break;\n    case ae.invalid_string:\n      typeof s.validation == \"object\" ? \"includes\" in s.validation ? (t = `Invalid input: must include \"${s.validation.includes}\"`, typeof s.validation.position == \"number\" &amp;&amp; (t = `${t} at one or more positions greater than or equal to ${s.validation.position}`)) : \"startsWith\" in s.validation ? t = `Invalid input: must start with \"${s.validation.startsWith}\"` : \"endsWith\" in s.validation ? t = `Invalid input: must end with \"${s.validation.endsWith}\"` : Ze.assertNever(s.validation) : s.validation !== \"regex\" ? t = `Invalid ${s.validation}` : t = \"Invalid\";\n      break;\n    case ae.too_small:\n      s.type === \"array\" ? t = `Array must contain ${s.exact ? \"exactly\" : s.inclusive ? \"at least\" : \"more than\"} ${s.minimum} element(s)` : s.type === \"string\" ? t = `String must contain ${s.exact ? \"exactly\" : s.inclusive ? \"at least\" : \"over\"} ${s.minimum} character(s)` : s.type === \"number\" ? t = `Number must be ${s.exact ? \"exactly equal to \" : s.inclusive ? \"greater than or equal to \" : \"greater than \"}${s.minimum}` : s.type === \"bigint\" ? t = `Number must be ${s.exact ? \"exactly equal to \" : s.inclusive ? \"greater than or equal to \" : \"greater than \"}${s.minimum}` : s.type === \"date\" ? t = `Date must be ${s.exact ? \"exactly equal to \" : s.inclusive ? \"greater than or equal to \" : \"greater than \"}${new Date(Number(s.minimum))}` : t = \"Invalid input\";\n      break;\n    case ae.too_big:\n      s.type === \"array\" ? t = `Array must contain ${s.exact ? \"exactly\" : s.inclusive ? \"at most\" : \"less than\"} ${s.maximum} element(s)` : s.type === \"string\" ? t = `String must contain ${s.exact ? \"exactly\" : s.inclusive ? \"at most\" : \"under\"} ${s.maximum} character(s)` : s.type === \"number\" ? t = `Number must be ${s.exact ? \"exactly\" : s.inclusive ? \"less than or equal to\" : \"less than\"} ${s.maximum}` : s.type === \"bigint\" ? t = `BigInt must be ${s.exact ? \"exactly\" : s.inclusive ? \"less than or equal to\" : \"less than\"} ${s.maximum}` : s.type === \"date\" ? t = `Date must be ${s.exact ? \"exactly\" : s.inclusive ? \"smaller than or equal to\" : \"smaller than\"} ${new Date(Number(s.maximum))}` : t = \"Invalid input\";\n      break;\n    case ae.custom:\n      t = \"Invalid input\";\n      break;\n    case ae.invalid_intersection_types:\n      t = \"Intersection results could not be merged\";\n      break;\n    case ae.not_multiple_of:\n      t = `Number must be a multiple of ${s.multipleOf}`;\n      break;\n    case ae.not_finite:\n      t = \"Number must be finite\";\n      break;\n    default:\n      t = e.defaultError, Ze.assertNever(s);\n  }\n  return { message: t };\n};\nlet Rm = Kl;\nfunction Lm() {\n  return Rm;\n}\nconst Cm = (s) =&gt; {\n  const { data: e, path: t, errorMaps: r, issueData: n } = s, i = [...t, ...n.path || []], o = {\n    ...n,\n    path: i\n  };\n  if (n.message !== void 0)\n    return {\n      ...n,\n      path: i,\n      message: n.message\n    };\n  let a = \"\";\n  const l = r.filter((c) =&gt; !!c).slice().reverse();\n  for (const c of l)\n    a = c(o, { data: e, defaultError: a }).message;\n  return {\n    ...n,\n    path: i,\n    message: a\n  };\n};\nfunction he(s, e) {\n  const t = Lm(), r = Cm({\n    issueData: e,\n    data: s.data,\n    path: s.path,\n    errorMaps: [\n      s.common.contextualErrorMap,\n      // contextual error map is first priority\n      s.schemaErrorMap,\n      // then schema-bound map if available\n      t,\n      // then global override map\n      t === Kl ? void 0 : Kl\n      // then global default map\n    ].filter((n) =&gt; !!n)\n  });\n  s.common.issues.push(r);\n}\nclass wr {\n  constructor() {\n    this.value = \"valid\";\n  }\n  dirty() {\n    this.value === \"valid\" &amp;&amp; (this.value = \"dirty\");\n  }\n  abort() {\n    this.value !== \"aborted\" &amp;&amp; (this.value = \"aborted\");\n  }\n  static mergeArray(e, t) {\n    const r = [];\n    for (const n of t) {\n      if (n.status === \"aborted\")\n        return Re;\n      n.status === \"dirty\" &amp;&amp; e.dirty(), r.push(n.value);\n    }\n    return { status: e.value, value: r };\n  }\n  static async mergeObjectAsync(e, t) {\n    const r = [];\n    for (const n of t) {\n      const i = await n.key, o = await n.value;\n      r.push({\n        key: i,\n        value: o\n      });\n    }\n    return wr.mergeObjectSync(e, r);\n  }\n  static mergeObjectSync(e, t) {\n    const r = {};\n    for (const n of t) {\n      const { key: i, value: o } = n;\n      if (i.status === \"aborted\" || o.status === \"aborted\")\n        return Re;\n      i.status === \"dirty\" &amp;&amp; e.dirty(), o.status === \"dirty\" &amp;&amp; e.dirty(), i.value !== \"__proto__\" &amp;&amp; (typeof o.value &lt; \"u\" || n.alwaysSet) &amp;&amp; (r[i.value] = o.value);\n    }\n    return { status: e.value, value: r };\n  }\n}\nconst Re = Object.freeze({\n  status: \"aborted\"\n}), Wn = (s) =&gt; ({ status: \"dirty\", value: s }), Rr = (s) =&gt; ({ status: \"valid\", value: s }), Zu = (s) =&gt; s.status === \"aborted\", Xu = (s) =&gt; s.status === \"dirty\", Ln = (s) =&gt; s.status === \"valid\", bo = (s) =&gt; typeof Promise &lt; \"u\" &amp;&amp; s instanceof Promise;\nvar Ee;\n(function(s) {\n  s.errToObj = (e) =&gt; typeof e == \"string\" ? { message: e } : e || {}, s.toString = (e) =&gt; typeof e == \"string\" ? e : e == null ? void 0 : e.message;\n})(Ee || (Ee = {}));\nclass Ds {\n  constructor(e, t, r, n) {\n    this._cachedPath = [], this.parent = e, this.data = t, this._path = r, this._key = n;\n  }\n  get path() {\n    return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;\n  }\n}\nconst Ju = (s, e) =&gt; {\n  if (Ln(e))\n    return { success: !0, data: e.value };\n  if (!s.common.issues.length)\n    throw new Error(\"Validation failed but no issues detected.\");\n  return {\n    success: !1,\n    get error() {\n      if (this._error)\n        return this._error;\n      const t = new ps(s.common.issues);\n      return this._error = t, this._error;\n    }\n  };\n};\nfunction Ve(s) {\n  if (!s)\n    return {};\n  const { errorMap: e, invalid_type_error: t, required_error: r, description: n } = s;\n  if (e &amp;&amp; (t || r))\n    throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n  return e ? { errorMap: e, description: n } : { errorMap: (o, a) =&gt; {\n    const { message: l } = s;\n    return o.code === \"invalid_enum_value\" ? { message: l ?? a.defaultError } : typeof a.data &gt; \"u\" ? { message: l ?? r ?? a.defaultError } : o.code !== \"invalid_type\" ? { message: a.defaultError } : { message: l ?? t ?? a.defaultError };\n  }, description: n };\n}\nclass Ye {\n  get description() {\n    return this._def.description;\n  }\n  _getType(e) {\n    return ws(e.data);\n  }\n  _getOrReturnCtx(e, t) {\n    return t || {\n      common: e.parent.common,\n      data: e.data,\n      parsedType: ws(e.data),\n      schemaErrorMap: this._def.errorMap,\n      path: e.path,\n      parent: e.parent\n    };\n  }\n  _processInputParams(e) {\n    return {\n      status: new wr(),\n      ctx: {\n        common: e.parent.common,\n        data: e.data,\n        parsedType: ws(e.data),\n        schemaErrorMap: this._def.errorMap,\n        path: e.path,\n        parent: e.parent\n      }\n    };\n  }\n  _parseSync(e) {\n    const t = this._parse(e);\n    if (bo(t))\n      throw new Error(\"Synchronous parse encountered promise.\");\n    return t;\n  }\n  _parseAsync(e) {\n    const t = this._parse(e);\n    return Promise.resolve(t);\n  }\n  parse(e, t) {\n    const r = this.safeParse(e, t);\n    if (r.success)\n      return r.data;\n    throw r.error;\n  }\n  safeParse(e, t) {\n    const r = {\n      common: {\n        issues: [],\n        async: (t == null ? void 0 : t.async) ?? !1,\n        contextualErrorMap: t == null ? void 0 : t.errorMap\n      },\n      path: (t == null ? void 0 : t.path) || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data: e,\n      parsedType: ws(e)\n    }, n = this._parseSync({ data: e, path: r.path, parent: r });\n    return Ju(r, n);\n  }\n  \"~validate\"(e) {\n    var r, n;\n    const t = {\n      common: {\n        issues: [],\n        async: !!this[\"~standard\"].async\n      },\n      path: [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data: e,\n      parsedType: ws(e)\n    };\n    if (!this[\"~standard\"].async)\n      try {\n        const i = this._parseSync({ data: e, path: [], parent: t });\n        return Ln(i) ? {\n          value: i.value\n        } : {\n          issues: t.common.issues\n        };\n      } catch (i) {\n        (n = (r = i == null ? void 0 : i.message) == null ? void 0 : r.toLowerCase()) != null &amp;&amp; n.includes(\"encountered\") &amp;&amp; (this[\"~standard\"].async = !0), t.common = {\n          issues: [],\n          async: !0\n        };\n      }\n    return this._parseAsync({ data: e, path: [], parent: t }).then((i) =&gt; Ln(i) ? {\n      value: i.value\n    } : {\n      issues: t.common.issues\n    });\n  }\n  async parseAsync(e, t) {\n    const r = await this.safeParseAsync(e, t);\n    if (r.success)\n      return r.data;\n    throw r.error;\n  }\n  async safeParseAsync(e, t) {\n    const r = {\n      common: {\n        issues: [],\n        contextualErrorMap: t == null ? void 0 : t.errorMap,\n        async: !0\n      },\n      path: (t == null ? void 0 : t.path) || [],\n      schemaErrorMap: this._def.errorMap,\n      parent: null,\n      data: e,\n      parsedType: ws(e)\n    }, n = this._parse({ data: e, path: r.path, parent: r }), i = await (bo(n) ? n : Promise.resolve(n));\n    return Ju(r, i);\n  }\n  refine(e, t) {\n    const r = (n) =&gt; typeof t == \"string\" || typeof t &gt; \"u\" ? { message: t } : typeof t == \"function\" ? t(n) : t;\n    return this._refinement((n, i) =&gt; {\n      const o = e(n), a = () =&gt; i.addIssue({\n        code: ae.custom,\n        ...r(n)\n      });\n      return typeof Promise &lt; \"u\" &amp;&amp; o instanceof Promise ? o.then((l) =&gt; l ? !0 : (a(), !1)) : o ? !0 : (a(), !1);\n    });\n  }\n  refinement(e, t) {\n    return this._refinement((r, n) =&gt; e(r) ? !0 : (n.addIssue(typeof t == \"function\" ? t(r, n) : t), !1));\n  }\n  _refinement(e) {\n    return new Ys({\n      schema: this,\n      typeName: ke.ZodEffects,\n      effect: { type: \"refinement\", refinement: e }\n    });\n  }\n  superRefine(e) {\n    return this._refinement(e);\n  }\n  constructor(e) {\n    this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this[\"~standard\"] = {\n      version: 1,\n      vendor: \"zod\",\n      validate: (t) =&gt; this[\"~validate\"](t)\n    };\n  }\n  optional() {\n    return fs.create(this, this._def);\n  }\n  nullable() {\n    return Zs.create(this, this._def);\n  }\n  nullish() {\n    return this.nullable().optional();\n  }\n  array() {\n    return Yr.create(this);\n  }\n  promise() {\n    return _o.create(this, this._def);\n  }\n  or(e) {\n    return wo.create([this, e], this._def);\n  }\n  and(e) {\n    return Ao.create(this, e, this._def);\n  }\n  transform(e) {\n    return new Ys({\n      ...Ve(this._def),\n      schema: this,\n      typeName: ke.ZodEffects,\n      effect: { type: \"transform\", transform: e }\n    });\n  }\n  default(e) {\n    const t = typeof e == \"function\" ? e : () =&gt; e;\n    return new Ro({\n      ...Ve(this._def),\n      innerType: this,\n      defaultValue: t,\n      typeName: ke.ZodDefault\n    });\n  }\n  brand() {\n    return new Uf({\n      typeName: ke.ZodBranded,\n      type: this,\n      ...Ve(this._def)\n    });\n  }\n  catch(e) {\n    const t = typeof e == \"function\" ? e : () =&gt; e;\n    return new Lo({\n      ...Ve(this._def),\n      innerType: this,\n      catchValue: t,\n      typeName: ke.ZodCatch\n    });\n  }\n  describe(e) {\n    const t = this.constructor;\n    return new t({\n      ...this._def,\n      description: e\n    });\n  }\n  pipe(e) {\n    return $c.create(this, e);\n  }\n  readonly() {\n    return Co.create(this);\n  }\n  isOptional() {\n    return this.safeParse(void 0).success;\n  }\n  isNullable() {\n    return this.safeParse(null).success;\n  }\n}\nconst km = /^c[^\\s-]{8,}$/i, Dm = /^[0-9a-z]+$/, Pm = /^[0-9A-HJKMNP-TV-Z]{26}$/i, Mm = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/i, Om = /^[a-z0-9_-]{21}$/i, Bm = /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/, Fm = /^[-+]?P(?!$)(?:(?:[-+]?\\d+Y)|(?:[-+]?\\d+[.,]\\d+Y$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:(?:[-+]?\\d+W)|(?:[-+]?\\d+[.,]\\d+W$))?(?:(?:[-+]?\\d+D)|(?:[-+]?\\d+[.,]\\d+D$))?(?:T(?=[\\d+-])(?:(?:[-+]?\\d+H)|(?:[-+]?\\d+[.,]\\d+H$))?(?:(?:[-+]?\\d+M)|(?:[-+]?\\d+[.,]\\d+M$))?(?:[-+]?\\d+(?:[.,]\\d+)?S)?)??$/, Nm = /^(?!\\.)(?!.*\\.\\.)([A-Z0-9_'+\\-\\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\\-]*\\.)+[A-Z]{2,}$/i, Um = \"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\";\nlet $a;\nconst $m = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Gm = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/, Vm = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, jm = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, Km = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, Hm = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, Bf = \"((\\\\d\\\\d[2468][048]|\\\\d\\\\d[13579][26]|\\\\d\\\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\\\d|30)|(02)-(0[1-9]|1\\\\d|2[0-8])))\", qm = new RegExp(`^${Bf}$`);\nfunction Ff(s) {\n  let e = \"[0-5]\\\\d\";\n  s.precision ? e = `${e}\\\\.\\\\d{${s.precision}}` : s.precision == null &amp;&amp; (e = `${e}(\\\\.\\\\d+)?`);\n  const t = s.precision ? \"+\" : \"?\";\n  return `([01]\\\\d|2[0-3]):[0-5]\\\\d(:${e})${t}`;\n}\nfunction Wm(s) {\n  return new RegExp(`^${Ff(s)}$`);\n}\nfunction zm(s) {\n  let e = `${Bf}T${Ff(s)}`;\n  const t = [];\n  return t.push(s.local ? \"Z?\" : \"Z\"), s.offset &amp;&amp; t.push(\"([+-]\\\\d{2}:?\\\\d{2})\"), e = `${e}(${t.join(\"|\")})`, new RegExp(`^${e}$`);\n}\nfunction Ym(s, e) {\n  return !!((e === \"v4\" || !e) &amp;&amp; $m.test(s) || (e === \"v6\" || !e) &amp;&amp; Vm.test(s));\n}\nfunction Zm(s, e) {\n  if (!Bm.test(s))\n    return !1;\n  try {\n    const [t] = s.split(\".\");\n    if (!t)\n      return !1;\n    const r = t.replace(/-/g, \"+\").replace(/_/g, \"/\").padEnd(t.length + (4 - t.length % 4) % 4, \"=\"), n = JSON.parse(atob(r));\n    return !(typeof n != \"object\" || n === null || \"typ\" in n &amp;&amp; (n == null ? void 0 : n.typ) !== \"JWT\" || !n.alg || e &amp;&amp; n.alg !== e);\n  } catch {\n    return !1;\n  }\n}\nfunction Xm(s, e) {\n  return !!((e === \"v4\" || !e) &amp;&amp; Gm.test(s) || (e === \"v6\" || !e) &amp;&amp; jm.test(s));\n}\nclass Rs extends Ye {\n  _parse(e) {\n    if (this._def.coerce &amp;&amp; (e.data = String(e.data)), this._getType(e) !== me.string) {\n      const i = this._getOrReturnCtx(e);\n      return he(i, {\n        code: ae.invalid_type,\n        expected: me.string,\n        received: i.parsedType\n      }), Re;\n    }\n    const r = new wr();\n    let n;\n    for (const i of this._def.checks)\n      if (i.kind === \"min\")\n        e.data.length &lt; i.value &amp;&amp; (n = this._getOrReturnCtx(e, n), he(n, {\n          code: ae.too_small,\n          minimum: i.value,\n          type: \"string\",\n          inclusive: !0,\n          exact: !1,\n          message: i.message\n        }), r.dirty());\n      else if (i.kind === \"max\")\n        e.data.length &gt; i.value &amp;&amp; (n = this._getOrReturnCtx(e, n), he(n, {\n          code: ae.too_big,\n          maximum: i.value,\n          type: \"string\",\n          inclusive: !0,\n          exact: !1,\n          message: i.message\n        }), r.dirty());\n      else if (i.kind === \"length\") {\n        const o = e.data.length &gt; i.value, a = e.data.length &lt; i.value;\n        (o || a) &amp;&amp; (n = this._getOrReturnCtx(e, n), o ? he(n, {\n          code: ae.too_big,\n          maximum: i.value,\n          type: \"string\",\n          inclusive: !0,\n          exact: !0,\n          message: i.message\n        }) : a &amp;&amp; he(n, {\n          code: ae.too_small,\n          minimum: i.value,\n          type: \"string\",\n          inclusive: !0,\n          exact: !0,\n          message: i.message\n        }), r.dirty());\n      } else if (i.kind === \"email\")\n        Nm.test(e.data) || (n = this._getOrReturnCtx(e, n), he(n, {\n          validation: \"email\",\n          code: ae.invalid_string,\n          message: i.message\n        }), r.dirty());\n      else if (i.kind === \"emoji\")\n        $a || ($a = new RegExp(Um, \"u\")), $a.test(e.data) || (n = this._getOrReturnCtx(e, n), he(n, {\n          validation: \"emoji\",\n          code: ae.invalid_string,\n          message: i.message\n        }), r.dirty());\n      else if (i.kind === \"uuid\")\n        Mm.test(e.data) || (n = this._getOrReturnCtx(e, n), he(n, {\n          validation: \"uuid\",\n          code: ae.invalid_string,\n          message: i.message\n        }), r.dirty());\n      else if (i.kind === \"nanoid\")\n        Om.test(e.data) || (n = this._getOrReturnCtx(e, n), he(n, {\n          validation: \"nanoid\",\n          code: ae.invalid_string,\n          message: i.message\n        }), r.dirty());\n      else if (i.kind === \"cuid\")\n        km.test(e.data) || (n = this._getOrReturnCtx(e, n), he(n, {\n          validation: \"cuid\",\n          code: ae.invalid_string,\n          message: i.message\n        }), r.dirty());\n      else if (i.kind === \"cuid2\")\n        Dm.test(e.data) || (n = this._getOrReturnCtx(e, n), he(n, {\n          validation: \"cuid2\",\n          code: ae.invalid_string,\n          message: i.message\n        }), r.dirty());\n      else if (i.kind === \"ulid\")\n        Pm.test(e.data) || (n = this._getOrReturnCtx(e, n), he(n, {\n          validation: \"ulid\",\n          code: ae.invalid_string,\n          message: i.message\n        }), r.dirty());\n      else if (i.kind === \"url\")\n        try {\n          new URL(e.data);\n        } catch {\n          n = this._getOrReturnCtx(e, n), he(n, {\n            validation: \"url\",\n            code: ae.invalid_string,\n            message: i.message\n          }), r.dirty();\n        }\n      else i.kind === \"regex\" ? (i.regex.lastIndex = 0, i.regex.test(e.data) || (n = this._getOrReturnCtx(e, n), he(n, {\n        validation: \"regex\",\n        code: ae.invalid_string,\n        message: i.message\n      }), r.dirty())) : i.kind === \"trim\" ? e.data = e.data.trim() : i.kind === \"includes\" ? e.data.includes(i.value, i.position) || (n = this._getOrReturnCtx(e, n), he(n, {\n        code: ae.invalid_string,\n        validation: { includes: i.value, position: i.position },\n        message: i.message\n      }), r.dirty()) : i.kind === \"toLowerCase\" ? e.data = e.data.toLowerCase() : i.kind === \"toUpperCase\" ? e.data = e.data.toUpperCase() : i.kind === \"startsWith\" ? e.data.startsWith(i.value) || (n = this._getOrReturnCtx(e, n), he(n, {\n        code: ae.invalid_string,\n        validation: { startsWith: i.value },\n        message: i.message\n      }), r.dirty()) : i.kind === \"endsWith\" ? e.data.endsWith(i.value) || (n = this._getOrReturnCtx(e, n), he(n, {\n        code: ae.invalid_string,\n        validation: { endsWith: i.value },\n        message: i.message\n      }), r.dirty()) : i.kind === \"datetime\" ? zm(i).test(e.data) || (n = this._getOrReturnCtx(e, n), he(n, {\n        code: ae.invalid_string,\n        validation: \"datetime\",\n        message: i.message\n      }), r.dirty()) : i.kind === \"date\" ? qm.test(e.data) || (n = this._getOrReturnCtx(e, n), he(n, {\n        code: ae.invalid_string,\n        validation: \"date\",\n        message: i.message\n      }), r.dirty()) : i.kind === \"time\" ? Wm(i).test(e.data) || (n = this._getOrReturnCtx(e, n), he(n, {\n        code: ae.invalid_string,\n        validation: \"time\",\n        message: i.message\n      }), r.dirty()) : i.kind === \"duration\" ? Fm.test(e.data) || (n = this._getOrReturnCtx(e, n), he(n, {\n        validation: \"duration\",\n        code: ae.invalid_string,\n        message: i.message\n      }), r.dirty()) : i.kind === \"ip\" ? Ym(e.data, i.version) || (n = this._getOrReturnCtx(e, n), he(n, {\n        validation: \"ip\",\n        code: ae.invalid_string,\n        message: i.message\n      }), r.dirty()) : i.kind === \"jwt\" ? Zm(e.data, i.alg) || (n = this._getOrReturnCtx(e, n), he(n, {\n        validation: \"jwt\",\n        code: ae.invalid_string,\n        message: i.message\n      }), r.dirty()) : i.kind === \"cidr\" ? Xm(e.data, i.version) || (n = this._getOrReturnCtx(e, n), he(n, {\n        validation: \"cidr\",\n        code: ae.invalid_string,\n        message: i.message\n      }), r.dirty()) : i.kind === \"base64\" ? Km.test(e.data) || (n = this._getOrReturnCtx(e, n), he(n, {\n        validation: \"base64\",\n        code: ae.invalid_string,\n        message: i.message\n      }), r.dirty()) : i.kind === \"base64url\" ? Hm.test(e.data) || (n = this._getOrReturnCtx(e, n), he(n, {\n        validation: \"base64url\",\n        code: ae.invalid_string,\n        message: i.message\n      }), r.dirty()) : Ze.assertNever(i);\n    return { status: r.value, value: e.data };\n  }\n  _regex(e, t, r) {\n    return this.refinement((n) =&gt; e.test(n), {\n      validation: t,\n      code: ae.invalid_string,\n      ...Ee.errToObj(r)\n    });\n  }\n  _addCheck(e) {\n    return new Rs({\n      ...this._def,\n      checks: [...this._def.checks, e]\n    });\n  }\n  email(e) {\n    return this._addCheck({ kind: \"email\", ...Ee.errToObj(e) });\n  }\n  url(e) {\n    return this._addCheck({ kind: \"url\", ...Ee.errToObj(e) });\n  }\n  emoji(e) {\n    return this._addCheck({ kind: \"emoji\", ...Ee.errToObj(e) });\n  }\n  uuid(e) {\n    return this._addCheck({ kind: \"uuid\", ...Ee.errToObj(e) });\n  }\n  nanoid(e) {\n    return this._addCheck({ kind: \"nanoid\", ...Ee.errToObj(e) });\n  }\n  cuid(e) {\n    return this._addCheck({ kind: \"cuid\", ...Ee.errToObj(e) });\n  }\n  cuid2(e) {\n    return this._addCheck({ kind: \"cuid2\", ...Ee.errToObj(e) });\n  }\n  ulid(e) {\n    return this._addCheck({ kind: \"ulid\", ...Ee.errToObj(e) });\n  }\n  base64(e) {\n    return this._addCheck({ kind: \"base64\", ...Ee.errToObj(e) });\n  }\n  base64url(e) {\n    return this._addCheck({\n      kind: \"base64url\",\n      ...Ee.errToObj(e)\n    });\n  }\n  jwt(e) {\n    return this._addCheck({ kind: \"jwt\", ...Ee.errToObj(e) });\n  }\n  ip(e) {\n    return this._addCheck({ kind: \"ip\", ...Ee.errToObj(e) });\n  }\n  cidr(e) {\n    return this._addCheck({ kind: \"cidr\", ...Ee.errToObj(e) });\n  }\n  datetime(e) {\n    return typeof e == \"string\" ? this._addCheck({\n      kind: \"datetime\",\n      precision: null,\n      offset: !1,\n      local: !1,\n      message: e\n    }) : this._addCheck({\n      kind: \"datetime\",\n      precision: typeof (e == null ? void 0 : e.precision) &gt; \"u\" ? null : e == null ? void 0 : e.precision,\n      offset: (e == null ? void 0 : e.offset) ?? !1,\n      local: (e == null ? void 0 : e.local) ?? !1,\n      ...Ee.errToObj(e == null ? void 0 : e.message)\n    });\n  }\n  date(e) {\n    return this._addCheck({ kind: \"date\", message: e });\n  }\n  time(e) {\n    return typeof e == \"string\" ? this._addCheck({\n      kind: \"time\",\n      precision: null,\n      message: e\n    }) : this._addCheck({\n      kind: \"time\",\n      precision: typeof (e == null ? void 0 : e.precision) &gt; \"u\" ? null : e == null ? void 0 : e.precision,\n      ...Ee.errToObj(e == null ? void 0 : e.message)\n    });\n  }\n  duration(e) {\n    return this._addCheck({ kind: \"duration\", ...Ee.errToObj(e) });\n  }\n  regex(e, t) {\n    return this._addCheck({\n      kind: \"regex\",\n      regex: e,\n      ...Ee.errToObj(t)\n    });\n  }\n  includes(e, t) {\n    return this._addCheck({\n      kind: \"includes\",\n      value: e,\n      position: t == null ? void 0 : t.position,\n      ...Ee.errToObj(t == null ? void 0 : t.message)\n    });\n  }\n  startsWith(e, t) {\n    return this._addCheck({\n      kind: \"startsWith\",\n      value: e,\n      ...Ee.errToObj(t)\n    });\n  }\n  endsWith(e, t) {\n    return this._addCheck({\n      kind: \"endsWith\",\n      value: e,\n      ...Ee.errToObj(t)\n    });\n  }\n  min(e, t) {\n    return this._addCheck({\n      kind: \"min\",\n      value: e,\n      ...Ee.errToObj(t)\n    });\n  }\n  max(e, t) {\n    return this._addCheck({\n      kind: \"max\",\n      value: e,\n      ...Ee.errToObj(t)\n    });\n  }\n  length(e, t) {\n    return this._addCheck({\n      kind: \"length\",\n      value: e,\n      ...Ee.errToObj(t)\n    });\n  }\n  /**\n   * Equivalent to `.min(1)`\n   */\n  nonempty(e) {\n    return this.min(1, Ee.errToObj(e));\n  }\n  trim() {\n    return new Rs({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"trim\" }]\n    });\n  }\n  toLowerCase() {\n    return new Rs({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toLowerCase\" }]\n    });\n  }\n  toUpperCase() {\n    return new Rs({\n      ...this._def,\n      checks: [...this._def.checks, { kind: \"toUpperCase\" }]\n    });\n  }\n  get isDatetime() {\n    return !!this._def.checks.find((e) =&gt; e.kind === \"datetime\");\n  }\n  get isDate() {\n    return !!this._def.checks.find((e) =&gt; e.kind === \"date\");\n  }\n  get isTime() {\n    return !!this._def.checks.find((e) =&gt; e.kind === \"time\");\n  }\n  get isDuration() {\n    return !!this._def.checks.find((e) =&gt; e.kind === \"duration\");\n  }\n  get isEmail() {\n    return !!this._def.checks.find((e) =&gt; e.kind === \"email\");\n  }\n  get isURL() {\n    return !!this._def.checks.find((e) =&gt; e.kind === \"url\");\n  }\n  get isEmoji() {\n    return !!this._def.checks.find((e) =&gt; e.kind === \"emoji\");\n  }\n  get isUUID() {\n    return !!this._def.checks.find((e) =&gt; e.kind === \"uuid\");\n  }\n  get isNANOID() {\n    return !!this._def.checks.find((e) =&gt; e.kind === \"nanoid\");\n  }\n  get isCUID() {\n    return !!this._def.checks.find((e) =&gt; e.kind === \"cuid\");\n  }\n  get isCUID2() {\n    return !!this._def.checks.find((e) =&gt; e.kind === \"cuid2\");\n  }\n  get isULID() {\n    return !!this._def.checks.find((e) =&gt; e.kind === \"ulid\");\n  }\n  get isIP() {\n    return !!this._def.checks.find((e) =&gt; e.kind === \"ip\");\n  }\n  get isCIDR() {\n    return !!this._def.checks.find((e) =&gt; e.kind === \"cidr\");\n  }\n  get isBase64() {\n    return !!this._def.checks.find((e) =&gt; e.kind === \"base64\");\n  }\n  get isBase64url() {\n    return !!this._def.checks.find((e) =&gt; e.kind === \"base64url\");\n  }\n  get minLength() {\n    let e = null;\n    for (const t of this._def.checks)\n      t.kind === \"min\" &amp;&amp; (e === null || t.value &gt; e) &amp;&amp; (e = t.value);\n    return e;\n  }\n  get maxLength() {\n    let e = null;\n    for (const t of this._def.checks)\n      t.kind === \"max\" &amp;&amp; (e === null || t.value &lt; e) &amp;&amp; (e = t.value);\n    return e;\n  }\n}\nRs.create = (s) =&gt; new Rs({\n  checks: [],\n  typeName: ke.ZodString,\n  coerce: (s == null ? void 0 : s.coerce) ?? !1,\n  ...Ve(s)\n});\nfunction Jm(s, e) {\n  const t = (s.toString().split(\".\")[1] || \"\").length, r = (e.toString().split(\".\")[1] || \"\").length, n = t &gt; r ? t : r, i = Number.parseInt(s.toFixed(n).replace(\".\", \"\")), o = Number.parseInt(e.toFixed(n).replace(\".\", \"\"));\n  return i % o / 10 ** n;\n}\nclass Cn extends Ye {\n  constructor() {\n    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;\n  }\n  _parse(e) {\n    if (this._def.coerce &amp;&amp; (e.data = Number(e.data)), this._getType(e) !== me.number) {\n      const i = this._getOrReturnCtx(e);\n      return he(i, {\n        code: ae.invalid_type,\n        expected: me.number,\n        received: i.parsedType\n      }), Re;\n    }\n    let r;\n    const n = new wr();\n    for (const i of this._def.checks)\n      i.kind === \"int\" ? Ze.isInteger(e.data) || (r = this._getOrReturnCtx(e, r), he(r, {\n        code: ae.invalid_type,\n        expected: \"integer\",\n        received: \"float\",\n        message: i.message\n      }), n.dirty()) : i.kind === \"min\" ? (i.inclusive ? e.data &lt; i.value : e.data &lt;= i.value) &amp;&amp; (r = this._getOrReturnCtx(e, r), he(r, {\n        code: ae.too_small,\n        minimum: i.value,\n        type: \"number\",\n        inclusive: i.inclusive,\n        exact: !1,\n        message: i.message\n      }), n.dirty()) : i.kind === \"max\" ? (i.inclusive ? e.data &gt; i.value : e.data &gt;= i.value) &amp;&amp; (r = this._getOrReturnCtx(e, r), he(r, {\n        code: ae.too_big,\n        maximum: i.value,\n        type: \"number\",\n        inclusive: i.inclusive,\n        exact: !1,\n        message: i.message\n      }), n.dirty()) : i.kind === \"multipleOf\" ? Jm(e.data, i.value) !== 0 &amp;&amp; (r = this._getOrReturnCtx(e, r), he(r, {\n        code: ae.not_multiple_of,\n        multipleOf: i.value,\n        message: i.message\n      }), n.dirty()) : i.kind === \"finite\" ? Number.isFinite(e.data) || (r = this._getOrReturnCtx(e, r), he(r, {\n        code: ae.not_finite,\n        message: i.message\n      }), n.dirty()) : Ze.assertNever(i);\n    return { status: n.value, value: e.data };\n  }\n  gte(e, t) {\n    return this.setLimit(\"min\", e, !0, Ee.toString(t));\n  }\n  gt(e, t) {\n    return this.setLimit(\"min\", e, !1, Ee.toString(t));\n  }\n  lte(e, t) {\n    return this.setLimit(\"max\", e, !0, Ee.toString(t));\n  }\n  lt(e, t) {\n    return this.setLimit(\"max\", e, !1, Ee.toString(t));\n  }\n  setLimit(e, t, r, n) {\n    return new Cn({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind: e,\n          value: t,\n          inclusive: r,\n          message: Ee.toString(n)\n        }\n      ]\n    });\n  }\n  _addCheck(e) {\n    return new Cn({\n      ...this._def,\n      checks: [...this._def.checks, e]\n    });\n  }\n  int(e) {\n    return this._addCheck({\n      kind: \"int\",\n      message: Ee.toString(e)\n    });\n  }\n  positive(e) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: !1,\n      message: Ee.toString(e)\n    });\n  }\n  negative(e) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: !1,\n      message: Ee.toString(e)\n    });\n  }\n  nonpositive(e) {\n    return this._addCheck({\n      kind: \"max\",\n      value: 0,\n      inclusive: !0,\n      message: Ee.toString(e)\n    });\n  }\n  nonnegative(e) {\n    return this._addCheck({\n      kind: \"min\",\n      value: 0,\n      inclusive: !0,\n      message: Ee.toString(e)\n    });\n  }\n  multipleOf(e, t) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value: e,\n      message: Ee.toString(t)\n    });\n  }\n  finite(e) {\n    return this._addCheck({\n      kind: \"finite\",\n      message: Ee.toString(e)\n    });\n  }\n  safe(e) {\n    return this._addCheck({\n      kind: \"min\",\n      inclusive: !0,\n      value: Number.MIN_SAFE_INTEGER,\n      message: Ee.toString(e)\n    })._addCheck({\n      kind: \"max\",\n      inclusive: !0,\n      value: Number.MAX_SAFE_INTEGER,\n      message: Ee.toString(e)\n    });\n  }\n  get minValue() {\n    let e = null;\n    for (const t of this._def.checks)\n      t.kind === \"min\" &amp;&amp; (e === null || t.value &gt; e) &amp;&amp; (e = t.value);\n    return e;\n  }\n  get maxValue() {\n    let e = null;\n    for (const t of this._def.checks)\n      t.kind === \"max\" &amp;&amp; (e === null || t.value &lt; e) &amp;&amp; (e = t.value);\n    return e;\n  }\n  get isInt() {\n    return !!this._def.checks.find((e) =&gt; e.kind === \"int\" || e.kind === \"multipleOf\" &amp;&amp; Ze.isInteger(e.value));\n  }\n  get isFinite() {\n    let e = null, t = null;\n    for (const r of this._def.checks) {\n      if (r.kind === \"finite\" || r.kind === \"int\" || r.kind === \"multipleOf\")\n        return !0;\n      r.kind === \"min\" ? (t === null || r.value &gt; t) &amp;&amp; (t = r.value) : r.kind === \"max\" &amp;&amp; (e === null || r.value &lt; e) &amp;&amp; (e = r.value);\n    }\n    return Number.isFinite(t) &amp;&amp; Number.isFinite(e);\n  }\n}\nCn.create = (s) =&gt; new Cn({\n  checks: [],\n  typeName: ke.ZodNumber,\n  coerce: (s == null ? void 0 : s.coerce) || !1,\n  ...Ve(s)\n});\nclass Jn extends Ye {\n  constructor() {\n    super(...arguments), this.min = this.gte, this.max = this.lte;\n  }\n  _parse(e) {\n    if (this._def.coerce)\n      try {\n        e.data = BigInt(e.data);\n      } catch {\n        return this._getInvalidInput(e);\n      }\n    if (this._getType(e) !== me.bigint)\n      return this._getInvalidInput(e);\n    let r;\n    const n = new wr();\n    for (const i of this._def.checks)\n      i.kind === \"min\" ? (i.inclusive ? e.data &lt; i.value : e.data &lt;= i.value) &amp;&amp; (r = this._getOrReturnCtx(e, r), he(r, {\n        code: ae.too_small,\n        type: \"bigint\",\n        minimum: i.value,\n        inclusive: i.inclusive,\n        message: i.message\n      }), n.dirty()) : i.kind === \"max\" ? (i.inclusive ? e.data &gt; i.value : e.data &gt;= i.value) &amp;&amp; (r = this._getOrReturnCtx(e, r), he(r, {\n        code: ae.too_big,\n        type: \"bigint\",\n        maximum: i.value,\n        inclusive: i.inclusive,\n        message: i.message\n      }), n.dirty()) : i.kind === \"multipleOf\" ? e.data % i.value !== BigInt(0) &amp;&amp; (r = this._getOrReturnCtx(e, r), he(r, {\n        code: ae.not_multiple_of,\n        multipleOf: i.value,\n        message: i.message\n      }), n.dirty()) : Ze.assertNever(i);\n    return { status: n.value, value: e.data };\n  }\n  _getInvalidInput(e) {\n    const t = this._getOrReturnCtx(e);\n    return he(t, {\n      code: ae.invalid_type,\n      expected: me.bigint,\n      received: t.parsedType\n    }), Re;\n  }\n  gte(e, t) {\n    return this.setLimit(\"min\", e, !0, Ee.toString(t));\n  }\n  gt(e, t) {\n    return this.setLimit(\"min\", e, !1, Ee.toString(t));\n  }\n  lte(e, t) {\n    return this.setLimit(\"max\", e, !0, Ee.toString(t));\n  }\n  lt(e, t) {\n    return this.setLimit(\"max\", e, !1, Ee.toString(t));\n  }\n  setLimit(e, t, r, n) {\n    return new Jn({\n      ...this._def,\n      checks: [\n        ...this._def.checks,\n        {\n          kind: e,\n          value: t,\n          inclusive: r,\n          message: Ee.toString(n)\n        }\n      ]\n    });\n  }\n  _addCheck(e) {\n    return new Jn({\n      ...this._def,\n      checks: [...this._def.checks, e]\n    });\n  }\n  positive(e) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: !1,\n      message: Ee.toString(e)\n    });\n  }\n  negative(e) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: !1,\n      message: Ee.toString(e)\n    });\n  }\n  nonpositive(e) {\n    return this._addCheck({\n      kind: \"max\",\n      value: BigInt(0),\n      inclusive: !0,\n      message: Ee.toString(e)\n    });\n  }\n  nonnegative(e) {\n    return this._addCheck({\n      kind: \"min\",\n      value: BigInt(0),\n      inclusive: !0,\n      message: Ee.toString(e)\n    });\n  }\n  multipleOf(e, t) {\n    return this._addCheck({\n      kind: \"multipleOf\",\n      value: e,\n      message: Ee.toString(t)\n    });\n  }\n  get minValue() {\n    let e = null;\n    for (const t of this._def.checks)\n      t.kind === \"min\" &amp;&amp; (e === null || t.value &gt; e) &amp;&amp; (e = t.value);\n    return e;\n  }\n  get maxValue() {\n    let e = null;\n    for (const t of this._def.checks)\n      t.kind === \"max\" &amp;&amp; (e === null || t.value &lt; e) &amp;&amp; (e = t.value);\n    return e;\n  }\n}\nJn.create = (s) =&gt; new Jn({\n  checks: [],\n  typeName: ke.ZodBigInt,\n  coerce: (s == null ? void 0 : s.coerce) ?? !1,\n  ...Ve(s)\n});\nclass Hl extends Ye {\n  _parse(e) {\n    if (this._def.coerce &amp;&amp; (e.data = !!e.data), this._getType(e) !== me.boolean) {\n      const r = this._getOrReturnCtx(e);\n      return he(r, {\n        code: ae.invalid_type,\n        expected: me.boolean,\n        received: r.parsedType\n      }), Re;\n    }\n    return Rr(e.data);\n  }\n}\nHl.create = (s) =&gt; new Hl({\n  typeName: ke.ZodBoolean,\n  coerce: (s == null ? void 0 : s.coerce) || !1,\n  ...Ve(s)\n});\nclass To extends Ye {\n  _parse(e) {\n    if (this._def.coerce &amp;&amp; (e.data = new Date(e.data)), this._getType(e) !== me.date) {\n      const i = this._getOrReturnCtx(e);\n      return he(i, {\n        code: ae.invalid_type,\n        expected: me.date,\n        received: i.parsedType\n      }), Re;\n    }\n    if (Number.isNaN(e.data.getTime())) {\n      const i = this._getOrReturnCtx(e);\n      return he(i, {\n        code: ae.invalid_date\n      }), Re;\n    }\n    const r = new wr();\n    let n;\n    for (const i of this._def.checks)\n      i.kind === \"min\" ? e.data.getTime() &lt; i.value &amp;&amp; (n = this._getOrReturnCtx(e, n), he(n, {\n        code: ae.too_small,\n        message: i.message,\n        inclusive: !0,\n        exact: !1,\n        minimum: i.value,\n        type: \"date\"\n      }), r.dirty()) : i.kind === \"max\" ? e.data.getTime() &gt; i.value &amp;&amp; (n = this._getOrReturnCtx(e, n), he(n, {\n        code: ae.too_big,\n        message: i.message,\n        inclusive: !0,\n        exact: !1,\n        maximum: i.value,\n        type: \"date\"\n      }), r.dirty()) : Ze.assertNever(i);\n    return {\n      status: r.value,\n      value: new Date(e.data.getTime())\n    };\n  }\n  _addCheck(e) {\n    return new To({\n      ...this._def,\n      checks: [...this._def.checks, e]\n    });\n  }\n  min(e, t) {\n    return this._addCheck({\n      kind: \"min\",\n      value: e.getTime(),\n      message: Ee.toString(t)\n    });\n  }\n  max(e, t) {\n    return this._addCheck({\n      kind: \"max\",\n      value: e.getTime(),\n      message: Ee.toString(t)\n    });\n  }\n  get minDate() {\n    let e = null;\n    for (const t of this._def.checks)\n      t.kind === \"min\" &amp;&amp; (e === null || t.value &gt; e) &amp;&amp; (e = t.value);\n    return e != null ? new Date(e) : null;\n  }\n  get maxDate() {\n    let e = null;\n    for (const t of this._def.checks)\n      t.kind === \"max\" &amp;&amp; (e === null || t.value &lt; e) &amp;&amp; (e = t.value);\n    return e != null ? new Date(e) : null;\n  }\n}\nTo.create = (s) =&gt; new To({\n  checks: [],\n  coerce: (s == null ? void 0 : s.coerce) || !1,\n  typeName: ke.ZodDate,\n  ...Ve(s)\n});\nclass Qu extends Ye {\n  _parse(e) {\n    if (this._getType(e) !== me.symbol) {\n      const r = this._getOrReturnCtx(e);\n      return he(r, {\n        code: ae.invalid_type,\n        expected: me.symbol,\n        received: r.parsedType\n      }), Re;\n    }\n    return Rr(e.data);\n  }\n}\nQu.create = (s) =&gt; new Qu({\n  typeName: ke.ZodSymbol,\n  ...Ve(s)\n});\nclass ql extends Ye {\n  _parse(e) {\n    if (this._getType(e) !== me.undefined) {\n      const r = this._getOrReturnCtx(e);\n      return he(r, {\n        code: ae.invalid_type,\n        expected: me.undefined,\n        received: r.parsedType\n      }), Re;\n    }\n    return Rr(e.data);\n  }\n}\nql.create = (s) =&gt; new ql({\n  typeName: ke.ZodUndefined,\n  ...Ve(s)\n});\nclass Wl extends Ye {\n  _parse(e) {\n    if (this._getType(e) !== me.null) {\n      const r = this._getOrReturnCtx(e);\n      return he(r, {\n        code: ae.invalid_type,\n        expected: me.null,\n        received: r.parsedType\n      }), Re;\n    }\n    return Rr(e.data);\n  }\n}\nWl.create = (s) =&gt; new Wl({\n  typeName: ke.ZodNull,\n  ...Ve(s)\n});\nclass ed extends Ye {\n  constructor() {\n    super(...arguments), this._any = !0;\n  }\n  _parse(e) {\n    return Rr(e.data);\n  }\n}\ned.create = (s) =&gt; new ed({\n  typeName: ke.ZodAny,\n  ...Ve(s)\n});\nclass td extends Ye {\n  constructor() {\n    super(...arguments), this._unknown = !0;\n  }\n  _parse(e) {\n    return Rr(e.data);\n  }\n}\ntd.create = (s) =&gt; new td({\n  typeName: ke.ZodUnknown,\n  ...Ve(s)\n});\nclass Ps extends Ye {\n  _parse(e) {\n    const t = this._getOrReturnCtx(e);\n    return he(t, {\n      code: ae.invalid_type,\n      expected: me.never,\n      received: t.parsedType\n    }), Re;\n  }\n}\nPs.create = (s) =&gt; new Ps({\n  typeName: ke.ZodNever,\n  ...Ve(s)\n});\nclass rd extends Ye {\n  _parse(e) {\n    if (this._getType(e) !== me.undefined) {\n      const r = this._getOrReturnCtx(e);\n      return he(r, {\n        code: ae.invalid_type,\n        expected: me.void,\n        received: r.parsedType\n      }), Re;\n    }\n    return Rr(e.data);\n  }\n}\nrd.create = (s) =&gt; new rd({\n  typeName: ke.ZodVoid,\n  ...Ve(s)\n});\nclass Yr extends Ye {\n  _parse(e) {\n    const { ctx: t, status: r } = this._processInputParams(e), n = this._def;\n    if (t.parsedType !== me.array)\n      return he(t, {\n        code: ae.invalid_type,\n        expected: me.array,\n        received: t.parsedType\n      }), Re;\n    if (n.exactLength !== null) {\n      const o = t.data.length &gt; n.exactLength.value, a = t.data.length &lt; n.exactLength.value;\n      (o || a) &amp;&amp; (he(t, {\n        code: o ? ae.too_big : ae.too_small,\n        minimum: a ? n.exactLength.value : void 0,\n        maximum: o ? n.exactLength.value : void 0,\n        type: \"array\",\n        inclusive: !0,\n        exact: !0,\n        message: n.exactLength.message\n      }), r.dirty());\n    }\n    if (n.minLength !== null &amp;&amp; t.data.length &lt; n.minLength.value &amp;&amp; (he(t, {\n      code: ae.too_small,\n      minimum: n.minLength.value,\n      type: \"array\",\n      inclusive: !0,\n      exact: !1,\n      message: n.minLength.message\n    }), r.dirty()), n.maxLength !== null &amp;&amp; t.data.length &gt; n.maxLength.value &amp;&amp; (he(t, {\n      code: ae.too_big,\n      maximum: n.maxLength.value,\n      type: \"array\",\n      inclusive: !0,\n      exact: !1,\n      message: n.maxLength.message\n    }), r.dirty()), t.common.async)\n      return Promise.all([...t.data].map((o, a) =&gt; n.type._parseAsync(new Ds(t, o, t.path, a)))).then((o) =&gt; wr.mergeArray(r, o));\n    const i = [...t.data].map((o, a) =&gt; n.type._parseSync(new Ds(t, o, t.path, a)));\n    return wr.mergeArray(r, i);\n  }\n  get element() {\n    return this._def.type;\n  }\n  min(e, t) {\n    return new Yr({\n      ...this._def,\n      minLength: { value: e, message: Ee.toString(t) }\n    });\n  }\n  max(e, t) {\n    return new Yr({\n      ...this._def,\n      maxLength: { value: e, message: Ee.toString(t) }\n    });\n  }\n  length(e, t) {\n    return new Yr({\n      ...this._def,\n      exactLength: { value: e, message: Ee.toString(t) }\n    });\n  }\n  nonempty(e) {\n    return this.min(1, e);\n  }\n}\nYr.create = (s, e) =&gt; new Yr({\n  type: s,\n  minLength: null,\n  maxLength: null,\n  exactLength: null,\n  typeName: ke.ZodArray,\n  ...Ve(e)\n});\nfunction mn(s) {\n  if (s instanceof $t) {\n    const e = {};\n    for (const t in s.shape) {\n      const r = s.shape[t];\n      e[t] = fs.create(mn(r));\n    }\n    return new $t({\n      ...s._def,\n      shape: () =&gt; e\n    });\n  } else return s instanceof Yr ? new Yr({\n    ...s._def,\n    type: mn(s.element)\n  }) : s instanceof fs ? fs.create(mn(s.unwrap())) : s instanceof Zs ? Zs.create(mn(s.unwrap())) : s instanceof Ws ? Ws.create(s.items.map((e) =&gt; mn(e))) : s;\n}\nclass $t extends Ye {\n  constructor() {\n    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;\n  }\n  _getCached() {\n    if (this._cached !== null)\n      return this._cached;\n    const e = this._def.shape(), t = Ze.objectKeys(e);\n    return this._cached = { shape: e, keys: t }, this._cached;\n  }\n  _parse(e) {\n    if (this._getType(e) !== me.object) {\n      const c = this._getOrReturnCtx(e);\n      return he(c, {\n        code: ae.invalid_type,\n        expected: me.object,\n        received: c.parsedType\n      }), Re;\n    }\n    const { status: r, ctx: n } = this._processInputParams(e), { shape: i, keys: o } = this._getCached(), a = [];\n    if (!(this._def.catchall instanceof Ps &amp;&amp; this._def.unknownKeys === \"strip\"))\n      for (const c in n.data)\n        o.includes(c) || a.push(c);\n    const l = [];\n    for (const c of o) {\n      const u = i[c], d = n.data[c];\n      l.push({\n        key: { status: \"valid\", value: c },\n        value: u._parse(new Ds(n, d, n.path, c)),\n        alwaysSet: c in n.data\n      });\n    }\n    if (this._def.catchall instanceof Ps) {\n      const c = this._def.unknownKeys;\n      if (c === \"passthrough\")\n        for (const u of a)\n          l.push({\n            key: { status: \"valid\", value: u },\n            value: { status: \"valid\", value: n.data[u] }\n          });\n      else if (c === \"strict\")\n        a.length &gt; 0 &amp;&amp; (he(n, {\n          code: ae.unrecognized_keys,\n          keys: a\n        }), r.dirty());\n      else if (c !== \"strip\") throw new Error(\"Internal ZodObject error: invalid unknownKeys value.\");\n    } else {\n      const c = this._def.catchall;\n      for (const u of a) {\n        const d = n.data[u];\n        l.push({\n          key: { status: \"valid\", value: u },\n          value: c._parse(\n            new Ds(n, d, n.path, u)\n            //, ctx.child(key), value, getParsedType(value)\n          ),\n          alwaysSet: u in n.data\n        });\n      }\n    }\n    return n.common.async ? Promise.resolve().then(async () =&gt; {\n      const c = [];\n      for (const u of l) {\n        const d = await u.key, h = await u.value;\n        c.push({\n          key: d,\n          value: h,\n          alwaysSet: u.alwaysSet\n        });\n      }\n      return c;\n    }).then((c) =&gt; wr.mergeObjectSync(r, c)) : wr.mergeObjectSync(r, l);\n  }\n  get shape() {\n    return this._def.shape();\n  }\n  strict(e) {\n    return Ee.errToObj, new $t({\n      ...this._def,\n      unknownKeys: \"strict\",\n      ...e !== void 0 ? {\n        errorMap: (t, r) =&gt; {\n          var i, o;\n          const n = ((o = (i = this._def).errorMap) == null ? void 0 : o.call(i, t, r).message) ?? r.defaultError;\n          return t.code === \"unrecognized_keys\" ? {\n            message: Ee.errToObj(e).message ?? n\n          } : {\n            message: n\n          };\n        }\n      } : {}\n    });\n  }\n  strip() {\n    return new $t({\n      ...this._def,\n      unknownKeys: \"strip\"\n    });\n  }\n  passthrough() {\n    return new $t({\n      ...this._def,\n      unknownKeys: \"passthrough\"\n    });\n  }\n  // const AugmentFactory =\n  //   &lt;Def extends ZodObjectDef&gt;(def: Def) =&gt;\n  //   &lt;Augmentation extends ZodRawShape&gt;(\n  //     augmentation: Augmentation\n  //   ): ZodObject&lt;\n  //     extendShape&lt;ReturnType&lt;Def[\"shape\"]&gt;, Augmentation&gt;,\n  //     Def[\"unknownKeys\"],\n  //     Def[\"catchall\"]\n  //   &gt; =&gt; {\n  //     return new ZodObject({\n  //       ...def,\n  //       shape: () =&gt; ({\n  //         ...def.shape(),\n  //         ...augmentation,\n  //       }),\n  //     }) as any;\n  //   };\n  extend(e) {\n    return new $t({\n      ...this._def,\n      shape: () =&gt; ({\n        ...this._def.shape(),\n        ...e\n      })\n    });\n  }\n  /**\n   * Prior to zod@1.0.12 there was a bug in the\n   * inferred type of merged objects. Please\n   * upgrade if you are experiencing issues.\n   */\n  merge(e) {\n    return new $t({\n      unknownKeys: e._def.unknownKeys,\n      catchall: e._def.catchall,\n      shape: () =&gt; ({\n        ...this._def.shape(),\n        ...e._def.shape()\n      }),\n      typeName: ke.ZodObject\n    });\n  }\n  // merge&lt;\n  //   Incoming extends AnyZodObject,\n  //   Augmentation extends Incoming[\"shape\"],\n  //   NewOutput extends {\n  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_output\"]\n  //       : k extends keyof Output\n  //       ? Output[k]\n  //       : never;\n  //   },\n  //   NewInput extends {\n  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation\n  //       ? Augmentation[k][\"_input\"]\n  //       : k extends keyof Input\n  //       ? Input[k]\n  //       : never;\n  //   }\n  // &gt;(\n  //   merging: Incoming\n  // ): ZodObject&lt;\n  //   extendShape&lt;T, ReturnType&lt;Incoming[\"_def\"][\"shape\"]&gt;&gt;,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"],\n  //   NewOutput,\n  //   NewInput\n  // &gt; {\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =&gt;\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n  setKey(e, t) {\n    return this.augment({ [e]: t });\n  }\n  // merge&lt;Incoming extends AnyZodObject&gt;(\n  //   merging: Incoming\n  // ): //ZodObject&lt;T &amp; Incoming[\"_shape\"], UnknownKeys, Catchall&gt; = (merging) =&gt; {\n  // ZodObject&lt;\n  //   extendShape&lt;T, ReturnType&lt;Incoming[\"_def\"][\"shape\"]&gt;&gt;,\n  //   Incoming[\"_def\"][\"unknownKeys\"],\n  //   Incoming[\"_def\"][\"catchall\"]\n  // &gt; {\n  //   // const mergedShape = objectUtil.mergeShapes(\n  //   //   this._def.shape(),\n  //   //   merging._def.shape()\n  //   // );\n  //   const merged: any = new ZodObject({\n  //     unknownKeys: merging._def.unknownKeys,\n  //     catchall: merging._def.catchall,\n  //     shape: () =&gt;\n  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n  //     typeName: ZodFirstPartyTypeKind.ZodObject,\n  //   }) as any;\n  //   return merged;\n  // }\n  catchall(e) {\n    return new $t({\n      ...this._def,\n      catchall: e\n    });\n  }\n  pick(e) {\n    const t = {};\n    for (const r of Ze.objectKeys(e))\n      e[r] &amp;&amp; this.shape[r] &amp;&amp; (t[r] = this.shape[r]);\n    return new $t({\n      ...this._def,\n      shape: () =&gt; t\n    });\n  }\n  omit(e) {\n    const t = {};\n    for (const r of Ze.objectKeys(this.shape))\n      e[r] || (t[r] = this.shape[r]);\n    return new $t({\n      ...this._def,\n      shape: () =&gt; t\n    });\n  }\n  /**\n   * @deprecated\n   */\n  deepPartial() {\n    return mn(this);\n  }\n  partial(e) {\n    const t = {};\n    for (const r of Ze.objectKeys(this.shape)) {\n      const n = this.shape[r];\n      e &amp;&amp; !e[r] ? t[r] = n : t[r] = n.optional();\n    }\n    return new $t({\n      ...this._def,\n      shape: () =&gt; t\n    });\n  }\n  required(e) {\n    const t = {};\n    for (const r of Ze.objectKeys(this.shape))\n      if (e &amp;&amp; !e[r])\n        t[r] = this.shape[r];\n      else {\n        let i = this.shape[r];\n        for (; i instanceof fs; )\n          i = i._def.innerType;\n        t[r] = i;\n      }\n    return new $t({\n      ...this._def,\n      shape: () =&gt; t\n    });\n  }\n  keyof() {\n    return Nf(Ze.objectKeys(this.shape));\n  }\n}\n$t.create = (s, e) =&gt; new $t({\n  shape: () =&gt; s,\n  unknownKeys: \"strip\",\n  catchall: Ps.create(),\n  typeName: ke.ZodObject,\n  ...Ve(e)\n});\n$t.strictCreate = (s, e) =&gt; new $t({\n  shape: () =&gt; s,\n  unknownKeys: \"strict\",\n  catchall: Ps.create(),\n  typeName: ke.ZodObject,\n  ...Ve(e)\n});\n$t.lazycreate = (s, e) =&gt; new $t({\n  shape: s,\n  unknownKeys: \"strip\",\n  catchall: Ps.create(),\n  typeName: ke.ZodObject,\n  ...Ve(e)\n});\nclass wo extends Ye {\n  _parse(e) {\n    const { ctx: t } = this._processInputParams(e), r = this._def.options;\n    function n(i) {\n      for (const a of i)\n        if (a.result.status === \"valid\")\n          return a.result;\n      for (const a of i)\n        if (a.result.status === \"dirty\")\n          return t.common.issues.push(...a.ctx.common.issues), a.result;\n      const o = i.map((a) =&gt; new ps(a.ctx.common.issues));\n      return he(t, {\n        code: ae.invalid_union,\n        unionErrors: o\n      }), Re;\n    }\n    if (t.common.async)\n      return Promise.all(r.map(async (i) =&gt; {\n        const o = {\n          ...t,\n          common: {\n            ...t.common,\n            issues: []\n          },\n          parent: null\n        };\n        return {\n          result: await i._parseAsync({\n            data: t.data,\n            path: t.path,\n            parent: o\n          }),\n          ctx: o\n        };\n      })).then(n);\n    {\n      let i;\n      const o = [];\n      for (const l of r) {\n        const c = {\n          ...t,\n          common: {\n            ...t.common,\n            issues: []\n          },\n          parent: null\n        }, u = l._parseSync({\n          data: t.data,\n          path: t.path,\n          parent: c\n        });\n        if (u.status === \"valid\")\n          return u;\n        u.status === \"dirty\" &amp;&amp; !i &amp;&amp; (i = { result: u, ctx: c }), c.common.issues.length &amp;&amp; o.push(c.common.issues);\n      }\n      if (i)\n        return t.common.issues.push(...i.ctx.common.issues), i.result;\n      const a = o.map((l) =&gt; new ps(l));\n      return he(t, {\n        code: ae.invalid_union,\n        unionErrors: a\n      }), Re;\n    }\n  }\n  get options() {\n    return this._def.options;\n  }\n}\nwo.create = (s, e) =&gt; new wo({\n  options: s,\n  typeName: ke.ZodUnion,\n  ...Ve(e)\n});\nconst os = (s) =&gt; s instanceof Yl ? os(s.schema) : s instanceof Ys ? os(s.innerType()) : s instanceof Io ? [s.value] : s instanceof zs ? s.options : s instanceof Zl ? Ze.objectValues(s.enum) : s instanceof Ro ? os(s._def.innerType) : s instanceof ql ? [void 0] : s instanceof Wl ? [null] : s instanceof fs ? [void 0, ...os(s.unwrap())] : s instanceof Zs ? [null, ...os(s.unwrap())] : s instanceof Uf || s instanceof Co ? os(s.unwrap()) : s instanceof Lo ? os(s._def.innerType) : [];\nclass Uc extends Ye {\n  _parse(e) {\n    const { ctx: t } = this._processInputParams(e);\n    if (t.parsedType !== me.object)\n      return he(t, {\n        code: ae.invalid_type,\n        expected: me.object,\n        received: t.parsedType\n      }), Re;\n    const r = this.discriminator, n = t.data[r], i = this.optionsMap.get(n);\n    return i ? t.common.async ? i._parseAsync({\n      data: t.data,\n      path: t.path,\n      parent: t\n    }) : i._parseSync({\n      data: t.data,\n      path: t.path,\n      parent: t\n    }) : (he(t, {\n      code: ae.invalid_union_discriminator,\n      options: Array.from(this.optionsMap.keys()),\n      path: [r]\n    }), Re);\n  }\n  get discriminator() {\n    return this._def.discriminator;\n  }\n  get options() {\n    return this._def.options;\n  }\n  get optionsMap() {\n    return this._def.optionsMap;\n  }\n  /**\n   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n   * have a different value for each object in the union.\n   * @param discriminator the name of the discriminator property\n   * @param types an array of object schemas\n   * @param params\n   */\n  static create(e, t, r) {\n    const n = /* @__PURE__ */ new Map();\n    for (const i of t) {\n      const o = os(i.shape[e]);\n      if (!o.length)\n        throw new Error(`A discriminator value for key \\`${e}\\` could not be extracted from all schema options`);\n      for (const a of o) {\n        if (n.has(a))\n          throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(a)}`);\n        n.set(a, i);\n      }\n    }\n    return new Uc({\n      typeName: ke.ZodDiscriminatedUnion,\n      discriminator: e,\n      options: t,\n      optionsMap: n,\n      ...Ve(r)\n    });\n  }\n}\nfunction zl(s, e) {\n  const t = ws(s), r = ws(e);\n  if (s === e)\n    return { valid: !0, data: s };\n  if (t === me.object &amp;&amp; r === me.object) {\n    const n = Ze.objectKeys(e), i = Ze.objectKeys(s).filter((a) =&gt; n.indexOf(a) !== -1), o = { ...s, ...e };\n    for (const a of i) {\n      const l = zl(s[a], e[a]);\n      if (!l.valid)\n        return { valid: !1 };\n      o[a] = l.data;\n    }\n    return { valid: !0, data: o };\n  } else if (t === me.array &amp;&amp; r === me.array) {\n    if (s.length !== e.length)\n      return { valid: !1 };\n    const n = [];\n    for (let i = 0; i &lt; s.length; i++) {\n      const o = s[i], a = e[i], l = zl(o, a);\n      if (!l.valid)\n        return { valid: !1 };\n      n.push(l.data);\n    }\n    return { valid: !0, data: n };\n  } else return t === me.date &amp;&amp; r === me.date &amp;&amp; +s == +e ? { valid: !0, data: s } : { valid: !1 };\n}\nclass Ao extends Ye {\n  _parse(e) {\n    const { status: t, ctx: r } = this._processInputParams(e), n = (i, o) =&gt; {\n      if (Zu(i) || Zu(o))\n        return Re;\n      const a = zl(i.value, o.value);\n      return a.valid ? ((Xu(i) || Xu(o)) &amp;&amp; t.dirty(), { status: t.value, value: a.data }) : (he(r, {\n        code: ae.invalid_intersection_types\n      }), Re);\n    };\n    return r.common.async ? Promise.all([\n      this._def.left._parseAsync({\n        data: r.data,\n        path: r.path,\n        parent: r\n      }),\n      this._def.right._parseAsync({\n        data: r.data,\n        path: r.path,\n        parent: r\n      })\n    ]).then(([i, o]) =&gt; n(i, o)) : n(this._def.left._parseSync({\n      data: r.data,\n      path: r.path,\n      parent: r\n    }), this._def.right._parseSync({\n      data: r.data,\n      path: r.path,\n      parent: r\n    }));\n  }\n}\nAo.create = (s, e, t) =&gt; new Ao({\n  left: s,\n  right: e,\n  typeName: ke.ZodIntersection,\n  ...Ve(t)\n});\nclass Ws extends Ye {\n  _parse(e) {\n    const { status: t, ctx: r } = this._processInputParams(e);\n    if (r.parsedType !== me.array)\n      return he(r, {\n        code: ae.invalid_type,\n        expected: me.array,\n        received: r.parsedType\n      }), Re;\n    if (r.data.length &lt; this._def.items.length)\n      return he(r, {\n        code: ae.too_small,\n        minimum: this._def.items.length,\n        inclusive: !0,\n        exact: !1,\n        type: \"array\"\n      }), Re;\n    !this._def.rest &amp;&amp; r.data.length &gt; this._def.items.length &amp;&amp; (he(r, {\n      code: ae.too_big,\n      maximum: this._def.items.length,\n      inclusive: !0,\n      exact: !1,\n      type: \"array\"\n    }), t.dirty());\n    const i = [...r.data].map((o, a) =&gt; {\n      const l = this._def.items[a] || this._def.rest;\n      return l ? l._parse(new Ds(r, o, r.path, a)) : null;\n    }).filter((o) =&gt; !!o);\n    return r.common.async ? Promise.all(i).then((o) =&gt; wr.mergeArray(t, o)) : wr.mergeArray(t, i);\n  }\n  get items() {\n    return this._def.items;\n  }\n  rest(e) {\n    return new Ws({\n      ...this._def,\n      rest: e\n    });\n  }\n}\nWs.create = (s, e) =&gt; {\n  if (!Array.isArray(s))\n    throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n  return new Ws({\n    items: s,\n    typeName: ke.ZodTuple,\n    rest: null,\n    ...Ve(e)\n  });\n};\nclass sd extends Ye {\n  get keySchema() {\n    return this._def.keyType;\n  }\n  get valueSchema() {\n    return this._def.valueType;\n  }\n  _parse(e) {\n    const { status: t, ctx: r } = this._processInputParams(e);\n    if (r.parsedType !== me.map)\n      return he(r, {\n        code: ae.invalid_type,\n        expected: me.map,\n        received: r.parsedType\n      }), Re;\n    const n = this._def.keyType, i = this._def.valueType, o = [...r.data.entries()].map(([a, l], c) =&gt; ({\n      key: n._parse(new Ds(r, a, r.path, [c, \"key\"])),\n      value: i._parse(new Ds(r, l, r.path, [c, \"value\"]))\n    }));\n    if (r.common.async) {\n      const a = /* @__PURE__ */ new Map();\n      return Promise.resolve().then(async () =&gt; {\n        for (const l of o) {\n          const c = await l.key, u = await l.value;\n          if (c.status === \"aborted\" || u.status === \"aborted\")\n            return Re;\n          (c.status === \"dirty\" || u.status === \"dirty\") &amp;&amp; t.dirty(), a.set(c.value, u.value);\n        }\n        return { status: t.value, value: a };\n      });\n    } else {\n      const a = /* @__PURE__ */ new Map();\n      for (const l of o) {\n        const c = l.key, u = l.value;\n        if (c.status === \"aborted\" || u.status === \"aborted\")\n          return Re;\n        (c.status === \"dirty\" || u.status === \"dirty\") &amp;&amp; t.dirty(), a.set(c.value, u.value);\n      }\n      return { status: t.value, value: a };\n    }\n  }\n}\nsd.create = (s, e, t) =&gt; new sd({\n  valueType: e,\n  keyType: s,\n  typeName: ke.ZodMap,\n  ...Ve(t)\n});\nclass Qn extends Ye {\n  _parse(e) {\n    const { status: t, ctx: r } = this._processInputParams(e);\n    if (r.parsedType !== me.set)\n      return he(r, {\n        code: ae.invalid_type,\n        expected: me.set,\n        received: r.parsedType\n      }), Re;\n    const n = this._def;\n    n.minSize !== null &amp;&amp; r.data.size &lt; n.minSize.value &amp;&amp; (he(r, {\n      code: ae.too_small,\n      minimum: n.minSize.value,\n      type: \"set\",\n      inclusive: !0,\n      exact: !1,\n      message: n.minSize.message\n    }), t.dirty()), n.maxSize !== null &amp;&amp; r.data.size &gt; n.maxSize.value &amp;&amp; (he(r, {\n      code: ae.too_big,\n      maximum: n.maxSize.value,\n      type: \"set\",\n      inclusive: !0,\n      exact: !1,\n      message: n.maxSize.message\n    }), t.dirty());\n    const i = this._def.valueType;\n    function o(l) {\n      const c = /* @__PURE__ */ new Set();\n      for (const u of l) {\n        if (u.status === \"aborted\")\n          return Re;\n        u.status === \"dirty\" &amp;&amp; t.dirty(), c.add(u.value);\n      }\n      return { status: t.value, value: c };\n    }\n    const a = [...r.data.values()].map((l, c) =&gt; i._parse(new Ds(r, l, r.path, c)));\n    return r.common.async ? Promise.all(a).then((l) =&gt; o(l)) : o(a);\n  }\n  min(e, t) {\n    return new Qn({\n      ...this._def,\n      minSize: { value: e, message: Ee.toString(t) }\n    });\n  }\n  max(e, t) {\n    return new Qn({\n      ...this._def,\n      maxSize: { value: e, message: Ee.toString(t) }\n    });\n  }\n  size(e, t) {\n    return this.min(e, t).max(e, t);\n  }\n  nonempty(e) {\n    return this.min(1, e);\n  }\n}\nQn.create = (s, e) =&gt; new Qn({\n  valueType: s,\n  minSize: null,\n  maxSize: null,\n  typeName: ke.ZodSet,\n  ...Ve(e)\n});\nclass Yl extends Ye {\n  get schema() {\n    return this._def.getter();\n  }\n  _parse(e) {\n    const { ctx: t } = this._processInputParams(e);\n    return this._def.getter()._parse({ data: t.data, path: t.path, parent: t });\n  }\n}\nYl.create = (s, e) =&gt; new Yl({\n  getter: s,\n  typeName: ke.ZodLazy,\n  ...Ve(e)\n});\nclass Io extends Ye {\n  _parse(e) {\n    if (e.data !== this._def.value) {\n      const t = this._getOrReturnCtx(e);\n      return he(t, {\n        received: t.data,\n        code: ae.invalid_literal,\n        expected: this._def.value\n      }), Re;\n    }\n    return { status: \"valid\", value: e.data };\n  }\n  get value() {\n    return this._def.value;\n  }\n}\nIo.create = (s, e) =&gt; new Io({\n  value: s,\n  typeName: ke.ZodLiteral,\n  ...Ve(e)\n});\nfunction Nf(s, e) {\n  return new zs({\n    values: s,\n    typeName: ke.ZodEnum,\n    ...Ve(e)\n  });\n}\nclass zs extends Ye {\n  _parse(e) {\n    if (typeof e.data != \"string\") {\n      const t = this._getOrReturnCtx(e), r = this._def.values;\n      return he(t, {\n        expected: Ze.joinValues(r),\n        received: t.parsedType,\n        code: ae.invalid_type\n      }), Re;\n    }\n    if (this._cache || (this._cache = new Set(this._def.values)), !this._cache.has(e.data)) {\n      const t = this._getOrReturnCtx(e), r = this._def.values;\n      return he(t, {\n        received: t.data,\n        code: ae.invalid_enum_value,\n        options: r\n      }), Re;\n    }\n    return Rr(e.data);\n  }\n  get options() {\n    return this._def.values;\n  }\n  get enum() {\n    const e = {};\n    for (const t of this._def.values)\n      e[t] = t;\n    return e;\n  }\n  get Values() {\n    const e = {};\n    for (const t of this._def.values)\n      e[t] = t;\n    return e;\n  }\n  get Enum() {\n    const e = {};\n    for (const t of this._def.values)\n      e[t] = t;\n    return e;\n  }\n  extract(e, t = this._def) {\n    return zs.create(e, {\n      ...this._def,\n      ...t\n    });\n  }\n  exclude(e, t = this._def) {\n    return zs.create(this.options.filter((r) =&gt; !e.includes(r)), {\n      ...this._def,\n      ...t\n    });\n  }\n}\nzs.create = Nf;\nclass Zl extends Ye {\n  _parse(e) {\n    const t = Ze.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(e);\n    if (r.parsedType !== me.string &amp;&amp; r.parsedType !== me.number) {\n      const n = Ze.objectValues(t);\n      return he(r, {\n        expected: Ze.joinValues(n),\n        received: r.parsedType,\n        code: ae.invalid_type\n      }), Re;\n    }\n    if (this._cache || (this._cache = new Set(Ze.getValidEnumValues(this._def.values))), !this._cache.has(e.data)) {\n      const n = Ze.objectValues(t);\n      return he(r, {\n        received: r.data,\n        code: ae.invalid_enum_value,\n        options: n\n      }), Re;\n    }\n    return Rr(e.data);\n  }\n  get enum() {\n    return this._def.values;\n  }\n}\nZl.create = (s, e) =&gt; new Zl({\n  values: s,\n  typeName: ke.ZodNativeEnum,\n  ...Ve(e)\n});\nclass _o extends Ye {\n  unwrap() {\n    return this._def.type;\n  }\n  _parse(e) {\n    const { ctx: t } = this._processInputParams(e);\n    if (t.parsedType !== me.promise &amp;&amp; t.common.async === !1)\n      return he(t, {\n        code: ae.invalid_type,\n        expected: me.promise,\n        received: t.parsedType\n      }), Re;\n    const r = t.parsedType === me.promise ? t.data : Promise.resolve(t.data);\n    return Rr(r.then((n) =&gt; this._def.type.parseAsync(n, {\n      path: t.path,\n      errorMap: t.common.contextualErrorMap\n    })));\n  }\n}\n_o.create = (s, e) =&gt; new _o({\n  type: s,\n  typeName: ke.ZodPromise,\n  ...Ve(e)\n});\nclass Ys extends Ye {\n  innerType() {\n    return this._def.schema;\n  }\n  sourceType() {\n    return this._def.schema._def.typeName === ke.ZodEffects ? this._def.schema.sourceType() : this._def.schema;\n  }\n  _parse(e) {\n    const { status: t, ctx: r } = this._processInputParams(e), n = this._def.effect || null, i = {\n      addIssue: (o) =&gt; {\n        he(r, o), o.fatal ? t.abort() : t.dirty();\n      },\n      get path() {\n        return r.path;\n      }\n    };\n    if (i.addIssue = i.addIssue.bind(i), n.type === \"preprocess\") {\n      const o = n.transform(r.data, i);\n      if (r.common.async)\n        return Promise.resolve(o).then(async (a) =&gt; {\n          if (t.value === \"aborted\")\n            return Re;\n          const l = await this._def.schema._parseAsync({\n            data: a,\n            path: r.path,\n            parent: r\n          });\n          return l.status === \"aborted\" ? Re : l.status === \"dirty\" || t.value === \"dirty\" ? Wn(l.value) : l;\n        });\n      {\n        if (t.value === \"aborted\")\n          return Re;\n        const a = this._def.schema._parseSync({\n          data: o,\n          path: r.path,\n          parent: r\n        });\n        return a.status === \"aborted\" ? Re : a.status === \"dirty\" || t.value === \"dirty\" ? Wn(a.value) : a;\n      }\n    }\n    if (n.type === \"refinement\") {\n      const o = (a) =&gt; {\n        const l = n.refinement(a, i);\n        if (r.common.async)\n          return Promise.resolve(l);\n        if (l instanceof Promise)\n          throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n        return a;\n      };\n      if (r.common.async === !1) {\n        const a = this._def.schema._parseSync({\n          data: r.data,\n          path: r.path,\n          parent: r\n        });\n        return a.status === \"aborted\" ? Re : (a.status === \"dirty\" &amp;&amp; t.dirty(), o(a.value), { status: t.value, value: a.value });\n      } else\n        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((a) =&gt; a.status === \"aborted\" ? Re : (a.status === \"dirty\" &amp;&amp; t.dirty(), o(a.value).then(() =&gt; ({ status: t.value, value: a.value }))));\n    }\n    if (n.type === \"transform\")\n      if (r.common.async === !1) {\n        const o = this._def.schema._parseSync({\n          data: r.data,\n          path: r.path,\n          parent: r\n        });\n        if (!Ln(o))\n          return Re;\n        const a = n.transform(o.value, i);\n        if (a instanceof Promise)\n          throw new Error(\"Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.\");\n        return { status: t.value, value: a };\n      } else\n        return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then((o) =&gt; Ln(o) ? Promise.resolve(n.transform(o.value, i)).then((a) =&gt; ({\n          status: t.value,\n          value: a\n        })) : Re);\n    Ze.assertNever(n);\n  }\n}\nYs.create = (s, e, t) =&gt; new Ys({\n  schema: s,\n  typeName: ke.ZodEffects,\n  effect: e,\n  ...Ve(t)\n});\nYs.createWithPreprocess = (s, e, t) =&gt; new Ys({\n  schema: e,\n  effect: { type: \"preprocess\", transform: s },\n  typeName: ke.ZodEffects,\n  ...Ve(t)\n});\nclass fs extends Ye {\n  _parse(e) {\n    return this._getType(e) === me.undefined ? Rr(void 0) : this._def.innerType._parse(e);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n}\nfs.create = (s, e) =&gt; new fs({\n  innerType: s,\n  typeName: ke.ZodOptional,\n  ...Ve(e)\n});\nclass Zs extends Ye {\n  _parse(e) {\n    return this._getType(e) === me.null ? Rr(null) : this._def.innerType._parse(e);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n}\nZs.create = (s, e) =&gt; new Zs({\n  innerType: s,\n  typeName: ke.ZodNullable,\n  ...Ve(e)\n});\nclass Ro extends Ye {\n  _parse(e) {\n    const { ctx: t } = this._processInputParams(e);\n    let r = t.data;\n    return t.parsedType === me.undefined &amp;&amp; (r = this._def.defaultValue()), this._def.innerType._parse({\n      data: r,\n      path: t.path,\n      parent: t\n    });\n  }\n  removeDefault() {\n    return this._def.innerType;\n  }\n}\nRo.create = (s, e) =&gt; new Ro({\n  innerType: s,\n  typeName: ke.ZodDefault,\n  defaultValue: typeof e.default == \"function\" ? e.default : () =&gt; e.default,\n  ...Ve(e)\n});\nclass Lo extends Ye {\n  _parse(e) {\n    const { ctx: t } = this._processInputParams(e), r = {\n      ...t,\n      common: {\n        ...t.common,\n        issues: []\n      }\n    }, n = this._def.innerType._parse({\n      data: r.data,\n      path: r.path,\n      parent: {\n        ...r\n      }\n    });\n    return bo(n) ? n.then((i) =&gt; ({\n      status: \"valid\",\n      value: i.status === \"valid\" ? i.value : this._def.catchValue({\n        get error() {\n          return new ps(r.common.issues);\n        },\n        input: r.data\n      })\n    })) : {\n      status: \"valid\",\n      value: n.status === \"valid\" ? n.value : this._def.catchValue({\n        get error() {\n          return new ps(r.common.issues);\n        },\n        input: r.data\n      })\n    };\n  }\n  removeCatch() {\n    return this._def.innerType;\n  }\n}\nLo.create = (s, e) =&gt; new Lo({\n  innerType: s,\n  typeName: ke.ZodCatch,\n  catchValue: typeof e.catch == \"function\" ? e.catch : () =&gt; e.catch,\n  ...Ve(e)\n});\nclass nd extends Ye {\n  _parse(e) {\n    if (this._getType(e) !== me.nan) {\n      const r = this._getOrReturnCtx(e);\n      return he(r, {\n        code: ae.invalid_type,\n        expected: me.nan,\n        received: r.parsedType\n      }), Re;\n    }\n    return { status: \"valid\", value: e.data };\n  }\n}\nnd.create = (s) =&gt; new nd({\n  typeName: ke.ZodNaN,\n  ...Ve(s)\n});\nclass Uf extends Ye {\n  _parse(e) {\n    const { ctx: t } = this._processInputParams(e), r = t.data;\n    return this._def.type._parse({\n      data: r,\n      path: t.path,\n      parent: t\n    });\n  }\n  unwrap() {\n    return this._def.type;\n  }\n}\nclass $c extends Ye {\n  _parse(e) {\n    const { status: t, ctx: r } = this._processInputParams(e);\n    if (r.common.async)\n      return (async () =&gt; {\n        const i = await this._def.in._parseAsync({\n          data: r.data,\n          path: r.path,\n          parent: r\n        });\n        return i.status === \"aborted\" ? Re : i.status === \"dirty\" ? (t.dirty(), Wn(i.value)) : this._def.out._parseAsync({\n          data: i.value,\n          path: r.path,\n          parent: r\n        });\n      })();\n    {\n      const n = this._def.in._parseSync({\n        data: r.data,\n        path: r.path,\n        parent: r\n      });\n      return n.status === \"aborted\" ? Re : n.status === \"dirty\" ? (t.dirty(), {\n        status: \"dirty\",\n        value: n.value\n      }) : this._def.out._parseSync({\n        data: n.value,\n        path: r.path,\n        parent: r\n      });\n    }\n  }\n  static create(e, t) {\n    return new $c({\n      in: e,\n      out: t,\n      typeName: ke.ZodPipeline\n    });\n  }\n}\nclass Co extends Ye {\n  _parse(e) {\n    const t = this._def.innerType._parse(e), r = (n) =&gt; (Ln(n) &amp;&amp; (n.value = Object.freeze(n.value)), n);\n    return bo(t) ? t.then((n) =&gt; r(n)) : r(t);\n  }\n  unwrap() {\n    return this._def.innerType;\n  }\n}\nCo.create = (s, e) =&gt; new Co({\n  innerType: s,\n  typeName: ke.ZodReadonly,\n  ...Ve(e)\n});\nvar ke;\n(function(s) {\n  s.ZodString = \"ZodString\", s.ZodNumber = \"ZodNumber\", s.ZodNaN = \"ZodNaN\", s.ZodBigInt = \"ZodBigInt\", s.ZodBoolean = \"ZodBoolean\", s.ZodDate = \"ZodDate\", s.ZodSymbol = \"ZodSymbol\", s.ZodUndefined = \"ZodUndefined\", s.ZodNull = \"ZodNull\", s.ZodAny = \"ZodAny\", s.ZodUnknown = \"ZodUnknown\", s.ZodNever = \"ZodNever\", s.ZodVoid = \"ZodVoid\", s.ZodArray = \"ZodArray\", s.ZodObject = \"ZodObject\", s.ZodUnion = \"ZodUnion\", s.ZodDiscriminatedUnion = \"ZodDiscriminatedUnion\", s.ZodIntersection = \"ZodIntersection\", s.ZodTuple = \"ZodTuple\", s.ZodRecord = \"ZodRecord\", s.ZodMap = \"ZodMap\", s.ZodSet = \"ZodSet\", s.ZodFunction = \"ZodFunction\", s.ZodLazy = \"ZodLazy\", s.ZodLiteral = \"ZodLiteral\", s.ZodEnum = \"ZodEnum\", s.ZodEffects = \"ZodEffects\", s.ZodNativeEnum = \"ZodNativeEnum\", s.ZodOptional = \"ZodOptional\", s.ZodNullable = \"ZodNullable\", s.ZodDefault = \"ZodDefault\", s.ZodCatch = \"ZodCatch\", s.ZodPromise = \"ZodPromise\", s.ZodBranded = \"ZodBranded\", s.ZodPipeline = \"ZodPipeline\", s.ZodReadonly = \"ZodReadonly\";\n})(ke || (ke = {}));\nconst xt = Rs.create, $f = Cn.create, Qm = Hl.create;\nPs.create;\nconst Ks = Yr.create, Jt = $t.create, ko = wo.create, Gf = Uc.create;\nAo.create;\nWs.create;\nconst ir = Io.create, Gc = zs.create;\n_o.create;\nfs.create;\nZs.create;\nconst e1 = /[@#$%^&amp;*+=/\\\\|~]/, t1 = /(!{2,}|\\?{2,}|-{2,})/, r1 = /[\\u{1F300}-\\u{1F9FF}]|[\\u{2702}-\\u{27B0}]|[\\u{2600}-\\u{26FF}]|[\\u{2B00}-\\u{2BFF}]/u, $n = ({ max: s, noSpaces: e } = {}) =&gt; (e ? xt().max(s ?? Number.POSITIVE_INFINITY).regex(/^\\S*$/, \"Spaces are not allowed\") : xt().max(s ?? Number.POSITIVE_INFINITY)).refine((r) =&gt; !r1.test(r), {\n  message: \"Emojis and symbols are not allowed\"\n}).refine((r) =&gt; !e1.test(r), {\n  message: \"Special characters (@, #, $, %, ^, &amp;, *, +, =, /, \\\\, |, ~, , ) are not allowed\"\n}).refine((r) =&gt; !t1.test(r), {\n  message: \"Repeated punctuations (!!, ??, --) are not allowed\"\n}), or = xt().url().startsWith(\"https://\", { message: \"Must be an https url\" }).max(1024).refine((s) =&gt; !s.includes(\" \"), {\n  message: \"URL must not contain spaces\"\n}).refine((s) =&gt; {\n  try {\n    const e = new URL(s).hostname;\n    return !(e === \"localhost\" || e.endsWith(\".localhost\") || /^(\\d{1,3}\\.){3}\\d{1,3}$/.test(e) || e.startsWith(\"[\") &amp;&amp; e.endsWith(\"]\"));\n  } catch {\n    return !1;\n  }\n}, {\n  message: \"URL must not use IP addresses or localhost\"\n}), Vc = xt().max(32), Vf = xt().max(32), s1 = /^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}\\/(?:[-a-z0-9]{3,8}:[-.%a-zA-Z0-9]{1,128}(?:\\/[-.%a-zA-Z0-9]{1,78})?|native)$/, n1 = xt().regex(s1, { message: \"Invalid CAIP-19 asset ID\" }), jc = xt().regex(/^#([0-9A-F]{3}|[0-9A-F]{6})$/i, {\n  message: \"Invalid hex color code. It should be in the format #RRGGBB or #RGB.\"\n}), i1 = /^(?!.*\\.\\.)([a-zA-Z0-9]([a-zA-Z0-9-]*[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,}$/, o1 = xt().max(1024).regex(i1, {\n  message: \"Must be a valid domain name (e.g., example.com, sub.example.com)\"\n}).refine((s) =&gt; !s.includes(\"://\"), {\n  message: \"Domain must not include protocol (http://, https://, etc.)\"\n}).refine((s) =&gt; !s.includes(\"/\"), {\n  message: \"Domain must not include path separators\"\n}).refine((s) =&gt; !s.includes(\"@\"), {\n  message: \"Domain must not include @ symbol\"\n}).refine((s) =&gt; !s.includes(\":\"), {\n  message: \"Domain must not include port numbers\"\n}), a1 = ko([ir(\"1:1\"), ir(\"3:2\")]), l1 = Jt({\n  header: xt(),\n  payload: xt(),\n  signature: xt()\n});\nJt({\n  fid: $f(),\n  type: ir(\"app_key\"),\n  key: xt().startsWith(\"0x\")\n});\nconst c1 = Jt({\n  type: ir(\"launch_frame\"),\n  name: Vc,\n  url: or.optional(),\n  splashImageUrl: or.optional(),\n  splashBackgroundColor: jc.optional()\n}), u1 = Jt({\n  type: ir(\"launch_miniapp\"),\n  name: Vc,\n  url: or.optional(),\n  splashImageUrl: or.optional(),\n  splashBackgroundColor: jc.optional()\n}), d1 = Jt({\n  type: ir(\"view_token\"),\n  token: n1\n}), h1 = Gf(\"type\", [\n  u1,\n  d1,\n  // Remove after compatibility period\n  c1\n]), f1 = Jt({\n  title: Vf,\n  action: h1\n});\nJt({\n  version: ko([xt(), $f()]).transform((s) =&gt; String(s)).pipe(ko([ir(\"next\"), ir(\"1\")])),\n  imageUrl: or,\n  aspectRatio: a1.optional(),\n  button: f1\n});\nconst jf = Jt({\n  url: xt(),\n  token: xt()\n});\nJt({\n  notificationId: xt().max(128),\n  title: xt().max(32),\n  body: xt().max(128),\n  targetUrl: or,\n  tokens: xt().array().max(100)\n});\nJt({\n  result: Jt({\n    successfulTokens: Ks(xt()),\n    invalidTokens: Ks(xt()),\n    rateLimitedTokens: Ks(xt())\n  })\n});\nconst g1 = Jt({\n  event: ir(\"miniapp_added\"),\n  notificationDetails: jf.optional()\n}), p1 = Jt({\n  event: ir(\"miniapp_removed\")\n}), m1 = Jt({\n  event: ir(\"notifications_enabled\"),\n  notificationDetails: jf.required()\n}), y1 = Jt({\n  event: ir(\"notifications_disabled\")\n});\nGf(\"event\", [\n  g1,\n  p1,\n  m1,\n  y1\n]);\nconst v1 = [\n  \"wallet.getEthereumProvider\",\n  \"wallet.getSolanaProvider\",\n  \"actions.ready\",\n  \"actions.openUrl\",\n  \"actions.close\",\n  \"actions.setPrimaryButton\",\n  \"actions.addMiniApp\",\n  \"actions.signIn\",\n  \"actions.viewCast\",\n  \"actions.viewProfile\",\n  \"actions.composeCast\",\n  \"actions.viewToken\",\n  \"actions.sendToken\",\n  \"actions.swapToken\",\n  \"actions.openMiniApp\",\n  \"actions.requestCameraAndMicrophoneAccess\",\n  \"experimental.signManifest\",\n  \"haptics.impactOccurred\",\n  \"haptics.notificationOccurred\",\n  \"haptics.selectionChanged\",\n  \"back\"\n], E1 = [\n  \"games\",\n  \"social\",\n  \"finance\",\n  \"utility\",\n  \"productivity\",\n  \"health-fitness\",\n  \"news-media\",\n  \"music\",\n  \"shopping\",\n  \"education\",\n  \"developer-tools\",\n  \"entertainment\",\n  \"art-creativity\"\n], x1 = Gc(E1), S1 = ko([\n  ir(\"0.0.0\"),\n  ir(\"0.0.1\"),\n  ir(\"1\"),\n  ir(\"next\")\n]), b1 = $n({ max: 30 }), T1 = $n({ max: 170 }), w1 = Ks(or).max(3), A1 = Ks($n({ max: 20, noSpaces: !0 })).max(5), I1 = $n({ max: 30 }), _1 = $n({ max: 30 }), R1 = $n({ max: 100 }), L1 = Qm(), C1 = [\n  \"eip155:1\",\n  // Ethereum mainnet\n  \"eip155:8453\",\n  // Base mainnet\n  \"eip155:42161\",\n  // Arbitrum One\n  \"eip155:421614\",\n  // Arbitrum Sepolia\n  \"eip155:84532\",\n  // Base Sepolia\n  \"eip155:666666666\",\n  // Degen\n  \"eip155:100\",\n  // Gnosis\n  \"eip155:10\",\n  // Optimism\n  \"eip155:11155420\",\n  // Optimism Sepolia\n  \"eip155:137\",\n  // Polygon\n  \"eip155:11155111\",\n  // Ethereum Sepolia\n  \"eip155:7777777\",\n  // Zora\n  \"eip155:130\",\n  // Unichain\n  \"eip155:10143\",\n  // Monad testnet\n  \"eip155:42220\",\n  // Celo\n  \"solana:5eykt4UsFv8P8NJdTREpY1vzqKqZKvdp\"\n  // Solana\n];\nfunction Kf(s) {\n  const e = new Set(s);\n  return Array.from(e);\n}\nconst k1 = Ks(Gc(C1)).transform(Kf), D1 = Ks(Gc(v1)).transform(Kf), id = Jt({\n  // 0.0.0 and 0.0.1 are not technically part of the spec but kept for\n  // backwards compatibility. next should always resolve to the most recent\n  // schema version.\n  version: S1,\n  name: Vc,\n  iconUrl: or,\n  homeUrl: or,\n  /** deprecated, set ogImageUrl instead */\n  imageUrl: or.optional(),\n  /** deprecated, will rely on fc:frame/fc:miniapp meta tag */\n  buttonTitle: Vf.optional(),\n  splashImageUrl: or.optional(),\n  splashBackgroundColor: jc.optional(),\n  webhookUrl: or.optional(),\n  /** see: https://github.com/farcasterxyz/miniapps/discussions/191 */\n  subtitle: b1.optional(),\n  description: T1.optional(),\n  screenshotUrls: w1.optional(),\n  primaryCategory: x1.optional(),\n  tags: A1.optional(),\n  heroImageUrl: or.optional(),\n  tagline: I1.optional(),\n  ogTitle: _1.optional(),\n  ogDescription: R1.optional(),\n  ogImageUrl: or.optional(),\n  /** see: https://github.com/farcasterxyz/miniapps/discussions/204 */\n  noindex: L1.optional(),\n  /** see https://github.com/farcasterxyz/miniapps/discussions/256 */\n  requiredChains: k1.optional(),\n  requiredCapabilities: D1.optional(),\n  /** see https://github.com/farcasterxyz/miniapps/discussions/158 */\n  /** Documentation will be added once this feature is finalized. */\n  castShareUrl: or.optional(),\n  /** Canonical domain for the miniapp application */\n  canonicalDomain: o1.optional()\n}).refine((s) =&gt; {\n  if (s.castShareUrl === void 0)\n    return !0;\n  try {\n    const e = new URL(s.homeUrl).hostname, t = new URL(s.castShareUrl).hostname;\n    return e === t;\n  } catch {\n    return !1;\n  }\n}, {\n  message: \"castShareUrl must have the same domain as homeUrl\",\n  path: [\"castShareUrl\"]\n});\nJt({\n  accountAssociation: l1,\n  miniapp: id.optional(),\n  // Support both 'frame' and 'miniapp' during transition period\n  frame: id.optional()\n}).refine((s) =&gt; s.frame &amp;&amp; s.miniapp ? JSON.stringify(s.frame) === JSON.stringify(s.miniapp) : !0, {\n  message: 'If both \"frame\" and \"miniapp\" are provided, they must be identical',\n  path: [\"frame\", \"miniapp\"]\n}).transform((s) =&gt; ({\n  ...s,\n  frame: s.frame ?? s.miniapp\n}));\nvar Ga = {}, Hn = {}, od;\nfunction P1() {\n  if (od) return Hn;\n  od = 1, Hn.byteLength = a, Hn.toByteArray = c, Hn.fromByteArray = h;\n  for (var s = [], e = [], t = typeof Uint8Array &lt; \"u\" ? Uint8Array : Array, r = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", n = 0, i = r.length; n &lt; i; ++n)\n    s[n] = r[n], e[r.charCodeAt(n)] = n;\n  e[45] = 62, e[95] = 63;\n  function o(f) {\n    var p = f.length;\n    if (p % 4 &gt; 0)\n      throw new Error(\"Invalid string. Length must be a multiple of 4\");\n    var y = f.indexOf(\"=\");\n    y === -1 &amp;&amp; (y = p);\n    var E = y === p ? 0 : 4 - y % 4;\n    return [y, E];\n  }\n  function a(f) {\n    var p = o(f), y = p[0], E = p[1];\n    return (y + E) * 3 / 4 - E;\n  }\n  function l(f, p, y) {\n    return (p + y) * 3 / 4 - y;\n  }\n  function c(f) {\n    var p, y = o(f), E = y[0], b = y[1], R = new t(l(f, E, b)), A = 0, F = b &gt; 0 ? E - 4 : E, M;\n    for (M = 0; M &lt; F; M += 4)\n      p = e[f.charCodeAt(M)] &lt;&lt; 18 | e[f.charCodeAt(M + 1)] &lt;&lt; 12 | e[f.charCodeAt(M + 2)] &lt;&lt; 6 | e[f.charCodeAt(M + 3)], R[A++] = p &gt;&gt; 16 &amp; 255, R[A++] = p &gt;&gt; 8 &amp; 255, R[A++] = p &amp; 255;\n    return b === 2 &amp;&amp; (p = e[f.charCodeAt(M)] &lt;&lt; 2 | e[f.charCodeAt(M + 1)] &gt;&gt; 4, R[A++] = p &amp; 255), b === 1 &amp;&amp; (p = e[f.charCodeAt(M)] &lt;&lt; 10 | e[f.charCodeAt(M + 1)] &lt;&lt; 4 | e[f.charCodeAt(M + 2)] &gt;&gt; 2, R[A++] = p &gt;&gt; 8 &amp; 255, R[A++] = p &amp; 255), R;\n  }\n  function u(f) {\n    return s[f &gt;&gt; 18 &amp; 63] + s[f &gt;&gt; 12 &amp; 63] + s[f &gt;&gt; 6 &amp; 63] + s[f &amp; 63];\n  }\n  function d(f, p, y) {\n    for (var E, b = [], R = p; R &lt; y; R += 3)\n      E = (f[R] &lt;&lt; 16 &amp; 16711680) + (f[R + 1] &lt;&lt; 8 &amp; 65280) + (f[R + 2] &amp; 255), b.push(u(E));\n    return b.join(\"\");\n  }\n  function h(f) {\n    for (var p, y = f.length, E = y % 3, b = [], R = 16383, A = 0, F = y - E; A &lt; F; A += R)\n      b.push(d(f, A, A + R &gt; F ? F : A + R));\n    return E === 1 ? (p = f[y - 1], b.push(\n      s[p &gt;&gt; 2] + s[p &lt;&lt; 4 &amp; 63] + \"==\"\n    )) : E === 2 &amp;&amp; (p = (f[y - 2] &lt;&lt; 8) + f[y - 1], b.push(\n      s[p &gt;&gt; 10] + s[p &gt;&gt; 4 &amp; 63] + s[p &lt;&lt; 2 &amp; 63] + \"=\"\n    )), b.join(\"\");\n  }\n  return Hn;\n}\nvar Mi = {};\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh &lt;https://feross.org/opensource&gt; */\nvar ad;\nfunction M1() {\n  return ad || (ad = 1, Mi.read = function(s, e, t, r, n) {\n    var i, o, a = n * 8 - r - 1, l = (1 &lt;&lt; a) - 1, c = l &gt;&gt; 1, u = -7, d = t ? n - 1 : 0, h = t ? -1 : 1, f = s[e + d];\n    for (d += h, i = f &amp; (1 &lt;&lt; -u) - 1, f &gt;&gt;= -u, u += a; u &gt; 0; i = i * 256 + s[e + d], d += h, u -= 8)\n      ;\n    for (o = i &amp; (1 &lt;&lt; -u) - 1, i &gt;&gt;= -u, u += r; u &gt; 0; o = o * 256 + s[e + d], d += h, u -= 8)\n      ;\n    if (i === 0)\n      i = 1 - c;\n    else {\n      if (i === l)\n        return o ? NaN : (f ? -1 : 1) * (1 / 0);\n      o = o + Math.pow(2, r), i = i - c;\n    }\n    return (f ? -1 : 1) * o * Math.pow(2, i - r);\n  }, Mi.write = function(s, e, t, r, n, i) {\n    var o, a, l, c = i * 8 - n - 1, u = (1 &lt;&lt; c) - 1, d = u &gt;&gt; 1, h = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f = r ? 0 : i - 1, p = r ? 1 : -1, y = e &lt; 0 || e === 0 &amp;&amp; 1 / e &lt; 0 ? 1 : 0;\n    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (a = isNaN(e) ? 1 : 0, o = u) : (o = Math.floor(Math.log(e) / Math.LN2), e * (l = Math.pow(2, -o)) &lt; 1 &amp;&amp; (o--, l *= 2), o + d &gt;= 1 ? e += h / l : e += h * Math.pow(2, 1 - d), e * l &gt;= 2 &amp;&amp; (o++, l /= 2), o + d &gt;= u ? (a = 0, o = u) : o + d &gt;= 1 ? (a = (e * l - 1) * Math.pow(2, n), o = o + d) : (a = e * Math.pow(2, d - 1) * Math.pow(2, n), o = 0)); n &gt;= 8; s[t + f] = a &amp; 255, f += p, a /= 256, n -= 8)\n      ;\n    for (o = o &lt;&lt; n | a, c += n; c &gt; 0; s[t + f] = o &amp; 255, f += p, o /= 256, c -= 8)\n      ;\n    s[t + f - p] |= y * 128;\n  }), Mi;\n}\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh &lt;https://feross.org&gt;\n * @license  MIT\n */\nvar ld;\nfunction Kc() {\n  return ld || (ld = 1, (function(s) {\n    const e = P1(), t = M1(), r = typeof Symbol == \"function\" &amp;&amp; typeof Symbol.for == \"function\" ? Symbol.for(\"nodejs.util.inspect.custom\") : null;\n    s.Buffer = a, s.SlowBuffer = R, s.INSPECT_MAX_BYTES = 50;\n    const n = 2147483647;\n    s.kMaxLength = n, a.TYPED_ARRAY_SUPPORT = i(), !a.TYPED_ARRAY_SUPPORT &amp;&amp; typeof console &lt; \"u\" &amp;&amp; typeof console.error == \"function\" &amp;&amp; console.error(\n      \"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"\n    );\n    function i() {\n      try {\n        const B = new Uint8Array(1), S = { foo: function() {\n          return 42;\n        } };\n        return Object.setPrototypeOf(S, Uint8Array.prototype), Object.setPrototypeOf(B, S), B.foo() === 42;\n      } catch {\n        return !1;\n      }\n    }\n    Object.defineProperty(a.prototype, \"parent\", {\n      enumerable: !0,\n      get: function() {\n        if (a.isBuffer(this))\n          return this.buffer;\n      }\n    }), Object.defineProperty(a.prototype, \"offset\", {\n      enumerable: !0,\n      get: function() {\n        if (a.isBuffer(this))\n          return this.byteOffset;\n      }\n    });\n    function o(B) {\n      if (B &gt; n)\n        throw new RangeError('The value \"' + B + '\" is invalid for option \"size\"');\n      const S = new Uint8Array(B);\n      return Object.setPrototypeOf(S, a.prototype), S;\n    }\n    function a(B, S, T) {\n      if (typeof B == \"number\") {\n        if (typeof S == \"string\")\n          throw new TypeError(\n            'The \"string\" argument must be of type string. Received type number'\n          );\n        return d(B);\n      }\n      return l(B, S, T);\n    }\n    a.poolSize = 8192;\n    function l(B, S, T) {\n      if (typeof B == \"string\")\n        return h(B, S);\n      if (ArrayBuffer.isView(B))\n        return p(B);\n      if (B == null)\n        throw new TypeError(\n          \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof B\n        );\n      if (dt(B, ArrayBuffer) || B &amp;&amp; dt(B.buffer, ArrayBuffer) || typeof SharedArrayBuffer &lt; \"u\" &amp;&amp; (dt(B, SharedArrayBuffer) || B &amp;&amp; dt(B.buffer, SharedArrayBuffer)))\n        return y(B, S, T);\n      if (typeof B == \"number\")\n        throw new TypeError(\n          'The \"value\" argument must not be of type number. Received type number'\n        );\n      const G = B.valueOf &amp;&amp; B.valueOf();\n      if (G != null &amp;&amp; G !== B)\n        return a.from(G, S, T);\n      const Z = E(B);\n      if (Z) return Z;\n      if (typeof Symbol &lt; \"u\" &amp;&amp; Symbol.toPrimitive != null &amp;&amp; typeof B[Symbol.toPrimitive] == \"function\")\n        return a.from(B[Symbol.toPrimitive](\"string\"), S, T);\n      throw new TypeError(\n        \"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof B\n      );\n    }\n    a.from = function(B, S, T) {\n      return l(B, S, T);\n    }, Object.setPrototypeOf(a.prototype, Uint8Array.prototype), Object.setPrototypeOf(a, Uint8Array);\n    function c(B) {\n      if (typeof B != \"number\")\n        throw new TypeError('\"size\" argument must be of type number');\n      if (B &lt; 0)\n        throw new RangeError('The value \"' + B + '\" is invalid for option \"size\"');\n    }\n    function u(B, S, T) {\n      return c(B), B &lt;= 0 ? o(B) : S !== void 0 ? typeof T == \"string\" ? o(B).fill(S, T) : o(B).fill(S) : o(B);\n    }\n    a.alloc = function(B, S, T) {\n      return u(B, S, T);\n    };\n    function d(B) {\n      return c(B), o(B &lt; 0 ? 0 : b(B) | 0);\n    }\n    a.allocUnsafe = function(B) {\n      return d(B);\n    }, a.allocUnsafeSlow = function(B) {\n      return d(B);\n    };\n    function h(B, S) {\n      if ((typeof S != \"string\" || S === \"\") &amp;&amp; (S = \"utf8\"), !a.isEncoding(S))\n        throw new TypeError(\"Unknown encoding: \" + S);\n      const T = A(B, S) | 0;\n      let G = o(T);\n      const Z = G.write(B, S);\n      return Z !== T &amp;&amp; (G = G.slice(0, Z)), G;\n    }\n    function f(B) {\n      const S = B.length &lt; 0 ? 0 : b(B.length) | 0, T = o(S);\n      for (let G = 0; G &lt; S; G += 1)\n        T[G] = B[G] &amp; 255;\n      return T;\n    }\n    function p(B) {\n      if (dt(B, Uint8Array)) {\n        const S = new Uint8Array(B);\n        return y(S.buffer, S.byteOffset, S.byteLength);\n      }\n      return f(B);\n    }\n    function y(B, S, T) {\n      if (S &lt; 0 || B.byteLength &lt; S)\n        throw new RangeError('\"offset\" is outside of buffer bounds');\n      if (B.byteLength &lt; S + (T || 0))\n        throw new RangeError('\"length\" is outside of buffer bounds');\n      let G;\n      return S === void 0 &amp;&amp; T === void 0 ? G = new Uint8Array(B) : T === void 0 ? G = new Uint8Array(B, S) : G = new Uint8Array(B, S, T), Object.setPrototypeOf(G, a.prototype), G;\n    }\n    function E(B) {\n      if (a.isBuffer(B)) {\n        const S = b(B.length) | 0, T = o(S);\n        return T.length === 0 || B.copy(T, 0, 0, S), T;\n      }\n      if (B.length !== void 0)\n        return typeof B.length != \"number\" || Je(B.length) ? o(0) : f(B);\n      if (B.type === \"Buffer\" &amp;&amp; Array.isArray(B.data))\n        return f(B.data);\n    }\n    function b(B) {\n      if (B &gt;= n)\n        throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + n.toString(16) + \" bytes\");\n      return B | 0;\n    }\n    function R(B) {\n      return +B != B &amp;&amp; (B = 0), a.alloc(+B);\n    }\n    a.isBuffer = function(S) {\n      return S != null &amp;&amp; S._isBuffer === !0 &amp;&amp; S !== a.prototype;\n    }, a.compare = function(S, T) {\n      if (dt(S, Uint8Array) &amp;&amp; (S = a.from(S, S.offset, S.byteLength)), dt(T, Uint8Array) &amp;&amp; (T = a.from(T, T.offset, T.byteLength)), !a.isBuffer(S) || !a.isBuffer(T))\n        throw new TypeError(\n          'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n        );\n      if (S === T) return 0;\n      let G = S.length, Z = T.length;\n      for (let Q = 0, se = Math.min(G, Z); Q &lt; se; ++Q)\n        if (S[Q] !== T[Q]) {\n          G = S[Q], Z = T[Q];\n          break;\n        }\n      return G &lt; Z ? -1 : Z &lt; G ? 1 : 0;\n    }, a.isEncoding = function(S) {\n      switch (String(S).toLowerCase()) {\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return !0;\n        default:\n          return !1;\n      }\n    }, a.concat = function(S, T) {\n      if (!Array.isArray(S))\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      if (S.length === 0)\n        return a.alloc(0);\n      let G;\n      if (T === void 0)\n        for (T = 0, G = 0; G &lt; S.length; ++G)\n          T += S[G].length;\n      const Z = a.allocUnsafe(T);\n      let Q = 0;\n      for (G = 0; G &lt; S.length; ++G) {\n        let se = S[G];\n        if (dt(se, Uint8Array))\n          Q + se.length &gt; Z.length ? (a.isBuffer(se) || (se = a.from(se)), se.copy(Z, Q)) : Uint8Array.prototype.set.call(\n            Z,\n            se,\n            Q\n          );\n        else if (a.isBuffer(se))\n          se.copy(Z, Q);\n        else\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        Q += se.length;\n      }\n      return Z;\n    };\n    function A(B, S) {\n      if (a.isBuffer(B))\n        return B.length;\n      if (ArrayBuffer.isView(B) || dt(B, ArrayBuffer))\n        return B.byteLength;\n      if (typeof B != \"string\")\n        throw new TypeError(\n          'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof B\n        );\n      const T = B.length, G = arguments.length &gt; 2 &amp;&amp; arguments[2] === !0;\n      if (!G &amp;&amp; T === 0) return 0;\n      let Z = !1;\n      for (; ; )\n        switch (S) {\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return T;\n          case \"utf8\":\n          case \"utf-8\":\n            return be(B).length;\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return T * 2;\n          case \"hex\":\n            return T &gt;&gt;&gt; 1;\n          case \"base64\":\n            return we(B).length;\n          default:\n            if (Z)\n              return G ? -1 : be(B).length;\n            S = (\"\" + S).toLowerCase(), Z = !0;\n        }\n    }\n    a.byteLength = A;\n    function F(B, S, T) {\n      let G = !1;\n      if ((S === void 0 || S &lt; 0) &amp;&amp; (S = 0), S &gt; this.length || ((T === void 0 || T &gt; this.length) &amp;&amp; (T = this.length), T &lt;= 0) || (T &gt;&gt;&gt;= 0, S &gt;&gt;&gt;= 0, T &lt;= S))\n        return \"\";\n      for (B || (B = \"utf8\"); ; )\n        switch (B) {\n          case \"hex\":\n            return U(this, S, T);\n          case \"utf8\":\n          case \"utf-8\":\n            return g(this, S, T);\n          case \"ascii\":\n            return D(this, S, T);\n          case \"latin1\":\n          case \"binary\":\n            return O(this, S, T);\n          case \"base64\":\n            return _(this, S, T);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return V(this, S, T);\n          default:\n            if (G) throw new TypeError(\"Unknown encoding: \" + B);\n            B = (B + \"\").toLowerCase(), G = !0;\n        }\n    }\n    a.prototype._isBuffer = !0;\n    function M(B, S, T) {\n      const G = B[S];\n      B[S] = B[T], B[T] = G;\n    }\n    a.prototype.swap16 = function() {\n      const S = this.length;\n      if (S % 2 !== 0)\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n      for (let T = 0; T &lt; S; T += 2)\n        M(this, T, T + 1);\n      return this;\n    }, a.prototype.swap32 = function() {\n      const S = this.length;\n      if (S % 4 !== 0)\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n      for (let T = 0; T &lt; S; T += 4)\n        M(this, T, T + 3), M(this, T + 1, T + 2);\n      return this;\n    }, a.prototype.swap64 = function() {\n      const S = this.length;\n      if (S % 8 !== 0)\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n      for (let T = 0; T &lt; S; T += 8)\n        M(this, T, T + 7), M(this, T + 1, T + 6), M(this, T + 2, T + 5), M(this, T + 3, T + 4);\n      return this;\n    }, a.prototype.toString = function() {\n      const S = this.length;\n      return S === 0 ? \"\" : arguments.length === 0 ? g(this, 0, S) : F.apply(this, arguments);\n    }, a.prototype.toLocaleString = a.prototype.toString, a.prototype.equals = function(S) {\n      if (!a.isBuffer(S)) throw new TypeError(\"Argument must be a Buffer\");\n      return this === S ? !0 : a.compare(this, S) === 0;\n    }, a.prototype.inspect = function() {\n      let S = \"\";\n      const T = s.INSPECT_MAX_BYTES;\n      return S = this.toString(\"hex\", 0, T).replace(/(.{2})/g, \"$1 \").trim(), this.length &gt; T &amp;&amp; (S += \" ... \"), \"&lt;Buffer \" + S + \"&gt;\";\n    }, r &amp;&amp; (a.prototype[r] = a.prototype.inspect), a.prototype.compare = function(S, T, G, Z, Q) {\n      if (dt(S, Uint8Array) &amp;&amp; (S = a.from(S, S.offset, S.byteLength)), !a.isBuffer(S))\n        throw new TypeError(\n          'The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof S\n        );\n      if (T === void 0 &amp;&amp; (T = 0), G === void 0 &amp;&amp; (G = S ? S.length : 0), Z === void 0 &amp;&amp; (Z = 0), Q === void 0 &amp;&amp; (Q = this.length), T &lt; 0 || G &gt; S.length || Z &lt; 0 || Q &gt; this.length)\n        throw new RangeError(\"out of range index\");\n      if (Z &gt;= Q &amp;&amp; T &gt;= G)\n        return 0;\n      if (Z &gt;= Q)\n        return -1;\n      if (T &gt;= G)\n        return 1;\n      if (T &gt;&gt;&gt;= 0, G &gt;&gt;&gt;= 0, Z &gt;&gt;&gt;= 0, Q &gt;&gt;&gt;= 0, this === S) return 0;\n      let se = Q - Z, Ue = G - T;\n      const Pe = Math.min(se, Ue), Le = this.slice(Z, Q), ct = S.slice(T, G);\n      for (let Ae = 0; Ae &lt; Pe; ++Ae)\n        if (Le[Ae] !== ct[Ae]) {\n          se = Le[Ae], Ue = ct[Ae];\n          break;\n        }\n      return se &lt; Ue ? -1 : Ue &lt; se ? 1 : 0;\n    };\n    function H(B, S, T, G, Z) {\n      if (B.length === 0) return -1;\n      if (typeof T == \"string\" ? (G = T, T = 0) : T &gt; 2147483647 ? T = 2147483647 : T &lt; -2147483648 &amp;&amp; (T = -2147483648), T = +T, Je(T) &amp;&amp; (T = Z ? 0 : B.length - 1), T &lt; 0 &amp;&amp; (T = B.length + T), T &gt;= B.length) {\n        if (Z) return -1;\n        T = B.length - 1;\n      } else if (T &lt; 0)\n        if (Z) T = 0;\n        else return -1;\n      if (typeof S == \"string\" &amp;&amp; (S = a.from(S, G)), a.isBuffer(S))\n        return S.length === 0 ? -1 : K(B, S, T, G, Z);\n      if (typeof S == \"number\")\n        return S = S &amp; 255, typeof Uint8Array.prototype.indexOf == \"function\" ? Z ? Uint8Array.prototype.indexOf.call(B, S, T) : Uint8Array.prototype.lastIndexOf.call(B, S, T) : K(B, [S], T, G, Z);\n      throw new TypeError(\"val must be string, number or Buffer\");\n    }\n    function K(B, S, T, G, Z) {\n      let Q = 1, se = B.length, Ue = S.length;\n      if (G !== void 0 &amp;&amp; (G = String(G).toLowerCase(), G === \"ucs2\" || G === \"ucs-2\" || G === \"utf16le\" || G === \"utf-16le\")) {\n        if (B.length &lt; 2 || S.length &lt; 2)\n          return -1;\n        Q = 2, se /= 2, Ue /= 2, T /= 2;\n      }\n      function Pe(ct, Ae) {\n        return Q === 1 ? ct[Ae] : ct.readUInt16BE(Ae * Q);\n      }\n      let Le;\n      if (Z) {\n        let ct = -1;\n        for (Le = T; Le &lt; se; Le++)\n          if (Pe(B, Le) === Pe(S, ct === -1 ? 0 : Le - ct)) {\n            if (ct === -1 &amp;&amp; (ct = Le), Le - ct + 1 === Ue) return ct * Q;\n          } else\n            ct !== -1 &amp;&amp; (Le -= Le - ct), ct = -1;\n      } else\n        for (T + Ue &gt; se &amp;&amp; (T = se - Ue), Le = T; Le &gt;= 0; Le--) {\n          let ct = !0;\n          for (let Ae = 0; Ae &lt; Ue; Ae++)\n            if (Pe(B, Le + Ae) !== Pe(S, Ae)) {\n              ct = !1;\n              break;\n            }\n          if (ct) return Le;\n        }\n      return -1;\n    }\n    a.prototype.includes = function(S, T, G) {\n      return this.indexOf(S, T, G) !== -1;\n    }, a.prototype.indexOf = function(S, T, G) {\n      return H(this, S, T, G, !0);\n    }, a.prototype.lastIndexOf = function(S, T, G) {\n      return H(this, S, T, G, !1);\n    };\n    function j(B, S, T, G) {\n      T = Number(T) || 0;\n      const Z = B.length - T;\n      G ? (G = Number(G), G &gt; Z &amp;&amp; (G = Z)) : G = Z;\n      const Q = S.length;\n      G &gt; Q / 2 &amp;&amp; (G = Q / 2);\n      let se;\n      for (se = 0; se &lt; G; ++se) {\n        const Ue = parseInt(S.substr(se * 2, 2), 16);\n        if (Je(Ue)) return se;\n        B[T + se] = Ue;\n      }\n      return se;\n    }\n    function C(B, S, T, G) {\n      return Ne(be(S, B.length - T), B, T, G);\n    }\n    function k(B, S, T, G) {\n      return Ne(Fe(S), B, T, G);\n    }\n    function $(B, S, T, G) {\n      return Ne(we(S), B, T, G);\n    }\n    function W(B, S, T, G) {\n      return Ne(Xe(S, B.length - T), B, T, G);\n    }\n    a.prototype.write = function(S, T, G, Z) {\n      if (T === void 0)\n        Z = \"utf8\", G = this.length, T = 0;\n      else if (G === void 0 &amp;&amp; typeof T == \"string\")\n        Z = T, G = this.length, T = 0;\n      else if (isFinite(T))\n        T = T &gt;&gt;&gt; 0, isFinite(G) ? (G = G &gt;&gt;&gt; 0, Z === void 0 &amp;&amp; (Z = \"utf8\")) : (Z = G, G = void 0);\n      else\n        throw new Error(\n          \"Buffer.write(string, encoding, offset[, length]) is no longer supported\"\n        );\n      const Q = this.length - T;\n      if ((G === void 0 || G &gt; Q) &amp;&amp; (G = Q), S.length &gt; 0 &amp;&amp; (G &lt; 0 || T &lt; 0) || T &gt; this.length)\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n      Z || (Z = \"utf8\");\n      let se = !1;\n      for (; ; )\n        switch (Z) {\n          case \"hex\":\n            return j(this, S, T, G);\n          case \"utf8\":\n          case \"utf-8\":\n            return C(this, S, T, G);\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return k(this, S, T, G);\n          case \"base64\":\n            return $(this, S, T, G);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return W(this, S, T, G);\n          default:\n            if (se) throw new TypeError(\"Unknown encoding: \" + Z);\n            Z = (\"\" + Z).toLowerCase(), se = !0;\n        }\n    }, a.prototype.toJSON = function() {\n      return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n      };\n    };\n    function _(B, S, T) {\n      return S === 0 &amp;&amp; T === B.length ? e.fromByteArray(B) : e.fromByteArray(B.slice(S, T));\n    }\n    function g(B, S, T) {\n      T = Math.min(B.length, T);\n      const G = [];\n      let Z = S;\n      for (; Z &lt; T; ) {\n        const Q = B[Z];\n        let se = null, Ue = Q &gt; 239 ? 4 : Q &gt; 223 ? 3 : Q &gt; 191 ? 2 : 1;\n        if (Z + Ue &lt;= T) {\n          let Pe, Le, ct, Ae;\n          switch (Ue) {\n            case 1:\n              Q &lt; 128 &amp;&amp; (se = Q);\n              break;\n            case 2:\n              Pe = B[Z + 1], (Pe &amp; 192) === 128 &amp;&amp; (Ae = (Q &amp; 31) &lt;&lt; 6 | Pe &amp; 63, Ae &gt; 127 &amp;&amp; (se = Ae));\n              break;\n            case 3:\n              Pe = B[Z + 1], Le = B[Z + 2], (Pe &amp; 192) === 128 &amp;&amp; (Le &amp; 192) === 128 &amp;&amp; (Ae = (Q &amp; 15) &lt;&lt; 12 | (Pe &amp; 63) &lt;&lt; 6 | Le &amp; 63, Ae &gt; 2047 &amp;&amp; (Ae &lt; 55296 || Ae &gt; 57343) &amp;&amp; (se = Ae));\n              break;\n            case 4:\n              Pe = B[Z + 1], Le = B[Z + 2], ct = B[Z + 3], (Pe &amp; 192) === 128 &amp;&amp; (Le &amp; 192) === 128 &amp;&amp; (ct &amp; 192) === 128 &amp;&amp; (Ae = (Q &amp; 15) &lt;&lt; 18 | (Pe &amp; 63) &lt;&lt; 12 | (Le &amp; 63) &lt;&lt; 6 | ct &amp; 63, Ae &gt; 65535 &amp;&amp; Ae &lt; 1114112 &amp;&amp; (se = Ae));\n          }\n        }\n        se === null ? (se = 65533, Ue = 1) : se &gt; 65535 &amp;&amp; (se -= 65536, G.push(se &gt;&gt;&gt; 10 &amp; 1023 | 55296), se = 56320 | se &amp; 1023), G.push(se), Z += Ue;\n      }\n      return w(G);\n    }\n    const x = 4096;\n    function w(B) {\n      const S = B.length;\n      if (S &lt;= x)\n        return String.fromCharCode.apply(String, B);\n      let T = \"\", G = 0;\n      for (; G &lt; S; )\n        T += String.fromCharCode.apply(\n          String,\n          B.slice(G, G += x)\n        );\n      return T;\n    }\n    function D(B, S, T) {\n      let G = \"\";\n      T = Math.min(B.length, T);\n      for (let Z = S; Z &lt; T; ++Z)\n        G += String.fromCharCode(B[Z] &amp; 127);\n      return G;\n    }\n    function O(B, S, T) {\n      let G = \"\";\n      T = Math.min(B.length, T);\n      for (let Z = S; Z &lt; T; ++Z)\n        G += String.fromCharCode(B[Z]);\n      return G;\n    }\n    function U(B, S, T) {\n      const G = B.length;\n      (!S || S &lt; 0) &amp;&amp; (S = 0), (!T || T &lt; 0 || T &gt; G) &amp;&amp; (T = G);\n      let Z = \"\";\n      for (let Q = S; Q &lt; T; ++Q)\n        Z += Qe[B[Q]];\n      return Z;\n    }\n    function V(B, S, T) {\n      const G = B.slice(S, T);\n      let Z = \"\";\n      for (let Q = 0; Q &lt; G.length - 1; Q += 2)\n        Z += String.fromCharCode(G[Q] + G[Q + 1] * 256);\n      return Z;\n    }\n    a.prototype.slice = function(S, T) {\n      const G = this.length;\n      S = ~~S, T = T === void 0 ? G : ~~T, S &lt; 0 ? (S += G, S &lt; 0 &amp;&amp; (S = 0)) : S &gt; G &amp;&amp; (S = G), T &lt; 0 ? (T += G, T &lt; 0 &amp;&amp; (T = 0)) : T &gt; G &amp;&amp; (T = G), T &lt; S &amp;&amp; (T = S);\n      const Z = this.subarray(S, T);\n      return Object.setPrototypeOf(Z, a.prototype), Z;\n    };\n    function L(B, S, T) {\n      if (B % 1 !== 0 || B &lt; 0) throw new RangeError(\"offset is not uint\");\n      if (B + S &gt; T) throw new RangeError(\"Trying to access beyond buffer length\");\n    }\n    a.prototype.readUintLE = a.prototype.readUIntLE = function(S, T, G) {\n      S = S &gt;&gt;&gt; 0, T = T &gt;&gt;&gt; 0, G || L(S, T, this.length);\n      let Z = this[S], Q = 1, se = 0;\n      for (; ++se &lt; T &amp;&amp; (Q *= 256); )\n        Z += this[S + se] * Q;\n      return Z;\n    }, a.prototype.readUintBE = a.prototype.readUIntBE = function(S, T, G) {\n      S = S &gt;&gt;&gt; 0, T = T &gt;&gt;&gt; 0, G || L(S, T, this.length);\n      let Z = this[S + --T], Q = 1;\n      for (; T &gt; 0 &amp;&amp; (Q *= 256); )\n        Z += this[S + --T] * Q;\n      return Z;\n    }, a.prototype.readUint8 = a.prototype.readUInt8 = function(S, T) {\n      return S = S &gt;&gt;&gt; 0, T || L(S, 1, this.length), this[S];\n    }, a.prototype.readUint16LE = a.prototype.readUInt16LE = function(S, T) {\n      return S = S &gt;&gt;&gt; 0, T || L(S, 2, this.length), this[S] | this[S + 1] &lt;&lt; 8;\n    }, a.prototype.readUint16BE = a.prototype.readUInt16BE = function(S, T) {\n      return S = S &gt;&gt;&gt; 0, T || L(S, 2, this.length), this[S] &lt;&lt; 8 | this[S + 1];\n    }, a.prototype.readUint32LE = a.prototype.readUInt32LE = function(S, T) {\n      return S = S &gt;&gt;&gt; 0, T || L(S, 4, this.length), (this[S] | this[S + 1] &lt;&lt; 8 | this[S + 2] &lt;&lt; 16) + this[S + 3] * 16777216;\n    }, a.prototype.readUint32BE = a.prototype.readUInt32BE = function(S, T) {\n      return S = S &gt;&gt;&gt; 0, T || L(S, 4, this.length), this[S] * 16777216 + (this[S + 1] &lt;&lt; 16 | this[S + 2] &lt;&lt; 8 | this[S + 3]);\n    }, a.prototype.readBigUInt64LE = it(function(S) {\n      S = S &gt;&gt;&gt; 0, _e(S, \"offset\");\n      const T = this[S], G = this[S + 7];\n      (T === void 0 || G === void 0) &amp;&amp; xe(S, this.length - 8);\n      const Z = T + this[++S] * 2 ** 8 + this[++S] * 2 ** 16 + this[++S] * 2 ** 24, Q = this[++S] + this[++S] * 2 ** 8 + this[++S] * 2 ** 16 + G * 2 ** 24;\n      return BigInt(Z) + (BigInt(Q) &lt;&lt; BigInt(32));\n    }), a.prototype.readBigUInt64BE = it(function(S) {\n      S = S &gt;&gt;&gt; 0, _e(S, \"offset\");\n      const T = this[S], G = this[S + 7];\n      (T === void 0 || G === void 0) &amp;&amp; xe(S, this.length - 8);\n      const Z = T * 2 ** 24 + this[++S] * 2 ** 16 + this[++S] * 2 ** 8 + this[++S], Q = this[++S] * 2 ** 24 + this[++S] * 2 ** 16 + this[++S] * 2 ** 8 + G;\n      return (BigInt(Z) &lt;&lt; BigInt(32)) + BigInt(Q);\n    }), a.prototype.readIntLE = function(S, T, G) {\n      S = S &gt;&gt;&gt; 0, T = T &gt;&gt;&gt; 0, G || L(S, T, this.length);\n      let Z = this[S], Q = 1, se = 0;\n      for (; ++se &lt; T &amp;&amp; (Q *= 256); )\n        Z += this[S + se] * Q;\n      return Q *= 128, Z &gt;= Q &amp;&amp; (Z -= Math.pow(2, 8 * T)), Z;\n    }, a.prototype.readIntBE = function(S, T, G) {\n      S = S &gt;&gt;&gt; 0, T = T &gt;&gt;&gt; 0, G || L(S, T, this.length);\n      let Z = T, Q = 1, se = this[S + --Z];\n      for (; Z &gt; 0 &amp;&amp; (Q *= 256); )\n        se += this[S + --Z] * Q;\n      return Q *= 128, se &gt;= Q &amp;&amp; (se -= Math.pow(2, 8 * T)), se;\n    }, a.prototype.readInt8 = function(S, T) {\n      return S = S &gt;&gt;&gt; 0, T || L(S, 1, this.length), this[S] &amp; 128 ? (255 - this[S] + 1) * -1 : this[S];\n    }, a.prototype.readInt16LE = function(S, T) {\n      S = S &gt;&gt;&gt; 0, T || L(S, 2, this.length);\n      const G = this[S] | this[S + 1] &lt;&lt; 8;\n      return G &amp; 32768 ? G | 4294901760 : G;\n    }, a.prototype.readInt16BE = function(S, T) {\n      S = S &gt;&gt;&gt; 0, T || L(S, 2, this.length);\n      const G = this[S + 1] | this[S] &lt;&lt; 8;\n      return G &amp; 32768 ? G | 4294901760 : G;\n    }, a.prototype.readInt32LE = function(S, T) {\n      return S = S &gt;&gt;&gt; 0, T || L(S, 4, this.length), this[S] | this[S + 1] &lt;&lt; 8 | this[S + 2] &lt;&lt; 16 | this[S + 3] &lt;&lt; 24;\n    }, a.prototype.readInt32BE = function(S, T) {\n      return S = S &gt;&gt;&gt; 0, T || L(S, 4, this.length), this[S] &lt;&lt; 24 | this[S + 1] &lt;&lt; 16 | this[S + 2] &lt;&lt; 8 | this[S + 3];\n    }, a.prototype.readBigInt64LE = it(function(S) {\n      S = S &gt;&gt;&gt; 0, _e(S, \"offset\");\n      const T = this[S], G = this[S + 7];\n      (T === void 0 || G === void 0) &amp;&amp; xe(S, this.length - 8);\n      const Z = this[S + 4] + this[S + 5] * 2 ** 8 + this[S + 6] * 2 ** 16 + (G &lt;&lt; 24);\n      return (BigInt(Z) &lt;&lt; BigInt(32)) + BigInt(T + this[++S] * 2 ** 8 + this[++S] * 2 ** 16 + this[++S] * 2 ** 24);\n    }), a.prototype.readBigInt64BE = it(function(S) {\n      S = S &gt;&gt;&gt; 0, _e(S, \"offset\");\n      const T = this[S], G = this[S + 7];\n      (T === void 0 || G === void 0) &amp;&amp; xe(S, this.length - 8);\n      const Z = (T &lt;&lt; 24) + // Overflow\n      this[++S] * 2 ** 16 + this[++S] * 2 ** 8 + this[++S];\n      return (BigInt(Z) &lt;&lt; BigInt(32)) + BigInt(this[++S] * 2 ** 24 + this[++S] * 2 ** 16 + this[++S] * 2 ** 8 + G);\n    }), a.prototype.readFloatLE = function(S, T) {\n      return S = S &gt;&gt;&gt; 0, T || L(S, 4, this.length), t.read(this, S, !0, 23, 4);\n    }, a.prototype.readFloatBE = function(S, T) {\n      return S = S &gt;&gt;&gt; 0, T || L(S, 4, this.length), t.read(this, S, !1, 23, 4);\n    }, a.prototype.readDoubleLE = function(S, T) {\n      return S = S &gt;&gt;&gt; 0, T || L(S, 8, this.length), t.read(this, S, !0, 52, 8);\n    }, a.prototype.readDoubleBE = function(S, T) {\n      return S = S &gt;&gt;&gt; 0, T || L(S, 8, this.length), t.read(this, S, !1, 52, 8);\n    };\n    function m(B, S, T, G, Z, Q) {\n      if (!a.isBuffer(B)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n      if (S &gt; Z || S &lt; Q) throw new RangeError('\"value\" argument is out of bounds');\n      if (T + G &gt; B.length) throw new RangeError(\"Index out of range\");\n    }\n    a.prototype.writeUintLE = a.prototype.writeUIntLE = function(S, T, G, Z) {\n      if (S = +S, T = T &gt;&gt;&gt; 0, G = G &gt;&gt;&gt; 0, !Z) {\n        const Ue = Math.pow(2, 8 * G) - 1;\n        m(this, S, T, G, Ue, 0);\n      }\n      let Q = 1, se = 0;\n      for (this[T] = S &amp; 255; ++se &lt; G &amp;&amp; (Q *= 256); )\n        this[T + se] = S / Q &amp; 255;\n      return T + G;\n    }, a.prototype.writeUintBE = a.prototype.writeUIntBE = function(S, T, G, Z) {\n      if (S = +S, T = T &gt;&gt;&gt; 0, G = G &gt;&gt;&gt; 0, !Z) {\n        const Ue = Math.pow(2, 8 * G) - 1;\n        m(this, S, T, G, Ue, 0);\n      }\n      let Q = G - 1, se = 1;\n      for (this[T + Q] = S &amp; 255; --Q &gt;= 0 &amp;&amp; (se *= 256); )\n        this[T + Q] = S / se &amp; 255;\n      return T + G;\n    }, a.prototype.writeUint8 = a.prototype.writeUInt8 = function(S, T, G) {\n      return S = +S, T = T &gt;&gt;&gt; 0, G || m(this, S, T, 1, 255, 0), this[T] = S &amp; 255, T + 1;\n    }, a.prototype.writeUint16LE = a.prototype.writeUInt16LE = function(S, T, G) {\n      return S = +S, T = T &gt;&gt;&gt; 0, G || m(this, S, T, 2, 65535, 0), this[T] = S &amp; 255, this[T + 1] = S &gt;&gt;&gt; 8, T + 2;\n    }, a.prototype.writeUint16BE = a.prototype.writeUInt16BE = function(S, T, G) {\n      return S = +S, T = T &gt;&gt;&gt; 0, G || m(this, S, T, 2, 65535, 0), this[T] = S &gt;&gt;&gt; 8, this[T + 1] = S &amp; 255, T + 2;\n    }, a.prototype.writeUint32LE = a.prototype.writeUInt32LE = function(S, T, G) {\n      return S = +S, T = T &gt;&gt;&gt; 0, G || m(this, S, T, 4, 4294967295, 0), this[T + 3] = S &gt;&gt;&gt; 24, this[T + 2] = S &gt;&gt;&gt; 16, this[T + 1] = S &gt;&gt;&gt; 8, this[T] = S &amp; 255, T + 4;\n    }, a.prototype.writeUint32BE = a.prototype.writeUInt32BE = function(S, T, G) {\n      return S = +S, T = T &gt;&gt;&gt; 0, G || m(this, S, T, 4, 4294967295, 0), this[T] = S &gt;&gt;&gt; 24, this[T + 1] = S &gt;&gt;&gt; 16, this[T + 2] = S &gt;&gt;&gt; 8, this[T + 3] = S &amp; 255, T + 4;\n    };\n    function v(B, S, T, G, Z) {\n      ze(S, G, Z, B, T, 7);\n      let Q = Number(S &amp; BigInt(4294967295));\n      B[T++] = Q, Q = Q &gt;&gt; 8, B[T++] = Q, Q = Q &gt;&gt; 8, B[T++] = Q, Q = Q &gt;&gt; 8, B[T++] = Q;\n      let se = Number(S &gt;&gt; BigInt(32) &amp; BigInt(4294967295));\n      return B[T++] = se, se = se &gt;&gt; 8, B[T++] = se, se = se &gt;&gt; 8, B[T++] = se, se = se &gt;&gt; 8, B[T++] = se, T;\n    }\n    function P(B, S, T, G, Z) {\n      ze(S, G, Z, B, T, 7);\n      let Q = Number(S &amp; BigInt(4294967295));\n      B[T + 7] = Q, Q = Q &gt;&gt; 8, B[T + 6] = Q, Q = Q &gt;&gt; 8, B[T + 5] = Q, Q = Q &gt;&gt; 8, B[T + 4] = Q;\n      let se = Number(S &gt;&gt; BigInt(32) &amp; BigInt(4294967295));\n      return B[T + 3] = se, se = se &gt;&gt; 8, B[T + 2] = se, se = se &gt;&gt; 8, B[T + 1] = se, se = se &gt;&gt; 8, B[T] = se, T + 8;\n    }\n    a.prototype.writeBigUInt64LE = it(function(S, T = 0) {\n      return v(this, S, T, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    }), a.prototype.writeBigUInt64BE = it(function(S, T = 0) {\n      return P(this, S, T, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    }), a.prototype.writeIntLE = function(S, T, G, Z) {\n      if (S = +S, T = T &gt;&gt;&gt; 0, !Z) {\n        const Pe = Math.pow(2, 8 * G - 1);\n        m(this, S, T, G, Pe - 1, -Pe);\n      }\n      let Q = 0, se = 1, Ue = 0;\n      for (this[T] = S &amp; 255; ++Q &lt; G &amp;&amp; (se *= 256); )\n        S &lt; 0 &amp;&amp; Ue === 0 &amp;&amp; this[T + Q - 1] !== 0 &amp;&amp; (Ue = 1), this[T + Q] = (S / se &gt;&gt; 0) - Ue &amp; 255;\n      return T + G;\n    }, a.prototype.writeIntBE = function(S, T, G, Z) {\n      if (S = +S, T = T &gt;&gt;&gt; 0, !Z) {\n        const Pe = Math.pow(2, 8 * G - 1);\n        m(this, S, T, G, Pe - 1, -Pe);\n      }\n      let Q = G - 1, se = 1, Ue = 0;\n      for (this[T + Q] = S &amp; 255; --Q &gt;= 0 &amp;&amp; (se *= 256); )\n        S &lt; 0 &amp;&amp; Ue === 0 &amp;&amp; this[T + Q + 1] !== 0 &amp;&amp; (Ue = 1), this[T + Q] = (S / se &gt;&gt; 0) - Ue &amp; 255;\n      return T + G;\n    }, a.prototype.writeInt8 = function(S, T, G) {\n      return S = +S, T = T &gt;&gt;&gt; 0, G || m(this, S, T, 1, 127, -128), S &lt; 0 &amp;&amp; (S = 255 + S + 1), this[T] = S &amp; 255, T + 1;\n    }, a.prototype.writeInt16LE = function(S, T, G) {\n      return S = +S, T = T &gt;&gt;&gt; 0, G || m(this, S, T, 2, 32767, -32768), this[T] = S &amp; 255, this[T + 1] = S &gt;&gt;&gt; 8, T + 2;\n    }, a.prototype.writeInt16BE = function(S, T, G) {\n      return S = +S, T = T &gt;&gt;&gt; 0, G || m(this, S, T, 2, 32767, -32768), this[T] = S &gt;&gt;&gt; 8, this[T + 1] = S &amp; 255, T + 2;\n    }, a.prototype.writeInt32LE = function(S, T, G) {\n      return S = +S, T = T &gt;&gt;&gt; 0, G || m(this, S, T, 4, 2147483647, -2147483648), this[T] = S &amp; 255, this[T + 1] = S &gt;&gt;&gt; 8, this[T + 2] = S &gt;&gt;&gt; 16, this[T + 3] = S &gt;&gt;&gt; 24, T + 4;\n    }, a.prototype.writeInt32BE = function(S, T, G) {\n      return S = +S, T = T &gt;&gt;&gt; 0, G || m(this, S, T, 4, 2147483647, -2147483648), S &lt; 0 &amp;&amp; (S = 4294967295 + S + 1), this[T] = S &gt;&gt;&gt; 24, this[T + 1] = S &gt;&gt;&gt; 16, this[T + 2] = S &gt;&gt;&gt; 8, this[T + 3] = S &amp; 255, T + 4;\n    }, a.prototype.writeBigInt64LE = it(function(S, T = 0) {\n      return v(this, S, T, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    }), a.prototype.writeBigInt64BE = it(function(S, T = 0) {\n      return P(this, S, T, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    });\n    function N(B, S, T, G, Z, Q) {\n      if (T + G &gt; B.length) throw new RangeError(\"Index out of range\");\n      if (T &lt; 0) throw new RangeError(\"Index out of range\");\n    }\n    function Y(B, S, T, G, Z) {\n      return S = +S, T = T &gt;&gt;&gt; 0, Z || N(B, S, T, 4), t.write(B, S, T, G, 23, 4), T + 4;\n    }\n    a.prototype.writeFloatLE = function(S, T, G) {\n      return Y(this, S, T, !0, G);\n    }, a.prototype.writeFloatBE = function(S, T, G) {\n      return Y(this, S, T, !1, G);\n    };\n    function ee(B, S, T, G, Z) {\n      return S = +S, T = T &gt;&gt;&gt; 0, Z || N(B, S, T, 8), t.write(B, S, T, G, 52, 8), T + 8;\n    }\n    a.prototype.writeDoubleLE = function(S, T, G) {\n      return ee(this, S, T, !0, G);\n    }, a.prototype.writeDoubleBE = function(S, T, G) {\n      return ee(this, S, T, !1, G);\n    }, a.prototype.copy = function(S, T, G, Z) {\n      if (!a.isBuffer(S)) throw new TypeError(\"argument should be a Buffer\");\n      if (G || (G = 0), !Z &amp;&amp; Z !== 0 &amp;&amp; (Z = this.length), T &gt;= S.length &amp;&amp; (T = S.length), T || (T = 0), Z &gt; 0 &amp;&amp; Z &lt; G &amp;&amp; (Z = G), Z === G || S.length === 0 || this.length === 0) return 0;\n      if (T &lt; 0)\n        throw new RangeError(\"targetStart out of bounds\");\n      if (G &lt; 0 || G &gt;= this.length) throw new RangeError(\"Index out of range\");\n      if (Z &lt; 0) throw new RangeError(\"sourceEnd out of bounds\");\n      Z &gt; this.length &amp;&amp; (Z = this.length), S.length - T &lt; Z - G &amp;&amp; (Z = S.length - T + G);\n      const Q = Z - G;\n      return this === S &amp;&amp; typeof Uint8Array.prototype.copyWithin == \"function\" ? this.copyWithin(T, G, Z) : Uint8Array.prototype.set.call(\n        S,\n        this.subarray(G, Z),\n        T\n      ), Q;\n    }, a.prototype.fill = function(S, T, G, Z) {\n      if (typeof S == \"string\") {\n        if (typeof T == \"string\" ? (Z = T, T = 0, G = this.length) : typeof G == \"string\" &amp;&amp; (Z = G, G = this.length), Z !== void 0 &amp;&amp; typeof Z != \"string\")\n          throw new TypeError(\"encoding must be a string\");\n        if (typeof Z == \"string\" &amp;&amp; !a.isEncoding(Z))\n          throw new TypeError(\"Unknown encoding: \" + Z);\n        if (S.length === 1) {\n          const se = S.charCodeAt(0);\n          (Z === \"utf8\" &amp;&amp; se &lt; 128 || Z === \"latin1\") &amp;&amp; (S = se);\n        }\n      } else typeof S == \"number\" ? S = S &amp; 255 : typeof S == \"boolean\" &amp;&amp; (S = Number(S));\n      if (T &lt; 0 || this.length &lt; T || this.length &lt; G)\n        throw new RangeError(\"Out of range index\");\n      if (G &lt;= T)\n        return this;\n      T = T &gt;&gt;&gt; 0, G = G === void 0 ? this.length : G &gt;&gt;&gt; 0, S || (S = 0);\n      let Q;\n      if (typeof S == \"number\")\n        for (Q = T; Q &lt; G; ++Q)\n          this[Q] = S;\n      else {\n        const se = a.isBuffer(S) ? S : a.from(S, Z), Ue = se.length;\n        if (Ue === 0)\n          throw new TypeError('The value \"' + S + '\" is invalid for argument \"value\"');\n        for (Q = 0; Q &lt; G - T; ++Q)\n          this[Q + T] = se[Q % Ue];\n      }\n      return this;\n    };\n    const ie = {};\n    function le(B, S, T) {\n      ie[B] = class extends T {\n        constructor() {\n          super(), Object.defineProperty(this, \"message\", {\n            value: S.apply(this, arguments),\n            writable: !0,\n            configurable: !0\n          }), this.name = `${this.name} [${B}]`, this.stack, delete this.name;\n        }\n        get code() {\n          return B;\n        }\n        set code(Z) {\n          Object.defineProperty(this, \"code\", {\n            configurable: !0,\n            enumerable: !0,\n            value: Z,\n            writable: !0\n          });\n        }\n        toString() {\n          return `${this.name} [${B}]: ${this.message}`;\n        }\n      };\n    }\n    le(\n      \"ERR_BUFFER_OUT_OF_BOUNDS\",\n      function(B) {\n        return B ? `${B} is outside of buffer bounds` : \"Attempt to access memory outside buffer bounds\";\n      },\n      RangeError\n    ), le(\n      \"ERR_INVALID_ARG_TYPE\",\n      function(B, S) {\n        return `The \"${B}\" argument must be of type number. Received type ${typeof S}`;\n      },\n      TypeError\n    ), le(\n      \"ERR_OUT_OF_RANGE\",\n      function(B, S, T) {\n        let G = `The value of \"${B}\" is out of range.`, Z = T;\n        return Number.isInteger(T) &amp;&amp; Math.abs(T) &gt; 2 ** 32 ? Z = Te(String(T)) : typeof T == \"bigint\" &amp;&amp; (Z = String(T), (T &gt; BigInt(2) ** BigInt(32) || T &lt; -(BigInt(2) ** BigInt(32))) &amp;&amp; (Z = Te(Z)), Z += \"n\"), G += ` It must be ${S}. Received ${Z}`, G;\n      },\n      RangeError\n    );\n    function Te(B) {\n      let S = \"\", T = B.length;\n      const G = B[0] === \"-\" ? 1 : 0;\n      for (; T &gt;= G + 4; T -= 3)\n        S = `_${B.slice(T - 3, T)}${S}`;\n      return `${B.slice(0, T)}${S}`;\n    }\n    function De(B, S, T) {\n      _e(S, \"offset\"), (B[S] === void 0 || B[S + T] === void 0) &amp;&amp; xe(S, B.length - (T + 1));\n    }\n    function ze(B, S, T, G, Z, Q) {\n      if (B &gt; T || B &lt; S) {\n        const se = typeof S == \"bigint\" ? \"n\" : \"\";\n        let Ue;\n        throw S === 0 || S === BigInt(0) ? Ue = `&gt;= 0${se} and &lt; 2${se} ** ${(Q + 1) * 8}${se}` : Ue = `&gt;= -(2${se} ** ${(Q + 1) * 8 - 1}${se}) and &lt; 2 ** ${(Q + 1) * 8 - 1}${se}`, new ie.ERR_OUT_OF_RANGE(\"value\", Ue, B);\n      }\n      De(G, Z, Q);\n    }\n    function _e(B, S) {\n      if (typeof B != \"number\")\n        throw new ie.ERR_INVALID_ARG_TYPE(S, \"number\", B);\n    }\n    function xe(B, S, T) {\n      throw Math.floor(B) !== B ? (_e(B, T), new ie.ERR_OUT_OF_RANGE(\"offset\", \"an integer\", B)) : S &lt; 0 ? new ie.ERR_BUFFER_OUT_OF_BOUNDS() : new ie.ERR_OUT_OF_RANGE(\n        \"offset\",\n        `&gt;= 0 and &lt;= ${S}`,\n        B\n      );\n    }\n    const Be = /[^+/0-9A-Za-z-_]/g;\n    function ye(B) {\n      if (B = B.split(\"=\")[0], B = B.trim().replace(Be, \"\"), B.length &lt; 2) return \"\";\n      for (; B.length % 4 !== 0; )\n        B = B + \"=\";\n      return B;\n    }\n    function be(B, S) {\n      S = S || 1 / 0;\n      let T;\n      const G = B.length;\n      let Z = null;\n      const Q = [];\n      for (let se = 0; se &lt; G; ++se) {\n        if (T = B.charCodeAt(se), T &gt; 55295 &amp;&amp; T &lt; 57344) {\n          if (!Z) {\n            if (T &gt; 56319) {\n              (S -= 3) &gt; -1 &amp;&amp; Q.push(239, 191, 189);\n              continue;\n            } else if (se + 1 === G) {\n              (S -= 3) &gt; -1 &amp;&amp; Q.push(239, 191, 189);\n              continue;\n            }\n            Z = T;\n            continue;\n          }\n          if (T &lt; 56320) {\n            (S -= 3) &gt; -1 &amp;&amp; Q.push(239, 191, 189), Z = T;\n            continue;\n          }\n          T = (Z - 55296 &lt;&lt; 10 | T - 56320) + 65536;\n        } else Z &amp;&amp; (S -= 3) &gt; -1 &amp;&amp; Q.push(239, 191, 189);\n        if (Z = null, T &lt; 128) {\n          if ((S -= 1) &lt; 0) break;\n          Q.push(T);\n        } else if (T &lt; 2048) {\n          if ((S -= 2) &lt; 0) break;\n          Q.push(\n            T &gt;&gt; 6 | 192,\n            T &amp; 63 | 128\n          );\n        } else if (T &lt; 65536) {\n          if ((S -= 3) &lt; 0) break;\n          Q.push(\n            T &gt;&gt; 12 | 224,\n            T &gt;&gt; 6 &amp; 63 | 128,\n            T &amp; 63 | 128\n          );\n        } else if (T &lt; 1114112) {\n          if ((S -= 4) &lt; 0) break;\n          Q.push(\n            T &gt;&gt; 18 | 240,\n            T &gt;&gt; 12 &amp; 63 | 128,\n            T &gt;&gt; 6 &amp; 63 | 128,\n            T &amp; 63 | 128\n          );\n        } else\n          throw new Error(\"Invalid code point\");\n      }\n      return Q;\n    }\n    function Fe(B) {\n      const S = [];\n      for (let T = 0; T &lt; B.length; ++T)\n        S.push(B.charCodeAt(T) &amp; 255);\n      return S;\n    }\n    function Xe(B, S) {\n      let T, G, Z;\n      const Q = [];\n      for (let se = 0; se &lt; B.length &amp;&amp; !((S -= 2) &lt; 0); ++se)\n        T = B.charCodeAt(se), G = T &gt;&gt; 8, Z = T % 256, Q.push(Z), Q.push(G);\n      return Q;\n    }\n    function we(B) {\n      return e.toByteArray(ye(B));\n    }\n    function Ne(B, S, T, G) {\n      let Z;\n      for (Z = 0; Z &lt; G &amp;&amp; !(Z + T &gt;= S.length || Z &gt;= B.length); ++Z)\n        S[Z + T] = B[Z];\n      return Z;\n    }\n    function dt(B, S) {\n      return B instanceof S || B != null &amp;&amp; B.constructor != null &amp;&amp; B.constructor.name != null &amp;&amp; B.constructor.name === S.name;\n    }\n    function Je(B) {\n      return B !== B;\n    }\n    const Qe = (function() {\n      const B = \"0123456789abcdef\", S = new Array(256);\n      for (let T = 0; T &lt; 16; ++T) {\n        const G = T * 16;\n        for (let Z = 0; Z &lt; 16; ++Z)\n          S[G + Z] = B[T] + B[Z];\n      }\n      return S;\n    })();\n    function it(B) {\n      return typeof BigInt &gt; \"u\" ? je : B;\n    }\n    function je() {\n      throw new Error(\"BigInt not supported\");\n    }\n  })(Ga)), Ga;\n}\nvar He = Kc();\nconst ln = typeof globalThis == \"object\" &amp;&amp; \"crypto\" in globalThis ? globalThis.crypto : void 0;\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction Ii(s) {\n  return s instanceof Uint8Array || ArrayBuffer.isView(s) &amp;&amp; s.constructor.name === \"Uint8Array\";\n}\nfunction Xl(s) {\n  if (!Number.isSafeInteger(s) || s &lt; 0)\n    throw new Error(\"positive integer expected, got \" + s);\n}\nfunction Qs(s, ...e) {\n  if (!Ii(s))\n    throw new Error(\"Uint8Array expected\");\n  if (e.length &gt; 0 &amp;&amp; !e.includes(s.length))\n    throw new Error(\"Uint8Array expected of length \" + e + \", got length=\" + s.length);\n}\nfunction Hf(s) {\n  if (typeof s != \"function\" || typeof s.create != \"function\")\n    throw new Error(\"Hash should be wrapped by utils.createHasher\");\n  Xl(s.outputLen), Xl(s.blockLen);\n}\nfunction Do(s, e = !0) {\n  if (s.destroyed)\n    throw new Error(\"Hash instance has been destroyed\");\n  if (e &amp;&amp; s.finished)\n    throw new Error(\"Hash#digest() has already been called\");\n}\nfunction O1(s, e) {\n  Qs(s);\n  const t = e.outputLen;\n  if (s.length &lt; t)\n    throw new Error(\"digestInto() expects output buffer of length at least \" + t);\n}\nfunction kn(...s) {\n  for (let e = 0; e &lt; s.length; e++)\n    s[e].fill(0);\n}\nfunction Va(s) {\n  return new DataView(s.buffer, s.byteOffset, s.byteLength);\n}\nfunction Nr(s, e) {\n  return s &lt;&lt; 32 - e | s &gt;&gt;&gt; e;\n}\nconst qf = /* @ts-ignore */ typeof Uint8Array.from([]).toHex == \"function\" &amp;&amp; typeof Uint8Array.fromHex == \"function\", B1 = /* @__PURE__ */ Array.from({ length: 256 }, (s, e) =&gt; e.toString(16).padStart(2, \"0\"));\nfunction Hs(s) {\n  if (Qs(s), qf)\n    return s.toHex();\n  let e = \"\";\n  for (let t = 0; t &lt; s.length; t++)\n    e += B1[s[t]];\n  return e;\n}\nconst rs = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction cd(s) {\n  if (s &gt;= rs._0 &amp;&amp; s &lt;= rs._9)\n    return s - rs._0;\n  if (s &gt;= rs.A &amp;&amp; s &lt;= rs.F)\n    return s - (rs.A - 10);\n  if (s &gt;= rs.a &amp;&amp; s &lt;= rs.f)\n    return s - (rs.a - 10);\n}\nfunction Po(s) {\n  if (typeof s != \"string\")\n    throw new Error(\"hex string expected, got \" + typeof s);\n  if (qf)\n    return Uint8Array.fromHex(s);\n  const e = s.length, t = e / 2;\n  if (e % 2)\n    throw new Error(\"hex string expected, got unpadded hex of length \" + e);\n  const r = new Uint8Array(t);\n  for (let n = 0, i = 0; n &lt; t; n++, i += 2) {\n    const o = cd(s.charCodeAt(i)), a = cd(s.charCodeAt(i + 1));\n    if (o === void 0 || a === void 0) {\n      const l = s[i] + s[i + 1];\n      throw new Error('hex string expected, got non-hex character \"' + l + '\" at index ' + i);\n    }\n    r[n] = o * 16 + a;\n  }\n  return r;\n}\nfunction F1(s) {\n  if (typeof s != \"string\")\n    throw new Error(\"string expected\");\n  return new Uint8Array(new TextEncoder().encode(s));\n}\nfunction Hc(s) {\n  return typeof s == \"string\" &amp;&amp; (s = F1(s)), Qs(s), s;\n}\nfunction Kr(...s) {\n  let e = 0;\n  for (let r = 0; r &lt; s.length; r++) {\n    const n = s[r];\n    Qs(n), e += n.length;\n  }\n  const t = new Uint8Array(e);\n  for (let r = 0, n = 0; r &lt; s.length; r++) {\n    const i = s[r];\n    t.set(i, n), n += i.length;\n  }\n  return t;\n}\nclass Wf {\n}\nfunction zf(s) {\n  const e = (r) =&gt; s().update(Hc(r)).digest(), t = s();\n  return e.outputLen = t.outputLen, e.blockLen = t.blockLen, e.create = () =&gt; s(), e;\n}\nfunction qc(s = 32) {\n  if (ln &amp;&amp; typeof ln.getRandomValues == \"function\")\n    return ln.getRandomValues(new Uint8Array(s));\n  if (ln &amp;&amp; typeof ln.randomBytes == \"function\")\n    return Uint8Array.from(ln.randomBytes(s));\n  throw new Error(\"crypto.getRandomValues must be defined\");\n}\nfunction N1(s, e, t, r) {\n  if (typeof s.setBigUint64 == \"function\")\n    return s.setBigUint64(e, t, r);\n  const n = BigInt(32), i = BigInt(4294967295), o = Number(t &gt;&gt; n &amp; i), a = Number(t &amp; i), l = r ? 4 : 0, c = r ? 0 : 4;\n  s.setUint32(e + l, o, r), s.setUint32(e + c, a, r);\n}\nfunction U1(s, e, t) {\n  return s &amp; e ^ ~s &amp; t;\n}\nfunction $1(s, e, t) {\n  return s &amp; e ^ s &amp; t ^ e &amp; t;\n}\nclass Yf extends Wf {\n  constructor(e, t, r, n) {\n    super(), this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.blockLen = e, this.outputLen = t, this.padOffset = r, this.isLE = n, this.buffer = new Uint8Array(e), this.view = Va(this.buffer);\n  }\n  update(e) {\n    Do(this), e = Hc(e), Qs(e);\n    const { view: t, buffer: r, blockLen: n } = this, i = e.length;\n    for (let o = 0; o &lt; i; ) {\n      const a = Math.min(n - this.pos, i - o);\n      if (a === n) {\n        const l = Va(e);\n        for (; n &lt;= i - o; o += n)\n          this.process(l, o);\n        continue;\n      }\n      r.set(e.subarray(o, o + a), this.pos), this.pos += a, o += a, this.pos === n &amp;&amp; (this.process(t, 0), this.pos = 0);\n    }\n    return this.length += e.length, this.roundClean(), this;\n  }\n  digestInto(e) {\n    Do(this), O1(e, this), this.finished = !0;\n    const { buffer: t, view: r, blockLen: n, isLE: i } = this;\n    let { pos: o } = this;\n    t[o++] = 128, kn(this.buffer.subarray(o)), this.padOffset &gt; n - o &amp;&amp; (this.process(r, 0), o = 0);\n    for (let d = o; d &lt; n; d++)\n      t[d] = 0;\n    N1(r, n - 8, BigInt(this.length * 8), i), this.process(r, 0);\n    const a = Va(e), l = this.outputLen;\n    if (l % 4)\n      throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n    const c = l / 4, u = this.get();\n    if (c &gt; u.length)\n      throw new Error(\"_sha2: outputLen bigger than state\");\n    for (let d = 0; d &lt; c; d++)\n      a.setUint32(4 * d, u[d], i);\n  }\n  digest() {\n    const { buffer: e, outputLen: t } = this;\n    this.digestInto(e);\n    const r = e.slice(0, t);\n    return this.destroy(), r;\n  }\n  _cloneInto(e) {\n    e || (e = new this.constructor()), e.set(...this.get());\n    const { blockLen: t, buffer: r, length: n, finished: i, destroyed: o, pos: a } = this;\n    return e.destroyed = o, e.finished = i, e.length = n, e.pos = a, n % t &amp;&amp; e.buffer.set(r), e;\n  }\n  clone() {\n    return this._cloneInto();\n  }\n}\nconst ms = /* @__PURE__ */ Uint32Array.from([\n  1779033703,\n  3144134277,\n  1013904242,\n  2773480762,\n  1359893119,\n  2600822924,\n  528734635,\n  1541459225\n]), Qt = /* @__PURE__ */ Uint32Array.from([\n  1779033703,\n  4089235720,\n  3144134277,\n  2227873595,\n  1013904242,\n  4271175723,\n  2773480762,\n  1595750129,\n  1359893119,\n  2917565137,\n  2600822924,\n  725511199,\n  528734635,\n  4215389547,\n  1541459225,\n  327033209\n]), Oi = /* @__PURE__ */ BigInt(2 ** 32 - 1), ud = /* @__PURE__ */ BigInt(32);\nfunction G1(s, e = !1) {\n  return e ? { h: Number(s &amp; Oi), l: Number(s &gt;&gt; ud &amp; Oi) } : { h: Number(s &gt;&gt; ud &amp; Oi) | 0, l: Number(s &amp; Oi) | 0 };\n}\nfunction V1(s, e = !1) {\n  const t = s.length;\n  let r = new Uint32Array(t), n = new Uint32Array(t);\n  for (let i = 0; i &lt; t; i++) {\n    const { h: o, l: a } = G1(s[i], e);\n    [r[i], n[i]] = [o, a];\n  }\n  return [r, n];\n}\nconst dd = (s, e, t) =&gt; s &gt;&gt;&gt; t, hd = (s, e, t) =&gt; s &lt;&lt; 32 - t | e &gt;&gt;&gt; t, cn = (s, e, t) =&gt; s &gt;&gt;&gt; t | e &lt;&lt; 32 - t, un = (s, e, t) =&gt; s &lt;&lt; 32 - t | e &gt;&gt;&gt; t, Bi = (s, e, t) =&gt; s &lt;&lt; 64 - t | e &gt;&gt;&gt; t - 32, Fi = (s, e, t) =&gt; s &gt;&gt;&gt; t - 32 | e &lt;&lt; 64 - t;\nfunction ss(s, e, t, r) {\n  const n = (e &gt;&gt;&gt; 0) + (r &gt;&gt;&gt; 0);\n  return { h: s + t + (n / 2 ** 32 | 0) | 0, l: n | 0 };\n}\nconst j1 = (s, e, t) =&gt; (s &gt;&gt;&gt; 0) + (e &gt;&gt;&gt; 0) + (t &gt;&gt;&gt; 0), K1 = (s, e, t, r) =&gt; e + t + r + (s / 2 ** 32 | 0) | 0, H1 = (s, e, t, r) =&gt; (s &gt;&gt;&gt; 0) + (e &gt;&gt;&gt; 0) + (t &gt;&gt;&gt; 0) + (r &gt;&gt;&gt; 0), q1 = (s, e, t, r, n) =&gt; e + t + r + n + (s / 2 ** 32 | 0) | 0, W1 = (s, e, t, r, n) =&gt; (s &gt;&gt;&gt; 0) + (e &gt;&gt;&gt; 0) + (t &gt;&gt;&gt; 0) + (r &gt;&gt;&gt; 0) + (n &gt;&gt;&gt; 0), z1 = (s, e, t, r, n, i) =&gt; e + t + r + n + i + (s / 2 ** 32 | 0) | 0, Y1 = /* @__PURE__ */ Uint32Array.from([\n  1116352408,\n  1899447441,\n  3049323471,\n  3921009573,\n  961987163,\n  1508970993,\n  2453635748,\n  2870763221,\n  3624381080,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  2162078206,\n  2614888103,\n  3248222580,\n  3835390401,\n  4022224774,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  2554220882,\n  2821834349,\n  2952996808,\n  3210313671,\n  3336571891,\n  3584528711,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  2177026350,\n  2456956037,\n  2730485921,\n  2820302411,\n  3259730800,\n  3345764771,\n  3516065817,\n  3600352804,\n  4094571909,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  2227730452,\n  2361852424,\n  2428436474,\n  2756734187,\n  3204031479,\n  3329325298\n]), ys = /* @__PURE__ */ new Uint32Array(64);\nclass Z1 extends Yf {\n  constructor(e = 32) {\n    super(64, e, 8, !1), this.A = ms[0] | 0, this.B = ms[1] | 0, this.C = ms[2] | 0, this.D = ms[3] | 0, this.E = ms[4] | 0, this.F = ms[5] | 0, this.G = ms[6] | 0, this.H = ms[7] | 0;\n  }\n  get() {\n    const { A: e, B: t, C: r, D: n, E: i, F: o, G: a, H: l } = this;\n    return [e, t, r, n, i, o, a, l];\n  }\n  // prettier-ignore\n  set(e, t, r, n, i, o, a, l) {\n    this.A = e | 0, this.B = t | 0, this.C = r | 0, this.D = n | 0, this.E = i | 0, this.F = o | 0, this.G = a | 0, this.H = l | 0;\n  }\n  process(e, t) {\n    for (let d = 0; d &lt; 16; d++, t += 4)\n      ys[d] = e.getUint32(t, !1);\n    for (let d = 16; d &lt; 64; d++) {\n      const h = ys[d - 15], f = ys[d - 2], p = Nr(h, 7) ^ Nr(h, 18) ^ h &gt;&gt;&gt; 3, y = Nr(f, 17) ^ Nr(f, 19) ^ f &gt;&gt;&gt; 10;\n      ys[d] = y + ys[d - 7] + p + ys[d - 16] | 0;\n    }\n    let { A: r, B: n, C: i, D: o, E: a, F: l, G: c, H: u } = this;\n    for (let d = 0; d &lt; 64; d++) {\n      const h = Nr(a, 6) ^ Nr(a, 11) ^ Nr(a, 25), f = u + h + U1(a, l, c) + Y1[d] + ys[d] | 0, y = (Nr(r, 2) ^ Nr(r, 13) ^ Nr(r, 22)) + $1(r, n, i) | 0;\n      u = c, c = l, l = a, a = o + f | 0, o = i, i = n, n = r, r = f + y | 0;\n    }\n    r = r + this.A | 0, n = n + this.B | 0, i = i + this.C | 0, o = o + this.D | 0, a = a + this.E | 0, l = l + this.F | 0, c = c + this.G | 0, u = u + this.H | 0, this.set(r, n, i, o, a, l, c, u);\n  }\n  roundClean() {\n    kn(ys);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0), kn(this.buffer);\n  }\n}\nconst Zf = V1([\n  \"0x428a2f98d728ae22\",\n  \"0x7137449123ef65cd\",\n  \"0xb5c0fbcfec4d3b2f\",\n  \"0xe9b5dba58189dbbc\",\n  \"0x3956c25bf348b538\",\n  \"0x59f111f1b605d019\",\n  \"0x923f82a4af194f9b\",\n  \"0xab1c5ed5da6d8118\",\n  \"0xd807aa98a3030242\",\n  \"0x12835b0145706fbe\",\n  \"0x243185be4ee4b28c\",\n  \"0x550c7dc3d5ffb4e2\",\n  \"0x72be5d74f27b896f\",\n  \"0x80deb1fe3b1696b1\",\n  \"0x9bdc06a725c71235\",\n  \"0xc19bf174cf692694\",\n  \"0xe49b69c19ef14ad2\",\n  \"0xefbe4786384f25e3\",\n  \"0x0fc19dc68b8cd5b5\",\n  \"0x240ca1cc77ac9c65\",\n  \"0x2de92c6f592b0275\",\n  \"0x4a7484aa6ea6e483\",\n  \"0x5cb0a9dcbd41fbd4\",\n  \"0x76f988da831153b5\",\n  \"0x983e5152ee66dfab\",\n  \"0xa831c66d2db43210\",\n  \"0xb00327c898fb213f\",\n  \"0xbf597fc7beef0ee4\",\n  \"0xc6e00bf33da88fc2\",\n  \"0xd5a79147930aa725\",\n  \"0x06ca6351e003826f\",\n  \"0x142929670a0e6e70\",\n  \"0x27b70a8546d22ffc\",\n  \"0x2e1b21385c26c926\",\n  \"0x4d2c6dfc5ac42aed\",\n  \"0x53380d139d95b3df\",\n  \"0x650a73548baf63de\",\n  \"0x766a0abb3c77b2a8\",\n  \"0x81c2c92e47edaee6\",\n  \"0x92722c851482353b\",\n  \"0xa2bfe8a14cf10364\",\n  \"0xa81a664bbc423001\",\n  \"0xc24b8b70d0f89791\",\n  \"0xc76c51a30654be30\",\n  \"0xd192e819d6ef5218\",\n  \"0xd69906245565a910\",\n  \"0xf40e35855771202a\",\n  \"0x106aa07032bbd1b8\",\n  \"0x19a4c116b8d2d0c8\",\n  \"0x1e376c085141ab53\",\n  \"0x2748774cdf8eeb99\",\n  \"0x34b0bcb5e19b48a8\",\n  \"0x391c0cb3c5c95a63\",\n  \"0x4ed8aa4ae3418acb\",\n  \"0x5b9cca4f7763e373\",\n  \"0x682e6ff3d6b2b8a3\",\n  \"0x748f82ee5defb2fc\",\n  \"0x78a5636f43172f60\",\n  \"0x84c87814a1f0ab72\",\n  \"0x8cc702081a6439ec\",\n  \"0x90befffa23631e28\",\n  \"0xa4506cebde82bde9\",\n  \"0xbef9a3f7b2c67915\",\n  \"0xc67178f2e372532b\",\n  \"0xca273eceea26619c\",\n  \"0xd186b8c721c0c207\",\n  \"0xeada7dd6cde0eb1e\",\n  \"0xf57d4f7fee6ed178\",\n  \"0x06f067aa72176fba\",\n  \"0x0a637dc5a2c898a6\",\n  \"0x113f9804bef90dae\",\n  \"0x1b710b35131c471b\",\n  \"0x28db77f523047d84\",\n  \"0x32caab7b40c72493\",\n  \"0x3c9ebe0a15c9bebc\",\n  \"0x431d67c49c100d4c\",\n  \"0x4cc5d4becb3e42b6\",\n  \"0x597f299cfc657e2a\",\n  \"0x5fcb6fab3ad6faec\",\n  \"0x6c44198c4a475817\"\n].map((s) =&gt; BigInt(s))), X1 = Zf[0], J1 = Zf[1], vs = /* @__PURE__ */ new Uint32Array(80), Es = /* @__PURE__ */ new Uint32Array(80);\nclass Q1 extends Yf {\n  constructor(e = 64) {\n    super(128, e, 16, !1), this.Ah = Qt[0] | 0, this.Al = Qt[1] | 0, this.Bh = Qt[2] | 0, this.Bl = Qt[3] | 0, this.Ch = Qt[4] | 0, this.Cl = Qt[5] | 0, this.Dh = Qt[6] | 0, this.Dl = Qt[7] | 0, this.Eh = Qt[8] | 0, this.El = Qt[9] | 0, this.Fh = Qt[10] | 0, this.Fl = Qt[11] | 0, this.Gh = Qt[12] | 0, this.Gl = Qt[13] | 0, this.Hh = Qt[14] | 0, this.Hl = Qt[15] | 0;\n  }\n  // prettier-ignore\n  get() {\n    const { Ah: e, Al: t, Bh: r, Bl: n, Ch: i, Cl: o, Dh: a, Dl: l, Eh: c, El: u, Fh: d, Fl: h, Gh: f, Gl: p, Hh: y, Hl: E } = this;\n    return [e, t, r, n, i, o, a, l, c, u, d, h, f, p, y, E];\n  }\n  // prettier-ignore\n  set(e, t, r, n, i, o, a, l, c, u, d, h, f, p, y, E) {\n    this.Ah = e | 0, this.Al = t | 0, this.Bh = r | 0, this.Bl = n | 0, this.Ch = i | 0, this.Cl = o | 0, this.Dh = a | 0, this.Dl = l | 0, this.Eh = c | 0, this.El = u | 0, this.Fh = d | 0, this.Fl = h | 0, this.Gh = f | 0, this.Gl = p | 0, this.Hh = y | 0, this.Hl = E | 0;\n  }\n  process(e, t) {\n    for (let A = 0; A &lt; 16; A++, t += 4)\n      vs[A] = e.getUint32(t), Es[A] = e.getUint32(t += 4);\n    for (let A = 16; A &lt; 80; A++) {\n      const F = vs[A - 15] | 0, M = Es[A - 15] | 0, H = cn(F, M, 1) ^ cn(F, M, 8) ^ dd(F, M, 7), K = un(F, M, 1) ^ un(F, M, 8) ^ hd(F, M, 7), j = vs[A - 2] | 0, C = Es[A - 2] | 0, k = cn(j, C, 19) ^ Bi(j, C, 61) ^ dd(j, C, 6), $ = un(j, C, 19) ^ Fi(j, C, 61) ^ hd(j, C, 6), W = H1(K, $, Es[A - 7], Es[A - 16]), _ = q1(W, H, k, vs[A - 7], vs[A - 16]);\n      vs[A] = _ | 0, Es[A] = W | 0;\n    }\n    let { Ah: r, Al: n, Bh: i, Bl: o, Ch: a, Cl: l, Dh: c, Dl: u, Eh: d, El: h, Fh: f, Fl: p, Gh: y, Gl: E, Hh: b, Hl: R } = this;\n    for (let A = 0; A &lt; 80; A++) {\n      const F = cn(d, h, 14) ^ cn(d, h, 18) ^ Bi(d, h, 41), M = un(d, h, 14) ^ un(d, h, 18) ^ Fi(d, h, 41), H = d &amp; f ^ ~d &amp; y, K = h &amp; p ^ ~h &amp; E, j = W1(R, M, K, J1[A], Es[A]), C = z1(j, b, F, H, X1[A], vs[A]), k = j | 0, $ = cn(r, n, 28) ^ Bi(r, n, 34) ^ Bi(r, n, 39), W = un(r, n, 28) ^ Fi(r, n, 34) ^ Fi(r, n, 39), _ = r &amp; i ^ r &amp; a ^ i &amp; a, g = n &amp; o ^ n &amp; l ^ o &amp; l;\n      b = y | 0, R = E | 0, y = f | 0, E = p | 0, f = d | 0, p = h | 0, { h: d, l: h } = ss(c | 0, u | 0, C | 0, k | 0), c = a | 0, u = l | 0, a = i | 0, l = o | 0, i = r | 0, o = n | 0;\n      const x = j1(k, W, g);\n      r = K1(x, C, $, _), n = x | 0;\n    }\n    ({ h: r, l: n } = ss(this.Ah | 0, this.Al | 0, r | 0, n | 0)), { h: i, l: o } = ss(this.Bh | 0, this.Bl | 0, i | 0, o | 0), { h: a, l } = ss(this.Ch | 0, this.Cl | 0, a | 0, l | 0), { h: c, l: u } = ss(this.Dh | 0, this.Dl | 0, c | 0, u | 0), { h: d, l: h } = ss(this.Eh | 0, this.El | 0, d | 0, h | 0), { h: f, l: p } = ss(this.Fh | 0, this.Fl | 0, f | 0, p | 0), { h: y, l: E } = ss(this.Gh | 0, this.Gl | 0, y | 0, E | 0), { h: b, l: R } = ss(this.Hh | 0, this.Hl | 0, b | 0, R | 0), this.set(r, n, i, o, a, l, c, u, d, h, f, p, y, E, b, R);\n  }\n  roundClean() {\n    kn(vs, Es);\n  }\n  destroy() {\n    kn(this.buffer), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\nconst Xf = /* @__PURE__ */ zf(() =&gt; new Z1()), ey = /* @__PURE__ */ zf(() =&gt; new Q1());\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst Wc = /* @__PURE__ */ BigInt(0), Jl = /* @__PURE__ */ BigInt(1);\nfunction Xs(s, e = \"\") {\n  if (typeof s != \"boolean\") {\n    const t = e &amp;&amp; `\"${e}\"`;\n    throw new Error(t + \"expected boolean, got type=\" + typeof s);\n  }\n  return s;\n}\nfunction Or(s, e, t = \"\") {\n  const r = Ii(s), n = s == null ? void 0 : s.length, i = e !== void 0;\n  if (!r || i &amp;&amp; n !== e) {\n    const o = t &amp;&amp; `\"${t}\" `, a = i ? ` of length ${e}` : \"\", l = r ? `length=${n}` : `type=${typeof s}`;\n    throw new Error(o + \"expected Uint8Array\" + a + \", got \" + l);\n  }\n  return s;\n}\nfunction Ni(s) {\n  const e = s.toString(16);\n  return e.length &amp; 1 ? \"0\" + e : e;\n}\nfunction Jf(s) {\n  if (typeof s != \"string\")\n    throw new Error(\"hex string expected, got \" + typeof s);\n  return s === \"\" ? Wc : BigInt(\"0x\" + s);\n}\nfunction la(s) {\n  return Jf(Hs(s));\n}\nfunction ei(s) {\n  return Qs(s), Jf(Hs(Uint8Array.from(s).reverse()));\n}\nfunction zc(s, e) {\n  return Po(s.toString(16).padStart(e * 2, \"0\"));\n}\nfunction Qf(s, e) {\n  return zc(s, e).reverse();\n}\nfunction Et(s, e, t) {\n  let r;\n  if (typeof e == \"string\")\n    try {\n      r = Po(e);\n    } catch (i) {\n      throw new Error(s + \" must be hex string or Uint8Array, cause: \" + i);\n    }\n  else if (Ii(e))\n    r = Uint8Array.from(e);\n  else\n    throw new Error(s + \" must be hex string or Uint8Array\");\n  const n = r.length;\n  if (typeof t == \"number\" &amp;&amp; n !== t)\n    throw new Error(s + \" of length \" + t + \" expected, got \" + n);\n  return r;\n}\nfunction fd(s) {\n  return Uint8Array.from(s);\n}\nconst ja = (s) =&gt; typeof s == \"bigint\" &amp;&amp; Wc &lt;= s;\nfunction ty(s, e, t) {\n  return ja(s) &amp;&amp; ja(e) &amp;&amp; ja(t) &amp;&amp; e &lt;= s &amp;&amp; s &lt; t;\n}\nfunction Ql(s, e, t, r) {\n  if (!ty(e, t, r))\n    throw new Error(\"expected valid \" + s + \": \" + t + \" &lt;= n &lt; \" + r + \", got \" + e);\n}\nfunction e0(s) {\n  let e;\n  for (e = 0; s &gt; Wc; s &gt;&gt;= Jl, e += 1)\n    ;\n  return e;\n}\nconst _i = (s) =&gt; (Jl &lt;&lt; BigInt(s)) - Jl;\nfunction ry(s, e, t) {\n  if (typeof s != \"number\" || s &lt; 2)\n    throw new Error(\"hashLen must be a number\");\n  if (typeof e != \"number\" || e &lt; 2)\n    throw new Error(\"qByteLen must be a number\");\n  if (typeof t != \"function\")\n    throw new Error(\"hmacFn must be a function\");\n  const r = (f) =&gt; new Uint8Array(f), n = (f) =&gt; Uint8Array.of(f);\n  let i = r(s), o = r(s), a = 0;\n  const l = () =&gt; {\n    i.fill(1), o.fill(0), a = 0;\n  }, c = (...f) =&gt; t(o, i, ...f), u = (f = r(0)) =&gt; {\n    o = c(n(0), f), i = c(), f.length !== 0 &amp;&amp; (o = c(n(1), f), i = c());\n  }, d = () =&gt; {\n    if (a++ &gt;= 1e3)\n      throw new Error(\"drbg: tried 1000 values\");\n    let f = 0;\n    const p = [];\n    for (; f &lt; e; ) {\n      i = c();\n      const y = i.slice();\n      p.push(y), f += i.length;\n    }\n    return Kr(...p);\n  };\n  return (f, p) =&gt; {\n    l(), u(f);\n    let y;\n    for (; !(y = p(d())); )\n      u();\n    return l(), y;\n  };\n}\nfunction Ri(s, e, t = {}) {\n  if (!s || typeof s != \"object\")\n    throw new Error(\"expected valid options object\");\n  function r(n, i, o) {\n    const a = s[n];\n    if (o &amp;&amp; a === void 0)\n      return;\n    const l = typeof a;\n    if (l !== i || a === null)\n      throw new Error(`param \"${n}\" is invalid: expected ${i}, got ${l}`);\n  }\n  Object.entries(e).forEach(([n, i]) =&gt; r(n, i, !1)), Object.entries(t).forEach(([n, i]) =&gt; r(n, i, !0));\n}\nfunction Mo(s) {\n  const e = /* @__PURE__ */ new WeakMap();\n  return (t, ...r) =&gt; {\n    const n = e.get(t);\n    if (n !== void 0)\n      return n;\n    const i = s(t, ...r);\n    return e.set(t, i), i;\n  };\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst gr = BigInt(0), Xt = BigInt(1), Gs = /* @__PURE__ */ BigInt(2), t0 = /* @__PURE__ */ BigInt(3), r0 = /* @__PURE__ */ BigInt(4), s0 = /* @__PURE__ */ BigInt(5), sy = /* @__PURE__ */ BigInt(7), n0 = /* @__PURE__ */ BigInt(8), ny = /* @__PURE__ */ BigInt(9), i0 = /* @__PURE__ */ BigInt(16);\nfunction Gt(s, e) {\n  const t = s % e;\n  return t &gt;= gr ? t : e + t;\n}\nfunction vt(s, e, t) {\n  let r = s;\n  for (; e-- &gt; gr; )\n    r *= r, r %= t;\n  return r;\n}\nfunction gd(s, e) {\n  if (s === gr)\n    throw new Error(\"invert: expected non-zero number\");\n  if (e &lt;= gr)\n    throw new Error(\"invert: expected positive modulus, got \" + e);\n  let t = Gt(s, e), r = e, n = gr, i = Xt;\n  for (; t !== gr; ) {\n    const a = r / t, l = r % t, c = n - i * a;\n    r = t, t = l, n = i, i = c;\n  }\n  if (r !== Xt)\n    throw new Error(\"invert: does not exist\");\n  return Gt(n, e);\n}\nfunction Yc(s, e, t) {\n  if (!s.eql(s.sqr(e), t))\n    throw new Error(\"Cannot find square root\");\n}\nfunction o0(s, e) {\n  const t = (s.ORDER + Xt) / r0, r = s.pow(e, t);\n  return Yc(s, r, e), r;\n}\nfunction iy(s, e) {\n  const t = (s.ORDER - s0) / n0, r = s.mul(e, Gs), n = s.pow(r, t), i = s.mul(e, n), o = s.mul(s.mul(i, Gs), n), a = s.mul(i, s.sub(o, s.ONE));\n  return Yc(s, a, e), a;\n}\nfunction oy(s) {\n  const e = en(s), t = a0(s), r = t(e, e.neg(e.ONE)), n = t(e, r), i = t(e, e.neg(r)), o = (s + sy) / i0;\n  return (a, l) =&gt; {\n    let c = a.pow(l, o), u = a.mul(c, r);\n    const d = a.mul(c, n), h = a.mul(c, i), f = a.eql(a.sqr(u), l), p = a.eql(a.sqr(d), l);\n    c = a.cmov(c, u, f), u = a.cmov(h, d, p);\n    const y = a.eql(a.sqr(u), l), E = a.cmov(c, u, y);\n    return Yc(a, E, l), E;\n  };\n}\nfunction a0(s) {\n  if (s &lt; t0)\n    throw new Error(\"sqrt is not defined for small field\");\n  let e = s - Xt, t = 0;\n  for (; e % Gs === gr; )\n    e /= Gs, t++;\n  let r = Gs;\n  const n = en(s);\n  for (; pd(n, r) === 1; )\n    if (r++ &gt; 1e3)\n      throw new Error(\"Cannot find square root: probably non-prime P\");\n  if (t === 1)\n    return o0;\n  let i = n.pow(r, e);\n  const o = (e + Xt) / Gs;\n  return function(l, c) {\n    if (l.is0(c))\n      return c;\n    if (pd(l, c) !== 1)\n      throw new Error(\"Cannot find square root\");\n    let u = t, d = l.mul(l.ONE, i), h = l.pow(c, e), f = l.pow(c, o);\n    for (; !l.eql(h, l.ONE); ) {\n      if (l.is0(h))\n        return l.ZERO;\n      let p = 1, y = l.sqr(h);\n      for (; !l.eql(y, l.ONE); )\n        if (p++, y = l.sqr(y), p === u)\n          throw new Error(\"Cannot find square root\");\n      const E = Xt &lt;&lt; BigInt(u - p - 1), b = l.pow(d, E);\n      u = p, d = l.sqr(b), h = l.mul(h, d), f = l.mul(f, b);\n    }\n    return f;\n  };\n}\nfunction ay(s) {\n  return s % r0 === t0 ? o0 : s % n0 === s0 ? iy : s % i0 === ny ? oy(s) : a0(s);\n}\nconst ly = (s, e) =&gt; (Gt(s, e) &amp; Xt) === Xt, cy = [\n  \"create\",\n  \"isValid\",\n  \"is0\",\n  \"neg\",\n  \"inv\",\n  \"sqrt\",\n  \"sqr\",\n  \"eql\",\n  \"add\",\n  \"sub\",\n  \"mul\",\n  \"pow\",\n  \"div\",\n  \"addN\",\n  \"subN\",\n  \"mulN\",\n  \"sqrN\"\n];\nfunction uy(s) {\n  const e = {\n    ORDER: \"bigint\",\n    MASK: \"bigint\",\n    BYTES: \"number\",\n    BITS: \"number\"\n  }, t = cy.reduce((r, n) =&gt; (r[n] = \"function\", r), e);\n  return Ri(s, t), s;\n}\nfunction dy(s, e, t) {\n  if (t &lt; gr)\n    throw new Error(\"invalid exponent, negatives unsupported\");\n  if (t === gr)\n    return s.ONE;\n  if (t === Xt)\n    return e;\n  let r = s.ONE, n = e;\n  for (; t &gt; gr; )\n    t &amp; Xt &amp;&amp; (r = s.mul(r, n)), n = s.sqr(n), t &gt;&gt;= Xt;\n  return r;\n}\nfunction l0(s, e, t = !1) {\n  const r = new Array(e.length).fill(t ? s.ZERO : void 0), n = e.reduce((o, a, l) =&gt; s.is0(a) ? o : (r[l] = o, s.mul(o, a)), s.ONE), i = s.inv(n);\n  return e.reduceRight((o, a, l) =&gt; s.is0(a) ? o : (r[l] = s.mul(o, r[l]), s.mul(o, a)), i), r;\n}\nfunction pd(s, e) {\n  const t = (s.ORDER - Xt) / Gs, r = s.pow(e, t), n = s.eql(r, s.ONE), i = s.eql(r, s.ZERO), o = s.eql(r, s.neg(s.ONE));\n  if (!n &amp;&amp; !i &amp;&amp; !o)\n    throw new Error(\"invalid Legendre symbol result\");\n  return n ? 1 : i ? 0 : -1;\n}\nfunction c0(s, e) {\n  e !== void 0 &amp;&amp; Xl(e);\n  const t = e !== void 0 ? e : s.toString(2).length, r = Math.ceil(t / 8);\n  return { nBitLength: t, nByteLength: r };\n}\nfunction en(s, e, t = !1, r = {}) {\n  if (s &lt;= gr)\n    throw new Error(\"invalid field: expected ORDER &gt; 0, got \" + s);\n  let n, i, o = !1, a;\n  if (typeof e == \"object\" &amp;&amp; e != null) {\n    if (r.sqrt || t)\n      throw new Error(\"cannot specify opts in two arguments\");\n    const h = e;\n    h.BITS &amp;&amp; (n = h.BITS), h.sqrt &amp;&amp; (i = h.sqrt), typeof h.isLE == \"boolean\" &amp;&amp; (t = h.isLE), typeof h.modFromBytes == \"boolean\" &amp;&amp; (o = h.modFromBytes), a = h.allowedLengths;\n  } else\n    typeof e == \"number\" &amp;&amp; (n = e), r.sqrt &amp;&amp; (i = r.sqrt);\n  const { nBitLength: l, nByteLength: c } = c0(s, n);\n  if (c &gt; 2048)\n    throw new Error(\"invalid field: expected ORDER of &lt;= 2048 bytes\");\n  let u;\n  const d = Object.freeze({\n    ORDER: s,\n    isLE: t,\n    BITS: l,\n    BYTES: c,\n    MASK: _i(l),\n    ZERO: gr,\n    ONE: Xt,\n    allowedLengths: a,\n    create: (h) =&gt; Gt(h, s),\n    isValid: (h) =&gt; {\n      if (typeof h != \"bigint\")\n        throw new Error(\"invalid field element: expected bigint, got \" + typeof h);\n      return gr &lt;= h &amp;&amp; h &lt; s;\n    },\n    is0: (h) =&gt; h === gr,\n    // is valid and invertible\n    isValidNot0: (h) =&gt; !d.is0(h) &amp;&amp; d.isValid(h),\n    isOdd: (h) =&gt; (h &amp; Xt) === Xt,\n    neg: (h) =&gt; Gt(-h, s),\n    eql: (h, f) =&gt; h === f,\n    sqr: (h) =&gt; Gt(h * h, s),\n    add: (h, f) =&gt; Gt(h + f, s),\n    sub: (h, f) =&gt; Gt(h - f, s),\n    mul: (h, f) =&gt; Gt(h * f, s),\n    pow: (h, f) =&gt; dy(d, h, f),\n    div: (h, f) =&gt; Gt(h * gd(f, s), s),\n    // Same as above, but doesn't normalize\n    sqrN: (h) =&gt; h * h,\n    addN: (h, f) =&gt; h + f,\n    subN: (h, f) =&gt; h - f,\n    mulN: (h, f) =&gt; h * f,\n    inv: (h) =&gt; gd(h, s),\n    sqrt: i || ((h) =&gt; (u || (u = ay(s)), u(d, h))),\n    toBytes: (h) =&gt; t ? Qf(h, c) : zc(h, c),\n    fromBytes: (h, f = !0) =&gt; {\n      if (a) {\n        if (!a.includes(h.length) || h.length &gt; c)\n          throw new Error(\"Field.fromBytes: expected \" + a + \" bytes, got \" + h.length);\n        const y = new Uint8Array(c);\n        y.set(h, t ? 0 : y.length - h.length), h = y;\n      }\n      if (h.length !== c)\n        throw new Error(\"Field.fromBytes: expected \" + c + \" bytes, got \" + h.length);\n      let p = t ? ei(h) : la(h);\n      if (o &amp;&amp; (p = Gt(p, s)), !f &amp;&amp; !d.isValid(p))\n        throw new Error(\"invalid field element: outside of range 0..ORDER\");\n      return p;\n    },\n    // TODO: we don't need it here, move out to separate fn\n    invertBatch: (h) =&gt; l0(d, h),\n    // We can't move this out because Fp6, Fp12 implement it\n    // and it's unclear what to return in there.\n    cmov: (h, f, p) =&gt; p ? f : h\n  });\n  return Object.freeze(d);\n}\nfunction u0(s) {\n  if (typeof s != \"bigint\")\n    throw new Error(\"field order must be bigint\");\n  const e = s.toString(2).length;\n  return Math.ceil(e / 8);\n}\nfunction d0(s) {\n  const e = u0(s);\n  return e + Math.ceil(e / 2);\n}\nfunction hy(s, e, t = !1) {\n  const r = s.length, n = u0(e), i = d0(e);\n  if (r &lt; 16 || r &lt; i || r &gt; 1024)\n    throw new Error(\"expected \" + i + \"-1024 bytes of input, got \" + r);\n  const o = t ? ei(s) : la(s), a = Gt(o, e - Xt) + Xt;\n  return t ? Qf(a, n) : zc(a, n);\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst Dn = BigInt(0), Vs = BigInt(1);\nfunction Oo(s, e) {\n  const t = e.negate();\n  return s ? t : e;\n}\nfunction js(s, e) {\n  const t = l0(s.Fp, e.map((r) =&gt; r.Z));\n  return e.map((r, n) =&gt; s.fromAffine(r.toAffine(t[n])));\n}\nfunction h0(s, e) {\n  if (!Number.isSafeInteger(s) || s &lt;= 0 || s &gt; e)\n    throw new Error(\"invalid window size, expected [1..\" + e + \"], got W=\" + s);\n}\nfunction Ka(s, e) {\n  h0(s, e);\n  const t = Math.ceil(e / s) + 1, r = 2 ** (s - 1), n = 2 ** s, i = _i(s), o = BigInt(s);\n  return { windows: t, windowSize: r, mask: i, maxNumber: n, shiftBy: o };\n}\nfunction md(s, e, t) {\n  const { windowSize: r, mask: n, maxNumber: i, shiftBy: o } = t;\n  let a = Number(s &amp; n), l = s &gt;&gt; o;\n  a &gt; r &amp;&amp; (a -= i, l += Vs);\n  const c = e * r, u = c + Math.abs(a) - 1, d = a === 0, h = a &lt; 0, f = e % 2 !== 0;\n  return { nextN: l, offset: u, isZero: d, isNeg: h, isNegF: f, offsetF: c };\n}\nfunction fy(s, e) {\n  if (!Array.isArray(s))\n    throw new Error(\"array expected\");\n  s.forEach((t, r) =&gt; {\n    if (!(t instanceof e))\n      throw new Error(\"invalid point at index \" + r);\n  });\n}\nfunction gy(s, e) {\n  if (!Array.isArray(s))\n    throw new Error(\"array of scalars expected\");\n  s.forEach((t, r) =&gt; {\n    if (!e.isValid(t))\n      throw new Error(\"invalid scalar at index \" + r);\n  });\n}\nconst Ha = /* @__PURE__ */ new WeakMap(), f0 = /* @__PURE__ */ new WeakMap();\nfunction qa(s) {\n  return f0.get(s) || 1;\n}\nfunction yd(s) {\n  if (s !== Dn)\n    throw new Error(\"invalid wNAF\");\n}\nclass g0 {\n  // Parametrized with a given Point class (not individual point)\n  constructor(e, t) {\n    this.BASE = e.BASE, this.ZERO = e.ZERO, this.Fn = e.Fn, this.bits = t;\n  }\n  // non-const time multiplication ladder\n  _unsafeLadder(e, t, r = this.ZERO) {\n    let n = e;\n    for (; t &gt; Dn; )\n      t &amp; Vs &amp;&amp; (r = r.add(n)), n = n.double(), t &gt;&gt;= Vs;\n    return r;\n  }\n  /**\n   * Creates a wNAF precomputation window. Used for caching.\n   * Default window size is set by `utils.precompute()` and is equal to 8.\n   * Number of precomputed points depends on the curve size:\n   * 2^(1) * (Math.ceil( / ) + 1), where:\n   * -  is the window size\n   * -  is the bitlength of the curve order.\n   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n   * @param point Point instance\n   * @param W window size\n   * @returns precomputed point tables flattened to a single array\n   */\n  precomputeWindow(e, t) {\n    const { windows: r, windowSize: n } = Ka(t, this.bits), i = [];\n    let o = e, a = o;\n    for (let l = 0; l &lt; r; l++) {\n      a = o, i.push(a);\n      for (let c = 1; c &lt; n; c++)\n        a = a.add(o), i.push(a);\n      o = a.double();\n    }\n    return i;\n  }\n  /**\n   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n   * More compact implementation:\n   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n   * @returns real and fake (for const-time) points\n   */\n  wNAF(e, t, r) {\n    if (!this.Fn.isValid(r))\n      throw new Error(\"invalid scalar\");\n    let n = this.ZERO, i = this.BASE;\n    const o = Ka(e, this.bits);\n    for (let a = 0; a &lt; o.windows; a++) {\n      const { nextN: l, offset: c, isZero: u, isNeg: d, isNegF: h, offsetF: f } = md(r, a, o);\n      r = l, u ? i = i.add(Oo(h, t[f])) : n = n.add(Oo(d, t[c]));\n    }\n    return yd(r), { p: n, f: i };\n  }\n  /**\n   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n   * @param acc accumulator point to add result of multiplication\n   * @returns point\n   */\n  wNAFUnsafe(e, t, r, n = this.ZERO) {\n    const i = Ka(e, this.bits);\n    for (let o = 0; o &lt; i.windows &amp;&amp; r !== Dn; o++) {\n      const { nextN: a, offset: l, isZero: c, isNeg: u } = md(r, o, i);\n      if (r = a, !c) {\n        const d = t[l];\n        n = n.add(u ? d.negate() : d);\n      }\n    }\n    return yd(r), n;\n  }\n  getPrecomputes(e, t, r) {\n    let n = Ha.get(t);\n    return n || (n = this.precomputeWindow(t, e), e !== 1 &amp;&amp; (typeof r == \"function\" &amp;&amp; (n = r(n)), Ha.set(t, n))), n;\n  }\n  cached(e, t, r) {\n    const n = qa(e);\n    return this.wNAF(n, this.getPrecomputes(n, e, r), t);\n  }\n  unsafe(e, t, r, n) {\n    const i = qa(e);\n    return i === 1 ? this._unsafeLadder(e, t, n) : this.wNAFUnsafe(i, this.getPrecomputes(i, e, r), t, n);\n  }\n  // We calculate precomputes for elliptic curve point multiplication\n  // using windowed method. This specifies window size and\n  // stores precomputed values. Usually only base point would be precomputed.\n  createCache(e, t) {\n    h0(t, this.bits), f0.set(e, t), Ha.delete(e);\n  }\n  hasCache(e) {\n    return qa(e) !== 1;\n  }\n}\nfunction py(s, e, t, r) {\n  let n = e, i = s.ZERO, o = s.ZERO;\n  for (; t &gt; Dn || r &gt; Dn; )\n    t &amp; Vs &amp;&amp; (i = i.add(n)), r &amp; Vs &amp;&amp; (o = o.add(n)), n = n.double(), t &gt;&gt;= Vs, r &gt;&gt;= Vs;\n  return { p1: i, p2: o };\n}\nfunction p0(s, e, t, r) {\n  fy(t, s), gy(r, e);\n  const n = t.length, i = r.length;\n  if (n !== i)\n    throw new Error(\"arrays of points and scalars must have equal length\");\n  const o = s.ZERO, a = e0(BigInt(n));\n  let l = 1;\n  a &gt; 12 ? l = a - 3 : a &gt; 4 ? l = a - 2 : a &gt; 0 &amp;&amp; (l = 2);\n  const c = _i(l), u = new Array(Number(c) + 1).fill(o), d = Math.floor((e.BITS - 1) / l) * l;\n  let h = o;\n  for (let f = d; f &gt;= 0; f -= l) {\n    u.fill(o);\n    for (let y = 0; y &lt; i; y++) {\n      const E = r[y], b = Number(E &gt;&gt; BigInt(f) &amp; c);\n      u[b] = u[b].add(t[y]);\n    }\n    let p = o;\n    for (let y = u.length - 1, E = o; y &gt; 0; y--)\n      E = E.add(u[y]), p = p.add(E);\n    if (h = h.add(p), f !== 0)\n      for (let y = 0; y &lt; l; y++)\n        h = h.double();\n  }\n  return h;\n}\nfunction vd(s, e, t) {\n  if (e) {\n    if (e.ORDER !== s)\n      throw new Error(\"Field.ORDER must match order: Fp == p, Fn == n\");\n    return uy(e), e;\n  } else\n    return en(s, { isLE: t });\n}\nfunction m0(s, e, t = {}, r) {\n  if (r === void 0 &amp;&amp; (r = s === \"edwards\"), !e || typeof e != \"object\")\n    throw new Error(`expected valid ${s} CURVE object`);\n  for (const l of [\"p\", \"n\", \"h\"]) {\n    const c = e[l];\n    if (!(typeof c == \"bigint\" &amp;&amp; c &gt; Dn))\n      throw new Error(`CURVE.${l} must be positive bigint`);\n  }\n  const n = vd(e.p, t.Fp, r), i = vd(e.n, t.Fn, r), a = [\"Gx\", \"Gy\", \"a\", s === \"weierstrass\" ? \"b\" : \"d\"];\n  for (const l of a)\n    if (!n.isValid(e[l]))\n      throw new Error(`CURVE.${l} must be valid field element of CURVE.Fp`);\n  return e = Object.freeze(Object.assign({}, e)), { CURVE: e, Fp: n, Fn: i };\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst xs = BigInt(0), zt = BigInt(1), Wa = BigInt(2), my = BigInt(8);\nfunction yy(s, e, t, r) {\n  const n = s.sqr(t), i = s.sqr(r), o = s.add(s.mul(e.a, n), i), a = s.add(s.ONE, s.mul(e.d, s.mul(n, i)));\n  return s.eql(o, a);\n}\nfunction vy(s, e = {}) {\n  const t = m0(\"edwards\", s, e, e.FpFnLE), { Fp: r, Fn: n } = t;\n  let i = t.CURVE;\n  const { h: o } = i;\n  Ri(e, {}, { uvRatio: \"function\" });\n  const a = Wa &lt;&lt; BigInt(n.BYTES * 8) - zt, l = (E) =&gt; r.create(E), c = e.uvRatio || ((E, b) =&gt; {\n    try {\n      return { isValid: !0, value: r.sqrt(r.div(E, b)) };\n    } catch {\n      return { isValid: !1, value: xs };\n    }\n  });\n  if (!yy(r, i, i.Gx, i.Gy))\n    throw new Error(\"bad curve params: generator point\");\n  function u(E, b, R = !1) {\n    const A = R ? zt : xs;\n    return Ql(\"coordinate \" + E, b, A, a), b;\n  }\n  function d(E) {\n    if (!(E instanceof p))\n      throw new Error(\"ExtendedPoint expected\");\n  }\n  const h = Mo((E, b) =&gt; {\n    const { X: R, Y: A, Z: F } = E, M = E.is0();\n    b == null &amp;&amp; (b = M ? my : r.inv(F));\n    const H = l(R * b), K = l(A * b), j = r.mul(F, b);\n    if (M)\n      return { x: xs, y: zt };\n    if (j !== zt)\n      throw new Error(\"invZ was invalid\");\n    return { x: H, y: K };\n  }), f = Mo((E) =&gt; {\n    const { a: b, d: R } = i;\n    if (E.is0())\n      throw new Error(\"bad point: ZERO\");\n    const { X: A, Y: F, Z: M, T: H } = E, K = l(A * A), j = l(F * F), C = l(M * M), k = l(C * C), $ = l(K * b), W = l(C * l($ + j)), _ = l(k + l(R * l(K * j)));\n    if (W !== _)\n      throw new Error(\"bad point: equation left != right (1)\");\n    const g = l(A * F), x = l(M * H);\n    if (g !== x)\n      throw new Error(\"bad point: equation left != right (2)\");\n    return !0;\n  });\n  class p {\n    constructor(b, R, A, F) {\n      this.X = u(\"x\", b), this.Y = u(\"y\", R), this.Z = u(\"z\", A, !0), this.T = u(\"t\", F), Object.freeze(this);\n    }\n    static CURVE() {\n      return i;\n    }\n    static fromAffine(b) {\n      if (b instanceof p)\n        throw new Error(\"extended point not allowed\");\n      const { x: R, y: A } = b || {};\n      return u(\"x\", R), u(\"y\", A), new p(R, A, zt, l(R * A));\n    }\n    // Uses algo from RFC8032 5.1.3.\n    static fromBytes(b, R = !1) {\n      const A = r.BYTES, { a: F, d: M } = i;\n      b = fd(Or(b, A, \"point\")), Xs(R, \"zip215\");\n      const H = fd(b), K = b[A - 1];\n      H[A - 1] = K &amp; -129;\n      const j = ei(H), C = R ? a : r.ORDER;\n      Ql(\"point.y\", j, xs, C);\n      const k = l(j * j), $ = l(k - zt), W = l(M * k - F);\n      let { isValid: _, value: g } = c($, W);\n      if (!_)\n        throw new Error(\"bad point: invalid y coordinate\");\n      const x = (g &amp; zt) === zt, w = (K &amp; 128) !== 0;\n      if (!R &amp;&amp; g === xs &amp;&amp; w)\n        throw new Error(\"bad point: x=0 and x_0=1\");\n      return w !== x &amp;&amp; (g = l(-g)), p.fromAffine({ x: g, y: j });\n    }\n    static fromHex(b, R = !1) {\n      return p.fromBytes(Et(\"point\", b), R);\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    precompute(b = 8, R = !0) {\n      return y.createCache(this, b), R || this.multiply(Wa), this;\n    }\n    // Useful in fromAffine() - not for fromBytes(), which always created valid points.\n    assertValidity() {\n      f(this);\n    }\n    // Compare one point to another.\n    equals(b) {\n      d(b);\n      const { X: R, Y: A, Z: F } = this, { X: M, Y: H, Z: K } = b, j = l(R * K), C = l(M * F), k = l(A * K), $ = l(H * F);\n      return j === C &amp;&amp; k === $;\n    }\n    is0() {\n      return this.equals(p.ZERO);\n    }\n    negate() {\n      return new p(l(-this.X), this.Y, this.Z, l(-this.T));\n    }\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double() {\n      const { a: b } = i, { X: R, Y: A, Z: F } = this, M = l(R * R), H = l(A * A), K = l(Wa * l(F * F)), j = l(b * M), C = R + A, k = l(l(C * C) - M - H), $ = j + H, W = $ - K, _ = j - H, g = l(k * W), x = l($ * _), w = l(k * _), D = l(W * $);\n      return new p(g, x, D, w);\n    }\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(b) {\n      d(b);\n      const { a: R, d: A } = i, { X: F, Y: M, Z: H, T: K } = this, { X: j, Y: C, Z: k, T: $ } = b, W = l(F * j), _ = l(M * C), g = l(K * A * $), x = l(H * k), w = l((F + M) * (j + C) - W - _), D = x - g, O = x + g, U = l(_ - R * W), V = l(w * D), L = l(O * U), m = l(w * U), v = l(D * O);\n      return new p(V, L, v, m);\n    }\n    subtract(b) {\n      return this.add(b.negate());\n    }\n    // Constant-time multiplication.\n    multiply(b) {\n      if (!n.isValidNot0(b))\n        throw new Error(\"invalid scalar: expected 1 &lt;= sc &lt; curve.n\");\n      const { p: R, f: A } = y.cached(this, b, (F) =&gt; js(p, F));\n      return js(p, [R, A])[0];\n    }\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(b, R = p.ZERO) {\n      if (!n.isValid(b))\n        throw new Error(\"invalid scalar: expected 0 &lt;= sc &lt; curve.n\");\n      return b === xs ? p.ZERO : this.is0() || b === zt ? this : y.unsafe(this, b, (A) =&gt; js(p, A), R);\n    }\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder() {\n      return this.multiplyUnsafe(o).is0();\n    }\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree() {\n      return y.unsafe(this, i.n).is0();\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(b) {\n      return h(this, b);\n    }\n    clearCofactor() {\n      return o === zt ? this : this.multiplyUnsafe(o);\n    }\n    toBytes() {\n      const { x: b, y: R } = this.toAffine(), A = r.toBytes(R);\n      return A[A.length - 1] |= b &amp; zt ? 128 : 0, A;\n    }\n    toHex() {\n      return Hs(this.toBytes());\n    }\n    toString() {\n      return `&lt;Point ${this.is0() ? \"ZERO\" : this.toHex()}&gt;`;\n    }\n    // TODO: remove\n    get ex() {\n      return this.X;\n    }\n    get ey() {\n      return this.Y;\n    }\n    get ez() {\n      return this.Z;\n    }\n    get et() {\n      return this.T;\n    }\n    static normalizeZ(b) {\n      return js(p, b);\n    }\n    static msm(b, R) {\n      return p0(p, n, b, R);\n    }\n    _setWindowSize(b) {\n      this.precompute(b);\n    }\n    toRawBytes() {\n      return this.toBytes();\n    }\n  }\n  p.BASE = new p(i.Gx, i.Gy, zt, l(i.Gx * i.Gy)), p.ZERO = new p(xs, zt, zt, xs), p.Fp = r, p.Fn = n;\n  const y = new g0(p, n.BITS);\n  return p.BASE.precompute(8), p;\n}\nfunction Ey(s, e, t = {}) {\n  if (typeof e != \"function\")\n    throw new Error('\"hash\" function param is required');\n  Ri(t, {}, {\n    adjustScalarBytes: \"function\",\n    randomBytes: \"function\",\n    domain: \"function\",\n    prehash: \"function\",\n    mapToCurve: \"function\"\n  });\n  const { prehash: r } = t, { BASE: n, Fp: i, Fn: o } = s, a = t.randomBytes || qc, l = t.adjustScalarBytes || ((C) =&gt; C), c = t.domain || ((C, k, $) =&gt; {\n    if (Xs($, \"phflag\"), k.length || $)\n      throw new Error(\"Contexts/pre-hash are not supported\");\n    return C;\n  });\n  function u(C) {\n    return o.create(ei(C));\n  }\n  function d(C) {\n    const k = A.secretKey;\n    C = Et(\"private key\", C, k);\n    const $ = Et(\"hashed private key\", e(C), 2 * k), W = l($.slice(0, k)), _ = $.slice(k, 2 * k), g = u(W);\n    return { head: W, prefix: _, scalar: g };\n  }\n  function h(C) {\n    const { head: k, prefix: $, scalar: W } = d(C), _ = n.multiply(W), g = _.toBytes();\n    return { head: k, prefix: $, scalar: W, point: _, pointBytes: g };\n  }\n  function f(C) {\n    return h(C).pointBytes;\n  }\n  function p(C = Uint8Array.of(), ...k) {\n    const $ = Kr(...k);\n    return u(e(c($, Et(\"context\", C), !!r)));\n  }\n  function y(C, k, $ = {}) {\n    C = Et(\"message\", C), r &amp;&amp; (C = r(C));\n    const { prefix: W, scalar: _, pointBytes: g } = h(k), x = p($.context, W, C), w = n.multiply(x).toBytes(), D = p($.context, w, g, C), O = o.create(x + D * _);\n    if (!o.isValid(O))\n      throw new Error(\"sign failed: invalid s\");\n    const U = Kr(w, o.toBytes(O));\n    return Or(U, A.signature, \"result\");\n  }\n  const E = { zip215: !0 };\n  function b(C, k, $, W = E) {\n    const { context: _, zip215: g } = W, x = A.signature;\n    C = Et(\"signature\", C, x), k = Et(\"message\", k), $ = Et(\"publicKey\", $, A.publicKey), g !== void 0 &amp;&amp; Xs(g, \"zip215\"), r &amp;&amp; (k = r(k));\n    const w = x / 2, D = C.subarray(0, w), O = ei(C.subarray(w, x));\n    let U, V, L;\n    try {\n      U = s.fromBytes($, g), V = s.fromBytes(D, g), L = n.multiplyUnsafe(O);\n    } catch {\n      return !1;\n    }\n    if (!g &amp;&amp; U.isSmallOrder())\n      return !1;\n    const m = p(_, V.toBytes(), U.toBytes(), k);\n    return V.add(U.multiplyUnsafe(m)).subtract(L).clearCofactor().is0();\n  }\n  const R = i.BYTES, A = {\n    secretKey: R,\n    publicKey: R,\n    signature: 2 * R,\n    seed: R\n  };\n  function F(C = a(A.seed)) {\n    return Or(C, A.seed, \"seed\");\n  }\n  function M(C) {\n    const k = j.randomSecretKey(C);\n    return { secretKey: k, publicKey: f(k) };\n  }\n  function H(C) {\n    return Ii(C) &amp;&amp; C.length === o.BYTES;\n  }\n  function K(C, k) {\n    try {\n      return !!s.fromBytes(C, k);\n    } catch {\n      return !1;\n    }\n  }\n  const j = {\n    getExtendedPublicKey: h,\n    randomSecretKey: F,\n    isValidSecretKey: H,\n    isValidPublicKey: K,\n    /**\n     * Converts ed public key to x public key. Uses formula:\n     * - ed25519:\n     *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n     *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n     * - ed448:\n     *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`\n     *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`\n     */\n    toMontgomery(C) {\n      const { y: k } = s.fromBytes(C), $ = A.publicKey, W = $ === 32;\n      if (!W &amp;&amp; $ !== 57)\n        throw new Error(\"only defined for 25519 and 448\");\n      const _ = W ? i.div(zt + k, zt - k) : i.div(k - zt, k + zt);\n      return i.toBytes(_);\n    },\n    toMontgomerySecret(C) {\n      const k = A.secretKey;\n      Or(C, k);\n      const $ = e(C.subarray(0, k));\n      return l($).subarray(0, k);\n    },\n    /** @deprecated */\n    randomPrivateKey: F,\n    /** @deprecated */\n    precompute(C = 8, k = s.BASE) {\n      return k.precompute(C, !1);\n    }\n  };\n  return Object.freeze({\n    keygen: M,\n    getPublicKey: f,\n    sign: y,\n    verify: b,\n    utils: j,\n    Point: s,\n    lengths: A\n  });\n}\nfunction xy(s) {\n  const e = {\n    a: s.a,\n    d: s.d,\n    p: s.Fp.ORDER,\n    n: s.n,\n    h: s.h,\n    Gx: s.Gx,\n    Gy: s.Gy\n  }, t = s.Fp, r = en(e.n, s.nBitLength, !0), n = { Fp: t, Fn: r, uvRatio: s.uvRatio }, i = {\n    randomBytes: s.randomBytes,\n    adjustScalarBytes: s.adjustScalarBytes,\n    domain: s.domain,\n    prehash: s.prehash,\n    mapToCurve: s.mapToCurve\n  };\n  return { CURVE: e, curveOpts: n, hash: s.hash, eddsaOpts: i };\n}\nfunction Sy(s, e) {\n  const t = e.Point;\n  return Object.assign({}, e, {\n    ExtendedPoint: t,\n    CURVE: s,\n    nBitLength: t.Fn.BITS,\n    nByteLength: t.Fn.BYTES\n  });\n}\nfunction by(s) {\n  const { CURVE: e, curveOpts: t, hash: r, eddsaOpts: n } = xy(s), i = vy(e, t), o = Ey(i, r, n);\n  return Sy(s, o);\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst Ty = BigInt(1), Ed = BigInt(2);\nBigInt(3);\nconst wy = BigInt(5), Ay = BigInt(8), Zc = BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed\"), y0 = {\n  p: Zc,\n  n: BigInt(\"0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed\"),\n  h: Ay,\n  a: BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec\"),\n  d: BigInt(\"0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3\"),\n  Gx: BigInt(\"0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a\"),\n  Gy: BigInt(\"0x6666666666666666666666666666666666666666666666666666666666666658\")\n};\nfunction Iy(s) {\n  const e = BigInt(10), t = BigInt(20), r = BigInt(40), n = BigInt(80), i = Zc, a = s * s % i * s % i, l = vt(a, Ed, i) * a % i, c = vt(l, Ty, i) * s % i, u = vt(c, wy, i) * c % i, d = vt(u, e, i) * u % i, h = vt(d, t, i) * d % i, f = vt(h, r, i) * h % i, p = vt(f, n, i) * f % i, y = vt(p, n, i) * f % i, E = vt(y, e, i) * u % i;\n  return { pow_p_5_8: vt(E, Ed, i) * s % i, b2: a };\n}\nfunction _y(s) {\n  return s[0] &amp;= 248, s[31] &amp;= 127, s[31] |= 64, s;\n}\nconst xd = /* @__PURE__ */ BigInt(\"19681161376707505956807079304988542015446066515923890162744021073123829784752\");\nfunction Ry(s, e) {\n  const t = Zc, r = Gt(e * e * e, t), n = Gt(r * r * e, t), i = Iy(s * n).pow_p_5_8;\n  let o = Gt(s * r * i, t);\n  const a = Gt(e * o * o, t), l = o, c = Gt(o * xd, t), u = a === s, d = a === Gt(-s, t), h = a === Gt(-s * xd, t);\n  return u &amp;&amp; (o = l), (d || h) &amp;&amp; (o = c), ly(o, t) &amp;&amp; (o = Gt(-o, t)), { isValid: u || d, value: o };\n}\nconst Ly = en(y0.p, { isLE: !0 }), Cy = {\n  ...y0,\n  Fp: Ly,\n  hash: ey,\n  adjustScalarBytes: _y,\n  // dom2\n  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n  // Constant-time, u/v\n  uvRatio: Ry\n}, Li = by(Cy);\nvar co = { exports: {} };\nconst ky = {}, Dy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  default: ky\n}, Symbol.toStringTag, { value: \"Module\" })), Py = /* @__PURE__ */ Nc(Dy);\nvar My = co.exports, Sd;\nfunction v0() {\n  return Sd || (Sd = 1, (function(s) {\n    (function(e, t) {\n      function r(_, g) {\n        if (!_) throw new Error(g || \"Assertion failed\");\n      }\n      function n(_, g) {\n        _.super_ = g;\n        var x = function() {\n        };\n        x.prototype = g.prototype, _.prototype = new x(), _.prototype.constructor = _;\n      }\n      function i(_, g, x) {\n        if (i.isBN(_))\n          return _;\n        this.negative = 0, this.words = null, this.length = 0, this.red = null, _ !== null &amp;&amp; ((g === \"le\" || g === \"be\") &amp;&amp; (x = g, g = 10), this._init(_ || 0, g || 10, x || \"be\"));\n      }\n      typeof e == \"object\" ? e.exports = i : t.BN = i, i.BN = i, i.wordSize = 26;\n      var o;\n      try {\n        typeof window &lt; \"u\" &amp;&amp; typeof window.Buffer &lt; \"u\" ? o = window.Buffer : o = Py.Buffer;\n      } catch {\n      }\n      i.isBN = function(g) {\n        return g instanceof i ? !0 : g !== null &amp;&amp; typeof g == \"object\" &amp;&amp; g.constructor.wordSize === i.wordSize &amp;&amp; Array.isArray(g.words);\n      }, i.max = function(g, x) {\n        return g.cmp(x) &gt; 0 ? g : x;\n      }, i.min = function(g, x) {\n        return g.cmp(x) &lt; 0 ? g : x;\n      }, i.prototype._init = function(g, x, w) {\n        if (typeof g == \"number\")\n          return this._initNumber(g, x, w);\n        if (typeof g == \"object\")\n          return this._initArray(g, x, w);\n        x === \"hex\" &amp;&amp; (x = 16), r(x === (x | 0) &amp;&amp; x &gt;= 2 &amp;&amp; x &lt;= 36), g = g.toString().replace(/\\s+/g, \"\");\n        var D = 0;\n        g[0] === \"-\" &amp;&amp; (D++, this.negative = 1), D &lt; g.length &amp;&amp; (x === 16 ? this._parseHex(g, D, w) : (this._parseBase(g, x, D), w === \"le\" &amp;&amp; this._initArray(this.toArray(), x, w)));\n      }, i.prototype._initNumber = function(g, x, w) {\n        g &lt; 0 &amp;&amp; (this.negative = 1, g = -g), g &lt; 67108864 ? (this.words = [g &amp; 67108863], this.length = 1) : g &lt; 4503599627370496 ? (this.words = [\n          g &amp; 67108863,\n          g / 67108864 &amp; 67108863\n        ], this.length = 2) : (r(g &lt; 9007199254740992), this.words = [\n          g &amp; 67108863,\n          g / 67108864 &amp; 67108863,\n          1\n        ], this.length = 3), w === \"le\" &amp;&amp; this._initArray(this.toArray(), x, w);\n      }, i.prototype._initArray = function(g, x, w) {\n        if (r(typeof g.length == \"number\"), g.length &lt;= 0)\n          return this.words = [0], this.length = 1, this;\n        this.length = Math.ceil(g.length / 3), this.words = new Array(this.length);\n        for (var D = 0; D &lt; this.length; D++)\n          this.words[D] = 0;\n        var O, U, V = 0;\n        if (w === \"be\")\n          for (D = g.length - 1, O = 0; D &gt;= 0; D -= 3)\n            U = g[D] | g[D - 1] &lt;&lt; 8 | g[D - 2] &lt;&lt; 16, this.words[O] |= U &lt;&lt; V &amp; 67108863, this.words[O + 1] = U &gt;&gt;&gt; 26 - V &amp; 67108863, V += 24, V &gt;= 26 &amp;&amp; (V -= 26, O++);\n        else if (w === \"le\")\n          for (D = 0, O = 0; D &lt; g.length; D += 3)\n            U = g[D] | g[D + 1] &lt;&lt; 8 | g[D + 2] &lt;&lt; 16, this.words[O] |= U &lt;&lt; V &amp; 67108863, this.words[O + 1] = U &gt;&gt;&gt; 26 - V &amp; 67108863, V += 24, V &gt;= 26 &amp;&amp; (V -= 26, O++);\n        return this._strip();\n      };\n      function a(_, g) {\n        var x = _.charCodeAt(g);\n        if (x &gt;= 48 &amp;&amp; x &lt;= 57)\n          return x - 48;\n        if (x &gt;= 65 &amp;&amp; x &lt;= 70)\n          return x - 55;\n        if (x &gt;= 97 &amp;&amp; x &lt;= 102)\n          return x - 87;\n        r(!1, \"Invalid character in \" + _);\n      }\n      function l(_, g, x) {\n        var w = a(_, x);\n        return x - 1 &gt;= g &amp;&amp; (w |= a(_, x - 1) &lt;&lt; 4), w;\n      }\n      i.prototype._parseHex = function(g, x, w) {\n        this.length = Math.ceil((g.length - x) / 6), this.words = new Array(this.length);\n        for (var D = 0; D &lt; this.length; D++)\n          this.words[D] = 0;\n        var O = 0, U = 0, V;\n        if (w === \"be\")\n          for (D = g.length - 1; D &gt;= x; D -= 2)\n            V = l(g, x, D) &lt;&lt; O, this.words[U] |= V &amp; 67108863, O &gt;= 18 ? (O -= 18, U += 1, this.words[U] |= V &gt;&gt;&gt; 26) : O += 8;\n        else {\n          var L = g.length - x;\n          for (D = L % 2 === 0 ? x + 1 : x; D &lt; g.length; D += 2)\n            V = l(g, x, D) &lt;&lt; O, this.words[U] |= V &amp; 67108863, O &gt;= 18 ? (O -= 18, U += 1, this.words[U] |= V &gt;&gt;&gt; 26) : O += 8;\n        }\n        this._strip();\n      };\n      function c(_, g, x, w) {\n        for (var D = 0, O = 0, U = Math.min(_.length, x), V = g; V &lt; U; V++) {\n          var L = _.charCodeAt(V) - 48;\n          D *= w, L &gt;= 49 ? O = L - 49 + 10 : L &gt;= 17 ? O = L - 17 + 10 : O = L, r(L &gt;= 0 &amp;&amp; O &lt; w, \"Invalid character\"), D += O;\n        }\n        return D;\n      }\n      i.prototype._parseBase = function(g, x, w) {\n        this.words = [0], this.length = 1;\n        for (var D = 0, O = 1; O &lt;= 67108863; O *= x)\n          D++;\n        D--, O = O / x | 0;\n        for (var U = g.length - w, V = U % D, L = Math.min(U, U - V) + w, m = 0, v = w; v &lt; L; v += D)\n          m = c(g, v, v + D, x), this.imuln(O), this.words[0] + m &lt; 67108864 ? this.words[0] += m : this._iaddn(m);\n        if (V !== 0) {\n          var P = 1;\n          for (m = c(g, v, g.length, x), v = 0; v &lt; V; v++)\n            P *= x;\n          this.imuln(P), this.words[0] + m &lt; 67108864 ? this.words[0] += m : this._iaddn(m);\n        }\n        this._strip();\n      }, i.prototype.copy = function(g) {\n        g.words = new Array(this.length);\n        for (var x = 0; x &lt; this.length; x++)\n          g.words[x] = this.words[x];\n        g.length = this.length, g.negative = this.negative, g.red = this.red;\n      };\n      function u(_, g) {\n        _.words = g.words, _.length = g.length, _.negative = g.negative, _.red = g.red;\n      }\n      if (i.prototype._move = function(g) {\n        u(g, this);\n      }, i.prototype.clone = function() {\n        var g = new i(null);\n        return this.copy(g), g;\n      }, i.prototype._expand = function(g) {\n        for (; this.length &lt; g; )\n          this.words[this.length++] = 0;\n        return this;\n      }, i.prototype._strip = function() {\n        for (; this.length &gt; 1 &amp;&amp; this.words[this.length - 1] === 0; )\n          this.length--;\n        return this._normSign();\n      }, i.prototype._normSign = function() {\n        return this.length === 1 &amp;&amp; this.words[0] === 0 &amp;&amp; (this.negative = 0), this;\n      }, typeof Symbol &lt; \"u\" &amp;&amp; typeof Symbol.for == \"function\")\n        try {\n          i.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = d;\n        } catch {\n          i.prototype.inspect = d;\n        }\n      else\n        i.prototype.inspect = d;\n      function d() {\n        return (this.red ? \"&lt;BN-R: \" : \"&lt;BN: \") + this.toString(16) + \"&gt;\";\n      }\n      var h = [\n        \"\",\n        \"0\",\n        \"00\",\n        \"000\",\n        \"0000\",\n        \"00000\",\n        \"000000\",\n        \"0000000\",\n        \"00000000\",\n        \"000000000\",\n        \"0000000000\",\n        \"00000000000\",\n        \"000000000000\",\n        \"0000000000000\",\n        \"00000000000000\",\n        \"000000000000000\",\n        \"0000000000000000\",\n        \"00000000000000000\",\n        \"000000000000000000\",\n        \"0000000000000000000\",\n        \"00000000000000000000\",\n        \"000000000000000000000\",\n        \"0000000000000000000000\",\n        \"00000000000000000000000\",\n        \"000000000000000000000000\",\n        \"0000000000000000000000000\"\n      ], f = [\n        0,\n        0,\n        25,\n        16,\n        12,\n        11,\n        10,\n        9,\n        8,\n        8,\n        7,\n        7,\n        7,\n        7,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        6,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5,\n        5\n      ], p = [\n        0,\n        0,\n        33554432,\n        43046721,\n        16777216,\n        48828125,\n        60466176,\n        40353607,\n        16777216,\n        43046721,\n        1e7,\n        19487171,\n        35831808,\n        62748517,\n        7529536,\n        11390625,\n        16777216,\n        24137569,\n        34012224,\n        47045881,\n        64e6,\n        4084101,\n        5153632,\n        6436343,\n        7962624,\n        9765625,\n        11881376,\n        14348907,\n        17210368,\n        20511149,\n        243e5,\n        28629151,\n        33554432,\n        39135393,\n        45435424,\n        52521875,\n        60466176\n      ];\n      i.prototype.toString = function(g, x) {\n        g = g || 10, x = x | 0 || 1;\n        var w;\n        if (g === 16 || g === \"hex\") {\n          w = \"\";\n          for (var D = 0, O = 0, U = 0; U &lt; this.length; U++) {\n            var V = this.words[U], L = ((V &lt;&lt; D | O) &amp; 16777215).toString(16);\n            O = V &gt;&gt;&gt; 24 - D &amp; 16777215, D += 2, D &gt;= 26 &amp;&amp; (D -= 26, U--), O !== 0 || U !== this.length - 1 ? w = h[6 - L.length] + L + w : w = L + w;\n          }\n          for (O !== 0 &amp;&amp; (w = O.toString(16) + w); w.length % x !== 0; )\n            w = \"0\" + w;\n          return this.negative !== 0 &amp;&amp; (w = \"-\" + w), w;\n        }\n        if (g === (g | 0) &amp;&amp; g &gt;= 2 &amp;&amp; g &lt;= 36) {\n          var m = f[g], v = p[g];\n          w = \"\";\n          var P = this.clone();\n          for (P.negative = 0; !P.isZero(); ) {\n            var N = P.modrn(v).toString(g);\n            P = P.idivn(v), P.isZero() ? w = N + w : w = h[m - N.length] + N + w;\n          }\n          for (this.isZero() &amp;&amp; (w = \"0\" + w); w.length % x !== 0; )\n            w = \"0\" + w;\n          return this.negative !== 0 &amp;&amp; (w = \"-\" + w), w;\n        }\n        r(!1, \"Base should be between 2 and 36\");\n      }, i.prototype.toNumber = function() {\n        var g = this.words[0];\n        return this.length === 2 ? g += this.words[1] * 67108864 : this.length === 3 &amp;&amp; this.words[2] === 1 ? g += 4503599627370496 + this.words[1] * 67108864 : this.length &gt; 2 &amp;&amp; r(!1, \"Number can only safely store up to 53 bits\"), this.negative !== 0 ? -g : g;\n      }, i.prototype.toJSON = function() {\n        return this.toString(16, 2);\n      }, o &amp;&amp; (i.prototype.toBuffer = function(g, x) {\n        return this.toArrayLike(o, g, x);\n      }), i.prototype.toArray = function(g, x) {\n        return this.toArrayLike(Array, g, x);\n      };\n      var y = function(g, x) {\n        return g.allocUnsafe ? g.allocUnsafe(x) : new g(x);\n      };\n      i.prototype.toArrayLike = function(g, x, w) {\n        this._strip();\n        var D = this.byteLength(), O = w || Math.max(1, D);\n        r(D &lt;= O, \"byte array longer than desired length\"), r(O &gt; 0, \"Requested array length &lt;= 0\");\n        var U = y(g, O), V = x === \"le\" ? \"LE\" : \"BE\";\n        return this[\"_toArrayLike\" + V](U, D), U;\n      }, i.prototype._toArrayLikeLE = function(g, x) {\n        for (var w = 0, D = 0, O = 0, U = 0; O &lt; this.length; O++) {\n          var V = this.words[O] &lt;&lt; U | D;\n          g[w++] = V &amp; 255, w &lt; g.length &amp;&amp; (g[w++] = V &gt;&gt; 8 &amp; 255), w &lt; g.length &amp;&amp; (g[w++] = V &gt;&gt; 16 &amp; 255), U === 6 ? (w &lt; g.length &amp;&amp; (g[w++] = V &gt;&gt; 24 &amp; 255), D = 0, U = 0) : (D = V &gt;&gt;&gt; 24, U += 2);\n        }\n        if (w &lt; g.length)\n          for (g[w++] = D; w &lt; g.length; )\n            g[w++] = 0;\n      }, i.prototype._toArrayLikeBE = function(g, x) {\n        for (var w = g.length - 1, D = 0, O = 0, U = 0; O &lt; this.length; O++) {\n          var V = this.words[O] &lt;&lt; U | D;\n          g[w--] = V &amp; 255, w &gt;= 0 &amp;&amp; (g[w--] = V &gt;&gt; 8 &amp; 255), w &gt;= 0 &amp;&amp; (g[w--] = V &gt;&gt; 16 &amp; 255), U === 6 ? (w &gt;= 0 &amp;&amp; (g[w--] = V &gt;&gt; 24 &amp; 255), D = 0, U = 0) : (D = V &gt;&gt;&gt; 24, U += 2);\n        }\n        if (w &gt;= 0)\n          for (g[w--] = D; w &gt;= 0; )\n            g[w--] = 0;\n      }, Math.clz32 ? i.prototype._countBits = function(g) {\n        return 32 - Math.clz32(g);\n      } : i.prototype._countBits = function(g) {\n        var x = g, w = 0;\n        return x &gt;= 4096 &amp;&amp; (w += 13, x &gt;&gt;&gt;= 13), x &gt;= 64 &amp;&amp; (w += 7, x &gt;&gt;&gt;= 7), x &gt;= 8 &amp;&amp; (w += 4, x &gt;&gt;&gt;= 4), x &gt;= 2 &amp;&amp; (w += 2, x &gt;&gt;&gt;= 2), w + x;\n      }, i.prototype._zeroBits = function(g) {\n        if (g === 0) return 26;\n        var x = g, w = 0;\n        return (x &amp; 8191) === 0 &amp;&amp; (w += 13, x &gt;&gt;&gt;= 13), (x &amp; 127) === 0 &amp;&amp; (w += 7, x &gt;&gt;&gt;= 7), (x &amp; 15) === 0 &amp;&amp; (w += 4, x &gt;&gt;&gt;= 4), (x &amp; 3) === 0 &amp;&amp; (w += 2, x &gt;&gt;&gt;= 2), (x &amp; 1) === 0 &amp;&amp; w++, w;\n      }, i.prototype.bitLength = function() {\n        var g = this.words[this.length - 1], x = this._countBits(g);\n        return (this.length - 1) * 26 + x;\n      };\n      function E(_) {\n        for (var g = new Array(_.bitLength()), x = 0; x &lt; g.length; x++) {\n          var w = x / 26 | 0, D = x % 26;\n          g[x] = _.words[w] &gt;&gt;&gt; D &amp; 1;\n        }\n        return g;\n      }\n      i.prototype.zeroBits = function() {\n        if (this.isZero()) return 0;\n        for (var g = 0, x = 0; x &lt; this.length; x++) {\n          var w = this._zeroBits(this.words[x]);\n          if (g += w, w !== 26) break;\n        }\n        return g;\n      }, i.prototype.byteLength = function() {\n        return Math.ceil(this.bitLength() / 8);\n      }, i.prototype.toTwos = function(g) {\n        return this.negative !== 0 ? this.abs().inotn(g).iaddn(1) : this.clone();\n      }, i.prototype.fromTwos = function(g) {\n        return this.testn(g - 1) ? this.notn(g).iaddn(1).ineg() : this.clone();\n      }, i.prototype.isNeg = function() {\n        return this.negative !== 0;\n      }, i.prototype.neg = function() {\n        return this.clone().ineg();\n      }, i.prototype.ineg = function() {\n        return this.isZero() || (this.negative ^= 1), this;\n      }, i.prototype.iuor = function(g) {\n        for (; this.length &lt; g.length; )\n          this.words[this.length++] = 0;\n        for (var x = 0; x &lt; g.length; x++)\n          this.words[x] = this.words[x] | g.words[x];\n        return this._strip();\n      }, i.prototype.ior = function(g) {\n        return r((this.negative | g.negative) === 0), this.iuor(g);\n      }, i.prototype.or = function(g) {\n        return this.length &gt; g.length ? this.clone().ior(g) : g.clone().ior(this);\n      }, i.prototype.uor = function(g) {\n        return this.length &gt; g.length ? this.clone().iuor(g) : g.clone().iuor(this);\n      }, i.prototype.iuand = function(g) {\n        var x;\n        this.length &gt; g.length ? x = g : x = this;\n        for (var w = 0; w &lt; x.length; w++)\n          this.words[w] = this.words[w] &amp; g.words[w];\n        return this.length = x.length, this._strip();\n      }, i.prototype.iand = function(g) {\n        return r((this.negative | g.negative) === 0), this.iuand(g);\n      }, i.prototype.and = function(g) {\n        return this.length &gt; g.length ? this.clone().iand(g) : g.clone().iand(this);\n      }, i.prototype.uand = function(g) {\n        return this.length &gt; g.length ? this.clone().iuand(g) : g.clone().iuand(this);\n      }, i.prototype.iuxor = function(g) {\n        var x, w;\n        this.length &gt; g.length ? (x = this, w = g) : (x = g, w = this);\n        for (var D = 0; D &lt; w.length; D++)\n          this.words[D] = x.words[D] ^ w.words[D];\n        if (this !== x)\n          for (; D &lt; x.length; D++)\n            this.words[D] = x.words[D];\n        return this.length = x.length, this._strip();\n      }, i.prototype.ixor = function(g) {\n        return r((this.negative | g.negative) === 0), this.iuxor(g);\n      }, i.prototype.xor = function(g) {\n        return this.length &gt; g.length ? this.clone().ixor(g) : g.clone().ixor(this);\n      }, i.prototype.uxor = function(g) {\n        return this.length &gt; g.length ? this.clone().iuxor(g) : g.clone().iuxor(this);\n      }, i.prototype.inotn = function(g) {\n        r(typeof g == \"number\" &amp;&amp; g &gt;= 0);\n        var x = Math.ceil(g / 26) | 0, w = g % 26;\n        this._expand(x), w &gt; 0 &amp;&amp; x--;\n        for (var D = 0; D &lt; x; D++)\n          this.words[D] = ~this.words[D] &amp; 67108863;\n        return w &gt; 0 &amp;&amp; (this.words[D] = ~this.words[D] &amp; 67108863 &gt;&gt; 26 - w), this._strip();\n      }, i.prototype.notn = function(g) {\n        return this.clone().inotn(g);\n      }, i.prototype.setn = function(g, x) {\n        r(typeof g == \"number\" &amp;&amp; g &gt;= 0);\n        var w = g / 26 | 0, D = g % 26;\n        return this._expand(w + 1), x ? this.words[w] = this.words[w] | 1 &lt;&lt; D : this.words[w] = this.words[w] &amp; ~(1 &lt;&lt; D), this._strip();\n      }, i.prototype.iadd = function(g) {\n        var x;\n        if (this.negative !== 0 &amp;&amp; g.negative === 0)\n          return this.negative = 0, x = this.isub(g), this.negative ^= 1, this._normSign();\n        if (this.negative === 0 &amp;&amp; g.negative !== 0)\n          return g.negative = 0, x = this.isub(g), g.negative = 1, x._normSign();\n        var w, D;\n        this.length &gt; g.length ? (w = this, D = g) : (w = g, D = this);\n        for (var O = 0, U = 0; U &lt; D.length; U++)\n          x = (w.words[U] | 0) + (D.words[U] | 0) + O, this.words[U] = x &amp; 67108863, O = x &gt;&gt;&gt; 26;\n        for (; O !== 0 &amp;&amp; U &lt; w.length; U++)\n          x = (w.words[U] | 0) + O, this.words[U] = x &amp; 67108863, O = x &gt;&gt;&gt; 26;\n        if (this.length = w.length, O !== 0)\n          this.words[this.length] = O, this.length++;\n        else if (w !== this)\n          for (; U &lt; w.length; U++)\n            this.words[U] = w.words[U];\n        return this;\n      }, i.prototype.add = function(g) {\n        var x;\n        return g.negative !== 0 &amp;&amp; this.negative === 0 ? (g.negative = 0, x = this.sub(g), g.negative ^= 1, x) : g.negative === 0 &amp;&amp; this.negative !== 0 ? (this.negative = 0, x = g.sub(this), this.negative = 1, x) : this.length &gt; g.length ? this.clone().iadd(g) : g.clone().iadd(this);\n      }, i.prototype.isub = function(g) {\n        if (g.negative !== 0) {\n          g.negative = 0;\n          var x = this.iadd(g);\n          return g.negative = 1, x._normSign();\n        } else if (this.negative !== 0)\n          return this.negative = 0, this.iadd(g), this.negative = 1, this._normSign();\n        var w = this.cmp(g);\n        if (w === 0)\n          return this.negative = 0, this.length = 1, this.words[0] = 0, this;\n        var D, O;\n        w &gt; 0 ? (D = this, O = g) : (D = g, O = this);\n        for (var U = 0, V = 0; V &lt; O.length; V++)\n          x = (D.words[V] | 0) - (O.words[V] | 0) + U, U = x &gt;&gt; 26, this.words[V] = x &amp; 67108863;\n        for (; U !== 0 &amp;&amp; V &lt; D.length; V++)\n          x = (D.words[V] | 0) + U, U = x &gt;&gt; 26, this.words[V] = x &amp; 67108863;\n        if (U === 0 &amp;&amp; V &lt; D.length &amp;&amp; D !== this)\n          for (; V &lt; D.length; V++)\n            this.words[V] = D.words[V];\n        return this.length = Math.max(this.length, V), D !== this &amp;&amp; (this.negative = 1), this._strip();\n      }, i.prototype.sub = function(g) {\n        return this.clone().isub(g);\n      };\n      function b(_, g, x) {\n        x.negative = g.negative ^ _.negative;\n        var w = _.length + g.length | 0;\n        x.length = w, w = w - 1 | 0;\n        var D = _.words[0] | 0, O = g.words[0] | 0, U = D * O, V = U &amp; 67108863, L = U / 67108864 | 0;\n        x.words[0] = V;\n        for (var m = 1; m &lt; w; m++) {\n          for (var v = L &gt;&gt;&gt; 26, P = L &amp; 67108863, N = Math.min(m, g.length - 1), Y = Math.max(0, m - _.length + 1); Y &lt;= N; Y++) {\n            var ee = m - Y | 0;\n            D = _.words[ee] | 0, O = g.words[Y] | 0, U = D * O + P, v += U / 67108864 | 0, P = U &amp; 67108863;\n          }\n          x.words[m] = P | 0, L = v | 0;\n        }\n        return L !== 0 ? x.words[m] = L | 0 : x.length--, x._strip();\n      }\n      var R = function(g, x, w) {\n        var D = g.words, O = x.words, U = w.words, V = 0, L, m, v, P = D[0] | 0, N = P &amp; 8191, Y = P &gt;&gt;&gt; 13, ee = D[1] | 0, ie = ee &amp; 8191, le = ee &gt;&gt;&gt; 13, Te = D[2] | 0, De = Te &amp; 8191, ze = Te &gt;&gt;&gt; 13, _e = D[3] | 0, xe = _e &amp; 8191, Be = _e &gt;&gt;&gt; 13, ye = D[4] | 0, be = ye &amp; 8191, Fe = ye &gt;&gt;&gt; 13, Xe = D[5] | 0, we = Xe &amp; 8191, Ne = Xe &gt;&gt;&gt; 13, dt = D[6] | 0, Je = dt &amp; 8191, Qe = dt &gt;&gt;&gt; 13, it = D[7] | 0, je = it &amp; 8191, B = it &gt;&gt;&gt; 13, S = D[8] | 0, T = S &amp; 8191, G = S &gt;&gt;&gt; 13, Z = D[9] | 0, Q = Z &amp; 8191, se = Z &gt;&gt;&gt; 13, Ue = O[0] | 0, Pe = Ue &amp; 8191, Le = Ue &gt;&gt;&gt; 13, ct = O[1] | 0, Ae = ct &amp; 8191, Tt = ct &gt;&gt;&gt; 13, Uu = O[2] | 0, wt = Uu &amp; 8191, At = Uu &gt;&gt;&gt; 13, $u = O[3] | 0, It = $u &amp; 8191, _t = $u &gt;&gt;&gt; 13, Gu = O[4] | 0, Rt = Gu &amp; 8191, Lt = Gu &gt;&gt;&gt; 13, Vu = O[5] | 0, Ct = Vu &amp; 8191, kt = Vu &gt;&gt;&gt; 13, ju = O[6] | 0, Dt = ju &amp; 8191, Pt = ju &gt;&gt;&gt; 13, Ku = O[7] | 0, Mt = Ku &amp; 8191, Ot = Ku &gt;&gt;&gt; 13, Hu = O[8] | 0, Bt = Hu &amp; 8191, Ft = Hu &gt;&gt;&gt; 13, qu = O[9] | 0, Nt = qu &amp; 8191, Ut = qu &gt;&gt;&gt; 13;\n        w.negative = g.negative ^ x.negative, w.length = 19, L = Math.imul(N, Pe), m = Math.imul(N, Le), m = m + Math.imul(Y, Pe) | 0, v = Math.imul(Y, Le);\n        var xa = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        V = (v + (m &gt;&gt;&gt; 13) | 0) + (xa &gt;&gt;&gt; 26) | 0, xa &amp;= 67108863, L = Math.imul(ie, Pe), m = Math.imul(ie, Le), m = m + Math.imul(le, Pe) | 0, v = Math.imul(le, Le), L = L + Math.imul(N, Ae) | 0, m = m + Math.imul(N, Tt) | 0, m = m + Math.imul(Y, Ae) | 0, v = v + Math.imul(Y, Tt) | 0;\n        var Sa = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        V = (v + (m &gt;&gt;&gt; 13) | 0) + (Sa &gt;&gt;&gt; 26) | 0, Sa &amp;= 67108863, L = Math.imul(De, Pe), m = Math.imul(De, Le), m = m + Math.imul(ze, Pe) | 0, v = Math.imul(ze, Le), L = L + Math.imul(ie, Ae) | 0, m = m + Math.imul(ie, Tt) | 0, m = m + Math.imul(le, Ae) | 0, v = v + Math.imul(le, Tt) | 0, L = L + Math.imul(N, wt) | 0, m = m + Math.imul(N, At) | 0, m = m + Math.imul(Y, wt) | 0, v = v + Math.imul(Y, At) | 0;\n        var ba = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        V = (v + (m &gt;&gt;&gt; 13) | 0) + (ba &gt;&gt;&gt; 26) | 0, ba &amp;= 67108863, L = Math.imul(xe, Pe), m = Math.imul(xe, Le), m = m + Math.imul(Be, Pe) | 0, v = Math.imul(Be, Le), L = L + Math.imul(De, Ae) | 0, m = m + Math.imul(De, Tt) | 0, m = m + Math.imul(ze, Ae) | 0, v = v + Math.imul(ze, Tt) | 0, L = L + Math.imul(ie, wt) | 0, m = m + Math.imul(ie, At) | 0, m = m + Math.imul(le, wt) | 0, v = v + Math.imul(le, At) | 0, L = L + Math.imul(N, It) | 0, m = m + Math.imul(N, _t) | 0, m = m + Math.imul(Y, It) | 0, v = v + Math.imul(Y, _t) | 0;\n        var Ta = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        V = (v + (m &gt;&gt;&gt; 13) | 0) + (Ta &gt;&gt;&gt; 26) | 0, Ta &amp;= 67108863, L = Math.imul(be, Pe), m = Math.imul(be, Le), m = m + Math.imul(Fe, Pe) | 0, v = Math.imul(Fe, Le), L = L + Math.imul(xe, Ae) | 0, m = m + Math.imul(xe, Tt) | 0, m = m + Math.imul(Be, Ae) | 0, v = v + Math.imul(Be, Tt) | 0, L = L + Math.imul(De, wt) | 0, m = m + Math.imul(De, At) | 0, m = m + Math.imul(ze, wt) | 0, v = v + Math.imul(ze, At) | 0, L = L + Math.imul(ie, It) | 0, m = m + Math.imul(ie, _t) | 0, m = m + Math.imul(le, It) | 0, v = v + Math.imul(le, _t) | 0, L = L + Math.imul(N, Rt) | 0, m = m + Math.imul(N, Lt) | 0, m = m + Math.imul(Y, Rt) | 0, v = v + Math.imul(Y, Lt) | 0;\n        var wa = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        V = (v + (m &gt;&gt;&gt; 13) | 0) + (wa &gt;&gt;&gt; 26) | 0, wa &amp;= 67108863, L = Math.imul(we, Pe), m = Math.imul(we, Le), m = m + Math.imul(Ne, Pe) | 0, v = Math.imul(Ne, Le), L = L + Math.imul(be, Ae) | 0, m = m + Math.imul(be, Tt) | 0, m = m + Math.imul(Fe, Ae) | 0, v = v + Math.imul(Fe, Tt) | 0, L = L + Math.imul(xe, wt) | 0, m = m + Math.imul(xe, At) | 0, m = m + Math.imul(Be, wt) | 0, v = v + Math.imul(Be, At) | 0, L = L + Math.imul(De, It) | 0, m = m + Math.imul(De, _t) | 0, m = m + Math.imul(ze, It) | 0, v = v + Math.imul(ze, _t) | 0, L = L + Math.imul(ie, Rt) | 0, m = m + Math.imul(ie, Lt) | 0, m = m + Math.imul(le, Rt) | 0, v = v + Math.imul(le, Lt) | 0, L = L + Math.imul(N, Ct) | 0, m = m + Math.imul(N, kt) | 0, m = m + Math.imul(Y, Ct) | 0, v = v + Math.imul(Y, kt) | 0;\n        var Aa = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        V = (v + (m &gt;&gt;&gt; 13) | 0) + (Aa &gt;&gt;&gt; 26) | 0, Aa &amp;= 67108863, L = Math.imul(Je, Pe), m = Math.imul(Je, Le), m = m + Math.imul(Qe, Pe) | 0, v = Math.imul(Qe, Le), L = L + Math.imul(we, Ae) | 0, m = m + Math.imul(we, Tt) | 0, m = m + Math.imul(Ne, Ae) | 0, v = v + Math.imul(Ne, Tt) | 0, L = L + Math.imul(be, wt) | 0, m = m + Math.imul(be, At) | 0, m = m + Math.imul(Fe, wt) | 0, v = v + Math.imul(Fe, At) | 0, L = L + Math.imul(xe, It) | 0, m = m + Math.imul(xe, _t) | 0, m = m + Math.imul(Be, It) | 0, v = v + Math.imul(Be, _t) | 0, L = L + Math.imul(De, Rt) | 0, m = m + Math.imul(De, Lt) | 0, m = m + Math.imul(ze, Rt) | 0, v = v + Math.imul(ze, Lt) | 0, L = L + Math.imul(ie, Ct) | 0, m = m + Math.imul(ie, kt) | 0, m = m + Math.imul(le, Ct) | 0, v = v + Math.imul(le, kt) | 0, L = L + Math.imul(N, Dt) | 0, m = m + Math.imul(N, Pt) | 0, m = m + Math.imul(Y, Dt) | 0, v = v + Math.imul(Y, Pt) | 0;\n        var Ia = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        V = (v + (m &gt;&gt;&gt; 13) | 0) + (Ia &gt;&gt;&gt; 26) | 0, Ia &amp;= 67108863, L = Math.imul(je, Pe), m = Math.imul(je, Le), m = m + Math.imul(B, Pe) | 0, v = Math.imul(B, Le), L = L + Math.imul(Je, Ae) | 0, m = m + Math.imul(Je, Tt) | 0, m = m + Math.imul(Qe, Ae) | 0, v = v + Math.imul(Qe, Tt) | 0, L = L + Math.imul(we, wt) | 0, m = m + Math.imul(we, At) | 0, m = m + Math.imul(Ne, wt) | 0, v = v + Math.imul(Ne, At) | 0, L = L + Math.imul(be, It) | 0, m = m + Math.imul(be, _t) | 0, m = m + Math.imul(Fe, It) | 0, v = v + Math.imul(Fe, _t) | 0, L = L + Math.imul(xe, Rt) | 0, m = m + Math.imul(xe, Lt) | 0, m = m + Math.imul(Be, Rt) | 0, v = v + Math.imul(Be, Lt) | 0, L = L + Math.imul(De, Ct) | 0, m = m + Math.imul(De, kt) | 0, m = m + Math.imul(ze, Ct) | 0, v = v + Math.imul(ze, kt) | 0, L = L + Math.imul(ie, Dt) | 0, m = m + Math.imul(ie, Pt) | 0, m = m + Math.imul(le, Dt) | 0, v = v + Math.imul(le, Pt) | 0, L = L + Math.imul(N, Mt) | 0, m = m + Math.imul(N, Ot) | 0, m = m + Math.imul(Y, Mt) | 0, v = v + Math.imul(Y, Ot) | 0;\n        var _a = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        V = (v + (m &gt;&gt;&gt; 13) | 0) + (_a &gt;&gt;&gt; 26) | 0, _a &amp;= 67108863, L = Math.imul(T, Pe), m = Math.imul(T, Le), m = m + Math.imul(G, Pe) | 0, v = Math.imul(G, Le), L = L + Math.imul(je, Ae) | 0, m = m + Math.imul(je, Tt) | 0, m = m + Math.imul(B, Ae) | 0, v = v + Math.imul(B, Tt) | 0, L = L + Math.imul(Je, wt) | 0, m = m + Math.imul(Je, At) | 0, m = m + Math.imul(Qe, wt) | 0, v = v + Math.imul(Qe, At) | 0, L = L + Math.imul(we, It) | 0, m = m + Math.imul(we, _t) | 0, m = m + Math.imul(Ne, It) | 0, v = v + Math.imul(Ne, _t) | 0, L = L + Math.imul(be, Rt) | 0, m = m + Math.imul(be, Lt) | 0, m = m + Math.imul(Fe, Rt) | 0, v = v + Math.imul(Fe, Lt) | 0, L = L + Math.imul(xe, Ct) | 0, m = m + Math.imul(xe, kt) | 0, m = m + Math.imul(Be, Ct) | 0, v = v + Math.imul(Be, kt) | 0, L = L + Math.imul(De, Dt) | 0, m = m + Math.imul(De, Pt) | 0, m = m + Math.imul(ze, Dt) | 0, v = v + Math.imul(ze, Pt) | 0, L = L + Math.imul(ie, Mt) | 0, m = m + Math.imul(ie, Ot) | 0, m = m + Math.imul(le, Mt) | 0, v = v + Math.imul(le, Ot) | 0, L = L + Math.imul(N, Bt) | 0, m = m + Math.imul(N, Ft) | 0, m = m + Math.imul(Y, Bt) | 0, v = v + Math.imul(Y, Ft) | 0;\n        var Ra = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        V = (v + (m &gt;&gt;&gt; 13) | 0) + (Ra &gt;&gt;&gt; 26) | 0, Ra &amp;= 67108863, L = Math.imul(Q, Pe), m = Math.imul(Q, Le), m = m + Math.imul(se, Pe) | 0, v = Math.imul(se, Le), L = L + Math.imul(T, Ae) | 0, m = m + Math.imul(T, Tt) | 0, m = m + Math.imul(G, Ae) | 0, v = v + Math.imul(G, Tt) | 0, L = L + Math.imul(je, wt) | 0, m = m + Math.imul(je, At) | 0, m = m + Math.imul(B, wt) | 0, v = v + Math.imul(B, At) | 0, L = L + Math.imul(Je, It) | 0, m = m + Math.imul(Je, _t) | 0, m = m + Math.imul(Qe, It) | 0, v = v + Math.imul(Qe, _t) | 0, L = L + Math.imul(we, Rt) | 0, m = m + Math.imul(we, Lt) | 0, m = m + Math.imul(Ne, Rt) | 0, v = v + Math.imul(Ne, Lt) | 0, L = L + Math.imul(be, Ct) | 0, m = m + Math.imul(be, kt) | 0, m = m + Math.imul(Fe, Ct) | 0, v = v + Math.imul(Fe, kt) | 0, L = L + Math.imul(xe, Dt) | 0, m = m + Math.imul(xe, Pt) | 0, m = m + Math.imul(Be, Dt) | 0, v = v + Math.imul(Be, Pt) | 0, L = L + Math.imul(De, Mt) | 0, m = m + Math.imul(De, Ot) | 0, m = m + Math.imul(ze, Mt) | 0, v = v + Math.imul(ze, Ot) | 0, L = L + Math.imul(ie, Bt) | 0, m = m + Math.imul(ie, Ft) | 0, m = m + Math.imul(le, Bt) | 0, v = v + Math.imul(le, Ft) | 0, L = L + Math.imul(N, Nt) | 0, m = m + Math.imul(N, Ut) | 0, m = m + Math.imul(Y, Nt) | 0, v = v + Math.imul(Y, Ut) | 0;\n        var La = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        V = (v + (m &gt;&gt;&gt; 13) | 0) + (La &gt;&gt;&gt; 26) | 0, La &amp;= 67108863, L = Math.imul(Q, Ae), m = Math.imul(Q, Tt), m = m + Math.imul(se, Ae) | 0, v = Math.imul(se, Tt), L = L + Math.imul(T, wt) | 0, m = m + Math.imul(T, At) | 0, m = m + Math.imul(G, wt) | 0, v = v + Math.imul(G, At) | 0, L = L + Math.imul(je, It) | 0, m = m + Math.imul(je, _t) | 0, m = m + Math.imul(B, It) | 0, v = v + Math.imul(B, _t) | 0, L = L + Math.imul(Je, Rt) | 0, m = m + Math.imul(Je, Lt) | 0, m = m + Math.imul(Qe, Rt) | 0, v = v + Math.imul(Qe, Lt) | 0, L = L + Math.imul(we, Ct) | 0, m = m + Math.imul(we, kt) | 0, m = m + Math.imul(Ne, Ct) | 0, v = v + Math.imul(Ne, kt) | 0, L = L + Math.imul(be, Dt) | 0, m = m + Math.imul(be, Pt) | 0, m = m + Math.imul(Fe, Dt) | 0, v = v + Math.imul(Fe, Pt) | 0, L = L + Math.imul(xe, Mt) | 0, m = m + Math.imul(xe, Ot) | 0, m = m + Math.imul(Be, Mt) | 0, v = v + Math.imul(Be, Ot) | 0, L = L + Math.imul(De, Bt) | 0, m = m + Math.imul(De, Ft) | 0, m = m + Math.imul(ze, Bt) | 0, v = v + Math.imul(ze, Ft) | 0, L = L + Math.imul(ie, Nt) | 0, m = m + Math.imul(ie, Ut) | 0, m = m + Math.imul(le, Nt) | 0, v = v + Math.imul(le, Ut) | 0;\n        var Ca = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        V = (v + (m &gt;&gt;&gt; 13) | 0) + (Ca &gt;&gt;&gt; 26) | 0, Ca &amp;= 67108863, L = Math.imul(Q, wt), m = Math.imul(Q, At), m = m + Math.imul(se, wt) | 0, v = Math.imul(se, At), L = L + Math.imul(T, It) | 0, m = m + Math.imul(T, _t) | 0, m = m + Math.imul(G, It) | 0, v = v + Math.imul(G, _t) | 0, L = L + Math.imul(je, Rt) | 0, m = m + Math.imul(je, Lt) | 0, m = m + Math.imul(B, Rt) | 0, v = v + Math.imul(B, Lt) | 0, L = L + Math.imul(Je, Ct) | 0, m = m + Math.imul(Je, kt) | 0, m = m + Math.imul(Qe, Ct) | 0, v = v + Math.imul(Qe, kt) | 0, L = L + Math.imul(we, Dt) | 0, m = m + Math.imul(we, Pt) | 0, m = m + Math.imul(Ne, Dt) | 0, v = v + Math.imul(Ne, Pt) | 0, L = L + Math.imul(be, Mt) | 0, m = m + Math.imul(be, Ot) | 0, m = m + Math.imul(Fe, Mt) | 0, v = v + Math.imul(Fe, Ot) | 0, L = L + Math.imul(xe, Bt) | 0, m = m + Math.imul(xe, Ft) | 0, m = m + Math.imul(Be, Bt) | 0, v = v + Math.imul(Be, Ft) | 0, L = L + Math.imul(De, Nt) | 0, m = m + Math.imul(De, Ut) | 0, m = m + Math.imul(ze, Nt) | 0, v = v + Math.imul(ze, Ut) | 0;\n        var ka = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        V = (v + (m &gt;&gt;&gt; 13) | 0) + (ka &gt;&gt;&gt; 26) | 0, ka &amp;= 67108863, L = Math.imul(Q, It), m = Math.imul(Q, _t), m = m + Math.imul(se, It) | 0, v = Math.imul(se, _t), L = L + Math.imul(T, Rt) | 0, m = m + Math.imul(T, Lt) | 0, m = m + Math.imul(G, Rt) | 0, v = v + Math.imul(G, Lt) | 0, L = L + Math.imul(je, Ct) | 0, m = m + Math.imul(je, kt) | 0, m = m + Math.imul(B, Ct) | 0, v = v + Math.imul(B, kt) | 0, L = L + Math.imul(Je, Dt) | 0, m = m + Math.imul(Je, Pt) | 0, m = m + Math.imul(Qe, Dt) | 0, v = v + Math.imul(Qe, Pt) | 0, L = L + Math.imul(we, Mt) | 0, m = m + Math.imul(we, Ot) | 0, m = m + Math.imul(Ne, Mt) | 0, v = v + Math.imul(Ne, Ot) | 0, L = L + Math.imul(be, Bt) | 0, m = m + Math.imul(be, Ft) | 0, m = m + Math.imul(Fe, Bt) | 0, v = v + Math.imul(Fe, Ft) | 0, L = L + Math.imul(xe, Nt) | 0, m = m + Math.imul(xe, Ut) | 0, m = m + Math.imul(Be, Nt) | 0, v = v + Math.imul(Be, Ut) | 0;\n        var Da = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        V = (v + (m &gt;&gt;&gt; 13) | 0) + (Da &gt;&gt;&gt; 26) | 0, Da &amp;= 67108863, L = Math.imul(Q, Rt), m = Math.imul(Q, Lt), m = m + Math.imul(se, Rt) | 0, v = Math.imul(se, Lt), L = L + Math.imul(T, Ct) | 0, m = m + Math.imul(T, kt) | 0, m = m + Math.imul(G, Ct) | 0, v = v + Math.imul(G, kt) | 0, L = L + Math.imul(je, Dt) | 0, m = m + Math.imul(je, Pt) | 0, m = m + Math.imul(B, Dt) | 0, v = v + Math.imul(B, Pt) | 0, L = L + Math.imul(Je, Mt) | 0, m = m + Math.imul(Je, Ot) | 0, m = m + Math.imul(Qe, Mt) | 0, v = v + Math.imul(Qe, Ot) | 0, L = L + Math.imul(we, Bt) | 0, m = m + Math.imul(we, Ft) | 0, m = m + Math.imul(Ne, Bt) | 0, v = v + Math.imul(Ne, Ft) | 0, L = L + Math.imul(be, Nt) | 0, m = m + Math.imul(be, Ut) | 0, m = m + Math.imul(Fe, Nt) | 0, v = v + Math.imul(Fe, Ut) | 0;\n        var Pa = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        V = (v + (m &gt;&gt;&gt; 13) | 0) + (Pa &gt;&gt;&gt; 26) | 0, Pa &amp;= 67108863, L = Math.imul(Q, Ct), m = Math.imul(Q, kt), m = m + Math.imul(se, Ct) | 0, v = Math.imul(se, kt), L = L + Math.imul(T, Dt) | 0, m = m + Math.imul(T, Pt) | 0, m = m + Math.imul(G, Dt) | 0, v = v + Math.imul(G, Pt) | 0, L = L + Math.imul(je, Mt) | 0, m = m + Math.imul(je, Ot) | 0, m = m + Math.imul(B, Mt) | 0, v = v + Math.imul(B, Ot) | 0, L = L + Math.imul(Je, Bt) | 0, m = m + Math.imul(Je, Ft) | 0, m = m + Math.imul(Qe, Bt) | 0, v = v + Math.imul(Qe, Ft) | 0, L = L + Math.imul(we, Nt) | 0, m = m + Math.imul(we, Ut) | 0, m = m + Math.imul(Ne, Nt) | 0, v = v + Math.imul(Ne, Ut) | 0;\n        var Ma = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        V = (v + (m &gt;&gt;&gt; 13) | 0) + (Ma &gt;&gt;&gt; 26) | 0, Ma &amp;= 67108863, L = Math.imul(Q, Dt), m = Math.imul(Q, Pt), m = m + Math.imul(se, Dt) | 0, v = Math.imul(se, Pt), L = L + Math.imul(T, Mt) | 0, m = m + Math.imul(T, Ot) | 0, m = m + Math.imul(G, Mt) | 0, v = v + Math.imul(G, Ot) | 0, L = L + Math.imul(je, Bt) | 0, m = m + Math.imul(je, Ft) | 0, m = m + Math.imul(B, Bt) | 0, v = v + Math.imul(B, Ft) | 0, L = L + Math.imul(Je, Nt) | 0, m = m + Math.imul(Je, Ut) | 0, m = m + Math.imul(Qe, Nt) | 0, v = v + Math.imul(Qe, Ut) | 0;\n        var Oa = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        V = (v + (m &gt;&gt;&gt; 13) | 0) + (Oa &gt;&gt;&gt; 26) | 0, Oa &amp;= 67108863, L = Math.imul(Q, Mt), m = Math.imul(Q, Ot), m = m + Math.imul(se, Mt) | 0, v = Math.imul(se, Ot), L = L + Math.imul(T, Bt) | 0, m = m + Math.imul(T, Ft) | 0, m = m + Math.imul(G, Bt) | 0, v = v + Math.imul(G, Ft) | 0, L = L + Math.imul(je, Nt) | 0, m = m + Math.imul(je, Ut) | 0, m = m + Math.imul(B, Nt) | 0, v = v + Math.imul(B, Ut) | 0;\n        var Ba = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        V = (v + (m &gt;&gt;&gt; 13) | 0) + (Ba &gt;&gt;&gt; 26) | 0, Ba &amp;= 67108863, L = Math.imul(Q, Bt), m = Math.imul(Q, Ft), m = m + Math.imul(se, Bt) | 0, v = Math.imul(se, Ft), L = L + Math.imul(T, Nt) | 0, m = m + Math.imul(T, Ut) | 0, m = m + Math.imul(G, Nt) | 0, v = v + Math.imul(G, Ut) | 0;\n        var Fa = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        V = (v + (m &gt;&gt;&gt; 13) | 0) + (Fa &gt;&gt;&gt; 26) | 0, Fa &amp;= 67108863, L = Math.imul(Q, Nt), m = Math.imul(Q, Ut), m = m + Math.imul(se, Nt) | 0, v = Math.imul(se, Ut);\n        var Na = (V + L | 0) + ((m &amp; 8191) &lt;&lt; 13) | 0;\n        return V = (v + (m &gt;&gt;&gt; 13) | 0) + (Na &gt;&gt;&gt; 26) | 0, Na &amp;= 67108863, U[0] = xa, U[1] = Sa, U[2] = ba, U[3] = Ta, U[4] = wa, U[5] = Aa, U[6] = Ia, U[7] = _a, U[8] = Ra, U[9] = La, U[10] = Ca, U[11] = ka, U[12] = Da, U[13] = Pa, U[14] = Ma, U[15] = Oa, U[16] = Ba, U[17] = Fa, U[18] = Na, V !== 0 &amp;&amp; (U[19] = V, w.length++), w;\n      };\n      Math.imul || (R = b);\n      function A(_, g, x) {\n        x.negative = g.negative ^ _.negative, x.length = _.length + g.length;\n        for (var w = 0, D = 0, O = 0; O &lt; x.length - 1; O++) {\n          var U = D;\n          D = 0;\n          for (var V = w &amp; 67108863, L = Math.min(O, g.length - 1), m = Math.max(0, O - _.length + 1); m &lt;= L; m++) {\n            var v = O - m, P = _.words[v] | 0, N = g.words[m] | 0, Y = P * N, ee = Y &amp; 67108863;\n            U = U + (Y / 67108864 | 0) | 0, ee = ee + V | 0, V = ee &amp; 67108863, U = U + (ee &gt;&gt;&gt; 26) | 0, D += U &gt;&gt;&gt; 26, U &amp;= 67108863;\n          }\n          x.words[O] = V, w = U, U = D;\n        }\n        return w !== 0 ? x.words[O] = w : x.length--, x._strip();\n      }\n      function F(_, g, x) {\n        return A(_, g, x);\n      }\n      i.prototype.mulTo = function(g, x) {\n        var w, D = this.length + g.length;\n        return this.length === 10 &amp;&amp; g.length === 10 ? w = R(this, g, x) : D &lt; 63 ? w = b(this, g, x) : D &lt; 1024 ? w = A(this, g, x) : w = F(this, g, x), w;\n      }, i.prototype.mul = function(g) {\n        var x = new i(null);\n        return x.words = new Array(this.length + g.length), this.mulTo(g, x);\n      }, i.prototype.mulf = function(g) {\n        var x = new i(null);\n        return x.words = new Array(this.length + g.length), F(this, g, x);\n      }, i.prototype.imul = function(g) {\n        return this.clone().mulTo(g, this);\n      }, i.prototype.imuln = function(g) {\n        var x = g &lt; 0;\n        x &amp;&amp; (g = -g), r(typeof g == \"number\"), r(g &lt; 67108864);\n        for (var w = 0, D = 0; D &lt; this.length; D++) {\n          var O = (this.words[D] | 0) * g, U = (O &amp; 67108863) + (w &amp; 67108863);\n          w &gt;&gt;= 26, w += O / 67108864 | 0, w += U &gt;&gt;&gt; 26, this.words[D] = U &amp; 67108863;\n        }\n        return w !== 0 &amp;&amp; (this.words[D] = w, this.length++), this.length = g === 0 ? 1 : this.length, x ? this.ineg() : this;\n      }, i.prototype.muln = function(g) {\n        return this.clone().imuln(g);\n      }, i.prototype.sqr = function() {\n        return this.mul(this);\n      }, i.prototype.isqr = function() {\n        return this.imul(this.clone());\n      }, i.prototype.pow = function(g) {\n        var x = E(g);\n        if (x.length === 0) return new i(1);\n        for (var w = this, D = 0; D &lt; x.length &amp;&amp; x[D] === 0; D++, w = w.sqr())\n          ;\n        if (++D &lt; x.length)\n          for (var O = w.sqr(); D &lt; x.length; D++, O = O.sqr())\n            x[D] !== 0 &amp;&amp; (w = w.mul(O));\n        return w;\n      }, i.prototype.iushln = function(g) {\n        r(typeof g == \"number\" &amp;&amp; g &gt;= 0);\n        var x = g % 26, w = (g - x) / 26, D = 67108863 &gt;&gt;&gt; 26 - x &lt;&lt; 26 - x, O;\n        if (x !== 0) {\n          var U = 0;\n          for (O = 0; O &lt; this.length; O++) {\n            var V = this.words[O] &amp; D, L = (this.words[O] | 0) - V &lt;&lt; x;\n            this.words[O] = L | U, U = V &gt;&gt;&gt; 26 - x;\n          }\n          U &amp;&amp; (this.words[O] = U, this.length++);\n        }\n        if (w !== 0) {\n          for (O = this.length - 1; O &gt;= 0; O--)\n            this.words[O + w] = this.words[O];\n          for (O = 0; O &lt; w; O++)\n            this.words[O] = 0;\n          this.length += w;\n        }\n        return this._strip();\n      }, i.prototype.ishln = function(g) {\n        return r(this.negative === 0), this.iushln(g);\n      }, i.prototype.iushrn = function(g, x, w) {\n        r(typeof g == \"number\" &amp;&amp; g &gt;= 0);\n        var D;\n        x ? D = (x - x % 26) / 26 : D = 0;\n        var O = g % 26, U = Math.min((g - O) / 26, this.length), V = 67108863 ^ 67108863 &gt;&gt;&gt; O &lt;&lt; O, L = w;\n        if (D -= U, D = Math.max(0, D), L) {\n          for (var m = 0; m &lt; U; m++)\n            L.words[m] = this.words[m];\n          L.length = U;\n        }\n        if (U !== 0) if (this.length &gt; U)\n          for (this.length -= U, m = 0; m &lt; this.length; m++)\n            this.words[m] = this.words[m + U];\n        else\n          this.words[0] = 0, this.length = 1;\n        var v = 0;\n        for (m = this.length - 1; m &gt;= 0 &amp;&amp; (v !== 0 || m &gt;= D); m--) {\n          var P = this.words[m] | 0;\n          this.words[m] = v &lt;&lt; 26 - O | P &gt;&gt;&gt; O, v = P &amp; V;\n        }\n        return L &amp;&amp; v !== 0 &amp;&amp; (L.words[L.length++] = v), this.length === 0 &amp;&amp; (this.words[0] = 0, this.length = 1), this._strip();\n      }, i.prototype.ishrn = function(g, x, w) {\n        return r(this.negative === 0), this.iushrn(g, x, w);\n      }, i.prototype.shln = function(g) {\n        return this.clone().ishln(g);\n      }, i.prototype.ushln = function(g) {\n        return this.clone().iushln(g);\n      }, i.prototype.shrn = function(g) {\n        return this.clone().ishrn(g);\n      }, i.prototype.ushrn = function(g) {\n        return this.clone().iushrn(g);\n      }, i.prototype.testn = function(g) {\n        r(typeof g == \"number\" &amp;&amp; g &gt;= 0);\n        var x = g % 26, w = (g - x) / 26, D = 1 &lt;&lt; x;\n        if (this.length &lt;= w) return !1;\n        var O = this.words[w];\n        return !!(O &amp; D);\n      }, i.prototype.imaskn = function(g) {\n        r(typeof g == \"number\" &amp;&amp; g &gt;= 0);\n        var x = g % 26, w = (g - x) / 26;\n        if (r(this.negative === 0, \"imaskn works only with positive numbers\"), this.length &lt;= w)\n          return this;\n        if (x !== 0 &amp;&amp; w++, this.length = Math.min(w, this.length), x !== 0) {\n          var D = 67108863 ^ 67108863 &gt;&gt;&gt; x &lt;&lt; x;\n          this.words[this.length - 1] &amp;= D;\n        }\n        return this._strip();\n      }, i.prototype.maskn = function(g) {\n        return this.clone().imaskn(g);\n      }, i.prototype.iaddn = function(g) {\n        return r(typeof g == \"number\"), r(g &lt; 67108864), g &lt; 0 ? this.isubn(-g) : this.negative !== 0 ? this.length === 1 &amp;&amp; (this.words[0] | 0) &lt;= g ? (this.words[0] = g - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(g), this.negative = 1, this) : this._iaddn(g);\n      }, i.prototype._iaddn = function(g) {\n        this.words[0] += g;\n        for (var x = 0; x &lt; this.length &amp;&amp; this.words[x] &gt;= 67108864; x++)\n          this.words[x] -= 67108864, x === this.length - 1 ? this.words[x + 1] = 1 : this.words[x + 1]++;\n        return this.length = Math.max(this.length, x + 1), this;\n      }, i.prototype.isubn = function(g) {\n        if (r(typeof g == \"number\"), r(g &lt; 67108864), g &lt; 0) return this.iaddn(-g);\n        if (this.negative !== 0)\n          return this.negative = 0, this.iaddn(g), this.negative = 1, this;\n        if (this.words[0] -= g, this.length === 1 &amp;&amp; this.words[0] &lt; 0)\n          this.words[0] = -this.words[0], this.negative = 1;\n        else\n          for (var x = 0; x &lt; this.length &amp;&amp; this.words[x] &lt; 0; x++)\n            this.words[x] += 67108864, this.words[x + 1] -= 1;\n        return this._strip();\n      }, i.prototype.addn = function(g) {\n        return this.clone().iaddn(g);\n      }, i.prototype.subn = function(g) {\n        return this.clone().isubn(g);\n      }, i.prototype.iabs = function() {\n        return this.negative = 0, this;\n      }, i.prototype.abs = function() {\n        return this.clone().iabs();\n      }, i.prototype._ishlnsubmul = function(g, x, w) {\n        var D = g.length + w, O;\n        this._expand(D);\n        var U, V = 0;\n        for (O = 0; O &lt; g.length; O++) {\n          U = (this.words[O + w] | 0) + V;\n          var L = (g.words[O] | 0) * x;\n          U -= L &amp; 67108863, V = (U &gt;&gt; 26) - (L / 67108864 | 0), this.words[O + w] = U &amp; 67108863;\n        }\n        for (; O &lt; this.length - w; O++)\n          U = (this.words[O + w] | 0) + V, V = U &gt;&gt; 26, this.words[O + w] = U &amp; 67108863;\n        if (V === 0) return this._strip();\n        for (r(V === -1), V = 0, O = 0; O &lt; this.length; O++)\n          U = -(this.words[O] | 0) + V, V = U &gt;&gt; 26, this.words[O] = U &amp; 67108863;\n        return this.negative = 1, this._strip();\n      }, i.prototype._wordDiv = function(g, x) {\n        var w = this.length - g.length, D = this.clone(), O = g, U = O.words[O.length - 1] | 0, V = this._countBits(U);\n        w = 26 - V, w !== 0 &amp;&amp; (O = O.ushln(w), D.iushln(w), U = O.words[O.length - 1] | 0);\n        var L = D.length - O.length, m;\n        if (x !== \"mod\") {\n          m = new i(null), m.length = L + 1, m.words = new Array(m.length);\n          for (var v = 0; v &lt; m.length; v++)\n            m.words[v] = 0;\n        }\n        var P = D.clone()._ishlnsubmul(O, 1, L);\n        P.negative === 0 &amp;&amp; (D = P, m &amp;&amp; (m.words[L] = 1));\n        for (var N = L - 1; N &gt;= 0; N--) {\n          var Y = (D.words[O.length + N] | 0) * 67108864 + (D.words[O.length + N - 1] | 0);\n          for (Y = Math.min(Y / U | 0, 67108863), D._ishlnsubmul(O, Y, N); D.negative !== 0; )\n            Y--, D.negative = 0, D._ishlnsubmul(O, 1, N), D.isZero() || (D.negative ^= 1);\n          m &amp;&amp; (m.words[N] = Y);\n        }\n        return m &amp;&amp; m._strip(), D._strip(), x !== \"div\" &amp;&amp; w !== 0 &amp;&amp; D.iushrn(w), {\n          div: m || null,\n          mod: D\n        };\n      }, i.prototype.divmod = function(g, x, w) {\n        if (r(!g.isZero()), this.isZero())\n          return {\n            div: new i(0),\n            mod: new i(0)\n          };\n        var D, O, U;\n        return this.negative !== 0 &amp;&amp; g.negative === 0 ? (U = this.neg().divmod(g, x), x !== \"mod\" &amp;&amp; (D = U.div.neg()), x !== \"div\" &amp;&amp; (O = U.mod.neg(), w &amp;&amp; O.negative !== 0 &amp;&amp; O.iadd(g)), {\n          div: D,\n          mod: O\n        }) : this.negative === 0 &amp;&amp; g.negative !== 0 ? (U = this.divmod(g.neg(), x), x !== \"mod\" &amp;&amp; (D = U.div.neg()), {\n          div: D,\n          mod: U.mod\n        }) : (this.negative &amp; g.negative) !== 0 ? (U = this.neg().divmod(g.neg(), x), x !== \"div\" &amp;&amp; (O = U.mod.neg(), w &amp;&amp; O.negative !== 0 &amp;&amp; O.isub(g)), {\n          div: U.div,\n          mod: O\n        }) : g.length &gt; this.length || this.cmp(g) &lt; 0 ? {\n          div: new i(0),\n          mod: this\n        } : g.length === 1 ? x === \"div\" ? {\n          div: this.divn(g.words[0]),\n          mod: null\n        } : x === \"mod\" ? {\n          div: null,\n          mod: new i(this.modrn(g.words[0]))\n        } : {\n          div: this.divn(g.words[0]),\n          mod: new i(this.modrn(g.words[0]))\n        } : this._wordDiv(g, x);\n      }, i.prototype.div = function(g) {\n        return this.divmod(g, \"div\", !1).div;\n      }, i.prototype.mod = function(g) {\n        return this.divmod(g, \"mod\", !1).mod;\n      }, i.prototype.umod = function(g) {\n        return this.divmod(g, \"mod\", !0).mod;\n      }, i.prototype.divRound = function(g) {\n        var x = this.divmod(g);\n        if (x.mod.isZero()) return x.div;\n        var w = x.div.negative !== 0 ? x.mod.isub(g) : x.mod, D = g.ushrn(1), O = g.andln(1), U = w.cmp(D);\n        return U &lt; 0 || O === 1 &amp;&amp; U === 0 ? x.div : x.div.negative !== 0 ? x.div.isubn(1) : x.div.iaddn(1);\n      }, i.prototype.modrn = function(g) {\n        var x = g &lt; 0;\n        x &amp;&amp; (g = -g), r(g &lt;= 67108863);\n        for (var w = (1 &lt;&lt; 26) % g, D = 0, O = this.length - 1; O &gt;= 0; O--)\n          D = (w * D + (this.words[O] | 0)) % g;\n        return x ? -D : D;\n      }, i.prototype.modn = function(g) {\n        return this.modrn(g);\n      }, i.prototype.idivn = function(g) {\n        var x = g &lt; 0;\n        x &amp;&amp; (g = -g), r(g &lt;= 67108863);\n        for (var w = 0, D = this.length - 1; D &gt;= 0; D--) {\n          var O = (this.words[D] | 0) + w * 67108864;\n          this.words[D] = O / g | 0, w = O % g;\n        }\n        return this._strip(), x ? this.ineg() : this;\n      }, i.prototype.divn = function(g) {\n        return this.clone().idivn(g);\n      }, i.prototype.egcd = function(g) {\n        r(g.negative === 0), r(!g.isZero());\n        var x = this, w = g.clone();\n        x.negative !== 0 ? x = x.umod(g) : x = x.clone();\n        for (var D = new i(1), O = new i(0), U = new i(0), V = new i(1), L = 0; x.isEven() &amp;&amp; w.isEven(); )\n          x.iushrn(1), w.iushrn(1), ++L;\n        for (var m = w.clone(), v = x.clone(); !x.isZero(); ) {\n          for (var P = 0, N = 1; (x.words[0] &amp; N) === 0 &amp;&amp; P &lt; 26; ++P, N &lt;&lt;= 1) ;\n          if (P &gt; 0)\n            for (x.iushrn(P); P-- &gt; 0; )\n              (D.isOdd() || O.isOdd()) &amp;&amp; (D.iadd(m), O.isub(v)), D.iushrn(1), O.iushrn(1);\n          for (var Y = 0, ee = 1; (w.words[0] &amp; ee) === 0 &amp;&amp; Y &lt; 26; ++Y, ee &lt;&lt;= 1) ;\n          if (Y &gt; 0)\n            for (w.iushrn(Y); Y-- &gt; 0; )\n              (U.isOdd() || V.isOdd()) &amp;&amp; (U.iadd(m), V.isub(v)), U.iushrn(1), V.iushrn(1);\n          x.cmp(w) &gt;= 0 ? (x.isub(w), D.isub(U), O.isub(V)) : (w.isub(x), U.isub(D), V.isub(O));\n        }\n        return {\n          a: U,\n          b: V,\n          gcd: w.iushln(L)\n        };\n      }, i.prototype._invmp = function(g) {\n        r(g.negative === 0), r(!g.isZero());\n        var x = this, w = g.clone();\n        x.negative !== 0 ? x = x.umod(g) : x = x.clone();\n        for (var D = new i(1), O = new i(0), U = w.clone(); x.cmpn(1) &gt; 0 &amp;&amp; w.cmpn(1) &gt; 0; ) {\n          for (var V = 0, L = 1; (x.words[0] &amp; L) === 0 &amp;&amp; V &lt; 26; ++V, L &lt;&lt;= 1) ;\n          if (V &gt; 0)\n            for (x.iushrn(V); V-- &gt; 0; )\n              D.isOdd() &amp;&amp; D.iadd(U), D.iushrn(1);\n          for (var m = 0, v = 1; (w.words[0] &amp; v) === 0 &amp;&amp; m &lt; 26; ++m, v &lt;&lt;= 1) ;\n          if (m &gt; 0)\n            for (w.iushrn(m); m-- &gt; 0; )\n              O.isOdd() &amp;&amp; O.iadd(U), O.iushrn(1);\n          x.cmp(w) &gt;= 0 ? (x.isub(w), D.isub(O)) : (w.isub(x), O.isub(D));\n        }\n        var P;\n        return x.cmpn(1) === 0 ? P = D : P = O, P.cmpn(0) &lt; 0 &amp;&amp; P.iadd(g), P;\n      }, i.prototype.gcd = function(g) {\n        if (this.isZero()) return g.abs();\n        if (g.isZero()) return this.abs();\n        var x = this.clone(), w = g.clone();\n        x.negative = 0, w.negative = 0;\n        for (var D = 0; x.isEven() &amp;&amp; w.isEven(); D++)\n          x.iushrn(1), w.iushrn(1);\n        do {\n          for (; x.isEven(); )\n            x.iushrn(1);\n          for (; w.isEven(); )\n            w.iushrn(1);\n          var O = x.cmp(w);\n          if (O &lt; 0) {\n            var U = x;\n            x = w, w = U;\n          } else if (O === 0 || w.cmpn(1) === 0)\n            break;\n          x.isub(w);\n        } while (!0);\n        return w.iushln(D);\n      }, i.prototype.invm = function(g) {\n        return this.egcd(g).a.umod(g);\n      }, i.prototype.isEven = function() {\n        return (this.words[0] &amp; 1) === 0;\n      }, i.prototype.isOdd = function() {\n        return (this.words[0] &amp; 1) === 1;\n      }, i.prototype.andln = function(g) {\n        return this.words[0] &amp; g;\n      }, i.prototype.bincn = function(g) {\n        r(typeof g == \"number\");\n        var x = g % 26, w = (g - x) / 26, D = 1 &lt;&lt; x;\n        if (this.length &lt;= w)\n          return this._expand(w + 1), this.words[w] |= D, this;\n        for (var O = D, U = w; O !== 0 &amp;&amp; U &lt; this.length; U++) {\n          var V = this.words[U] | 0;\n          V += O, O = V &gt;&gt;&gt; 26, V &amp;= 67108863, this.words[U] = V;\n        }\n        return O !== 0 &amp;&amp; (this.words[U] = O, this.length++), this;\n      }, i.prototype.isZero = function() {\n        return this.length === 1 &amp;&amp; this.words[0] === 0;\n      }, i.prototype.cmpn = function(g) {\n        var x = g &lt; 0;\n        if (this.negative !== 0 &amp;&amp; !x) return -1;\n        if (this.negative === 0 &amp;&amp; x) return 1;\n        this._strip();\n        var w;\n        if (this.length &gt; 1)\n          w = 1;\n        else {\n          x &amp;&amp; (g = -g), r(g &lt;= 67108863, \"Number is too big\");\n          var D = this.words[0] | 0;\n          w = D === g ? 0 : D &lt; g ? -1 : 1;\n        }\n        return this.negative !== 0 ? -w | 0 : w;\n      }, i.prototype.cmp = function(g) {\n        if (this.negative !== 0 &amp;&amp; g.negative === 0) return -1;\n        if (this.negative === 0 &amp;&amp; g.negative !== 0) return 1;\n        var x = this.ucmp(g);\n        return this.negative !== 0 ? -x | 0 : x;\n      }, i.prototype.ucmp = function(g) {\n        if (this.length &gt; g.length) return 1;\n        if (this.length &lt; g.length) return -1;\n        for (var x = 0, w = this.length - 1; w &gt;= 0; w--) {\n          var D = this.words[w] | 0, O = g.words[w] | 0;\n          if (D !== O) {\n            D &lt; O ? x = -1 : D &gt; O &amp;&amp; (x = 1);\n            break;\n          }\n        }\n        return x;\n      }, i.prototype.gtn = function(g) {\n        return this.cmpn(g) === 1;\n      }, i.prototype.gt = function(g) {\n        return this.cmp(g) === 1;\n      }, i.prototype.gten = function(g) {\n        return this.cmpn(g) &gt;= 0;\n      }, i.prototype.gte = function(g) {\n        return this.cmp(g) &gt;= 0;\n      }, i.prototype.ltn = function(g) {\n        return this.cmpn(g) === -1;\n      }, i.prototype.lt = function(g) {\n        return this.cmp(g) === -1;\n      }, i.prototype.lten = function(g) {\n        return this.cmpn(g) &lt;= 0;\n      }, i.prototype.lte = function(g) {\n        return this.cmp(g) &lt;= 0;\n      }, i.prototype.eqn = function(g) {\n        return this.cmpn(g) === 0;\n      }, i.prototype.eq = function(g) {\n        return this.cmp(g) === 0;\n      }, i.red = function(g) {\n        return new $(g);\n      }, i.prototype.toRed = function(g) {\n        return r(!this.red, \"Already a number in reduction context\"), r(this.negative === 0, \"red works only with positives\"), g.convertTo(this)._forceRed(g);\n      }, i.prototype.fromRed = function() {\n        return r(this.red, \"fromRed works only with numbers in reduction context\"), this.red.convertFrom(this);\n      }, i.prototype._forceRed = function(g) {\n        return this.red = g, this;\n      }, i.prototype.forceRed = function(g) {\n        return r(!this.red, \"Already a number in reduction context\"), this._forceRed(g);\n      }, i.prototype.redAdd = function(g) {\n        return r(this.red, \"redAdd works only with red numbers\"), this.red.add(this, g);\n      }, i.prototype.redIAdd = function(g) {\n        return r(this.red, \"redIAdd works only with red numbers\"), this.red.iadd(this, g);\n      }, i.prototype.redSub = function(g) {\n        return r(this.red, \"redSub works only with red numbers\"), this.red.sub(this, g);\n      }, i.prototype.redISub = function(g) {\n        return r(this.red, \"redISub works only with red numbers\"), this.red.isub(this, g);\n      }, i.prototype.redShl = function(g) {\n        return r(this.red, \"redShl works only with red numbers\"), this.red.shl(this, g);\n      }, i.prototype.redMul = function(g) {\n        return r(this.red, \"redMul works only with red numbers\"), this.red._verify2(this, g), this.red.mul(this, g);\n      }, i.prototype.redIMul = function(g) {\n        return r(this.red, \"redMul works only with red numbers\"), this.red._verify2(this, g), this.red.imul(this, g);\n      }, i.prototype.redSqr = function() {\n        return r(this.red, \"redSqr works only with red numbers\"), this.red._verify1(this), this.red.sqr(this);\n      }, i.prototype.redISqr = function() {\n        return r(this.red, \"redISqr works only with red numbers\"), this.red._verify1(this), this.red.isqr(this);\n      }, i.prototype.redSqrt = function() {\n        return r(this.red, \"redSqrt works only with red numbers\"), this.red._verify1(this), this.red.sqrt(this);\n      }, i.prototype.redInvm = function() {\n        return r(this.red, \"redInvm works only with red numbers\"), this.red._verify1(this), this.red.invm(this);\n      }, i.prototype.redNeg = function() {\n        return r(this.red, \"redNeg works only with red numbers\"), this.red._verify1(this), this.red.neg(this);\n      }, i.prototype.redPow = function(g) {\n        return r(this.red &amp;&amp; !g.red, \"redPow(normalNum)\"), this.red._verify1(this), this.red.pow(this, g);\n      };\n      var M = {\n        k256: null,\n        p224: null,\n        p192: null,\n        p25519: null\n      };\n      function H(_, g) {\n        this.name = _, this.p = new i(g, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();\n      }\n      H.prototype._tmp = function() {\n        var g = new i(null);\n        return g.words = new Array(Math.ceil(this.n / 13)), g;\n      }, H.prototype.ireduce = function(g) {\n        var x = g, w;\n        do\n          this.split(x, this.tmp), x = this.imulK(x), x = x.iadd(this.tmp), w = x.bitLength();\n        while (w &gt; this.n);\n        var D = w &lt; this.n ? -1 : x.ucmp(this.p);\n        return D === 0 ? (x.words[0] = 0, x.length = 1) : D &gt; 0 ? x.isub(this.p) : x.strip !== void 0 ? x.strip() : x._strip(), x;\n      }, H.prototype.split = function(g, x) {\n        g.iushrn(this.n, 0, x);\n      }, H.prototype.imulK = function(g) {\n        return g.imul(this.k);\n      };\n      function K() {\n        H.call(\n          this,\n          \"k256\",\n          \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\"\n        );\n      }\n      n(K, H), K.prototype.split = function(g, x) {\n        for (var w = 4194303, D = Math.min(g.length, 9), O = 0; O &lt; D; O++)\n          x.words[O] = g.words[O];\n        if (x.length = D, g.length &lt;= 9) {\n          g.words[0] = 0, g.length = 1;\n          return;\n        }\n        var U = g.words[9];\n        for (x.words[x.length++] = U &amp; w, O = 10; O &lt; g.length; O++) {\n          var V = g.words[O] | 0;\n          g.words[O - 10] = (V &amp; w) &lt;&lt; 4 | U &gt;&gt;&gt; 22, U = V;\n        }\n        U &gt;&gt;&gt;= 22, g.words[O - 10] = U, U === 0 &amp;&amp; g.length &gt; 10 ? g.length -= 10 : g.length -= 9;\n      }, K.prototype.imulK = function(g) {\n        g.words[g.length] = 0, g.words[g.length + 1] = 0, g.length += 2;\n        for (var x = 0, w = 0; w &lt; g.length; w++) {\n          var D = g.words[w] | 0;\n          x += D * 977, g.words[w] = x &amp; 67108863, x = D * 64 + (x / 67108864 | 0);\n        }\n        return g.words[g.length - 1] === 0 &amp;&amp; (g.length--, g.words[g.length - 1] === 0 &amp;&amp; g.length--), g;\n      };\n      function j() {\n        H.call(\n          this,\n          \"p224\",\n          \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\"\n        );\n      }\n      n(j, H);\n      function C() {\n        H.call(\n          this,\n          \"p192\",\n          \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\"\n        );\n      }\n      n(C, H);\n      function k() {\n        H.call(\n          this,\n          \"25519\",\n          \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\"\n        );\n      }\n      n(k, H), k.prototype.imulK = function(g) {\n        for (var x = 0, w = 0; w &lt; g.length; w++) {\n          var D = (g.words[w] | 0) * 19 + x, O = D &amp; 67108863;\n          D &gt;&gt;&gt;= 26, g.words[w] = O, x = D;\n        }\n        return x !== 0 &amp;&amp; (g.words[g.length++] = x), g;\n      }, i._prime = function(g) {\n        if (M[g]) return M[g];\n        var x;\n        if (g === \"k256\")\n          x = new K();\n        else if (g === \"p224\")\n          x = new j();\n        else if (g === \"p192\")\n          x = new C();\n        else if (g === \"p25519\")\n          x = new k();\n        else\n          throw new Error(\"Unknown prime \" + g);\n        return M[g] = x, x;\n      };\n      function $(_) {\n        if (typeof _ == \"string\") {\n          var g = i._prime(_);\n          this.m = g.p, this.prime = g;\n        } else\n          r(_.gtn(1), \"modulus must be greater than 1\"), this.m = _, this.prime = null;\n      }\n      $.prototype._verify1 = function(g) {\n        r(g.negative === 0, \"red works only with positives\"), r(g.red, \"red works only with red numbers\");\n      }, $.prototype._verify2 = function(g, x) {\n        r((g.negative | x.negative) === 0, \"red works only with positives\"), r(\n          g.red &amp;&amp; g.red === x.red,\n          \"red works only with red numbers\"\n        );\n      }, $.prototype.imod = function(g) {\n        return this.prime ? this.prime.ireduce(g)._forceRed(this) : (u(g, g.umod(this.m)._forceRed(this)), g);\n      }, $.prototype.neg = function(g) {\n        return g.isZero() ? g.clone() : this.m.sub(g)._forceRed(this);\n      }, $.prototype.add = function(g, x) {\n        this._verify2(g, x);\n        var w = g.add(x);\n        return w.cmp(this.m) &gt;= 0 &amp;&amp; w.isub(this.m), w._forceRed(this);\n      }, $.prototype.iadd = function(g, x) {\n        this._verify2(g, x);\n        var w = g.iadd(x);\n        return w.cmp(this.m) &gt;= 0 &amp;&amp; w.isub(this.m), w;\n      }, $.prototype.sub = function(g, x) {\n        this._verify2(g, x);\n        var w = g.sub(x);\n        return w.cmpn(0) &lt; 0 &amp;&amp; w.iadd(this.m), w._forceRed(this);\n      }, $.prototype.isub = function(g, x) {\n        this._verify2(g, x);\n        var w = g.isub(x);\n        return w.cmpn(0) &lt; 0 &amp;&amp; w.iadd(this.m), w;\n      }, $.prototype.shl = function(g, x) {\n        return this._verify1(g), this.imod(g.ushln(x));\n      }, $.prototype.imul = function(g, x) {\n        return this._verify2(g, x), this.imod(g.imul(x));\n      }, $.prototype.mul = function(g, x) {\n        return this._verify2(g, x), this.imod(g.mul(x));\n      }, $.prototype.isqr = function(g) {\n        return this.imul(g, g.clone());\n      }, $.prototype.sqr = function(g) {\n        return this.mul(g, g);\n      }, $.prototype.sqrt = function(g) {\n        if (g.isZero()) return g.clone();\n        var x = this.m.andln(3);\n        if (r(x % 2 === 1), x === 3) {\n          var w = this.m.add(new i(1)).iushrn(2);\n          return this.pow(g, w);\n        }\n        for (var D = this.m.subn(1), O = 0; !D.isZero() &amp;&amp; D.andln(1) === 0; )\n          O++, D.iushrn(1);\n        r(!D.isZero());\n        var U = new i(1).toRed(this), V = U.redNeg(), L = this.m.subn(1).iushrn(1), m = this.m.bitLength();\n        for (m = new i(2 * m * m).toRed(this); this.pow(m, L).cmp(V) !== 0; )\n          m.redIAdd(V);\n        for (var v = this.pow(m, D), P = this.pow(g, D.addn(1).iushrn(1)), N = this.pow(g, D), Y = O; N.cmp(U) !== 0; ) {\n          for (var ee = N, ie = 0; ee.cmp(U) !== 0; ie++)\n            ee = ee.redSqr();\n          r(ie &lt; Y);\n          var le = this.pow(v, new i(1).iushln(Y - ie - 1));\n          P = P.redMul(le), v = le.redSqr(), N = N.redMul(v), Y = ie;\n        }\n        return P;\n      }, $.prototype.invm = function(g) {\n        var x = g._invmp(this.m);\n        return x.negative !== 0 ? (x.negative = 0, this.imod(x).redNeg()) : this.imod(x);\n      }, $.prototype.pow = function(g, x) {\n        if (x.isZero()) return new i(1).toRed(this);\n        if (x.cmpn(1) === 0) return g.clone();\n        var w = 4, D = new Array(1 &lt;&lt; w);\n        D[0] = new i(1).toRed(this), D[1] = g;\n        for (var O = 2; O &lt; D.length; O++)\n          D[O] = this.mul(D[O - 1], g);\n        var U = D[0], V = 0, L = 0, m = x.bitLength() % 26;\n        for (m === 0 &amp;&amp; (m = 26), O = x.length - 1; O &gt;= 0; O--) {\n          for (var v = x.words[O], P = m - 1; P &gt;= 0; P--) {\n            var N = v &gt;&gt; P &amp; 1;\n            if (U !== D[0] &amp;&amp; (U = this.sqr(U)), N === 0 &amp;&amp; V === 0) {\n              L = 0;\n              continue;\n            }\n            V &lt;&lt;= 1, V |= N, L++, !(L !== w &amp;&amp; (O !== 0 || P !== 0)) &amp;&amp; (U = this.mul(U, D[V]), L = 0, V = 0);\n          }\n          m = 26;\n        }\n        return U;\n      }, $.prototype.convertTo = function(g) {\n        var x = g.umod(this.m);\n        return x === g ? x.clone() : x;\n      }, $.prototype.convertFrom = function(g) {\n        var x = g.clone();\n        return x.red = null, x;\n      }, i.mont = function(g) {\n        return new W(g);\n      };\n      function W(_) {\n        $.call(this, _), this.shift = this.m.bitLength(), this.shift % 26 !== 0 &amp;&amp; (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);\n      }\n      n(W, $), W.prototype.convertTo = function(g) {\n        return this.imod(g.ushln(this.shift));\n      }, W.prototype.convertFrom = function(g) {\n        var x = this.imod(g.mul(this.rinv));\n        return x.red = null, x;\n      }, W.prototype.imul = function(g, x) {\n        if (g.isZero() || x.isZero())\n          return g.words[0] = 0, g.length = 1, g;\n        var w = g.imul(x), D = w.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = w.isub(D).iushrn(this.shift), U = O;\n        return O.cmp(this.m) &gt;= 0 ? U = O.isub(this.m) : O.cmpn(0) &lt; 0 &amp;&amp; (U = O.iadd(this.m)), U._forceRed(this);\n      }, W.prototype.mul = function(g, x) {\n        if (g.isZero() || x.isZero()) return new i(0)._forceRed(this);\n        var w = g.mul(x), D = w.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = w.isub(D).iushrn(this.shift), U = O;\n        return O.cmp(this.m) &gt;= 0 ? U = O.isub(this.m) : O.cmpn(0) &lt; 0 &amp;&amp; (U = O.iadd(this.m)), U._forceRed(this);\n      }, W.prototype.invm = function(g) {\n        var x = this.imod(g._invmp(this.m).mul(this.r2));\n        return x._forceRed(this);\n      };\n    })(s, My);\n  })(co)), co.exports;\n}\nvar Oy = v0();\nconst bd = /* @__PURE__ */ Fc(Oy);\nvar Ui = { exports: {} };\n/*! safe-buffer. MIT License. Feross Aboukhadijeh &lt;https://feross.org/opensource&gt; */\nvar Td;\nfunction By() {\n  return Td || (Td = 1, (function(s, e) {\n    var t = Kc(), r = t.Buffer;\n    function n(o, a) {\n      for (var l in o)\n        a[l] = o[l];\n    }\n    r.from &amp;&amp; r.alloc &amp;&amp; r.allocUnsafe &amp;&amp; r.allocUnsafeSlow ? s.exports = t : (n(t, e), e.Buffer = i);\n    function i(o, a, l) {\n      return r(o, a, l);\n    }\n    i.prototype = Object.create(r.prototype), n(r, i), i.from = function(o, a, l) {\n      if (typeof o == \"number\")\n        throw new TypeError(\"Argument must not be a number\");\n      return r(o, a, l);\n    }, i.alloc = function(o, a, l) {\n      if (typeof o != \"number\")\n        throw new TypeError(\"Argument must be a number\");\n      var c = r(o);\n      return a !== void 0 ? typeof l == \"string\" ? c.fill(a, l) : c.fill(a) : c.fill(0), c;\n    }, i.allocUnsafe = function(o) {\n      if (typeof o != \"number\")\n        throw new TypeError(\"Argument must be a number\");\n      return r(o);\n    }, i.allocUnsafeSlow = function(o) {\n      if (typeof o != \"number\")\n        throw new TypeError(\"Argument must be a number\");\n      return t.SlowBuffer(o);\n    };\n  })(Ui, Ui.exports)), Ui.exports;\n}\nvar za, wd;\nfunction E0() {\n  if (wd) return za;\n  wd = 1;\n  var s = By().Buffer;\n  function e(t) {\n    if (t.length &gt;= 255)\n      throw new TypeError(\"Alphabet too long\");\n    for (var r = new Uint8Array(256), n = 0; n &lt; r.length; n++)\n      r[n] = 255;\n    for (var i = 0; i &lt; t.length; i++) {\n      var o = t.charAt(i), a = o.charCodeAt(0);\n      if (r[a] !== 255)\n        throw new TypeError(o + \" is ambiguous\");\n      r[a] = i;\n    }\n    var l = t.length, c = t.charAt(0), u = Math.log(l) / Math.log(256), d = Math.log(256) / Math.log(l);\n    function h(y) {\n      if ((Array.isArray(y) || y instanceof Uint8Array) &amp;&amp; (y = s.from(y)), !s.isBuffer(y))\n        throw new TypeError(\"Expected Buffer\");\n      if (y.length === 0)\n        return \"\";\n      for (var E = 0, b = 0, R = 0, A = y.length; R !== A &amp;&amp; y[R] === 0; )\n        R++, E++;\n      for (var F = (A - R) * d + 1 &gt;&gt;&gt; 0, M = new Uint8Array(F); R !== A; ) {\n        for (var H = y[R], K = 0, j = F - 1; (H !== 0 || K &lt; b) &amp;&amp; j !== -1; j--, K++)\n          H += 256 * M[j] &gt;&gt;&gt; 0, M[j] = H % l &gt;&gt;&gt; 0, H = H / l &gt;&gt;&gt; 0;\n        if (H !== 0)\n          throw new Error(\"Non-zero carry\");\n        b = K, R++;\n      }\n      for (var C = F - b; C !== F &amp;&amp; M[C] === 0; )\n        C++;\n      for (var k = c.repeat(E); C &lt; F; ++C)\n        k += t.charAt(M[C]);\n      return k;\n    }\n    function f(y) {\n      if (typeof y != \"string\")\n        throw new TypeError(\"Expected String\");\n      if (y.length === 0)\n        return s.alloc(0);\n      for (var E = 0, b = 0, R = 0; y[E] === c; )\n        b++, E++;\n      for (var A = (y.length - E) * u + 1 &gt;&gt;&gt; 0, F = new Uint8Array(A); E &lt; y.length; ) {\n        var M = y.charCodeAt(E);\n        if (M &gt; 255)\n          return;\n        var H = r[M];\n        if (H === 255)\n          return;\n        for (var K = 0, j = A - 1; (H !== 0 || K &lt; R) &amp;&amp; j !== -1; j--, K++)\n          H += l * F[j] &gt;&gt;&gt; 0, F[j] = H % 256 &gt;&gt;&gt; 0, H = H / 256 &gt;&gt;&gt; 0;\n        if (H !== 0)\n          throw new Error(\"Non-zero carry\");\n        R = K, E++;\n      }\n      for (var C = A - R; C !== A &amp;&amp; F[C] === 0; )\n        C++;\n      var k = s.allocUnsafe(b + (A - C));\n      k.fill(0, 0, b);\n      for (var $ = b; C !== A; )\n        k[$++] = F[C++];\n      return k;\n    }\n    function p(y) {\n      var E = f(y);\n      if (E)\n        return E;\n      throw new Error(\"Non-base\" + l + \" character\");\n    }\n    return {\n      encode: h,\n      decodeUnsafe: f,\n      decode: p\n    };\n  }\n  return za = e, za;\n}\nvar Ya, Ad;\nfunction Fy() {\n  if (Ad) return Ya;\n  Ad = 1;\n  var s = E0(), e = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n  return Ya = s(e), Ya;\n}\nvar Ny = Fy();\nconst ar = /* @__PURE__ */ Fc(Ny), Id = Xf;\nvar et = {}, Za, _d;\nfunction Uy() {\n  if (_d) return Za;\n  _d = 1;\n  var s = E0(), e = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n  return Za = s(e), Za;\n}\nfunction us(s, e, t) {\n  return e &lt;= s &amp;&amp; s &lt;= t;\n}\nfunction ca(s) {\n  if (s === void 0) return {};\n  if (s === Object(s)) return s;\n  throw TypeError(\"Could not convert argument to dictionary\");\n}\nfunction $y(s) {\n  for (var e = String(s), t = e.length, r = 0, n = []; r &lt; t; ) {\n    var i = e.charCodeAt(r);\n    if (i &lt; 55296 || i &gt; 57343)\n      n.push(i);\n    else if (56320 &lt;= i &amp;&amp; i &lt;= 57343)\n      n.push(65533);\n    else if (55296 &lt;= i &amp;&amp; i &lt;= 56319)\n      if (r === t - 1)\n        n.push(65533);\n      else {\n        var o = s.charCodeAt(r + 1);\n        if (56320 &lt;= o &amp;&amp; o &lt;= 57343) {\n          var a = i &amp; 1023, l = o &amp; 1023;\n          n.push(65536 + (a &lt;&lt; 10) + l), r += 1;\n        } else\n          n.push(65533);\n      }\n    r += 1;\n  }\n  return n;\n}\nfunction Gy(s) {\n  for (var e = \"\", t = 0; t &lt; s.length; ++t) {\n    var r = s[t];\n    r &lt;= 65535 ? e += String.fromCharCode(r) : (r -= 65536, e += String.fromCharCode(\n      (r &gt;&gt; 10) + 55296,\n      (r &amp; 1023) + 56320\n    ));\n  }\n  return e;\n}\nvar Bo = -1;\nfunction Xc(s) {\n  this.tokens = [].slice.call(s);\n}\nXc.prototype = {\n  /**\n   * @return {boolean} True if end-of-stream has been hit.\n   */\n  endOfStream: function() {\n    return !this.tokens.length;\n  },\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return {number} Get the next token from the stream, or\n   * end_of_stream.\n   */\n  read: function() {\n    return this.tokens.length ? this.tokens.shift() : Bo;\n  },\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param {(number|!Array.&lt;number&gt;)} token The token(s) to prepend to the stream.\n   */\n  prepend: function(s) {\n    if (Array.isArray(s))\n      for (var e = (\n        /**@type {!Array.&lt;number&gt;}*/\n        s\n      ); e.length; )\n        this.tokens.unshift(e.pop());\n    else\n      this.tokens.unshift(s);\n  },\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param {(number|!Array.&lt;number&gt;)} token The tokens(s) to prepend to the stream.\n   */\n  push: function(s) {\n    if (Array.isArray(s))\n      for (var e = (\n        /**@type {!Array.&lt;number&gt;}*/\n        s\n      ); e.length; )\n        this.tokens.push(e.shift());\n    else\n      this.tokens.push(s);\n  }\n};\nvar Pn = -1;\nfunction Xa(s, e) {\n  if (s)\n    throw TypeError(\"Decoder error\");\n  return e || 65533;\n}\nvar Fo = \"utf-8\";\nfunction No(s, e) {\n  if (!(this instanceof No))\n    return new No(s, e);\n  if (s = s !== void 0 ? String(s).toLowerCase() : Fo, s !== Fo)\n    throw new Error(\"Encoding not supported. Only utf-8 is supported\");\n  e = ca(e), this._streaming = !1, this._BOMseen = !1, this._decoder = null, this._fatal = !!e.fatal, this._ignoreBOM = !!e.ignoreBOM, Object.defineProperty(this, \"encoding\", { value: \"utf-8\" }), Object.defineProperty(this, \"fatal\", { value: this._fatal }), Object.defineProperty(this, \"ignoreBOM\", { value: this._ignoreBOM });\n}\nNo.prototype = {\n  /**\n   * @param {ArrayBufferView=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */\n  decode: function(e, t) {\n    var r;\n    typeof e == \"object\" &amp;&amp; e instanceof ArrayBuffer ? r = new Uint8Array(e) : typeof e == \"object\" &amp;&amp; \"buffer\" in e &amp;&amp; e.buffer instanceof ArrayBuffer ? r = new Uint8Array(\n      e.buffer,\n      e.byteOffset,\n      e.byteLength\n    ) : r = new Uint8Array(0), t = ca(t), this._streaming || (this._decoder = new Vy({ fatal: this._fatal }), this._BOMseen = !1), this._streaming = !!t.stream;\n    for (var n = new Xc(r), i = [], o; !n.endOfStream() &amp;&amp; (o = this._decoder.handler(n, n.read()), o !== Pn); )\n      o !== null &amp;&amp; (Array.isArray(o) ? i.push.apply(\n        i,\n        /**@type {!Array.&lt;number&gt;}*/\n        o\n      ) : i.push(o));\n    if (!this._streaming) {\n      do {\n        if (o = this._decoder.handler(n, n.read()), o === Pn)\n          break;\n        o !== null &amp;&amp; (Array.isArray(o) ? i.push.apply(\n          i,\n          /**@type {!Array.&lt;number&gt;}*/\n          o\n        ) : i.push(o));\n      } while (!n.endOfStream());\n      this._decoder = null;\n    }\n    return i.length &amp;&amp; [\"utf-8\"].indexOf(this.encoding) !== -1 &amp;&amp; !this._ignoreBOM &amp;&amp; !this._BOMseen &amp;&amp; (i[0] === 65279 ? (this._BOMseen = !0, i.shift()) : this._BOMseen = !0), Gy(i);\n  }\n};\nfunction Uo(s, e) {\n  if (!(this instanceof Uo))\n    return new Uo(s, e);\n  if (s = s !== void 0 ? String(s).toLowerCase() : Fo, s !== Fo)\n    throw new Error(\"Encoding not supported. Only utf-8 is supported\");\n  e = ca(e), this._streaming = !1, this._encoder = null, this._options = { fatal: !!e.fatal }, Object.defineProperty(this, \"encoding\", { value: \"utf-8\" });\n}\nUo.prototype = {\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {Uint8Array} Encoded bytes, as a Uint8Array.\n   */\n  encode: function(e, t) {\n    e = e ? String(e) : \"\", t = ca(t), this._streaming || (this._encoder = new jy(this._options)), this._streaming = !!t.stream;\n    for (var r = [], n = new Xc($y(e)), i; !n.endOfStream() &amp;&amp; (i = this._encoder.handler(n, n.read()), i !== Pn); )\n      Array.isArray(i) ? r.push.apply(\n        r,\n        /**@type {!Array.&lt;number&gt;}*/\n        i\n      ) : r.push(i);\n    if (!this._streaming) {\n      for (; i = this._encoder.handler(n, n.read()), i !== Pn; )\n        Array.isArray(i) ? r.push.apply(\n          r,\n          /**@type {!Array.&lt;number&gt;}*/\n          i\n        ) : r.push(i);\n      this._encoder = null;\n    }\n    return new Uint8Array(r);\n  }\n};\nfunction Vy(s) {\n  var e = s.fatal, t = 0, r = 0, n = 0, i = 128, o = 191;\n  this.handler = function(a, l) {\n    if (l === Bo &amp;&amp; n !== 0)\n      return n = 0, Xa(e);\n    if (l === Bo)\n      return Pn;\n    if (n === 0) {\n      if (us(l, 0, 127))\n        return l;\n      if (us(l, 194, 223))\n        n = 1, t = l - 192;\n      else if (us(l, 224, 239))\n        l === 224 &amp;&amp; (i = 160), l === 237 &amp;&amp; (o = 159), n = 2, t = l - 224;\n      else if (us(l, 240, 244))\n        l === 240 &amp;&amp; (i = 144), l === 244 &amp;&amp; (o = 143), n = 3, t = l - 240;\n      else\n        return Xa(e);\n      return t = t &lt;&lt; 6 * n, null;\n    }\n    if (!us(l, i, o))\n      return t = n = r = 0, i = 128, o = 191, a.prepend(l), Xa(e);\n    if (i = 128, o = 191, r += 1, t += l - 128 &lt;&lt; 6 * (n - r), r !== n)\n      return null;\n    var c = t;\n    return t = n = r = 0, c;\n  };\n}\nfunction jy(s) {\n  s.fatal, this.handler = function(e, t) {\n    if (t === Bo)\n      return Pn;\n    if (us(t, 0, 127))\n      return t;\n    var r, n;\n    us(t, 128, 2047) ? (r = 1, n = 192) : us(t, 2048, 65535) ? (r = 2, n = 224) : us(t, 65536, 1114111) &amp;&amp; (r = 3, n = 240);\n    for (var i = [(t &gt;&gt; 6 * r) + n]; r &gt; 0; ) {\n      var o = t &gt;&gt; 6 * (r - 1);\n      i.push(128 | o &amp; 63), r -= 1;\n    }\n    return i;\n  };\n}\nconst Ky = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  TextDecoder: No,\n  TextEncoder: Uo\n}, Symbol.toStringTag, { value: \"Module\" })), Hy = /* @__PURE__ */ Nc(Ky);\nvar Rd;\nfunction qy() {\n  if (Rd) return et;\n  Rd = 1;\n  var s = et &amp;&amp; et.__createBinding || (Object.create ? (function(C, k, $, W) {\n    W === void 0 &amp;&amp; (W = $), Object.defineProperty(C, W, { enumerable: !0, get: function() {\n      return k[$];\n    } });\n  }) : (function(C, k, $, W) {\n    W === void 0 &amp;&amp; (W = $), C[W] = k[$];\n  })), e = et &amp;&amp; et.__setModuleDefault || (Object.create ? (function(C, k) {\n    Object.defineProperty(C, \"default\", { enumerable: !0, value: k });\n  }) : function(C, k) {\n    C.default = k;\n  }), t = et &amp;&amp; et.__decorate || function(C, k, $, W) {\n    var _ = arguments.length, g = _ &lt; 3 ? k : W === null ? W = Object.getOwnPropertyDescriptor(k, $) : W, x;\n    if (typeof Reflect == \"object\" &amp;&amp; typeof Reflect.decorate == \"function\") g = Reflect.decorate(C, k, $, W);\n    else for (var w = C.length - 1; w &gt;= 0; w--) (x = C[w]) &amp;&amp; (g = (_ &lt; 3 ? x(g) : _ &gt; 3 ? x(k, $, g) : x(k, $)) || g);\n    return _ &gt; 3 &amp;&amp; g &amp;&amp; Object.defineProperty(k, $, g), g;\n  }, r = et &amp;&amp; et.__importStar || function(C) {\n    if (C &amp;&amp; C.__esModule) return C;\n    var k = {};\n    if (C != null) for (var $ in C) $ !== \"default\" &amp;&amp; Object.hasOwnProperty.call(C, $) &amp;&amp; s(k, C, $);\n    return e(k, C), k;\n  }, n = et &amp;&amp; et.__importDefault || function(C) {\n    return C &amp;&amp; C.__esModule ? C : { default: C };\n  };\n  Object.defineProperty(et, \"__esModule\", { value: !0 }), et.deserializeUnchecked = et.deserialize = et.serialize = et.BinaryReader = et.BinaryWriter = et.BorshError = et.baseDecode = et.baseEncode = void 0;\n  const i = n(v0()), o = n(Uy()), a = r(Hy), l = typeof TextDecoder != \"function\" ? a.TextDecoder : TextDecoder, c = new l(\"utf-8\", { fatal: !0 });\n  function u(C) {\n    return typeof C == \"string\" &amp;&amp; (C = Buffer.from(C, \"utf8\")), o.default.encode(Buffer.from(C));\n  }\n  et.baseEncode = u;\n  function d(C) {\n    return Buffer.from(o.default.decode(C));\n  }\n  et.baseDecode = d;\n  const h = 1024;\n  class f extends Error {\n    constructor(k) {\n      super(k), this.fieldPath = [], this.originalMessage = k;\n    }\n    addToFieldPath(k) {\n      this.fieldPath.splice(0, 0, k), this.message = this.originalMessage + \": \" + this.fieldPath.join(\".\");\n    }\n  }\n  et.BorshError = f;\n  class p {\n    constructor() {\n      this.buf = Buffer.alloc(h), this.length = 0;\n    }\n    maybeResize() {\n      this.buf.length &lt; 16 + this.length &amp;&amp; (this.buf = Buffer.concat([this.buf, Buffer.alloc(h)]));\n    }\n    writeU8(k) {\n      this.maybeResize(), this.buf.writeUInt8(k, this.length), this.length += 1;\n    }\n    writeU16(k) {\n      this.maybeResize(), this.buf.writeUInt16LE(k, this.length), this.length += 2;\n    }\n    writeU32(k) {\n      this.maybeResize(), this.buf.writeUInt32LE(k, this.length), this.length += 4;\n    }\n    writeU64(k) {\n      this.maybeResize(), this.writeBuffer(Buffer.from(new i.default(k).toArray(\"le\", 8)));\n    }\n    writeU128(k) {\n      this.maybeResize(), this.writeBuffer(Buffer.from(new i.default(k).toArray(\"le\", 16)));\n    }\n    writeU256(k) {\n      this.maybeResize(), this.writeBuffer(Buffer.from(new i.default(k).toArray(\"le\", 32)));\n    }\n    writeU512(k) {\n      this.maybeResize(), this.writeBuffer(Buffer.from(new i.default(k).toArray(\"le\", 64)));\n    }\n    writeBuffer(k) {\n      this.buf = Buffer.concat([\n        Buffer.from(this.buf.subarray(0, this.length)),\n        k,\n        Buffer.alloc(h)\n      ]), this.length += k.length;\n    }\n    writeString(k) {\n      this.maybeResize();\n      const $ = Buffer.from(k, \"utf8\");\n      this.writeU32($.length), this.writeBuffer($);\n    }\n    writeFixedArray(k) {\n      this.writeBuffer(Buffer.from(k));\n    }\n    writeArray(k, $) {\n      this.maybeResize(), this.writeU32(k.length);\n      for (const W of k)\n        this.maybeResize(), $(W);\n    }\n    toArray() {\n      return this.buf.subarray(0, this.length);\n    }\n  }\n  et.BinaryWriter = p;\n  function y(C, k, $) {\n    const W = $.value;\n    $.value = function(..._) {\n      try {\n        return W.apply(this, _);\n      } catch (g) {\n        if (g instanceof RangeError) {\n          const x = g.code;\n          if ([\"ERR_BUFFER_OUT_OF_BOUNDS\", \"ERR_OUT_OF_RANGE\"].indexOf(x) &gt;= 0)\n            throw new f(\"Reached the end of buffer when deserializing\");\n        }\n        throw g;\n      }\n    };\n  }\n  class E {\n    constructor(k) {\n      this.buf = k, this.offset = 0;\n    }\n    readU8() {\n      const k = this.buf.readUInt8(this.offset);\n      return this.offset += 1, k;\n    }\n    readU16() {\n      const k = this.buf.readUInt16LE(this.offset);\n      return this.offset += 2, k;\n    }\n    readU32() {\n      const k = this.buf.readUInt32LE(this.offset);\n      return this.offset += 4, k;\n    }\n    readU64() {\n      const k = this.readBuffer(8);\n      return new i.default(k, \"le\");\n    }\n    readU128() {\n      const k = this.readBuffer(16);\n      return new i.default(k, \"le\");\n    }\n    readU256() {\n      const k = this.readBuffer(32);\n      return new i.default(k, \"le\");\n    }\n    readU512() {\n      const k = this.readBuffer(64);\n      return new i.default(k, \"le\");\n    }\n    readBuffer(k) {\n      if (this.offset + k &gt; this.buf.length)\n        throw new f(`Expected buffer length ${k} isn't within bounds`);\n      const $ = this.buf.slice(this.offset, this.offset + k);\n      return this.offset += k, $;\n    }\n    readString() {\n      const k = this.readU32(), $ = this.readBuffer(k);\n      try {\n        return c.decode($);\n      } catch (W) {\n        throw new f(`Error decoding UTF-8 string: ${W}`);\n      }\n    }\n    readFixedArray(k) {\n      return new Uint8Array(this.readBuffer(k));\n    }\n    readArray(k) {\n      const $ = this.readU32(), W = Array();\n      for (let _ = 0; _ &lt; $; ++_)\n        W.push(k());\n      return W;\n    }\n  }\n  t([\n    y\n  ], E.prototype, \"readU8\", null), t([\n    y\n  ], E.prototype, \"readU16\", null), t([\n    y\n  ], E.prototype, \"readU32\", null), t([\n    y\n  ], E.prototype, \"readU64\", null), t([\n    y\n  ], E.prototype, \"readU128\", null), t([\n    y\n  ], E.prototype, \"readU256\", null), t([\n    y\n  ], E.prototype, \"readU512\", null), t([\n    y\n  ], E.prototype, \"readString\", null), t([\n    y\n  ], E.prototype, \"readFixedArray\", null), t([\n    y\n  ], E.prototype, \"readArray\", null), et.BinaryReader = E;\n  function b(C) {\n    return C.charAt(0).toUpperCase() + C.slice(1);\n  }\n  function R(C, k, $, W, _) {\n    try {\n      if (typeof W == \"string\")\n        _[`write${b(W)}`]($);\n      else if (W instanceof Array)\n        if (typeof W[0] == \"number\") {\n          if ($.length !== W[0])\n            throw new f(`Expecting byte array of length ${W[0]}, but got ${$.length} bytes`);\n          _.writeFixedArray($);\n        } else if (W.length === 2 &amp;&amp; typeof W[1] == \"number\") {\n          if ($.length !== W[1])\n            throw new f(`Expecting byte array of length ${W[1]}, but got ${$.length} bytes`);\n          for (let g = 0; g &lt; W[1]; g++)\n            R(C, null, $[g], W[0], _);\n        } else\n          _.writeArray($, (g) =&gt; {\n            R(C, k, g, W[0], _);\n          });\n      else if (W.kind !== void 0)\n        switch (W.kind) {\n          case \"option\": {\n            $ == null ? _.writeU8(0) : (_.writeU8(1), R(C, k, $, W.type, _));\n            break;\n          }\n          case \"map\": {\n            _.writeU32($.size), $.forEach((g, x) =&gt; {\n              R(C, k, x, W.key, _), R(C, k, g, W.value, _);\n            });\n            break;\n          }\n          default:\n            throw new f(`FieldType ${W} unrecognized`);\n        }\n      else\n        A(C, $, _);\n    } catch (g) {\n      throw g instanceof f &amp;&amp; g.addToFieldPath(k), g;\n    }\n  }\n  function A(C, k, $) {\n    if (typeof k.borshSerialize == \"function\") {\n      k.borshSerialize($);\n      return;\n    }\n    const W = C.get(k.constructor);\n    if (!W)\n      throw new f(`Class ${k.constructor.name} is missing in schema`);\n    if (W.kind === \"struct\")\n      W.fields.map(([_, g]) =&gt; {\n        R(C, _, k[_], g, $);\n      });\n    else if (W.kind === \"enum\") {\n      const _ = k[W.field];\n      for (let g = 0; g &lt; W.values.length; ++g) {\n        const [x, w] = W.values[g];\n        if (x === _) {\n          $.writeU8(g), R(C, x, k[x], w, $);\n          break;\n        }\n      }\n    } else\n      throw new f(`Unexpected schema kind: ${W.kind} for ${k.constructor.name}`);\n  }\n  function F(C, k, $ = p) {\n    const W = new $();\n    return A(C, k, W), W.toArray();\n  }\n  et.serialize = F;\n  function M(C, k, $, W) {\n    try {\n      if (typeof $ == \"string\")\n        return W[`read${b($)}`]();\n      if ($ instanceof Array) {\n        if (typeof $[0] == \"number\")\n          return W.readFixedArray($[0]);\n        if (typeof $[1] == \"number\") {\n          const _ = [];\n          for (let g = 0; g &lt; $[1]; g++)\n            _.push(M(C, null, $[0], W));\n          return _;\n        } else\n          return W.readArray(() =&gt; M(C, k, $[0], W));\n      }\n      if ($.kind === \"option\")\n        return W.readU8() ? M(C, k, $.type, W) : void 0;\n      if ($.kind === \"map\") {\n        let _ = /* @__PURE__ */ new Map();\n        const g = W.readU32();\n        for (let x = 0; x &lt; g; x++) {\n          const w = M(C, k, $.key, W), D = M(C, k, $.value, W);\n          _.set(w, D);\n        }\n        return _;\n      }\n      return H(C, $, W);\n    } catch (_) {\n      throw _ instanceof f &amp;&amp; _.addToFieldPath(k), _;\n    }\n  }\n  function H(C, k, $) {\n    if (typeof k.borshDeserialize == \"function\")\n      return k.borshDeserialize($);\n    const W = C.get(k);\n    if (!W)\n      throw new f(`Class ${k.name} is missing in schema`);\n    if (W.kind === \"struct\") {\n      const _ = {};\n      for (const [g, x] of C.get(k).fields)\n        _[g] = M(C, g, x, $);\n      return new k(_);\n    }\n    if (W.kind === \"enum\") {\n      const _ = $.readU8();\n      if (_ &gt;= W.values.length)\n        throw new f(`Enum index: ${_} is out of range`);\n      const [g, x] = W.values[_], w = M(C, g, x, $);\n      return new k({ [g]: w });\n    }\n    throw new f(`Unexpected schema kind: ${W.kind} for ${k.constructor.name}`);\n  }\n  function K(C, k, $, W = E) {\n    const _ = new W($), g = H(C, k, _);\n    if (_.offset &lt; $.length)\n      throw new f(`Unexpected ${$.length - _.offset} bytes after deserialized data`);\n    return g;\n  }\n  et.deserialize = K;\n  function j(C, k, $, W = E) {\n    const _ = new W($);\n    return H(C, k, _);\n  }\n  return et.deserializeUnchecked = j, et;\n}\nvar Ja = qy(), re = {}, Ld;\nfunction Wy() {\n  if (Ld) return re;\n  Ld = 1, Object.defineProperty(re, \"__esModule\", { value: !0 }), re.s16 = re.s8 = re.nu64be = re.u48be = re.u40be = re.u32be = re.u24be = re.u16be = re.nu64 = re.u48 = re.u40 = re.u32 = re.u24 = re.u16 = re.u8 = re.offset = re.greedy = re.Constant = re.UTF8 = re.CString = re.Blob = re.Boolean = re.BitField = re.BitStructure = re.VariantLayout = re.Union = re.UnionLayoutDiscriminator = re.UnionDiscriminator = re.Structure = re.Sequence = re.DoubleBE = re.Double = re.FloatBE = re.Float = re.NearInt64BE = re.NearInt64 = re.NearUInt64BE = re.NearUInt64 = re.IntBE = re.Int = re.UIntBE = re.UInt = re.OffsetLayout = re.GreedyCount = re.ExternalLayout = re.bindConstructorLayout = re.nameWithProperty = re.Layout = re.uint8ArrayToBuffer = re.checkUint8Array = void 0, re.constant = re.utf8 = re.cstr = re.blob = re.unionLayoutDiscriminator = re.union = re.seq = re.bits = re.struct = re.f64be = re.f64 = re.f32be = re.f32 = re.ns64be = re.s48be = re.s40be = re.s32be = re.s24be = re.s16be = re.ns64 = re.s48 = re.s40 = re.s32 = re.s24 = void 0;\n  const s = Kc();\n  function e(m) {\n    if (!(m instanceof Uint8Array))\n      throw new TypeError(\"b must be a Uint8Array\");\n  }\n  re.checkUint8Array = e;\n  function t(m) {\n    return e(m), s.Buffer.from(m.buffer, m.byteOffset, m.length);\n  }\n  re.uint8ArrayToBuffer = t;\n  let r = class {\n    constructor(v, P) {\n      if (!Number.isInteger(v))\n        throw new TypeError(\"span must be an integer\");\n      this.span = v, this.property = P;\n    }\n    /** Function to create an Object into which decoded properties will\n     * be written.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances, which means:\n     * * {@link Structure}\n     * * {@link Union}\n     * * {@link VariantLayout}\n     * * {@link BitStructure}\n     *\n     * If left undefined the JavaScript representation of these layouts\n     * will be Object instances.\n     *\n     * See {@link bindConstructorLayout}.\n     */\n    makeDestinationObject() {\n      return {};\n    }\n    /**\n     * Calculate the span of a specific instance of a layout.\n     *\n     * @param {Uint8Array} b - the buffer that contains an encoded instance.\n     *\n     * @param {Number} [offset] - the offset at which the encoded instance\n     * starts.  If absent a zero offset is inferred.\n     *\n     * @return {Number} - the number of bytes covered by the layout\n     * instance.  If this method is not overridden in a subclass the\n     * definition-time constant {@link Layout#span|span} will be\n     * returned.\n     *\n     * @throws {RangeError} - if the length of the value cannot be\n     * determined.\n     */\n    getSpan(v, P) {\n      if (0 &gt; this.span)\n        throw new RangeError(\"indeterminate span\");\n      return this.span;\n    }\n    /**\n     * Replicate the layout using a new property.\n     *\n     * This function must be used to get a structurally-equivalent layout\n     * with a different name since all {@link Layout} instances are\n     * immutable.\n     *\n     * **NOTE** This is a shallow copy.  All fields except {@link\n     * Layout#property|property} are strictly equal to the origin layout.\n     *\n     * @param {String} property - the value for {@link\n     * Layout#property|property} in the replica.\n     *\n     * @returns {Layout} - the copy with {@link Layout#property|property}\n     * set to `property`.\n     */\n    replicate(v) {\n      const P = Object.create(this.constructor.prototype);\n      return Object.assign(P, this), P.property = v, P;\n    }\n    /**\n     * Create an object from layout properties and an array of values.\n     *\n     * **NOTE** This function returns `undefined` if invoked on a layout\n     * that does not return its value as an Object.  Objects are\n     * returned for things that are a {@link Structure}, which includes\n     * {@link VariantLayout|variant layouts} if they are structures, and\n     * excludes {@link Union}s.  If you want this feature for a union\n     * you must use {@link Union.getVariant|getVariant} to select the\n     * desired layout.\n     *\n     * @param {Array} values - an array of values that correspond to the\n     * default order for properties.  As with {@link Layout#decode|decode}\n     * layout elements that have no property name are skipped when\n     * iterating over the array values.  Only the top-level properties are\n     * assigned; arguments are not assigned to properties of contained\n     * layouts.  Any unused values are ignored.\n     *\n     * @return {(Object|undefined)}\n     */\n    fromArray(v) {\n    }\n  };\n  re.Layout = r;\n  function n(m, v) {\n    return v.property ? m + \"[\" + v.property + \"]\" : m;\n  }\n  re.nameWithProperty = n;\n  function i(m, v) {\n    if (typeof m != \"function\")\n      throw new TypeError(\"Class must be constructor\");\n    if (Object.prototype.hasOwnProperty.call(m, \"layout_\"))\n      throw new Error(\"Class is already bound to a layout\");\n    if (!(v &amp;&amp; v instanceof r))\n      throw new TypeError(\"layout must be a Layout\");\n    if (Object.prototype.hasOwnProperty.call(v, \"boundConstructor_\"))\n      throw new Error(\"layout is already bound to a constructor\");\n    m.layout_ = v, v.boundConstructor_ = m, v.makeDestinationObject = (() =&gt; new m()), Object.defineProperty(m.prototype, \"encode\", {\n      value(P, N) {\n        return v.encode(this, P, N);\n      },\n      writable: !0\n    }), Object.defineProperty(m, \"decode\", {\n      value(P, N) {\n        return v.decode(P, N);\n      },\n      writable: !0\n    });\n  }\n  re.bindConstructorLayout = i;\n  class o extends r {\n    /**\n     * Return `true` iff the external layout decodes to an unsigned\n     * integer layout.\n     *\n     * In that case it can be used as the source of {@link\n     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n     * or as {@link UnionLayoutDiscriminator#layout|external union\n     * discriminators}.\n     *\n     * @abstract\n     */\n    isCount() {\n      throw new Error(\"ExternalLayout is abstract\");\n    }\n  }\n  re.ExternalLayout = o;\n  class a extends o {\n    constructor(v = 1, P) {\n      if (!Number.isInteger(v) || 0 &gt;= v)\n        throw new TypeError(\"elementSpan must be a (positive) integer\");\n      super(-1, P), this.elementSpan = v;\n    }\n    /** @override */\n    isCount() {\n      return !0;\n    }\n    /** @override */\n    decode(v, P = 0) {\n      e(v);\n      const N = v.length - P;\n      return Math.floor(N / this.elementSpan);\n    }\n    /** @override */\n    encode(v, P, N) {\n      return 0;\n    }\n  }\n  re.GreedyCount = a;\n  class l extends o {\n    constructor(v, P = 0, N) {\n      if (!(v instanceof r))\n        throw new TypeError(\"layout must be a Layout\");\n      if (!Number.isInteger(P))\n        throw new TypeError(\"offset must be integer or undefined\");\n      super(v.span, N || v.property), this.layout = v, this.offset = P;\n    }\n    /** @override */\n    isCount() {\n      return this.layout instanceof c || this.layout instanceof u;\n    }\n    /** @override */\n    decode(v, P = 0) {\n      return this.layout.decode(v, P + this.offset);\n    }\n    /** @override */\n    encode(v, P, N = 0) {\n      return this.layout.encode(v, P, N + this.offset);\n    }\n  }\n  re.OffsetLayout = l;\n  class c extends r {\n    constructor(v, P) {\n      if (super(v, P), 6 &lt; this.span)\n        throw new RangeError(\"span must not exceed 6 bytes\");\n    }\n    /** @override */\n    decode(v, P = 0) {\n      return t(v).readUIntLE(P, this.span);\n    }\n    /** @override */\n    encode(v, P, N = 0) {\n      return t(P).writeUIntLE(v, N, this.span), this.span;\n    }\n  }\n  re.UInt = c;\n  class u extends r {\n    constructor(v, P) {\n      if (super(v, P), 6 &lt; this.span)\n        throw new RangeError(\"span must not exceed 6 bytes\");\n    }\n    /** @override */\n    decode(v, P = 0) {\n      return t(v).readUIntBE(P, this.span);\n    }\n    /** @override */\n    encode(v, P, N = 0) {\n      return t(P).writeUIntBE(v, N, this.span), this.span;\n    }\n  }\n  re.UIntBE = u;\n  class d extends r {\n    constructor(v, P) {\n      if (super(v, P), 6 &lt; this.span)\n        throw new RangeError(\"span must not exceed 6 bytes\");\n    }\n    /** @override */\n    decode(v, P = 0) {\n      return t(v).readIntLE(P, this.span);\n    }\n    /** @override */\n    encode(v, P, N = 0) {\n      return t(P).writeIntLE(v, N, this.span), this.span;\n    }\n  }\n  re.Int = d;\n  class h extends r {\n    constructor(v, P) {\n      if (super(v, P), 6 &lt; this.span)\n        throw new RangeError(\"span must not exceed 6 bytes\");\n    }\n    /** @override */\n    decode(v, P = 0) {\n      return t(v).readIntBE(P, this.span);\n    }\n    /** @override */\n    encode(v, P, N = 0) {\n      return t(P).writeIntBE(v, N, this.span), this.span;\n    }\n  }\n  re.IntBE = h;\n  const f = Math.pow(2, 32);\n  function p(m) {\n    const v = Math.floor(m / f), P = m - v * f;\n    return { hi32: v, lo32: P };\n  }\n  function y(m, v) {\n    return m * f + v;\n  }\n  class E extends r {\n    constructor(v) {\n      super(8, v);\n    }\n    /** @override */\n    decode(v, P = 0) {\n      const N = t(v), Y = N.readUInt32LE(P), ee = N.readUInt32LE(P + 4);\n      return y(ee, Y);\n    }\n    /** @override */\n    encode(v, P, N = 0) {\n      const Y = p(v), ee = t(P);\n      return ee.writeUInt32LE(Y.lo32, N), ee.writeUInt32LE(Y.hi32, N + 4), 8;\n    }\n  }\n  re.NearUInt64 = E;\n  class b extends r {\n    constructor(v) {\n      super(8, v);\n    }\n    /** @override */\n    decode(v, P = 0) {\n      const N = t(v), Y = N.readUInt32BE(P), ee = N.readUInt32BE(P + 4);\n      return y(Y, ee);\n    }\n    /** @override */\n    encode(v, P, N = 0) {\n      const Y = p(v), ee = t(P);\n      return ee.writeUInt32BE(Y.hi32, N), ee.writeUInt32BE(Y.lo32, N + 4), 8;\n    }\n  }\n  re.NearUInt64BE = b;\n  class R extends r {\n    constructor(v) {\n      super(8, v);\n    }\n    /** @override */\n    decode(v, P = 0) {\n      const N = t(v), Y = N.readUInt32LE(P), ee = N.readInt32LE(P + 4);\n      return y(ee, Y);\n    }\n    /** @override */\n    encode(v, P, N = 0) {\n      const Y = p(v), ee = t(P);\n      return ee.writeUInt32LE(Y.lo32, N), ee.writeInt32LE(Y.hi32, N + 4), 8;\n    }\n  }\n  re.NearInt64 = R;\n  class A extends r {\n    constructor(v) {\n      super(8, v);\n    }\n    /** @override */\n    decode(v, P = 0) {\n      const N = t(v), Y = N.readInt32BE(P), ee = N.readUInt32BE(P + 4);\n      return y(Y, ee);\n    }\n    /** @override */\n    encode(v, P, N = 0) {\n      const Y = p(v), ee = t(P);\n      return ee.writeInt32BE(Y.hi32, N), ee.writeUInt32BE(Y.lo32, N + 4), 8;\n    }\n  }\n  re.NearInt64BE = A;\n  class F extends r {\n    constructor(v) {\n      super(4, v);\n    }\n    /** @override */\n    decode(v, P = 0) {\n      return t(v).readFloatLE(P);\n    }\n    /** @override */\n    encode(v, P, N = 0) {\n      return t(P).writeFloatLE(v, N), 4;\n    }\n  }\n  re.Float = F;\n  class M extends r {\n    constructor(v) {\n      super(4, v);\n    }\n    /** @override */\n    decode(v, P = 0) {\n      return t(v).readFloatBE(P);\n    }\n    /** @override */\n    encode(v, P, N = 0) {\n      return t(P).writeFloatBE(v, N), 4;\n    }\n  }\n  re.FloatBE = M;\n  class H extends r {\n    constructor(v) {\n      super(8, v);\n    }\n    /** @override */\n    decode(v, P = 0) {\n      return t(v).readDoubleLE(P);\n    }\n    /** @override */\n    encode(v, P, N = 0) {\n      return t(P).writeDoubleLE(v, N), 8;\n    }\n  }\n  re.Double = H;\n  class K extends r {\n    constructor(v) {\n      super(8, v);\n    }\n    /** @override */\n    decode(v, P = 0) {\n      return t(v).readDoubleBE(P);\n    }\n    /** @override */\n    encode(v, P, N = 0) {\n      return t(P).writeDoubleBE(v, N), 8;\n    }\n  }\n  re.DoubleBE = K;\n  class j extends r {\n    constructor(v, P, N) {\n      if (!(v instanceof r))\n        throw new TypeError(\"elementLayout must be a Layout\");\n      if (!(P instanceof o &amp;&amp; P.isCount() || Number.isInteger(P) &amp;&amp; 0 &lt;= P))\n        throw new TypeError(\"count must be non-negative integer or an unsigned integer ExternalLayout\");\n      let Y = -1;\n      !(P instanceof o) &amp;&amp; 0 &lt; v.span &amp;&amp; (Y = P * v.span), super(Y, N), this.elementLayout = v, this.count = P;\n    }\n    /** @override */\n    getSpan(v, P = 0) {\n      if (0 &lt;= this.span)\n        return this.span;\n      let N = 0, Y = this.count;\n      if (Y instanceof o &amp;&amp; (Y = Y.decode(v, P)), 0 &lt; this.elementLayout.span)\n        N = Y * this.elementLayout.span;\n      else {\n        let ee = 0;\n        for (; ee &lt; Y; )\n          N += this.elementLayout.getSpan(v, P + N), ++ee;\n      }\n      return N;\n    }\n    /** @override */\n    decode(v, P = 0) {\n      const N = [];\n      let Y = 0, ee = this.count;\n      for (ee instanceof o &amp;&amp; (ee = ee.decode(v, P)); Y &lt; ee; )\n        N.push(this.elementLayout.decode(v, P)), P += this.elementLayout.getSpan(v, P), Y += 1;\n      return N;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n     *\n     * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n     * the unused space in the buffer is left unchanged.  If `src` is\n     * longer than {@link Sequence#count|count} the unneeded elements are\n     * ignored.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */\n    encode(v, P, N = 0) {\n      const Y = this.elementLayout, ee = v.reduce((ie, le) =&gt; ie + Y.encode(le, P, N + ie), 0);\n      return this.count instanceof o &amp;&amp; this.count.encode(v.length, P, N), ee;\n    }\n  }\n  re.Sequence = j;\n  class C extends r {\n    constructor(v, P, N) {\n      if (!(Array.isArray(v) &amp;&amp; v.reduce((ee, ie) =&gt; ee &amp;&amp; ie instanceof r, !0)))\n        throw new TypeError(\"fields must be array of Layout instances\");\n      typeof P == \"boolean\" &amp;&amp; N === void 0 &amp;&amp; (N = P, P = void 0);\n      for (const ee of v)\n        if (0 &gt; ee.span &amp;&amp; ee.property === void 0)\n          throw new Error(\"fields cannot contain unnamed variable-length layout\");\n      let Y = -1;\n      try {\n        Y = v.reduce((ee, ie) =&gt; ee + ie.getSpan(), 0);\n      } catch {\n      }\n      super(Y, P), this.fields = v, this.decodePrefixes = !!N;\n    }\n    /** @override */\n    getSpan(v, P = 0) {\n      if (0 &lt;= this.span)\n        return this.span;\n      let N = 0;\n      try {\n        N = this.fields.reduce((Y, ee) =&gt; {\n          const ie = ee.getSpan(v, P);\n          return P += ie, Y + ie;\n        }, 0);\n      } catch {\n        throw new RangeError(\"indeterminate span\");\n      }\n      return N;\n    }\n    /** @override */\n    decode(v, P = 0) {\n      e(v);\n      const N = this.makeDestinationObject();\n      for (const Y of this.fields)\n        if (Y.property !== void 0 &amp;&amp; (N[Y.property] = Y.decode(v, P)), P += Y.getSpan(v, P), this.decodePrefixes &amp;&amp; v.length === P)\n          break;\n      return N;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Structure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the buffer is\n     * left unmodified. */\n    encode(v, P, N = 0) {\n      const Y = N;\n      let ee = 0, ie = 0;\n      for (const le of this.fields) {\n        let Te = le.span;\n        if (ie = 0 &lt; Te ? Te : 0, le.property !== void 0) {\n          const De = v[le.property];\n          De !== void 0 &amp;&amp; (ie = le.encode(De, P, N), 0 &gt; Te &amp;&amp; (Te = le.getSpan(P, N)));\n        }\n        ee = N, N += Te;\n      }\n      return ee + ie - Y;\n    }\n    /** @override */\n    fromArray(v) {\n      const P = this.makeDestinationObject();\n      for (const N of this.fields)\n        N.property !== void 0 &amp;&amp; 0 &lt; v.length &amp;&amp; (P[N.property] = v.shift());\n      return P;\n    }\n    /**\n     * Get access to the layout of a given property.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Layout} - the layout associated with `property`, or\n     * undefined if there is no such property.\n     */\n    layoutFor(v) {\n      if (typeof v != \"string\")\n        throw new TypeError(\"property must be string\");\n      for (const P of this.fields)\n        if (P.property === v)\n          return P;\n    }\n    /**\n     * Get the offset of a structure member.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Number} - the offset in bytes to the start of `property`\n     * within the structure, or undefined if `property` is not a field\n     * within the structure.  If the property is a member but follows a\n     * variable-length structure member a negative number will be\n     * returned.\n     */\n    offsetOf(v) {\n      if (typeof v != \"string\")\n        throw new TypeError(\"property must be string\");\n      let P = 0;\n      for (const N of this.fields) {\n        if (N.property === v)\n          return P;\n        0 &gt; N.span ? P = -1 : 0 &lt;= P &amp;&amp; (P += N.span);\n      }\n    }\n  }\n  re.Structure = C;\n  class k {\n    constructor(v) {\n      this.property = v;\n    }\n    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n     *\n     * The implementation of this method need not reference the buffer if\n     * variant information is available through other means. */\n    decode(v, P) {\n      throw new Error(\"UnionDiscriminator is abstract\");\n    }\n    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n     *\n     * The implementation of this method need not store the value if\n     * variant information is maintained through other means. */\n    encode(v, P, N) {\n      throw new Error(\"UnionDiscriminator is abstract\");\n    }\n  }\n  re.UnionDiscriminator = k;\n  class $ extends k {\n    constructor(v, P) {\n      if (!(v instanceof o &amp;&amp; v.isCount()))\n        throw new TypeError(\"layout must be an unsigned integer ExternalLayout\");\n      super(P || v.property || \"variant\"), this.layout = v;\n    }\n    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n    decode(v, P) {\n      return this.layout.decode(v, P);\n    }\n    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n    encode(v, P, N) {\n      return this.layout.encode(v, P, N);\n    }\n  }\n  re.UnionLayoutDiscriminator = $;\n  class W extends r {\n    constructor(v, P, N) {\n      let Y;\n      if (v instanceof c || v instanceof u)\n        Y = new $(new l(v));\n      else if (v instanceof o &amp;&amp; v.isCount())\n        Y = new $(v);\n      else if (v instanceof k)\n        Y = v;\n      else\n        throw new TypeError(\"discr must be a UnionDiscriminator or an unsigned integer layout\");\n      if (P === void 0 &amp;&amp; (P = null), !(P === null || P instanceof r))\n        throw new TypeError(\"defaultLayout must be null or a Layout\");\n      if (P !== null) {\n        if (0 &gt; P.span)\n          throw new Error(\"defaultLayout must have constant span\");\n        P.property === void 0 &amp;&amp; (P = P.replicate(\"content\"));\n      }\n      let ee = -1;\n      P &amp;&amp; (ee = P.span, 0 &lt;= ee &amp;&amp; (v instanceof c || v instanceof u) &amp;&amp; (ee += Y.layout.span)), super(ee, N), this.discriminator = Y, this.usesPrefixDiscriminator = v instanceof c || v instanceof u, this.defaultLayout = P, this.registry = {};\n      let ie = this.defaultGetSourceVariant.bind(this);\n      this.getSourceVariant = function(le) {\n        return ie(le);\n      }, this.configGetSourceVariant = function(le) {\n        ie = le.bind(this);\n      };\n    }\n    /** @override */\n    getSpan(v, P = 0) {\n      if (0 &lt;= this.span)\n        return this.span;\n      const N = this.getVariant(v, P);\n      if (!N)\n        throw new Error(\"unable to determine span for unrecognized variant\");\n      return N.getSpan(v, P);\n    }\n    /**\n     * Method to infer a registered Union variant compatible with `src`.\n     *\n     * The first satisfied rule in the following sequence defines the\n     * return value:\n     * * If `src` has properties matching the Union discriminator and\n     *   the default layout, `undefined` is returned regardless of the\n     *   value of the discriminator property (this ensures the default\n     *   layout will be used);\n     * * If `src` has a property matching the Union discriminator, the\n     *   value of the discriminator identifies a registered variant, and\n     *   either (a) the variant has no layout, or (b) `src` has the\n     *   variant's property, then the variant is returned (because the\n     *   source satisfies the constraints of the variant it identifies);\n     * * If `src` does not have a property matching the Union\n     *   discriminator, but does have a property matching a registered\n     *   variant, then the variant is returned (because the source\n     *   matches a variant without an explicit conflict);\n     * * An error is thrown (because we either can't identify a variant,\n     *   or we were explicitly told the variant but can't satisfy it).\n     *\n     * @param {Object} src - an object presumed to be compatible with\n     * the content of the Union.\n     *\n     * @return {(undefined|VariantLayout)} - as described above.\n     *\n     * @throws {Error} - if `src` cannot be associated with a default or\n     * registered variant.\n     */\n    defaultGetSourceVariant(v) {\n      if (Object.prototype.hasOwnProperty.call(v, this.discriminator.property)) {\n        if (this.defaultLayout &amp;&amp; this.defaultLayout.property &amp;&amp; Object.prototype.hasOwnProperty.call(v, this.defaultLayout.property))\n          return;\n        const P = this.registry[v[this.discriminator.property]];\n        if (P &amp;&amp; (!P.layout || P.property &amp;&amp; Object.prototype.hasOwnProperty.call(v, P.property)))\n          return P;\n      } else\n        for (const P in this.registry) {\n          const N = this.registry[P];\n          if (N.property &amp;&amp; Object.prototype.hasOwnProperty.call(v, N.property))\n            return N;\n        }\n      throw new Error(\"unable to infer src variant\");\n    }\n    /** Implement {@link Layout#decode|decode} for {@link Union}.\n     *\n     * If the variant is {@link Union#addVariant|registered} the return\n     * value is an instance of that variant, with no explicit\n     * discriminator.  Otherwise the {@link Union#defaultLayout|default\n     * layout} is used to decode the content. */\n    decode(v, P = 0) {\n      let N;\n      const Y = this.discriminator, ee = Y.decode(v, P), ie = this.registry[ee];\n      if (ie === void 0) {\n        const le = this.defaultLayout;\n        let Te = 0;\n        this.usesPrefixDiscriminator &amp;&amp; (Te = Y.layout.span), N = this.makeDestinationObject(), N[Y.property] = ee, N[le.property] = le.decode(v, P + Te);\n      } else\n        N = ie.decode(v, P);\n      return N;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Union}.\n     *\n     * This API assumes the `src` object is consistent with the union's\n     * {@link Union#defaultLayout|default layout}.  To encode variants\n     * use the appropriate variant-specific {@link VariantLayout#encode}\n     * method. */\n    encode(v, P, N = 0) {\n      const Y = this.getSourceVariant(v);\n      if (Y === void 0) {\n        const ee = this.discriminator, ie = this.defaultLayout;\n        let le = 0;\n        return this.usesPrefixDiscriminator &amp;&amp; (le = ee.layout.span), ee.encode(v[ee.property], P, N), le + ie.encode(v[ie.property], P, N + le);\n      }\n      return Y.encode(v, P, N);\n    }\n    /** Register a new variant structure within a union.  The newly\n     * created variant is returned.\n     *\n     * @param {Number} variant - initializer for {@link\n     * VariantLayout#variant|variant}.\n     *\n     * @param {Layout} layout - initializer for {@link\n     * VariantLayout#layout|layout}.\n     *\n     * @param {String} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {VariantLayout} */\n    addVariant(v, P, N) {\n      const Y = new _(this, v, P, N);\n      return this.registry[v] = Y, Y;\n    }\n    /**\n     * Get the layout associated with a registered variant.\n     *\n     * If `vb` does not produce a registered variant the function returns\n     * `undefined`.\n     *\n     * @param {(Number|Uint8Array)} vb - either the variant number, or a\n     * buffer from which the discriminator is to be read.\n     *\n     * @param {Number} offset - offset into `vb` for the start of the\n     * union.  Used only when `vb` is an instance of {Uint8Array}.\n     *\n     * @return {({VariantLayout}|undefined)}\n     */\n    getVariant(v, P = 0) {\n      let N;\n      return v instanceof Uint8Array ? N = this.discriminator.decode(v, P) : N = v, this.registry[N];\n    }\n  }\n  re.Union = W;\n  class _ extends r {\n    constructor(v, P, N, Y) {\n      if (!(v instanceof W))\n        throw new TypeError(\"union must be a Union\");\n      if (!Number.isInteger(P) || 0 &gt; P)\n        throw new TypeError(\"variant must be a (non-negative) integer\");\n      if (typeof N == \"string\" &amp;&amp; Y === void 0 &amp;&amp; (Y = N, N = null), N) {\n        if (!(N instanceof r))\n          throw new TypeError(\"layout must be a Layout\");\n        if (v.defaultLayout !== null &amp;&amp; 0 &lt;= N.span &amp;&amp; N.span &gt; v.defaultLayout.span)\n          throw new Error(\"variant span exceeds span of containing union\");\n        if (typeof Y != \"string\")\n          throw new TypeError(\"variant must have a String property\");\n      }\n      let ee = v.span;\n      0 &gt; v.span &amp;&amp; (ee = N ? N.span : 0, 0 &lt;= ee &amp;&amp; v.usesPrefixDiscriminator &amp;&amp; (ee += v.discriminator.layout.span)), super(ee, Y), this.union = v, this.variant = P, this.layout = N || null;\n    }\n    /** @override */\n    getSpan(v, P = 0) {\n      if (0 &lt;= this.span)\n        return this.span;\n      let N = 0;\n      this.union.usesPrefixDiscriminator &amp;&amp; (N = this.union.discriminator.layout.span);\n      let Y = 0;\n      return this.layout &amp;&amp; (Y = this.layout.getSpan(v, P + N)), N + Y;\n    }\n    /** @override */\n    decode(v, P = 0) {\n      const N = this.makeDestinationObject();\n      if (this !== this.union.getVariant(v, P))\n        throw new Error(\"variant mismatch\");\n      let Y = 0;\n      return this.union.usesPrefixDiscriminator &amp;&amp; (Y = this.union.discriminator.layout.span), this.layout ? N[this.property] = this.layout.decode(v, P + Y) : this.property ? N[this.property] = !0 : this.union.usesPrefixDiscriminator &amp;&amp; (N[this.union.discriminator.property] = this.variant), N;\n    }\n    /** @override */\n    encode(v, P, N = 0) {\n      let Y = 0;\n      if (this.union.usesPrefixDiscriminator &amp;&amp; (Y = this.union.discriminator.layout.span), this.layout &amp;&amp; !Object.prototype.hasOwnProperty.call(v, this.property))\n        throw new TypeError(\"variant lacks property \" + this.property);\n      this.union.discriminator.encode(this.variant, P, N);\n      let ee = Y;\n      if (this.layout &amp;&amp; (this.layout.encode(v[this.property], P, N + Y), ee += this.layout.getSpan(P, N + Y), 0 &lt;= this.union.span &amp;&amp; ee &gt; this.union.span))\n        throw new Error(\"encoded variant overruns containing union\");\n      return ee;\n    }\n    /** Delegate {@link Layout#fromArray|fromArray} to {@link\n     * VariantLayout#layout|layout}. */\n    fromArray(v) {\n      if (this.layout)\n        return this.layout.fromArray(v);\n    }\n  }\n  re.VariantLayout = _;\n  function g(m) {\n    return 0 &gt; m &amp;&amp; (m += 4294967296), m;\n  }\n  class x extends r {\n    constructor(v, P, N) {\n      if (!(v instanceof c || v instanceof u))\n        throw new TypeError(\"word must be a UInt or UIntBE layout\");\n      if (typeof P == \"string\" &amp;&amp; N === void 0 &amp;&amp; (N = P, P = !1), 4 &lt; v.span)\n        throw new RangeError(\"word cannot exceed 32 bits\");\n      super(v.span, N), this.word = v, this.msb = !!P, this.fields = [];\n      let Y = 0;\n      this._packedSetValue = function(ee) {\n        return Y = g(ee), this;\n      }, this._packedGetValue = function() {\n        return Y;\n      };\n    }\n    /** @override */\n    decode(v, P = 0) {\n      const N = this.makeDestinationObject(), Y = this.word.decode(v, P);\n      this._packedSetValue(Y);\n      for (const ee of this.fields)\n        ee.property !== void 0 &amp;&amp; (N[ee.property] = ee.decode(v));\n      return N;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the packed\n     * value is left unmodified.  Unused bits are also left unmodified. */\n    encode(v, P, N = 0) {\n      const Y = this.word.decode(P, N);\n      this._packedSetValue(Y);\n      for (const ee of this.fields)\n        if (ee.property !== void 0) {\n          const ie = v[ee.property];\n          ie !== void 0 &amp;&amp; ee.encode(ie);\n        }\n      return this.word.encode(this._packedGetValue(), P, N);\n    }\n    /** Register a new bitfield with a containing bit structure.  The\n     * resulting bitfield is returned.\n     *\n     * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {BitField} */\n    addField(v, P) {\n      const N = new w(this, v, P);\n      return this.fields.push(N), N;\n    }\n    /** As with {@link BitStructure#addField|addField} for single-bit\n     * fields with `boolean` value representation.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {Boolean} */\n    // `Boolean` conflicts with the native primitive type\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    addBoolean(v) {\n      const P = new D(this, v);\n      return this.fields.push(P), P;\n    }\n    /**\n     * Get access to the bit field for a given property.\n     *\n     * @param {String} property - the bit field of interest.\n     *\n     * @return {BitField} - the field associated with `property`, or\n     * undefined if there is no such property.\n     */\n    fieldFor(v) {\n      if (typeof v != \"string\")\n        throw new TypeError(\"property must be string\");\n      for (const P of this.fields)\n        if (P.property === v)\n          return P;\n    }\n  }\n  re.BitStructure = x;\n  class w {\n    constructor(v, P, N) {\n      if (!(v instanceof x))\n        throw new TypeError(\"container must be a BitStructure\");\n      if (!Number.isInteger(P) || 0 &gt;= P)\n        throw new TypeError(\"bits must be positive integer\");\n      const Y = 8 * v.span, ee = v.fields.reduce((ie, le) =&gt; ie + le.bits, 0);\n      if (P + ee &gt; Y)\n        throw new Error(\"bits too long for span remainder (\" + (Y - ee) + \" of \" + Y + \" remain)\");\n      this.container = v, this.bits = P, this.valueMask = (1 &lt;&lt; P) - 1, P === 32 &amp;&amp; (this.valueMask = 4294967295), this.start = ee, this.container.msb &amp;&amp; (this.start = Y - ee - P), this.wordMask = g(this.valueMask &lt;&lt; this.start), this.property = N;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field. */\n    decode(v, P) {\n      const N = this.container._packedGetValue();\n      return g(N &amp; this.wordMask) &gt;&gt;&gt; this.start;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field.\n     *\n     * **NOTE** This is not a specialization of {@link\n     * Layout#encode|Layout.encode} and there is no return value. */\n    encode(v) {\n      if (typeof v != \"number\" || !Number.isInteger(v) || v !== g(v &amp; this.valueMask))\n        throw new TypeError(n(\"BitField.encode\", this) + \" value must be integer not exceeding \" + this.valueMask);\n      const P = this.container._packedGetValue(), N = g(v &lt;&lt; this.start);\n      this.container._packedSetValue(g(P &amp; ~this.wordMask) | N);\n    }\n  }\n  re.BitField = w;\n  class D extends w {\n    constructor(v, P) {\n      super(v, 1, P);\n    }\n    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n     *\n     * @returns {boolean} */\n    decode(v, P) {\n      return !!super.decode(v, P);\n    }\n    /** @override */\n    encode(v) {\n      typeof v == \"boolean\" &amp;&amp; (v = +v), super.encode(v);\n    }\n  }\n  re.Boolean = D;\n  class O extends r {\n    constructor(v, P) {\n      if (!(v instanceof o &amp;&amp; v.isCount() || Number.isInteger(v) &amp;&amp; 0 &lt;= v))\n        throw new TypeError(\"length must be positive integer or an unsigned integer ExternalLayout\");\n      let N = -1;\n      v instanceof o || (N = v), super(N, P), this.length = v;\n    }\n    /** @override */\n    getSpan(v, P) {\n      let N = this.span;\n      return 0 &gt; N &amp;&amp; (N = this.length.decode(v, P)), N;\n    }\n    /** @override */\n    decode(v, P = 0) {\n      let N = this.span;\n      return 0 &gt; N &amp;&amp; (N = this.length.decode(v, P)), t(v).slice(P, P + N);\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Blob}.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */\n    encode(v, P, N) {\n      let Y = this.length;\n      if (this.length instanceof o &amp;&amp; (Y = v.length), !(v instanceof Uint8Array &amp;&amp; Y === v.length))\n        throw new TypeError(n(\"Blob.encode\", this) + \" requires (length \" + Y + \") Uint8Array as src\");\n      if (N + Y &gt; P.length)\n        throw new RangeError(\"encoding overruns Uint8Array\");\n      const ee = t(v);\n      return t(P).write(ee.toString(\"hex\"), N, Y, \"hex\"), this.length instanceof o &amp;&amp; this.length.encode(Y, P, N), Y;\n    }\n  }\n  re.Blob = O;\n  class U extends r {\n    constructor(v) {\n      super(-1, v);\n    }\n    /** @override */\n    getSpan(v, P = 0) {\n      e(v);\n      let N = P;\n      for (; N &lt; v.length &amp;&amp; v[N] !== 0; )\n        N += 1;\n      return 1 + N - P;\n    }\n    /** @override */\n    decode(v, P = 0) {\n      const N = this.getSpan(v, P);\n      return t(v).slice(P, P + N - 1).toString(\"utf-8\");\n    }\n    /** @override */\n    encode(v, P, N = 0) {\n      typeof v != \"string\" &amp;&amp; (v = String(v));\n      const Y = s.Buffer.from(v, \"utf8\"), ee = Y.length;\n      if (N + ee &gt; P.length)\n        throw new RangeError(\"encoding overruns Buffer\");\n      const ie = t(P);\n      return Y.copy(ie, N), ie[N + ee] = 0, ee + 1;\n    }\n  }\n  re.CString = U;\n  class V extends r {\n    constructor(v, P) {\n      if (typeof v == \"string\" &amp;&amp; P === void 0 &amp;&amp; (P = v, v = void 0), v === void 0)\n        v = -1;\n      else if (!Number.isInteger(v))\n        throw new TypeError(\"maxSpan must be an integer\");\n      super(-1, P), this.maxSpan = v;\n    }\n    /** @override */\n    getSpan(v, P = 0) {\n      return e(v), v.length - P;\n    }\n    /** @override */\n    decode(v, P = 0) {\n      const N = this.getSpan(v, P);\n      if (0 &lt;= this.maxSpan &amp;&amp; this.maxSpan &lt; N)\n        throw new RangeError(\"text length exceeds maxSpan\");\n      return t(v).slice(P, P + N).toString(\"utf-8\");\n    }\n    /** @override */\n    encode(v, P, N = 0) {\n      typeof v != \"string\" &amp;&amp; (v = String(v));\n      const Y = s.Buffer.from(v, \"utf8\"), ee = Y.length;\n      if (0 &lt;= this.maxSpan &amp;&amp; this.maxSpan &lt; ee)\n        throw new RangeError(\"text length exceeds maxSpan\");\n      if (N + ee &gt; P.length)\n        throw new RangeError(\"encoding overruns Buffer\");\n      return Y.copy(t(P), N), ee;\n    }\n  }\n  re.UTF8 = V;\n  class L extends r {\n    constructor(v, P) {\n      super(0, P), this.value = v;\n    }\n    /** @override */\n    decode(v, P) {\n      return this.value;\n    }\n    /** @override */\n    encode(v, P, N) {\n      return 0;\n    }\n  }\n  return re.Constant = L, re.greedy = ((m, v) =&gt; new a(m, v)), re.offset = ((m, v, P) =&gt; new l(m, v, P)), re.u8 = ((m) =&gt; new c(1, m)), re.u16 = ((m) =&gt; new c(2, m)), re.u24 = ((m) =&gt; new c(3, m)), re.u32 = ((m) =&gt; new c(4, m)), re.u40 = ((m) =&gt; new c(5, m)), re.u48 = ((m) =&gt; new c(6, m)), re.nu64 = ((m) =&gt; new E(m)), re.u16be = ((m) =&gt; new u(2, m)), re.u24be = ((m) =&gt; new u(3, m)), re.u32be = ((m) =&gt; new u(4, m)), re.u40be = ((m) =&gt; new u(5, m)), re.u48be = ((m) =&gt; new u(6, m)), re.nu64be = ((m) =&gt; new b(m)), re.s8 = ((m) =&gt; new d(1, m)), re.s16 = ((m) =&gt; new d(2, m)), re.s24 = ((m) =&gt; new d(3, m)), re.s32 = ((m) =&gt; new d(4, m)), re.s40 = ((m) =&gt; new d(5, m)), re.s48 = ((m) =&gt; new d(6, m)), re.ns64 = ((m) =&gt; new R(m)), re.s16be = ((m) =&gt; new h(2, m)), re.s24be = ((m) =&gt; new h(3, m)), re.s32be = ((m) =&gt; new h(4, m)), re.s40be = ((m) =&gt; new h(5, m)), re.s48be = ((m) =&gt; new h(6, m)), re.ns64be = ((m) =&gt; new A(m)), re.f32 = ((m) =&gt; new F(m)), re.f32be = ((m) =&gt; new M(m)), re.f64 = ((m) =&gt; new H(m)), re.f64be = ((m) =&gt; new K(m)), re.struct = ((m, v, P) =&gt; new C(m, v, P)), re.bits = ((m, v, P) =&gt; new x(m, v, P)), re.seq = ((m, v, P) =&gt; new j(m, v, P)), re.union = ((m, v, P) =&gt; new W(m, v, P)), re.unionLayoutDiscriminator = ((m, v) =&gt; new $(m, v)), re.blob = ((m, v) =&gt; new O(m, v)), re.cstr = ((m) =&gt; new U(m)), re.utf8 = ((m, v) =&gt; new V(m, v)), re.constant = ((m, v) =&gt; new L(m, v)), re;\n}\nvar z = Wy(), zy = 8078e3, Yy = 8078001, Zy = 8078004, Xy = 8078005, Jy = 8078006, Qy = 8078011;\nfunction x0(s) {\n  return Array.isArray(s) ? \"%5B\" + s.map(x0).join(\n    \"%2C%20\"\n    /* \", \" */\n  ) + /* \"]\" */\n  \"%5D\" : typeof s == \"bigint\" ? `${s}n` : encodeURIComponent(\n    String(\n      s != null &amp;&amp; Object.getPrototypeOf(s) === null ? (\n        // Plain objects with no prototype don't have a `toString` method.\n        // Convert them before stringifying them.\n        { ...s }\n      ) : s\n    )\n  );\n}\nfunction ev([s, e]) {\n  return `${s}=${x0(e)}`;\n}\nfunction tv(s) {\n  const e = Object.entries(s).map(ev).join(\"&amp;\");\n  return btoa(e);\n}\nfunction rv(s, e = {}) {\n  {\n    let t = `Solana error #${s}; Decode this error by running \\`npx @solana/errors decode -- ${s}`;\n    return Object.keys(e).length &amp;&amp; (t += ` '${tv(e)}'`), `${t}\\``;\n  }\n}\nvar bn = class extends Error {\n  constructor(...[e, t]) {\n    let r, n;\n    if (t) {\n      const { cause: o, ...a } = t;\n      o &amp;&amp; (n = { cause: o }), Object.keys(a).length &gt; 0 &amp;&amp; (r = a);\n    }\n    const i = rv(e, r);\n    super(i, n);\n    /**\n     * Indicates the root cause of this {@link SolanaError}, if any.\n     *\n     * For example, a transaction error might have an instruction error as its root cause. In this\n     * case, you will be able to access the instruction error on the transaction error as `cause`.\n     */\n    Cr(this, \"cause\", this.cause);\n    /**\n     * Contains context that can assist in understanding or recovering from a {@link SolanaError}.\n     */\n    Cr(this, \"context\");\n    this.context = {\n      __code: e,\n      ...r\n    }, this.name = \"SolanaError\";\n  }\n};\nfunction sv(s, e) {\n  return \"fixedSize\" in e ? e.fixedSize : e.getSizeFromValue(s);\n}\nfunction nv(s) {\n  return Object.freeze({\n    ...s,\n    encode: (e) =&gt; {\n      const t = new Uint8Array(sv(e, s));\n      return s.write(e, t, 0), t;\n    }\n  });\n}\nfunction iv(s) {\n  return Object.freeze({\n    ...s,\n    decode: (e, t = 0) =&gt; s.read(e, t)[0]\n  });\n}\nfunction dn(s) {\n  return \"fixedSize\" in s &amp;&amp; typeof s.fixedSize == \"number\";\n}\nfunction ov(s, e) {\n  if (dn(s) !== dn(e))\n    throw new bn(Zy);\n  if (dn(s) &amp;&amp; dn(e) &amp;&amp; s.fixedSize !== e.fixedSize)\n    throw new bn(Xy, {\n      decoderFixedSize: e.fixedSize,\n      encoderFixedSize: s.fixedSize\n    });\n  if (!dn(s) &amp;&amp; !dn(e) &amp;&amp; s.maxSize !== e.maxSize)\n    throw new bn(Jy, {\n      decoderMaxSize: e.maxSize,\n      encoderMaxSize: s.maxSize\n    });\n  return {\n    ...e,\n    ...s,\n    decode: e.decode,\n    encode: s.encode,\n    read: e.read,\n    write: s.write\n  };\n}\nfunction av(s, e, t = 0) {\n  if (e.length - t &lt;= 0)\n    throw new bn(zy, {\n      codecDescription: s\n    });\n}\nfunction lv(s, e, t, r = 0) {\n  const n = t.length - r;\n  if (n &lt; e)\n    throw new bn(Yy, {\n      bytesLength: n,\n      codecDescription: s,\n      expected: e\n    });\n}\nfunction cv(s, e, t, r) {\n  if (r &lt; e || r &gt; t)\n    throw new bn(Qy, {\n      codecDescription: s,\n      max: t,\n      min: e,\n      value: r\n    });\n}\nfunction S0(s) {\n  return (s == null ? void 0 : s.endian) !== 1;\n}\nfunction uv(s) {\n  return nv({\n    fixedSize: s.size,\n    write(e, t, r) {\n      s.range &amp;&amp; cv(s.name, s.range[0], s.range[1], e);\n      const n = new ArrayBuffer(s.size);\n      return s.set(new DataView(n), e, S0(s.config)), t.set(new Uint8Array(n), r), r + s.size;\n    }\n  });\n}\nfunction dv(s) {\n  return iv({\n    fixedSize: s.size,\n    read(e, t = 0) {\n      av(s.name, e, t), lv(s.name, s.size, e, t);\n      const r = new DataView(hv(e, t, s.size));\n      return [s.get(r, S0(s.config)), t + s.size];\n    }\n  });\n}\nfunction hv(s, e, t) {\n  const r = s.byteOffset + (e ?? 0), n = t ?? s.byteLength;\n  return s.buffer.slice(r, r + n);\n}\nvar fv = (s = {}) =&gt; uv({\n  config: s,\n  name: \"u64\",\n  range: [0n, BigInt(\"0xffffffffffffffff\")],\n  set: (e, t, r) =&gt; e.setBigUint64(0, BigInt(t), r),\n  size: 8\n}), gv = (s = {}) =&gt; dv({\n  config: s,\n  get: (e, t) =&gt; e.getBigUint64(0, t),\n  name: \"u64\",\n  size: 8\n}), pv = (s = {}) =&gt; ov(fv(s), gv(s));\nclass mv extends TypeError {\n  constructor(e, t) {\n    let r;\n    const { message: n, explanation: i, ...o } = e, { path: a } = e, l = a.length === 0 ? n : `At path: ${a.join(\".\")} -- ${n}`;\n    super(i ?? l), i != null &amp;&amp; (this.cause = l), Object.assign(this, o), this.name = this.constructor.name, this.failures = () =&gt; r ?? (r = [e, ...t()]);\n  }\n}\nfunction yv(s) {\n  return Ci(s) &amp;&amp; typeof s[Symbol.iterator] == \"function\";\n}\nfunction Ci(s) {\n  return typeof s == \"object\" &amp;&amp; s != null;\n}\nfunction $o(s) {\n  return Ci(s) &amp;&amp; !Array.isArray(s);\n}\nfunction Br(s) {\n  return typeof s == \"symbol\" ? s.toString() : typeof s == \"string\" ? JSON.stringify(s) : `${s}`;\n}\nfunction vv(s) {\n  const { done: e, value: t } = s.next();\n  return e ? void 0 : t;\n}\nfunction Ev(s, e, t, r) {\n  if (s === !0)\n    return;\n  s === !1 ? s = {} : typeof s == \"string\" &amp;&amp; (s = { message: s });\n  const { path: n, branch: i } = e, { type: o } = t, { refinement: a, message: l = `Expected a value of type \\`${o}\\`${a ? ` with refinement \\`${a}\\`` : \"\"}, but received: \\`${Br(r)}\\`` } = s;\n  return {\n    value: r,\n    type: o,\n    refinement: a,\n    key: n[n.length - 1],\n    path: n,\n    branch: i,\n    ...s,\n    message: l\n  };\n}\nfunction* Cd(s, e, t, r) {\n  yv(s) || (s = [s]);\n  for (const n of s) {\n    const i = Ev(n, e, t, r);\n    i &amp;&amp; (yield i);\n  }\n}\nfunction* Jc(s, e, t = {}) {\n  const { path: r = [], branch: n = [s], coerce: i = !1, mask: o = !1 } = t, a = { path: r, branch: n, mask: o };\n  i &amp;&amp; (s = e.coercer(s, a));\n  let l = \"valid\";\n  for (const c of e.validator(s, a))\n    c.explanation = t.message, l = \"not_valid\", yield [c, void 0];\n  for (let [c, u, d] of e.entries(s, a)) {\n    const h = Jc(u, d, {\n      path: c === void 0 ? r : [...r, c],\n      branch: c === void 0 ? n : [...n, u],\n      coerce: i,\n      mask: o,\n      message: t.message\n    });\n    for (const f of h)\n      f[0] ? (l = f[0].refinement != null ? \"not_refined\" : \"not_valid\", yield [f[0], void 0]) : i &amp;&amp; (u = f[1], c === void 0 ? s = u : s instanceof Map ? s.set(c, u) : s instanceof Set ? s.add(u) : Ci(s) &amp;&amp; (u !== void 0 || c in s) &amp;&amp; (s[c] = u));\n  }\n  if (l !== \"not_valid\")\n    for (const c of e.refiner(s, a))\n      c.explanation = t.message, l = \"not_refined\", yield [c, void 0];\n  l === \"valid\" &amp;&amp; (yield [void 0, s]);\n}\nlet es = class {\n  constructor(e) {\n    const { type: t, schema: r, validator: n, refiner: i, coercer: o = (l) =&gt; l, entries: a = function* () {\n    } } = e;\n    this.type = t, this.schema = r, this.entries = a, this.coercer = o, n ? this.validator = (l, c) =&gt; {\n      const u = n(l, c);\n      return Cd(u, c, this, l);\n    } : this.validator = () =&gt; [], i ? this.refiner = (l, c) =&gt; {\n      const u = i(l, c);\n      return Cd(u, c, this, l);\n    } : this.refiner = () =&gt; [];\n  }\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n  assert(e, t) {\n    return xv(e, this, t);\n  }\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n  create(e, t) {\n    return ti(e, this, t);\n  }\n  /**\n   * Check if a value passes the struct's validation.\n   */\n  is(e) {\n    return b0(e, this);\n  }\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema. Masking applies recursively to\n   * props of `object` structs only.\n   */\n  mask(e, t) {\n    return Sv(e, this, t);\n  }\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `coerce` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful. Also, `mask` will turn on\n   * masking of the unknown `object` props recursively if passed.\n   */\n  validate(e, t = {}) {\n    return ki(e, this, t);\n  }\n};\nfunction xv(s, e, t) {\n  const r = ki(s, e, { message: t });\n  if (r[0])\n    throw r[0];\n}\nfunction ti(s, e, t) {\n  const r = ki(s, e, { coerce: !0, message: t });\n  if (r[0])\n    throw r[0];\n  return r[1];\n}\nfunction Sv(s, e, t) {\n  const r = ki(s, e, { coerce: !0, mask: !0, message: t });\n  if (r[0])\n    throw r[0];\n  return r[1];\n}\nfunction b0(s, e) {\n  return !ki(s, e)[0];\n}\nfunction ki(s, e, t = {}) {\n  const r = Jc(s, e, t), n = vv(r);\n  return n[0] ? [new mv(n[0], function* () {\n    for (const o of r)\n      o[0] &amp;&amp; (yield o[0]);\n  }), void 0] : [void 0, n[1]];\n}\nfunction tn(s, e) {\n  return new es({ type: s, schema: null, validator: e });\n}\nfunction bv() {\n  return tn(\"any\", () =&gt; !0);\n}\nfunction fe(s) {\n  return new es({\n    type: \"array\",\n    schema: s,\n    *entries(e) {\n      if (s &amp;&amp; Array.isArray(e))\n        for (const [t, r] of e.entries())\n          yield [t, r, s];\n    },\n    coercer(e) {\n      return Array.isArray(e) ? e.slice() : e;\n    },\n    validator(e) {\n      return Array.isArray(e) || `Expected an array value, but received: ${Br(e)}`;\n    }\n  });\n}\nfunction Xr() {\n  return tn(\"boolean\", (s) =&gt; typeof s == \"boolean\");\n}\nfunction Qc(s) {\n  return tn(\"instance\", (e) =&gt; e instanceof s || `Expected a \\`${s.name}\\` instance, but received: ${Br(e)}`);\n}\nfunction pt(s) {\n  const e = Br(s), t = typeof s;\n  return new es({\n    type: \"literal\",\n    schema: t === \"string\" || t === \"number\" || t === \"boolean\" ? s : null,\n    validator(r) {\n      return r === s || `Expected the literal \\`${e}\\`, but received: ${Br(r)}`;\n    }\n  });\n}\nfunction Tv() {\n  return tn(\"never\", () =&gt; !1);\n}\nfunction ge(s) {\n  return new es({\n    ...s,\n    validator: (e, t) =&gt; e === null || s.validator(e, t),\n    refiner: (e, t) =&gt; e === null || s.refiner(e, t)\n  });\n}\nfunction te() {\n  return tn(\"number\", (s) =&gt; typeof s == \"number\" &amp;&amp; !isNaN(s) || `Expected a number, but received: ${Br(s)}`);\n}\nfunction Se(s) {\n  return new es({\n    ...s,\n    validator: (e, t) =&gt; e === void 0 || s.validator(e, t),\n    refiner: (e, t) =&gt; e === void 0 || s.refiner(e, t)\n  });\n}\nfunction T0(s, e) {\n  return new es({\n    type: \"record\",\n    schema: null,\n    *entries(t) {\n      if (Ci(t))\n        for (const r in t) {\n          const n = t[r];\n          yield [r, r, s], yield [r, n, e];\n        }\n    },\n    validator(t) {\n      return $o(t) || `Expected an object, but received: ${Br(t)}`;\n    },\n    coercer(t) {\n      return $o(t) ? { ...t } : t;\n    }\n  });\n}\nfunction ce() {\n  return tn(\"string\", (s) =&gt; typeof s == \"string\" || `Expected a string, but received: ${Br(s)}`);\n}\nfunction eu(s) {\n  const e = Tv();\n  return new es({\n    type: \"tuple\",\n    schema: null,\n    *entries(t) {\n      if (Array.isArray(t)) {\n        const r = Math.max(s.length, t.length);\n        for (let n = 0; n &lt; r; n++)\n          yield [n, t[n], s[n] || e];\n      }\n    },\n    validator(t) {\n      return Array.isArray(t) || `Expected an array, but received: ${Br(t)}`;\n    },\n    coercer(t) {\n      return Array.isArray(t) ? t.slice() : t;\n    }\n  });\n}\nfunction oe(s) {\n  const e = Object.keys(s);\n  return new es({\n    type: \"type\",\n    schema: s,\n    *entries(t) {\n      if (Ci(t))\n        for (const r of e)\n          yield [r, t[r], s[r]];\n    },\n    validator(t) {\n      return $o(t) || `Expected an object, but received: ${Br(t)}`;\n    },\n    coercer(t) {\n      return $o(t) ? { ...t } : t;\n    }\n  });\n}\nfunction ur(s) {\n  const e = s.map((t) =&gt; t.type).join(\" | \");\n  return new es({\n    type: \"union\",\n    schema: null,\n    coercer(t, r) {\n      for (const n of s) {\n        const [i, o] = n.validate(t, {\n          coerce: !0,\n          mask: r.mask\n        });\n        if (!i)\n          return o;\n      }\n      return t;\n    },\n    validator(t, r) {\n      const n = [];\n      for (const i of s) {\n        const [...o] = Jc(t, i, r), [a] = o;\n        if (a[0])\n          for (const [l] of o)\n            l &amp;&amp; n.push(l);\n        else\n          return [];\n      }\n      return [\n        `Expected the value to satisfy a union of \\`${e}\\`, but received: ${Br(t)}`,\n        ...n\n      ];\n    }\n  });\n}\nfunction Gn() {\n  return tn(\"unknown\", () =&gt; !0);\n}\nfunction Di(s, e, t) {\n  return new es({\n    ...s,\n    coercer: (r, n) =&gt; b0(r, e) ? s.coercer(t(r, n), n) : s.coercer(r, n)\n  });\n}\nvar $i, wv = new Uint8Array(16);\nfunction w0() {\n  if (!$i &amp;&amp; ($i = typeof crypto &lt; \"u\" &amp;&amp; crypto.getRandomValues &amp;&amp; crypto.getRandomValues.bind(crypto) || typeof msCrypto &lt; \"u\" &amp;&amp; typeof msCrypto.getRandomValues == \"function\" &amp;&amp; msCrypto.getRandomValues.bind(msCrypto), !$i))\n    throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n  return $i(wv);\n}\nconst Av = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nfunction ua(s) {\n  return typeof s == \"string\" &amp;&amp; Av.test(s);\n}\nvar Yt = [];\nfor (var Qa = 0; Qa &lt; 256; ++Qa)\n  Yt.push((Qa + 256).toString(16).substr(1));\nfunction da(s) {\n  var e = arguments.length &gt; 1 &amp;&amp; arguments[1] !== void 0 ? arguments[1] : 0, t = (Yt[s[e + 0]] + Yt[s[e + 1]] + Yt[s[e + 2]] + Yt[s[e + 3]] + \"-\" + Yt[s[e + 4]] + Yt[s[e + 5]] + \"-\" + Yt[s[e + 6]] + Yt[s[e + 7]] + \"-\" + Yt[s[e + 8]] + Yt[s[e + 9]] + \"-\" + Yt[s[e + 10]] + Yt[s[e + 11]] + Yt[s[e + 12]] + Yt[s[e + 13]] + Yt[s[e + 14]] + Yt[s[e + 15]]).toLowerCase();\n  if (!ua(t))\n    throw TypeError(\"Stringified UUID is invalid\");\n  return t;\n}\nvar kd, el, tl = 0, rl = 0;\nfunction Iv(s, e, t) {\n  var r = e &amp;&amp; t || 0, n = e || new Array(16);\n  s = s || {};\n  var i = s.node || kd, o = s.clockseq !== void 0 ? s.clockseq : el;\n  if (i == null || o == null) {\n    var a = s.random || (s.rng || w0)();\n    i == null &amp;&amp; (i = kd = [a[0] | 1, a[1], a[2], a[3], a[4], a[5]]), o == null &amp;&amp; (o = el = (a[6] &lt;&lt; 8 | a[7]) &amp; 16383);\n  }\n  var l = s.msecs !== void 0 ? s.msecs : Date.now(), c = s.nsecs !== void 0 ? s.nsecs : rl + 1, u = l - tl + (c - rl) / 1e4;\n  if (u &lt; 0 &amp;&amp; s.clockseq === void 0 &amp;&amp; (o = o + 1 &amp; 16383), (u &lt; 0 || l &gt; tl) &amp;&amp; s.nsecs === void 0 &amp;&amp; (c = 0), c &gt;= 1e4)\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  tl = l, rl = c, el = o, l += 122192928e5;\n  var d = ((l &amp; 268435455) * 1e4 + c) % 4294967296;\n  n[r++] = d &gt;&gt;&gt; 24 &amp; 255, n[r++] = d &gt;&gt;&gt; 16 &amp; 255, n[r++] = d &gt;&gt;&gt; 8 &amp; 255, n[r++] = d &amp; 255;\n  var h = l / 4294967296 * 1e4 &amp; 268435455;\n  n[r++] = h &gt;&gt;&gt; 8 &amp; 255, n[r++] = h &amp; 255, n[r++] = h &gt;&gt;&gt; 24 &amp; 15 | 16, n[r++] = h &gt;&gt;&gt; 16 &amp; 255, n[r++] = o &gt;&gt;&gt; 8 | 128, n[r++] = o &amp; 255;\n  for (var f = 0; f &lt; 6; ++f)\n    n[r + f] = i[f];\n  return e || da(n);\n}\nfunction A0(s) {\n  if (!ua(s))\n    throw TypeError(\"Invalid UUID\");\n  var e, t = new Uint8Array(16);\n  return t[0] = (e = parseInt(s.slice(0, 8), 16)) &gt;&gt;&gt; 24, t[1] = e &gt;&gt;&gt; 16 &amp; 255, t[2] = e &gt;&gt;&gt; 8 &amp; 255, t[3] = e &amp; 255, t[4] = (e = parseInt(s.slice(9, 13), 16)) &gt;&gt;&gt; 8, t[5] = e &amp; 255, t[6] = (e = parseInt(s.slice(14, 18), 16)) &gt;&gt;&gt; 8, t[7] = e &amp; 255, t[8] = (e = parseInt(s.slice(19, 23), 16)) &gt;&gt;&gt; 8, t[9] = e &amp; 255, t[10] = (e = parseInt(s.slice(24, 36), 16)) / 1099511627776 &amp; 255, t[11] = e / 4294967296 &amp; 255, t[12] = e &gt;&gt;&gt; 24 &amp; 255, t[13] = e &gt;&gt;&gt; 16 &amp; 255, t[14] = e &gt;&gt;&gt; 8 &amp; 255, t[15] = e &amp; 255, t;\n}\nfunction _v(s) {\n  s = unescape(encodeURIComponent(s));\n  for (var e = [], t = 0; t &lt; s.length; ++t)\n    e.push(s.charCodeAt(t));\n  return e;\n}\nvar Rv = \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\", Lv = \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\";\nfunction I0(s, e, t) {\n  function r(n, i, o, a) {\n    if (typeof n == \"string\" &amp;&amp; (n = _v(n)), typeof i == \"string\" &amp;&amp; (i = A0(i)), i.length !== 16)\n      throw TypeError(\"Namespace must be array-like (16 iterable integer values, 0-255)\");\n    var l = new Uint8Array(16 + n.length);\n    if (l.set(i), l.set(n, i.length), l = t(l), l[6] = l[6] &amp; 15 | e, l[8] = l[8] &amp; 63 | 128, o) {\n      a = a || 0;\n      for (var c = 0; c &lt; 16; ++c)\n        o[a + c] = l[c];\n      return o;\n    }\n    return da(l);\n  }\n  try {\n    r.name = s;\n  } catch {\n  }\n  return r.DNS = Rv, r.URL = Lv, r;\n}\nfunction Cv(s) {\n  if (typeof s == \"string\") {\n    var e = unescape(encodeURIComponent(s));\n    s = new Uint8Array(e.length);\n    for (var t = 0; t &lt; e.length; ++t)\n      s[t] = e.charCodeAt(t);\n  }\n  return kv(Dv(Pv(s), s.length * 8));\n}\nfunction kv(s) {\n  for (var e = [], t = s.length * 32, r = \"0123456789abcdef\", n = 0; n &lt; t; n += 8) {\n    var i = s[n &gt;&gt; 5] &gt;&gt;&gt; n % 32 &amp; 255, o = parseInt(r.charAt(i &gt;&gt;&gt; 4 &amp; 15) + r.charAt(i &amp; 15), 16);\n    e.push(o);\n  }\n  return e;\n}\nfunction _0(s) {\n  return (s + 64 &gt;&gt;&gt; 9 &lt;&lt; 4) + 14 + 1;\n}\nfunction Dv(s, e) {\n  s[e &gt;&gt; 5] |= 128 &lt;&lt; e % 32, s[_0(e) - 1] = e;\n  for (var t = 1732584193, r = -271733879, n = -1732584194, i = 271733878, o = 0; o &lt; s.length; o += 16) {\n    var a = t, l = r, c = n, u = i;\n    t = er(t, r, n, i, s[o], 7, -680876936), i = er(i, t, r, n, s[o + 1], 12, -389564586), n = er(n, i, t, r, s[o + 2], 17, 606105819), r = er(r, n, i, t, s[o + 3], 22, -1044525330), t = er(t, r, n, i, s[o + 4], 7, -176418897), i = er(i, t, r, n, s[o + 5], 12, 1200080426), n = er(n, i, t, r, s[o + 6], 17, -1473231341), r = er(r, n, i, t, s[o + 7], 22, -45705983), t = er(t, r, n, i, s[o + 8], 7, 1770035416), i = er(i, t, r, n, s[o + 9], 12, -1958414417), n = er(n, i, t, r, s[o + 10], 17, -42063), r = er(r, n, i, t, s[o + 11], 22, -1990404162), t = er(t, r, n, i, s[o + 12], 7, 1804603682), i = er(i, t, r, n, s[o + 13], 12, -40341101), n = er(n, i, t, r, s[o + 14], 17, -1502002290), r = er(r, n, i, t, s[o + 15], 22, 1236535329), t = tr(t, r, n, i, s[o + 1], 5, -165796510), i = tr(i, t, r, n, s[o + 6], 9, -1069501632), n = tr(n, i, t, r, s[o + 11], 14, 643717713), r = tr(r, n, i, t, s[o], 20, -373897302), t = tr(t, r, n, i, s[o + 5], 5, -701558691), i = tr(i, t, r, n, s[o + 10], 9, 38016083), n = tr(n, i, t, r, s[o + 15], 14, -660478335), r = tr(r, n, i, t, s[o + 4], 20, -405537848), t = tr(t, r, n, i, s[o + 9], 5, 568446438), i = tr(i, t, r, n, s[o + 14], 9, -1019803690), n = tr(n, i, t, r, s[o + 3], 14, -187363961), r = tr(r, n, i, t, s[o + 8], 20, 1163531501), t = tr(t, r, n, i, s[o + 13], 5, -1444681467), i = tr(i, t, r, n, s[o + 2], 9, -51403784), n = tr(n, i, t, r, s[o + 7], 14, 1735328473), r = tr(r, n, i, t, s[o + 12], 20, -1926607734), t = rr(t, r, n, i, s[o + 5], 4, -378558), i = rr(i, t, r, n, s[o + 8], 11, -2022574463), n = rr(n, i, t, r, s[o + 11], 16, 1839030562), r = rr(r, n, i, t, s[o + 14], 23, -35309556), t = rr(t, r, n, i, s[o + 1], 4, -1530992060), i = rr(i, t, r, n, s[o + 4], 11, 1272893353), n = rr(n, i, t, r, s[o + 7], 16, -155497632), r = rr(r, n, i, t, s[o + 10], 23, -1094730640), t = rr(t, r, n, i, s[o + 13], 4, 681279174), i = rr(i, t, r, n, s[o], 11, -358537222), n = rr(n, i, t, r, s[o + 3], 16, -722521979), r = rr(r, n, i, t, s[o + 6], 23, 76029189), t = rr(t, r, n, i, s[o + 9], 4, -640364487), i = rr(i, t, r, n, s[o + 12], 11, -421815835), n = rr(n, i, t, r, s[o + 15], 16, 530742520), r = rr(r, n, i, t, s[o + 2], 23, -995338651), t = sr(t, r, n, i, s[o], 6, -198630844), i = sr(i, t, r, n, s[o + 7], 10, 1126891415), n = sr(n, i, t, r, s[o + 14], 15, -1416354905), r = sr(r, n, i, t, s[o + 5], 21, -57434055), t = sr(t, r, n, i, s[o + 12], 6, 1700485571), i = sr(i, t, r, n, s[o + 3], 10, -1894986606), n = sr(n, i, t, r, s[o + 10], 15, -1051523), r = sr(r, n, i, t, s[o + 1], 21, -2054922799), t = sr(t, r, n, i, s[o + 8], 6, 1873313359), i = sr(i, t, r, n, s[o + 15], 10, -30611744), n = sr(n, i, t, r, s[o + 6], 15, -1560198380), r = sr(r, n, i, t, s[o + 13], 21, 1309151649), t = sr(t, r, n, i, s[o + 4], 6, -145523070), i = sr(i, t, r, n, s[o + 11], 10, -1120210379), n = sr(n, i, t, r, s[o + 2], 15, 718787259), r = sr(r, n, i, t, s[o + 9], 21, -343485551), t = Ls(t, a), r = Ls(r, l), n = Ls(n, c), i = Ls(i, u);\n  }\n  return [t, r, n, i];\n}\nfunction Pv(s) {\n  if (s.length === 0)\n    return [];\n  for (var e = s.length * 8, t = new Uint32Array(_0(e)), r = 0; r &lt; e; r += 8)\n    t[r &gt;&gt; 5] |= (s[r / 8] &amp; 255) &lt;&lt; r % 32;\n  return t;\n}\nfunction Ls(s, e) {\n  var t = (s &amp; 65535) + (e &amp; 65535), r = (s &gt;&gt; 16) + (e &gt;&gt; 16) + (t &gt;&gt; 16);\n  return r &lt;&lt; 16 | t &amp; 65535;\n}\nfunction Mv(s, e) {\n  return s &lt;&lt; e | s &gt;&gt;&gt; 32 - e;\n}\nfunction ha(s, e, t, r, n, i) {\n  return Ls(Mv(Ls(Ls(e, s), Ls(r, i)), n), t);\n}\nfunction er(s, e, t, r, n, i, o) {\n  return ha(e &amp; t | ~e &amp; r, s, e, n, i, o);\n}\nfunction tr(s, e, t, r, n, i, o) {\n  return ha(e &amp; r | t &amp; ~r, s, e, n, i, o);\n}\nfunction rr(s, e, t, r, n, i, o) {\n  return ha(e ^ t ^ r, s, e, n, i, o);\n}\nfunction sr(s, e, t, r, n, i, o) {\n  return ha(t ^ (e | ~r), s, e, n, i, o);\n}\nvar Ov = I0(\"v3\", 48, Cv);\nfunction Bv(s, e, t) {\n  s = s || {};\n  var r = s.random || (s.rng || w0)();\n  if (r[6] = r[6] &amp; 15 | 64, r[8] = r[8] &amp; 63 | 128, e) {\n    t = t || 0;\n    for (var n = 0; n &lt; 16; ++n)\n      e[t + n] = r[n];\n    return e;\n  }\n  return da(r);\n}\nfunction Fv(s, e, t, r) {\n  switch (s) {\n    case 0:\n      return e &amp; t ^ ~e &amp; r;\n    case 1:\n      return e ^ t ^ r;\n    case 2:\n      return e &amp; t ^ e &amp; r ^ t &amp; r;\n    case 3:\n      return e ^ t ^ r;\n  }\n}\nfunction sl(s, e) {\n  return s &lt;&lt; e | s &gt;&gt;&gt; 32 - e;\n}\nfunction Nv(s) {\n  var e = [1518500249, 1859775393, 2400959708, 3395469782], t = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];\n  if (typeof s == \"string\") {\n    var r = unescape(encodeURIComponent(s));\n    s = [];\n    for (var n = 0; n &lt; r.length; ++n)\n      s.push(r.charCodeAt(n));\n  } else Array.isArray(s) || (s = Array.prototype.slice.call(s));\n  s.push(128);\n  for (var i = s.length / 4 + 2, o = Math.ceil(i / 16), a = new Array(o), l = 0; l &lt; o; ++l) {\n    for (var c = new Uint32Array(16), u = 0; u &lt; 16; ++u)\n      c[u] = s[l * 64 + u * 4] &lt;&lt; 24 | s[l * 64 + u * 4 + 1] &lt;&lt; 16 | s[l * 64 + u * 4 + 2] &lt;&lt; 8 | s[l * 64 + u * 4 + 3];\n    a[l] = c;\n  }\n  a[o - 1][14] = (s.length - 1) * 8 / Math.pow(2, 32), a[o - 1][14] = Math.floor(a[o - 1][14]), a[o - 1][15] = (s.length - 1) * 8 &amp; 4294967295;\n  for (var d = 0; d &lt; o; ++d) {\n    for (var h = new Uint32Array(80), f = 0; f &lt; 16; ++f)\n      h[f] = a[d][f];\n    for (var p = 16; p &lt; 80; ++p)\n      h[p] = sl(h[p - 3] ^ h[p - 8] ^ h[p - 14] ^ h[p - 16], 1);\n    for (var y = t[0], E = t[1], b = t[2], R = t[3], A = t[4], F = 0; F &lt; 80; ++F) {\n      var M = Math.floor(F / 20), H = sl(y, 5) + Fv(M, E, b, R) + A + e[M] + h[F] &gt;&gt;&gt; 0;\n      A = R, R = b, b = sl(E, 30) &gt;&gt;&gt; 0, E = y, y = H;\n    }\n    t[0] = t[0] + y &gt;&gt;&gt; 0, t[1] = t[1] + E &gt;&gt;&gt; 0, t[2] = t[2] + b &gt;&gt;&gt; 0, t[3] = t[3] + R &gt;&gt;&gt; 0, t[4] = t[4] + A &gt;&gt;&gt; 0;\n  }\n  return [t[0] &gt;&gt; 24 &amp; 255, t[0] &gt;&gt; 16 &amp; 255, t[0] &gt;&gt; 8 &amp; 255, t[0] &amp; 255, t[1] &gt;&gt; 24 &amp; 255, t[1] &gt;&gt; 16 &amp; 255, t[1] &gt;&gt; 8 &amp; 255, t[1] &amp; 255, t[2] &gt;&gt; 24 &amp; 255, t[2] &gt;&gt; 16 &amp; 255, t[2] &gt;&gt; 8 &amp; 255, t[2] &amp; 255, t[3] &gt;&gt; 24 &amp; 255, t[3] &gt;&gt; 16 &amp; 255, t[3] &gt;&gt; 8 &amp; 255, t[3] &amp; 255, t[4] &gt;&gt; 24 &amp; 255, t[4] &gt;&gt; 16 &amp; 255, t[4] &gt;&gt; 8 &amp; 255, t[4] &amp; 255];\n}\nvar Uv = I0(\"v5\", 80, Nv);\nconst $v = \"00000000-0000-0000-0000-000000000000\";\nfunction Gv(s) {\n  if (!ua(s))\n    throw TypeError(\"Invalid UUID\");\n  return parseInt(s.substr(14, 1), 16);\n}\nconst Vv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  NIL: $v,\n  parse: A0,\n  stringify: da,\n  v1: Iv,\n  v3: Ov,\n  v4: Bv,\n  v5: Uv,\n  validate: ua,\n  version: Gv\n}, Symbol.toStringTag, { value: \"Module\" })), R0 = /* @__PURE__ */ Nc(Vv);\nvar nl, Dd;\nfunction jv() {\n  if (Dd) return nl;\n  Dd = 1;\n  const s = R0.v4;\n  return nl = function(t, r, n, i) {\n    if (typeof t != \"string\")\n      throw new TypeError(t + \" must be a string\");\n    i = i || {};\n    const o = typeof i.version == \"number\" ? i.version : 2;\n    if (o !== 1 &amp;&amp; o !== 2)\n      throw new TypeError(o + \" must be 1 or 2\");\n    const a = {\n      method: t\n    };\n    if (o === 2 &amp;&amp; (a.jsonrpc = \"2.0\"), r) {\n      if (typeof r != \"object\" &amp;&amp; !Array.isArray(r))\n        throw new TypeError(r + \" must be an object, array or omitted\");\n      a.params = r;\n    }\n    if (typeof n &gt; \"u\") {\n      const l = typeof i.generator == \"function\" ? i.generator : function() {\n        return s();\n      };\n      a.id = l(a, i);\n    } else o === 2 &amp;&amp; n === null ? i.notificationIdNull &amp;&amp; (a.id = null) : a.id = n;\n    return a;\n  }, nl;\n}\nvar il, Pd;\nfunction Kv() {\n  if (Pd) return il;\n  Pd = 1;\n  const s = R0.v4, e = jv(), t = function(r, n) {\n    if (!(this instanceof t))\n      return new t(r, n);\n    n || (n = {}), this.options = {\n      reviver: typeof n.reviver &lt; \"u\" ? n.reviver : null,\n      replacer: typeof n.replacer &lt; \"u\" ? n.replacer : null,\n      generator: typeof n.generator &lt; \"u\" ? n.generator : function() {\n        return s();\n      },\n      version: typeof n.version &lt; \"u\" ? n.version : 2,\n      notificationIdNull: typeof n.notificationIdNull == \"boolean\" ? n.notificationIdNull : !1\n    }, this.callServer = r;\n  };\n  return il = t, t.prototype.request = function(r, n, i, o) {\n    const a = this;\n    let l = null;\n    const c = Array.isArray(r) &amp;&amp; typeof n == \"function\";\n    if (this.options.version === 1 &amp;&amp; c)\n      throw new TypeError(\"JSON-RPC 1.0 does not support batching\");\n    if (c || !c &amp;&amp; r &amp;&amp; typeof r == \"object\" &amp;&amp; typeof n == \"function\")\n      o = n, l = r;\n    else {\n      typeof i == \"function\" &amp;&amp; (o = i, i = void 0);\n      const h = typeof o == \"function\";\n      try {\n        l = e(r, n, i, {\n          generator: this.options.generator,\n          version: this.options.version,\n          notificationIdNull: this.options.notificationIdNull\n        });\n      } catch (f) {\n        if (h)\n          return o(f);\n        throw f;\n      }\n      if (!h)\n        return l;\n    }\n    let d;\n    try {\n      d = JSON.stringify(l, this.options.replacer);\n    } catch (h) {\n      return o(h);\n    }\n    return this.callServer(d, function(h, f) {\n      a._parseResponse(h, f, o);\n    }), l;\n  }, t.prototype._parseResponse = function(r, n, i) {\n    if (r) {\n      i(r);\n      return;\n    }\n    if (!n)\n      return i();\n    let o;\n    try {\n      o = JSON.parse(n, this.options.reviver);\n    } catch (a) {\n      return i(a);\n    }\n    if (i.length === 3)\n      if (Array.isArray(o)) {\n        const a = function(c) {\n          return typeof c.error &lt; \"u\";\n        }, l = function(c) {\n          return !a(c);\n        };\n        return i(null, o.filter(a), o.filter(l));\n      } else\n        return i(null, o.error, o.result);\n    i(null, o);\n  }, il;\n}\nKv();\nvar ol = { exports: {} }, Md;\nfunction Hv() {\n  return Md || (Md = 1, (function(s) {\n    var e = Object.prototype.hasOwnProperty, t = \"~\";\n    function r() {\n    }\n    Object.create &amp;&amp; (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (t = !1));\n    function n(l, c, u) {\n      this.fn = l, this.context = c, this.once = u || !1;\n    }\n    function i(l, c, u, d, h) {\n      if (typeof u != \"function\")\n        throw new TypeError(\"The listener must be a function\");\n      var f = new n(u, d || l, h), p = t ? t + c : c;\n      return l._events[p] ? l._events[p].fn ? l._events[p] = [l._events[p], f] : l._events[p].push(f) : (l._events[p] = f, l._eventsCount++), l;\n    }\n    function o(l, c) {\n      --l._eventsCount === 0 ? l._events = new r() : delete l._events[c];\n    }\n    function a() {\n      this._events = new r(), this._eventsCount = 0;\n    }\n    a.prototype.eventNames = function() {\n      var c = [], u, d;\n      if (this._eventsCount === 0) return c;\n      for (d in u = this._events)\n        e.call(u, d) &amp;&amp; c.push(t ? d.slice(1) : d);\n      return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(u)) : c;\n    }, a.prototype.listeners = function(c) {\n      var u = t ? t + c : c, d = this._events[u];\n      if (!d) return [];\n      if (d.fn) return [d.fn];\n      for (var h = 0, f = d.length, p = new Array(f); h &lt; f; h++)\n        p[h] = d[h].fn;\n      return p;\n    }, a.prototype.listenerCount = function(c) {\n      var u = t ? t + c : c, d = this._events[u];\n      return d ? d.fn ? 1 : d.length : 0;\n    }, a.prototype.emit = function(c, u, d, h, f, p) {\n      var y = t ? t + c : c;\n      if (!this._events[y]) return !1;\n      var E = this._events[y], b = arguments.length, R, A;\n      if (E.fn) {\n        switch (E.once &amp;&amp; this.removeListener(c, E.fn, void 0, !0), b) {\n          case 1:\n            return E.fn.call(E.context), !0;\n          case 2:\n            return E.fn.call(E.context, u), !0;\n          case 3:\n            return E.fn.call(E.context, u, d), !0;\n          case 4:\n            return E.fn.call(E.context, u, d, h), !0;\n          case 5:\n            return E.fn.call(E.context, u, d, h, f), !0;\n          case 6:\n            return E.fn.call(E.context, u, d, h, f, p), !0;\n        }\n        for (A = 1, R = new Array(b - 1); A &lt; b; A++)\n          R[A - 1] = arguments[A];\n        E.fn.apply(E.context, R);\n      } else {\n        var F = E.length, M;\n        for (A = 0; A &lt; F; A++)\n          switch (E[A].once &amp;&amp; this.removeListener(c, E[A].fn, void 0, !0), b) {\n            case 1:\n              E[A].fn.call(E[A].context);\n              break;\n            case 2:\n              E[A].fn.call(E[A].context, u);\n              break;\n            case 3:\n              E[A].fn.call(E[A].context, u, d);\n              break;\n            case 4:\n              E[A].fn.call(E[A].context, u, d, h);\n              break;\n            default:\n              if (!R) for (M = 1, R = new Array(b - 1); M &lt; b; M++)\n                R[M - 1] = arguments[M];\n              E[A].fn.apply(E[A].context, R);\n          }\n      }\n      return !0;\n    }, a.prototype.on = function(c, u, d) {\n      return i(this, c, u, d, !1);\n    }, a.prototype.once = function(c, u, d) {\n      return i(this, c, u, d, !0);\n    }, a.prototype.removeListener = function(c, u, d, h) {\n      var f = t ? t + c : c;\n      if (!this._events[f]) return this;\n      if (!u)\n        return o(this, f), this;\n      var p = this._events[f];\n      if (p.fn)\n        p.fn === u &amp;&amp; (!h || p.once) &amp;&amp; (!d || p.context === d) &amp;&amp; o(this, f);\n      else {\n        for (var y = 0, E = [], b = p.length; y &lt; b; y++)\n          (p[y].fn !== u || h &amp;&amp; !p[y].once || d &amp;&amp; p[y].context !== d) &amp;&amp; E.push(p[y]);\n        E.length ? this._events[f] = E.length === 1 ? E[0] : E : o(this, f);\n      }\n      return this;\n    }, a.prototype.removeAllListeners = function(c) {\n      var u;\n      return c ? (u = t ? t + c : c, this._events[u] &amp;&amp; o(this, u)) : (this._events = new r(), this._eventsCount = 0), this;\n    }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = t, a.EventEmitter = a, s.exports = a;\n  })(ol)), ol.exports;\n}\nvar qv = Hv();\nconst L0 = /* @__PURE__ */ Fc(qv);\nclass C0 extends Wf {\n  constructor(e, t) {\n    super(), this.finished = !1, this.destroyed = !1, Hf(e);\n    const r = Hc(t);\n    if (this.iHash = e.create(), typeof this.iHash.update != \"function\")\n      throw new Error(\"Expected instance of class which extends utils.Hash\");\n    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;\n    const n = this.blockLen, i = new Uint8Array(n);\n    i.set(r.length &gt; n ? e.create().update(r).digest() : r);\n    for (let o = 0; o &lt; i.length; o++)\n      i[o] ^= 54;\n    this.iHash.update(i), this.oHash = e.create();\n    for (let o = 0; o &lt; i.length; o++)\n      i[o] ^= 106;\n    this.oHash.update(i), kn(i);\n  }\n  update(e) {\n    return Do(this), this.iHash.update(e), this;\n  }\n  digestInto(e) {\n    Do(this), Qs(e, this.outputLen), this.finished = !0, this.iHash.digestInto(e), this.oHash.update(e), this.oHash.digestInto(e), this.destroy();\n  }\n  digest() {\n    const e = new Uint8Array(this.oHash.outputLen);\n    return this.digestInto(e), e;\n  }\n  _cloneInto(e) {\n    e || (e = Object.create(Object.getPrototypeOf(this), {}));\n    const { oHash: t, iHash: r, finished: n, destroyed: i, blockLen: o, outputLen: a } = this;\n    return e = e, e.finished = n, e.destroyed = i, e.blockLen = o, e.outputLen = a, e.oHash = t._cloneInto(e.oHash), e.iHash = r._cloneInto(e.iHash), e;\n  }\n  clone() {\n    return this._cloneInto();\n  }\n  destroy() {\n    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();\n  }\n}\nconst k0 = (s, e, t) =&gt; new C0(s, e).update(t).digest();\nk0.create = (s, e) =&gt; new C0(s, e);\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst Od = (s, e) =&gt; (s + (s &gt;= 0 ? e : -e) / D0) / e;\nfunction Wv(s, e, t) {\n  const [[r, n], [i, o]] = e, a = Od(o * s, t), l = Od(-n * s, t);\n  let c = s - a * r - l * i, u = -a * n - l * o;\n  const d = c &lt; hs, h = u &lt; hs;\n  d &amp;&amp; (c = -c), h &amp;&amp; (u = -u);\n  const f = _i(Math.ceil(e0(t) / 2)) + Tn;\n  if (c &lt; hs || c &gt;= f || u &lt; hs || u &gt;= f)\n    throw new Error(\"splitScalar (endomorphism): failed, k=\" + s);\n  return { k1neg: d, k1: c, k2neg: h, k2: u };\n}\nfunction ec(s) {\n  if (![\"compact\", \"recovered\", \"der\"].includes(s))\n    throw new Error('Signature format must be \"compact\", \"recovered\", or \"der\"');\n  return s;\n}\nfunction al(s, e) {\n  const t = {};\n  for (let r of Object.keys(e))\n    t[r] = s[r] === void 0 ? e[r] : s[r];\n  return Xs(t.lowS, \"lowS\"), Xs(t.prehash, \"prehash\"), t.format !== void 0 &amp;&amp; ec(t.format), t;\n}\nclass zv extends Error {\n  constructor(e = \"\") {\n    super(e);\n  }\n}\nconst cs = {\n  // asn.1 DER encoding utils\n  Err: zv,\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (s, e) =&gt; {\n      const { Err: t } = cs;\n      if (s &lt; 0 || s &gt; 256)\n        throw new t(\"tlv.encode: wrong tag\");\n      if (e.length &amp; 1)\n        throw new t(\"tlv.encode: unpadded data\");\n      const r = e.length / 2, n = Ni(r);\n      if (n.length / 2 &amp; 128)\n        throw new t(\"tlv.encode: long form length too big\");\n      const i = r &gt; 127 ? Ni(n.length / 2 | 128) : \"\";\n      return Ni(s) + i + n + e;\n    },\n    // v - value, l - left bytes (unparsed)\n    decode(s, e) {\n      const { Err: t } = cs;\n      let r = 0;\n      if (s &lt; 0 || s &gt; 256)\n        throw new t(\"tlv.encode: wrong tag\");\n      if (e.length &lt; 2 || e[r++] !== s)\n        throw new t(\"tlv.decode: wrong tlv\");\n      const n = e[r++], i = !!(n &amp; 128);\n      let o = 0;\n      if (!i)\n        o = n;\n      else {\n        const l = n &amp; 127;\n        if (!l)\n          throw new t(\"tlv.decode(long): indefinite length not supported\");\n        if (l &gt; 4)\n          throw new t(\"tlv.decode(long): byte length is too big\");\n        const c = e.subarray(r, r + l);\n        if (c.length !== l)\n          throw new t(\"tlv.decode: length bytes not complete\");\n        if (c[0] === 0)\n          throw new t(\"tlv.decode(long): zero leftmost byte\");\n        for (const u of c)\n          o = o &lt;&lt; 8 | u;\n        if (r += l, o &lt; 128)\n          throw new t(\"tlv.decode(long): not minimal encoding\");\n      }\n      const a = e.subarray(r, r + o);\n      if (a.length !== o)\n        throw new t(\"tlv.decode: wrong value length\");\n      return { v: a, l: e.subarray(r + o) };\n    }\n  },\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(s) {\n      const { Err: e } = cs;\n      if (s &lt; hs)\n        throw new e(\"integer: negative integers are not allowed\");\n      let t = Ni(s);\n      if (Number.parseInt(t[0], 16) &amp; 8 &amp;&amp; (t = \"00\" + t), t.length &amp; 1)\n        throw new e(\"unexpected DER parsing assertion: unpadded hex\");\n      return t;\n    },\n    decode(s) {\n      const { Err: e } = cs;\n      if (s[0] &amp; 128)\n        throw new e(\"invalid signature integer: negative\");\n      if (s[0] === 0 &amp;&amp; !(s[1] &amp; 128))\n        throw new e(\"invalid signature integer: unnecessary leading zero\");\n      return la(s);\n    }\n  },\n  toSig(s) {\n    const { Err: e, _int: t, _tlv: r } = cs, n = Et(\"signature\", s), { v: i, l: o } = r.decode(48, n);\n    if (o.length)\n      throw new e(\"invalid signature: left bytes after parsing\");\n    const { v: a, l } = r.decode(2, i), { v: c, l: u } = r.decode(2, l);\n    if (u.length)\n      throw new e(\"invalid signature: left bytes after parsing\");\n    return { r: t.decode(a), s: t.decode(c) };\n  },\n  hexFromSig(s) {\n    const { _tlv: e, _int: t } = cs, r = e.encode(2, t.encode(s.r)), n = e.encode(2, t.encode(s.s)), i = r + n;\n    return e.encode(48, i);\n  }\n}, hs = BigInt(0), Tn = BigInt(1), D0 = BigInt(2), Gi = BigInt(3), Yv = BigInt(4);\nfunction En(s, e) {\n  const { BYTES: t } = s;\n  let r;\n  if (typeof e == \"bigint\")\n    r = e;\n  else {\n    let n = Et(\"private key\", e);\n    try {\n      r = s.fromBytes(n);\n    } catch {\n      throw new Error(`invalid private key: expected ui8a of size ${t}, got ${typeof e}`);\n    }\n  }\n  if (!s.isValidNot0(r))\n    throw new Error(\"invalid private key: out of range [1..N-1]\");\n  return r;\n}\nfunction Zv(s, e = {}) {\n  const t = m0(\"weierstrass\", s, e), { Fp: r, Fn: n } = t;\n  let i = t.CURVE;\n  const { h: o, n: a } = i;\n  Ri(e, {}, {\n    allowInfinityPoint: \"boolean\",\n    clearCofactor: \"function\",\n    isTorsionFree: \"function\",\n    fromBytes: \"function\",\n    toBytes: \"function\",\n    endo: \"object\",\n    wrapPrivateKey: \"boolean\"\n  });\n  const { endo: l } = e;\n  if (l &amp;&amp; (!r.is0(i.a) || typeof l.beta != \"bigint\" || !Array.isArray(l.basises)))\n    throw new Error('invalid endo: expected \"beta\": bigint and \"basises\": array');\n  const c = M0(r, n);\n  function u() {\n    if (!r.isOdd)\n      throw new Error(\"compression is not supported: Field does not have .isOdd()\");\n  }\n  function d(W, _, g) {\n    const { x, y: w } = _.toAffine(), D = r.toBytes(x);\n    if (Xs(g, \"isCompressed\"), g) {\n      u();\n      const O = !r.isOdd(w);\n      return Kr(P0(O), D);\n    } else\n      return Kr(Uint8Array.of(4), D, r.toBytes(w));\n  }\n  function h(W) {\n    Or(W, void 0, \"Point\");\n    const { publicKey: _, publicKeyUncompressed: g } = c, x = W.length, w = W[0], D = W.subarray(1);\n    if (x === _ &amp;&amp; (w === 2 || w === 3)) {\n      const O = r.fromBytes(D);\n      if (!r.isValid(O))\n        throw new Error(\"bad point: is not on curve, wrong x\");\n      const U = y(O);\n      let V;\n      try {\n        V = r.sqrt(U);\n      } catch (v) {\n        const P = v instanceof Error ? \": \" + v.message : \"\";\n        throw new Error(\"bad point: is not on curve, sqrt error\" + P);\n      }\n      u();\n      const L = r.isOdd(V);\n      return (w &amp; 1) === 1 !== L &amp;&amp; (V = r.neg(V)), { x: O, y: V };\n    } else if (x === g &amp;&amp; w === 4) {\n      const O = r.BYTES, U = r.fromBytes(D.subarray(0, O)), V = r.fromBytes(D.subarray(O, O * 2));\n      if (!E(U, V))\n        throw new Error(\"bad point: is not on curve\");\n      return { x: U, y: V };\n    } else\n      throw new Error(`bad point: got length ${x}, expected compressed=${_} or uncompressed=${g}`);\n  }\n  const f = e.toBytes || d, p = e.fromBytes || h;\n  function y(W) {\n    const _ = r.sqr(W), g = r.mul(_, W);\n    return r.add(r.add(g, r.mul(W, i.a)), i.b);\n  }\n  function E(W, _) {\n    const g = r.sqr(_), x = y(W);\n    return r.eql(g, x);\n  }\n  if (!E(i.Gx, i.Gy))\n    throw new Error(\"bad curve params: generator point\");\n  const b = r.mul(r.pow(i.a, Gi), Yv), R = r.mul(r.sqr(i.b), BigInt(27));\n  if (r.is0(r.add(b, R)))\n    throw new Error(\"bad curve params: a or b\");\n  function A(W, _, g = !1) {\n    if (!r.isValid(_) || g &amp;&amp; r.is0(_))\n      throw new Error(`bad point coordinate ${W}`);\n    return _;\n  }\n  function F(W) {\n    if (!(W instanceof C))\n      throw new Error(\"ProjectivePoint expected\");\n  }\n  function M(W) {\n    if (!l || !l.basises)\n      throw new Error(\"no endo\");\n    return Wv(W, l.basises, n.ORDER);\n  }\n  const H = Mo((W, _) =&gt; {\n    const { X: g, Y: x, Z: w } = W;\n    if (r.eql(w, r.ONE))\n      return { x: g, y: x };\n    const D = W.is0();\n    _ == null &amp;&amp; (_ = D ? r.ONE : r.inv(w));\n    const O = r.mul(g, _), U = r.mul(x, _), V = r.mul(w, _);\n    if (D)\n      return { x: r.ZERO, y: r.ZERO };\n    if (!r.eql(V, r.ONE))\n      throw new Error(\"invZ was invalid\");\n    return { x: O, y: U };\n  }), K = Mo((W) =&gt; {\n    if (W.is0()) {\n      if (e.allowInfinityPoint &amp;&amp; !r.is0(W.Y))\n        return;\n      throw new Error(\"bad point: ZERO\");\n    }\n    const { x: _, y: g } = W.toAffine();\n    if (!r.isValid(_) || !r.isValid(g))\n      throw new Error(\"bad point: x or y not field elements\");\n    if (!E(_, g))\n      throw new Error(\"bad point: equation left != right\");\n    if (!W.isTorsionFree())\n      throw new Error(\"bad point: not in prime-order subgroup\");\n    return !0;\n  });\n  function j(W, _, g, x, w) {\n    return g = new C(r.mul(g.X, W), g.Y, g.Z), _ = Oo(x, _), g = Oo(w, g), _.add(g);\n  }\n  class C {\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    constructor(_, g, x) {\n      this.X = A(\"x\", _), this.Y = A(\"y\", g, !0), this.Z = A(\"z\", x), Object.freeze(this);\n    }\n    static CURVE() {\n      return i;\n    }\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    static fromAffine(_) {\n      const { x: g, y: x } = _ || {};\n      if (!_ || !r.isValid(g) || !r.isValid(x))\n        throw new Error(\"invalid affine point\");\n      if (_ instanceof C)\n        throw new Error(\"projective point not allowed\");\n      return r.is0(g) &amp;&amp; r.is0(x) ? C.ZERO : new C(g, x, r.ONE);\n    }\n    static fromBytes(_) {\n      const g = C.fromAffine(p(Or(_, void 0, \"point\")));\n      return g.assertValidity(), g;\n    }\n    static fromHex(_) {\n      return C.fromBytes(Et(\"pointHex\", _));\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    /**\n     *\n     * @param windowSize\n     * @param isLazy true will defer table computation until the first multiplication\n     * @returns\n     */\n    precompute(_ = 8, g = !0) {\n      return $.createCache(this, _), g || this.multiply(Gi), this;\n    }\n    // TODO: return `this`\n    /** A point on curve is valid if it conforms to equation. */\n    assertValidity() {\n      K(this);\n    }\n    hasEvenY() {\n      const { y: _ } = this.toAffine();\n      if (!r.isOdd)\n        throw new Error(\"Field doesn't support isOdd\");\n      return !r.isOdd(_);\n    }\n    /** Compare one point to another. */\n    equals(_) {\n      F(_);\n      const { X: g, Y: x, Z: w } = this, { X: D, Y: O, Z: U } = _, V = r.eql(r.mul(g, U), r.mul(D, w)), L = r.eql(r.mul(x, U), r.mul(O, w));\n      return V &amp;&amp; L;\n    }\n    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n    negate() {\n      return new C(this.X, r.neg(this.Y), this.Z);\n    }\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const { a: _, b: g } = i, x = r.mul(g, Gi), { X: w, Y: D, Z: O } = this;\n      let U = r.ZERO, V = r.ZERO, L = r.ZERO, m = r.mul(w, w), v = r.mul(D, D), P = r.mul(O, O), N = r.mul(w, D);\n      return N = r.add(N, N), L = r.mul(w, O), L = r.add(L, L), U = r.mul(_, L), V = r.mul(x, P), V = r.add(U, V), U = r.sub(v, V), V = r.add(v, V), V = r.mul(U, V), U = r.mul(N, U), L = r.mul(x, L), P = r.mul(_, P), N = r.sub(m, P), N = r.mul(_, N), N = r.add(N, L), L = r.add(m, m), m = r.add(L, m), m = r.add(m, P), m = r.mul(m, N), V = r.add(V, m), P = r.mul(D, O), P = r.add(P, P), m = r.mul(P, N), U = r.sub(U, m), L = r.mul(P, v), L = r.add(L, L), L = r.add(L, L), new C(U, V, L);\n    }\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(_) {\n      F(_);\n      const { X: g, Y: x, Z: w } = this, { X: D, Y: O, Z: U } = _;\n      let V = r.ZERO, L = r.ZERO, m = r.ZERO;\n      const v = i.a, P = r.mul(i.b, Gi);\n      let N = r.mul(g, D), Y = r.mul(x, O), ee = r.mul(w, U), ie = r.add(g, x), le = r.add(D, O);\n      ie = r.mul(ie, le), le = r.add(N, Y), ie = r.sub(ie, le), le = r.add(g, w);\n      let Te = r.add(D, U);\n      return le = r.mul(le, Te), Te = r.add(N, ee), le = r.sub(le, Te), Te = r.add(x, w), V = r.add(O, U), Te = r.mul(Te, V), V = r.add(Y, ee), Te = r.sub(Te, V), m = r.mul(v, le), V = r.mul(P, ee), m = r.add(V, m), V = r.sub(Y, m), m = r.add(Y, m), L = r.mul(V, m), Y = r.add(N, N), Y = r.add(Y, N), ee = r.mul(v, ee), le = r.mul(P, le), Y = r.add(Y, ee), ee = r.sub(N, ee), ee = r.mul(v, ee), le = r.add(le, ee), N = r.mul(Y, le), L = r.add(L, N), N = r.mul(Te, le), V = r.mul(ie, V), V = r.sub(V, N), N = r.mul(ie, Y), m = r.mul(Te, m), m = r.add(m, N), new C(V, L, m);\n    }\n    subtract(_) {\n      return this.add(_.negate());\n    }\n    is0() {\n      return this.equals(C.ZERO);\n    }\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(_) {\n      const { endo: g } = e;\n      if (!n.isValidNot0(_))\n        throw new Error(\"invalid scalar: out of range\");\n      let x, w;\n      const D = (O) =&gt; $.cached(this, O, (U) =&gt; js(C, U));\n      if (g) {\n        const { k1neg: O, k1: U, k2neg: V, k2: L } = M(_), { p: m, f: v } = D(U), { p: P, f: N } = D(L);\n        w = v.add(N), x = j(g.beta, m, P, O, V);\n      } else {\n        const { p: O, f: U } = D(_);\n        x = O, w = U;\n      }\n      return js(C, [x, w])[0];\n    }\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed secret key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(_) {\n      const { endo: g } = e, x = this;\n      if (!n.isValid(_))\n        throw new Error(\"invalid scalar: out of range\");\n      if (_ === hs || x.is0())\n        return C.ZERO;\n      if (_ === Tn)\n        return x;\n      if ($.hasCache(this))\n        return this.multiply(_);\n      if (g) {\n        const { k1neg: w, k1: D, k2neg: O, k2: U } = M(_), { p1: V, p2: L } = py(C, x, D, U);\n        return j(g.beta, V, L, w, O);\n      } else\n        return $.unsafe(x, _);\n    }\n    multiplyAndAddUnsafe(_, g, x) {\n      const w = this.multiplyUnsafe(g).add(_.multiplyUnsafe(x));\n      return w.is0() ? void 0 : w;\n    }\n    /**\n     * Converts Projective point to affine (x, y) coordinates.\n     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n     */\n    toAffine(_) {\n      return H(this, _);\n    }\n    /**\n     * Checks whether Point is free of torsion elements (is in prime subgroup).\n     * Always torsion-free for cofactor=1 curves.\n     */\n    isTorsionFree() {\n      const { isTorsionFree: _ } = e;\n      return o === Tn ? !0 : _ ? _(C, this) : $.unsafe(this, a).is0();\n    }\n    clearCofactor() {\n      const { clearCofactor: _ } = e;\n      return o === Tn ? this : _ ? _(C, this) : this.multiplyUnsafe(o);\n    }\n    isSmallOrder() {\n      return this.multiplyUnsafe(o).is0();\n    }\n    toBytes(_ = !0) {\n      return Xs(_, \"isCompressed\"), this.assertValidity(), f(C, this, _);\n    }\n    toHex(_ = !0) {\n      return Hs(this.toBytes(_));\n    }\n    toString() {\n      return `&lt;Point ${this.is0() ? \"ZERO\" : this.toHex()}&gt;`;\n    }\n    // TODO: remove\n    get px() {\n      return this.X;\n    }\n    get py() {\n      return this.X;\n    }\n    get pz() {\n      return this.Z;\n    }\n    toRawBytes(_ = !0) {\n      return this.toBytes(_);\n    }\n    _setWindowSize(_) {\n      this.precompute(_);\n    }\n    static normalizeZ(_) {\n      return js(C, _);\n    }\n    static msm(_, g) {\n      return p0(C, n, _, g);\n    }\n    static fromPrivateKey(_) {\n      return C.BASE.multiply(En(n, _));\n    }\n  }\n  C.BASE = new C(i.Gx, i.Gy, r.ONE), C.ZERO = new C(r.ZERO, r.ONE, r.ZERO), C.Fp = r, C.Fn = n;\n  const k = n.BITS, $ = new g0(C, e.endo ? Math.ceil(k / 2) : k);\n  return C.BASE.precompute(8), C;\n}\nfunction P0(s) {\n  return Uint8Array.of(s ? 2 : 3);\n}\nfunction M0(s, e) {\n  return {\n    secretKey: e.BYTES,\n    publicKey: 1 + s.BYTES,\n    publicKeyUncompressed: 1 + 2 * s.BYTES,\n    publicKeyHasPrefix: !0,\n    signature: 2 * e.BYTES\n  };\n}\nfunction Xv(s, e = {}) {\n  const { Fn: t } = s, r = e.randomBytes || qc, n = Object.assign(M0(s.Fp, t), { seed: d0(t.ORDER) });\n  function i(f) {\n    try {\n      return !!En(t, f);\n    } catch {\n      return !1;\n    }\n  }\n  function o(f, p) {\n    const { publicKey: y, publicKeyUncompressed: E } = n;\n    try {\n      const b = f.length;\n      return p === !0 &amp;&amp; b !== y || p === !1 &amp;&amp; b !== E ? !1 : !!s.fromBytes(f);\n    } catch {\n      return !1;\n    }\n  }\n  function a(f = r(n.seed)) {\n    return hy(Or(f, n.seed, \"seed\"), t.ORDER);\n  }\n  function l(f, p = !0) {\n    return s.BASE.multiply(En(t, f)).toBytes(p);\n  }\n  function c(f) {\n    const p = a(f);\n    return { secretKey: p, publicKey: l(p) };\n  }\n  function u(f) {\n    if (typeof f == \"bigint\")\n      return !1;\n    if (f instanceof s)\n      return !0;\n    const { secretKey: p, publicKey: y, publicKeyUncompressed: E } = n;\n    if (t.allowedLengths || p === y)\n      return;\n    const b = Et(\"key\", f).length;\n    return b === y || b === E;\n  }\n  function d(f, p, y = !0) {\n    if (u(f) === !0)\n      throw new Error(\"first arg must be private key\");\n    if (u(p) === !1)\n      throw new Error(\"second arg must be public key\");\n    const E = En(t, f);\n    return s.fromHex(p).multiply(E).toBytes(y);\n  }\n  return Object.freeze({ getPublicKey: l, getSharedSecret: d, keygen: c, Point: s, utils: {\n    isValidSecretKey: i,\n    isValidPublicKey: o,\n    randomSecretKey: a,\n    // TODO: remove\n    isValidPrivateKey: i,\n    randomPrivateKey: a,\n    normPrivateKeyToScalar: (f) =&gt; En(t, f),\n    precompute(f = 8, p = s.BASE) {\n      return p.precompute(f, !1);\n    }\n  }, lengths: n });\n}\nfunction Jv(s, e, t = {}) {\n  Hf(e), Ri(t, {}, {\n    hmac: \"function\",\n    lowS: \"boolean\",\n    randomBytes: \"function\",\n    bits2int: \"function\",\n    bits2int_modN: \"function\"\n  });\n  const r = t.randomBytes || qc, n = t.hmac || ((g, ...x) =&gt; k0(e, g, Kr(...x))), { Fp: i, Fn: o } = s, { ORDER: a, BITS: l } = o, { keygen: c, getPublicKey: u, getSharedSecret: d, utils: h, lengths: f } = Xv(s, t), p = {\n    prehash: !1,\n    lowS: typeof t.lowS == \"boolean\" ? t.lowS : !1,\n    format: void 0,\n    //'compact' as ECDSASigFormat,\n    extraEntropy: !1\n  }, y = \"compact\";\n  function E(g) {\n    const x = a &gt;&gt; Tn;\n    return g &gt; x;\n  }\n  function b(g, x) {\n    if (!o.isValidNot0(x))\n      throw new Error(`invalid signature ${g}: out of range 1..Point.Fn.ORDER`);\n    return x;\n  }\n  function R(g, x) {\n    ec(x);\n    const w = f.signature, D = x === \"compact\" ? w : x === \"recovered\" ? w + 1 : void 0;\n    return Or(g, D, `${x} signature`);\n  }\n  class A {\n    constructor(x, w, D) {\n      this.r = b(\"r\", x), this.s = b(\"s\", w), D != null &amp;&amp; (this.recovery = D), Object.freeze(this);\n    }\n    static fromBytes(x, w = y) {\n      R(x, w);\n      let D;\n      if (w === \"der\") {\n        const { r: L, s: m } = cs.toSig(Or(x));\n        return new A(L, m);\n      }\n      w === \"recovered\" &amp;&amp; (D = x[0], w = \"compact\", x = x.subarray(1));\n      const O = o.BYTES, U = x.subarray(0, O), V = x.subarray(O, O * 2);\n      return new A(o.fromBytes(U), o.fromBytes(V), D);\n    }\n    static fromHex(x, w) {\n      return this.fromBytes(Po(x), w);\n    }\n    addRecoveryBit(x) {\n      return new A(this.r, this.s, x);\n    }\n    recoverPublicKey(x) {\n      const w = i.ORDER, { r: D, s: O, recovery: U } = this;\n      if (U == null || ![0, 1, 2, 3].includes(U))\n        throw new Error(\"recovery id invalid\");\n      if (a * D0 &lt; w &amp;&amp; U &gt; 1)\n        throw new Error(\"recovery id is ambiguous for h&gt;1 curve\");\n      const L = U === 2 || U === 3 ? D + a : D;\n      if (!i.isValid(L))\n        throw new Error(\"recovery id 2 or 3 invalid\");\n      const m = i.toBytes(L), v = s.fromBytes(Kr(P0((U &amp; 1) === 0), m)), P = o.inv(L), N = M(Et(\"msgHash\", x)), Y = o.create(-N * P), ee = o.create(O * P), ie = s.BASE.multiplyUnsafe(Y).add(v.multiplyUnsafe(ee));\n      if (ie.is0())\n        throw new Error(\"point at infinify\");\n      return ie.assertValidity(), ie;\n    }\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS() {\n      return E(this.s);\n    }\n    toBytes(x = y) {\n      if (ec(x), x === \"der\")\n        return Po(cs.hexFromSig(this));\n      const w = o.toBytes(this.r), D = o.toBytes(this.s);\n      if (x === \"recovered\") {\n        if (this.recovery == null)\n          throw new Error(\"recovery bit must be present\");\n        return Kr(Uint8Array.of(this.recovery), w, D);\n      }\n      return Kr(w, D);\n    }\n    toHex(x) {\n      return Hs(this.toBytes(x));\n    }\n    // TODO: remove\n    assertValidity() {\n    }\n    static fromCompact(x) {\n      return A.fromBytes(Et(\"sig\", x), \"compact\");\n    }\n    static fromDER(x) {\n      return A.fromBytes(Et(\"sig\", x), \"der\");\n    }\n    normalizeS() {\n      return this.hasHighS() ? new A(this.r, o.neg(this.s), this.recovery) : this;\n    }\n    toDERRawBytes() {\n      return this.toBytes(\"der\");\n    }\n    toDERHex() {\n      return Hs(this.toBytes(\"der\"));\n    }\n    toCompactRawBytes() {\n      return this.toBytes(\"compact\");\n    }\n    toCompactHex() {\n      return Hs(this.toBytes(\"compact\"));\n    }\n  }\n  const F = t.bits2int || function(x) {\n    if (x.length &gt; 8192)\n      throw new Error(\"input is too large\");\n    const w = la(x), D = x.length * 8 - l;\n    return D &gt; 0 ? w &gt;&gt; BigInt(D) : w;\n  }, M = t.bits2int_modN || function(x) {\n    return o.create(F(x));\n  }, H = _i(l);\n  function K(g) {\n    return Ql(\"num &lt; 2^\" + l, g, hs, H), o.toBytes(g);\n  }\n  function j(g, x) {\n    return Or(g, void 0, \"message\"), x ? Or(e(g), void 0, \"prehashed message\") : g;\n  }\n  function C(g, x, w) {\n    if ([\"recovered\", \"canonical\"].some((Y) =&gt; Y in w))\n      throw new Error(\"sign() legacy options not supported\");\n    const { lowS: D, prehash: O, extraEntropy: U } = al(w, p);\n    g = j(g, O);\n    const V = M(g), L = En(o, x), m = [K(L), K(V)];\n    if (U != null &amp;&amp; U !== !1) {\n      const Y = U === !0 ? r(f.secretKey) : U;\n      m.push(Et(\"extraEntropy\", Y));\n    }\n    const v = Kr(...m), P = V;\n    function N(Y) {\n      const ee = F(Y);\n      if (!o.isValidNot0(ee))\n        return;\n      const ie = o.inv(ee), le = s.BASE.multiply(ee).toAffine(), Te = o.create(le.x);\n      if (Te === hs)\n        return;\n      const De = o.create(ie * o.create(P + Te * L));\n      if (De === hs)\n        return;\n      let ze = (le.x === Te ? 0 : 2) | Number(le.y &amp; Tn), _e = De;\n      return D &amp;&amp; E(De) &amp;&amp; (_e = o.neg(De), ze ^= 1), new A(Te, _e, ze);\n    }\n    return { seed: v, k2sig: N };\n  }\n  function k(g, x, w = {}) {\n    g = Et(\"message\", g);\n    const { seed: D, k2sig: O } = C(g, x, w);\n    return ry(e.outputLen, o.BYTES, n)(D, O);\n  }\n  function $(g) {\n    let x;\n    const w = typeof g == \"string\" || Ii(g), D = !w &amp;&amp; g !== null &amp;&amp; typeof g == \"object\" &amp;&amp; typeof g.r == \"bigint\" &amp;&amp; typeof g.s == \"bigint\";\n    if (!w &amp;&amp; !D)\n      throw new Error(\"invalid signature, expected Uint8Array, hex string or Signature instance\");\n    if (D)\n      x = new A(g.r, g.s);\n    else if (w) {\n      try {\n        x = A.fromBytes(Et(\"sig\", g), \"der\");\n      } catch (O) {\n        if (!(O instanceof cs.Err))\n          throw O;\n      }\n      if (!x)\n        try {\n          x = A.fromBytes(Et(\"sig\", g), \"compact\");\n        } catch {\n          return !1;\n        }\n    }\n    return x || !1;\n  }\n  function W(g, x, w, D = {}) {\n    const { lowS: O, prehash: U, format: V } = al(D, p);\n    if (w = Et(\"publicKey\", w), x = j(Et(\"message\", x), U), \"strict\" in D)\n      throw new Error(\"options.strict was renamed to lowS\");\n    const L = V === void 0 ? $(g) : A.fromBytes(Et(\"sig\", g), V);\n    if (L === !1)\n      return !1;\n    try {\n      const m = s.fromBytes(w);\n      if (O &amp;&amp; L.hasHighS())\n        return !1;\n      const { r: v, s: P } = L, N = M(x), Y = o.inv(P), ee = o.create(N * Y), ie = o.create(v * Y), le = s.BASE.multiplyUnsafe(ee).add(m.multiplyUnsafe(ie));\n      return le.is0() ? !1 : o.create(le.x) === v;\n    } catch {\n      return !1;\n    }\n  }\n  function _(g, x, w = {}) {\n    const { prehash: D } = al(w, p);\n    return x = j(x, D), A.fromBytes(g, \"recovered\").recoverPublicKey(x).toBytes();\n  }\n  return Object.freeze({\n    keygen: c,\n    getPublicKey: u,\n    getSharedSecret: d,\n    utils: h,\n    lengths: f,\n    Point: s,\n    sign: k,\n    verify: W,\n    recoverPublicKey: _,\n    Signature: A,\n    hash: e\n  });\n}\nfunction Qv(s) {\n  const e = {\n    a: s.a,\n    b: s.b,\n    p: s.Fp.ORDER,\n    n: s.n,\n    h: s.h,\n    Gx: s.Gx,\n    Gy: s.Gy\n  }, t = s.Fp;\n  let r = s.allowedPrivateKeyLengths ? Array.from(new Set(s.allowedPrivateKeyLengths.map((o) =&gt; Math.ceil(o / 2)))) : void 0;\n  const n = en(e.n, {\n    BITS: s.nBitLength,\n    allowedLengths: r,\n    modFromBytes: s.wrapPrivateKey\n  }), i = {\n    Fp: t,\n    Fn: n,\n    allowInfinityPoint: s.allowInfinityPoint,\n    endo: s.endo,\n    isTorsionFree: s.isTorsionFree,\n    clearCofactor: s.clearCofactor,\n    fromBytes: s.fromBytes,\n    toBytes: s.toBytes\n  };\n  return { CURVE: e, curveOpts: i };\n}\nfunction eE(s) {\n  const { CURVE: e, curveOpts: t } = Qv(s), r = {\n    hmac: s.hmac,\n    randomBytes: s.randomBytes,\n    lowS: s.lowS,\n    bits2int: s.bits2int,\n    bits2int_modN: s.bits2int_modN\n  };\n  return { CURVE: e, curveOpts: t, hash: s.hash, ecdsaOpts: r };\n}\nfunction tE(s, e) {\n  const t = e.Point;\n  return Object.assign({}, e, {\n    ProjectivePoint: t,\n    CURVE: Object.assign({}, s, c0(t.Fn.ORDER, t.Fn.BITS))\n  });\n}\nfunction rE(s) {\n  const { CURVE: e, curveOpts: t, hash: r, ecdsaOpts: n } = eE(s), i = Zv(e, t), o = Jv(i, r, n);\n  return tE(s, o);\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nfunction sE(s, e) {\n  const t = (r) =&gt; rE({ ...s, hash: r });\n  return { ...t(e), create: t };\n}\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst tu = {\n  p: BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\"),\n  n: BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"),\n  h: BigInt(1),\n  a: BigInt(0),\n  b: BigInt(7),\n  Gx: BigInt(\"0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\"),\n  Gy: BigInt(\"0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\")\n}, nE = {\n  beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n  basises: [\n    [BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\"), -BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\")],\n    [BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\"), BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\")]\n  ]\n}, Bd = /* @__PURE__ */ BigInt(2);\nfunction iE(s) {\n  const e = tu.p, t = BigInt(3), r = BigInt(6), n = BigInt(11), i = BigInt(22), o = BigInt(23), a = BigInt(44), l = BigInt(88), c = s * s * s % e, u = c * c * s % e, d = vt(u, t, e) * u % e, h = vt(d, t, e) * u % e, f = vt(h, Bd, e) * c % e, p = vt(f, n, e) * f % e, y = vt(p, i, e) * p % e, E = vt(y, a, e) * y % e, b = vt(E, l, e) * E % e, R = vt(b, a, e) * y % e, A = vt(R, t, e) * u % e, F = vt(A, o, e) * p % e, M = vt(F, r, e) * c % e, H = vt(M, Bd, e);\n  if (!tc.eql(tc.sqr(H), s))\n    throw new Error(\"Cannot find square root\");\n  return H;\n}\nconst tc = en(tu.p, { sqrt: iE }), oE = sE({ ...tu, Fp: tc, lowS: !0, endo: nE }, Xf);\nLi.utils.randomPrivateKey;\nLi.getPublicKey;\nfunction Fd(s) {\n  try {\n    return Li.ExtendedPoint.fromHex(s), !0;\n  } catch {\n    return !1;\n  }\n}\nconst O0 = (s, e) =&gt; Li.sign(s, e.slice(0, 32)), aE = Li.verify, ru = (s) =&gt; He.Buffer.isBuffer(s) ? s : s instanceof Uint8Array ? He.Buffer.from(s.buffer, s.byteOffset, s.byteLength) : He.Buffer.from(s);\nclass lE {\n  constructor(e) {\n    Object.assign(this, e);\n  }\n  encode() {\n    return He.Buffer.from(Ja.serialize(uo, this));\n  }\n  static decode(e) {\n    return Ja.deserialize(uo, this, e);\n  }\n  static decodeUnchecked(e) {\n    return Ja.deserializeUnchecked(uo, this, e);\n  }\n}\nconst uo = /* @__PURE__ */ new Map();\nvar B0;\nconst cE = 32, ks = 32;\nfunction uE(s) {\n  return s._bn !== void 0;\n}\nlet Nd = 1;\nclass Oe extends lE {\n  /**\n   * Create a new PublicKey object\n   * @param value ed25519 public key as buffer or base-58 encoded string\n   */\n  constructor(e) {\n    if (super({}), this._bn = void 0, uE(e))\n      this._bn = e._bn;\n    else {\n      if (typeof e == \"string\") {\n        const t = ar.decode(e);\n        if (t.length != ks)\n          throw new Error(\"Invalid public key input\");\n        this._bn = new bd(t);\n      } else\n        this._bn = new bd(e);\n      if (this._bn.byteLength() &gt; ks)\n        throw new Error(\"Invalid public key input\");\n    }\n  }\n  /**\n   * Returns a unique PublicKey for tests and benchmarks using a counter\n   */\n  static unique() {\n    const e = new Oe(Nd);\n    return Nd += 1, new Oe(e.toBuffer());\n  }\n  /**\n   * Default public key value. The base58-encoded string representation is all ones (as seen below)\n   * The underlying BN number is 32 bytes that are all zeros\n   */\n  /**\n   * Checks if two publicKeys are equal\n   */\n  equals(e) {\n    return this._bn.eq(e._bn);\n  }\n  /**\n   * Return the base-58 representation of the public key\n   */\n  toBase58() {\n    return ar.encode(this.toBytes());\n  }\n  toJSON() {\n    return this.toBase58();\n  }\n  /**\n   * Return the byte array representation of the public key in big endian\n   */\n  toBytes() {\n    const e = this.toBuffer();\n    return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);\n  }\n  /**\n   * Return the Buffer representation of the public key in big endian\n   */\n  toBuffer() {\n    const e = this._bn.toArrayLike(He.Buffer);\n    if (e.length === ks)\n      return e;\n    const t = He.Buffer.alloc(32);\n    return e.copy(t, 32 - e.length), t;\n  }\n  get [Symbol.toStringTag]() {\n    return `PublicKey(${this.toString()})`;\n  }\n  /**\n   * Return the base-58 representation of the public key\n   */\n  toString() {\n    return this.toBase58();\n  }\n  /**\n   * Derive a public key from another key, a seed, and a program ID.\n   * The program ID will also serve as the owner of the public key, giving\n   * it permission to write data to the account.\n   */\n  /* eslint-disable require-await */\n  static async createWithSeed(e, t, r) {\n    const n = He.Buffer.concat([e.toBuffer(), He.Buffer.from(t), r.toBuffer()]), i = Id(n);\n    return new Oe(i);\n  }\n  /**\n   * Derive a program address from seeds and a program ID.\n   */\n  /* eslint-disable require-await */\n  static createProgramAddressSync(e, t) {\n    let r = He.Buffer.alloc(0);\n    e.forEach(function(i) {\n      if (i.length &gt; cE)\n        throw new TypeError(\"Max seed length exceeded\");\n      r = He.Buffer.concat([r, ru(i)]);\n    }), r = He.Buffer.concat([r, t.toBuffer(), He.Buffer.from(\"ProgramDerivedAddress\")]);\n    const n = Id(r);\n    if (Fd(n))\n      throw new Error(\"Invalid seeds, address must fall off the curve\");\n    return new Oe(n);\n  }\n  /**\n   * Async version of createProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link createProgramAddressSync} instead\n   */\n  /* eslint-disable require-await */\n  static async createProgramAddress(e, t) {\n    return this.createProgramAddressSync(e, t);\n  }\n  /**\n   * Find a valid program address\n   *\n   * Valid program addresses must fall off the ed25519 curve.  This function\n   * iterates a nonce until it finds one that when combined with the seeds\n   * results in a valid program address.\n   */\n  static findProgramAddressSync(e, t) {\n    let r = 255, n;\n    for (; r != 0; ) {\n      try {\n        const i = e.concat(He.Buffer.from([r]));\n        n = this.createProgramAddressSync(i, t);\n      } catch (i) {\n        if (i instanceof TypeError)\n          throw i;\n        r--;\n        continue;\n      }\n      return [n, r];\n    }\n    throw new Error(\"Unable to find a viable program address nonce\");\n  }\n  /**\n   * Async version of findProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link findProgramAddressSync} instead\n   */\n  static async findProgramAddress(e, t) {\n    return this.findProgramAddressSync(e, t);\n  }\n  /**\n   * Check that a pubkey is on the ed25519 curve.\n   */\n  static isOnCurve(e) {\n    const t = new Oe(e);\n    return Fd(t.toBytes());\n  }\n}\nB0 = Oe;\nOe.default = new B0(\"11111111111111111111111111111111\");\nuo.set(Oe, {\n  kind: \"struct\",\n  fields: [[\"_bn\", \"u256\"]]\n});\nnew Oe(\"BPFLoader1111111111111111111111111111111111\");\nconst wn = 1232, su = 127, Go = 64;\nclass Vo {\n  constructor(e, t) {\n    this.staticAccountKeys = void 0, this.accountKeysFromLookups = void 0, this.staticAccountKeys = e, this.accountKeysFromLookups = t;\n  }\n  keySegments() {\n    const e = [this.staticAccountKeys];\n    return this.accountKeysFromLookups &amp;&amp; (e.push(this.accountKeysFromLookups.writable), e.push(this.accountKeysFromLookups.readonly)), e;\n  }\n  get(e) {\n    for (const t of this.keySegments()) {\n      if (e &lt; t.length)\n        return t[e];\n      e -= t.length;\n    }\n  }\n  get length() {\n    return this.keySegments().flat().length;\n  }\n  compileInstructions(e) {\n    if (this.length &gt; 256)\n      throw new Error(\"Account index overflow encountered during compilation\");\n    const r = /* @__PURE__ */ new Map();\n    this.keySegments().flat().forEach((i, o) =&gt; {\n      r.set(i.toBase58(), o);\n    });\n    const n = (i) =&gt; {\n      const o = r.get(i.toBase58());\n      if (o === void 0) throw new Error(\"Encountered an unknown instruction account key during compilation\");\n      return o;\n    };\n    return e.map((i) =&gt; ({\n      programIdIndex: n(i.programId),\n      accountKeyIndexes: i.keys.map((o) =&gt; n(o.pubkey)),\n      data: i.data\n    }));\n  }\n}\nconst We = (s = \"publicKey\") =&gt; z.blob(32, s), dE = (s = \"signature\") =&gt; z.blob(64, s), xn = (s = \"string\") =&gt; {\n  const e = z.struct([z.u32(\"length\"), z.u32(\"lengthPadding\"), z.blob(z.offset(z.u32(), -8), \"chars\")], s), t = e.decode.bind(e), r = e.encode.bind(e), n = e;\n  return n.decode = (i, o) =&gt; t(i, o).chars.toString(), n.encode = (i, o, a) =&gt; {\n    const l = {\n      chars: He.Buffer.from(i, \"utf8\")\n    };\n    return r(l, o, a);\n  }, n.alloc = (i) =&gt; z.u32().span + z.u32().span + He.Buffer.from(i, \"utf8\").length, n;\n}, hE = (s = \"authorized\") =&gt; z.struct([We(\"staker\"), We(\"withdrawer\")], s), fE = (s = \"lockup\") =&gt; z.struct([z.ns64(\"unixTimestamp\"), z.ns64(\"epoch\"), We(\"custodian\")], s), gE = (s = \"voteInit\") =&gt; z.struct([We(\"nodePubkey\"), We(\"authorizedVoter\"), We(\"authorizedWithdrawer\"), z.u8(\"commission\")], s), pE = (s = \"voteAuthorizeWithSeedArgs\") =&gt; z.struct([z.u32(\"voteAuthorizationType\"), We(\"currentAuthorityDerivedKeyOwnerPubkey\"), xn(\"currentAuthorityDerivedKeySeed\"), We(\"newAuthorized\")], s);\nfunction Er(s) {\n  let e = 0, t = 0;\n  for (; ; ) {\n    let r = s.shift();\n    if (e |= (r &amp; 127) &lt;&lt; t * 7, t += 1, (r &amp; 128) === 0)\n      break;\n  }\n  return e;\n}\nfunction xr(s, e) {\n  let t = e;\n  for (; ; ) {\n    let r = t &amp; 127;\n    if (t &gt;&gt;= 7, t == 0) {\n      s.push(r);\n      break;\n    } else\n      r |= 128, s.push(r);\n  }\n}\nfunction Kt(s, e) {\n  if (!s)\n    throw new Error(e || \"Assertion failed\");\n}\nclass fa {\n  constructor(e, t) {\n    this.payer = void 0, this.keyMetaMap = void 0, this.payer = e, this.keyMetaMap = t;\n  }\n  static compile(e, t) {\n    const r = /* @__PURE__ */ new Map(), n = (o) =&gt; {\n      const a = o.toBase58();\n      let l = r.get(a);\n      return l === void 0 &amp;&amp; (l = {\n        isSigner: !1,\n        isWritable: !1,\n        isInvoked: !1\n      }, r.set(a, l)), l;\n    }, i = n(t);\n    i.isSigner = !0, i.isWritable = !0;\n    for (const o of e) {\n      n(o.programId).isInvoked = !0;\n      for (const a of o.keys) {\n        const l = n(a.pubkey);\n        l.isSigner || (l.isSigner = a.isSigner), l.isWritable || (l.isWritable = a.isWritable);\n      }\n    }\n    return new fa(t, r);\n  }\n  getMessageComponents() {\n    const e = [...this.keyMetaMap.entries()];\n    Kt(e.length &lt;= 256, \"Max static account keys length exceeded\");\n    const t = e.filter(([, l]) =&gt; l.isSigner &amp;&amp; l.isWritable), r = e.filter(([, l]) =&gt; l.isSigner &amp;&amp; !l.isWritable), n = e.filter(([, l]) =&gt; !l.isSigner &amp;&amp; l.isWritable), i = e.filter(([, l]) =&gt; !l.isSigner &amp;&amp; !l.isWritable), o = {\n      numRequiredSignatures: t.length + r.length,\n      numReadonlySignedAccounts: r.length,\n      numReadonlyUnsignedAccounts: i.length\n    };\n    {\n      Kt(t.length &gt; 0, \"Expected at least one writable signer key\");\n      const [l] = t[0];\n      Kt(l === this.payer.toBase58(), \"Expected first writable signer key to be the fee payer\");\n    }\n    const a = [...t.map(([l]) =&gt; new Oe(l)), ...r.map(([l]) =&gt; new Oe(l)), ...n.map(([l]) =&gt; new Oe(l)), ...i.map(([l]) =&gt; new Oe(l))];\n    return [o, a];\n  }\n  extractTableLookup(e) {\n    const [t, r] = this.drainKeysFoundInLookupTable(e.state.addresses, (o) =&gt; !o.isSigner &amp;&amp; !o.isInvoked &amp;&amp; o.isWritable), [n, i] = this.drainKeysFoundInLookupTable(e.state.addresses, (o) =&gt; !o.isSigner &amp;&amp; !o.isInvoked &amp;&amp; !o.isWritable);\n    if (!(t.length === 0 &amp;&amp; n.length === 0))\n      return [{\n        accountKey: e.key,\n        writableIndexes: t,\n        readonlyIndexes: n\n      }, {\n        writable: r,\n        readonly: i\n      }];\n  }\n  /** @internal */\n  drainKeysFoundInLookupTable(e, t) {\n    const r = new Array(), n = new Array();\n    for (const [i, o] of this.keyMetaMap.entries())\n      if (t(o)) {\n        const a = new Oe(i), l = e.findIndex((c) =&gt; c.equals(a));\n        l &gt;= 0 &amp;&amp; (Kt(l &lt; 256, \"Max lookup table index exceeded\"), r.push(l), n.push(a), this.keyMetaMap.delete(i));\n      }\n    return [r, n];\n  }\n}\nconst F0 = \"Reached end of buffer unexpectedly\";\nfunction ds(s) {\n  if (s.length === 0)\n    throw new Error(F0);\n  return s.shift();\n}\nfunction Sr(s, ...e) {\n  const [t] = e;\n  if (e.length === 2 ? t + (e[1] ?? 0) &gt; s.length : t &gt;= s.length)\n    throw new Error(F0);\n  return s.splice(...e);\n}\nclass Mn {\n  constructor(e) {\n    this.header = void 0, this.accountKeys = void 0, this.recentBlockhash = void 0, this.instructions = void 0, this.indexToProgramIds = /* @__PURE__ */ new Map(), this.header = e.header, this.accountKeys = e.accountKeys.map((t) =&gt; new Oe(t)), this.recentBlockhash = e.recentBlockhash, this.instructions = e.instructions, this.instructions.forEach((t) =&gt; this.indexToProgramIds.set(t.programIdIndex, this.accountKeys[t.programIdIndex]));\n  }\n  get version() {\n    return \"legacy\";\n  }\n  get staticAccountKeys() {\n    return this.accountKeys;\n  }\n  get compiledInstructions() {\n    return this.instructions.map((e) =&gt; ({\n      programIdIndex: e.programIdIndex,\n      accountKeyIndexes: e.accounts,\n      data: ar.decode(e.data)\n    }));\n  }\n  get addressTableLookups() {\n    return [];\n  }\n  getAccountKeys() {\n    return new Vo(this.staticAccountKeys);\n  }\n  static compile(e) {\n    const t = fa.compile(e.instructions, e.payerKey), [r, n] = t.getMessageComponents(), o = new Vo(n).compileInstructions(e.instructions).map((a) =&gt; ({\n      programIdIndex: a.programIdIndex,\n      accounts: a.accountKeyIndexes,\n      data: ar.encode(a.data)\n    }));\n    return new Mn({\n      header: r,\n      accountKeys: n,\n      recentBlockhash: e.recentBlockhash,\n      instructions: o\n    });\n  }\n  isAccountSigner(e) {\n    return e &lt; this.header.numRequiredSignatures;\n  }\n  isAccountWritable(e) {\n    const t = this.header.numRequiredSignatures;\n    if (e &gt;= this.header.numRequiredSignatures) {\n      const r = e - t, i = this.accountKeys.length - t - this.header.numReadonlyUnsignedAccounts;\n      return r &lt; i;\n    } else {\n      const r = t - this.header.numReadonlySignedAccounts;\n      return e &lt; r;\n    }\n  }\n  isProgramId(e) {\n    return this.indexToProgramIds.has(e);\n  }\n  programIds() {\n    return [...this.indexToProgramIds.values()];\n  }\n  nonProgramIds() {\n    return this.accountKeys.filter((e, t) =&gt; !this.isProgramId(t));\n  }\n  serialize() {\n    const e = this.accountKeys.length;\n    let t = [];\n    xr(t, e);\n    const r = this.instructions.map((d) =&gt; {\n      const {\n        accounts: h,\n        programIdIndex: f\n      } = d, p = Array.from(ar.decode(d.data));\n      let y = [];\n      xr(y, h.length);\n      let E = [];\n      return xr(E, p.length), {\n        programIdIndex: f,\n        keyIndicesCount: He.Buffer.from(y),\n        keyIndices: h,\n        dataLength: He.Buffer.from(E),\n        data: p\n      };\n    });\n    let n = [];\n    xr(n, r.length);\n    let i = He.Buffer.alloc(wn);\n    He.Buffer.from(n).copy(i);\n    let o = n.length;\n    r.forEach((d) =&gt; {\n      const f = z.struct([z.u8(\"programIdIndex\"), z.blob(d.keyIndicesCount.length, \"keyIndicesCount\"), z.seq(z.u8(\"keyIndex\"), d.keyIndices.length, \"keyIndices\"), z.blob(d.dataLength.length, \"dataLength\"), z.seq(z.u8(\"userdatum\"), d.data.length, \"data\")]).encode(d, i, o);\n      o += f;\n    }), i = i.slice(0, o);\n    const a = z.struct([z.blob(1, \"numRequiredSignatures\"), z.blob(1, \"numReadonlySignedAccounts\"), z.blob(1, \"numReadonlyUnsignedAccounts\"), z.blob(t.length, \"keyCount\"), z.seq(We(\"key\"), e, \"keys\"), We(\"recentBlockhash\")]), l = {\n      numRequiredSignatures: He.Buffer.from([this.header.numRequiredSignatures]),\n      numReadonlySignedAccounts: He.Buffer.from([this.header.numReadonlySignedAccounts]),\n      numReadonlyUnsignedAccounts: He.Buffer.from([this.header.numReadonlyUnsignedAccounts]),\n      keyCount: He.Buffer.from(t),\n      keys: this.accountKeys.map((d) =&gt; ru(d.toBytes())),\n      recentBlockhash: ar.decode(this.recentBlockhash)\n    };\n    let c = He.Buffer.alloc(2048);\n    const u = a.encode(l, c);\n    return i.copy(c, u), c.slice(0, u + i.length);\n  }\n  /**\n   * Decode a compiled message into a Message object.\n   */\n  static from(e) {\n    let t = [...e];\n    const r = ds(t);\n    if (r !== (r &amp; su))\n      throw new Error(\"Versioned messages must be deserialized with VersionedMessage.deserialize()\");\n    const n = ds(t), i = ds(t), o = Er(t);\n    let a = [];\n    for (let h = 0; h &lt; o; h++) {\n      const f = Sr(t, 0, ks);\n      a.push(new Oe(He.Buffer.from(f)));\n    }\n    const l = Sr(t, 0, ks), c = Er(t);\n    let u = [];\n    for (let h = 0; h &lt; c; h++) {\n      const f = ds(t), p = Er(t), y = Sr(t, 0, p), E = Er(t), b = Sr(t, 0, E), R = ar.encode(He.Buffer.from(b));\n      u.push({\n        programIdIndex: f,\n        accounts: y,\n        data: R\n      });\n    }\n    const d = {\n      header: {\n        numRequiredSignatures: r,\n        numReadonlySignedAccounts: n,\n        numReadonlyUnsignedAccounts: i\n      },\n      recentBlockhash: ar.encode(He.Buffer.from(l)),\n      accountKeys: a,\n      instructions: u\n    };\n    return new Mn(d);\n  }\n}\nclass jo {\n  constructor(e) {\n    this.header = void 0, this.staticAccountKeys = void 0, this.recentBlockhash = void 0, this.compiledInstructions = void 0, this.addressTableLookups = void 0, this.header = e.header, this.staticAccountKeys = e.staticAccountKeys, this.recentBlockhash = e.recentBlockhash, this.compiledInstructions = e.compiledInstructions, this.addressTableLookups = e.addressTableLookups;\n  }\n  get version() {\n    return 0;\n  }\n  get numAccountKeysFromLookups() {\n    let e = 0;\n    for (const t of this.addressTableLookups)\n      e += t.readonlyIndexes.length + t.writableIndexes.length;\n    return e;\n  }\n  getAccountKeys(e) {\n    let t;\n    if (e &amp;&amp; \"accountKeysFromLookups\" in e &amp;&amp; e.accountKeysFromLookups) {\n      if (this.numAccountKeysFromLookups != e.accountKeysFromLookups.writable.length + e.accountKeysFromLookups.readonly.length)\n        throw new Error(\"Failed to get account keys because of a mismatch in the number of account keys from lookups\");\n      t = e.accountKeysFromLookups;\n    } else if (e &amp;&amp; \"addressLookupTableAccounts\" in e &amp;&amp; e.addressLookupTableAccounts)\n      t = this.resolveAddressTableLookups(e.addressLookupTableAccounts);\n    else if (this.addressTableLookups.length &gt; 0)\n      throw new Error(\"Failed to get account keys because address table lookups were not resolved\");\n    return new Vo(this.staticAccountKeys, t);\n  }\n  isAccountSigner(e) {\n    return e &lt; this.header.numRequiredSignatures;\n  }\n  isAccountWritable(e) {\n    const t = this.header.numRequiredSignatures, r = this.staticAccountKeys.length;\n    if (e &gt;= r) {\n      const n = e - r, i = this.addressTableLookups.reduce((o, a) =&gt; o + a.writableIndexes.length, 0);\n      return n &lt; i;\n    } else if (e &gt;= this.header.numRequiredSignatures) {\n      const n = e - t, o = r - t - this.header.numReadonlyUnsignedAccounts;\n      return n &lt; o;\n    } else {\n      const n = t - this.header.numReadonlySignedAccounts;\n      return e &lt; n;\n    }\n  }\n  resolveAddressTableLookups(e) {\n    const t = {\n      writable: [],\n      readonly: []\n    };\n    for (const r of this.addressTableLookups) {\n      const n = e.find((i) =&gt; i.key.equals(r.accountKey));\n      if (!n)\n        throw new Error(`Failed to find address lookup table account for table key ${r.accountKey.toBase58()}`);\n      for (const i of r.writableIndexes)\n        if (i &lt; n.state.addresses.length)\n          t.writable.push(n.state.addresses[i]);\n        else\n          throw new Error(`Failed to find address for index ${i} in address lookup table ${r.accountKey.toBase58()}`);\n      for (const i of r.readonlyIndexes)\n        if (i &lt; n.state.addresses.length)\n          t.readonly.push(n.state.addresses[i]);\n        else\n          throw new Error(`Failed to find address for index ${i} in address lookup table ${r.accountKey.toBase58()}`);\n    }\n    return t;\n  }\n  static compile(e) {\n    const t = fa.compile(e.instructions, e.payerKey), r = new Array(), n = {\n      writable: new Array(),\n      readonly: new Array()\n    }, i = e.addressLookupTableAccounts || [];\n    for (const u of i) {\n      const d = t.extractTableLookup(u);\n      if (d !== void 0) {\n        const [h, {\n          writable: f,\n          readonly: p\n        }] = d;\n        r.push(h), n.writable.push(...f), n.readonly.push(...p);\n      }\n    }\n    const [o, a] = t.getMessageComponents(), c = new Vo(a, n).compileInstructions(e.instructions);\n    return new jo({\n      header: o,\n      staticAccountKeys: a,\n      recentBlockhash: e.recentBlockhash,\n      compiledInstructions: c,\n      addressTableLookups: r\n    });\n  }\n  serialize() {\n    const e = Array();\n    xr(e, this.staticAccountKeys.length);\n    const t = this.serializeInstructions(), r = Array();\n    xr(r, this.compiledInstructions.length);\n    const n = this.serializeAddressTableLookups(), i = Array();\n    xr(i, this.addressTableLookups.length);\n    const o = z.struct([z.u8(\"prefix\"), z.struct([z.u8(\"numRequiredSignatures\"), z.u8(\"numReadonlySignedAccounts\"), z.u8(\"numReadonlyUnsignedAccounts\")], \"header\"), z.blob(e.length, \"staticAccountKeysLength\"), z.seq(We(), this.staticAccountKeys.length, \"staticAccountKeys\"), We(\"recentBlockhash\"), z.blob(r.length, \"instructionsLength\"), z.blob(t.length, \"serializedInstructions\"), z.blob(i.length, \"addressTableLookupsLength\"), z.blob(n.length, \"serializedAddressTableLookups\")]), a = new Uint8Array(wn), c = o.encode({\n      prefix: 128,\n      header: this.header,\n      staticAccountKeysLength: new Uint8Array(e),\n      staticAccountKeys: this.staticAccountKeys.map((u) =&gt; u.toBytes()),\n      recentBlockhash: ar.decode(this.recentBlockhash),\n      instructionsLength: new Uint8Array(r),\n      serializedInstructions: t,\n      addressTableLookupsLength: new Uint8Array(i),\n      serializedAddressTableLookups: n\n    }, a);\n    return a.slice(0, c);\n  }\n  serializeInstructions() {\n    let e = 0;\n    const t = new Uint8Array(wn);\n    for (const r of this.compiledInstructions) {\n      const n = Array();\n      xr(n, r.accountKeyIndexes.length);\n      const i = Array();\n      xr(i, r.data.length);\n      const o = z.struct([z.u8(\"programIdIndex\"), z.blob(n.length, \"encodedAccountKeyIndexesLength\"), z.seq(z.u8(), r.accountKeyIndexes.length, \"accountKeyIndexes\"), z.blob(i.length, \"encodedDataLength\"), z.blob(r.data.length, \"data\")]);\n      e += o.encode({\n        programIdIndex: r.programIdIndex,\n        encodedAccountKeyIndexesLength: new Uint8Array(n),\n        accountKeyIndexes: r.accountKeyIndexes,\n        encodedDataLength: new Uint8Array(i),\n        data: r.data\n      }, t, e);\n    }\n    return t.slice(0, e);\n  }\n  serializeAddressTableLookups() {\n    let e = 0;\n    const t = new Uint8Array(wn);\n    for (const r of this.addressTableLookups) {\n      const n = Array();\n      xr(n, r.writableIndexes.length);\n      const i = Array();\n      xr(i, r.readonlyIndexes.length);\n      const o = z.struct([We(\"accountKey\"), z.blob(n.length, \"encodedWritableIndexesLength\"), z.seq(z.u8(), r.writableIndexes.length, \"writableIndexes\"), z.blob(i.length, \"encodedReadonlyIndexesLength\"), z.seq(z.u8(), r.readonlyIndexes.length, \"readonlyIndexes\")]);\n      e += o.encode({\n        accountKey: r.accountKey.toBytes(),\n        encodedWritableIndexesLength: new Uint8Array(n),\n        writableIndexes: r.writableIndexes,\n        encodedReadonlyIndexesLength: new Uint8Array(i),\n        readonlyIndexes: r.readonlyIndexes\n      }, t, e);\n    }\n    return t.slice(0, e);\n  }\n  static deserialize(e) {\n    let t = [...e];\n    const r = ds(t), n = r &amp; su;\n    Kt(r !== n, \"Expected versioned message but received legacy message\");\n    const i = n;\n    Kt(i === 0, `Expected versioned message with version 0 but found version ${i}`);\n    const o = {\n      numRequiredSignatures: ds(t),\n      numReadonlySignedAccounts: ds(t),\n      numReadonlyUnsignedAccounts: ds(t)\n    }, a = [], l = Er(t);\n    for (let p = 0; p &lt; l; p++)\n      a.push(new Oe(Sr(t, 0, ks)));\n    const c = ar.encode(Sr(t, 0, ks)), u = Er(t), d = [];\n    for (let p = 0; p &lt; u; p++) {\n      const y = ds(t), E = Er(t), b = Sr(t, 0, E), R = Er(t), A = new Uint8Array(Sr(t, 0, R));\n      d.push({\n        programIdIndex: y,\n        accountKeyIndexes: b,\n        data: A\n      });\n    }\n    const h = Er(t), f = [];\n    for (let p = 0; p &lt; h; p++) {\n      const y = new Oe(Sr(t, 0, ks)), E = Er(t), b = Sr(t, 0, E), R = Er(t), A = Sr(t, 0, R);\n      f.push({\n        accountKey: y,\n        writableIndexes: b,\n        readonlyIndexes: A\n      });\n    }\n    return new jo({\n      header: o,\n      staticAccountKeys: a,\n      recentBlockhash: c,\n      compiledInstructions: d,\n      addressTableLookups: f\n    });\n  }\n}\nconst nu = {\n  deserializeMessageVersion(s) {\n    const e = s[0], t = e &amp; su;\n    return t === e ? \"legacy\" : t;\n  },\n  deserialize: (s) =&gt; {\n    const e = nu.deserializeMessageVersion(s);\n    if (e === \"legacy\")\n      return Mn.from(s);\n    if (e === 0)\n      return jo.deserialize(s);\n    throw new Error(`Transaction message version ${e} deserialization is not supported`);\n  }\n}, mE = He.Buffer.alloc(Go).fill(0);\nclass Ud {\n  constructor(e) {\n    this.keys = void 0, this.programId = void 0, this.data = He.Buffer.alloc(0), this.programId = e.programId, this.keys = e.keys, e.data &amp;&amp; (this.data = e.data);\n  }\n  /**\n   * @internal\n   */\n  toJSON() {\n    return {\n      keys: this.keys.map(({\n        pubkey: e,\n        isSigner: t,\n        isWritable: r\n      }) =&gt; ({\n        pubkey: e.toJSON(),\n        isSigner: t,\n        isWritable: r\n      })),\n      programId: this.programId.toJSON(),\n      data: [...this.data]\n    };\n  }\n}\nclass Ko {\n  /**\n   * The first (payer) Transaction signature\n   *\n   * @returns {Buffer | null} Buffer of payer's signature\n   */\n  get signature() {\n    return this.signatures.length &gt; 0 ? this.signatures[0].signature : null;\n  }\n  /**\n   * The transaction fee payer\n   */\n  // Construct a transaction with a blockhash and lastValidBlockHeight\n  // Construct a transaction using a durable nonce\n  /**\n   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.\n   * Please supply a `TransactionBlockhashCtor` instead.\n   */\n  /**\n   * Construct an empty Transaction\n   */\n  constructor(e) {\n    if (this.signatures = [], this.feePayer = void 0, this.instructions = [], this.recentBlockhash = void 0, this.lastValidBlockHeight = void 0, this.nonceInfo = void 0, this.minNonceContextSlot = void 0, this._message = void 0, this._json = void 0, !!e)\n      if (e.feePayer &amp;&amp; (this.feePayer = e.feePayer), e.signatures &amp;&amp; (this.signatures = e.signatures), Object.prototype.hasOwnProperty.call(e, \"nonceInfo\")) {\n        const {\n          minContextSlot: t,\n          nonceInfo: r\n        } = e;\n        this.minNonceContextSlot = t, this.nonceInfo = r;\n      } else if (Object.prototype.hasOwnProperty.call(e, \"lastValidBlockHeight\")) {\n        const {\n          blockhash: t,\n          lastValidBlockHeight: r\n        } = e;\n        this.recentBlockhash = t, this.lastValidBlockHeight = r;\n      } else {\n        const {\n          recentBlockhash: t,\n          nonceInfo: r\n        } = e;\n        r &amp;&amp; (this.nonceInfo = r), this.recentBlockhash = t;\n      }\n  }\n  /**\n   * @internal\n   */\n  toJSON() {\n    return {\n      recentBlockhash: this.recentBlockhash || null,\n      feePayer: this.feePayer ? this.feePayer.toJSON() : null,\n      nonceInfo: this.nonceInfo ? {\n        nonce: this.nonceInfo.nonce,\n        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()\n      } : null,\n      instructions: this.instructions.map((e) =&gt; e.toJSON()),\n      signers: this.signatures.map(({\n        publicKey: e\n      }) =&gt; e.toJSON())\n    };\n  }\n  /**\n   * Add one or more instructions to this Transaction\n   *\n   * @param {Array&lt; Transaction | TransactionInstruction | TransactionInstructionCtorFields &gt;} items - Instructions to add to the Transaction\n   */\n  add(...e) {\n    if (e.length === 0)\n      throw new Error(\"No instructions\");\n    return e.forEach((t) =&gt; {\n      \"instructions\" in t ? this.instructions = this.instructions.concat(t.instructions) : \"data\" in t &amp;&amp; \"programId\" in t &amp;&amp; \"keys\" in t ? this.instructions.push(t) : this.instructions.push(new Ud(t));\n    }), this;\n  }\n  /**\n   * Compile transaction data\n   */\n  compileMessage() {\n    if (this._message &amp;&amp; JSON.stringify(this.toJSON()) === JSON.stringify(this._json))\n      return this._message;\n    let e, t;\n    if (this.nonceInfo ? (e = this.nonceInfo.nonce, this.instructions[0] != this.nonceInfo.nonceInstruction ? t = [this.nonceInfo.nonceInstruction, ...this.instructions] : t = this.instructions) : (e = this.recentBlockhash, t = this.instructions), !e)\n      throw new Error(\"Transaction recentBlockhash required\");\n    t.length &lt; 1 &amp;&amp; console.warn(\"No instructions provided\");\n    let r;\n    if (this.feePayer)\n      r = this.feePayer;\n    else if (this.signatures.length &gt; 0 &amp;&amp; this.signatures[0].publicKey)\n      r = this.signatures[0].publicKey;\n    else\n      throw new Error(\"Transaction fee payer required\");\n    for (let y = 0; y &lt; t.length; y++)\n      if (t[y].programId === void 0)\n        throw new Error(`Transaction instruction index ${y} has undefined program id`);\n    const n = [], i = [];\n    t.forEach((y) =&gt; {\n      y.keys.forEach((b) =&gt; {\n        i.push({\n          ...b\n        });\n      });\n      const E = y.programId.toString();\n      n.includes(E) || n.push(E);\n    }), n.forEach((y) =&gt; {\n      i.push({\n        pubkey: new Oe(y),\n        isSigner: !1,\n        isWritable: !1\n      });\n    });\n    const o = [];\n    i.forEach((y) =&gt; {\n      const E = y.pubkey.toString(), b = o.findIndex((R) =&gt; R.pubkey.toString() === E);\n      b &gt; -1 ? (o[b].isWritable = o[b].isWritable || y.isWritable, o[b].isSigner = o[b].isSigner || y.isSigner) : o.push(y);\n    }), o.sort(function(y, E) {\n      if (y.isSigner !== E.isSigner)\n        return y.isSigner ? -1 : 1;\n      if (y.isWritable !== E.isWritable)\n        return y.isWritable ? -1 : 1;\n      const b = {\n        localeMatcher: \"best fit\",\n        usage: \"sort\",\n        sensitivity: \"variant\",\n        ignorePunctuation: !1,\n        numeric: !1,\n        caseFirst: \"lower\"\n      };\n      return y.pubkey.toBase58().localeCompare(E.pubkey.toBase58(), \"en\", b);\n    });\n    const a = o.findIndex((y) =&gt; y.pubkey.equals(r));\n    if (a &gt; -1) {\n      const [y] = o.splice(a, 1);\n      y.isSigner = !0, y.isWritable = !0, o.unshift(y);\n    } else\n      o.unshift({\n        pubkey: r,\n        isSigner: !0,\n        isWritable: !0\n      });\n    for (const y of this.signatures) {\n      const E = o.findIndex((b) =&gt; b.pubkey.equals(y.publicKey));\n      if (E &gt; -1)\n        o[E].isSigner || (o[E].isSigner = !0, console.warn(\"Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.\"));\n      else\n        throw new Error(`unknown signer: ${y.publicKey.toString()}`);\n    }\n    let l = 0, c = 0, u = 0;\n    const d = [], h = [];\n    o.forEach(({\n      pubkey: y,\n      isSigner: E,\n      isWritable: b\n    }) =&gt; {\n      E ? (d.push(y.toString()), l += 1, b || (c += 1)) : (h.push(y.toString()), b || (u += 1));\n    });\n    const f = d.concat(h), p = t.map((y) =&gt; {\n      const {\n        data: E,\n        programId: b\n      } = y;\n      return {\n        programIdIndex: f.indexOf(b.toString()),\n        accounts: y.keys.map((R) =&gt; f.indexOf(R.pubkey.toString())),\n        data: ar.encode(E)\n      };\n    });\n    return p.forEach((y) =&gt; {\n      Kt(y.programIdIndex &gt;= 0), y.accounts.forEach((E) =&gt; Kt(E &gt;= 0));\n    }), new Mn({\n      header: {\n        numRequiredSignatures: l,\n        numReadonlySignedAccounts: c,\n        numReadonlyUnsignedAccounts: u\n      },\n      accountKeys: f,\n      recentBlockhash: e,\n      instructions: p\n    });\n  }\n  /**\n   * @internal\n   */\n  _compile() {\n    const e = this.compileMessage(), t = e.accountKeys.slice(0, e.header.numRequiredSignatures);\n    return this.signatures.length === t.length &amp;&amp; this.signatures.every((n, i) =&gt; t[i].equals(n.publicKey)) || (this.signatures = t.map((r) =&gt; ({\n      signature: null,\n      publicKey: r\n    }))), e;\n  }\n  /**\n   * Get a buffer of the Transaction data that need to be covered by signatures\n   */\n  serializeMessage() {\n    return this._compile().serialize();\n  }\n  /**\n   * Get the estimated fee associated with a transaction\n   *\n   * @param {Connection} connection Connection to RPC Endpoint.\n   *\n   * @returns {Promise&lt;number | null&gt;} The estimated fee for the transaction\n   */\n  async getEstimatedFee(e) {\n    return (await e.getFeeForMessage(this.compileMessage())).value;\n  }\n  /**\n   * Specify the public keys which will be used to sign the Transaction.\n   * The first signer will be used as the transaction fee payer account.\n   *\n   * Signatures can be added with either `partialSign` or `addSignature`\n   *\n   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be\n   * specified and it can be set in the Transaction constructor or with the\n   * `feePayer` property.\n   */\n  setSigners(...e) {\n    if (e.length === 0)\n      throw new Error(\"No signers\");\n    const t = /* @__PURE__ */ new Set();\n    this.signatures = e.filter((r) =&gt; {\n      const n = r.toString();\n      return t.has(n) ? !1 : (t.add(n), !0);\n    }).map((r) =&gt; ({\n      signature: null,\n      publicKey: r\n    }));\n  }\n  /**\n   * Sign the Transaction with the specified signers. Multiple signatures may\n   * be applied to a Transaction. The first signature is considered \"primary\"\n   * and is used identify and confirm transactions.\n   *\n   * If the Transaction `feePayer` is not set, the first signer will be used\n   * as the transaction fee payer account.\n   *\n   * Transaction fields should not be modified after the first call to `sign`,\n   * as doing so may invalidate the signature and cause the Transaction to be\n   * rejected.\n   *\n   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n   *\n   * @param {Array&lt;Signer&gt;} signers Array of signers that will sign the transaction\n   */\n  sign(...e) {\n    if (e.length === 0)\n      throw new Error(\"No signers\");\n    const t = /* @__PURE__ */ new Set(), r = [];\n    for (const i of e) {\n      const o = i.publicKey.toString();\n      t.has(o) || (t.add(o), r.push(i));\n    }\n    this.signatures = r.map((i) =&gt; ({\n      signature: null,\n      publicKey: i.publicKey\n    }));\n    const n = this._compile();\n    this._partialSign(n, ...r);\n  }\n  /**\n   * Partially sign a transaction with the specified accounts. All accounts must\n   * correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * All the caveats from the `sign` method apply to `partialSign`\n   *\n   * @param {Array&lt;Signer&gt;} signers Array of signers that will sign the transaction\n   */\n  partialSign(...e) {\n    if (e.length === 0)\n      throw new Error(\"No signers\");\n    const t = /* @__PURE__ */ new Set(), r = [];\n    for (const i of e) {\n      const o = i.publicKey.toString();\n      t.has(o) || (t.add(o), r.push(i));\n    }\n    const n = this._compile();\n    this._partialSign(n, ...r);\n  }\n  /**\n   * @internal\n   */\n  _partialSign(e, ...t) {\n    const r = e.serialize();\n    t.forEach((n) =&gt; {\n      const i = O0(r, n.secretKey);\n      this._addSignature(n.publicKey, ru(i));\n    });\n  }\n  /**\n   * Add an externally created signature to a transaction. The public key\n   * must correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * @param {PublicKey} pubkey Public key that will be added to the transaction.\n   * @param {Buffer} signature An externally created signature to add to the transaction.\n   */\n  addSignature(e, t) {\n    this._compile(), this._addSignature(e, t);\n  }\n  /**\n   * @internal\n   */\n  _addSignature(e, t) {\n    Kt(t.length === 64);\n    const r = this.signatures.findIndex((n) =&gt; e.equals(n.publicKey));\n    if (r &lt; 0)\n      throw new Error(`unknown signer: ${e.toString()}`);\n    this.signatures[r].signature = He.Buffer.from(t);\n  }\n  /**\n   * Verify signatures of a Transaction\n   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.\n   * If no boolean is provided, we expect a fully signed Transaction by default.\n   *\n   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction\n   */\n  verifySignatures(e = !0) {\n    return !this._getMessageSignednessErrors(this.serializeMessage(), e);\n  }\n  /**\n   * @internal\n   */\n  _getMessageSignednessErrors(e, t) {\n    const r = {};\n    for (const {\n      signature: n,\n      publicKey: i\n    } of this.signatures)\n      n === null ? t &amp;&amp; (r.missing || (r.missing = [])).push(i) : aE(n, e, i.toBytes()) || (r.invalid || (r.invalid = [])).push(i);\n    return r.invalid || r.missing ? r : void 0;\n  }\n  /**\n   * Serialize the Transaction in the wire format.\n   *\n   * @param {Buffer} [config] Config of transaction.\n   *\n   * @returns {Buffer} Signature of transaction in wire format.\n   */\n  serialize(e) {\n    const {\n      requireAllSignatures: t,\n      verifySignatures: r\n    } = Object.assign({\n      requireAllSignatures: !0,\n      verifySignatures: !0\n    }, e), n = this.serializeMessage();\n    if (r) {\n      const i = this._getMessageSignednessErrors(n, t);\n      if (i) {\n        let o = \"Signature verification failed.\";\n        throw i.invalid &amp;&amp; (o += `\nInvalid signature for public key${i.invalid.length === 1 ? \"\" : \"(s)\"} [\\`${i.invalid.map((a) =&gt; a.toBase58()).join(\"`, `\")}\\`].`), i.missing &amp;&amp; (o += `\nMissing signature for public key${i.missing.length === 1 ? \"\" : \"(s)\"} [\\`${i.missing.map((a) =&gt; a.toBase58()).join(\"`, `\")}\\`].`), new Error(o);\n      }\n    }\n    return this._serialize(n);\n  }\n  /**\n   * @internal\n   */\n  _serialize(e) {\n    const {\n      signatures: t\n    } = this, r = [];\n    xr(r, t.length);\n    const n = r.length + t.length * 64 + e.length, i = He.Buffer.alloc(n);\n    return Kt(t.length &lt; 256), He.Buffer.from(r).copy(i, 0), t.forEach(({\n      signature: o\n    }, a) =&gt; {\n      o !== null &amp;&amp; (Kt(o.length === 64, \"signature has invalid length\"), He.Buffer.from(o).copy(i, r.length + a * 64));\n    }), e.copy(i, r.length + t.length * 64), Kt(i.length &lt;= wn, `Transaction too large: ${i.length} &gt; ${wn}`), i;\n  }\n  /**\n   * Deprecated method\n   * @internal\n   */\n  get keys() {\n    return Kt(this.instructions.length === 1), this.instructions[0].keys.map((e) =&gt; e.pubkey);\n  }\n  /**\n   * Deprecated method\n   * @internal\n   */\n  get programId() {\n    return Kt(this.instructions.length === 1), this.instructions[0].programId;\n  }\n  /**\n   * Deprecated method\n   * @internal\n   */\n  get data() {\n    return Kt(this.instructions.length === 1), this.instructions[0].data;\n  }\n  /**\n   * Parse a wire transaction into a Transaction object.\n   *\n   * @param {Buffer | Uint8Array | Array&lt;number&gt;} buffer Signature of wire Transaction\n   *\n   * @returns {Transaction} Transaction associated with the signature\n   */\n  static from(e) {\n    let t = [...e];\n    const r = Er(t);\n    let n = [];\n    for (let i = 0; i &lt; r; i++) {\n      const o = Sr(t, 0, Go);\n      n.push(ar.encode(He.Buffer.from(o)));\n    }\n    return Ko.populate(Mn.from(t), n);\n  }\n  /**\n   * Populate Transaction object from message and signatures\n   *\n   * @param {Message} message Message of transaction\n   * @param {Array&lt;string&gt;} signatures List of signatures to assign to the transaction\n   *\n   * @returns {Transaction} The populated Transaction\n   */\n  static populate(e, t = []) {\n    const r = new Ko();\n    return r.recentBlockhash = e.recentBlockhash, e.header.numRequiredSignatures &gt; 0 &amp;&amp; (r.feePayer = e.accountKeys[0]), t.forEach((n, i) =&gt; {\n      const o = {\n        signature: n == ar.encode(mE) ? null : ar.decode(n),\n        publicKey: e.accountKeys[i]\n      };\n      r.signatures.push(o);\n    }), e.instructions.forEach((n) =&gt; {\n      const i = n.accounts.map((o) =&gt; {\n        const a = e.accountKeys[o];\n        return {\n          pubkey: a,\n          isSigner: r.signatures.some((l) =&gt; l.publicKey.toString() === a.toString()) || e.isAccountSigner(o),\n          isWritable: e.isAccountWritable(o)\n        };\n      });\n      r.instructions.push(new Ud({\n        keys: i,\n        programId: e.accountKeys[n.programIdIndex],\n        data: ar.decode(n.data)\n      }));\n    }), r._message = e, r._json = r.toJSON(), r;\n  }\n}\nclass iu {\n  get version() {\n    return this.message.version;\n  }\n  constructor(e, t) {\n    if (this.signatures = void 0, this.message = void 0, t !== void 0)\n      Kt(t.length === e.header.numRequiredSignatures, \"Expected signatures length to be equal to the number of required signatures\"), this.signatures = t;\n    else {\n      const r = [];\n      for (let n = 0; n &lt; e.header.numRequiredSignatures; n++)\n        r.push(new Uint8Array(Go));\n      this.signatures = r;\n    }\n    this.message = e;\n  }\n  serialize() {\n    const e = this.message.serialize(), t = Array();\n    xr(t, this.signatures.length);\n    const r = z.struct([z.blob(t.length, \"encodedSignaturesLength\"), z.seq(dE(), this.signatures.length, \"signatures\"), z.blob(e.length, \"serializedMessage\")]), n = new Uint8Array(2048), i = r.encode({\n      encodedSignaturesLength: new Uint8Array(t),\n      signatures: this.signatures,\n      serializedMessage: e\n    }, n);\n    return n.slice(0, i);\n  }\n  static deserialize(e) {\n    let t = [...e];\n    const r = [], n = Er(t);\n    for (let o = 0; o &lt; n; o++)\n      r.push(new Uint8Array(Sr(t, 0, Go)));\n    const i = nu.deserialize(new Uint8Array(t));\n    return new iu(i, r);\n  }\n  sign(e) {\n    const t = this.message.serialize(), r = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n    for (const n of e) {\n      const i = r.findIndex((o) =&gt; o.equals(n.publicKey));\n      Kt(i &gt;= 0, `Cannot sign with non signer key ${n.publicKey.toBase58()}`), this.signatures[i] = O0(t, n.secretKey);\n    }\n  }\n  addSignature(e, t) {\n    Kt(t.byteLength === 64, \"Signature must be 64 bytes long\");\n    const n = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures).findIndex((i) =&gt; i.equals(e));\n    Kt(n &gt;= 0, `Can not add signature; \\`${e.toBase58()}\\` is not required to sign this transaction`), this.signatures[n] = t;\n  }\n}\nnew Oe(\"SysvarC1ock11111111111111111111111111111111\");\nnew Oe(\"SysvarEpochSchedu1e111111111111111111111111\");\nnew Oe(\"Sysvar1nstructions1111111111111111111111111\");\nnew Oe(\"SysvarRecentB1ockHashes11111111111111111111\");\nnew Oe(\"SysvarRent111111111111111111111111111111111\");\nnew Oe(\"SysvarRewards111111111111111111111111111111\");\nnew Oe(\"SysvarS1otHashes111111111111111111111111111\");\nnew Oe(\"SysvarS1otHistory11111111111111111111111111\");\nnew Oe(\"SysvarStakeHistory1111111111111111111111111\");\nconst yE = z.nu64(\"lamportsPerSignature\"), vE = z.struct([z.u32(\"version\"), z.u32(\"state\"), We(\"authorizedPubkey\"), We(\"nonce\"), z.struct([yE], \"feeCalculator\")]);\nvE.span;\nfunction On(s) {\n  const e = z.blob(8, s), t = e.decode.bind(e), r = e.encode.bind(e), n = e, i = pv();\n  return n.decode = (o, a) =&gt; {\n    const l = t(o, a);\n    return i.decode(l);\n  }, n.encode = (o, a, l) =&gt; {\n    const c = i.encode(o);\n    return r(c, a, l);\n  }, n;\n}\nObject.freeze({\n  Create: {\n    index: 0,\n    layout: z.struct([z.u32(\"instruction\"), z.ns64(\"lamports\"), z.ns64(\"space\"), We(\"programId\")])\n  },\n  Assign: {\n    index: 1,\n    layout: z.struct([z.u32(\"instruction\"), We(\"programId\")])\n  },\n  Transfer: {\n    index: 2,\n    layout: z.struct([z.u32(\"instruction\"), On(\"lamports\")])\n  },\n  CreateWithSeed: {\n    index: 3,\n    layout: z.struct([z.u32(\"instruction\"), We(\"base\"), xn(\"seed\"), z.ns64(\"lamports\"), z.ns64(\"space\"), We(\"programId\")])\n  },\n  AdvanceNonceAccount: {\n    index: 4,\n    layout: z.struct([z.u32(\"instruction\")])\n  },\n  WithdrawNonceAccount: {\n    index: 5,\n    layout: z.struct([z.u32(\"instruction\"), z.ns64(\"lamports\")])\n  },\n  InitializeNonceAccount: {\n    index: 6,\n    layout: z.struct([z.u32(\"instruction\"), We(\"authorized\")])\n  },\n  AuthorizeNonceAccount: {\n    index: 7,\n    layout: z.struct([z.u32(\"instruction\"), We(\"authorized\")])\n  },\n  Allocate: {\n    index: 8,\n    layout: z.struct([z.u32(\"instruction\"), z.ns64(\"space\")])\n  },\n  AllocateWithSeed: {\n    index: 9,\n    layout: z.struct([z.u32(\"instruction\"), We(\"base\"), xn(\"seed\"), z.ns64(\"space\"), We(\"programId\")])\n  },\n  AssignWithSeed: {\n    index: 10,\n    layout: z.struct([z.u32(\"instruction\"), We(\"base\"), xn(\"seed\"), We(\"programId\")])\n  },\n  TransferWithSeed: {\n    index: 11,\n    layout: z.struct([z.u32(\"instruction\"), On(\"lamports\"), xn(\"seed\"), We(\"programId\")])\n  },\n  UpgradeNonceAccount: {\n    index: 12,\n    layout: z.struct([z.u32(\"instruction\")])\n  }\n});\nnew Oe(\"11111111111111111111111111111111\");\nnew Oe(\"BPFLoader2111111111111111111111111111111111\");\nz.struct([\n  z.u32(\"typeIndex\"),\n  On(\"deactivationSlot\"),\n  z.nu64(\"lastExtendedSlot\"),\n  z.u8(\"lastExtendedStartIndex\"),\n  z.u8(),\n  // option\n  z.seq(We(), z.offset(z.u8(), -1), \"authority\")\n]);\nconst St = Di(Qc(Oe), ce(), (s) =&gt; new Oe(s)), N0 = eu([ce(), pt(\"base64\")]), ou = Di(Qc(He.Buffer), N0, (s) =&gt; He.Buffer.from(s[0], \"base64\"));\nfunction U0(s) {\n  return ur([oe({\n    jsonrpc: pt(\"2.0\"),\n    id: ce(),\n    result: s\n  }), oe({\n    jsonrpc: pt(\"2.0\"),\n    id: ce(),\n    error: oe({\n      code: Gn(),\n      message: ce(),\n      data: Se(bv())\n    })\n  })]);\n}\nconst EE = U0(Gn());\nfunction lt(s) {\n  return Di(U0(s), EE, (e) =&gt; \"error\" in e ? e : {\n    ...e,\n    result: ti(e.result, s)\n  });\n}\nfunction Fr(s) {\n  return lt(oe({\n    context: oe({\n      slot: te()\n    }),\n    value: s\n  }));\n}\nfunction ga(s) {\n  return oe({\n    context: oe({\n      slot: te()\n    }),\n    value: s\n  });\n}\nconst xE = oe({\n  foundation: te(),\n  foundationTerm: te(),\n  initial: te(),\n  taper: te(),\n  terminal: te()\n});\nlt(fe(ge(oe({\n  epoch: te(),\n  effectiveSlot: te(),\n  amount: te(),\n  postBalance: te(),\n  commission: Se(ge(te()))\n}))));\nconst SE = fe(oe({\n  slot: te(),\n  prioritizationFee: te()\n})), bE = oe({\n  total: te(),\n  validator: te(),\n  foundation: te(),\n  epoch: te()\n}), TE = oe({\n  epoch: te(),\n  slotIndex: te(),\n  slotsInEpoch: te(),\n  absoluteSlot: te(),\n  blockHeight: Se(te()),\n  transactionCount: Se(te())\n}), wE = oe({\n  slotsPerEpoch: te(),\n  leaderScheduleSlotOffset: te(),\n  warmup: Xr(),\n  firstNormalEpoch: te(),\n  firstNormalSlot: te()\n}), AE = T0(ce(), fe(te())), rn = ge(ur([oe({}), ce()])), IE = oe({\n  err: rn\n}), _E = pt(\"receivedSignature\");\noe({\n  \"solana-core\": ce(),\n  \"feature-set\": Se(te())\n});\nconst RE = oe({\n  program: ce(),\n  programId: St,\n  parsed: Gn()\n}), LE = oe({\n  programId: St,\n  accounts: fe(St),\n  data: ce()\n});\nFr(oe({\n  err: ge(ur([oe({}), ce()])),\n  logs: ge(fe(ce())),\n  accounts: Se(ge(fe(ge(oe({\n    executable: Xr(),\n    owner: ce(),\n    lamports: te(),\n    data: fe(ce()),\n    rentEpoch: Se(te())\n  }))))),\n  unitsConsumed: Se(te()),\n  returnData: Se(ge(oe({\n    programId: ce(),\n    data: eu([ce(), pt(\"base64\")])\n  }))),\n  innerInstructions: Se(ge(fe(oe({\n    index: te(),\n    instructions: fe(ur([RE, LE]))\n  }))))\n}));\nFr(oe({\n  byIdentity: T0(ce(), fe(te())),\n  range: oe({\n    firstSlot: te(),\n    lastSlot: te()\n  })\n}));\nlt(xE);\nlt(bE);\nlt(SE);\nlt(TE);\nlt(wE);\nlt(AE);\nlt(te());\nFr(oe({\n  total: te(),\n  circulating: te(),\n  nonCirculating: te(),\n  nonCirculatingAccounts: fe(St)\n}));\nconst CE = oe({\n  amount: ce(),\n  uiAmount: ge(te()),\n  decimals: te(),\n  uiAmountString: Se(ce())\n});\nFr(fe(oe({\n  address: St,\n  amount: ce(),\n  uiAmount: ge(te()),\n  decimals: te(),\n  uiAmountString: Se(ce())\n})));\nFr(fe(oe({\n  pubkey: St,\n  account: oe({\n    executable: Xr(),\n    owner: St,\n    lamports: te(),\n    data: ou,\n    rentEpoch: te()\n  })\n})));\nconst rc = oe({\n  program: ce(),\n  parsed: Gn(),\n  space: te()\n});\nFr(fe(oe({\n  pubkey: St,\n  account: oe({\n    executable: Xr(),\n    owner: St,\n    lamports: te(),\n    data: rc,\n    rentEpoch: te()\n  })\n})));\nFr(fe(oe({\n  lamports: te(),\n  address: St\n})));\nconst au = oe({\n  executable: Xr(),\n  owner: St,\n  lamports: te(),\n  data: ou,\n  rentEpoch: te()\n});\noe({\n  pubkey: St,\n  account: au\n});\nconst kE = Di(ur([Qc(He.Buffer), rc]), ur([N0, rc]), (s) =&gt; Array.isArray(s) ? ti(s, ou) : s), DE = oe({\n  executable: Xr(),\n  owner: St,\n  lamports: te(),\n  data: kE,\n  rentEpoch: te()\n});\noe({\n  pubkey: St,\n  account: DE\n});\noe({\n  state: ur([pt(\"active\"), pt(\"inactive\"), pt(\"activating\"), pt(\"deactivating\")]),\n  active: te(),\n  inactive: te()\n});\nlt(fe(oe({\n  signature: ce(),\n  slot: te(),\n  err: rn,\n  memo: ge(ce()),\n  blockTime: Se(ge(te()))\n})));\nlt(fe(oe({\n  signature: ce(),\n  slot: te(),\n  err: rn,\n  memo: ge(ce()),\n  blockTime: Se(ge(te()))\n})));\noe({\n  subscription: te(),\n  result: ga(au)\n});\nconst PE = oe({\n  pubkey: St,\n  account: au\n});\noe({\n  subscription: te(),\n  result: ga(PE)\n});\nconst ME = oe({\n  parent: te(),\n  slot: te(),\n  root: te()\n});\noe({\n  subscription: te(),\n  result: ME\n});\nconst OE = ur([oe({\n  type: ur([pt(\"firstShredReceived\"), pt(\"completed\"), pt(\"optimisticConfirmation\"), pt(\"root\")]),\n  slot: te(),\n  timestamp: te()\n}), oe({\n  type: pt(\"createdBank\"),\n  parent: te(),\n  slot: te(),\n  timestamp: te()\n}), oe({\n  type: pt(\"frozen\"),\n  slot: te(),\n  timestamp: te(),\n  stats: oe({\n    numTransactionEntries: te(),\n    numSuccessfulTransactions: te(),\n    numFailedTransactions: te(),\n    maxTransactionsPerEntry: te()\n  })\n}), oe({\n  type: pt(\"dead\"),\n  slot: te(),\n  timestamp: te(),\n  err: ce()\n})]);\noe({\n  subscription: te(),\n  result: OE\n});\noe({\n  subscription: te(),\n  result: ga(ur([IE, _E]))\n});\noe({\n  subscription: te(),\n  result: te()\n});\noe({\n  pubkey: ce(),\n  gossip: ge(ce()),\n  tpu: ge(ce()),\n  rpc: ge(ce()),\n  version: ge(ce())\n});\nconst $d = oe({\n  votePubkey: ce(),\n  nodePubkey: ce(),\n  activatedStake: te(),\n  epochVoteAccount: Xr(),\n  epochCredits: fe(eu([te(), te(), te()])),\n  commission: te(),\n  lastVote: te(),\n  rootSlot: ge(te())\n});\nlt(oe({\n  current: fe($d),\n  delinquent: fe($d)\n}));\nconst BE = ur([pt(\"processed\"), pt(\"confirmed\"), pt(\"finalized\")]), FE = oe({\n  slot: te(),\n  confirmations: ge(te()),\n  err: rn,\n  confirmationStatus: Se(BE)\n});\nFr(fe(ge(FE)));\nlt(te());\nconst $0 = oe({\n  accountKey: St,\n  writableIndexes: fe(te()),\n  readonlyIndexes: fe(te())\n}), lu = oe({\n  signatures: fe(ce()),\n  message: oe({\n    accountKeys: fe(ce()),\n    header: oe({\n      numRequiredSignatures: te(),\n      numReadonlySignedAccounts: te(),\n      numReadonlyUnsignedAccounts: te()\n    }),\n    instructions: fe(oe({\n      accounts: fe(te()),\n      data: ce(),\n      programIdIndex: te()\n    })),\n    recentBlockhash: ce(),\n    addressTableLookups: Se(fe($0))\n  })\n}), G0 = oe({\n  pubkey: St,\n  signer: Xr(),\n  writable: Xr(),\n  source: Se(ur([pt(\"transaction\"), pt(\"lookupTable\")]))\n}), V0 = oe({\n  accountKeys: fe(G0),\n  signatures: fe(ce())\n}), j0 = oe({\n  parsed: Gn(),\n  program: ce(),\n  programId: St\n}), K0 = oe({\n  accounts: fe(St),\n  data: ce(),\n  programId: St\n}), NE = ur([K0, j0]), UE = ur([oe({\n  parsed: Gn(),\n  program: ce(),\n  programId: ce()\n}), oe({\n  accounts: fe(ce()),\n  data: ce(),\n  programId: ce()\n})]), H0 = Di(NE, UE, (s) =&gt; \"accounts\" in s ? ti(s, K0) : ti(s, j0)), q0 = oe({\n  signatures: fe(ce()),\n  message: oe({\n    accountKeys: fe(G0),\n    instructions: fe(H0),\n    recentBlockhash: ce(),\n    addressTableLookups: Se(ge(fe($0)))\n  })\n}), Ho = oe({\n  accountIndex: te(),\n  mint: ce(),\n  owner: Se(ce()),\n  programId: Se(ce()),\n  uiTokenAmount: CE\n}), W0 = oe({\n  writable: fe(St),\n  readonly: fe(St)\n}), pa = oe({\n  err: rn,\n  fee: te(),\n  innerInstructions: Se(ge(fe(oe({\n    index: te(),\n    instructions: fe(oe({\n      accounts: fe(te()),\n      data: ce(),\n      programIdIndex: te()\n    }))\n  })))),\n  preBalances: fe(te()),\n  postBalances: fe(te()),\n  logMessages: Se(ge(fe(ce()))),\n  preTokenBalances: Se(ge(fe(Ho))),\n  postTokenBalances: Se(ge(fe(Ho))),\n  loadedAddresses: Se(W0),\n  computeUnitsConsumed: Se(te()),\n  costUnits: Se(te())\n}), cu = oe({\n  err: rn,\n  fee: te(),\n  innerInstructions: Se(ge(fe(oe({\n    index: te(),\n    instructions: fe(H0)\n  })))),\n  preBalances: fe(te()),\n  postBalances: fe(te()),\n  logMessages: Se(ge(fe(ce()))),\n  preTokenBalances: Se(ge(fe(Ho))),\n  postTokenBalances: Se(ge(fe(Ho))),\n  loadedAddresses: Se(W0),\n  computeUnitsConsumed: Se(te()),\n  costUnits: Se(te())\n}), Vn = ur([pt(0), pt(\"legacy\")]), sn = oe({\n  pubkey: ce(),\n  lamports: te(),\n  postBalance: ge(te()),\n  rewardType: ge(ce()),\n  commission: Se(ge(te()))\n});\nlt(ge(oe({\n  blockhash: ce(),\n  previousBlockhash: ce(),\n  parentSlot: te(),\n  transactions: fe(oe({\n    transaction: lu,\n    meta: ge(pa),\n    version: Se(Vn)\n  })),\n  rewards: Se(fe(sn)),\n  blockTime: ge(te()),\n  blockHeight: ge(te())\n})));\nlt(ge(oe({\n  blockhash: ce(),\n  previousBlockhash: ce(),\n  parentSlot: te(),\n  rewards: Se(fe(sn)),\n  blockTime: ge(te()),\n  blockHeight: ge(te())\n})));\nlt(ge(oe({\n  blockhash: ce(),\n  previousBlockhash: ce(),\n  parentSlot: te(),\n  transactions: fe(oe({\n    transaction: V0,\n    meta: ge(pa),\n    version: Se(Vn)\n  })),\n  rewards: Se(fe(sn)),\n  blockTime: ge(te()),\n  blockHeight: ge(te())\n})));\nlt(ge(oe({\n  blockhash: ce(),\n  previousBlockhash: ce(),\n  parentSlot: te(),\n  transactions: fe(oe({\n    transaction: q0,\n    meta: ge(cu),\n    version: Se(Vn)\n  })),\n  rewards: Se(fe(sn)),\n  blockTime: ge(te()),\n  blockHeight: ge(te())\n})));\nlt(ge(oe({\n  blockhash: ce(),\n  previousBlockhash: ce(),\n  parentSlot: te(),\n  transactions: fe(oe({\n    transaction: V0,\n    meta: ge(cu),\n    version: Se(Vn)\n  })),\n  rewards: Se(fe(sn)),\n  blockTime: ge(te()),\n  blockHeight: ge(te())\n})));\nlt(ge(oe({\n  blockhash: ce(),\n  previousBlockhash: ce(),\n  parentSlot: te(),\n  rewards: Se(fe(sn)),\n  blockTime: ge(te()),\n  blockHeight: ge(te())\n})));\nlt(ge(oe({\n  blockhash: ce(),\n  previousBlockhash: ce(),\n  parentSlot: te(),\n  transactions: fe(oe({\n    transaction: lu,\n    meta: ge(pa)\n  })),\n  rewards: Se(fe(sn)),\n  blockTime: ge(te())\n})));\nlt(ge(oe({\n  blockhash: ce(),\n  previousBlockhash: ce(),\n  parentSlot: te(),\n  signatures: fe(ce()),\n  blockTime: ge(te())\n})));\nlt(ge(oe({\n  slot: te(),\n  meta: ge(pa),\n  blockTime: Se(ge(te())),\n  transaction: lu,\n  version: Se(Vn)\n})));\nlt(ge(oe({\n  slot: te(),\n  transaction: q0,\n  meta: ge(cu),\n  blockTime: Se(ge(te())),\n  version: Se(Vn)\n})));\nFr(oe({\n  blockhash: ce(),\n  lastValidBlockHeight: te()\n}));\nFr(Xr());\nconst $E = oe({\n  slot: te(),\n  numTransactions: te(),\n  numSlots: te(),\n  samplePeriodSecs: te()\n});\nlt(fe($E));\nFr(ge(oe({\n  feeCalculator: oe({\n    lamportsPerSignature: te()\n  })\n})));\nlt(ce());\nlt(ce());\nconst GE = oe({\n  err: rn,\n  logs: fe(ce()),\n  signature: ce()\n});\noe({\n  result: ga(GE),\n  subscription: te()\n});\nObject.freeze({\n  CreateLookupTable: {\n    index: 0,\n    layout: z.struct([z.u32(\"instruction\"), On(\"recentSlot\"), z.u8(\"bumpSeed\")])\n  },\n  FreezeLookupTable: {\n    index: 1,\n    layout: z.struct([z.u32(\"instruction\")])\n  },\n  ExtendLookupTable: {\n    index: 2,\n    layout: z.struct([z.u32(\"instruction\"), On(), z.seq(We(), z.offset(z.u32(), -8), \"addresses\")])\n  },\n  DeactivateLookupTable: {\n    index: 3,\n    layout: z.struct([z.u32(\"instruction\")])\n  },\n  CloseLookupTable: {\n    index: 4,\n    layout: z.struct([z.u32(\"instruction\")])\n  }\n});\nnew Oe(\"AddressLookupTab1e1111111111111111111111111\");\nObject.freeze({\n  RequestUnits: {\n    index: 0,\n    layout: z.struct([z.u8(\"instruction\"), z.u32(\"units\"), z.u32(\"additionalFee\")])\n  },\n  RequestHeapFrame: {\n    index: 1,\n    layout: z.struct([z.u8(\"instruction\"), z.u32(\"bytes\")])\n  },\n  SetComputeUnitLimit: {\n    index: 2,\n    layout: z.struct([z.u8(\"instruction\"), z.u32(\"units\")])\n  },\n  SetComputeUnitPrice: {\n    index: 3,\n    layout: z.struct([z.u8(\"instruction\"), On(\"microLamports\")])\n  }\n});\nnew Oe(\"ComputeBudget111111111111111111111111111111\");\nz.struct([z.u8(\"numSignatures\"), z.u8(\"padding\"), z.u16(\"signatureOffset\"), z.u16(\"signatureInstructionIndex\"), z.u16(\"publicKeyOffset\"), z.u16(\"publicKeyInstructionIndex\"), z.u16(\"messageDataOffset\"), z.u16(\"messageDataSize\"), z.u16(\"messageInstructionIndex\")]);\nnew Oe(\"Ed25519SigVerify111111111111111111111111111\");\noE.utils.isValidPrivateKey;\nz.struct([z.u8(\"numSignatures\"), z.u16(\"signatureOffset\"), z.u8(\"signatureInstructionIndex\"), z.u16(\"ethAddressOffset\"), z.u8(\"ethAddressInstructionIndex\"), z.u16(\"messageDataOffset\"), z.u16(\"messageDataSize\"), z.u8(\"messageInstructionIndex\"), z.blob(20, \"ethAddress\"), z.blob(64, \"signature\"), z.u8(\"recoveryId\")]);\nnew Oe(\"KeccakSecp256k11111111111111111111111111111\");\nvar z0;\nnew Oe(\"StakeConfig11111111111111111111111111111111\");\nclass Y0 {\n  /**\n   * Create a new Lockup object\n   */\n  constructor(e, t, r) {\n    this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = e, this.epoch = t, this.custodian = r;\n  }\n  /**\n   * Default, inactive Lockup value\n   */\n}\nz0 = Y0;\nY0.default = new z0(0, 0, Oe.default);\nObject.freeze({\n  Initialize: {\n    index: 0,\n    layout: z.struct([z.u32(\"instruction\"), hE(), fE()])\n  },\n  Authorize: {\n    index: 1,\n    layout: z.struct([z.u32(\"instruction\"), We(\"newAuthorized\"), z.u32(\"stakeAuthorizationType\")])\n  },\n  Delegate: {\n    index: 2,\n    layout: z.struct([z.u32(\"instruction\")])\n  },\n  Split: {\n    index: 3,\n    layout: z.struct([z.u32(\"instruction\"), z.ns64(\"lamports\")])\n  },\n  Withdraw: {\n    index: 4,\n    layout: z.struct([z.u32(\"instruction\"), z.ns64(\"lamports\")])\n  },\n  Deactivate: {\n    index: 5,\n    layout: z.struct([z.u32(\"instruction\")])\n  },\n  Merge: {\n    index: 7,\n    layout: z.struct([z.u32(\"instruction\")])\n  },\n  AuthorizeWithSeed: {\n    index: 8,\n    layout: z.struct([z.u32(\"instruction\"), We(\"newAuthorized\"), z.u32(\"stakeAuthorizationType\"), xn(\"authoritySeed\"), We(\"authorityOwner\")])\n  }\n});\nnew Oe(\"Stake11111111111111111111111111111111111111\");\nObject.freeze({\n  InitializeAccount: {\n    index: 0,\n    layout: z.struct([z.u32(\"instruction\"), gE()])\n  },\n  Authorize: {\n    index: 1,\n    layout: z.struct([z.u32(\"instruction\"), We(\"newAuthorized\"), z.u32(\"voteAuthorizationType\")])\n  },\n  Withdraw: {\n    index: 3,\n    layout: z.struct([z.u32(\"instruction\"), z.ns64(\"lamports\")])\n  },\n  UpdateValidatorIdentity: {\n    index: 4,\n    layout: z.struct([z.u32(\"instruction\")])\n  },\n  AuthorizeWithSeed: {\n    index: 10,\n    layout: z.struct([z.u32(\"instruction\"), pE()])\n  }\n});\nnew Oe(\"Vote111111111111111111111111111111111111111\");\nnew Oe(\"Va1idator1nfo111111111111111111111111111111\");\noe({\n  name: ce(),\n  website: Se(ce()),\n  details: Se(ce()),\n  iconUrl: Se(ce()),\n  keybaseUsername: Se(ce())\n});\nnew Oe(\"Vote111111111111111111111111111111111111111\");\nz.struct([\n  We(\"nodePubkey\"),\n  We(\"authorizedWithdrawer\"),\n  z.u8(\"commission\"),\n  z.nu64(),\n  // votes.length\n  z.seq(z.struct([z.nu64(\"slot\"), z.u32(\"confirmationCount\")]), z.offset(z.u32(), -8), \"votes\"),\n  z.u8(\"rootSlotValid\"),\n  z.nu64(\"rootSlot\"),\n  z.nu64(),\n  // authorizedVoters.length\n  z.seq(z.struct([z.nu64(\"epoch\"), We(\"authorizedVoter\")]), z.offset(z.u32(), -8), \"authorizedVoters\"),\n  z.struct([z.seq(z.struct([We(\"authorizedPubkey\"), z.nu64(\"epochOfLastAuthorizedSwitch\"), z.nu64(\"targetEpoch\")]), 32, \"buf\"), z.nu64(\"idx\"), z.u8(\"isEmpty\")], \"priorVoters\"),\n  z.nu64(),\n  // epochCredits.length\n  z.seq(z.struct([z.nu64(\"epoch\"), z.nu64(\"credits\"), z.nu64(\"prevCredits\")]), z.offset(z.u32(), -8), \"epochCredits\"),\n  z.struct([z.nu64(\"slot\"), z.nu64(\"timestamp\")], \"lastTimestamp\")\n]);\nconst VE = (s) =&gt; ({\n  request: s,\n  signMessage: (e) =&gt; s({ method: \"signMessage\", params: { message: e } }),\n  signTransaction: (e) =&gt; s({ method: \"signTransaction\", params: { transaction: e } }),\n  signAndSendTransaction: (e) =&gt; s({\n    method: \"signAndSendTransaction\",\n    params: e\n  })\n});\nfunction Gd(s) {\n  return Buffer.from(s.serialize({\n    verifySignatures: !1\n  })).toString(\"base64\");\n}\nfunction jE(s) {\n  const e = Buffer.from(s, \"base64\");\n  return nu.deserializeMessageVersion(e) === \"legacy\" ? iu.deserialize(e) : Ko.from(e);\n}\nfunction KE(s) {\n  return async (t) =&gt; {\n    if (t.method === \"connect\")\n      return await s(t);\n    if (t.method === \"signMessage\")\n      return await s(t);\n    if (t.method === \"signAndSendTransaction\") {\n      const { transaction: r } = t.params, n = {\n        transaction: Gd(r)\n      };\n      return await s({\n        method: \"signAndSendTransaction\",\n        params: n\n      });\n    }\n    if (t.method === \"signTransaction\") {\n      const { transaction: r } = t.params, n = {\n        transaction: Gd(r)\n      }, { signedTransaction: i } = await s({\n        method: \"signTransaction\",\n        params: n\n      });\n      return { signedTransaction: jE(i) };\n    }\n  };\n}\nconst HE = ({ miniAppHost: s, emitter: e }) =&gt; {\n  let t, r = null;\n  return {\n    visible: !1,\n    get onback() {\n      return r;\n    },\n    set onback(n) {\n      r &amp;&amp; e.removeListener(\"backNavigationTriggered\", r), r = n, n &amp;&amp; e.addListener(\"backNavigationTriggered\", n);\n    },\n    async show() {\n      await s.updateBackState({\n        visible: !0\n      }), this.visible = !0;\n    },\n    async hide() {\n      await s.updateBackState({\n        visible: !1\n      }), this.visible = !1;\n    },\n    async enableWebNavigation() {\n      t = qE({\n        back: this,\n        emitter: e\n      });\n    },\n    async disableWebNavigation() {\n      t == null || t(), t = void 0;\n    }\n  };\n};\nfunction qE({ emitter: s, back: e }) {\n  const t = WE();\n  if (t)\n    return zE({ emitter: s, back: e, navigation: t });\n  if (typeof window &lt; \"u\")\n    return YE({ emitter: s, back: e, window });\n}\nfunction WE() {\n  if (typeof window &lt; \"u\" &amp;&amp; window.navigation !== void 0)\n    return window.navigation;\n}\nfunction zE({ emitter: s, back: e, navigation: t }) {\n  function r() {\n    t.canGoBack ? e.show() : e.hide();\n  }\n  function n() {\n    e.visible &amp;&amp; t.canGoBack &amp;&amp; t.back();\n  }\n  return t.addEventListener(\"navigatesuccess\", r), s.addListener(\"backNavigationTriggered\", n), () =&gt; {\n    t.removeEventListener(\"navigatesuccess\", r), s.removeListener(\"backNavigationTriggered\", n);\n  };\n}\nfunction YE({ emitter: s, back: e, window: t }) {\n  e.show();\n  function r() {\n    e.visible &amp;&amp; t.history.back();\n  }\n  return s.addListener(\"backNavigationTriggered\", r), () =&gt; {\n    s.removeListener(\"backNavigationTriggered\", r);\n  };\n}\nconst ZE = \"0.1.1\";\nfunction XE() {\n  return ZE;\n}\nlet JE = class sc extends Error {\n  constructor(e, t = {}) {\n    const r = (() =&gt; {\n      var l;\n      if (t.cause instanceof sc) {\n        if (t.cause.details)\n          return t.cause.details;\n        if (t.cause.shortMessage)\n          return t.cause.shortMessage;\n      }\n      return (l = t.cause) != null &amp;&amp; l.message ? t.cause.message : t.details;\n    })(), n = t.cause instanceof sc &amp;&amp; t.cause.docsPath || t.docsPath, o = `https://oxlib.sh${n ?? \"\"}`, a = [\n      e || \"An error occurred.\",\n      ...t.metaMessages ? [\"\", ...t.metaMessages] : [],\n      ...r || n ? [\n        \"\",\n        r ? `Details: ${r}` : void 0,\n        n ? `See: ${o}` : void 0\n      ] : []\n    ].filter((l) =&gt; typeof l == \"string\").join(`\n`);\n    super(a, t.cause ? { cause: t.cause } : void 0), Object.defineProperty(this, \"details\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"docs\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"docsPath\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"shortMessage\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"cause\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"BaseError\"\n    }), Object.defineProperty(this, \"version\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: `ox@${XE()}`\n    }), this.cause = t.cause, this.details = r, this.docs = o, this.docsPath = n, this.shortMessage = e;\n  }\n  walk(e) {\n    return Z0(this, e);\n  }\n};\nfunction Z0(s, e) {\n  return e != null &amp;&amp; e(s) ? s : s &amp;&amp; typeof s == \"object\" &amp;&amp; \"cause\" in s &amp;&amp; s.cause ? Z0(s.cause, e) : e ? null : s;\n}\nfunction X0(s, e = {}) {\n  const { raw: t = !1 } = e, r = s;\n  if (t)\n    return s;\n  if (r.error) {\n    const { code: n } = r.error, i = n === Bn.code ? Bn : n === ri.code ? ri : n === di.code ? di : n === ci.code ? ci : n === ai.code ? ai : n === ui.code ? ui : n === oi.code ? oi : n === hi.code ? hi : n === si.code ? si : n === ni.code ? ni : n === ii.code ? ii : n === li.code ? li : mr;\n    throw new i(r.error);\n  }\n  return r.result;\n}\nlet mr = class extends Error {\n  constructor(e) {\n    const { code: t, message: r, data: n } = e;\n    super(r), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.BaseError\"\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"data\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), this.code = t, this.data = n;\n  }\n};\nclass ri extends mr {\n  constructor(e = {}) {\n    super({\n      message: \"Missing or invalid parameters.\",\n      ...e,\n      code: ri.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32e3\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.InvalidInputError\"\n    });\n  }\n}\nObject.defineProperty(ri, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32e3\n});\nclass si extends mr {\n  constructor(e = {}) {\n    super({\n      message: \"Requested resource not found.\",\n      ...e,\n      code: si.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32001\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.ResourceNotFoundError\"\n    });\n  }\n}\nObject.defineProperty(si, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32001\n});\nclass ni extends mr {\n  constructor(e = {}) {\n    super({\n      message: \"Requested resource not available.\",\n      ...e,\n      code: ni.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32002\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.ResourceUnavailableError\"\n    });\n  }\n}\nObject.defineProperty(ni, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32002\n});\nclass ii extends mr {\n  constructor(e = {}) {\n    super({\n      message: \"Transaction creation failed.\",\n      ...e,\n      code: ii.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32003\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.TransactionRejectedError\"\n    });\n  }\n}\nObject.defineProperty(ii, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32003\n});\nclass oi extends mr {\n  constructor(e = {}) {\n    super({\n      message: \"Method is not implemented.\",\n      ...e,\n      code: oi.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32004\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.MethodNotSupportedError\"\n    });\n  }\n}\nObject.defineProperty(oi, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32004\n});\nclass ai extends mr {\n  constructor(e = {}) {\n    super({\n      message: \"Rate limit exceeded.\",\n      ...e,\n      code: ai.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32005\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.LimitExceededError\"\n    });\n  }\n}\nObject.defineProperty(ai, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32005\n});\nclass li extends mr {\n  constructor(e = {}) {\n    super({\n      message: \"JSON-RPC version not supported.\",\n      ...e,\n      code: li.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32006\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.VersionNotSupportedError\"\n    });\n  }\n}\nObject.defineProperty(li, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32006\n});\nclass ci extends mr {\n  constructor(e = {}) {\n    super({\n      message: \"Input is not a valid JSON-RPC request.\",\n      ...e,\n      code: ci.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32600\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.InvalidRequestError\"\n    });\n  }\n}\nObject.defineProperty(ci, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32600\n});\nclass ui extends mr {\n  constructor(e = {}) {\n    super({\n      message: \"Method does not exist.\",\n      ...e,\n      code: ui.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32601\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.MethodNotFoundError\"\n    });\n  }\n}\nObject.defineProperty(ui, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32601\n});\nclass di extends mr {\n  constructor(e = {}) {\n    super({\n      message: \"Invalid method parameters.\",\n      ...e,\n      code: di.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32602\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.InvalidParamsError\"\n    });\n  }\n}\nObject.defineProperty(di, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32602\n});\nclass Bn extends mr {\n  constructor(e = {}) {\n    super({\n      message: \"Internal JSON-RPC error.\",\n      ...e,\n      code: Bn.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32603\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.InternalErrorError\"\n    });\n  }\n}\nObject.defineProperty(Bn, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32603\n});\nclass hi extends mr {\n  constructor(e = {}) {\n    super({\n      message: \"Failed to parse JSON-RPC response.\",\n      ...e,\n      code: hi.code\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: -32700\n    }), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"RpcResponse.ParseError\"\n    });\n  }\n}\nObject.defineProperty(hi, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: -32700\n});\nclass nn extends Error {\n  constructor(e, t) {\n    super(t), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"ProviderRpcError\"\n    }), Object.defineProperty(this, \"code\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), Object.defineProperty(this, \"details\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: void 0\n    }), this.code = e, this.details = t;\n  }\n}\nclass J0 extends nn {\n  constructor({ message: e = \"The user rejected the request.\" } = {}) {\n    super(4001, e), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"Provider.UserRejectedRequestError\"\n    });\n  }\n}\nObject.defineProperty(J0, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: 4001\n});\nclass Q0 extends nn {\n  constructor({ message: e = \"The requested method and/or account has not been authorized by the user.\" } = {}) {\n    super(4100, e), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"Provider.UnauthorizedError\"\n    });\n  }\n}\nObject.defineProperty(Q0, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: 4100\n});\nclass eg extends nn {\n  constructor({ message: e = \"The provider does not support the requested method.\" } = {}) {\n    super(4200, e), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"Provider.UnsupportedMethodError\"\n    });\n  }\n}\nObject.defineProperty(eg, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: 4200\n});\nclass tg extends nn {\n  constructor({ message: e = \"The provider is disconnected from all chains.\" } = {}) {\n    super(4900, e), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"Provider.DisconnectedError\"\n    });\n  }\n}\nObject.defineProperty(tg, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: 4900\n});\nclass rg extends nn {\n  constructor({ message: e = \"The provider is not connected to the requested chain.\" } = {}) {\n    super(4901, e), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"Provider.ChainDisconnectedError\"\n    });\n  }\n}\nObject.defineProperty(rg, \"code\", {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: 4901\n});\nfunction QE() {\n  const s = new L0();\n  return {\n    get eventNames() {\n      return s.eventNames.bind(s);\n    },\n    get listenerCount() {\n      return s.listenerCount.bind(s);\n    },\n    get listeners() {\n      return s.listeners.bind(s);\n    },\n    addListener: s.addListener.bind(s),\n    emit: s.emit.bind(s),\n    off: s.off.bind(s),\n    on: s.on.bind(s),\n    once: s.once.bind(s),\n    removeAllListeners: s.removeAllListeners.bind(s),\n    removeListener: s.removeListener.bind(s)\n  };\n}\nfunction ex(s, e = {}) {\n  var r, n;\n  const { includeEvents: t = !0 } = e;\n  if (!s)\n    throw new tx();\n  return {\n    ...t ? {\n      on: (r = s.on) == null ? void 0 : r.bind(s),\n      removeListener: (n = s.removeListener) == null ? void 0 : n.bind(s)\n    } : {},\n    async request(i) {\n      const o = await s.request(i);\n      return o &amp;&amp; typeof o == \"object\" &amp;&amp; \"jsonrpc\" in o ? X0(o) : o;\n    }\n  };\n}\nclass tx extends JE {\n  constructor() {\n    super(\"`provider` is undefined.\"), Object.defineProperty(this, \"name\", {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: \"Provider.IsUndefinedError\"\n    });\n  }\n}\nfunction rx(s = {}) {\n  let e = s.id ?? 0;\n  return {\n    prepare(t) {\n      return sx({\n        id: e++,\n        ...t\n      });\n    },\n    get id() {\n      return e;\n    }\n  };\n}\nfunction sx(s) {\n  return {\n    ...s,\n    jsonrpc: \"2.0\"\n  };\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nconst sg = Symbol(\"Comlink.proxy\"), nx = Symbol(\"Comlink.endpoint\"), ix = Symbol(\"Comlink.releaseProxy\"), ll = Symbol(\"Comlink.finalizer\"), ho = Symbol(\"Comlink.thrown\"), ng = (s) =&gt; typeof s == \"object\" &amp;&amp; s !== null || typeof s == \"function\", ox = {\n  canHandle: (s) =&gt; ng(s) &amp;&amp; s[sg],\n  serialize(s) {\n    const { port1: e, port2: t } = new MessageChannel();\n    return og(s, e), [t, [t]];\n  },\n  deserialize(s) {\n    return s.start(), lg(s);\n  }\n}, ax = {\n  canHandle: (s) =&gt; ng(s) &amp;&amp; ho in s,\n  serialize({ value: s }) {\n    let e;\n    return s instanceof Error ? e = {\n      isError: !0,\n      value: {\n        message: s.message,\n        name: s.name,\n        stack: s.stack\n      }\n    } : e = { isError: !1, value: s }, [e, []];\n  },\n  deserialize(s) {\n    throw s.isError ? Object.assign(new Error(s.value.message), s.value) : s.value;\n  }\n}, ig = /* @__PURE__ */ new Map([\n  [\"proxy\", ox],\n  [\"throw\", ax]\n]);\nfunction lx(s, e) {\n  for (const t of s)\n    if (e === t || t === \"*\" || t instanceof RegExp &amp;&amp; t.test(e))\n      return !0;\n  return !1;\n}\nfunction og(s, e = globalThis, t = [\"*\"]) {\n  e.addEventListener(\"message\", function r(n) {\n    if (!n || !n.data)\n      return;\n    if (!lx(t, n.origin)) {\n      console.warn(`Invalid origin '${n.origin}' for comlink proxy`);\n      return;\n    }\n    const { id: i, type: o, path: a } = Object.assign({ path: [] }, n.data), l = (n.data.argumentList || []).map($s);\n    let c;\n    try {\n      const u = a.slice(0, -1).reduce((h, f) =&gt; h[f], s), d = a.reduce((h, f) =&gt; h[f], s);\n      switch (o) {\n        case \"GET\":\n          c = d;\n          break;\n        case \"SET\":\n          u[a.slice(-1)[0]] = $s(n.data.value), c = !0;\n          break;\n        case \"APPLY\":\n          c = d.apply(u, l);\n          break;\n        case \"CONSTRUCT\":\n          {\n            const h = new d(...l);\n            c = gx(h);\n          }\n          break;\n        case \"ENDPOINT\":\n          {\n            const { port1: h, port2: f } = new MessageChannel();\n            og(s, f), c = fx(h, [h]);\n          }\n          break;\n        case \"RELEASE\":\n          c = void 0;\n          break;\n        default:\n          return;\n      }\n    } catch (u) {\n      c = { value: u, [ho]: 0 };\n    }\n    Promise.resolve(c).catch((u) =&gt; ({ value: u, [ho]: 0 })).then((u) =&gt; {\n      const [d, h] = zo(u);\n      e.postMessage(Object.assign(Object.assign({}, d), { id: i }), h), o === \"RELEASE\" &amp;&amp; (e.removeEventListener(\"message\", r), ag(e), ll in s &amp;&amp; typeof s[ll] == \"function\" &amp;&amp; s[ll]());\n    }).catch((u) =&gt; {\n      const [d, h] = zo({\n        value: new TypeError(\"Unserializable return value\"),\n        [ho]: 0\n      });\n      e.postMessage(Object.assign(Object.assign({}, d), { id: i }), h);\n    });\n  }), e.start &amp;&amp; e.start();\n}\nfunction cx(s) {\n  return s.constructor.name === \"MessagePort\";\n}\nfunction ag(s) {\n  cx(s) &amp;&amp; s.close();\n}\nfunction lg(s, e) {\n  const t = /* @__PURE__ */ new Map();\n  return s.addEventListener(\"message\", function(n) {\n    const { data: i } = n;\n    if (!i || !i.id)\n      return;\n    const o = t.get(i.id);\n    if (o)\n      try {\n        o(i);\n      } finally {\n        t.delete(i.id);\n      }\n  }), nc(s, t, [], e);\n}\nfunction Vi(s) {\n  if (s)\n    throw new Error(\"Proxy has been released and is not useable\");\n}\nfunction cg(s) {\n  return yn(s, /* @__PURE__ */ new Map(), {\n    type: \"RELEASE\"\n  }).then(() =&gt; {\n    ag(s);\n  });\n}\nconst qo = /* @__PURE__ */ new WeakMap(), Wo = \"FinalizationRegistry\" in globalThis &amp;&amp; new FinalizationRegistry((s) =&gt; {\n  const e = (qo.get(s) || 0) - 1;\n  qo.set(s, e), e === 0 &amp;&amp; cg(s);\n});\nfunction ux(s, e) {\n  const t = (qo.get(e) || 0) + 1;\n  qo.set(e, t), Wo &amp;&amp; Wo.register(s, e, s);\n}\nfunction dx(s) {\n  Wo &amp;&amp; Wo.unregister(s);\n}\nfunction nc(s, e, t = [], r = function() {\n}) {\n  let n = !1;\n  const i = new Proxy(r, {\n    get(o, a) {\n      if (Vi(n), a === ix)\n        return () =&gt; {\n          dx(i), cg(s), e.clear(), n = !0;\n        };\n      if (a === \"then\") {\n        if (t.length === 0)\n          return { then: () =&gt; i };\n        const l = yn(s, e, {\n          type: \"GET\",\n          path: t.map((c) =&gt; c.toString())\n        }).then($s);\n        return l.then.bind(l);\n      }\n      return nc(s, e, [...t, a]);\n    },\n    set(o, a, l) {\n      Vi(n);\n      const [c, u] = zo(l);\n      return yn(s, e, {\n        type: \"SET\",\n        path: [...t, a].map((d) =&gt; d.toString()),\n        value: c\n      }, u).then($s);\n    },\n    apply(o, a, l) {\n      Vi(n);\n      const c = t[t.length - 1];\n      if (c === nx)\n        return yn(s, e, {\n          type: \"ENDPOINT\"\n        }).then($s);\n      if (c === \"bind\")\n        return nc(s, e, t.slice(0, -1));\n      const [u, d] = Vd(l);\n      return yn(s, e, {\n        type: \"APPLY\",\n        path: t.map((h) =&gt; h.toString()),\n        argumentList: u\n      }, d).then($s);\n    },\n    construct(o, a) {\n      Vi(n);\n      const [l, c] = Vd(a);\n      return yn(s, e, {\n        type: \"CONSTRUCT\",\n        path: t.map((u) =&gt; u.toString()),\n        argumentList: l\n      }, c).then($s);\n    }\n  });\n  return ux(i, s), i;\n}\nfunction hx(s) {\n  return Array.prototype.concat.apply([], s);\n}\nfunction Vd(s) {\n  const e = s.map(zo);\n  return [e.map((t) =&gt; t[0]), hx(e.map((t) =&gt; t[1]))];\n}\nconst ug = /* @__PURE__ */ new WeakMap();\nfunction fx(s, e) {\n  return ug.set(s, e), s;\n}\nfunction gx(s) {\n  return Object.assign(s, { [sg]: !0 });\n}\nfunction px(s, e = globalThis, t = \"*\") {\n  return {\n    postMessage: (r, n) =&gt; s.postMessage(r, t, n),\n    addEventListener: e.addEventListener.bind(e),\n    removeEventListener: e.removeEventListener.bind(e)\n  };\n}\nfunction zo(s) {\n  for (const [e, t] of ig)\n    if (t.canHandle(s)) {\n      const [r, n] = t.serialize(s);\n      return [\n        {\n          type: \"HANDLER\",\n          name: e,\n          value: r\n        },\n        n\n      ];\n    }\n  return [\n    {\n      type: \"RAW\",\n      value: s\n    },\n    ug.get(s) || []\n  ];\n}\nfunction $s(s) {\n  switch (s.type) {\n    case \"HANDLER\":\n      return ig.get(s.name).deserialize(s.value);\n    case \"RAW\":\n      return s.value;\n  }\n}\nfunction yn(s, e, t, r) {\n  return new Promise((n) =&gt; {\n    const i = mx();\n    e.set(i, n), s.start &amp;&amp; s.start(), s.postMessage(Object.assign({ id: i }, t), r);\n  });\n}\nfunction mx() {\n  return new Array(4).fill(0).map(() =&gt; Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16)).join(\"-\");\n}\nconst yx = {\n  postMessage() {\n  },\n  addEventListener: () =&gt; {\n  },\n  removeEventListener: () =&gt; {\n  }\n}, vx = {\n  postMessage: (s) =&gt; {\n    window.ReactNativeWebView.postMessage(JSON.stringify(s));\n  },\n  addEventListener: (s, e, ...t) =&gt; {\n    document.addEventListener(\"FarcasterFrameCallback\", e, ...t);\n  },\n  removeEventListener: (s, e) =&gt; {\n    document.removeEventListener(\"FarcasterFrameCallback\", e);\n  }\n}, Ex = typeof window &gt; \"u\" ? yx : window != null &amp;&amp; window.ReactNativeWebView ? vx : px((window == null ? void 0 : window.parent) ?? window), Me = lg(Ex), uu = QE(), xx = rx();\nfunction Sx({ code: s, details: e }) {\n  switch (s) {\n    case 4001:\n      return new J0();\n    case 4100:\n      return new Q0();\n    case 4200:\n      return new eg();\n    case 4900:\n      return new tg();\n    case 4901:\n      return new rg();\n    default:\n      return new nn(s, e ?? \"Unknown provider RPC error\");\n  }\n}\nconst fi = ex({\n  ...uu,\n  async request(s) {\n    const e = xx.prepare(s);\n    try {\n      const t = await Me.ethProviderRequestV2(e).then((r) =&gt; X0(r, { request: e, raw: !0 }));\n      if (t.error)\n        throw Sx(t.error);\n      return t.result;\n    } catch (t) {\n      if (t instanceof Error &amp;&amp; t.message.match(/cannot read property 'apply'/i))\n        return await Me.ethProviderRequest(e);\n      throw t instanceof nn || t instanceof mr ? t : new Bn({\n        message: t instanceof Error ? t.message : void 0\n      });\n    }\n  }\n});\nasync function bx() {\n  try {\n    const s = await Me.getCapabilities();\n    return !s.includes(\"wallet.getEthereumProvider\") &amp;&amp; !s.includes(\"wallet.getEvmProvider\") ? void 0 : fi;\n  } catch {\n    return fi;\n  }\n}\nfunction dg(s) {\n  const e = new CustomEvent(\"eip6963:announceProvider\", { detail: Object.freeze(s) });\n  window.dispatchEvent(e);\n  const t = () =&gt; window.dispatchEvent(e);\n  return window.addEventListener(\"eip6963:requestProvider\", t), () =&gt; window.removeEventListener(\"eip6963:requestProvider\", t);\n}\ntypeof document &lt; \"u\" &amp;&amp; (document.addEventListener(\"eip6963:requestProvider\", () =&gt; {\n  Me.eip6963RequestProvider();\n}), document.addEventListener(\"FarcasterFrameEthProviderEvent\", (s) =&gt; {\n  if (s instanceof MessageEvent) {\n    const e = s.data;\n    uu.emit(e.event, ...e.params);\n  }\n}), document.addEventListener(\"FarcasterFrameEvent\", (s) =&gt; {\n  if (s instanceof MessageEvent) {\n    const e = s.data;\n    e.event === \"eip6963:announceProvider\" &amp;&amp; dg({\n      info: e.info,\n      provider: fi\n    });\n  }\n}));\ntypeof window &lt; \"u\" &amp;&amp; (window.addEventListener(\"eip6963:requestProvider\", () =&gt; {\n  Me.eip6963RequestProvider();\n}), window.addEventListener(\"message\", (s) =&gt; {\n  if (s instanceof MessageEvent &amp;&amp; s.data.type === \"frameEthProviderEvent\") {\n    const e = s.data;\n    uu.emit(e.event, ...e.params);\n  }\n}), window.addEventListener(\"message\", (s) =&gt; {\n  if (s instanceof MessageEvent &amp;&amp; s.data.type === \"frameEvent\") {\n    const e = s.data.event;\n    e.event === \"eip6963:announceProvider\" &amp;&amp; dg({\n      info: e.info,\n      provider: fi\n    });\n  }\n}));\nnew TextEncoder();\nconst hg = new TextDecoder(), Tx = (s) =&gt; {\n  const e = atob(s), t = new Uint8Array(e.length);\n  for (let r = 0; r &lt; e.length; r++)\n    t[r] = e.charCodeAt(r);\n  return t;\n}, wx = (s) =&gt; {\n  let e = s;\n  e instanceof Uint8Array &amp;&amp; (e = hg.decode(e)), e = e.replace(/-/g, \"+\").replace(/_/g, \"/\").replace(/\\s/g, \"\");\n  try {\n    return Tx(e);\n  } catch {\n    throw new TypeError(\"The input to be decoded is not correctly encoded.\");\n  }\n}, Ax = wx;\nfunction Ix(s) {\n  return typeof s == \"object\" &amp;&amp; s !== null;\n}\nfunction _x(s) {\n  if (!Ix(s) || Object.prototype.toString.call(s) !== \"[object Object]\")\n    return !1;\n  if (Object.getPrototypeOf(s) === null)\n    return !0;\n  let e = s;\n  for (; Object.getPrototypeOf(e) !== null; )\n    e = Object.getPrototypeOf(e);\n  return Object.getPrototypeOf(s) === e;\n}\nclass dr extends Error {\n  constructor(e, t) {\n    var r;\n    super(e, t), this.code = \"ERR_JOSE_GENERIC\", this.name = this.constructor.name, (r = Error.captureStackTrace) == null || r.call(Error, this, this.constructor);\n  }\n}\ndr.code = \"ERR_JOSE_GENERIC\";\nclass Rx extends dr {\n  constructor(e, t, r = \"unspecified\", n = \"unspecified\") {\n    super(e, { cause: { claim: r, reason: n, payload: t } }), this.code = \"ERR_JWT_CLAIM_VALIDATION_FAILED\", this.claim = r, this.reason = n, this.payload = t;\n  }\n}\nRx.code = \"ERR_JWT_CLAIM_VALIDATION_FAILED\";\nclass Lx extends dr {\n  constructor(e, t, r = \"unspecified\", n = \"unspecified\") {\n    super(e, { cause: { claim: r, reason: n, payload: t } }), this.code = \"ERR_JWT_EXPIRED\", this.claim = r, this.reason = n, this.payload = t;\n  }\n}\nLx.code = \"ERR_JWT_EXPIRED\";\nclass Cx extends dr {\n  constructor() {\n    super(...arguments), this.code = \"ERR_JOSE_ALG_NOT_ALLOWED\";\n  }\n}\nCx.code = \"ERR_JOSE_ALG_NOT_ALLOWED\";\nclass kx extends dr {\n  constructor() {\n    super(...arguments), this.code = \"ERR_JOSE_NOT_SUPPORTED\";\n  }\n}\nkx.code = \"ERR_JOSE_NOT_SUPPORTED\";\nclass Dx extends dr {\n  constructor(e = \"decryption operation failed\", t) {\n    super(e, t), this.code = \"ERR_JWE_DECRYPTION_FAILED\";\n  }\n}\nDx.code = \"ERR_JWE_DECRYPTION_FAILED\";\nclass Px extends dr {\n  constructor() {\n    super(...arguments), this.code = \"ERR_JWE_INVALID\";\n  }\n}\nPx.code = \"ERR_JWE_INVALID\";\nclass Mx extends dr {\n  constructor() {\n    super(...arguments), this.code = \"ERR_JWS_INVALID\";\n  }\n}\nMx.code = \"ERR_JWS_INVALID\";\nclass Ts extends dr {\n  constructor() {\n    super(...arguments), this.code = \"ERR_JWT_INVALID\";\n  }\n}\nTs.code = \"ERR_JWT_INVALID\";\nclass Ox extends dr {\n  constructor() {\n    super(...arguments), this.code = \"ERR_JWK_INVALID\";\n  }\n}\nOx.code = \"ERR_JWK_INVALID\";\nclass Bx extends dr {\n  constructor() {\n    super(...arguments), this.code = \"ERR_JWKS_INVALID\";\n  }\n}\nBx.code = \"ERR_JWKS_INVALID\";\nclass Fx extends dr {\n  constructor(e = \"no applicable key found in the JSON Web Key Set\", t) {\n    super(e, t), this.code = \"ERR_JWKS_NO_MATCHING_KEY\";\n  }\n}\nFx.code = \"ERR_JWKS_NO_MATCHING_KEY\";\nclass Nx extends dr {\n  constructor(e = \"multiple matching keys found in the JSON Web Key Set\", t) {\n    super(e, t), this.code = \"ERR_JWKS_MULTIPLE_MATCHING_KEYS\";\n  }\n}\nNx.code = \"ERR_JWKS_MULTIPLE_MATCHING_KEYS\";\nclass Ux extends dr {\n  constructor(e = \"request timed out\", t) {\n    super(e, t), this.code = \"ERR_JWKS_TIMEOUT\";\n  }\n}\nUx.code = \"ERR_JWKS_TIMEOUT\";\nclass $x extends dr {\n  constructor(e = \"signature verification failed\", t) {\n    super(e, t), this.code = \"ERR_JWS_SIGNATURE_VERIFICATION_FAILED\";\n  }\n}\n$x.code = \"ERR_JWS_SIGNATURE_VERIFICATION_FAILED\";\nfunction Gx(s) {\n  if (typeof s != \"string\")\n    throw new Ts(\"JWTs must use Compact JWS serialization, JWT must be a string\");\n  const { 1: e, length: t } = s.split(\".\");\n  if (t === 5)\n    throw new Ts(\"Only JWTs using Compact JWS serialization can be decoded\");\n  if (t !== 3)\n    throw new Ts(\"Invalid JWT\");\n  if (!e)\n    throw new Ts(\"JWTs must contain a payload\");\n  let r;\n  try {\n    r = Ax(e);\n  } catch {\n    throw new Ts(\"Failed to base64url decode the payload\");\n  }\n  let n;\n  try {\n    n = JSON.parse(hg.decode(r));\n  } catch {\n    throw new Ts(\"Failed to parse the decoded payload as JSON\");\n  }\n  if (!_x(n))\n    throw new Ts(\"Invalid JWT Claims Set\");\n  return n;\n}\nfunction Vx(s) {\n  return Gx(s);\n}\nclass ma extends Error {\n  constructor(e, t = {}) {\n    const r = (() =&gt; {\n      var i;\n      if (t.cause instanceof ma) {\n        if (t.cause.details)\n          return t.cause.details;\n        if (t.cause.shortMessage)\n          return t.cause.shortMessage;\n      }\n      return t.cause &amp;&amp; \"details\" in t.cause &amp;&amp; typeof t.cause.details == \"string\" ? t.cause.details : (i = t.cause) != null &amp;&amp; i.message ? t.cause.message : t.details;\n    })(), n = [\n      e || \"An error occurred.\",\n      ...t.metaMessages ? [\"\", ...t.metaMessages] : [],\n      ...r ? [\n        \"\",\n        r ? `Details: ${r}` : void 0\n      ] : []\n    ].filter((i) =&gt; typeof i == \"string\").join(`\n`);\n    super(n, t.cause ? { cause: t.cause } : void 0), this.name = \"BaseError\", this.cause = t.cause, this.details = r, this.shortMessage = e;\n  }\n}\nclass fg extends ma {\n  constructor({ status: e }) {\n    super(`Request failed with status ${e}`), this.name = \"RequestFailedError\";\n  }\n}\nclass jx extends ma {\n  constructor(e) {\n    super(e), this.name = \"InvalidToken\";\n  }\n}\nasync function Kx({ origin: s }) {\n  const e = await fetch(`${s}/nonce`, {\n    method: \"POST\"\n  });\n  if (!e.ok)\n    throw new fg({ status: e.status });\n  return await e.json();\n}\nasync function Hx({ origin: s }, e) {\n  const t = await fetch(`${s}/verify-siwf`, {\n    method: \"POST\",\n    headers: new Headers({ \"Content-Type\": \"application/json\" }),\n    body: JSON.stringify(e)\n  });\n  if (!t.ok)\n    throw new fg({ status: t.status });\n  const r = await t.json();\n  if (r.valid === !1)\n    throw new jx(r.message ?? \"unknown\");\n  return { token: r.token };\n}\nfunction qx(s = {}) {\n  return {\n    origin: s.origin ?? \"https://auth.farcaster.xyz\"\n  };\n}\nfunction Wx(s = {}) {\n  const e = qx(s);\n  return {\n    generateNonce: () =&gt; Kx(e),\n    verifySiwf: (t) =&gt; Hx(e, t)\n  };\n}\nconst zx = /^(?:(?&lt;scheme&gt;[a-zA-Z][a-zA-Z0-9+-.]*):\\/\\/)?(?&lt;domain&gt;[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\\n)(?&lt;address&gt;0x[a-fA-F0-9]{40})\\n\\n(?:(?&lt;statement&gt;.*)\\n\\n)?/, Yx = /(?:URI: (?&lt;uri&gt;.+))\\n(?:Version: (?&lt;version&gt;.+))\\n(?:Chain ID: (?&lt;chainId&gt;\\d+))\\n(?:Nonce: (?&lt;nonce&gt;[a-zA-Z0-9]+))\\n(?:Issued At: (?&lt;issuedAt&gt;.+))(?:\\nExpiration Time: (?&lt;expirationTime&gt;.+))?(?:\\nNot Before: (?&lt;notBefore&gt;.+))?(?:\\nRequest ID: (?&lt;requestId&gt;.+))?/;\nfunction Zx(s) {\n  var d, h, f;\n  const { scheme: e, statement: t, ...r } = ((d = s.match(zx)) == null ? void 0 : d.groups) ?? {}, { chainId: n, expirationTime: i, issuedAt: o, notBefore: a, requestId: l, ...c } = ((h = s.match(Yx)) == null ? void 0 : h.groups) ?? {}, u = (f = s.split(\"Resources:\")[1]) == null ? void 0 : f.split(`\n- `).slice(1);\n  return {\n    ...r,\n    ...c,\n    ...n ? { chainId: Number(n) } : {},\n    ...i ? { expirationTime: new Date(i) } : {},\n    ...o ? { issuedAt: new Date(o) } : {},\n    ...a ? { notBefore: new Date(a) } : {},\n    ...l ? { requestId: l } : {},\n    ...u ? { resources: u } : {},\n    ...e ? { scheme: e } : {},\n    ...t ? { statement: t } : {}\n  };\n}\nconst jd = /* @__PURE__ */ (() =&gt; {\n  let s, e;\n  async function t(r) {\n    const n = Wx({\n      origin: r.quickAuthServerOrigin\n    }), { nonce: i } = await n.generateNonce(), o = await Me.signIn({\n      nonce: i,\n      acceptAuthAddress: !0\n    });\n    if (o.result) {\n      const a = Zx(o.result.message);\n      if (!a.domain)\n        throw new Error(\"Missing domain on SIWE message\");\n      const l = await n.verifySiwf({\n        domain: a.domain,\n        message: o.result.message,\n        signature: o.result.signature\n      });\n      return s = {\n        token: l.token,\n        payload: Vx(l.token)\n      }, l;\n    }\n    throw o.error.type === \"rejected_by_user\" ? new Of() : new Error(\"Unreachable\");\n  }\n  return {\n    get token() {\n      if (s &amp;&amp; new Date(s.payload.exp * 1e3) &gt; new Date(Date.now() + 15e3))\n        return s.token;\n    },\n    async getToken(r = {}) {\n      const n = r.force ?? !1;\n      return s &amp;&amp; !n &amp;&amp; new Date(s.payload.exp * 1e3) &gt; new Date(Date.now() + 15e3) ? { token: s.token } : (e || (e = t(r)), e.finally(() =&gt; {\n        e = void 0;\n      }), e);\n    },\n    async fetch(r, n) {\n      const { token: i } = await this.getToken(), o = new Headers(n == null ? void 0 : n.headers);\n      return o.set(\"Authorization\", `Bearer ${i}`), fetch(r, {\n        ...n,\n        headers: o\n      });\n    }\n  };\n})();\nfunction Xx() {\n  const s = new L0();\n  return {\n    get eventNames() {\n      return s.eventNames.bind(s);\n    },\n    get listenerCount() {\n      return s.listenerCount.bind(s);\n    },\n    get listeners() {\n      return s.listeners.bind(s);\n    },\n    addListener: s.addListener.bind(s),\n    emit: s.emit.bind(s),\n    off: s.off.bind(s),\n    on: s.on.bind(s),\n    once: s.once.bind(s),\n    removeAllListeners: s.removeAllListeners.bind(s),\n    removeListener: s.removeListener.bind(s)\n  };\n}\nconst nr = Xx(), { solanaProviderRequest: Kd } = Me;\nlet gg;\nKd &amp;&amp; (gg = VE(KE(Kd)));\nasync function Hd() {\n  let s;\n  try {\n    s = await Me.getCapabilities();\n  } catch {\n  }\n  if (s != null &amp;&amp; s.includes(\"wallet.getSolanaProvider\"))\n    return gg;\n}\nlet qd = null;\nasync function Jx(s = 1e3) {\n  if (qd === !0)\n    return !0;\n  if (typeof window &gt; \"u\" || !window.ReactNativeWebView &amp;&amp; window === window.parent)\n    return !1;\n  const e = await Promise.race([\n    Me.context.then((t) =&gt; !!t),\n    // Check if context resolves to truthy\n    new Promise((t) =&gt; {\n      setTimeout(() =&gt; t(!1), s);\n    })\n  ]).catch(() =&gt; !1);\n  return e &amp;&amp; (qd = !0), e;\n}\nconst Wd = async () =&gt; {\n  const s = await Me.addFrame();\n  if (s.result)\n    return s.result;\n  throw s.error.type === \"invalid_domain_manifest\" ? new Tm() : s.error.type === \"rejected_by_user\" ? new wm() : new Error(\"Unreachable\");\n}, ht = {\n  ...nr,\n  getCapabilities: Me.getCapabilities,\n  getChains: Me.getChains,\n  isInMiniApp: Jx,\n  context: Me.context,\n  back: HE({ miniAppHost: Me, emitter: nr }),\n  quickAuth: jd,\n  actions: {\n    setPrimaryButton: Me.setPrimaryButton.bind(Me),\n    ready: async (s = {}) =&gt; await Me.ready(s),\n    close: Me.close.bind(Me),\n    viewCast: Me.viewCast.bind(Me),\n    viewProfile: Me.viewProfile.bind(Me),\n    openMiniApp: Me.openMiniApp.bind(Me),\n    signIn: async (s) =&gt; {\n      const e = await Me.signIn(s);\n      if (e.result)\n        return e.result;\n      throw e.error.type === \"rejected_by_user\" ? new Of() : new Error(\"Unreachable\");\n    },\n    openUrl: (s) =&gt; {\n      const e = typeof s == \"string\" ? s : s.url;\n      return Me.openUrl(e.trim());\n    },\n    addFrame: Wd,\n    addMiniApp: Wd,\n    composeCast(s = {}) {\n      return Me.composeCast(s);\n    },\n    viewToken: Me.viewToken.bind(Me),\n    sendToken: Me.sendToken.bind(Me),\n    swapToken: Me.swapToken.bind(Me),\n    requestCameraAndMicrophoneAccess: Me.requestCameraAndMicrophoneAccess.bind(Me)\n  },\n  experimental: {\n    getSolanaProvider: Hd,\n    signManifest: async (s) =&gt; {\n      const e = await Me.signManifest(s);\n      if (e.result)\n        return e.result;\n      throw e.error.type === \"rejected_by_user\" ? new Am() : e.error.type === \"invalid_domain\" ? new Im() : e.error.type === \"generic_error\" ? new _m(e.error.message) : new Error(\"Unreachable\");\n    },\n    quickAuth(s) {\n      return jd.getToken(s);\n    }\n  },\n  wallet: {\n    ethProvider: fi,\n    getEthereumProvider: bx,\n    getSolanaProvider: Hd\n  },\n  haptics: {\n    impactOccurred: Me.impactOccurred.bind(Me),\n    notificationOccurred: Me.notificationOccurred.bind(Me),\n    selectionChanged: Me.selectionChanged.bind(Me)\n  }\n};\ntypeof document &lt; \"u\" &amp;&amp; document.addEventListener(\"FarcasterFrameEvent\", (s) =&gt; {\n  if (s instanceof MessageEvent) {\n    const e = s.data;\n    e.event === \"primary_button_clicked\" ? nr.emit(\"primaryButtonClicked\") : e.event === \"miniapp_added\" ? nr.emit(\"miniAppAdded\", {\n      notificationDetails: e.notificationDetails\n    }) : e.event === \"miniapp_add_rejected\" ? nr.emit(\"miniAppAddRejected\", { reason: e.reason }) : e.event === \"miniapp_removed\" ? nr.emit(\"miniAppRemoved\") : e.event === \"notifications_enabled\" ? nr.emit(\"notificationsEnabled\", {\n      notificationDetails: e.notificationDetails\n    }) : e.event === \"notifications_disabled\" ? nr.emit(\"notificationsDisabled\") : e.event === \"back_navigation_triggered\" &amp;&amp; nr.emit(\"backNavigationTriggered\");\n  }\n});\ntypeof window &lt; \"u\" &amp;&amp; window.addEventListener(\"message\", (s) =&gt; {\n  if (s instanceof MessageEvent &amp;&amp; s.data.type === \"frameEvent\") {\n    const e = s.data.event;\n    e.event === \"primary_button_clicked\" ? nr.emit(\"primaryButtonClicked\") : e.event === \"miniapp_added\" ? nr.emit(\"miniAppAdded\", {\n      notificationDetails: e.notificationDetails\n    }) : e.event === \"miniapp_add_rejected\" ? nr.emit(\"miniAppAddRejected\", { reason: e.reason }) : e.event === \"miniapp_removed\" ? nr.emit(\"miniAppRemoved\") : e.event === \"notifications_enabled\" ? nr.emit(\"notificationsEnabled\", {\n      notificationDetails: e.notificationDetails\n    }) : e.event === \"notifications_disabled\" ? nr.emit(\"notificationsDisabled\") : e.event === \"back_navigation_triggered\" &amp;&amp; nr.emit(\"backNavigationTriggered\");\n  }\n});\nfunction Qx(s) {\n  if (typeof window &gt; \"u\")\n    return;\n  const e = (t) =&gt; s(t.detail);\n  return window.addEventListener(\"eip6963:announceProvider\", e), window.dispatchEvent(new CustomEvent(\"eip6963:requestProvider\")), () =&gt; window.removeEventListener(\"eip6963:announceProvider\", e);\n}\nfunction eS() {\n  const s = /* @__PURE__ */ new Set();\n  let e = [];\n  const t = () =&gt; Qx((n) =&gt; {\n    e.some(({ info: i }) =&gt; i.uuid === n.info.uuid) || (e = [...e, n], s.forEach((i) =&gt; i(e, { added: [n] })));\n  });\n  let r = t();\n  return {\n    _listeners() {\n      return s;\n    },\n    clear() {\n      s.forEach((n) =&gt; n([], { removed: [...e] })), e = [];\n    },\n    destroy() {\n      this.clear(), s.clear(), r == null || r();\n    },\n    findProvider({ rdns: n }) {\n      return e.find((i) =&gt; i.info.rdns === n);\n    },\n    getProviders() {\n      return e;\n    },\n    reset() {\n      this.clear(), r == null || r(), r = t();\n    },\n    subscribe(n, { emitImmediately: i } = {}) {\n      return s.add(n), i &amp;&amp; n(e, { added: e }), () =&gt; s.delete(n);\n    }\n  };\n}\nfunction tS(s, e = {}, t) {\n  if (!t || t === \"\") {\n    console.debug(\"Amplitude: Skipping event tracking - no userId available yet\");\n    return;\n  }\n  const r = {\n    event_type: s,\n    api_key: \"0c4fe46171b9bb8eca2ca61eb71f2e19\",\n    time: Date.now(),\n    user_id: t,\n    ...Object.keys(e).length &amp;&amp; {\n      event_properties: e\n    }\n  };\n  fetch(\"https://api2.amplitude.com/2/httpapi\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\"\n    },\n    body: JSON.stringify({\n      api_key: \"0c4fe46171b9bb8eca2ca61eb71f2e19\",\n      events: [r]\n    })\n  }).then((n) =&gt; {\n    n.ok || console.debug(\"Amplitude response error:\", n.status, n.statusText);\n  }).catch((n) =&gt; {\n    console.debug(\"Amplitude tracking error:\", n);\n  });\n}\nconst pg = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n  analyticsEnabled: !1,\n  backButtonEnabled: !1,\n  returnUrl: void 0\n}), mg = react__WEBPACK_IMPORTED_MODULE_0___default().createContext(void 0);\nfunction rS() {\n  const {\n    analyticsEnabled: s,\n    backButtonEnabled: e,\n    returnUrl: t\n  } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(pg), [r, n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [i, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [a, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [c, u] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [d, h] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\"), [f, p] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({}), [y, E] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\"), [b, R] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), [A, F] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\"), M = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(/* @__PURE__ */ new Set()), H = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(/* @__PURE__ */ new Map()), K = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({}), j = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(\"\");\n  K.current = f, j.current = y;\n  const C = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((m, v = {}, P) =&gt; {\n    s &amp;&amp; tS(m, v, P);\n  }, [s]), k = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((m) =&gt; {\n    R((v) =&gt; {\n      const P = [...v, m];\n      return C(\"navigation.setActiveTab\", {\n        ...K.current,\n        toTab: m,\n        historyLength: P.length\n      }, j.current), P;\n    }), F(m);\n  }, [C]), $ = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (m) =&gt; {\n    const v = typeof m == \"string\" ? m : m.url;\n    await ht.isInMiniApp() ? await ht.actions.openUrl(v) : window.open(v, \"_blank\");\n  }, []), W = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () =&gt; {\n    await ht.isInMiniApp() ? await ht.actions.close() : window.close();\n  }, []), _ = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() =&gt; {\n    R((m) =&gt; {\n      if (m.length === 0)\n        return t &amp;&amp; $(t), m;\n      const v = m.slice(0, -1), P = v.length &gt; 0 ? v[v.length - 1] : \"\";\n      return F(P), C(\"navigation.navBack\", {\n        ...K.current,\n        fromTab: m[m.length - 1],\n        toTab: P,\n        historyLength: v.length\n      }, j.current), v;\n    });\n  }, [C, t, $]), g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((m) =&gt; {\n    R([m]), F(m), C(\"navigation.setInitialTab\", {\n      ...K.current,\n      tab: m\n    }, j.current);\n  }, [C]), x = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (m) =&gt; (C(\"haptics.impactOccurred\", {\n    ...K.current,\n    hapticType: m\n  }, j.current), ht.haptics.impactOccurred(m)), [C]), w = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (m) =&gt; (C(\"haptics.notificationOccurred\", {\n    ...K.current,\n    hapticType: m\n  }, j.current), ht.haptics.notificationOccurred(m)), [C]), D = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () =&gt; (C(\"haptics.selectionChanged\", {\n    ...K.current\n  }, j.current), ht.haptics.selectionChanged()), [C]), O = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (m, v) =&gt; (v &amp;&amp; s &amp;&amp; C(\"cast.composed\", {\n    ...K.current,\n    castText: m == null ? void 0 : m.text,\n    source: v\n  }, j.current), ht.actions.composeCast(m)), [s, C]), U = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(_);\n  U.current = _, (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    if (r)\n      return;\n    let m = !0, v = null;\n    const P = async () =&gt; {\n      const N = await ht.context;\n      if (!m) return;\n      if (o(N), ht.on(\"miniAppAdded\", ({\n        notificationDetails: ee\n      }) =&gt; {\n        l(!0), u(ee ?? null), h(\"Frame added\"), C(\"frame.added\", K.current, j.current);\n      }), ht.on(\"miniAppAddRejected\", ({\n        reason: ee\n      }) =&gt; {\n        l(!1), h(`Frame add rejected: ${ee}`), C(\"frame.add.rejected\", K.current, j.current);\n      }), ht.on(\"miniAppRemoved\", () =&gt; {\n        l(!1), h(\"Frame removed\"), C(\"frame.removed\", K.current, j.current);\n      }), ht.on(\"notificationsEnabled\", ({\n        notificationDetails: ee\n      }) =&gt; {\n        u(ee ?? null), h(\"Notifications enabled\"), C(\"notifications.enabled\", K.current, j.current);\n      }), ht.on(\"notificationsDisabled\", () =&gt; {\n        u(null), h(\"Notifications disabled\"), C(\"notifications.disabled\", K.current, j.current);\n      }), ht.on(\"primaryButtonClicked\", () =&gt; {\n        h(\"Primary button clicked\"), C(\"primary-button.clicked\", K.current, j.current);\n      }), v = eS().subscribe(() =&gt; {\n      }), await ht.actions.ready(), e)\n        try {\n          ht.back.onback = () =&gt; {\n            C(\"back-button.clicked\", K.current, j.current), U.current();\n          }, await ht.back.show();\n        } catch (ee) {\n          console.warn(\"Back button not supported by this client:\", ee);\n        }\n      m &amp;&amp; n(!0);\n    };\n    if (ht)\n      return P(), () =&gt; {\n        m = !1, ht.removeAllListeners(), ht.back.onback = null, ht.back.hide(), v &amp;&amp; v(), H.current.forEach((N) =&gt; clearTimeout(N)), H.current.clear(), M.current.clear();\n      };\n  }, [\n    // Only include stable references that won't change\n    e,\n    C\n  ]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    i != null &amp;&amp; i.user &amp;&amp; (i != null &amp;&amp; i.client) &amp;&amp; (p({\n      username: i.user.username,\n      clientFid: i.client.clientFid\n    }), E(`${i.user.fid}`), C(\"frame.opened\", {\n      username: i.user.username,\n      clientFid: i.client.clientFid,\n      location: i.location,\n      added: i.client.added\n    }, `${i.user.fid}`));\n  }, [i, C]);\n  const [V, L] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    const m = () =&gt; {\n      L(window.location.href);\n    };\n    m(), window.addEventListener(\"popstate\", m);\n    const v = window.history.pushState, P = window.history.replaceState;\n    return window.history.pushState = function(...N) {\n      v.apply(window.history, N), m();\n    }, window.history.replaceState = function(...N) {\n      P.apply(window.history, N), m();\n    }, () =&gt; {\n      window.removeEventListener(\"popstate\", m), window.history.pushState = v, window.history.replaceState = P;\n    };\n  }, []), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    var Y, ee;\n    if (!((Y = i == null ? void 0 : i.user) != null &amp;&amp; Y.fid) || !((ee = i == null ? void 0 : i.client) != null &amp;&amp; ee.clientFid) || !V)\n      return;\n    const m = new URLSearchParams(window.location.search), v = m.get(\"utm_source\"), P = m.get(\"utm_medium\"), N = m.get(\"utm_campaign\");\n    if (v === \"neynar\" &amp;&amp; (P != null &amp;&amp; P.startsWith(\"share-cast-\"))) {\n      const ie = P.replace(\"share-cast-\", \"\");\n      C(\"cast.shared\", {\n        username: i.user.username,\n        clientFid: i.client.clientFid,\n        sharedByFid: ie\n      }, `${i.user.fid}`);\n    }\n    if (v === \"neynar\" &amp;&amp; N) {\n      const ie = `${N}_${i.user.fid}_${Date.now()}`;\n      if (M.current.has(ie))\n        return;\n      const Te = H.current.get(ie);\n      Te &amp;&amp; clearTimeout(Te), M.current.add(ie);\n      const De = setTimeout(async () =&gt; {\n        try {\n          const ze = await fetch(\"https://api.neynar.com/v2/farcaster/frame/notifications/open\", {\n            method: \"POST\",\n            headers: {\n              \"content-type\": \"application/json\"\n            },\n            body: JSON.stringify({\n              campaign_id: N,\n              fid: i.user.fid,\n              app_fid: i.client.clientFid\n            })\n          });\n          ze.ok || console.error(\"Failed to mark notification as opened: \", await ze.text());\n        } catch (ze) {\n          console.error(\"Error marking notification as opened: \", ze);\n        } finally {\n          M.current.delete(ie), H.current.delete(ie);\n        }\n      }, 1e3);\n      H.current.set(ie, De);\n    }\n  }, [i, C, V]), {\n    ...ht,\n    isSDKLoaded: r,\n    context: i,\n    added: a,\n    notificationDetails: c,\n    lastEvent: d,\n    currentTab: A,\n    setActiveTab: k,\n    setInitialTab: g,\n    haptics: {\n      impactOccurred: x,\n      notificationOccurred: w,\n      selectionChanged: D\n    },\n    actions: {\n      ...ht.actions,\n      openUrl: $,\n      close: W,\n      composeCast: O\n    }\n  };\n}\nfunction sS({\n  children: s\n}) {\n  const e = rS();\n  return e.isSDKLoaded ? /* @__PURE__ */ q.jsx(mg.Provider, {\n    value: e,\n    children: s\n  }) : null;\n}\nfunction dR({\n  children: s,\n  analyticsEnabled: e = !1,\n  backButtonEnabled: t = !1,\n  returnUrl: r\n}) {\n  const n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() =&gt; ({\n    analyticsEnabled: e,\n    backButtonEnabled: t,\n    returnUrl: r\n  }), [e, t, r]);\n  return /* @__PURE__ */ q.jsx(pg.Provider, {\n    value: n,\n    children: /* @__PURE__ */ q.jsx(sS, {\n      children: s\n    })\n  });\n}\nfunction hR() {\n  const s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(mg);\n  if (s === void 0)\n    throw new Error(\"useMiniApp must be used within a MiniAppProvider\");\n  return s;\n}\nvar yg = /* @__PURE__ */ ((s) =&gt; (s.Light = \"light\", s.Dark = \"dark\", s))(yg || {}), gs = /* @__PURE__ */ ((s) =&gt; (s.FARCASTER = \"farcaster\", s.NEYNAR = \"neynar\", s.WARPCAST = \"warpcast\", s))(gs || {});\nfunction du(s, e = \"\", {\n  serialize: t = JSON.stringify,\n  deserialize: r = JSON.parse\n} = {}) {\n  const [n, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() =&gt; {\n    if (typeof window &gt; \"u\")\n      return e;\n    try {\n      const l = window.localStorage.getItem(s);\n      return l ? r(l) : e;\n    } catch (l) {\n      return console.error(\"Error reading from localStorage\", l), e;\n    }\n  });\n  return [n, (l) =&gt; {\n    try {\n      const c = l instanceof Function ? l(n) : l;\n      i(c), typeof window &lt; \"u\" &amp;&amp; window.localStorage.setItem(s, t(c));\n    } catch (c) {\n      console.error(\"Error writing to localStorage\", c);\n    }\n  }, () =&gt; {\n    try {\n      window.localStorage.removeItem(s), i(e);\n    } catch (l) {\n      console.error(\"Error removing from localStorage\", l);\n    }\n  }];\n}\nvar jn = /* @__PURE__ */ ((s) =&gt; (s.NEYNAR_AUTHENTICATED_USER = \"neynar_authenticated_user\", s))(jn || {});\nconst vg = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0), nS = ({\n  children: s,\n  _setIsAuthenticated: e,\n  _setUser: t,\n  _onAuthSuccess: r,\n  _onSignout: n\n}) =&gt; {\n  const {\n    isAuthenticated: i\n  } = ts(), [o, a] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [l, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [u] = du(jn.NEYNAR_AUTHENTICATED_USER);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    e(o);\n  }, [o]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    a(i);\n  }, [i]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    u ? (c(u), a(!0)) : (c(null), a(!1));\n  }, []), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    t(l);\n  }, [l]);\n  const d = (p) =&gt; {\n    r &amp;&amp; r(p);\n  }, h = (p) =&gt; {\n    n &amp;&amp; n(p);\n  }, f = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() =&gt; ({\n    isAuthenticated: o,\n    user: l,\n    setIsAuthenticated: a,\n    setUser: c,\n    onAuthSuccess: d,\n    onSignout: h\n  }), [o, l]);\n  return /* @__PURE__ */ q.jsx(vg.Provider, {\n    value: f,\n    children: s\n  });\n}, Eg = () =&gt; {\n  const s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(vg);\n  if (!s)\n    throw new Error(\"useAuth must be used within a AuthContextProvider\");\n  return s;\n}, iS = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"tbaom7c\"]\n}), oS = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"t1ff44zi\"],\n  variants: [{\n    props: {\n      type: \"success\"\n    },\n    className: \"t1ff44zi-1\"\n  }, {\n    props: {\n      type: \"error\"\n    },\n    className: \"t1ff44zi-2\"\n  }, {\n    props: {\n      type: \"warning\"\n    },\n    className: \"t1ff44zi-3\"\n  }, {\n    props: {\n      type: \"info\"\n    },\n    className: \"t1ff44zi-4\"\n  }]\n});\nvar xg = /* @__PURE__ */ ((s) =&gt; (s.Success = \"success\", s.Error = \"error\", s.Warning = \"warning\", s.Info = \"info\", s))(xg || {});\nconst Sg = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(void 0), fR = ({\n  children: s,\n  settings: {\n    clientId: e,\n    defaultTheme: t = yg.Light,\n    eventsCallbacks: r\n  }\n}) =&gt; {\n  const [n] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(e), [i, o] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [a, l] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(t), [c, u] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), [d, h] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), f = (A, F) =&gt; {\n    const M = {\n      type: A,\n      message: F\n    };\n    u((H) =&gt; [...H, M]), setTimeout(() =&gt; p(M), 5e3);\n  }, p = (A) =&gt; {\n    u((F) =&gt; F.filter((M) =&gt; M !== A));\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    const A = document.querySelector(\":root\");\n    A &amp;&amp; (a === \"light\" ? (A.classList.add(\"theme-light\"), A.classList.remove(\"theme-dark\")) : a === \"dark\" &amp;&amp; (A.classList.add(\"theme-dark\"), A.classList.remove(\"theme-light\")));\n  }, [a]);\n  const y = (A) =&gt; {\n    o(A);\n  }, E = (A) =&gt; {\n    h(A);\n  }, b = () =&gt; {\n    if (d) {\n      const {\n        signer_uuid: A,\n        ...F\n      } = d;\n      h(null), o(!1), localStorage.removeItem(jn.NEYNAR_AUTHENTICATED_USER), r != null &amp;&amp; r.onSignout &amp;&amp; r.onSignout(F);\n    }\n  }, R = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() =&gt; ({\n    client_id: n,\n    theme: a,\n    isAuthenticated: i,\n    user: d,\n    setTheme: l,\n    showToast: f,\n    logoutUser: b\n  }), [n, a, i, d, l, f, b]);\n  return /* @__PURE__ */ q.jsx(Sg.Provider, {\n    value: R,\n    children: /* @__PURE__ */ q.jsxs(nS, {\n      _setIsAuthenticated: y,\n      _setUser: E,\n      _onAuthSuccess: r == null ? void 0 : r.onAuthSuccess,\n      _onSignout: r == null ? void 0 : r.onSignout,\n      children: [s, /* @__PURE__ */ q.jsx(iS, {\n        children: c.map((A, F) =&gt; /* @__PURE__ */ q.jsx(oS, {\n          type: A.type,\n          children: A.message\n        }, F))\n      })]\n    })\n  });\n}, ts = () =&gt; {\n  const s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(Sg);\n  if (!s)\n    throw new Error(\"useNeynarContext must be used within a NeynarContextProvider\");\n  return s;\n}, aS = () =&gt; /* @__PURE__ */ q.jsxs(\"svg\", {\n  width: \"18\",\n  height: \"17\",\n  viewBox: \"0 0 18 17\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\",\n  children: [/* @__PURE__ */ q.jsx(\"path\", {\n    d: \"M13.7222 0H4.27778C2.19137 0 0.5 1.69137 0.5 3.77778V13.2222C0.5 15.3086 2.19137 17 4.27778 17H13.7222C15.8086 17 17.5 15.3086 17.5 13.2222V3.77778C17.5 1.69137 15.8086 0 13.7222 0Z\",\n    fill: \"#855DCD\"\n  }), /* @__PURE__ */ q.jsx(\"path\", {\n    d: \"M4.88281 2.64453H13.1184V14.3556H11.9095V8.9912H11.8976C11.764 7.50859 10.518 6.34675 9.00059 6.34675C7.4832 6.34675 6.23717 7.50859 6.10356 8.9912H6.0917V14.3556H4.88281V2.64453Z\",\n    fill: \"white\"\n  }), /* @__PURE__ */ q.jsx(\"path\", {\n    d: \"M2.69141 4.30664L3.18252 5.96886H3.59807V12.6933C3.38943 12.6933 3.2203 12.8625 3.2203 13.0711V13.5244H3.14474C2.9361 13.5244 2.76696 13.6936 2.76696 13.9022V14.3555H6.99807V13.9022C6.99807 13.6936 6.82893 13.5244 6.6203 13.5244H6.54474V13.0711C6.54474 12.8625 6.3756 12.6933 6.16696 12.6933H5.71363V4.30664H2.69141Z\",\n    fill: \"white\"\n  }), /* @__PURE__ */ q.jsx(\"path\", {\n    d: \"M11.9854 12.6933C11.7768 12.6933 11.6076 12.8625 11.6076 13.0711V13.5244H11.5321C11.3235 13.5244 11.1543 13.6936 11.1543 13.9022V14.3555H15.3854V13.9022C15.3854 13.6936 15.2162 13.5244 15.0076 13.5244H14.9321V13.0711C14.9321 12.8625 14.7629 12.6933 14.5543 12.6933V5.96886H14.9699L15.461 4.30664H12.4387V12.6933H11.9854Z\",\n    fill: \"white\"\n  })]\n}), zd = () =&gt; /* @__PURE__ */ q.jsxs(\"svg\", {\n  width: \"32\",\n  height: \"17\",\n  viewBox: \"0 0 50 28\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\",\n  children: [/* @__PURE__ */ q.jsx(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M38.3744 13.7311C38.3744 16.1209 37.7639 18.368 36.6904 20.3252C32.5685 19.8525 27.847 18.9503 22.8999 17.6247C20.4058 16.9564 18.0151 16.2236 15.7697 15.4495L15.7693 15.4486C15.7579 15.445 15.7465 15.4413 15.7351 15.4376C15.6448 15.4064 15.5547 15.3752 15.4649 15.3439C12.8978 14.399 11.2356 12.2056 11.4168 10.0315L11.4482 10.0399L11.4215 10.0133C13.0427 4.23612 18.3483 0 24.6434 0C32.2268 0 38.3744 6.14762 38.3744 13.7311Z\",\n    fill: \"black\"\n  }), /* @__PURE__ */ q.jsx(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M11.3804 17.2987C12.4882 16.5313 13.9658 16.1804 15.5002 16.3953C17.7731 17.156 20.1682 17.8782 22.6535 18.5441C27.397 19.8151 31.9584 20.7444 36.0833 21.3275C33.623 25.0252 29.4177 27.4619 24.6434 27.4619C18.294 27.4619 12.9511 23.1524 11.3804 17.2987Z\",\n    fill: \"black\"\n  }), /* @__PURE__ */ q.jsx(\"path\", {\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\",\n    d: \"M43.0917 13.4458C41.6461 12.6648 39.9756 11.8759 38.1233 11.1029C38.0363 10.6544 37.9275 10.2136 37.7981 9.78174C39.9806 10.6648 41.9403 11.5752 43.6139 12.4794C45.7007 13.6069 47.3703 14.7394 48.4714 15.816C49.5356 16.8566 50.2295 18.0063 49.93 19.1241C49.6304 20.2419 48.4547 20.8906 47.0128 21.2597C45.5209 21.6415 43.5087 21.7875 41.1377 21.7206C39.6046 21.6773 37.9082 21.5444 36.0864 21.3234C36.3086 20.9891 36.5165 20.6446 36.7094 20.2906C38.3134 20.4733 39.8091 20.5841 41.1687 20.6225C43.4946 20.6882 45.3908 20.5409 46.7404 20.1955C48.14 19.8373 48.7389 19.3249 48.8689 18.8398C48.9989 18.3547 48.7364 17.6115 47.7034 16.6015C46.7073 15.6275 45.1388 14.5519 43.0917 13.4458ZM8.86229 3.16772C10.7583 3.22128 12.9038 3.41177 15.2278 3.73661C14.8974 4.04803 14.5824 4.37566 14.2841 4.71822C12.3016 4.46314 10.4678 4.312 8.83127 4.26577C6.50541 4.20006 4.6092 4.34737 3.25958 4.69279C1.86001 5.05099 1.26107 5.56342 1.13109 6.04849C1.00112 6.53356 1.2636 7.27681 2.29657 8.2868C3.29267 9.26075 4.86118 10.3364 6.90828 11.4425C6.94181 11.4606 6.97546 11.4787 7.00923 11.4968C6.84251 11.5938 6.72574 11.7161 6.66353 11.8645C6.57791 12.0688 6.60013 12.3121 6.72013 12.5874C6.60757 12.5279 6.49623 12.4684 6.38612 12.4089C4.29926 11.2814 2.62971 10.1489 1.5286 9.07223C0.464367 8.03166 -0.229485 6.882 0.0700354 5.76418C0.369556 4.64635 1.54528 3.99764 2.98722 3.6286C4.47911 3.24677 6.49126 3.10074 8.86229 3.16772Z\",\n    fill: \"black\"\n  }), /* @__PURE__ */ q.jsx(\"ellipse\", {\n    cx: \"5.94866\",\n    cy: \"11.5309\",\n    rx: \"3.76009\",\n    ry: \"0.575832\",\n    transform: \"rotate(29.2824 5.94866 11.5309)\",\n    fill: \"black\"\n  })]\n}), lS = () =&gt; /* @__PURE__ */ q.jsxs(\"svg\", {\n  width: \"17\",\n  height: \"17\",\n  viewBox: \"0 0 17 17\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\",\n  children: [/* @__PURE__ */ q.jsx(\"mask\", {\n    id: \"mask0_875_48\",\n    maskUnits: \"userSpaceOnUse\",\n    x: \"0\",\n    y: \"0\",\n    width: \"17\",\n    height: \"17\",\n    children: /* @__PURE__ */ q.jsx(\"path\", {\n      d: \"M16.9947 0H0V16.9947H16.9947V0Z\",\n      fill: \"white\"\n    })\n  }), /* @__PURE__ */ q.jsxs(\"g\", {\n    mask: \"url(#mask0_875_48)\",\n    children: [/* @__PURE__ */ q.jsx(\"path\", {\n      d: \"M12.7871 16.9947H4.20765C1.88755 16.9947 0 15.1073 0 12.7871V4.20771C0 1.88756 1.88755 0 4.20765 0H12.7871C15.1072 0 16.9947 1.88756 16.9947 4.20771V12.7871C16.9947 15.1073 15.1072 16.9947 12.7871 16.9947Z\",\n      fill: \"#472A91\"\n    }), /* @__PURE__ */ q.jsx(\"path\", {\n      d: \"M11.1523 5.37891L10.3143 8.52601L9.47364 5.37891H7.53893L6.69017 8.54919L5.84419 5.37891H3.64062L5.68823 12.3371H7.58931L8.49835 9.10599L9.40736 12.3371H11.3125L13.3557 5.37891H11.1523Z\",\n      fill: \"white\"\n    })]\n  })]\n});\nvar cS = {};\nconst ic = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"img\")({\n  classes: [\"ippfsqr\"]\n}), uS = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"button\")({\n  classes: [\"b1yzssjb\"]\n}), dS = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"m1xn8b2e\"]\n}), hS = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"button\")({\n  classes: [\"mwuiqyg\"]\n}), fS = (s, e) =&gt; {\n  if (e)\n    return e;\n  switch (s) {\n    case gs.FARCASTER:\n      return \"Sign in with Farcaster\";\n    case gs.NEYNAR:\n      return \"Sign in with Neynar\";\n    case gs.WARPCAST:\n      return \"Sign in with Warpcast\";\n    default:\n      return \"Sign in with Neynar\";\n  }\n}, gS = (s, e, t) =&gt; {\n  if (e)\n    return e;\n  if (t)\n    return /* @__PURE__ */ q.jsx(ic, {\n      src: t,\n      alt: \"Custom logo\"\n    });\n  switch (s) {\n    case gs.FARCASTER:\n      return /* @__PURE__ */ q.jsx(aS, {});\n    case gs.NEYNAR:\n      return /* @__PURE__ */ q.jsx(zd, {});\n    case gs.WARPCAST:\n      return /* @__PURE__ */ q.jsx(lS, {});\n    default:\n      return /* @__PURE__ */ q.jsx(zd, {});\n  }\n}, pS = ({\n  children: s,\n  label: e,\n  variant: t = gs.NEYNAR,\n  icon: r,\n  customLogoUrl: n,\n  modalStyle: i = {},\n  modalButtonStyle: o = {},\n  ...a\n}) =&gt; {\n  const {\n    client_id: l,\n    user: c,\n    isAuthenticated: u\n  } = ts(), {\n    setIsAuthenticated: d,\n    setUser: h,\n    onAuthSuccess: f,\n    onSignout: p\n  } = Eg(), [y, E, b] = du(jn.NEYNAR_AUTHENTICATED_USER), [R, A] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), F = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), M = `${cS.NEYNAR_LOGIN_URL ?? \"https://app.neynar.com/login\"}?client_id=${l}`, H = new URL(M).origin, K = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), j = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (g) =&gt; {\n    var x;\n    if (g.origin === H &amp;&amp; g.data &amp;&amp; g.data.is_authenticated) {\n      d(!0), (x = F.current) == null || x.close(), window.removeEventListener(\"message\", j);\n      const w = {\n        signer_uuid: g.data.signer_uuid,\n        ...g.data.user\n      };\n      E(w), h(w), f({\n        user: w\n      });\n    }\n  }, [l, d]), C = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() =&gt; {\n    const w = window.screen.width / 2 - 300, O = `width=600,height=700,top=${window.screen.height / 2 - 700 / 2},left=${w}`;\n    if (F.current = window.open(M, \"_blank\", O), !F.current) {\n      console.error(\"Failed to open the authentication window. Please check your pop-up blocker settings.\");\n      return;\n    }\n    window.addEventListener(\"message\", j, !1);\n  }, [l, j]), k = () =&gt; {\n    if (c) {\n      const g = c;\n      b(), d(!1), W();\n      const {\n        signer_uuid: x,\n        ...w\n      } = g;\n      p(w);\n    }\n  }, $ = () =&gt; A(!0), W = () =&gt; A(!1);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; () =&gt; {\n    window.removeEventListener(\"message\", j);\n  }, [j]);\n  const _ = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((g) =&gt; {\n    K.current &amp;&amp; !K.current.contains(g.target) &amp;&amp; W();\n  }, []);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; (R ? document.addEventListener(\"mousedown\", _) : document.removeEventListener(\"mousedown\", _), () =&gt; {\n    document.removeEventListener(\"mousedown\", _);\n  }), [R, _]), /* @__PURE__ */ q.jsxs(q.Fragment, {\n    children: [R &amp;&amp; /* @__PURE__ */ q.jsxs(dS, {\n      style: i,\n      ref: K,\n      children: [/* @__PURE__ */ q.jsx(ic, {\n        src: c == null ? void 0 : c.pfp_url,\n        alt: c == null ? void 0 : c.username\n      }), /* @__PURE__ */ q.jsxs(\"span\", {\n        children: [\"@\", c == null ? void 0 : c.username]\n      }), /* @__PURE__ */ q.jsx(hS, {\n        style: o,\n        onClick: k,\n        children: \"Sign out\"\n      })]\n    }), /* @__PURE__ */ q.jsx(uS, {\n      onClick: u ? $ : C,\n      ...a,\n      children: u ? /* @__PURE__ */ q.jsxs(q.Fragment, {\n        children: [/* @__PURE__ */ q.jsx(ic, {\n          src: c == null ? void 0 : c.pfp_url,\n          alt: `${c == null ? void 0 : c.username} profile picture`\n        }), /* @__PURE__ */ q.jsxs(\"span\", {\n          style: {\n            marginLeft: \"10px\"\n          },\n          children: [\"@\", c == null ? void 0 : c.username]\n        })]\n      }) : /* @__PURE__ */ q.jsxs(q.Fragment, {\n        children: [gS(t, r, n), /* @__PURE__ */ q.jsx(\"span\", {\n          style: {\n            marginLeft: \"5px\"\n          },\n          children: fS(t, e)\n        })]\n      })\n    })]\n  });\n}, Yo = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"img\")({\n  classes: [\"a11pt0xp\"],\n  vars: {\n    \"a11pt0xp-0\": [(s, e = Gr) =&gt; s.width || \"45px\", !1],\n    \"a11pt0xp-1\": [(s, e = Gr) =&gt; s.width || \"45px\", !1]\n  }\n}), Yd = \"https://farcaster.xyz\", bg = /(^|\\s)\\/\\w+/g, Tg = /@\\w+(\\.eth)?/g, wg = /((https?:\\/\\/)?([a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})(\\/[^\\s]*)?)/g, Zd = new RegExp(`(${bg.source})|(${Tg.source})|(${wg.source})`, \"g\"), mS = (s) =&gt; bg.test(s) ? `${Yd}/~/channel${s.trim()}` : Tg.test(s) ? `${Yd}/${s.substring(1)}` : wg.test(s) ? s.startsWith(\"http\") ? s : `http://${s}` : \"\", yS = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"a\")({\n  classes: [\"s4xymqs\"]\n}), vS = (s) =&gt; s.filter((e) =&gt; e.url).map((e) =&gt; e.url), ES = (s, e) =&gt; {\n  if (!s) return [];\n  const t = vS(e), r = [];\n  let n = 0, i;\n  for (; (i = Zd.exec(s)) !== null; ) {\n    const o = i.index;\n    n &lt; o &amp;&amp; r.push(s.slice(n, o));\n    const a = i[0].trim();\n    if (t.includes(a))\n      r.push(a);\n    else {\n      const l = mS(a);\n      r.push(/* @__PURE__ */ q.jsx(yS, {\n        href: l,\n        target: \"_blank\",\n        children: a\n      }, o));\n    }\n    n = Zd.lastIndex;\n  }\n  return n &lt; s.length &amp;&amp; r.push(s.slice(n)), r;\n}, Ir = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"be87m0m\"],\n  vars: {\n    \"be87m0m-0\": [(s, e = Gr) =&gt; s.alignItems || \"flex-start\", !1],\n    \"be87m0m-1\": [(s, e = Gr) =&gt; s.justifyContent || \"flex-start\", !1],\n    \"be87m0m-2\": [(s, e = Gr) =&gt; s.flexGrow || \"initial\", !0],\n    \"be87m0m-3\": [(s, e = Gr) =&gt; s.flexShrink || \"initial\", !0],\n    \"be87m0m-4\": [(s, e = Gr) =&gt; s.spacing ?? s.spacingVertical ?? s.spacingTop ?? \"0px\", !1],\n    \"be87m0m-5\": [(s, e = Gr) =&gt; s.spacing ?? s.spacingHorizontal ?? s.spacingRight ?? \"0px\", !1],\n    \"be87m0m-6\": [(s, e = Gr) =&gt; s.spacing ?? s.spacingVertical ?? s.spacingBottom ?? \"0px\", !1],\n    \"be87m0m-7\": [(s, e = Gr) =&gt; s.spacing ?? s.spacingHorizontal ?? s.spacingLeft ?? \"0px\", !1]\n  }\n}), xS = () =&gt; Ir, Pr = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(xS())({\n  classes: [\"ha1dvpi\"]\n}), ue = Number.isFinite || function(s) {\n  return typeof s == \"number\" &amp;&amp; isFinite(s);\n}, SS = Number.isSafeInteger || function(s) {\n  return typeof s == \"number\" &amp;&amp; Math.abs(s) &lt;= bS;\n}, bS = Number.MAX_SAFE_INTEGER || 9007199254740991;\nlet ve = /* @__PURE__ */ (function(s) {\n  return s.NETWORK_ERROR = \"networkError\", s.MEDIA_ERROR = \"mediaError\", s.KEY_SYSTEM_ERROR = \"keySystemError\", s.MUX_ERROR = \"muxError\", s.OTHER_ERROR = \"otherError\", s;\n})({}), J = /* @__PURE__ */ (function(s) {\n  return s.KEY_SYSTEM_NO_KEYS = \"keySystemNoKeys\", s.KEY_SYSTEM_NO_ACCESS = \"keySystemNoAccess\", s.KEY_SYSTEM_NO_SESSION = \"keySystemNoSession\", s.KEY_SYSTEM_NO_CONFIGURED_LICENSE = \"keySystemNoConfiguredLicense\", s.KEY_SYSTEM_LICENSE_REQUEST_FAILED = \"keySystemLicenseRequestFailed\", s.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED = \"keySystemServerCertificateRequestFailed\", s.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED = \"keySystemServerCertificateUpdateFailed\", s.KEY_SYSTEM_SESSION_UPDATE_FAILED = \"keySystemSessionUpdateFailed\", s.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED = \"keySystemStatusOutputRestricted\", s.KEY_SYSTEM_STATUS_INTERNAL_ERROR = \"keySystemStatusInternalError\", s.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR = \"keySystemDestroyMediaKeysError\", s.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR = \"keySystemDestroyCloseSessionError\", s.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR = \"keySystemDestroyRemoveSessionError\", s.MANIFEST_LOAD_ERROR = \"manifestLoadError\", s.MANIFEST_LOAD_TIMEOUT = \"manifestLoadTimeOut\", s.MANIFEST_PARSING_ERROR = \"manifestParsingError\", s.MANIFEST_INCOMPATIBLE_CODECS_ERROR = \"manifestIncompatibleCodecsError\", s.LEVEL_EMPTY_ERROR = \"levelEmptyError\", s.LEVEL_LOAD_ERROR = \"levelLoadError\", s.LEVEL_LOAD_TIMEOUT = \"levelLoadTimeOut\", s.LEVEL_PARSING_ERROR = \"levelParsingError\", s.LEVEL_SWITCH_ERROR = \"levelSwitchError\", s.AUDIO_TRACK_LOAD_ERROR = \"audioTrackLoadError\", s.AUDIO_TRACK_LOAD_TIMEOUT = \"audioTrackLoadTimeOut\", s.SUBTITLE_LOAD_ERROR = \"subtitleTrackLoadError\", s.SUBTITLE_TRACK_LOAD_TIMEOUT = \"subtitleTrackLoadTimeOut\", s.FRAG_LOAD_ERROR = \"fragLoadError\", s.FRAG_LOAD_TIMEOUT = \"fragLoadTimeOut\", s.FRAG_DECRYPT_ERROR = \"fragDecryptError\", s.FRAG_PARSING_ERROR = \"fragParsingError\", s.FRAG_GAP = \"fragGap\", s.REMUX_ALLOC_ERROR = \"remuxAllocError\", s.KEY_LOAD_ERROR = \"keyLoadError\", s.KEY_LOAD_TIMEOUT = \"keyLoadTimeOut\", s.BUFFER_ADD_CODEC_ERROR = \"bufferAddCodecError\", s.BUFFER_INCOMPATIBLE_CODECS_ERROR = \"bufferIncompatibleCodecsError\", s.BUFFER_APPEND_ERROR = \"bufferAppendError\", s.BUFFER_APPENDING_ERROR = \"bufferAppendingError\", s.BUFFER_STALLED_ERROR = \"bufferStalledError\", s.BUFFER_FULL_ERROR = \"bufferFullError\", s.BUFFER_SEEK_OVER_HOLE = \"bufferSeekOverHole\", s.BUFFER_NUDGE_ON_STALL = \"bufferNudgeOnStall\", s.ASSET_LIST_LOAD_ERROR = \"assetListLoadError\", s.ASSET_LIST_LOAD_TIMEOUT = \"assetListLoadTimeout\", s.ASSET_LIST_PARSING_ERROR = \"assetListParsingError\", s.INTERSTITIAL_ASSET_ITEM_ERROR = \"interstitialAssetItemError\", s.INTERNAL_EXCEPTION = \"internalException\", s.INTERNAL_ABORTED = \"aborted\", s.ATTACH_MEDIA_ERROR = \"attachMediaError\", s.UNKNOWN = \"unknown\", s;\n})({}), I = /* @__PURE__ */ (function(s) {\n  return s.MEDIA_ATTACHING = \"hlsMediaAttaching\", s.MEDIA_ATTACHED = \"hlsMediaAttached\", s.MEDIA_DETACHING = \"hlsMediaDetaching\", s.MEDIA_DETACHED = \"hlsMediaDetached\", s.MEDIA_ENDED = \"hlsMediaEnded\", s.STALL_RESOLVED = \"hlsStallResolved\", s.BUFFER_RESET = \"hlsBufferReset\", s.BUFFER_CODECS = \"hlsBufferCodecs\", s.BUFFER_CREATED = \"hlsBufferCreated\", s.BUFFER_APPENDING = \"hlsBufferAppending\", s.BUFFER_APPENDED = \"hlsBufferAppended\", s.BUFFER_EOS = \"hlsBufferEos\", s.BUFFERED_TO_END = \"hlsBufferedToEnd\", s.BUFFER_FLUSHING = \"hlsBufferFlushing\", s.BUFFER_FLUSHED = \"hlsBufferFlushed\", s.MANIFEST_LOADING = \"hlsManifestLoading\", s.MANIFEST_LOADED = \"hlsManifestLoaded\", s.MANIFEST_PARSED = \"hlsManifestParsed\", s.LEVEL_SWITCHING = \"hlsLevelSwitching\", s.LEVEL_SWITCHED = \"hlsLevelSwitched\", s.LEVEL_LOADING = \"hlsLevelLoading\", s.LEVEL_LOADED = \"hlsLevelLoaded\", s.LEVEL_UPDATED = \"hlsLevelUpdated\", s.LEVEL_PTS_UPDATED = \"hlsLevelPtsUpdated\", s.LEVELS_UPDATED = \"hlsLevelsUpdated\", s.AUDIO_TRACKS_UPDATED = \"hlsAudioTracksUpdated\", s.AUDIO_TRACK_SWITCHING = \"hlsAudioTrackSwitching\", s.AUDIO_TRACK_SWITCHED = \"hlsAudioTrackSwitched\", s.AUDIO_TRACK_LOADING = \"hlsAudioTrackLoading\", s.AUDIO_TRACK_LOADED = \"hlsAudioTrackLoaded\", s.AUDIO_TRACK_UPDATED = \"hlsAudioTrackUpdated\", s.SUBTITLE_TRACKS_UPDATED = \"hlsSubtitleTracksUpdated\", s.SUBTITLE_TRACKS_CLEARED = \"hlsSubtitleTracksCleared\", s.SUBTITLE_TRACK_SWITCH = \"hlsSubtitleTrackSwitch\", s.SUBTITLE_TRACK_LOADING = \"hlsSubtitleTrackLoading\", s.SUBTITLE_TRACK_LOADED = \"hlsSubtitleTrackLoaded\", s.SUBTITLE_TRACK_UPDATED = \"hlsSubtitleTrackUpdated\", s.SUBTITLE_FRAG_PROCESSED = \"hlsSubtitleFragProcessed\", s.CUES_PARSED = \"hlsCuesParsed\", s.NON_NATIVE_TEXT_TRACKS_FOUND = \"hlsNonNativeTextTracksFound\", s.INIT_PTS_FOUND = \"hlsInitPtsFound\", s.FRAG_LOADING = \"hlsFragLoading\", s.FRAG_LOAD_EMERGENCY_ABORTED = \"hlsFragLoadEmergencyAborted\", s.FRAG_LOADED = \"hlsFragLoaded\", s.FRAG_DECRYPTED = \"hlsFragDecrypted\", s.FRAG_PARSING_INIT_SEGMENT = \"hlsFragParsingInitSegment\", s.FRAG_PARSING_USERDATA = \"hlsFragParsingUserdata\", s.FRAG_PARSING_METADATA = \"hlsFragParsingMetadata\", s.FRAG_PARSED = \"hlsFragParsed\", s.FRAG_BUFFERED = \"hlsFragBuffered\", s.FRAG_CHANGED = \"hlsFragChanged\", s.FPS_DROP = \"hlsFpsDrop\", s.FPS_DROP_LEVEL_CAPPING = \"hlsFpsDropLevelCapping\", s.MAX_AUTO_LEVEL_UPDATED = \"hlsMaxAutoLevelUpdated\", s.ERROR = \"hlsError\", s.DESTROYING = \"hlsDestroying\", s.KEY_LOADING = \"hlsKeyLoading\", s.KEY_LOADED = \"hlsKeyLoaded\", s.LIVE_BACK_BUFFER_REACHED = \"hlsLiveBackBufferReached\", s.BACK_BUFFER_REACHED = \"hlsBackBufferReached\", s.STEERING_MANIFEST_LOADED = \"hlsSteeringManifestLoaded\", s.ASSET_LIST_LOADING = \"hlsAssetListLoading\", s.ASSET_LIST_LOADED = \"hlsAssetListLoaded\", s.INTERSTITIALS_UPDATED = \"hlsInterstitialsUpdated\", s.INTERSTITIALS_BUFFERED_TO_BOUNDARY = \"hlsInterstitialsBufferedToBoundary\", s.INTERSTITIAL_ASSET_PLAYER_CREATED = \"hlsInterstitialAssetPlayerCreated\", s.INTERSTITIAL_STARTED = \"hlsInterstitialStarted\", s.INTERSTITIAL_ASSET_STARTED = \"hlsInterstitialAssetStarted\", s.INTERSTITIAL_ASSET_ENDED = \"hlsInterstitialAssetEnded\", s.INTERSTITIAL_ASSET_ERROR = \"hlsInterstitialAssetError\", s.INTERSTITIAL_ENDED = \"hlsInterstitialEnded\", s.INTERSTITIALS_PRIMARY_RESUMED = \"hlsInterstitialsPrimaryResumed\", s.PLAYOUT_LIMIT_REACHED = \"hlsPlayoutLimitReached\", s.EVENT_CUE_ENTER = \"hlsEventCueEnter\", s;\n})({});\nvar Ke = {\n  MANIFEST: \"manifest\",\n  LEVEL: \"level\",\n  AUDIO_TRACK: \"audioTrack\",\n  SUBTITLE_TRACK: \"subtitleTrack\"\n}, pe = {\n  MAIN: \"main\",\n  AUDIO: \"audio\",\n  SUBTITLE: \"subtitle\"\n};\nclass hn {\n  //  About half of the estimated value will be from the last |halfLife| samples by weight.\n  constructor(e, t = 0, r = 0) {\n    this.halfLife = void 0, this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.halfLife = e, this.alpha_ = e ? Math.exp(Math.log(0.5) / e) : 0, this.estimate_ = t, this.totalWeight_ = r;\n  }\n  sample(e, t) {\n    const r = Math.pow(this.alpha_, e);\n    this.estimate_ = t * (1 - r) + r * this.estimate_, this.totalWeight_ += e;\n  }\n  getTotalWeight() {\n    return this.totalWeight_;\n  }\n  getEstimate() {\n    if (this.alpha_) {\n      const e = 1 - Math.pow(this.alpha_, this.totalWeight_);\n      if (e)\n        return this.estimate_ / e;\n    }\n    return this.estimate_;\n  }\n}\nclass TS {\n  constructor(e, t, r, n = 100) {\n    this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.defaultTTFB_ = void 0, this.ttfb_ = void 0, this.defaultEstimate_ = r, this.minWeight_ = 1e-3, this.minDelayMs_ = 50, this.slow_ = new hn(e), this.fast_ = new hn(t), this.defaultTTFB_ = n, this.ttfb_ = new hn(e);\n  }\n  update(e, t) {\n    const {\n      slow_: r,\n      fast_: n,\n      ttfb_: i\n    } = this;\n    r.halfLife !== e &amp;&amp; (this.slow_ = new hn(e, r.getEstimate(), r.getTotalWeight())), n.halfLife !== t &amp;&amp; (this.fast_ = new hn(t, n.getEstimate(), n.getTotalWeight())), i.halfLife !== e &amp;&amp; (this.ttfb_ = new hn(e, i.getEstimate(), i.getTotalWeight()));\n  }\n  sample(e, t) {\n    e = Math.max(e, this.minDelayMs_);\n    const r = 8 * t, n = e / 1e3, i = r / n;\n    this.fast_.sample(n, i), this.slow_.sample(n, i);\n  }\n  sampleTTFB(e) {\n    const t = e / 1e3, r = Math.sqrt(2) * Math.exp(-Math.pow(t, 2) / 2);\n    this.ttfb_.sample(r, Math.max(e, 5));\n  }\n  canEstimate() {\n    return this.fast_.getTotalWeight() &gt;= this.minWeight_;\n  }\n  getEstimate() {\n    return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_;\n  }\n  getEstimateTTFB() {\n    return this.ttfb_.getTotalWeight() &gt;= this.minWeight_ ? this.ttfb_.getEstimate() : this.defaultTTFB_;\n  }\n  get defaultEstimate() {\n    return this.defaultEstimate_;\n  }\n  destroy() {\n  }\n}\nfunction wS(s, e, t) {\n  return (e = IS(e)) in s ? Object.defineProperty(s, e, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : s[e] = t, s;\n}\nfunction nt() {\n  return nt = Object.assign ? Object.assign.bind() : function(s) {\n    for (var e = 1; e &lt; arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) &amp;&amp; (s[r] = t[r]);\n    }\n    return s;\n  }, nt.apply(null, arguments);\n}\nfunction Xd(s, e) {\n  var t = Object.keys(s);\n  if (Object.getOwnPropertySymbols) {\n    var r = Object.getOwnPropertySymbols(s);\n    e &amp;&amp; (r = r.filter(function(n) {\n      return Object.getOwnPropertyDescriptor(s, n).enumerable;\n    })), t.push.apply(t, r);\n  }\n  return t;\n}\nfunction tt(s) {\n  for (var e = 1; e &lt; arguments.length; e++) {\n    var t = arguments[e] != null ? arguments[e] : {};\n    e % 2 ? Xd(Object(t), !0).forEach(function(r) {\n      wS(s, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(s, Object.getOwnPropertyDescriptors(t)) : Xd(Object(t)).forEach(function(r) {\n      Object.defineProperty(s, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return s;\n}\nfunction AS(s, e) {\n  if (typeof s != \"object\" || !s) return s;\n  var t = s[Symbol.toPrimitive];\n  if (t !== void 0) {\n    var r = t.call(s, e);\n    if (typeof r != \"object\") return r;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (e === \"string\" ? String : Number)(s);\n}\nfunction IS(s) {\n  var e = AS(s, \"string\");\n  return typeof e == \"symbol\" ? e : e + \"\";\n}\nclass Lr {\n  constructor(e, t) {\n    this.trace = void 0, this.debug = void 0, this.log = void 0, this.warn = void 0, this.info = void 0, this.error = void 0;\n    const r = `[${e}]:`;\n    this.trace = As, this.debug = t.debug.bind(null, r), this.log = t.log.bind(null, r), this.warn = t.warn.bind(null, r), this.info = t.info.bind(null, r), this.error = t.error.bind(null, r);\n  }\n}\nconst As = function() {\n}, _S = {\n  trace: As,\n  debug: As,\n  log: As,\n  warn: As,\n  info: As,\n  error: As\n};\nfunction oc() {\n  return nt({}, _S);\n}\nfunction RS(s, e) {\n  const t = self.console[s];\n  return t ? t.bind(self.console, `${e ? \"[\" + e + \"] \" : \"\"}[${s}] &gt;`) : As;\n}\nfunction Jd(s, e, t) {\n  return e[s] ? e[s].bind(e) : RS(s, t);\n}\nconst ac = oc();\nfunction LS(s, e, t) {\n  const r = oc();\n  if (typeof console == \"object\" &amp;&amp; s === !0 || typeof s == \"object\") {\n    const n = [\n      // Remove out from list here to hard-disable a log-level\n      // 'trace',\n      \"debug\",\n      \"log\",\n      \"info\",\n      \"warn\",\n      \"error\"\n    ];\n    n.forEach((i) =&gt; {\n      r[i] = Jd(i, s, t);\n    });\n    try {\n      r.log(`Debug logs enabled for \"${e}\" in hls.js version 1.6.12`);\n    } catch {\n      return oc();\n    }\n    n.forEach((i) =&gt; {\n      ac[i] = Jd(i, s);\n    });\n  } else\n    nt(ac, r);\n  return r;\n}\nconst rt = ac;\nfunction Ms(s = !0) {\n  return typeof self &gt; \"u\" ? void 0 : (s || !self.MediaSource) &amp;&amp; self.ManagedMediaSource || self.MediaSource || self.WebKitMediaSource;\n}\nfunction CS(s) {\n  return typeof self &lt; \"u\" &amp;&amp; s === self.ManagedMediaSource;\n}\nfunction Ag(s, e) {\n  const t = Object.keys(s), r = Object.keys(e), n = t.length, i = r.length;\n  return !n || !i || n === i &amp;&amp; !t.some((o) =&gt; r.indexOf(o) === -1);\n}\nfunction Tr(s, e = !1) {\n  if (typeof TextDecoder &lt; \"u\") {\n    const c = new TextDecoder(\"utf-8\").decode(s);\n    if (e) {\n      const u = c.indexOf(\"\\0\");\n      return u !== -1 ? c.substring(0, u) : c;\n    }\n    return c.replace(/\\0/g, \"\");\n  }\n  const t = s.length;\n  let r, n, i, o = \"\", a = 0;\n  for (; a &lt; t; ) {\n    if (r = s[a++], r === 0 &amp;&amp; e)\n      return o;\n    if (r === 0 || r === 3)\n      continue;\n    switch (r &gt;&gt; 4) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n        o += String.fromCharCode(r);\n        break;\n      case 12:\n      case 13:\n        n = s[a++], o += String.fromCharCode((r &amp; 31) &lt;&lt; 6 | n &amp; 63);\n        break;\n      case 14:\n        n = s[a++], i = s[a++], o += String.fromCharCode((r &amp; 15) &lt;&lt; 12 | (n &amp; 63) &lt;&lt; 6 | (i &amp; 63) &lt;&lt; 0);\n        break;\n    }\n  }\n  return o;\n}\nfunction fr(s) {\n  let e = \"\";\n  for (let t = 0; t &lt; s.length; t++) {\n    let r = s[t].toString(16);\n    r.length &lt; 2 &amp;&amp; (r = \"0\" + r), e += r;\n  }\n  return e;\n}\nfunction Ig(s) {\n  return Uint8Array.from(s.replace(/^0x/, \"\").replace(/([\\da-fA-F]{2}) ?/g, \"0x$1 \").replace(/ +$/, \"\").split(\" \")).buffer;\n}\nfunction kS(s) {\n  return s &amp;&amp; s.__esModule &amp;&amp; Object.prototype.hasOwnProperty.call(s, \"default\") ? s.default : s;\n}\nvar cl = { exports: {} }, Qd;\nfunction DS() {\n  return Qd || (Qd = 1, (function(s, e) {\n    (function(t) {\n      var r = /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/, n = /^(?=([^\\/?#]*))\\1([^]*)$/, i = /(?:\\/|^)\\.(?=\\/)/g, o = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g, a = {\n        // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n        // E.g\n        // With opts.alwaysNormalize = false (default, spec compliant)\n        // http://a.com/b/cd + /e/f/../g =&gt; http://a.com/e/f/../g\n        // With opts.alwaysNormalize = true (not spec compliant)\n        // http://a.com/b/cd + /e/f/../g =&gt; http://a.com/e/g\n        buildAbsoluteURL: function(l, c, u) {\n          if (u = u || {}, l = l.trim(), c = c.trim(), !c) {\n            if (!u.alwaysNormalize)\n              return l;\n            var d = a.parseURL(l);\n            if (!d)\n              throw new Error(\"Error trying to parse base URL.\");\n            return d.path = a.normalizePath(\n              d.path\n            ), a.buildURLFromParts(d);\n          }\n          var h = a.parseURL(c);\n          if (!h)\n            throw new Error(\"Error trying to parse relative URL.\");\n          if (h.scheme)\n            return u.alwaysNormalize ? (h.path = a.normalizePath(h.path), a.buildURLFromParts(h)) : c;\n          var f = a.parseURL(l);\n          if (!f)\n            throw new Error(\"Error trying to parse base URL.\");\n          if (!f.netLoc &amp;&amp; f.path &amp;&amp; f.path[0] !== \"/\") {\n            var p = n.exec(f.path);\n            f.netLoc = p[1], f.path = p[2];\n          }\n          f.netLoc &amp;&amp; !f.path &amp;&amp; (f.path = \"/\");\n          var y = {\n            // 2c) Otherwise, the embedded URL inherits the scheme of\n            // the base URL.\n            scheme: f.scheme,\n            netLoc: h.netLoc,\n            path: null,\n            params: h.params,\n            query: h.query,\n            fragment: h.fragment\n          };\n          if (!h.netLoc &amp;&amp; (y.netLoc = f.netLoc, h.path[0] !== \"/\"))\n            if (!h.path)\n              y.path = f.path, h.params || (y.params = f.params, h.query || (y.query = f.query));\n            else {\n              var E = f.path, b = E.substring(0, E.lastIndexOf(\"/\") + 1) + h.path;\n              y.path = a.normalizePath(b);\n            }\n          return y.path === null &amp;&amp; (y.path = u.alwaysNormalize ? a.normalizePath(h.path) : h.path), a.buildURLFromParts(y);\n        },\n        parseURL: function(l) {\n          var c = r.exec(l);\n          return c ? {\n            scheme: c[1] || \"\",\n            netLoc: c[2] || \"\",\n            path: c[3] || \"\",\n            params: c[4] || \"\",\n            query: c[5] || \"\",\n            fragment: c[6] || \"\"\n          } : null;\n        },\n        normalizePath: function(l) {\n          for (l = l.split(\"\").reverse().join(\"\").replace(i, \"\"); l.length !== (l = l.replace(o, \"\")).length; )\n            ;\n          return l.split(\"\").reverse().join(\"\");\n        },\n        buildURLFromParts: function(l) {\n          return l.scheme + l.netLoc + l.path + l.params + l.query + l.fragment;\n        }\n      };\n      s.exports = a;\n    })();\n  })(cl)), cl.exports;\n}\nvar hu = DS();\nclass fu {\n  constructor() {\n    this.aborted = !1, this.loaded = 0, this.retry = 0, this.total = 0, this.chunkCount = 0, this.bwEstimate = 0, this.loading = {\n      start: 0,\n      first: 0,\n      end: 0\n    }, this.parsing = {\n      start: 0,\n      end: 0\n    }, this.buffering = {\n      start: 0,\n      first: 0,\n      end: 0\n    };\n  }\n}\nvar ot = {\n  AUDIO: \"audio\",\n  VIDEO: \"video\",\n  AUDIOVIDEO: \"audiovideo\"\n};\nclass _g {\n  constructor(e) {\n    this._byteRange = null, this._url = null, this._stats = null, this._streams = null, this.base = void 0, this.relurl = void 0, typeof e == \"string\" &amp;&amp; (e = {\n      url: e\n    }), this.base = e, MS(this, \"stats\");\n  }\n  // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array\n  setByteRange(e, t) {\n    const r = e.split(\"@\", 2);\n    let n;\n    r.length === 1 ? n = (t == null ? void 0 : t.byteRangeEndOffset) || 0 : n = parseInt(r[1]), this._byteRange = [n, parseInt(r[0]) + n];\n  }\n  get baseurl() {\n    return this.base.url;\n  }\n  get byteRange() {\n    return this._byteRange === null ? [] : this._byteRange;\n  }\n  get byteRangeStartOffset() {\n    return this.byteRange[0];\n  }\n  get byteRangeEndOffset() {\n    return this.byteRange[1];\n  }\n  get elementaryStreams() {\n    return this._streams === null &amp;&amp; (this._streams = {\n      [ot.AUDIO]: null,\n      [ot.VIDEO]: null,\n      [ot.AUDIOVIDEO]: null\n    }), this._streams;\n  }\n  set elementaryStreams(e) {\n    this._streams = e;\n  }\n  get hasStats() {\n    return this._stats !== null;\n  }\n  get hasStreams() {\n    return this._streams !== null;\n  }\n  get stats() {\n    return this._stats === null &amp;&amp; (this._stats = new fu()), this._stats;\n  }\n  set stats(e) {\n    this._stats = e;\n  }\n  get url() {\n    return !this._url &amp;&amp; this.baseurl &amp;&amp; this.relurl &amp;&amp; (this._url = hu.buildAbsoluteURL(this.baseurl, this.relurl, {\n      alwaysNormalize: !0\n    })), this._url || \"\";\n  }\n  set url(e) {\n    this._url = e;\n  }\n  clearElementaryStreamInfo() {\n    const {\n      elementaryStreams: e\n    } = this;\n    e[ot.AUDIO] = null, e[ot.VIDEO] = null, e[ot.AUDIOVIDEO] = null;\n  }\n}\nfunction Vt(s) {\n  return s.sn !== \"initSegment\";\n}\nclass ul extends _g {\n  constructor(e, t) {\n    super(t), this._decryptdata = null, this._programDateTime = null, this._ref = null, this._bitrate = void 0, this.rawProgramDateTime = null, this.tagList = [], this.duration = 0, this.sn = 0, this.levelkeys = void 0, this.type = void 0, this.loader = null, this.keyLoader = null, this.level = -1, this.cc = 0, this.startPTS = void 0, this.endPTS = void 0, this.startDTS = void 0, this.endDTS = void 0, this.start = 0, this.playlistOffset = 0, this.deltaPTS = void 0, this.maxStartPTS = void 0, this.minEndPTS = void 0, this.data = void 0, this.bitrateTest = !1, this.title = null, this.initSegment = null, this.endList = void 0, this.gap = void 0, this.urlId = 0, this.type = e;\n  }\n  get byteLength() {\n    if (this.hasStats) {\n      const e = this.stats.total;\n      if (e)\n        return e;\n    }\n    if (this.byteRange.length) {\n      const e = this.byteRange[0], t = this.byteRange[1];\n      if (ue(e) &amp;&amp; ue(t))\n        return t - e;\n    }\n    return null;\n  }\n  get bitrate() {\n    return this.byteLength ? this.byteLength * 8 / this.duration : this._bitrate ? this._bitrate : null;\n  }\n  set bitrate(e) {\n    this._bitrate = e;\n  }\n  get decryptdata() {\n    const {\n      levelkeys: e\n    } = this;\n    if (!e &amp;&amp; !this._decryptdata)\n      return null;\n    if (!this._decryptdata &amp;&amp; this.levelkeys &amp;&amp; !this.levelkeys.NONE) {\n      const t = this.levelkeys.identity;\n      if (t)\n        this._decryptdata = t.getDecryptData(this.sn);\n      else {\n        const r = Object.keys(this.levelkeys);\n        if (r.length === 1) {\n          const n = this._decryptdata = this.levelkeys[r[0]] || null;\n          if (n)\n            return n.getDecryptData(this.sn);\n        }\n      }\n    }\n    return this._decryptdata;\n  }\n  get end() {\n    return this.start + this.duration;\n  }\n  get endProgramDateTime() {\n    if (this.programDateTime === null)\n      return null;\n    const e = ue(this.duration) ? this.duration : 0;\n    return this.programDateTime + e * 1e3;\n  }\n  get encrypted() {\n    var e;\n    if ((e = this._decryptdata) != null &amp;&amp; e.encrypted)\n      return !0;\n    if (this.levelkeys) {\n      var t;\n      const r = Object.keys(this.levelkeys), n = r.length;\n      if (n &gt; 1 || n === 1 &amp;&amp; (t = this.levelkeys[r[0]]) != null &amp;&amp; t.encrypted)\n        return !0;\n    }\n    return !1;\n  }\n  get programDateTime() {\n    return this._programDateTime === null &amp;&amp; this.rawProgramDateTime &amp;&amp; (this.programDateTime = Date.parse(this.rawProgramDateTime)), this._programDateTime;\n  }\n  set programDateTime(e) {\n    if (!ue(e)) {\n      this._programDateTime = this.rawProgramDateTime = null;\n      return;\n    }\n    this._programDateTime = e;\n  }\n  get ref() {\n    return Vt(this) ? (this._ref || (this._ref = {\n      base: this.base,\n      start: this.start,\n      duration: this.duration,\n      sn: this.sn,\n      programDateTime: this.programDateTime\n    }), this._ref) : null;\n  }\n  addStart(e) {\n    this.setStart(this.start + e);\n  }\n  setStart(e) {\n    this.start = e, this._ref &amp;&amp; (this._ref.start = e);\n  }\n  setDuration(e) {\n    this.duration = e, this._ref &amp;&amp; (this._ref.duration = e);\n  }\n  setKeyFormat(e) {\n    if (this.levelkeys) {\n      const t = this.levelkeys[e];\n      t &amp;&amp; !this._decryptdata &amp;&amp; (this._decryptdata = t.getDecryptData(this.sn));\n    }\n  }\n  abortRequests() {\n    var e, t;\n    (e = this.loader) == null || e.abort(), (t = this.keyLoader) == null || t.abort();\n  }\n  setElementaryStreamInfo(e, t, r, n, i, o = !1) {\n    const {\n      elementaryStreams: a\n    } = this, l = a[e];\n    if (!l) {\n      a[e] = {\n        startPTS: t,\n        endPTS: r,\n        startDTS: n,\n        endDTS: i,\n        partial: o\n      };\n      return;\n    }\n    l.startPTS = Math.min(l.startPTS, t), l.endPTS = Math.max(l.endPTS, r), l.startDTS = Math.min(l.startDTS, n), l.endDTS = Math.max(l.endDTS, i);\n  }\n}\nclass PS extends _g {\n  constructor(e, t, r, n, i) {\n    super(r), this.fragOffset = 0, this.duration = 0, this.gap = !1, this.independent = !1, this.relurl = void 0, this.fragment = void 0, this.index = void 0, this.duration = e.decimalFloatingPoint(\"DURATION\"), this.gap = e.bool(\"GAP\"), this.independent = e.bool(\"INDEPENDENT\"), this.relurl = e.enumeratedString(\"URI\"), this.fragment = t, this.index = n;\n    const o = e.enumeratedString(\"BYTERANGE\");\n    o &amp;&amp; this.setByteRange(o, i), i &amp;&amp; (this.fragOffset = i.fragOffset + i.duration);\n  }\n  get start() {\n    return this.fragment.start + this.fragOffset;\n  }\n  get end() {\n    return this.start + this.duration;\n  }\n  get loaded() {\n    const {\n      elementaryStreams: e\n    } = this;\n    return !!(e.audio || e.video || e.audiovideo);\n  }\n}\nfunction Rg(s, e) {\n  const t = Object.getPrototypeOf(s);\n  if (t) {\n    const r = Object.getOwnPropertyDescriptor(t, e);\n    return r || Rg(t, e);\n  }\n}\nfunction MS(s, e) {\n  const t = Rg(s, e);\n  t &amp;&amp; (t.enumerable = !0, Object.defineProperty(s, e, t));\n}\nconst eh = Math.pow(2, 32) - 1, OS = [].push, Lg = {\n  video: 1,\n  audio: 2,\n  id3: 3,\n  text: 4\n};\nfunction jt(s) {\n  return String.fromCharCode.apply(null, s);\n}\nfunction Cg(s, e) {\n  const t = s[e] &lt;&lt; 8 | s[e + 1];\n  return t &lt; 0 ? 65536 + t : t;\n}\nfunction Ie(s, e) {\n  const t = kg(s, e);\n  return t &lt; 0 ? 4294967296 + t : t;\n}\nfunction th(s, e) {\n  let t = Ie(s, e);\n  return t *= Math.pow(2, 32), t += Ie(s, e + 4), t;\n}\nfunction kg(s, e) {\n  return s[e] &lt;&lt; 24 | s[e + 1] &lt;&lt; 16 | s[e + 2] &lt;&lt; 8 | s[e + 3];\n}\nfunction BS(s) {\n  const e = s.byteLength;\n  for (let t = 0; t &lt; e; ) {\n    const r = Ie(s, t);\n    if (r &gt; 8 &amp;&amp; s[t + 4] === 109 &amp;&amp; s[t + 5] === 111 &amp;&amp; s[t + 6] === 111 &amp;&amp; s[t + 7] === 102)\n      return !0;\n    t = r &gt; 1 ? t + r : e;\n  }\n  return !1;\n}\nfunction Ge(s, e) {\n  const t = [];\n  if (!e.length)\n    return t;\n  const r = s.byteLength;\n  for (let n = 0; n &lt; r; ) {\n    const i = Ie(s, n), o = jt(s.subarray(n + 4, n + 8)), a = i &gt; 1 ? n + i : r;\n    if (o === e[0])\n      if (e.length === 1)\n        t.push(s.subarray(n + 8, a));\n      else {\n        const l = Ge(s.subarray(n + 8, a), e.slice(1));\n        l.length &amp;&amp; OS.apply(t, l);\n      }\n    n = a;\n  }\n  return t;\n}\nfunction FS(s) {\n  const e = [], t = s[0];\n  let r = 8;\n  const n = Ie(s, r);\n  r += 4;\n  let i = 0, o = 0;\n  t === 0 ? (i = Ie(s, r), o = Ie(s, r + 4), r += 8) : (i = th(s, r), o = th(s, r + 8), r += 16), r += 2;\n  let a = s.length + o;\n  const l = Cg(s, r);\n  r += 2;\n  for (let c = 0; c &lt; l; c++) {\n    let u = r;\n    const d = Ie(s, u);\n    u += 4;\n    const h = d &amp; 2147483647;\n    if ((d &amp; 2147483648) &gt;&gt;&gt; 31 === 1)\n      return rt.warn(\"SIDX has hierarchical references (not supported)\"), null;\n    const p = Ie(s, u);\n    u += 4, e.push({\n      referenceSize: h,\n      subsegmentDuration: p,\n      // unscaled\n      info: {\n        duration: p / n,\n        start: a,\n        end: a + h - 1\n      }\n    }), a += h, u += 4, r = u;\n  }\n  return {\n    earliestPresentationTime: i,\n    timescale: n,\n    version: t,\n    referencesCount: l,\n    references: e\n  };\n}\nfunction Dg(s) {\n  const e = [], t = Ge(s, [\"moov\", \"trak\"]);\n  for (let n = 0; n &lt; t.length; n++) {\n    const i = t[n], o = Ge(i, [\"tkhd\"])[0];\n    if (o) {\n      let a = o[0];\n      const l = Ie(o, a === 0 ? 12 : 20), c = Ge(i, [\"mdia\", \"mdhd\"])[0];\n      if (c) {\n        a = c[0];\n        const u = Ie(c, a === 0 ? 12 : 20), d = Ge(i, [\"mdia\", \"hdlr\"])[0];\n        if (d) {\n          const h = jt(d.subarray(8, 12)), f = {\n            soun: ot.AUDIO,\n            vide: ot.VIDEO\n          }[h], p = Ge(i, [\"mdia\", \"minf\", \"stbl\", \"stsd\"])[0], y = NS(p);\n          f ? (e[l] = {\n            timescale: u,\n            type: f,\n            stsd: y\n          }, e[f] = tt({\n            timescale: u,\n            id: l\n          }, y)) : e[l] = {\n            timescale: u,\n            type: h,\n            stsd: y\n          };\n        }\n      }\n    }\n  }\n  return Ge(s, [\"moov\", \"mvex\", \"trex\"]).forEach((n) =&gt; {\n    const i = Ie(n, 4), o = e[i];\n    o &amp;&amp; (o.default = {\n      duration: Ie(n, 12),\n      flags: Ie(n, 20)\n    });\n  }), e;\n}\nfunction NS(s) {\n  const e = s.subarray(8), t = e.subarray(86), r = jt(e.subarray(4, 8));\n  let n = r, i;\n  const o = r === \"enca\" || r === \"encv\";\n  if (o) {\n    const c = Ge(e, [r])[0].subarray(r === \"enca\" ? 28 : 78);\n    Ge(c, [\"sinf\"]).forEach((d) =&gt; {\n      const h = Ge(d, [\"schm\"])[0];\n      if (h) {\n        const f = jt(h.subarray(4, 8));\n        if (f === \"cbcs\" || f === \"cenc\") {\n          const p = Ge(d, [\"frma\"])[0];\n          p &amp;&amp; (n = jt(p));\n        }\n      }\n    });\n  }\n  const a = n;\n  switch (n) {\n    case \"avc1\":\n    case \"avc2\":\n    case \"avc3\":\n    case \"avc4\": {\n      const l = Ge(t, [\"avcC\"])[0];\n      l &amp;&amp; l.length &gt; 3 &amp;&amp; (n += \".\" + Ki(l[1]) + Ki(l[2]) + Ki(l[3]), i = ji(a === \"avc1\" ? \"dva1\" : \"dvav\", t));\n      break;\n    }\n    case \"mp4a\": {\n      const l = Ge(e, [r])[0], c = Ge(l.subarray(28), [\"esds\"])[0];\n      if (c &amp;&amp; c.length &gt; 7) {\n        let u = 4;\n        if (c[u++] !== 3)\n          break;\n        u = dl(c, u), u += 2;\n        const d = c[u++];\n        if (d &amp; 128 &amp;&amp; (u += 2), d &amp; 64 &amp;&amp; (u += c[u++]), c[u++] !== 4)\n          break;\n        u = dl(c, u);\n        const h = c[u++];\n        if (h === 64)\n          n += \".\" + Ki(h);\n        else\n          break;\n        if (u += 12, c[u++] !== 5)\n          break;\n        u = dl(c, u);\n        const f = c[u++];\n        let p = (f &amp; 248) &gt;&gt; 3;\n        p === 31 &amp;&amp; (p += 1 + ((f &amp; 7) &lt;&lt; 3) + ((c[u] &amp; 224) &gt;&gt; 5)), n += \".\" + p;\n      }\n      break;\n    }\n    case \"hvc1\":\n    case \"hev1\": {\n      const l = Ge(t, [\"hvcC\"])[0];\n      if (l &amp;&amp; l.length &gt; 12) {\n        const c = l[1], u = [\"\", \"A\", \"B\", \"C\"][c &gt;&gt; 6], d = c &amp; 31, h = Ie(l, 2), f = (c &amp; 32) &gt;&gt; 5 ? \"H\" : \"L\", p = l[12], y = l.subarray(6, 12);\n        n += \".\" + u + d, n += \".\" + US(h).toString(16).toUpperCase(), n += \".\" + f + p;\n        let E = \"\";\n        for (let b = y.length; b--; ) {\n          const R = y[b];\n          (R || E) &amp;&amp; (E = \".\" + R.toString(16).toUpperCase() + E);\n        }\n        n += E;\n      }\n      i = ji(a == \"hev1\" ? \"dvhe\" : \"dvh1\", t);\n      break;\n    }\n    case \"dvh1\":\n    case \"dvhe\":\n    case \"dvav\":\n    case \"dva1\":\n    case \"dav1\": {\n      n = ji(n, t) || n;\n      break;\n    }\n    case \"vp09\": {\n      const l = Ge(t, [\"vpcC\"])[0];\n      if (l &amp;&amp; l.length &gt; 6) {\n        const c = l[4], u = l[5], d = l[6] &gt;&gt; 4 &amp; 15;\n        n += \".\" + Vr(c) + \".\" + Vr(u) + \".\" + Vr(d);\n      }\n      break;\n    }\n    case \"av01\": {\n      const l = Ge(t, [\"av1C\"])[0];\n      if (l &amp;&amp; l.length &gt; 2) {\n        const c = l[1] &gt;&gt;&gt; 5, u = l[1] &amp; 31, d = l[2] &gt;&gt;&gt; 7 ? \"H\" : \"M\", h = (l[2] &amp; 64) &gt;&gt; 6, f = (l[2] &amp; 32) &gt;&gt; 5, p = c === 2 &amp;&amp; h ? f ? 12 : 10 : h ? 10 : 8, y = (l[2] &amp; 16) &gt;&gt; 4, E = (l[2] &amp; 8) &gt;&gt; 3, b = (l[2] &amp; 4) &gt;&gt; 2, R = l[2] &amp; 3;\n        n += \".\" + c + \".\" + Vr(u) + d + \".\" + Vr(p) + \".\" + y + \".\" + E + b + R + \".\" + Vr(1) + \".\" + Vr(1) + \".\" + Vr(1) + \".\" + 0, i = ji(\"dav1\", t);\n      }\n      break;\n    }\n  }\n  return {\n    codec: n,\n    encrypted: o,\n    supplemental: i\n  };\n}\nfunction ji(s, e) {\n  const t = Ge(e, [\"dvvC\"]), r = t.length ? t[0] : Ge(e, [\"dvcC\"])[0];\n  if (r) {\n    const n = r[2] &gt;&gt; 1 &amp; 127, i = r[2] &lt;&lt; 5 &amp; 32 | r[3] &gt;&gt; 3 &amp; 31;\n    return s + \".\" + Vr(n) + \".\" + Vr(i);\n  }\n}\nfunction US(s) {\n  let e = 0;\n  for (let t = 0; t &lt; 32; t++)\n    e |= (s &gt;&gt; t &amp; 1) &lt;&lt; 31 - t;\n  return e &gt;&gt;&gt; 0;\n}\nfunction dl(s, e) {\n  const t = e + 5;\n  for (; s[e++] &amp; 128 &amp;&amp; e &lt; t; )\n    ;\n  return e;\n}\nfunction Ki(s) {\n  return (\"0\" + s.toString(16).toUpperCase()).slice(-2);\n}\nfunction Vr(s) {\n  return (s &lt; 10 ? \"0\" : \"\") + s;\n}\nfunction $S(s, e) {\n  if (!s || !e)\n    return;\n  const t = e.keyId;\n  t &amp;&amp; e.isCommonEncryption &amp;&amp; Ge(s, [\"moov\", \"trak\"]).forEach((n) =&gt; {\n    const o = Ge(n, [\"mdia\", \"minf\", \"stbl\", \"stsd\"])[0].subarray(8);\n    let a = Ge(o, [\"enca\"]);\n    const l = a.length &gt; 0;\n    l || (a = Ge(o, [\"encv\"])), a.forEach((c) =&gt; {\n      const u = l ? c.subarray(28) : c.subarray(78);\n      Ge(u, [\"sinf\"]).forEach((h) =&gt; {\n        const f = Pg(h);\n        if (f) {\n          const p = f.subarray(8, 24);\n          p.some((y) =&gt; y !== 0) || (rt.log(`[eme] Patching keyId in 'enc${l ? \"a\" : \"v\"}&gt;sinf&gt;&gt;tenc' box: ${fr(p)} -&gt; ${fr(t)}`), f.set(t, 8));\n        }\n      });\n    });\n  });\n}\nfunction Pg(s) {\n  const e = Ge(s, [\"schm\"])[0];\n  if (e) {\n    const t = jt(e.subarray(4, 8));\n    if (t === \"cbcs\" || t === \"cenc\")\n      return Ge(s, [\"schi\", \"tenc\"])[0];\n  }\n  return null;\n}\nfunction GS(s, e, t) {\n  const r = {}, n = Ge(s, [\"moof\", \"traf\"]);\n  for (let i = 0; i &lt; n.length; i++) {\n    const o = n[i], a = Ge(o, [\"tfhd\"])[0], l = Ie(a, 4), c = e[l];\n    if (!c)\n      continue;\n    r[l] || (r[l] = {\n      start: NaN,\n      duration: 0,\n      sampleCount: 0,\n      timescale: c.timescale,\n      type: c.type\n    });\n    const u = r[l], d = Ge(o, [\"tfdt\"])[0];\n    if (d) {\n      const A = d[0];\n      let F = Ie(d, 4);\n      A === 1 &amp;&amp; (F === eh ? t.warn(\"[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time\") : (F *= eh + 1, F += Ie(d, 8))), ue(F) &amp;&amp; (!ue(u.start) || F &lt; u.start) &amp;&amp; (u.start = F);\n    }\n    const h = c.default, f = Ie(a, 0) | (h == null ? void 0 : h.flags);\n    let p = (h == null ? void 0 : h.duration) || 0;\n    f &amp; 8 &amp;&amp; (f &amp; 2 ? p = Ie(a, 12) : p = Ie(a, 8));\n    const y = Ge(o, [\"trun\"]);\n    let E = u.start || 0, b = 0, R = p;\n    for (let A = 0; A &lt; y.length; A++) {\n      const F = y[A], M = Ie(F, 4), H = u.sampleCount;\n      u.sampleCount += M;\n      const K = F[3] &amp; 1, j = F[3] &amp; 4, C = F[2] &amp; 1, k = F[2] &amp; 2, $ = F[2] &amp; 4, W = F[2] &amp; 8;\n      let _ = 8, g = M;\n      for (K &amp;&amp; (_ += 4), j &amp;&amp; M &amp;&amp; (!(F[_ + 1] &amp; 1) &amp;&amp; u.keyFrameIndex === void 0 &amp;&amp; (u.keyFrameIndex = H), _ += 4, C ? (R = Ie(F, _), _ += 4) : R = p, k &amp;&amp; (_ += 4), W &amp;&amp; (_ += 4), E += R, b += R, g--); g--; )\n        C ? (R = Ie(F, _), _ += 4) : R = p, k &amp;&amp; (_ += 4), $ &amp;&amp; (F[_ + 1] &amp; 1 || u.keyFrameIndex === void 0 &amp;&amp; (u.keyFrameIndex = u.sampleCount - (g + 1), u.keyFrameStart = E), _ += 4), W &amp;&amp; (_ += 4), E += R, b += R;\n      !b &amp;&amp; p &amp;&amp; (b += p * M);\n    }\n    u.duration += b;\n  }\n  if (!Object.keys(r).some((i) =&gt; r[i].duration)) {\n    let i = 1 / 0, o = 0;\n    const a = Ge(s, [\"sidx\"]);\n    for (let l = 0; l &lt; a.length; l++) {\n      const c = FS(a[l]);\n      if (c != null &amp;&amp; c.references) {\n        i = Math.min(i, c.earliestPresentationTime / c.timescale);\n        const u = c.references.reduce((d, h) =&gt; d + h.info.duration || 0, 0);\n        o = Math.max(o, u + c.earliestPresentationTime / c.timescale);\n      }\n    }\n    o &amp;&amp; ue(o) &amp;&amp; Object.keys(r).forEach((l) =&gt; {\n      r[l].duration || (r[l].duration = o * r[l].timescale - r[l].start);\n    });\n  }\n  return r;\n}\nfunction VS(s) {\n  const e = {\n    valid: null,\n    remainder: null\n  }, t = Ge(s, [\"moof\"]);\n  if (t.length &lt; 2)\n    return e.remainder = s, e;\n  const r = t[t.length - 1];\n  return e.valid = s.slice(0, r.byteOffset - 8), e.remainder = s.slice(r.byteOffset - 8), e;\n}\nfunction _r(s, e) {\n  const t = new Uint8Array(s.length + e.length);\n  return t.set(s), t.set(e, s.length), t;\n}\nfunction rh(s, e) {\n  const t = [], r = e.samples, n = e.timescale, i = e.id;\n  let o = !1;\n  return Ge(r, [\"moof\"]).map((l) =&gt; {\n    const c = l.byteOffset - 8;\n    Ge(l, [\"traf\"]).map((d) =&gt; {\n      const h = Ge(d, [\"tfdt\"]).map((f) =&gt; {\n        const p = f[0];\n        let y = Ie(f, 4);\n        return p === 1 &amp;&amp; (y *= Math.pow(2, 32), y += Ie(f, 8)), y / n;\n      })[0];\n      return h !== void 0 &amp;&amp; (s = h), Ge(d, [\"tfhd\"]).map((f) =&gt; {\n        const p = Ie(f, 4), y = Ie(f, 0) &amp; 16777215, E = (y &amp; 1) !== 0, b = (y &amp; 2) !== 0, R = (y &amp; 8) !== 0;\n        let A = 0;\n        const F = (y &amp; 16) !== 0;\n        let M = 0;\n        const H = (y &amp; 32) !== 0;\n        let K = 8;\n        p === i &amp;&amp; (E &amp;&amp; (K += 8), b &amp;&amp; (K += 4), R &amp;&amp; (A = Ie(f, K), K += 4), F &amp;&amp; (M = Ie(f, K), K += 4), H &amp;&amp; (K += 4), e.type === \"video\" &amp;&amp; (o = ya(e.codec)), Ge(d, [\"trun\"]).map((j) =&gt; {\n          const C = j[0], k = Ie(j, 0) &amp; 16777215, $ = (k &amp; 1) !== 0;\n          let W = 0;\n          const _ = (k &amp; 4) !== 0, g = (k &amp; 256) !== 0;\n          let x = 0;\n          const w = (k &amp; 512) !== 0;\n          let D = 0;\n          const O = (k &amp; 1024) !== 0, U = (k &amp; 2048) !== 0;\n          let V = 0;\n          const L = Ie(j, 4);\n          let m = 8;\n          $ &amp;&amp; (W = Ie(j, m), m += 4), _ &amp;&amp; (m += 4);\n          let v = W + c;\n          for (let P = 0; P &lt; L; P++) {\n            if (g ? (x = Ie(j, m), m += 4) : x = A, w ? (D = Ie(j, m), m += 4) : D = M, O &amp;&amp; (m += 4), U &amp;&amp; (C === 0 ? V = Ie(j, m) : V = kg(j, m), m += 4), e.type === ot.VIDEO) {\n              let N = 0;\n              for (; N &lt; D; ) {\n                const Y = Ie(r, v);\n                if (v += 4, jS(o, r[v])) {\n                  const ee = r.subarray(v, v + Y);\n                  gu(ee, o ? 2 : 1, s + V / n, t);\n                }\n                v += Y, N += Y + 4;\n              }\n            }\n            s += x / n;\n          }\n        }));\n      });\n    });\n  }), t;\n}\nfunction ya(s) {\n  if (!s)\n    return !1;\n  const e = s.substring(0, 4);\n  return e === \"hvc1\" || e === \"hev1\" || // Dolby Vision\n  e === \"dvh1\" || e === \"dvhe\";\n}\nfunction jS(s, e) {\n  if (s) {\n    const t = e &gt;&gt; 1 &amp; 63;\n    return t === 39 || t === 40;\n  } else\n    return (e &amp; 31) === 6;\n}\nfunction gu(s, e, t, r) {\n  const n = Mg(s);\n  let i = 0;\n  i += e;\n  let o = 0, a = 0, l = 0;\n  for (; i &lt; n.length; ) {\n    o = 0;\n    do {\n      if (i &gt;= n.length)\n        break;\n      l = n[i++], o += l;\n    } while (l === 255);\n    a = 0;\n    do {\n      if (i &gt;= n.length)\n        break;\n      l = n[i++], a += l;\n    } while (l === 255);\n    const c = n.length - i;\n    let u = i;\n    if (a &lt; c)\n      i += a;\n    else if (a &gt; c) {\n      rt.error(`Malformed SEI payload. ${a} is too small, only ${c} bytes left to parse.`);\n      break;\n    }\n    if (o === 4) {\n      if (n[u++] === 181) {\n        const h = Cg(n, u);\n        if (u += 2, h === 49) {\n          const f = Ie(n, u);\n          if (u += 4, f === 1195456820) {\n            const p = n[u++];\n            if (p === 3) {\n              const y = n[u++], E = 31 &amp; y, b = 64 &amp; y, R = b ? 2 + E * 3 : 0, A = new Uint8Array(R);\n              if (b) {\n                A[0] = y;\n                for (let F = 1; F &lt; R; F++)\n                  A[F] = n[u++];\n              }\n              r.push({\n                type: p,\n                payloadType: o,\n                pts: t,\n                bytes: A\n              });\n            }\n          }\n        }\n      }\n    } else if (o === 5 &amp;&amp; a &gt; 16) {\n      const d = [];\n      for (let p = 0; p &lt; 16; p++) {\n        const y = n[u++].toString(16);\n        d.push(y.length == 1 ? \"0\" + y : y), (p === 3 || p === 5 || p === 7 || p === 9) &amp;&amp; d.push(\"-\");\n      }\n      const h = a - 16, f = new Uint8Array(h);\n      for (let p = 0; p &lt; h; p++)\n        f[p] = n[u++];\n      r.push({\n        payloadType: o,\n        pts: t,\n        uuid: d.join(\"\"),\n        userData: Tr(f),\n        userDataBytes: f\n      });\n    }\n  }\n}\nfunction Mg(s) {\n  const e = s.byteLength, t = [];\n  let r = 1;\n  for (; r &lt; e - 2; )\n    s[r] === 0 &amp;&amp; s[r + 1] === 0 &amp;&amp; s[r + 2] === 3 ? (t.push(r + 2), r += 2) : r++;\n  if (t.length === 0)\n    return s;\n  const n = e - t.length, i = new Uint8Array(n);\n  let o = 0;\n  for (r = 0; r &lt; n; o++, r++)\n    o === t[0] &amp;&amp; (o++, t.shift()), i[r] = s[o];\n  return i;\n}\nfunction KS(s) {\n  const e = s[0];\n  let t = \"\", r = \"\", n = 0, i = 0, o = 0, a = 0, l = 0, c = 0;\n  if (e === 0) {\n    for (; jt(s.subarray(c, c + 1)) !== \"\\0\"; )\n      t += jt(s.subarray(c, c + 1)), c += 1;\n    for (t += jt(s.subarray(c, c + 1)), c += 1; jt(s.subarray(c, c + 1)) !== \"\\0\"; )\n      r += jt(s.subarray(c, c + 1)), c += 1;\n    r += jt(s.subarray(c, c + 1)), c += 1, n = Ie(s, 12), i = Ie(s, 16), a = Ie(s, 20), l = Ie(s, 24), c = 28;\n  } else if (e === 1) {\n    c += 4, n = Ie(s, c), c += 4;\n    const d = Ie(s, c);\n    c += 4;\n    const h = Ie(s, c);\n    for (c += 4, o = 2 ** 32 * d + h, SS(o) || (o = Number.MAX_SAFE_INTEGER, rt.warn(\"Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box\")), a = Ie(s, c), c += 4, l = Ie(s, c), c += 4; jt(s.subarray(c, c + 1)) !== \"\\0\"; )\n      t += jt(s.subarray(c, c + 1)), c += 1;\n    for (t += jt(s.subarray(c, c + 1)), c += 1; jt(s.subarray(c, c + 1)) !== \"\\0\"; )\n      r += jt(s.subarray(c, c + 1)), c += 1;\n    r += jt(s.subarray(c, c + 1)), c += 1;\n  }\n  const u = s.subarray(c, s.byteLength);\n  return {\n    schemeIdUri: t,\n    value: r,\n    timeScale: n,\n    presentationTime: o,\n    presentationTimeDelta: i,\n    eventDuration: a,\n    id: l,\n    payload: u\n  };\n}\nfunction HS(s, ...e) {\n  const t = e.length;\n  let r = 8, n = t;\n  for (; n--; )\n    r += e[n].byteLength;\n  const i = new Uint8Array(r);\n  for (i[0] = r &gt;&gt; 24 &amp; 255, i[1] = r &gt;&gt; 16 &amp; 255, i[2] = r &gt;&gt; 8 &amp; 255, i[3] = r &amp; 255, i.set(s, 4), n = 0, r = 8; n &lt; t; n++)\n    i.set(e[n], r), r += e[n].byteLength;\n  return i;\n}\nfunction qS(s, e, t) {\n  if (s.byteLength !== 16)\n    throw new RangeError(\"Invalid system id\");\n  let r, n;\n  r = 0, n = new Uint8Array();\n  let i;\n  r &gt; 0 ? (i = new Uint8Array(4), e.length &gt; 0 &amp;&amp; new DataView(i.buffer).setUint32(0, e.length, !1)) : i = new Uint8Array();\n  const o = new Uint8Array(4);\n  return t.byteLength &gt; 0 &amp;&amp; new DataView(o.buffer).setUint32(0, t.byteLength, !1), HS(\n    [112, 115, 115, 104],\n    new Uint8Array([\n      r,\n      0,\n      0,\n      0\n      // Flags\n    ]),\n    s,\n    // 16 bytes\n    i,\n    n,\n    o,\n    t\n  );\n}\nfunction WS(s) {\n  const e = [];\n  if (s instanceof ArrayBuffer) {\n    const t = s.byteLength;\n    let r = 0;\n    for (; r + 32 &lt; t; ) {\n      const n = new DataView(s, r), i = zS(n);\n      e.push(i), r += i.size;\n    }\n  }\n  return e;\n}\nfunction zS(s) {\n  const e = s.getUint32(0), t = s.byteOffset, r = s.byteLength;\n  if (r &lt; e)\n    return {\n      offset: t,\n      size: r\n    };\n  if (s.getUint32(4) !== 1886614376)\n    return {\n      offset: t,\n      size: e\n    };\n  const i = s.getUint32(8) &gt;&gt;&gt; 24;\n  if (i !== 0 &amp;&amp; i !== 1)\n    return {\n      offset: t,\n      size: e\n    };\n  const o = s.buffer, a = fr(new Uint8Array(o, t + 12, 16));\n  let l = null, c = null, u = 0;\n  if (i === 0)\n    u = 28;\n  else {\n    const h = s.getUint32(28);\n    if (!h || r &lt; 32 + h * 16)\n      return {\n        offset: t,\n        size: e\n      };\n    l = [];\n    for (let f = 0; f &lt; h; f++)\n      l.push(new Uint8Array(o, t + 32 + f * 16, 16));\n    u = 32 + h * 16;\n  }\n  if (!u)\n    return {\n      offset: t,\n      size: e\n    };\n  const d = s.getUint32(u);\n  return e - 32 &lt; d ? {\n    offset: t,\n    size: e\n  } : (c = new Uint8Array(o, t + u + 4, d), {\n    version: i,\n    systemId: a,\n    kids: l,\n    data: c,\n    offset: t,\n    size: e\n  });\n}\nconst Og = () =&gt; /\\(Windows.+Firefox\\//i.test(navigator.userAgent), Fn = {\n  audio: {\n    a3ds: 1,\n    \"ac-3\": 0.95,\n    \"ac-4\": 1,\n    alac: 0.9,\n    alaw: 1,\n    dra1: 1,\n    \"dts+\": 1,\n    \"dts-\": 1,\n    dtsc: 1,\n    dtse: 1,\n    dtsh: 1,\n    \"ec-3\": 0.9,\n    enca: 1,\n    fLaC: 0.9,\n    // MP4-RA listed codec entry for FLAC\n    flac: 0.9,\n    // legacy browser codec name for FLAC\n    FLAC: 0.9,\n    // some manifests may list \"FLAC\" with Apple's tools\n    g719: 1,\n    g726: 1,\n    m4ae: 1,\n    mha1: 1,\n    mha2: 1,\n    mhm1: 1,\n    mhm2: 1,\n    mlpa: 1,\n    mp4a: 1,\n    \"raw \": 1,\n    Opus: 1,\n    opus: 1,\n    // browsers expect this to be lowercase despite MP4RA says 'Opus'\n    samr: 1,\n    sawb: 1,\n    sawp: 1,\n    sevc: 1,\n    sqcp: 1,\n    ssmv: 1,\n    twos: 1,\n    ulaw: 1\n  },\n  video: {\n    avc1: 1,\n    avc2: 1,\n    avc3: 1,\n    avc4: 1,\n    avcp: 1,\n    av01: 0.8,\n    dav1: 0.8,\n    drac: 1,\n    dva1: 1,\n    dvav: 1,\n    dvh1: 0.7,\n    dvhe: 0.7,\n    encv: 1,\n    hev1: 0.75,\n    hvc1: 0.75,\n    mjp2: 1,\n    mp4v: 1,\n    mvc1: 1,\n    mvc2: 1,\n    mvc3: 1,\n    mvc4: 1,\n    resv: 1,\n    rv60: 1,\n    s263: 1,\n    svc1: 1,\n    svc2: 1,\n    \"vc-1\": 1,\n    vp08: 1,\n    vp09: 0.9\n  },\n  text: {\n    stpp: 1,\n    wvtt: 1\n  }\n};\nfunction pu(s, e) {\n  const t = Fn[e];\n  return !!t &amp;&amp; !!t[s.slice(0, 4)];\n}\nfunction gi(s, e, t = !0) {\n  return !s.split(\",\").some((r) =&gt; !mu(r, e, t));\n}\nfunction mu(s, e, t = !0) {\n  var r;\n  const n = Ms(t);\n  return (r = n == null ? void 0 : n.isTypeSupported(pi(s, e))) != null ? r : !1;\n}\nfunction pi(s, e) {\n  return `${e}/mp4;codecs=${s}`;\n}\nfunction sh(s) {\n  if (s) {\n    const e = s.substring(0, 4);\n    return Fn.video[e];\n  }\n  return 2;\n}\nfunction Zo(s) {\n  const e = Og();\n  return s.split(\",\").reduce((t, r) =&gt; {\n    const i = e &amp;&amp; ya(r) ? 9 : Fn.video[r];\n    return i ? (i * 2 + t) / (t ? 3 : 2) : (Fn.audio[r] + t) / (t ? 2 : 1);\n  }, 0);\n}\nconst hl = {};\nfunction YS(s, e = !0) {\n  if (hl[s])\n    return hl[s];\n  const t = {\n    // Idealy fLaC and Opus would be first (spec-compliant) but\n    // some browsers will report that fLaC is supported then fail.\n    // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728\n    flac: [\"flac\", \"fLaC\", \"FLAC\"],\n    opus: [\"opus\", \"Opus\"],\n    // Replace audio codec info if browser does not support mp4a.40.34,\n    // and demuxer can fallback to 'audio/mpeg' or 'audio/mp4;codecs=\"mp3\"'\n    \"mp4a.40.34\": [\"mp3\"]\n  }[s];\n  for (let n = 0; n &lt; t.length; n++) {\n    var r;\n    if (mu(t[n], \"audio\", e))\n      return hl[s] = t[n], t[n];\n    if (t[n] === \"mp3\" &amp;&amp; (r = Ms(e)) != null &amp;&amp; r.isTypeSupported(\"audio/mpeg\"))\n      return \"\";\n  }\n  return s;\n}\nconst ZS = /flac|opus|mp4a\\.40\\.34/i;\nfunction Xo(s, e = !0) {\n  return s.replace(ZS, (t) =&gt; YS(t.toLowerCase(), e));\n}\nfunction XS(s, e) {\n  const t = [];\n  if (s) {\n    const r = s.split(\",\");\n    for (let n = 0; n &lt; r.length; n++)\n      pu(r[n], \"video\") || t.push(r[n]);\n  }\n  return e &amp;&amp; t.push(e), t.join(\",\");\n}\nfunction fo(s, e) {\n  if (s &amp;&amp; (s.length &gt; 4 || [\"ac-3\", \"ec-3\", \"alac\", \"fLaC\", \"Opus\"].indexOf(s) !== -1) &amp;&amp; (nh(s, \"audio\") || nh(s, \"video\")))\n    return s;\n  if (e) {\n    const t = e.split(\",\");\n    if (t.length &gt; 1) {\n      if (s) {\n        for (let r = t.length; r--; )\n          if (t[r].substring(0, 4) === s.substring(0, 4))\n            return t[r];\n      }\n      return t[0];\n    }\n  }\n  return e || s;\n}\nfunction nh(s, e) {\n  return pu(s, e) &amp;&amp; mu(s, e);\n}\nfunction JS(s) {\n  const e = s.split(\",\");\n  for (let t = 0; t &lt; e.length; t++) {\n    const r = e[t].split(\".\");\n    r.length &gt; 2 &amp;&amp; r[0] === \"avc1\" &amp;&amp; (e[t] = `avc1.${parseInt(r[1]).toString(16)}${(\"000\" + parseInt(r[2]).toString(16)).slice(-4)}`);\n  }\n  return e.join(\",\");\n}\nfunction QS(s) {\n  if (s.startsWith(\"av01.\")) {\n    const e = s.split(\".\"), t = [\"0\", \"111\", \"01\", \"01\", \"01\", \"0\"];\n    for (let r = e.length; r &gt; 4 &amp;&amp; r &lt; 10; r++)\n      e[r] = t[r - 4];\n    return e.join(\".\");\n  }\n  return s;\n}\nfunction ih(s) {\n  const e = Ms(s) || {\n    isTypeSupported: () =&gt; !1\n  };\n  return {\n    mpeg: e.isTypeSupported(\"audio/mpeg\"),\n    mp3: e.isTypeSupported('audio/mp4; codecs=\"mp3\"'),\n    ac3: e.isTypeSupported('audio/mp4; codecs=\"ac-3\"')\n  };\n}\nfunction lc(s) {\n  return s.replace(/^.+codecs=[\"']?([^\"']+).*$/, \"$1\");\n}\nconst eb = {\n  supported: !0,\n  powerEfficient: !0,\n  smooth: !0\n  // keySystemAccess: null,\n}, tb = {\n  supported: !1,\n  smooth: !1,\n  powerEfficient: !1\n  // keySystemAccess: null,\n}, Bg = {\n  supported: !0,\n  configurations: [],\n  decodingInfoResults: [eb]\n};\nfunction Fg(s, e) {\n  return {\n    supported: !1,\n    configurations: e,\n    decodingInfoResults: [tb],\n    error: s\n  };\n}\nfunction rb(s, e, t, r, n, i) {\n  const o = s.videoCodec, a = s.audioCodec ? s.audioGroups : null, l = i == null ? void 0 : i.audioCodec, c = i == null ? void 0 : i.channels, u = c ? parseInt(c) : l ? 1 / 0 : 2;\n  let d = null;\n  if (a != null &amp;&amp; a.length)\n    try {\n      a.length === 1 &amp;&amp; a[0] ? d = e.groups[a[0]].channels : d = a.reduce((h, f) =&gt; {\n        if (f) {\n          const p = e.groups[f];\n          if (!p)\n            throw new Error(`Audio track group ${f} not found`);\n          Object.keys(p.channels).forEach((y) =&gt; {\n            h[y] = (h[y] || 0) + p.channels[y];\n          });\n        }\n        return h;\n      }, {\n        2: 0\n      });\n    } catch {\n      return !0;\n    }\n  return o !== void 0 &amp;&amp; // Force media capabilities check for HEVC to avoid failure on Windows\n  (o.split(\",\").some((h) =&gt; ya(h)) || s.width &gt; 1920 &amp;&amp; s.height &gt; 1088 || s.height &gt; 1920 &amp;&amp; s.width &gt; 1088 || s.frameRate &gt; Math.max(r, 30) || s.videoRange !== \"SDR\" &amp;&amp; s.videoRange !== t || s.bitrate &gt; Math.max(n, 8e6)) || !!d &amp;&amp; ue(u) &amp;&amp; Object.keys(d).some((h) =&gt; parseInt(h) &gt; u);\n}\nfunction Ng(s, e, t, r = {}) {\n  const n = s.videoCodec;\n  if (!n &amp;&amp; !s.audioCodec || !t)\n    return Promise.resolve(Bg);\n  const i = [], o = sb(s), a = o.length, l = nb(s, e, a &gt; 0), c = l.length;\n  for (let u = a || 1 * c || 1; u--; ) {\n    const d = {\n      type: \"media-source\"\n    };\n    if (a &amp;&amp; (d.video = o[u % a]), c) {\n      d.audio = l[u % c];\n      const h = d.audio.bitrate;\n      d.video &amp;&amp; h &amp;&amp; (d.video.bitrate -= h);\n    }\n    i.push(d);\n  }\n  if (n) {\n    const u = navigator.userAgent;\n    if (n.split(\",\").some((d) =&gt; ya(d)) &amp;&amp; Og())\n      return Promise.resolve(Fg(new Error(`Overriding Windows Firefox HEVC MediaCapabilities result based on user-agent string: (${u})`), i));\n  }\n  return Promise.all(i.map((u) =&gt; {\n    const d = ob(u);\n    return r[d] || (r[d] = t.decodingInfo(u));\n  })).then((u) =&gt; ({\n    supported: !u.some((d) =&gt; !d.supported),\n    configurations: i,\n    decodingInfoResults: u\n  })).catch((u) =&gt; ({\n    supported: !1,\n    configurations: i,\n    decodingInfoResults: [],\n    error: u\n  }));\n}\nfunction sb(s) {\n  var e;\n  const t = (e = s.videoCodec) == null ? void 0 : e.split(\",\"), r = Ug(s), n = s.width || 640, i = s.height || 480, o = s.frameRate || 30, a = s.videoRange.toLowerCase();\n  return t ? t.map((l) =&gt; {\n    const c = {\n      contentType: pi(QS(l), \"video\"),\n      width: n,\n      height: i,\n      bitrate: r,\n      framerate: o\n    };\n    return a !== \"sdr\" &amp;&amp; (c.transferFunction = a), c;\n  }) : [];\n}\nfunction nb(s, e, t) {\n  var r;\n  const n = (r = s.audioCodec) == null ? void 0 : r.split(\",\"), i = Ug(s);\n  return n &amp;&amp; s.audioGroups ? s.audioGroups.reduce((o, a) =&gt; {\n    var l;\n    const c = a ? (l = e.groups[a]) == null ? void 0 : l.tracks : null;\n    return c ? c.reduce((u, d) =&gt; {\n      if (d.groupId === a) {\n        const h = parseFloat(d.channels || \"\");\n        n.forEach((f) =&gt; {\n          const p = {\n            contentType: pi(f, \"audio\"),\n            bitrate: t ? ib(f, i) : i\n          };\n          h &amp;&amp; (p.channels = \"\" + h), u.push(p);\n        });\n      }\n      return u;\n    }, o) : o;\n  }, []) : [];\n}\nfunction ib(s, e) {\n  if (e &lt;= 1)\n    return 1;\n  let t = 128e3;\n  return s === \"ec-3\" ? t = 768e3 : s === \"ac-3\" &amp;&amp; (t = 64e4), Math.min(e / 2, t);\n}\nfunction Ug(s) {\n  return Math.ceil(Math.max(s.bitrate * 0.9, s.averageBitrate) / 1e3) * 1e3 || 1;\n}\nfunction ob(s) {\n  let e = \"\";\n  const {\n    audio: t,\n    video: r\n  } = s;\n  if (r) {\n    const n = lc(r.contentType);\n    e += `${n}_r${r.height}x${r.width}f${Math.ceil(r.framerate)}${r.transferFunction || \"sd\"}_${Math.ceil(r.bitrate / 1e5)}`;\n  }\n  if (t) {\n    const n = lc(t.contentType);\n    e += `${r ? \"_\" : \"\"}${n}_c${t.channels}`;\n  }\n  return e;\n}\nconst cc = [\"NONE\", \"TYPE-0\", \"TYPE-1\", null];\nfunction ab(s) {\n  return cc.indexOf(s) &gt; -1;\n}\nconst Jo = [\"SDR\", \"PQ\", \"HLG\"];\nfunction lb(s) {\n  return !!s &amp;&amp; Jo.indexOf(s) &gt; -1;\n}\nvar go = {\n  No: \"\",\n  Yes: \"YES\",\n  v2: \"v2\"\n};\nfunction oh(s) {\n  const {\n    canSkipUntil: e,\n    canSkipDateRanges: t,\n    age: r\n  } = s, n = r &lt; e / 2;\n  return e &amp;&amp; n ? t ? go.v2 : go.Yes : go.No;\n}\nclass ah {\n  constructor(e, t, r) {\n    this.msn = void 0, this.part = void 0, this.skip = void 0, this.msn = e, this.part = t, this.skip = r;\n  }\n  addDirectives(e) {\n    const t = new self.URL(e);\n    return this.msn !== void 0 &amp;&amp; t.searchParams.set(\"_HLS_msn\", this.msn.toString()), this.part !== void 0 &amp;&amp; t.searchParams.set(\"_HLS_part\", this.part.toString()), this.skip &amp;&amp; t.searchParams.set(\"_HLS_skip\", this.skip), t.href;\n  }\n}\nclass mi {\n  constructor(e) {\n    if (this._attrs = void 0, this.audioCodec = void 0, this.bitrate = void 0, this.codecSet = void 0, this.url = void 0, this.frameRate = void 0, this.height = void 0, this.id = void 0, this.name = void 0, this.supplemental = void 0, this.videoCodec = void 0, this.width = void 0, this.details = void 0, this.fragmentError = 0, this.loadError = 0, this.loaded = void 0, this.realBitrate = 0, this.supportedPromise = void 0, this.supportedResult = void 0, this._avgBitrate = 0, this._audioGroups = void 0, this._subtitleGroups = void 0, this._urlId = 0, this.url = [e.url], this._attrs = [e.attrs], this.bitrate = e.bitrate, e.details &amp;&amp; (this.details = e.details), this.id = e.id || 0, this.name = e.name, this.width = e.width || 0, this.height = e.height || 0, this.frameRate = e.attrs.optionalFloat(\"FRAME-RATE\", 0), this._avgBitrate = e.attrs.decimalInteger(\"AVERAGE-BANDWIDTH\"), this.audioCodec = e.audioCodec, this.videoCodec = e.videoCodec, this.codecSet = [e.videoCodec, e.audioCodec].filter((r) =&gt; !!r).map((r) =&gt; r.substring(0, 4)).join(\",\"), \"supplemental\" in e) {\n      var t;\n      this.supplemental = e.supplemental;\n      const r = (t = e.supplemental) == null ? void 0 : t.videoCodec;\n      r &amp;&amp; r !== e.videoCodec &amp;&amp; (this.codecSet += `,${r.substring(0, 4)}`);\n    }\n    this.addGroupId(\"audio\", e.attrs.AUDIO), this.addGroupId(\"text\", e.attrs.SUBTITLES);\n  }\n  get maxBitrate() {\n    return Math.max(this.realBitrate, this.bitrate);\n  }\n  get averageBitrate() {\n    return this._avgBitrate || this.realBitrate || this.bitrate;\n  }\n  get attrs() {\n    return this._attrs[0];\n  }\n  get codecs() {\n    return this.attrs.CODECS || \"\";\n  }\n  get pathwayId() {\n    return this.attrs[\"PATHWAY-ID\"] || \".\";\n  }\n  get videoRange() {\n    return this.attrs[\"VIDEO-RANGE\"] || \"SDR\";\n  }\n  get score() {\n    return this.attrs.optionalFloat(\"SCORE\", 0);\n  }\n  get uri() {\n    return this.url[0] || \"\";\n  }\n  hasAudioGroup(e) {\n    return lh(this._audioGroups, e);\n  }\n  hasSubtitleGroup(e) {\n    return lh(this._subtitleGroups, e);\n  }\n  get audioGroups() {\n    return this._audioGroups;\n  }\n  get subtitleGroups() {\n    return this._subtitleGroups;\n  }\n  addGroupId(e, t) {\n    if (t) {\n      if (e === \"audio\") {\n        let r = this._audioGroups;\n        r || (r = this._audioGroups = []), r.indexOf(t) === -1 &amp;&amp; r.push(t);\n      } else if (e === \"text\") {\n        let r = this._subtitleGroups;\n        r || (r = this._subtitleGroups = []), r.indexOf(t) === -1 &amp;&amp; r.push(t);\n      }\n    }\n  }\n  // Deprecated methods (retained for backwards compatibility)\n  get urlId() {\n    return 0;\n  }\n  set urlId(e) {\n  }\n  get audioGroupIds() {\n    return this.audioGroups ? [this.audioGroupId] : void 0;\n  }\n  get textGroupIds() {\n    return this.subtitleGroups ? [this.textGroupId] : void 0;\n  }\n  get audioGroupId() {\n    var e;\n    return (e = this.audioGroups) == null ? void 0 : e[0];\n  }\n  get textGroupId() {\n    var e;\n    return (e = this.subtitleGroups) == null ? void 0 : e[0];\n  }\n  addFallback() {\n  }\n}\nfunction lh(s, e) {\n  return !e || !s ? !1 : s.indexOf(e) !== -1;\n}\nfunction cb() {\n  if (typeof matchMedia == \"function\") {\n    const s = matchMedia(\"(dynamic-range: high)\"), e = matchMedia(\"bad query\");\n    if (s.media !== e.media)\n      return s.matches === !0;\n  }\n  return !1;\n}\nfunction ub(s, e) {\n  let t = !1, r = [];\n  if (s &amp;&amp; (t = s !== \"SDR\", r = [s]), e) {\n    r = e.allowedVideoRanges || Jo.slice(0);\n    const n = r.join(\"\") !== \"SDR\" &amp;&amp; !e.videoCodec;\n    t = e.preferHDR !== void 0 ? e.preferHDR : n &amp;&amp; cb(), t || (r = [\"SDR\"]);\n  }\n  return {\n    preferHDR: t,\n    allowedVideoRanges: r\n  };\n}\nconst db = (s) =&gt; {\n  const e = /* @__PURE__ */ new WeakSet();\n  return (t, r) =&gt; {\n    if (s &amp;&amp; (r = s(t, r)), typeof r == \"object\" &amp;&amp; r !== null) {\n      if (e.has(r))\n        return;\n      e.add(r);\n    }\n    return r;\n  };\n}, at = (s, e) =&gt; JSON.stringify(s, db(e));\nfunction hb(s, e, t, r, n) {\n  const i = Object.keys(s), o = r == null ? void 0 : r.channels, a = r == null ? void 0 : r.audioCodec, l = n == null ? void 0 : n.videoCodec, c = o &amp;&amp; parseInt(o) === 2;\n  let u = !1, d = !1, h = 1 / 0, f = 1 / 0, p = 1 / 0, y = 1 / 0, E = 0, b = [];\n  const {\n    preferHDR: R,\n    allowedVideoRanges: A\n  } = ub(e, n);\n  for (let j = i.length; j--; ) {\n    const C = s[i[j]];\n    u || (u = C.channels[2] &gt; 0), h = Math.min(h, C.minHeight), f = Math.min(f, C.minFramerate), p = Math.min(p, C.minBitrate), A.filter(($) =&gt; C.videoRanges[$] &gt; 0).length &gt; 0 &amp;&amp; (d = !0);\n  }\n  h = ue(h) ? h : 0, f = ue(f) ? f : 0;\n  const F = Math.max(1080, h), M = Math.max(30, f);\n  p = ue(p) ? p : t, t = Math.max(p, t), d || (e = void 0);\n  const H = i.length &gt; 1;\n  return {\n    codecSet: i.reduce((j, C) =&gt; {\n      const k = s[C];\n      if (C === j)\n        return j;\n      if (b = d ? A.filter(($) =&gt; k.videoRanges[$] &gt; 0) : [], H) {\n        if (k.minBitrate &gt; t)\n          return Ur(C, `min bitrate of ${k.minBitrate} &gt; current estimate of ${t}`), j;\n        if (!k.hasDefaultAudio)\n          return Ur(C, \"no renditions with default or auto-select sound found\"), j;\n        if (a &amp;&amp; C.indexOf(a.substring(0, 4)) % 5 !== 0)\n          return Ur(C, `audio codec preference \"${a}\" not found`), j;\n        if (o &amp;&amp; !c) {\n          if (!k.channels[o])\n            return Ur(C, `no renditions with ${o} channel sound found (channels options: ${Object.keys(k.channels)})`), j;\n        } else if ((!a || c) &amp;&amp; u &amp;&amp; k.channels[2] === 0)\n          return Ur(C, \"no renditions with stereo sound found\"), j;\n        if (k.minHeight &gt; F)\n          return Ur(C, `min resolution of ${k.minHeight} &gt; maximum of ${F}`), j;\n        if (k.minFramerate &gt; M)\n          return Ur(C, `min framerate of ${k.minFramerate} &gt; maximum of ${M}`), j;\n        if (!b.some(($) =&gt; k.videoRanges[$] &gt; 0))\n          return Ur(C, `no variants with VIDEO-RANGE of ${at(b)} found`), j;\n        if (l &amp;&amp; C.indexOf(l.substring(0, 4)) % 5 !== 0)\n          return Ur(C, `video codec preference \"${l}\" not found`), j;\n        if (k.maxScore &lt; E)\n          return Ur(C, `max score of ${k.maxScore} &lt; selected max of ${E}`), j;\n      }\n      return j &amp;&amp; (Zo(C) &gt;= Zo(j) || k.fragmentError &gt; s[j].fragmentError) ? j : (y = k.minIndex, E = k.maxScore, C);\n    }, void 0),\n    videoRanges: b,\n    preferHDR: R,\n    minFramerate: f,\n    minBitrate: p,\n    minIndex: y\n  };\n}\nfunction Ur(s, e) {\n  rt.log(`[abr] start candidates with \"${s}\" ignored because ${e}`);\n}\nfunction $g(s) {\n  return s.reduce((e, t) =&gt; {\n    let r = e.groups[t.groupId];\n    r || (r = e.groups[t.groupId] = {\n      tracks: [],\n      channels: {\n        2: 0\n      },\n      hasDefault: !1,\n      hasAutoSelect: !1\n    }), r.tracks.push(t);\n    const n = t.channels || \"2\";\n    return r.channels[n] = (r.channels[n] || 0) + 1, r.hasDefault = r.hasDefault || t.default, r.hasAutoSelect = r.hasAutoSelect || t.autoselect, r.hasDefault &amp;&amp; (e.hasDefaultAudio = !0), r.hasAutoSelect &amp;&amp; (e.hasAutoSelectAudio = !0), e;\n  }, {\n    hasDefaultAudio: !1,\n    hasAutoSelectAudio: !1,\n    groups: {}\n  });\n}\nfunction fb(s, e, t, r) {\n  return s.slice(t, r + 1).reduce((n, i, o) =&gt; {\n    if (!i.codecSet)\n      return n;\n    const a = i.audioGroups;\n    let l = n[i.codecSet];\n    l || (n[i.codecSet] = l = {\n      minBitrate: 1 / 0,\n      minHeight: 1 / 0,\n      minFramerate: 1 / 0,\n      minIndex: o,\n      maxScore: 0,\n      videoRanges: {\n        SDR: 0\n      },\n      channels: {\n        2: 0\n      },\n      hasDefaultAudio: !a,\n      fragmentError: 0\n    }), l.minBitrate = Math.min(l.minBitrate, i.bitrate);\n    const c = Math.min(i.height, i.width);\n    return l.minHeight = Math.min(l.minHeight, c), l.minFramerate = Math.min(l.minFramerate, i.frameRate), l.minIndex = Math.min(l.minIndex, o), l.maxScore = Math.max(l.maxScore, i.score), l.fragmentError += i.fragmentError, l.videoRanges[i.videoRange] = (l.videoRanges[i.videoRange] || 0) + 1, a &amp;&amp; a.forEach((u) =&gt; {\n      if (!u)\n        return;\n      const d = e.groups[u];\n      d &amp;&amp; (l.hasDefaultAudio = l.hasDefaultAudio || e.hasDefaultAudio ? d.hasDefault : d.hasAutoSelect || !e.hasDefaultAudio &amp;&amp; !e.hasAutoSelectAudio, Object.keys(d.channels).forEach((h) =&gt; {\n        l.channels[h] = (l.channels[h] || 0) + d.channels[h];\n      }));\n    }), n;\n  }, {});\n}\nfunction ch(s) {\n  if (!s)\n    return s;\n  const {\n    lang: e,\n    assocLang: t,\n    characteristics: r,\n    channels: n,\n    audioCodec: i\n  } = s;\n  return {\n    lang: e,\n    assocLang: t,\n    characteristics: r,\n    channels: n,\n    audioCodec: i\n  };\n}\nfunction Wr(s, e, t) {\n  if (\"attrs\" in s) {\n    const r = e.indexOf(s);\n    if (r !== -1)\n      return r;\n  }\n  for (let r = 0; r &lt; e.length; r++) {\n    const n = e[r];\n    if (qs(s, n, t))\n      return r;\n  }\n  return -1;\n}\nfunction qs(s, e, t) {\n  const {\n    groupId: r,\n    name: n,\n    lang: i,\n    assocLang: o,\n    default: a\n  } = s, l = s.forced;\n  return (r === void 0 || e.groupId === r) &amp;&amp; (n === void 0 || e.name === n) &amp;&amp; (i === void 0 || gb(i, e.lang)) &amp;&amp; (i === void 0 || e.assocLang === o) &amp;&amp; (a === void 0 || e.default === a) &amp;&amp; (l === void 0 || e.forced === l) &amp;&amp; (!(\"characteristics\" in s) || pb(s.characteristics || \"\", e.characteristics)) &amp;&amp; (t === void 0 || t(s, e));\n}\nfunction gb(s, e = \"--\") {\n  return s.length === e.length ? s === e : s.startsWith(e) || e.startsWith(s);\n}\nfunction pb(s, e = \"\") {\n  const t = s.split(\",\"), r = e.split(\",\");\n  return t.length === r.length &amp;&amp; !t.some((n) =&gt; r.indexOf(n) === -1);\n}\nfunction Us(s, e) {\n  const {\n    audioCodec: t,\n    channels: r\n  } = s;\n  return (t === void 0 || (e.audioCodec || \"\").substring(0, 4) === t.substring(0, 4)) &amp;&amp; (r === void 0 || r === (e.channels || \"2\"));\n}\nfunction mb(s, e, t, r, n) {\n  const i = e[r], a = e.reduce((h, f, p) =&gt; {\n    const y = f.uri;\n    return (h[y] || (h[y] = [])).push(p), h;\n  }, {})[i.uri];\n  a.length &gt; 1 &amp;&amp; (r = Math.max.apply(Math, a));\n  const l = i.videoRange, c = i.frameRate, u = i.codecSet.substring(0, 4), d = uh(e, r, (h) =&gt; {\n    if (h.videoRange !== l || h.frameRate !== c || h.codecSet.substring(0, 4) !== u)\n      return !1;\n    const f = h.audioGroups, p = t.filter((y) =&gt; !f || f.indexOf(y.groupId) !== -1);\n    return Wr(s, p, n) &gt; -1;\n  });\n  return d &gt; -1 ? d : uh(e, r, (h) =&gt; {\n    const f = h.audioGroups, p = t.filter((y) =&gt; !f || f.indexOf(y.groupId) !== -1);\n    return Wr(s, p, n) &gt; -1;\n  });\n}\nfunction uh(s, e, t) {\n  for (let r = e; r &gt; -1; r--)\n    if (t(s[r]))\n      return r;\n  for (let r = e + 1; r &lt; s.length; r++)\n    if (t(s[r]))\n      return r;\n  return -1;\n}\nfunction Qo(s, e) {\n  var t;\n  return !!s &amp;&amp; s !== ((t = e.loadLevelObj) == null ? void 0 : t.uri);\n}\nclass yb extends Lr {\n  constructor(e) {\n    super(\"abr\", e.logger), this.hls = void 0, this.lastLevelLoadSec = 0, this.lastLoadedFragLevel = -1, this.firstSelection = -1, this._nextAutoLevel = -1, this.nextAutoLevelKey = \"\", this.audioTracksByGroup = null, this.codecTiers = null, this.timer = -1, this.fragCurrent = null, this.partCurrent = null, this.bitrateTestDelay = 0, this.rebufferNotice = -1, this.supportedCache = {}, this.bwEstimator = void 0, this._abandonRulesCheck = (t) =&gt; {\n      var r;\n      const {\n        fragCurrent: n,\n        partCurrent: i,\n        hls: o\n      } = this, {\n        autoLevelEnabled: a,\n        media: l\n      } = o;\n      if (!n || !l)\n        return;\n      const c = performance.now(), u = i ? i.stats : n.stats, d = i ? i.duration : n.duration, h = c - u.loading.start, f = o.minAutoLevel, p = n.level, y = this._nextAutoLevel;\n      if (u.aborted || u.loaded &amp;&amp; u.loaded === u.total || p &lt;= f) {\n        this.clearTimer(), this._nextAutoLevel = -1;\n        return;\n      }\n      if (!a)\n        return;\n      const E = y &gt; -1 &amp;&amp; y !== p, b = !!t || E;\n      if (!b &amp;&amp; (l.paused || !l.playbackRate || !l.readyState))\n        return;\n      const R = o.mainForwardBufferInfo;\n      if (!b &amp;&amp; R === null)\n        return;\n      const A = this.bwEstimator.getEstimateTTFB(), F = Math.abs(l.playbackRate);\n      if (h &lt;= Math.max(A, 1e3 * (d / (F * 2))))\n        return;\n      const M = R ? R.len / F : 0, H = u.loading.first ? u.loading.first - u.loading.start : -1, K = u.loaded &amp;&amp; H &gt; -1, j = this.getBwEstimate(), C = o.levels, k = C[p], $ = Math.max(u.loaded, Math.round(d * (n.bitrate || k.averageBitrate) / 8));\n      let W = K ? h - H : h;\n      W &lt; 1 &amp;&amp; K &amp;&amp; (W = Math.min(h, u.loaded * 8 / j));\n      const _ = K ? u.loaded * 1e3 / W : 0, g = A / 1e3, x = _ ? ($ - u.loaded) / _ : $ * 8 / j + g;\n      if (x &lt;= M)\n        return;\n      const w = _ ? _ * 8 : j, D = ((r = (t == null ? void 0 : t.details) || this.hls.latestLevelDetails) == null ? void 0 : r.live) === !0, O = this.hls.config.abrBandWidthUpFactor;\n      let U = Number.POSITIVE_INFINITY, V;\n      for (V = p - 1; V &gt; f; V--) {\n        const P = C[V].maxBitrate, N = !C[V].details || D;\n        if (U = this.getTimeToLoadFrag(g, w, d * P, N), U &lt; Math.min(M, d + g))\n          break;\n      }\n      if (U &gt;= x || U &gt; d * 10)\n        return;\n      K ? this.bwEstimator.sample(h - Math.min(A, H), u.loaded) : this.bwEstimator.sampleTTFB(h);\n      const L = C[V].maxBitrate;\n      this.getBwEstimate() * O &gt; L &amp;&amp; this.resetEstimator(L);\n      const m = this.findBestLevel(L, f, V, 0, M, 1, 1);\n      m &gt; -1 &amp;&amp; (V = m), this.warn(`Fragment ${n.sn}${i ? \" part \" + i.index : \"\"} of level ${p} is loading too slowly;\n      Fragment duration: ${n.duration.toFixed(3)}\n      Time to underbuffer: ${M.toFixed(3)} s\n      Estimated load time for current fragment: ${x.toFixed(3)} s\n      Estimated load time for down switch fragment: ${U.toFixed(3)} s\n      TTFB estimate: ${H | 0} ms\n      Current BW estimate: ${ue(j) ? j | 0 : \"Unknown\"} bps\n      New BW estimate: ${this.getBwEstimate() | 0} bps\n      Switching to level ${V} @ ${L | 0} bps`), o.nextLoadLevel = o.nextAutoLevel = V, this.clearTimer();\n      const v = () =&gt; {\n        if (this.clearTimer(), this.fragCurrent === n &amp;&amp; this.hls.loadLevel === V &amp;&amp; V &gt; 0) {\n          const P = this.getStarvationDelay();\n          if (this.warn(`Aborting inflight request ${V &gt; 0 ? \"and switching down\" : \"\"}\n      Fragment duration: ${n.duration.toFixed(3)} s\n      Time to underbuffer: ${P.toFixed(3)} s`), n.abortRequests(), this.fragCurrent = this.partCurrent = null, V &gt; f) {\n            let N = this.findBestLevel(this.hls.levels[f].bitrate, f, V, 0, P, 1, 1);\n            N === -1 &amp;&amp; (N = f), this.hls.nextLoadLevel = this.hls.nextAutoLevel = N, this.resetEstimator(this.hls.levels[N].bitrate);\n          }\n        }\n      };\n      E || x &gt; U * 2 ? v() : this.timer = self.setInterval(v, U * 1e3), o.trigger(I.FRAG_LOAD_EMERGENCY_ABORTED, {\n        frag: n,\n        part: i,\n        stats: u\n      });\n    }, this.hls = e, this.bwEstimator = this.initEstimator(), this.registerListeners();\n  }\n  resetEstimator(e) {\n    e &amp;&amp; (this.log(`setting initial bwe to ${e}`), this.hls.config.abrEwmaDefaultEstimate = e), this.firstSelection = -1, this.bwEstimator = this.initEstimator();\n  }\n  initEstimator() {\n    const e = this.hls.config;\n    return new TS(e.abrEwmaSlowVoD, e.abrEwmaFastVoD, e.abrEwmaDefaultEstimate);\n  }\n  registerListeners() {\n    const {\n      hls: e\n    } = this;\n    e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.FRAG_LOADING, this.onFragLoading, this), e.on(I.FRAG_LOADED, this.onFragLoaded, this), e.on(I.FRAG_BUFFERED, this.onFragBuffered, this), e.on(I.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(I.LEVEL_LOADED, this.onLevelLoaded, this), e.on(I.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(I.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.on(I.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls: e\n    } = this;\n    e &amp;&amp; (e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.FRAG_LOADING, this.onFragLoading, this), e.off(I.FRAG_LOADED, this.onFragLoaded, this), e.off(I.FRAG_BUFFERED, this.onFragBuffered, this), e.off(I.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(I.LEVEL_LOADED, this.onLevelLoaded, this), e.off(I.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(I.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this), e.off(I.ERROR, this.onError, this));\n  }\n  destroy() {\n    this.unregisterListeners(), this.clearTimer(), this.hls = this._abandonRulesCheck = this.supportedCache = null, this.fragCurrent = this.partCurrent = null;\n  }\n  onManifestLoading(e, t) {\n    this.lastLoadedFragLevel = -1, this.firstSelection = -1, this.lastLevelLoadSec = 0, this.supportedCache = {}, this.fragCurrent = this.partCurrent = null, this.onLevelsUpdated(), this.clearTimer();\n  }\n  onLevelsUpdated() {\n    this.lastLoadedFragLevel &gt; -1 &amp;&amp; this.fragCurrent &amp;&amp; (this.lastLoadedFragLevel = this.fragCurrent.level), this._nextAutoLevel = -1, this.onMaxAutoLevelUpdated(), this.codecTiers = null, this.audioTracksByGroup = null;\n  }\n  onMaxAutoLevelUpdated() {\n    this.firstSelection = -1, this.nextAutoLevelKey = \"\";\n  }\n  onFragLoading(e, t) {\n    const r = t.frag;\n    if (!this.ignoreFragment(r)) {\n      if (!r.bitrateTest) {\n        var n;\n        this.fragCurrent = r, this.partCurrent = (n = t.part) != null ? n : null;\n      }\n      this.clearTimer(), this.timer = self.setInterval(this._abandonRulesCheck, 100);\n    }\n  }\n  onLevelSwitching(e, t) {\n    this.clearTimer();\n  }\n  onError(e, t) {\n    if (!t.fatal)\n      switch (t.details) {\n        case J.BUFFER_ADD_CODEC_ERROR:\n        case J.BUFFER_APPEND_ERROR:\n          this.lastLoadedFragLevel = -1, this.firstSelection = -1;\n          break;\n        case J.FRAG_LOAD_TIMEOUT: {\n          const r = t.frag, {\n            fragCurrent: n,\n            partCurrent: i\n          } = this;\n          if (r &amp;&amp; n &amp;&amp; r.sn === n.sn &amp;&amp; r.level === n.level) {\n            const o = performance.now(), a = i ? i.stats : r.stats, l = o - a.loading.start, c = a.loading.first ? a.loading.first - a.loading.start : -1;\n            if (a.loaded &amp;&amp; c &gt; -1) {\n              const d = this.bwEstimator.getEstimateTTFB();\n              this.bwEstimator.sample(l - Math.min(d, c), a.loaded);\n            } else\n              this.bwEstimator.sampleTTFB(l);\n          }\n          break;\n        }\n      }\n  }\n  getTimeToLoadFrag(e, t, r, n) {\n    const i = e + r / t, o = n ? e + this.lastLevelLoadSec : 0;\n    return i + o;\n  }\n  onLevelLoaded(e, t) {\n    const r = this.hls.config, {\n      loading: n\n    } = t.stats, i = n.end - n.first;\n    ue(i) &amp;&amp; (this.lastLevelLoadSec = i / 1e3), t.details.live ? this.bwEstimator.update(r.abrEwmaSlowLive, r.abrEwmaFastLive) : this.bwEstimator.update(r.abrEwmaSlowVoD, r.abrEwmaFastVoD), this.timer &gt; -1 &amp;&amp; this._abandonRulesCheck(t.levelInfo);\n  }\n  onFragLoaded(e, {\n    frag: t,\n    part: r\n  }) {\n    const n = r ? r.stats : t.stats;\n    if (t.type === pe.MAIN &amp;&amp; this.bwEstimator.sampleTTFB(n.loading.first - n.loading.start), !this.ignoreFragment(t)) {\n      if (this.clearTimer(), t.level === this._nextAutoLevel &amp;&amp; (this._nextAutoLevel = -1), this.firstSelection = -1, this.hls.config.abrMaxWithRealBitrate) {\n        const i = r ? r.duration : t.duration, o = this.hls.levels[t.level], a = (o.loaded ? o.loaded.bytes : 0) + n.loaded, l = (o.loaded ? o.loaded.duration : 0) + i;\n        o.loaded = {\n          bytes: a,\n          duration: l\n        }, o.realBitrate = Math.round(8 * a / l);\n      }\n      if (t.bitrateTest) {\n        const i = {\n          stats: n,\n          frag: t,\n          part: r,\n          id: t.type\n        };\n        this.onFragBuffered(I.FRAG_BUFFERED, i), t.bitrateTest = !1;\n      } else\n        this.lastLoadedFragLevel = t.level;\n    }\n  }\n  onFragBuffered(e, t) {\n    const {\n      frag: r,\n      part: n\n    } = t, i = n != null &amp;&amp; n.stats.loaded ? n.stats : r.stats;\n    if (i.aborted || this.ignoreFragment(r))\n      return;\n    const o = i.parsing.end - i.loading.start - Math.min(i.loading.first - i.loading.start, this.bwEstimator.getEstimateTTFB());\n    this.bwEstimator.sample(o, i.loaded), i.bwEstimate = this.getBwEstimate(), r.bitrateTest ? this.bitrateTestDelay = o / 1e3 : this.bitrateTestDelay = 0;\n  }\n  ignoreFragment(e) {\n    return e.type !== pe.MAIN || e.sn === \"initSegment\";\n  }\n  clearTimer() {\n    this.timer &gt; -1 &amp;&amp; (self.clearInterval(this.timer), this.timer = -1);\n  }\n  get firstAutoLevel() {\n    const {\n      maxAutoLevel: e,\n      minAutoLevel: t\n    } = this.hls, r = this.getBwEstimate(), n = this.hls.config.maxStarvationDelay, i = this.findBestLevel(r, t, e, 0, n, 1, 1);\n    if (i &gt; -1)\n      return i;\n    const o = this.hls.firstLevel, a = Math.min(Math.max(o, t), e);\n    return this.warn(`Could not find best starting auto level. Defaulting to first in playlist ${o} clamped to ${a}`), a;\n  }\n  get forcedAutoLevel() {\n    return this.nextAutoLevelKey ? -1 : this._nextAutoLevel;\n  }\n  // return next auto level\n  get nextAutoLevel() {\n    const e = this.forcedAutoLevel, r = this.bwEstimator.canEstimate(), n = this.lastLoadedFragLevel &gt; -1;\n    if (e !== -1 &amp;&amp; (!r || !n || this.nextAutoLevelKey === this.getAutoLevelKey()))\n      return e;\n    const i = r &amp;&amp; n ? this.getNextABRAutoLevel() : this.firstAutoLevel;\n    if (e !== -1) {\n      const o = this.hls.levels;\n      if (o.length &gt; Math.max(e, i) &amp;&amp; o[e].loadError &lt;= o[i].loadError)\n        return e;\n    }\n    return this._nextAutoLevel = i, this.nextAutoLevelKey = this.getAutoLevelKey(), i;\n  }\n  getAutoLevelKey() {\n    return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`;\n  }\n  getNextABRAutoLevel() {\n    const {\n      fragCurrent: e,\n      partCurrent: t,\n      hls: r\n    } = this;\n    if (r.levels.length &lt;= 1)\n      return r.loadLevel;\n    const {\n      maxAutoLevel: n,\n      config: i,\n      minAutoLevel: o\n    } = r, a = t ? t.duration : e ? e.duration : 0, l = this.getBwEstimate(), c = this.getStarvationDelay();\n    let u = i.abrBandWidthFactor, d = i.abrBandWidthUpFactor;\n    if (c) {\n      const E = this.findBestLevel(l, o, n, c, 0, u, d);\n      if (E &gt;= 0)\n        return this.rebufferNotice = -1, E;\n    }\n    let h = a ? Math.min(a, i.maxStarvationDelay) : i.maxStarvationDelay;\n    if (!c) {\n      const E = this.bitrateTestDelay;\n      E &amp;&amp; (h = (a ? Math.min(a, i.maxLoadingDelay) : i.maxLoadingDelay) - E, this.info(`bitrate test took ${Math.round(1e3 * E)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * h)} ms`), u = d = 1);\n    }\n    const f = this.findBestLevel(l, o, n, c, h, u, d);\n    if (this.rebufferNotice !== f &amp;&amp; (this.rebufferNotice = f, this.info(`${c ? \"rebuffering expected\" : \"buffer is empty\"}, optimal quality level ${f}`)), f &gt; -1)\n      return f;\n    const p = r.levels[o], y = r.loadLevelObj;\n    return y &amp;&amp; (p == null ? void 0 : p.bitrate) &lt; y.bitrate ? o : r.loadLevel;\n  }\n  getStarvationDelay() {\n    const e = this.hls, t = e.media;\n    if (!t)\n      return 1 / 0;\n    const r = t &amp;&amp; t.playbackRate !== 0 ? Math.abs(t.playbackRate) : 1, n = e.mainForwardBufferInfo;\n    return (n ? n.len : 0) / r;\n  }\n  getBwEstimate() {\n    return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;\n  }\n  findBestLevel(e, t, r, n, i, o, a) {\n    var l;\n    const c = n + i, u = this.lastLoadedFragLevel, d = u === -1 ? this.hls.firstLevel : u, {\n      fragCurrent: h,\n      partCurrent: f\n    } = this, {\n      levels: p,\n      allAudioTracks: y,\n      loadLevel: E,\n      config: b\n    } = this.hls;\n    if (p.length === 1)\n      return 0;\n    const R = p[d], A = !!((l = this.hls.latestLevelDetails) != null &amp;&amp; l.live), F = E === -1 || u === -1;\n    let M, H = \"SDR\", K = (R == null ? void 0 : R.frameRate) || 0;\n    const {\n      audioPreference: j,\n      videoPreference: C\n    } = b, k = this.audioTracksByGroup || (this.audioTracksByGroup = $g(y));\n    let $ = -1;\n    if (F) {\n      if (this.firstSelection !== -1)\n        return this.firstSelection;\n      const w = this.codecTiers || (this.codecTiers = fb(p, k, t, r)), D = hb(w, H, e, j, C), {\n        codecSet: O,\n        videoRanges: U,\n        minFramerate: V,\n        minBitrate: L,\n        minIndex: m,\n        preferHDR: v\n      } = D;\n      $ = m, M = O, H = v ? U[U.length - 1] : U[0], K = V, e = Math.max(e, L), this.log(`picked start tier ${at(D)}`);\n    } else\n      M = R == null ? void 0 : R.codecSet, H = R == null ? void 0 : R.videoRange;\n    const W = f ? f.duration : h ? h.duration : 0, _ = this.bwEstimator.getEstimateTTFB() / 1e3, g = [];\n    for (let w = r; w &gt;= t; w--) {\n      var x;\n      const D = p[w], O = w &gt; d;\n      if (!D)\n        continue;\n      if (b.useMediaCapabilities &amp;&amp; !D.supportedResult &amp;&amp; !D.supportedPromise) {\n        const N = navigator.mediaCapabilities;\n        typeof (N == null ? void 0 : N.decodingInfo) == \"function\" &amp;&amp; rb(D, k, H, K, e, j) ? (D.supportedPromise = Ng(D, k, N, this.supportedCache), D.supportedPromise.then((Y) =&gt; {\n          if (!this.hls)\n            return;\n          D.supportedResult = Y;\n          const ee = this.hls.levels, ie = ee.indexOf(D);\n          Y.error ? this.warn(`MediaCapabilities decodingInfo error: \"${Y.error}\" for level ${ie} ${at(Y)}`) : Y.supported ? Y.decodingInfoResults.some((le) =&gt; le.smooth === !1 || le.powerEfficient === !1) &amp;&amp; this.log(`MediaCapabilities decodingInfo for level ${ie} not smooth or powerEfficient: ${at(Y)}`) : (this.warn(`Unsupported MediaCapabilities decodingInfo result for level ${ie} ${at(Y)}`), ie &gt; -1 &amp;&amp; ee.length &gt; 1 &amp;&amp; (this.log(`Removing unsupported level ${ie}`), this.hls.removeLevel(ie), this.hls.loadLevel === -1 &amp;&amp; (this.hls.nextLoadLevel = 0)));\n        }).catch((Y) =&gt; {\n          this.warn(`Error handling MediaCapabilities decodingInfo: ${Y}`);\n        })) : D.supportedResult = Bg;\n      }\n      if ((M &amp;&amp; D.codecSet !== M || H &amp;&amp; D.videoRange !== H || O &amp;&amp; K &gt; D.frameRate || !O &amp;&amp; K &gt; 0 &amp;&amp; K &lt; D.frameRate || (x = D.supportedResult) != null &amp;&amp; (x = x.decodingInfoResults) != null &amp;&amp; x.some((N) =&gt; N.smooth === !1)) &amp;&amp; (!F || w !== $)) {\n        g.push(w);\n        continue;\n      }\n      const U = D.details, V = (f ? U == null ? void 0 : U.partTarget : U == null ? void 0 : U.averagetargetduration) || W;\n      let L;\n      O ? L = a * e : L = o * e;\n      const m = W &amp;&amp; n &gt;= W * 2 &amp;&amp; i === 0 ? D.averageBitrate : D.maxBitrate, v = this.getTimeToLoadFrag(_, L, m * V, U === void 0);\n      if (\n        // if adjusted bw is greater than level bitrate AND\n        L &gt;= m &amp;&amp; // no level change, or new level has no error history\n        (w === u || D.loadError === 0 &amp;&amp; D.fragmentError === 0) &amp;&amp; // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches\n        // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...\n        // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1\n        (v &lt;= _ || !ue(v) || A &amp;&amp; !this.bitrateTestDelay || v &lt; c)\n      ) {\n        const N = this.forcedAutoLevel;\n        return w !== E &amp;&amp; (N === -1 || N !== E) &amp;&amp; (g.length &amp;&amp; this.trace(`Skipped level(s) ${g.join(\",\")} of ${r} max with CODECS and VIDEO-RANGE:\"${p[g[0]].codecs}\" ${p[g[0]].videoRange}; not compatible with \"${M}\" ${H}`), this.info(`switch candidate:${d}-&gt;${w} adjustedbw(${Math.round(L)})-bitrate=${Math.round(L - m)} ttfb:${_.toFixed(1)} avgDuration:${V.toFixed(1)} maxFetchDuration:${c.toFixed(1)} fetchDuration:${v.toFixed(1)} firstSelection:${F} codecSet:${D.codecSet} videoRange:${D.videoRange} hls.loadLevel:${E}`)), F &amp;&amp; (this.firstSelection = w), w;\n      }\n    }\n    return -1;\n  }\n  set nextAutoLevel(e) {\n    const t = this.deriveNextAutoLevel(e);\n    this._nextAutoLevel !== t &amp;&amp; (this.nextAutoLevelKey = \"\", this._nextAutoLevel = t);\n  }\n  deriveNextAutoLevel(e) {\n    const {\n      maxAutoLevel: t,\n      minAutoLevel: r\n    } = this.hls;\n    return Math.min(Math.max(e, r), t);\n  }\n}\nconst Gg = {\n  /**\n   * Searches for an item in an array which matches a certain condition.\n   * This requires the condition to only match one item in the array,\n   * and for the array to be ordered.\n   *\n   * @param list The array to search.\n   * @param comparisonFn\n   *      Called and provided a candidate item as the first argument.\n   *      Should return:\n   *          &gt; -1 if the item should be located at a lower index than the provided item.\n   *          &gt; 1 if the item should be located at a higher index than the provided item.\n   *          &gt; 0 if the item is the item you're looking for.\n   *\n   * @returns the object if found, otherwise returns null\n   */\n  search: function(s, e) {\n    let t = 0, r = s.length - 1, n = null, i = null;\n    for (; t &lt;= r; ) {\n      n = (t + r) / 2 | 0, i = s[n];\n      const o = e(i);\n      if (o &gt; 0)\n        t = n + 1;\n      else if (o &lt; 0)\n        r = n - 1;\n      else\n        return i;\n    }\n    return null;\n  }\n};\nfunction vb(s, e, t) {\n  if (e === null || !Array.isArray(s) || !s.length || !ue(e))\n    return null;\n  const r = s[0].programDateTime;\n  if (e &lt; (r || 0))\n    return null;\n  const n = s[s.length - 1].endProgramDateTime;\n  if (e &gt;= (n || 0))\n    return null;\n  for (let i = 0; i &lt; s.length; ++i) {\n    const o = s[i];\n    if (xb(e, t, o))\n      return o;\n  }\n  return null;\n}\nfunction Js(s, e, t = 0, r = 0, n = 5e-3) {\n  let i = null;\n  if (s) {\n    i = e[1 + s.sn - e[0].sn] || null;\n    const a = s.endDTS - t;\n    a &gt; 0 &amp;&amp; a &lt; 15e-7 &amp;&amp; (t += 15e-7), i &amp;&amp; s.level !== i.level &amp;&amp; i.end &lt;= s.end &amp;&amp; (i = e[2 + s.sn - e[0].sn] || null);\n  } else t === 0 &amp;&amp; e[0].start === 0 &amp;&amp; (i = e[0]);\n  if (i &amp;&amp; ((!s || s.level === i.level) &amp;&amp; dh(t, r, i) === 0 || Eb(i, s, Math.min(n, r))))\n    return i;\n  const o = Gg.search(e, dh.bind(null, t, r));\n  return o &amp;&amp; (o !== s || !i) ? o : i;\n}\nfunction Eb(s, e, t) {\n  if (e &amp;&amp; e.start === 0 &amp;&amp; e.level &lt; s.level &amp;&amp; (e.endPTS || 0) &gt; 0) {\n    const r = e.tagList.reduce((n, i) =&gt; (i[0] === \"INF\" &amp;&amp; (n += parseFloat(i[1])), n), t);\n    return s.start &lt;= r;\n  }\n  return !1;\n}\nfunction dh(s = 0, e = 0, t) {\n  if (t.start &lt;= s &amp;&amp; t.start + t.duration &gt; s)\n    return 0;\n  const r = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0));\n  return t.start + t.duration - r &lt;= s ? 1 : t.start - r &gt; s &amp;&amp; t.start ? -1 : 0;\n}\nfunction xb(s, e, t) {\n  const r = Math.min(e, t.duration + (t.deltaPTS ? t.deltaPTS : 0)) * 1e3;\n  return (t.endProgramDateTime || 0) - r &gt; s;\n}\nfunction Vg(s, e, t) {\n  if (s &amp;&amp; s.startCC &lt;= e &amp;&amp; s.endCC &gt;= e) {\n    let r = s.fragments;\n    const {\n      fragmentHint: n\n    } = s;\n    n &amp;&amp; (r = r.concat(n));\n    let i;\n    return Gg.search(r, (o) =&gt; o.cc &lt; e ? 1 : o.cc &gt; e ? -1 : (i = o, o.end &lt;= t ? 1 : o.start &gt; t ? -1 : 0)), i || null;\n  }\n  return null;\n}\nfunction ea(s) {\n  switch (s.details) {\n    case J.FRAG_LOAD_TIMEOUT:\n    case J.KEY_LOAD_TIMEOUT:\n    case J.LEVEL_LOAD_TIMEOUT:\n    case J.MANIFEST_LOAD_TIMEOUT:\n      return !0;\n  }\n  return !1;\n}\nfunction jg(s) {\n  return s.details.startsWith(\"key\");\n}\nfunction Kg(s) {\n  return jg(s) &amp;&amp; !!s.frag &amp;&amp; !s.frag.decryptdata;\n}\nfunction hh(s, e) {\n  const t = ea(e);\n  return s.default[`${t ? \"timeout\" : \"error\"}Retry`];\n}\nfunction yu(s, e) {\n  const t = s.backoff === \"linear\" ? 1 : Math.pow(2, e);\n  return Math.min(t * s.retryDelayMs, s.maxRetryDelayMs);\n}\nfunction fh(s) {\n  return tt(tt({}, s), {\n    errorRetry: null,\n    timeoutRetry: null\n  });\n}\nfunction ta(s, e, t, r) {\n  if (!s)\n    return !1;\n  const n = r == null ? void 0 : r.code, i = e &lt; s.maxNumRetry &amp;&amp; (Sb(n) || !!t);\n  return s.shouldRetry ? s.shouldRetry(s, e, t, r, i) : i;\n}\nfunction Sb(s) {\n  return uc(s) || !!s &amp;&amp; (s &lt; 400 || s &gt; 499);\n}\nfunction uc(s) {\n  return s === 0 &amp;&amp; navigator.onLine === !1;\n}\nvar Zt = {\n  DoNothing: 0,\n  SendAlternateToPenaltyBox: 2,\n  RemoveAlternatePermanently: 3,\n  RetryRequest: 5\n}, vr = {\n  None: 0,\n  MoveAllAlternatesMatchingHost: 1,\n  MoveAllAlternatesMatchingHDCP: 2,\n  MoveAllAlternatesMatchingKey: 4\n};\nclass bb extends Lr {\n  constructor(e) {\n    super(\"error-controller\", e.logger), this.hls = void 0, this.playlistError = 0, this.hls = e, this.registerListeners();\n  }\n  registerListeners() {\n    const e = this.hls;\n    e.on(I.ERROR, this.onError, this), e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n  unregisterListeners() {\n    const e = this.hls;\n    e &amp;&amp; (e.off(I.ERROR, this.onError, this), e.off(I.ERROR, this.onErrorOut, this), e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.LEVEL_UPDATED, this.onLevelUpdated, this));\n  }\n  destroy() {\n    this.unregisterListeners(), this.hls = null;\n  }\n  startLoad(e) {\n  }\n  stopLoad() {\n    this.playlistError = 0;\n  }\n  getVariantLevelIndex(e) {\n    return (e == null ? void 0 : e.type) === pe.MAIN ? e.level : this.getVariantIndex();\n  }\n  getVariantIndex() {\n    var e;\n    const t = this.hls, r = t.currentLevel;\n    return (e = t.loadLevelObj) != null &amp;&amp; e.details || r === -1 ? t.loadLevel : r;\n  }\n  variantHasKey(e, t) {\n    if (e) {\n      var r;\n      if ((r = e.details) != null &amp;&amp; r.hasKey(t))\n        return !0;\n      const n = e.audioGroups;\n      if (n)\n        return this.hls.allAudioTracks.filter((o) =&gt; n.indexOf(o.groupId) &gt;= 0).some((o) =&gt; {\n          var a;\n          return (a = o.details) == null ? void 0 : a.hasKey(t);\n        });\n    }\n    return !1;\n  }\n  onManifestLoading() {\n    this.playlistError = 0;\n  }\n  onLevelUpdated() {\n    this.playlistError = 0;\n  }\n  onError(e, t) {\n    var r;\n    if (t.fatal)\n      return;\n    const n = this.hls, i = t.context;\n    switch (t.details) {\n      case J.FRAG_LOAD_ERROR:\n      case J.FRAG_LOAD_TIMEOUT:\n      case J.KEY_LOAD_ERROR:\n      case J.KEY_LOAD_TIMEOUT:\n        t.errorAction = this.getFragRetryOrSwitchAction(t);\n        return;\n      case J.FRAG_PARSING_ERROR:\n        if ((r = t.frag) != null &amp;&amp; r.gap) {\n          t.errorAction = An();\n          return;\n        }\n      // falls through\n      case J.FRAG_GAP:\n      case J.FRAG_DECRYPT_ERROR: {\n        t.errorAction = this.getFragRetryOrSwitchAction(t), t.errorAction.action = Zt.SendAlternateToPenaltyBox;\n        return;\n      }\n      case J.LEVEL_EMPTY_ERROR:\n      case J.LEVEL_PARSING_ERROR:\n        {\n          var o;\n          const l = t.parent === pe.MAIN ? t.level : n.loadLevel;\n          t.details === J.LEVEL_EMPTY_ERROR &amp;&amp; ((o = t.context) != null &amp;&amp; (o = o.levelDetails) != null &amp;&amp; o.live) ? t.errorAction = this.getPlaylistRetryOrSwitchAction(t, l) : (t.levelRetry = !1, t.errorAction = this.getLevelSwitchAction(t, l));\n        }\n        return;\n      case J.LEVEL_LOAD_ERROR:\n      case J.LEVEL_LOAD_TIMEOUT:\n        typeof (i == null ? void 0 : i.level) == \"number\" &amp;&amp; (t.errorAction = this.getPlaylistRetryOrSwitchAction(t, i.level));\n        return;\n      case J.AUDIO_TRACK_LOAD_ERROR:\n      case J.AUDIO_TRACK_LOAD_TIMEOUT:\n      case J.SUBTITLE_LOAD_ERROR:\n      case J.SUBTITLE_TRACK_LOAD_TIMEOUT:\n        if (i) {\n          const l = n.loadLevelObj;\n          if (l &amp;&amp; (i.type === Ke.AUDIO_TRACK &amp;&amp; l.hasAudioGroup(i.groupId) || i.type === Ke.SUBTITLE_TRACK &amp;&amp; l.hasSubtitleGroup(i.groupId))) {\n            t.errorAction = this.getPlaylistRetryOrSwitchAction(t, n.loadLevel), t.errorAction.action = Zt.SendAlternateToPenaltyBox, t.errorAction.flags = vr.MoveAllAlternatesMatchingHost;\n            return;\n          }\n        }\n        return;\n      case J.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:\n        t.errorAction = {\n          action: Zt.SendAlternateToPenaltyBox,\n          flags: vr.MoveAllAlternatesMatchingHDCP\n        };\n        return;\n      case J.KEY_SYSTEM_SESSION_UPDATE_FAILED:\n      case J.KEY_SYSTEM_STATUS_INTERNAL_ERROR:\n      case J.KEY_SYSTEM_NO_SESSION:\n        t.errorAction = {\n          action: Zt.SendAlternateToPenaltyBox,\n          flags: vr.MoveAllAlternatesMatchingKey\n        };\n        return;\n      case J.BUFFER_ADD_CODEC_ERROR:\n      case J.REMUX_ALLOC_ERROR:\n      case J.BUFFER_APPEND_ERROR:\n        if (!t.errorAction) {\n          var a;\n          t.errorAction = this.getLevelSwitchAction(t, (a = t.level) != null ? a : n.loadLevel);\n        }\n        return;\n      case J.INTERNAL_EXCEPTION:\n      case J.BUFFER_APPENDING_ERROR:\n      case J.BUFFER_FULL_ERROR:\n      case J.LEVEL_SWITCH_ERROR:\n      case J.BUFFER_STALLED_ERROR:\n      case J.BUFFER_SEEK_OVER_HOLE:\n      case J.BUFFER_NUDGE_ON_STALL:\n        t.errorAction = An();\n        return;\n    }\n    t.type === ve.KEY_SYSTEM_ERROR &amp;&amp; (t.levelRetry = !1, t.errorAction = An());\n  }\n  getPlaylistRetryOrSwitchAction(e, t) {\n    const r = this.hls, n = hh(r.config.playlistLoadPolicy, e), i = this.playlistError++;\n    if (ta(n, i, ea(e), e.response))\n      return {\n        action: Zt.RetryRequest,\n        flags: vr.None,\n        retryConfig: n,\n        retryCount: i\n      };\n    const a = this.getLevelSwitchAction(e, t);\n    return n &amp;&amp; (a.retryConfig = n, a.retryCount = i), a;\n  }\n  getFragRetryOrSwitchAction(e) {\n    const t = this.hls, r = this.getVariantLevelIndex(e.frag), n = t.levels[r], {\n      fragLoadPolicy: i,\n      keyLoadPolicy: o\n    } = t.config, a = hh(jg(e) ? o : i, e), l = t.levels.reduce((u, d) =&gt; u + d.fragmentError, 0);\n    if (n &amp;&amp; (e.details !== J.FRAG_GAP &amp;&amp; n.fragmentError++, !Kg(e) &amp;&amp; ta(a, l, ea(e), e.response)))\n      return {\n        action: Zt.RetryRequest,\n        flags: vr.None,\n        retryConfig: a,\n        retryCount: l\n      };\n    const c = this.getLevelSwitchAction(e, r);\n    return a &amp;&amp; (c.retryConfig = a, c.retryCount = l), c;\n  }\n  getLevelSwitchAction(e, t) {\n    const r = this.hls;\n    t == null &amp;&amp; (t = r.loadLevel);\n    const n = this.hls.levels[t];\n    if (n) {\n      var i, o;\n      const c = e.details;\n      n.loadError++, c === J.BUFFER_APPEND_ERROR &amp;&amp; n.fragmentError++;\n      let u = -1;\n      const {\n        levels: d,\n        loadLevel: h,\n        minAutoLevel: f,\n        maxAutoLevel: p\n      } = r;\n      !r.autoLevelEnabled &amp;&amp; !r.config.preserveManualLevelOnError &amp;&amp; (r.loadLevel = -1);\n      const y = (i = e.frag) == null ? void 0 : i.type, b = (y === pe.AUDIO &amp;&amp; c === J.FRAG_PARSING_ERROR || e.sourceBufferName === \"audio\" &amp;&amp; (c === J.BUFFER_ADD_CODEC_ERROR || c === J.BUFFER_APPEND_ERROR)) &amp;&amp; d.some(({\n        audioCodec: H\n      }) =&gt; n.audioCodec !== H), A = e.sourceBufferName === \"video\" &amp;&amp; (c === J.BUFFER_ADD_CODEC_ERROR || c === J.BUFFER_APPEND_ERROR) &amp;&amp; d.some(({\n        codecSet: H,\n        audioCodec: K\n      }) =&gt; n.codecSet !== H &amp;&amp; n.audioCodec === K), {\n        type: F,\n        groupId: M\n      } = (o = e.context) != null ? o : {};\n      for (let H = d.length; H--; ) {\n        const K = (H + h) % d.length;\n        if (K !== h &amp;&amp; K &gt;= f &amp;&amp; K &lt;= p &amp;&amp; d[K].loadError === 0) {\n          var a, l;\n          const j = d[K];\n          if (c === J.FRAG_GAP &amp;&amp; y === pe.MAIN &amp;&amp; e.frag) {\n            const C = d[K].details;\n            if (C) {\n              const k = Js(e.frag, C.fragments, e.frag.start);\n              if (k != null &amp;&amp; k.gap)\n                continue;\n            }\n          } else {\n            if (F === Ke.AUDIO_TRACK &amp;&amp; j.hasAudioGroup(M) || F === Ke.SUBTITLE_TRACK &amp;&amp; j.hasSubtitleGroup(M))\n              continue;\n            if (y === pe.AUDIO &amp;&amp; (a = n.audioGroups) != null &amp;&amp; a.some((C) =&gt; j.hasAudioGroup(C)) || y === pe.SUBTITLE &amp;&amp; (l = n.subtitleGroups) != null &amp;&amp; l.some((C) =&gt; j.hasSubtitleGroup(C)) || b &amp;&amp; n.audioCodec === j.audioCodec || A &amp;&amp; n.codecSet === j.codecSet || !b &amp;&amp; n.codecSet !== j.codecSet)\n              continue;\n          }\n          u = K;\n          break;\n        }\n      }\n      if (u &gt; -1 &amp;&amp; r.loadLevel !== u)\n        return e.levelRetry = !0, this.playlistError = 0, {\n          action: Zt.SendAlternateToPenaltyBox,\n          flags: vr.None,\n          nextAutoLevel: u\n        };\n    }\n    return {\n      action: Zt.SendAlternateToPenaltyBox,\n      flags: vr.MoveAllAlternatesMatchingHost\n    };\n  }\n  onErrorOut(e, t) {\n    var r;\n    switch ((r = t.errorAction) == null ? void 0 : r.action) {\n      case Zt.DoNothing:\n        break;\n      case Zt.SendAlternateToPenaltyBox:\n        this.sendAlternateToPenaltyBox(t), !t.errorAction.resolved &amp;&amp; t.details !== J.FRAG_GAP ? t.fatal = !0 : /MediaSource readyState: ended/.test(t.error.message) &amp;&amp; (this.warn(`MediaSource ended after \"${t.sourceBufferName}\" sourceBuffer append error. Attempting to recover from media error.`), this.hls.recoverMediaError());\n        break;\n    }\n    if (t.fatal) {\n      this.hls.stopLoad();\n      return;\n    }\n  }\n  sendAlternateToPenaltyBox(e) {\n    const t = this.hls, r = e.errorAction;\n    if (!r)\n      return;\n    const {\n      flags: n\n    } = r, i = r.nextAutoLevel;\n    switch (n) {\n      case vr.None:\n        this.switchLevel(e, i);\n        break;\n      case vr.MoveAllAlternatesMatchingHDCP: {\n        const l = this.getVariantLevelIndex(e.frag), c = t.levels[l], u = c == null ? void 0 : c.attrs[\"HDCP-LEVEL\"];\n        if (r.hdcpLevel = u, u === \"NONE\")\n          this.warn(\"HDCP policy resticted output with HDCP-LEVEL=NONE\");\n        else if (u) {\n          t.maxHdcpLevel = cc[cc.indexOf(u) - 1], r.resolved = !0, this.warn(`Restricting playback to HDCP-LEVEL of \"${t.maxHdcpLevel}\" or lower`);\n          break;\n        }\n      }\n      // eslint-disable-next-line no-fallthrough\n      case vr.MoveAllAlternatesMatchingKey: {\n        const l = e.decryptdata;\n        if (l) {\n          const c = this.hls.levels, u = c.length;\n          for (let h = u; h--; )\n            if (this.variantHasKey(c[h], l)) {\n              var o, a;\n              this.log(`Banned key found in level ${h} (${c[h].bitrate}bps) or audio group \"${(o = c[h].audioGroups) == null ? void 0 : o.join(\",\")}\" (${(a = e.frag) == null ? void 0 : a.type} fragment) ${fr(l.keyId || [])}`), c[h].fragmentError++, c[h].loadError++, this.log(`Removing level ${h} with key error (${e.error})`), this.hls.removeLevel(h);\n            }\n          const d = e.frag;\n          if (this.hls.levels.length &lt; u)\n            r.resolved = !0;\n          else if (d &amp;&amp; d.type !== pe.MAIN) {\n            const h = d.decryptdata;\n            h &amp;&amp; !l.matches(h) &amp;&amp; (r.resolved = !0);\n          }\n        }\n        break;\n      }\n    }\n    r.resolved || this.switchLevel(e, i);\n  }\n  switchLevel(e, t) {\n    if (t !== void 0 &amp;&amp; e.errorAction &amp;&amp; (this.warn(`switching to level ${t} after ${e.details}`), this.hls.nextAutoLevel = t, e.errorAction.resolved = !0, this.hls.nextLoadLevel = this.hls.nextAutoLevel, e.details === J.BUFFER_ADD_CODEC_ERROR &amp;&amp; e.mimeType &amp;&amp; e.sourceBufferName !== \"audiovideo\")) {\n      const r = lc(e.mimeType), n = this.hls.levels;\n      for (let i = n.length; i--; )\n        n[i][`${e.sourceBufferName}Codec`] === r &amp;&amp; (this.log(`Removing level ${i} for ${e.details} (\"${r}\" not supported)`), this.hls.removeLevel(i));\n    }\n  }\n}\nfunction An(s) {\n  const e = {\n    action: Zt.DoNothing,\n    flags: vr.None\n  };\n  return s &amp;&amp; (e.resolved = !0), e;\n}\nvar Ht = {\n  NOT_LOADED: \"NOT_LOADED\",\n  APPENDING: \"APPENDING\",\n  PARTIAL: \"PARTIAL\",\n  OK: \"OK\"\n};\nclass Tb {\n  constructor(e) {\n    this.activePartLists = /* @__PURE__ */ Object.create(null), this.endListFragments = /* @__PURE__ */ Object.create(null), this.fragments = /* @__PURE__ */ Object.create(null), this.timeRanges = /* @__PURE__ */ Object.create(null), this.bufferPadding = 0.2, this.hls = void 0, this.hasGaps = !1, this.hls = e, this._registerListeners();\n  }\n  _registerListeners() {\n    const {\n      hls: e\n    } = this;\n    e &amp;&amp; (e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.BUFFER_APPENDED, this.onBufferAppended, this), e.on(I.FRAG_BUFFERED, this.onFragBuffered, this), e.on(I.FRAG_LOADED, this.onFragLoaded, this));\n  }\n  _unregisterListeners() {\n    const {\n      hls: e\n    } = this;\n    e &amp;&amp; (e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.BUFFER_APPENDED, this.onBufferAppended, this), e.off(I.FRAG_BUFFERED, this.onFragBuffered, this), e.off(I.FRAG_LOADED, this.onFragLoaded, this));\n  }\n  destroy() {\n    this._unregisterListeners(), this.hls = // @ts-ignore\n    this.fragments = // @ts-ignore\n    this.activePartLists = // @ts-ignore\n    this.endListFragments = this.timeRanges = null;\n  }\n  /**\n   * Return a Fragment or Part with an appended range that matches the position and levelType\n   * Otherwise, return null\n   */\n  getAppendedFrag(e, t) {\n    const r = this.activePartLists[t];\n    if (r)\n      for (let n = r.length; n--; ) {\n        const i = r[n];\n        if (!i)\n          break;\n        if (i.start &lt;= e &amp;&amp; e &lt;= i.end &amp;&amp; i.loaded)\n          return i;\n      }\n    return this.getBufferedFrag(e, t);\n  }\n  /**\n   * Return a buffered Fragment that matches the position and levelType.\n   * A buffered Fragment is one whose loading, parsing and appending is done (completed or \"partial\" meaning aborted).\n   * If not found any Fragment, return null\n   */\n  getBufferedFrag(e, t) {\n    return this.getFragAtPos(e, t, !0);\n  }\n  getFragAtPos(e, t, r) {\n    const {\n      fragments: n\n    } = this, i = Object.keys(n);\n    for (let o = i.length; o--; ) {\n      const a = n[i[o]];\n      if ((a == null ? void 0 : a.body.type) === t &amp;&amp; (!r || a.buffered)) {\n        const l = a.body;\n        if (l.start &lt;= e &amp;&amp; e &lt;= l.end)\n          return l;\n      }\n    }\n    return null;\n  }\n  /**\n   * Partial fragments effected by coded frame eviction will be removed\n   * The browser will unload parts of the buffer to free up memory for new buffer data\n   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)\n   */\n  detectEvictedFragments(e, t, r, n, i) {\n    this.timeRanges &amp;&amp; (this.timeRanges[e] = t);\n    const o = (n == null ? void 0 : n.fragment.sn) || -1;\n    Object.keys(this.fragments).forEach((a) =&gt; {\n      const l = this.fragments[a];\n      if (!l || o &gt;= l.body.sn)\n        return;\n      if (!l.buffered &amp;&amp; (!l.loaded || i)) {\n        l.body.type === r &amp;&amp; this.removeFragment(l.body);\n        return;\n      }\n      const c = l.range[e];\n      if (c) {\n        if (c.time.length === 0) {\n          this.removeFragment(l.body);\n          return;\n        }\n        c.time.some((u) =&gt; {\n          const d = !this.isTimeBuffered(u.startPTS, u.endPTS, t);\n          return d &amp;&amp; this.removeFragment(l.body), d;\n        });\n      }\n    });\n  }\n  /**\n   * Checks if the fragment passed in is loaded in the buffer properly\n   * Partially loaded fragments will be registered as a partial fragment\n   */\n  detectPartialFragments(e) {\n    const t = this.timeRanges;\n    if (!t || e.frag.sn === \"initSegment\")\n      return;\n    const r = e.frag, n = fn(r), i = this.fragments[n];\n    if (!i || i.buffered &amp;&amp; r.gap)\n      return;\n    const o = !r.relurl;\n    Object.keys(t).forEach((a) =&gt; {\n      const l = r.elementaryStreams[a];\n      if (!l)\n        return;\n      const c = t[a], u = o || l.partial === !0;\n      i.range[a] = this.getBufferedTimes(r, e.part, u, c);\n    }), i.loaded = null, Object.keys(i.range).length ? (i.buffered = !0, (i.body.endList = r.endList || i.body.endList) &amp;&amp; (this.endListFragments[i.body.type] = i), Hi(i) || this.removeParts(r.sn - 1, r.type)) : this.removeFragment(i.body);\n  }\n  removeParts(e, t) {\n    const r = this.activePartLists[t];\n    r &amp;&amp; (this.activePartLists[t] = gh(r, (n) =&gt; n.fragment.sn &gt;= e));\n  }\n  fragBuffered(e, t) {\n    const r = fn(e);\n    let n = this.fragments[r];\n    !n &amp;&amp; t &amp;&amp; (n = this.fragments[r] = {\n      body: e,\n      appendedPTS: null,\n      loaded: null,\n      buffered: !1,\n      range: /* @__PURE__ */ Object.create(null)\n    }, e.gap &amp;&amp; (this.hasGaps = !0)), n &amp;&amp; (n.loaded = null, n.buffered = !0);\n  }\n  getBufferedTimes(e, t, r, n) {\n    const i = {\n      time: [],\n      partial: r\n    }, o = e.start, a = e.end, l = e.minEndPTS || a, c = e.maxStartPTS || o;\n    for (let u = 0; u &lt; n.length; u++) {\n      const d = n.start(u) - this.bufferPadding, h = n.end(u) + this.bufferPadding;\n      if (c &gt;= d &amp;&amp; l &lt;= h) {\n        i.time.push({\n          startPTS: Math.max(o, n.start(u)),\n          endPTS: Math.min(a, n.end(u))\n        });\n        break;\n      } else if (o &lt; h &amp;&amp; a &gt; d) {\n        const f = Math.max(o, n.start(u)), p = Math.min(a, n.end(u));\n        p &gt; f &amp;&amp; (i.partial = !0, i.time.push({\n          startPTS: f,\n          endPTS: p\n        }));\n      } else if (a &lt;= d)\n        break;\n    }\n    return i;\n  }\n  /**\n   * Gets the partial fragment for a certain time\n   */\n  getPartialFragment(e) {\n    let t = null, r, n, i, o = 0;\n    const {\n      bufferPadding: a,\n      fragments: l\n    } = this;\n    return Object.keys(l).forEach((c) =&gt; {\n      const u = l[c];\n      u &amp;&amp; Hi(u) &amp;&amp; (n = u.body.start - a, i = u.body.end + a, e &gt;= n &amp;&amp; e &lt;= i &amp;&amp; (r = Math.min(e - n, i - e), o &lt;= r &amp;&amp; (t = u.body, o = r)));\n    }), t;\n  }\n  isEndListAppended(e) {\n    const t = this.endListFragments[e];\n    return t !== void 0 &amp;&amp; (t.buffered || Hi(t));\n  }\n  getState(e) {\n    const t = fn(e), r = this.fragments[t];\n    return r ? r.buffered ? Hi(r) ? Ht.PARTIAL : Ht.OK : Ht.APPENDING : Ht.NOT_LOADED;\n  }\n  isTimeBuffered(e, t, r) {\n    let n, i;\n    for (let o = 0; o &lt; r.length; o++) {\n      if (n = r.start(o) - this.bufferPadding, i = r.end(o) + this.bufferPadding, e &gt;= n &amp;&amp; t &lt;= i)\n        return !0;\n      if (t &lt;= n)\n        return !1;\n    }\n    return !1;\n  }\n  onManifestLoading() {\n    this.removeAllFragments();\n  }\n  onFragLoaded(e, t) {\n    if (t.frag.sn === \"initSegment\" || t.frag.bitrateTest)\n      return;\n    const r = t.frag, n = t.part ? null : t, i = fn(r);\n    this.fragments[i] = {\n      body: r,\n      appendedPTS: null,\n      loaded: n,\n      buffered: !1,\n      range: /* @__PURE__ */ Object.create(null)\n    };\n  }\n  onBufferAppended(e, t) {\n    const {\n      frag: r,\n      part: n,\n      timeRanges: i,\n      type: o\n    } = t;\n    if (r.sn === \"initSegment\")\n      return;\n    const a = r.type;\n    if (n) {\n      let c = this.activePartLists[a];\n      c || (this.activePartLists[a] = c = []), c.push(n);\n    }\n    this.timeRanges = i;\n    const l = i[o];\n    this.detectEvictedFragments(o, l, a, n);\n  }\n  onFragBuffered(e, t) {\n    this.detectPartialFragments(t);\n  }\n  hasFragment(e) {\n    const t = fn(e);\n    return !!this.fragments[t];\n  }\n  hasFragments(e) {\n    const {\n      fragments: t\n    } = this, r = Object.keys(t);\n    if (!e)\n      return r.length &gt; 0;\n    for (let n = r.length; n--; ) {\n      const i = t[r[n]];\n      if ((i == null ? void 0 : i.body.type) === e)\n        return !0;\n    }\n    return !1;\n  }\n  hasParts(e) {\n    var t;\n    return !!((t = this.activePartLists[e]) != null &amp;&amp; t.length);\n  }\n  removeFragmentsInRange(e, t, r, n, i) {\n    n &amp;&amp; !this.hasGaps || Object.keys(this.fragments).forEach((o) =&gt; {\n      const a = this.fragments[o];\n      if (!a)\n        return;\n      const l = a.body;\n      l.type !== r || n &amp;&amp; !l.gap || l.start &lt; t &amp;&amp; l.end &gt; e &amp;&amp; (a.buffered || i) &amp;&amp; this.removeFragment(l);\n    });\n  }\n  removeFragment(e) {\n    const t = fn(e);\n    e.clearElementaryStreamInfo();\n    const r = this.activePartLists[e.type];\n    if (r) {\n      const n = e.sn;\n      this.activePartLists[e.type] = gh(r, (i) =&gt; i.fragment.sn !== n);\n    }\n    delete this.fragments[t], e.endList &amp;&amp; delete this.endListFragments[e.type];\n  }\n  removeAllFragments() {\n    var e;\n    this.fragments = /* @__PURE__ */ Object.create(null), this.endListFragments = /* @__PURE__ */ Object.create(null), this.activePartLists = /* @__PURE__ */ Object.create(null), this.hasGaps = !1;\n    const t = (e = this.hls) == null || (e = e.latestLevelDetails) == null ? void 0 : e.partList;\n    t &amp;&amp; t.forEach((r) =&gt; r.clearElementaryStreamInfo());\n  }\n}\nfunction Hi(s) {\n  var e, t, r;\n  return s.buffered &amp;&amp; !!(s.body.gap || (e = s.range.video) != null &amp;&amp; e.partial || (t = s.range.audio) != null &amp;&amp; t.partial || (r = s.range.audiovideo) != null &amp;&amp; r.partial);\n}\nfunction fn(s) {\n  return `${s.type}_${s.level}_${s.sn}`;\n}\nfunction gh(s, e) {\n  return s.filter((t) =&gt; {\n    const r = e(t);\n    return r || t.clearElementaryStreamInfo(), r;\n  });\n}\nvar Os = {\n  cbc: 0,\n  ctr: 1\n};\nclass wb {\n  constructor(e, t, r) {\n    this.subtle = void 0, this.aesIV = void 0, this.aesMode = void 0, this.subtle = e, this.aesIV = t, this.aesMode = r;\n  }\n  decrypt(e, t) {\n    switch (this.aesMode) {\n      case Os.cbc:\n        return this.subtle.decrypt({\n          name: \"AES-CBC\",\n          iv: this.aesIV\n        }, t, e);\n      case Os.ctr:\n        return this.subtle.decrypt(\n          {\n            name: \"AES-CTR\",\n            counter: this.aesIV,\n            length: 64\n          },\n          //64 : NIST SP800-38A standard suggests that the counter should occupy half of the counter block\n          t,\n          e\n        );\n      default:\n        throw new Error(`[AESCrypto] invalid aes mode ${this.aesMode}`);\n    }\n  }\n}\nfunction Ab(s) {\n  const e = s.byteLength, t = e &amp;&amp; new DataView(s.buffer).getUint8(e - 1);\n  return t ? s.slice(0, e - t) : s;\n}\nclass Ib {\n  constructor() {\n    this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.ksRows = 0, this.keySize = 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.initTable();\n  }\n  // Using view.getUint32() also swaps the byte order.\n  uint8ArrayToUint32Array_(e) {\n    const t = new DataView(e), r = new Uint32Array(4);\n    for (let n = 0; n &lt; 4; n++)\n      r[n] = t.getUint32(n * 4);\n    return r;\n  }\n  initTable() {\n    const e = this.sBox, t = this.invSBox, r = this.subMix, n = r[0], i = r[1], o = r[2], a = r[3], l = this.invSubMix, c = l[0], u = l[1], d = l[2], h = l[3], f = new Uint32Array(256);\n    let p = 0, y = 0, E = 0;\n    for (E = 0; E &lt; 256; E++)\n      E &lt; 128 ? f[E] = E &lt;&lt; 1 : f[E] = E &lt;&lt; 1 ^ 283;\n    for (E = 0; E &lt; 256; E++) {\n      let b = y ^ y &lt;&lt; 1 ^ y &lt;&lt; 2 ^ y &lt;&lt; 3 ^ y &lt;&lt; 4;\n      b = b &gt;&gt;&gt; 8 ^ b &amp; 255 ^ 99, e[p] = b, t[b] = p;\n      const R = f[p], A = f[R], F = f[A];\n      let M = f[b] * 257 ^ b * 16843008;\n      n[p] = M &lt;&lt; 24 | M &gt;&gt;&gt; 8, i[p] = M &lt;&lt; 16 | M &gt;&gt;&gt; 16, o[p] = M &lt;&lt; 8 | M &gt;&gt;&gt; 24, a[p] = M, M = F * 16843009 ^ A * 65537 ^ R * 257 ^ p * 16843008, c[b] = M &lt;&lt; 24 | M &gt;&gt;&gt; 8, u[b] = M &lt;&lt; 16 | M &gt;&gt;&gt; 16, d[b] = M &lt;&lt; 8 | M &gt;&gt;&gt; 24, h[b] = M, p ? (p = R ^ f[f[f[F ^ R]]], y ^= f[f[y]]) : p = y = 1;\n    }\n  }\n  expandKey(e) {\n    const t = this.uint8ArrayToUint32Array_(e);\n    let r = !0, n = 0;\n    for (; n &lt; t.length &amp;&amp; r; )\n      r = t[n] === this.key[n], n++;\n    if (r)\n      return;\n    this.key = t;\n    const i = this.keySize = t.length;\n    if (i !== 4 &amp;&amp; i !== 6 &amp;&amp; i !== 8)\n      throw new Error(\"Invalid aes key size=\" + i);\n    const o = this.ksRows = (i + 6 + 1) * 4;\n    let a, l;\n    const c = this.keySchedule = new Uint32Array(o), u = this.invKeySchedule = new Uint32Array(o), d = this.sBox, h = this.rcon, f = this.invSubMix, p = f[0], y = f[1], E = f[2], b = f[3];\n    let R, A;\n    for (a = 0; a &lt; o; a++) {\n      if (a &lt; i) {\n        R = c[a] = t[a];\n        continue;\n      }\n      A = R, a % i === 0 ? (A = A &lt;&lt; 8 | A &gt;&gt;&gt; 24, A = d[A &gt;&gt;&gt; 24] &lt;&lt; 24 | d[A &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | d[A &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | d[A &amp; 255], A ^= h[a / i | 0] &lt;&lt; 24) : i &gt; 6 &amp;&amp; a % i === 4 &amp;&amp; (A = d[A &gt;&gt;&gt; 24] &lt;&lt; 24 | d[A &gt;&gt;&gt; 16 &amp; 255] &lt;&lt; 16 | d[A &gt;&gt;&gt; 8 &amp; 255] &lt;&lt; 8 | d[A &amp; 255]), c[a] = R = (c[a - i] ^ A) &gt;&gt;&gt; 0;\n    }\n    for (l = 0; l &lt; o; l++)\n      a = o - l, l &amp; 3 ? A = c[a] : A = c[a - 4], l &lt; 4 || a &lt;= 4 ? u[l] = A : u[l] = p[d[A &gt;&gt;&gt; 24]] ^ y[d[A &gt;&gt;&gt; 16 &amp; 255]] ^ E[d[A &gt;&gt;&gt; 8 &amp; 255]] ^ b[d[A &amp; 255]], u[l] = u[l] &gt;&gt;&gt; 0;\n  }\n  // Adding this as a method greatly improves performance.\n  networkToHostOrderSwap(e) {\n    return e &lt;&lt; 24 | (e &amp; 65280) &lt;&lt; 8 | (e &amp; 16711680) &gt;&gt; 8 | e &gt;&gt;&gt; 24;\n  }\n  decrypt(e, t, r) {\n    const n = this.keySize + 6, i = this.invKeySchedule, o = this.invSBox, a = this.invSubMix, l = a[0], c = a[1], u = a[2], d = a[3], h = this.uint8ArrayToUint32Array_(r);\n    let f = h[0], p = h[1], y = h[2], E = h[3];\n    const b = new Int32Array(e), R = new Int32Array(b.length);\n    let A, F, M, H, K, j, C, k, $, W, _, g, x, w;\n    const D = this.networkToHostOrderSwap;\n    for (; t &lt; b.length; ) {\n      for ($ = D(b[t]), W = D(b[t + 1]), _ = D(b[t + 2]), g = D(b[t + 3]), K = $ ^ i[0], j = g ^ i[1], C = _ ^ i[2], k = W ^ i[3], x = 4, w = 1; w &lt; n; w++)\n        A = l[K &gt;&gt;&gt; 24] ^ c[j &gt;&gt; 16 &amp; 255] ^ u[C &gt;&gt; 8 &amp; 255] ^ d[k &amp; 255] ^ i[x], F = l[j &gt;&gt;&gt; 24] ^ c[C &gt;&gt; 16 &amp; 255] ^ u[k &gt;&gt; 8 &amp; 255] ^ d[K &amp; 255] ^ i[x + 1], M = l[C &gt;&gt;&gt; 24] ^ c[k &gt;&gt; 16 &amp; 255] ^ u[K &gt;&gt; 8 &amp; 255] ^ d[j &amp; 255] ^ i[x + 2], H = l[k &gt;&gt;&gt; 24] ^ c[K &gt;&gt; 16 &amp; 255] ^ u[j &gt;&gt; 8 &amp; 255] ^ d[C &amp; 255] ^ i[x + 3], K = A, j = F, C = M, k = H, x = x + 4;\n      A = o[K &gt;&gt;&gt; 24] &lt;&lt; 24 ^ o[j &gt;&gt; 16 &amp; 255] &lt;&lt; 16 ^ o[C &gt;&gt; 8 &amp; 255] &lt;&lt; 8 ^ o[k &amp; 255] ^ i[x], F = o[j &gt;&gt;&gt; 24] &lt;&lt; 24 ^ o[C &gt;&gt; 16 &amp; 255] &lt;&lt; 16 ^ o[k &gt;&gt; 8 &amp; 255] &lt;&lt; 8 ^ o[K &amp; 255] ^ i[x + 1], M = o[C &gt;&gt;&gt; 24] &lt;&lt; 24 ^ o[k &gt;&gt; 16 &amp; 255] &lt;&lt; 16 ^ o[K &gt;&gt; 8 &amp; 255] &lt;&lt; 8 ^ o[j &amp; 255] ^ i[x + 2], H = o[k &gt;&gt;&gt; 24] &lt;&lt; 24 ^ o[K &gt;&gt; 16 &amp; 255] &lt;&lt; 16 ^ o[j &gt;&gt; 8 &amp; 255] &lt;&lt; 8 ^ o[C &amp; 255] ^ i[x + 3], R[t] = D(A ^ f), R[t + 1] = D(H ^ p), R[t + 2] = D(M ^ y), R[t + 3] = D(F ^ E), f = $, p = W, y = _, E = g, t = t + 4;\n    }\n    return R.buffer;\n  }\n}\nclass _b {\n  constructor(e, t, r) {\n    this.subtle = void 0, this.key = void 0, this.aesMode = void 0, this.subtle = e, this.key = t, this.aesMode = r;\n  }\n  expandKey() {\n    const e = Rb(this.aesMode);\n    return this.subtle.importKey(\"raw\", this.key, {\n      name: e\n    }, !1, [\"encrypt\", \"decrypt\"]);\n  }\n}\nfunction Rb(s) {\n  switch (s) {\n    case Os.cbc:\n      return \"AES-CBC\";\n    case Os.ctr:\n      return \"AES-CTR\";\n    default:\n      throw new Error(`[FastAESKey] invalid aes mode ${s}`);\n  }\n}\nconst Lb = 16;\nclass vu {\n  constructor(e, {\n    removePKCS7Padding: t = !0\n  } = {}) {\n    if (this.logEnabled = !0, this.removePKCS7Padding = void 0, this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null, this.useSoftware = void 0, this.enableSoftwareAES = void 0, this.enableSoftwareAES = e.enableSoftwareAES, this.removePKCS7Padding = t, t)\n      try {\n        const r = self.crypto;\n        r &amp;&amp; (this.subtle = r.subtle || r.webkitSubtle);\n      } catch {\n      }\n    this.useSoftware = !this.subtle;\n  }\n  destroy() {\n    this.subtle = null, this.softwareDecrypter = null, this.key = null, this.fastAesKey = null, this.remainderData = null, this.currentIV = null, this.currentResult = null;\n  }\n  isSync() {\n    return this.useSoftware;\n  }\n  flush() {\n    const {\n      currentResult: e,\n      remainderData: t\n    } = this;\n    if (!e || t)\n      return this.reset(), null;\n    const r = new Uint8Array(e);\n    return this.reset(), this.removePKCS7Padding ? Ab(r) : r;\n  }\n  reset() {\n    this.currentResult = null, this.currentIV = null, this.remainderData = null, this.softwareDecrypter &amp;&amp; (this.softwareDecrypter = null);\n  }\n  decrypt(e, t, r, n) {\n    return this.useSoftware ? new Promise((i, o) =&gt; {\n      const a = ArrayBuffer.isView(e) ? e : new Uint8Array(e);\n      this.softwareDecrypt(a, t, r, n);\n      const l = this.flush();\n      l ? i(l.buffer) : o(new Error(\"[softwareDecrypt] Failed to decrypt data\"));\n    }) : this.webCryptoDecrypt(new Uint8Array(e), t, r, n);\n  }\n  // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n  // data is handled in the flush() call\n  softwareDecrypt(e, t, r, n) {\n    const {\n      currentIV: i,\n      currentResult: o,\n      remainderData: a\n    } = this;\n    if (n !== Os.cbc || t.byteLength !== 16)\n      return rt.warn(\"SoftwareDecrypt: can only handle AES-128-CBC\"), null;\n    this.logOnce(\"JS AES decrypt\"), a &amp;&amp; (e = _r(a, e), this.remainderData = null);\n    const l = this.getValidChunk(e);\n    if (!l.length)\n      return null;\n    i &amp;&amp; (r = i);\n    let c = this.softwareDecrypter;\n    c || (c = this.softwareDecrypter = new Ib()), c.expandKey(t);\n    const u = o;\n    return this.currentResult = c.decrypt(l.buffer, 0, r), this.currentIV = l.slice(-16).buffer, u || null;\n  }\n  webCryptoDecrypt(e, t, r, n) {\n    if (this.key !== t || !this.fastAesKey) {\n      if (!this.subtle)\n        return Promise.resolve(this.onWebCryptoError(e, t, r, n));\n      this.key = t, this.fastAesKey = new _b(this.subtle, t, n);\n    }\n    return this.fastAesKey.expandKey().then((i) =&gt; this.subtle ? (this.logOnce(\"WebCrypto AES decrypt\"), new wb(this.subtle, new Uint8Array(r), n).decrypt(e.buffer, i)) : Promise.reject(new Error(\"web crypto not initialized\"))).catch((i) =&gt; (rt.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${i.name}: ${i.message}`), this.onWebCryptoError(e, t, r, n)));\n  }\n  onWebCryptoError(e, t, r, n) {\n    const i = this.enableSoftwareAES;\n    if (i) {\n      this.useSoftware = !0, this.logEnabled = !0, this.softwareDecrypt(e, t, r, n);\n      const o = this.flush();\n      if (o)\n        return o.buffer;\n    }\n    throw new Error(\"WebCrypto\" + (i ? \" and softwareDecrypt\" : \"\") + \": failed to decrypt data\");\n  }\n  getValidChunk(e) {\n    let t = e;\n    const r = e.length - e.length % Lb;\n    return r !== e.length &amp;&amp; (t = e.slice(0, r), this.remainderData = e.slice(r)), t;\n  }\n  logOnce(e) {\n    this.logEnabled &amp;&amp; (rt.log(`[decrypter]: ${e}`), this.logEnabled = !1);\n  }\n}\nconst ph = Math.pow(2, 17);\nclass Cb {\n  constructor(e) {\n    this.config = void 0, this.loader = null, this.partLoadTimeout = -1, this.config = e;\n  }\n  destroy() {\n    this.loader &amp;&amp; (this.loader.destroy(), this.loader = null);\n  }\n  abort() {\n    this.loader &amp;&amp; this.loader.abort();\n  }\n  load(e, t) {\n    const r = e.url;\n    if (!r)\n      return Promise.reject(new as({\n        type: ve.NETWORK_ERROR,\n        details: J.FRAG_LOAD_ERROR,\n        fatal: !1,\n        frag: e,\n        error: new Error(`Fragment does not have a ${r ? \"part list\" : \"url\"}`),\n        networkDetails: null\n      }));\n    this.abort();\n    const n = this.config, i = n.fLoader, o = n.loader;\n    return new Promise((a, l) =&gt; {\n      if (this.loader &amp;&amp; this.loader.destroy(), e.gap)\n        if (e.tagList.some((p) =&gt; p[0] === \"GAP\")) {\n          l(yh(e));\n          return;\n        } else\n          e.gap = !1;\n      const c = this.loader = i ? new i(n) : new o(n), u = mh(e);\n      e.loader = c;\n      const d = fh(n.fragLoadPolicy.default), h = {\n        loadPolicy: d,\n        timeout: d.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0,\n        highWaterMark: e.sn === \"initSegment\" ? 1 / 0 : ph\n      };\n      e.stats = c.stats;\n      const f = {\n        onSuccess: (p, y, E, b) =&gt; {\n          this.resetLoader(e, c);\n          let R = p.data;\n          E.resetIV &amp;&amp; e.decryptdata &amp;&amp; (e.decryptdata.iv = new Uint8Array(R.slice(0, 16)), R = R.slice(16)), a({\n            frag: e,\n            part: null,\n            payload: R,\n            networkDetails: b\n          });\n        },\n        onError: (p, y, E, b) =&gt; {\n          this.resetLoader(e, c), l(new as({\n            type: ve.NETWORK_ERROR,\n            details: J.FRAG_LOAD_ERROR,\n            fatal: !1,\n            frag: e,\n            response: tt({\n              url: r,\n              data: void 0\n            }, p),\n            error: new Error(`HTTP Error ${p.code} ${p.text}`),\n            networkDetails: E,\n            stats: b\n          }));\n        },\n        onAbort: (p, y, E) =&gt; {\n          this.resetLoader(e, c), l(new as({\n            type: ve.NETWORK_ERROR,\n            details: J.INTERNAL_ABORTED,\n            fatal: !1,\n            frag: e,\n            error: new Error(\"Aborted\"),\n            networkDetails: E,\n            stats: p\n          }));\n        },\n        onTimeout: (p, y, E) =&gt; {\n          this.resetLoader(e, c), l(new as({\n            type: ve.NETWORK_ERROR,\n            details: J.FRAG_LOAD_TIMEOUT,\n            fatal: !1,\n            frag: e,\n            error: new Error(`Timeout after ${h.timeout}ms`),\n            networkDetails: E,\n            stats: p\n          }));\n        }\n      };\n      t &amp;&amp; (f.onProgress = (p, y, E, b) =&gt; t({\n        frag: e,\n        part: null,\n        payload: E,\n        networkDetails: b\n      })), c.load(u, h, f);\n    });\n  }\n  loadPart(e, t, r) {\n    this.abort();\n    const n = this.config, i = n.fLoader, o = n.loader;\n    return new Promise((a, l) =&gt; {\n      if (this.loader &amp;&amp; this.loader.destroy(), e.gap || t.gap) {\n        l(yh(e, t));\n        return;\n      }\n      const c = this.loader = i ? new i(n) : new o(n), u = mh(e, t);\n      e.loader = c;\n      const d = fh(n.fragLoadPolicy.default), h = {\n        loadPolicy: d,\n        timeout: d.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0,\n        highWaterMark: ph\n      };\n      t.stats = c.stats, c.load(u, h, {\n        onSuccess: (f, p, y, E) =&gt; {\n          this.resetLoader(e, c), this.updateStatsFromPart(e, t);\n          const b = {\n            frag: e,\n            part: t,\n            payload: f.data,\n            networkDetails: E\n          };\n          r(b), a(b);\n        },\n        onError: (f, p, y, E) =&gt; {\n          this.resetLoader(e, c), l(new as({\n            type: ve.NETWORK_ERROR,\n            details: J.FRAG_LOAD_ERROR,\n            fatal: !1,\n            frag: e,\n            part: t,\n            response: tt({\n              url: u.url,\n              data: void 0\n            }, f),\n            error: new Error(`HTTP Error ${f.code} ${f.text}`),\n            networkDetails: y,\n            stats: E\n          }));\n        },\n        onAbort: (f, p, y) =&gt; {\n          e.stats.aborted = t.stats.aborted, this.resetLoader(e, c), l(new as({\n            type: ve.NETWORK_ERROR,\n            details: J.INTERNAL_ABORTED,\n            fatal: !1,\n            frag: e,\n            part: t,\n            error: new Error(\"Aborted\"),\n            networkDetails: y,\n            stats: f\n          }));\n        },\n        onTimeout: (f, p, y) =&gt; {\n          this.resetLoader(e, c), l(new as({\n            type: ve.NETWORK_ERROR,\n            details: J.FRAG_LOAD_TIMEOUT,\n            fatal: !1,\n            frag: e,\n            part: t,\n            error: new Error(`Timeout after ${h.timeout}ms`),\n            networkDetails: y,\n            stats: f\n          }));\n        }\n      });\n    });\n  }\n  updateStatsFromPart(e, t) {\n    const r = e.stats, n = t.stats, i = n.total;\n    if (r.loaded += n.loaded, i) {\n      const l = Math.round(e.duration / t.duration), c = Math.min(Math.round(r.loaded / i), l), d = (l - c) * Math.round(r.loaded / c);\n      r.total = r.loaded + d;\n    } else\n      r.total = Math.max(r.loaded, r.total);\n    const o = r.loading, a = n.loading;\n    o.start ? o.first += a.first - a.start : (o.start = a.start, o.first = a.first), o.end = a.end;\n  }\n  resetLoader(e, t) {\n    e.loader = null, this.loader === t &amp;&amp; (self.clearTimeout(this.partLoadTimeout), this.loader = null), t.destroy();\n  }\n}\nfunction mh(s, e = null) {\n  const t = e || s, r = {\n    frag: s,\n    part: e,\n    responseType: \"arraybuffer\",\n    url: t.url,\n    headers: {},\n    rangeStart: 0,\n    rangeEnd: 0\n  }, n = t.byteRangeStartOffset, i = t.byteRangeEndOffset;\n  if (ue(n) &amp;&amp; ue(i)) {\n    var o;\n    let a = n, l = i;\n    if (s.sn === \"initSegment\" &amp;&amp; kb((o = s.decryptdata) == null ? void 0 : o.method)) {\n      const c = i - n;\n      c % 16 &amp;&amp; (l = i + (16 - c % 16)), n !== 0 &amp;&amp; (r.resetIV = !0, a = n - 16);\n    }\n    r.rangeStart = a, r.rangeEnd = l;\n  }\n  return r;\n}\nfunction yh(s, e) {\n  const t = new Error(`GAP ${s.gap ? \"tag\" : \"attribute\"} found`), r = {\n    type: ve.MEDIA_ERROR,\n    details: J.FRAG_GAP,\n    fatal: !1,\n    frag: s,\n    error: t,\n    networkDetails: null\n  };\n  return e &amp;&amp; (r.part = e), (e || s).stats.aborted = !0, new as(r);\n}\nfunction kb(s) {\n  return s === \"AES-128\" || s === \"AES-256\";\n}\nclass as extends Error {\n  constructor(e) {\n    super(e.error.message), this.data = void 0, this.data = e;\n  }\n}\nclass Hg extends Lr {\n  constructor(e, t) {\n    super(e, t), this._boundTick = void 0, this._tickTimer = null, this._tickInterval = null, this._tickCallCount = 0, this._boundTick = this.tick.bind(this);\n  }\n  destroy() {\n    this.onHandlerDestroying(), this.onHandlerDestroyed();\n  }\n  onHandlerDestroying() {\n    this.clearNextTick(), this.clearInterval();\n  }\n  onHandlerDestroyed() {\n  }\n  hasInterval() {\n    return !!this._tickInterval;\n  }\n  hasNextTick() {\n    return !!this._tickTimer;\n  }\n  /**\n   * @param millis - Interval time (ms)\n   * @eturns True when interval has been scheduled, false when already scheduled (no effect)\n   */\n  setInterval(e) {\n    return this._tickInterval ? !1 : (this._tickCallCount = 0, this._tickInterval = self.setInterval(this._boundTick, e), !0);\n  }\n  /**\n   * @returns True when interval was cleared, false when none was set (no effect)\n   */\n  clearInterval() {\n    return this._tickInterval ? (self.clearInterval(this._tickInterval), this._tickInterval = null, !0) : !1;\n  }\n  /**\n   * @returns True when timeout was cleared, false when none was set (no effect)\n   */\n  clearNextTick() {\n    return this._tickTimer ? (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0) : !1;\n  }\n  /**\n   * Will call the subclass doTick implementation in this main loop tick\n   * or in the next one (via setTimeout(,0)) in case it has already been called\n   * in this tick (in case this is a re-entrant call).\n   */\n  tick() {\n    this._tickCallCount++, this._tickCallCount === 1 &amp;&amp; (this.doTick(), this._tickCallCount &gt; 1 &amp;&amp; this.tickImmediate(), this._tickCallCount = 0);\n  }\n  tickImmediate() {\n    this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0);\n  }\n  /**\n   * For subclass to implement task logic\n   * @abstract\n   */\n  doTick() {\n  }\n}\nclass Eu {\n  constructor(e, t, r, n = 0, i = -1, o = !1) {\n    this.level = void 0, this.sn = void 0, this.part = void 0, this.id = void 0, this.size = void 0, this.partial = void 0, this.transmuxing = qi(), this.buffering = {\n      audio: qi(),\n      video: qi(),\n      audiovideo: qi()\n    }, this.level = e, this.sn = t, this.id = r, this.size = n, this.part = i, this.partial = o;\n  }\n}\nfunction qi() {\n  return {\n    start: 0,\n    executeStart: 0,\n    executeEnd: 0,\n    end: 0\n  };\n}\nconst vh = {\n  length: 0,\n  start: () =&gt; 0,\n  end: () =&gt; 0\n};\nclass Ce {\n  /**\n   * Return true if `media`'s buffered include `position`\n   */\n  static isBuffered(e, t) {\n    if (e) {\n      const r = Ce.getBuffered(e);\n      for (let n = r.length; n--; )\n        if (t &gt;= r.start(n) &amp;&amp; t &lt;= r.end(n))\n          return !0;\n    }\n    return !1;\n  }\n  static bufferedRanges(e) {\n    if (e) {\n      const t = Ce.getBuffered(e);\n      return Ce.timeRangesToArray(t);\n    }\n    return [];\n  }\n  static timeRangesToArray(e) {\n    const t = [];\n    for (let r = 0; r &lt; e.length; r++)\n      t.push({\n        start: e.start(r),\n        end: e.end(r)\n      });\n    return t;\n  }\n  static bufferInfo(e, t, r) {\n    if (e) {\n      const n = Ce.bufferedRanges(e);\n      if (n.length)\n        return Ce.bufferedInfo(n, t, r);\n    }\n    return {\n      len: 0,\n      start: t,\n      end: t,\n      bufferedIndex: -1\n    };\n  }\n  static bufferedInfo(e, t, r) {\n    t = Math.max(0, t), e.length &gt; 1 &amp;&amp; e.sort((u, d) =&gt; u.start - d.start || d.end - u.end);\n    let n = -1, i = [];\n    if (r)\n      for (let u = 0; u &lt; e.length; u++) {\n        t &gt;= e[u].start &amp;&amp; t &lt;= e[u].end &amp;&amp; (n = u);\n        const d = i.length;\n        if (d) {\n          const h = i[d - 1].end;\n          e[u].start - h &lt; r ? e[u].end &gt; h &amp;&amp; (i[d - 1].end = e[u].end) : i.push(e[u]);\n        } else\n          i.push(e[u]);\n      }\n    else\n      i = e;\n    let o = 0, a, l = t, c = t;\n    for (let u = 0; u &lt; i.length; u++) {\n      const d = i[u].start, h = i[u].end;\n      if (n === -1 &amp;&amp; t &gt;= d &amp;&amp; t &lt;= h &amp;&amp; (n = u), t + r &gt;= d &amp;&amp; t &lt; h)\n        l = d, c = h, o = c - t;\n      else if (t + r &lt; d) {\n        a = d;\n        break;\n      }\n    }\n    return {\n      len: o,\n      start: l || 0,\n      end: c || 0,\n      nextStart: a,\n      buffered: e,\n      bufferedIndex: n\n    };\n  }\n  /**\n   * Safe method to get buffered property.\n   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource\n   */\n  static getBuffered(e) {\n    try {\n      return e.buffered || vh;\n    } catch (t) {\n      return rt.log(\"failed to get media.buffered\", t), vh;\n    }\n  }\n}\nconst qg = /\\{\\$([a-zA-Z0-9-_]+)\\}/g;\nfunction Eh(s) {\n  return qg.test(s);\n}\nfunction dc(s, e) {\n  if (s.variableList !== null || s.hasVariableRefs) {\n    const t = s.variableList;\n    return e.replace(qg, (r) =&gt; {\n      const n = r.substring(2, r.length - 1), i = t == null ? void 0 : t[n];\n      return i === void 0 ? (s.playlistParsingError || (s.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: \"${n}\"`)), r) : i;\n    });\n  }\n  return e;\n}\nfunction xh(s, e, t) {\n  let r = s.variableList;\n  r || (s.variableList = r = {});\n  let n, i;\n  if (\"QUERYPARAM\" in e) {\n    n = e.QUERYPARAM;\n    try {\n      const o = new self.URL(t).searchParams;\n      if (o.has(n))\n        i = o.get(n);\n      else\n        throw new Error(`\"${n}\" does not match any query parameter in URI: \"${t}\"`);\n    } catch (o) {\n      s.playlistParsingError || (s.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${o.message}`));\n    }\n  } else\n    n = e.NAME, i = e.VALUE;\n  n in r ? s.playlistParsingError || (s.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: \"${n}\"`)) : r[n] = i || \"\";\n}\nfunction Db(s, e, t) {\n  const r = e.IMPORT;\n  if (t &amp;&amp; r in t) {\n    let n = s.variableList;\n    n || (s.variableList = n = {}), n[r] = t[r];\n  } else\n    s.playlistParsingError || (s.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: \"${r}\"`));\n}\nconst Pb = /^(\\d+)x(\\d+)$/, Sh = /(.+?)=(\".*?\"|.*?)(?:,|$)/g;\nclass gt {\n  constructor(e, t) {\n    typeof e == \"string\" &amp;&amp; (e = gt.parseAttrList(e, t)), nt(this, e);\n  }\n  get clientAttrs() {\n    return Object.keys(this).filter((e) =&gt; e.substring(0, 2) === \"X-\");\n  }\n  decimalInteger(e) {\n    const t = parseInt(this[e], 10);\n    return t &gt; Number.MAX_SAFE_INTEGER ? 1 / 0 : t;\n  }\n  hexadecimalInteger(e) {\n    if (this[e]) {\n      let t = (this[e] || \"0x\").slice(2);\n      t = (t.length &amp; 1 ? \"0\" : \"\") + t;\n      const r = new Uint8Array(t.length / 2);\n      for (let n = 0; n &lt; t.length / 2; n++)\n        r[n] = parseInt(t.slice(n * 2, n * 2 + 2), 16);\n      return r;\n    }\n    return null;\n  }\n  hexadecimalIntegerAsNumber(e) {\n    const t = parseInt(this[e], 16);\n    return t &gt; Number.MAX_SAFE_INTEGER ? 1 / 0 : t;\n  }\n  decimalFloatingPoint(e) {\n    return parseFloat(this[e]);\n  }\n  optionalFloat(e, t) {\n    const r = this[e];\n    return r ? parseFloat(r) : t;\n  }\n  enumeratedString(e) {\n    return this[e];\n  }\n  enumeratedStringList(e, t) {\n    const r = this[e];\n    return (r ? r.split(/[ ,]+/) : []).reduce((n, i) =&gt; (n[i.toLowerCase()] = !0, n), t);\n  }\n  bool(e) {\n    return this[e] === \"YES\";\n  }\n  decimalResolution(e) {\n    const t = Pb.exec(this[e]);\n    if (t !== null)\n      return {\n        width: parseInt(t[1], 10),\n        height: parseInt(t[2], 10)\n      };\n  }\n  static parseAttrList(e, t) {\n    let r;\n    const n = {};\n    for (Sh.lastIndex = 0; (r = Sh.exec(e)) !== null; ) {\n      const o = r[1].trim();\n      let a = r[2];\n      const l = a.indexOf('\"') === 0 &amp;&amp; a.lastIndexOf('\"') === a.length - 1;\n      let c = !1;\n      if (l)\n        a = a.slice(1, -1);\n      else\n        switch (o) {\n          case \"IV\":\n          case \"SCTE35-CMD\":\n          case \"SCTE35-IN\":\n          case \"SCTE35-OUT\":\n            c = !0;\n        }\n      if (t &amp;&amp; (l || c))\n        a = dc(t, a);\n      else if (!c &amp;&amp; !l)\n        switch (o) {\n          case \"CLOSED-CAPTIONS\":\n            if (a === \"NONE\")\n              break;\n          // falls through\n          case \"ALLOWED-CPC\":\n          case \"CLASS\":\n          case \"ASSOC-LANGUAGE\":\n          case \"AUDIO\":\n          case \"BYTERANGE\":\n          case \"CHANNELS\":\n          case \"CHARACTERISTICS\":\n          case \"CODECS\":\n          case \"DATA-ID\":\n          case \"END-DATE\":\n          case \"GROUP-ID\":\n          case \"ID\":\n          case \"IMPORT\":\n          case \"INSTREAM-ID\":\n          case \"KEYFORMAT\":\n          case \"KEYFORMATVERSIONS\":\n          case \"LANGUAGE\":\n          case \"NAME\":\n          case \"PATHWAY-ID\":\n          case \"QUERYPARAM\":\n          case \"RECENTLY-REMOVED-DATERANGES\":\n          case \"SERVER-URI\":\n          case \"STABLE-RENDITION-ID\":\n          case \"STABLE-VARIANT-ID\":\n          case \"START-DATE\":\n          case \"SUBTITLES\":\n          case \"SUPPLEMENTAL-CODECS\":\n          case \"URI\":\n          case \"VALUE\":\n          case \"VIDEO\":\n          case \"X-ASSET-LIST\":\n          case \"X-ASSET-URI\":\n            rt.warn(`${e}: attribute ${o} is missing quotes`);\n        }\n      n[o] = a;\n    }\n    return n;\n  }\n}\nconst Mb = \"com.apple.hls.interstitial\";\nfunction Ob(s) {\n  return s !== \"ID\" &amp;&amp; s !== \"CLASS\" &amp;&amp; s !== \"CUE\" &amp;&amp; s !== \"START-DATE\" &amp;&amp; s !== \"DURATION\" &amp;&amp; s !== \"END-DATE\" &amp;&amp; s !== \"END-ON-NEXT\";\n}\nfunction Bb(s) {\n  return s === \"SCTE35-OUT\" || s === \"SCTE35-IN\" || s === \"SCTE35-CMD\";\n}\nclass Wg {\n  constructor(e, t, r = 0) {\n    var n;\n    if (this.attr = void 0, this.tagAnchor = void 0, this.tagOrder = void 0, this._startDate = void 0, this._endDate = void 0, this._dateAtEnd = void 0, this._cue = void 0, this._badValueForSameId = void 0, this.tagAnchor = (t == null ? void 0 : t.tagAnchor) || null, this.tagOrder = (n = t == null ? void 0 : t.tagOrder) != null ? n : r, t) {\n      const i = t.attr;\n      for (const o in i)\n        if (Object.prototype.hasOwnProperty.call(e, o) &amp;&amp; e[o] !== i[o]) {\n          rt.warn(`DATERANGE tag attribute: \"${o}\" does not match for tags with ID: \"${e.ID}\"`), this._badValueForSameId = o;\n          break;\n        }\n      e = nt(new gt({}), i, e);\n    }\n    if (this.attr = e, t ? (this._startDate = t._startDate, this._cue = t._cue, this._endDate = t._endDate, this._dateAtEnd = t._dateAtEnd) : this._startDate = new Date(e[\"START-DATE\"]), \"END-DATE\" in this.attr) {\n      const i = (t == null ? void 0 : t.endDate) || new Date(this.attr[\"END-DATE\"]);\n      ue(i.getTime()) &amp;&amp; (this._endDate = i);\n    }\n  }\n  get id() {\n    return this.attr.ID;\n  }\n  get class() {\n    return this.attr.CLASS;\n  }\n  get cue() {\n    const e = this._cue;\n    return e === void 0 ? this._cue = this.attr.enumeratedStringList(this.attr.CUE ? \"CUE\" : \"X-CUE\", {\n      pre: !1,\n      post: !1,\n      once: !1\n    }) : e;\n  }\n  get startTime() {\n    const {\n      tagAnchor: e\n    } = this;\n    return e === null || e.programDateTime === null ? (rt.warn(`Expected tagAnchor Fragment with PDT set for DateRange \"${this.id}\": ${e}`), NaN) : e.start + (this.startDate.getTime() - e.programDateTime) / 1e3;\n  }\n  get startDate() {\n    return this._startDate;\n  }\n  get endDate() {\n    const e = this._endDate || this._dateAtEnd;\n    if (e)\n      return e;\n    const t = this.duration;\n    return t !== null ? this._dateAtEnd = new Date(this._startDate.getTime() + t * 1e3) : null;\n  }\n  get duration() {\n    if (\"DURATION\" in this.attr) {\n      const e = this.attr.decimalFloatingPoint(\"DURATION\");\n      if (ue(e))\n        return e;\n    } else if (this._endDate)\n      return (this._endDate.getTime() - this._startDate.getTime()) / 1e3;\n    return null;\n  }\n  get plannedDuration() {\n    return \"PLANNED-DURATION\" in this.attr ? this.attr.decimalFloatingPoint(\"PLANNED-DURATION\") : null;\n  }\n  get endOnNext() {\n    return this.attr.bool(\"END-ON-NEXT\");\n  }\n  get isInterstitial() {\n    return this.class === Mb;\n  }\n  get isValid() {\n    return !!this.id &amp;&amp; !this._badValueForSameId &amp;&amp; ue(this.startDate.getTime()) &amp;&amp; (this.duration === null || this.duration &gt;= 0) &amp;&amp; (!this.endOnNext || !!this.class) &amp;&amp; (!this.attr.CUE || !this.cue.pre &amp;&amp; !this.cue.post || this.cue.pre !== this.cue.post) &amp;&amp; (!this.isInterstitial || \"X-ASSET-URI\" in this.attr || \"X-ASSET-LIST\" in this.attr);\n  }\n}\nconst Fb = 10;\nclass Nb {\n  constructor(e) {\n    this.PTSKnown = !1, this.alignedSliding = !1, this.averagetargetduration = void 0, this.endCC = 0, this.endSN = 0, this.fragments = void 0, this.fragmentHint = void 0, this.partList = null, this.dateRanges = void 0, this.dateRangeTagCount = 0, this.live = !0, this.requestScheduled = -1, this.ageHeader = 0, this.advancedDateTime = void 0, this.updated = !0, this.advanced = !0, this.misses = 0, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = void 0, this.m3u8 = \"\", this.version = null, this.canBlockReload = !1, this.canSkipUntil = 0, this.canSkipDateRanges = !1, this.skippedSegments = 0, this.recentlyRemovedDateranges = void 0, this.partHoldBack = 0, this.holdBack = 0, this.partTarget = 0, this.preloadHint = void 0, this.renditionReports = void 0, this.tuneInGoal = 0, this.deltaUpdateFailed = void 0, this.driftStartTime = 0, this.driftEndTime = 0, this.driftStart = 0, this.driftEnd = 0, this.encryptedFragments = void 0, this.playlistParsingError = null, this.variableList = null, this.hasVariableRefs = !1, this.appliedTimelineOffset = void 0, this.fragments = [], this.encryptedFragments = [], this.dateRanges = {}, this.url = e;\n  }\n  reloaded(e) {\n    if (!e) {\n      this.advanced = !0, this.updated = !0;\n      return;\n    }\n    const t = this.lastPartSn - e.lastPartSn, r = this.lastPartIndex - e.lastPartIndex;\n    this.updated = this.endSN !== e.endSN || !!r || !!t || !this.live, this.advanced = this.endSN &gt; e.endSN || t &gt; 0 || t === 0 &amp;&amp; r &gt; 0, this.updated || this.advanced ? this.misses = Math.floor(e.misses * 0.6) : this.misses = e.misses + 1;\n  }\n  hasKey(e) {\n    return this.encryptedFragments.some((t) =&gt; {\n      let r = t.decryptdata;\n      return r || (t.setKeyFormat(e.keyFormat), r = t.decryptdata), !!r &amp;&amp; e.matches(r);\n    });\n  }\n  get hasProgramDateTime() {\n    return this.fragments.length ? ue(this.fragments[this.fragments.length - 1].programDateTime) : !1;\n  }\n  get levelTargetDuration() {\n    return this.averagetargetduration || this.targetduration || Fb;\n  }\n  get drift() {\n    const e = this.driftEndTime - this.driftStartTime;\n    return e &gt; 0 ? (this.driftEnd - this.driftStart) * 1e3 / e : 1;\n  }\n  get edge() {\n    return this.partEnd || this.fragmentEnd;\n  }\n  get partEnd() {\n    var e;\n    return (e = this.partList) != null &amp;&amp; e.length ? this.partList[this.partList.length - 1].end : this.fragmentEnd;\n  }\n  get fragmentEnd() {\n    return this.fragments.length ? this.fragments[this.fragments.length - 1].end : 0;\n  }\n  get fragmentStart() {\n    return this.fragments.length ? this.fragments[0].start : 0;\n  }\n  get age() {\n    return this.advancedDateTime ? Math.max(Date.now() - this.advancedDateTime, 0) / 1e3 : 0;\n  }\n  get lastPartIndex() {\n    var e;\n    return (e = this.partList) != null &amp;&amp; e.length ? this.partList[this.partList.length - 1].index : -1;\n  }\n  get maxPartIndex() {\n    const e = this.partList;\n    if (e) {\n      const t = this.lastPartIndex;\n      if (t !== -1) {\n        for (let r = e.length; r--; )\n          if (e[r].index &gt; t)\n            return e[r].index;\n        return t;\n      }\n    }\n    return 0;\n  }\n  get lastPartSn() {\n    var e;\n    return (e = this.partList) != null &amp;&amp; e.length ? this.partList[this.partList.length - 1].fragment.sn : this.endSN;\n  }\n  get expired() {\n    if (this.live &amp;&amp; this.age &amp;&amp; this.misses &lt; 3) {\n      const e = this.partEnd - this.fragmentStart;\n      return this.age &gt; Math.max(e, this.totalduration) + this.levelTargetDuration;\n    }\n    return !1;\n  }\n}\nfunction xu(s, e) {\n  return s.length === e.length ? !s.some((t, r) =&gt; t !== e[r]) : !1;\n}\nfunction bh(s, e) {\n  return !s &amp;&amp; !e ? !0 : !s || !e ? !1 : xu(s, e);\n}\nfunction In(s) {\n  return s === \"AES-128\" || s === \"AES-256\" || s === \"AES-256-CTR\";\n}\nfunction Su(s) {\n  switch (s) {\n    case \"AES-128\":\n    case \"AES-256\":\n      return Os.cbc;\n    case \"AES-256-CTR\":\n      return Os.ctr;\n    default:\n      throw new Error(`invalid full segment method ${s}`);\n  }\n}\nfunction bu(s) {\n  return Uint8Array.from(atob(s), (e) =&gt; e.charCodeAt(0));\n}\nfunction hc(s) {\n  return Uint8Array.from(unescape(encodeURIComponent(s)), (e) =&gt; e.charCodeAt(0));\n}\nfunction Ub(s) {\n  const e = hc(s).subarray(0, 16), t = new Uint8Array(16);\n  return t.set(e, 16 - e.length), t;\n}\nfunction zg(s) {\n  const e = function(r, n, i) {\n    const o = r[n];\n    r[n] = r[i], r[i] = o;\n  };\n  e(s, 0, 3), e(s, 1, 2), e(s, 4, 5), e(s, 6, 7);\n}\nfunction $b(s) {\n  const e = s.split(\":\");\n  let t = null;\n  if (e[0] === \"data\" &amp;&amp; e.length === 2) {\n    const r = e[1].split(\";\"), n = r[r.length - 1].split(\",\");\n    if (n.length === 2) {\n      const i = n[0] === \"base64\", o = n[1];\n      i ? (r.splice(-1, 1), t = bu(o)) : t = Ub(o);\n    }\n  }\n  return t;\n}\nconst ra = typeof self &lt; \"u\" ? self : void 0;\nvar mt = {\n  CLEARKEY: \"org.w3.clearkey\",\n  FAIRPLAY: \"com.apple.fps\",\n  PLAYREADY: \"com.microsoft.playready\",\n  WIDEVINE: \"com.widevine.alpha\"\n}, lr = {\n  CLEARKEY: \"org.w3.clearkey\",\n  FAIRPLAY: \"com.apple.streamingkeydelivery\",\n  PLAYREADY: \"com.microsoft.playready\",\n  WIDEVINE: \"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\"\n};\nfunction po(s) {\n  switch (s) {\n    case lr.FAIRPLAY:\n      return mt.FAIRPLAY;\n    case lr.PLAYREADY:\n      return mt.PLAYREADY;\n    case lr.WIDEVINE:\n      return mt.WIDEVINE;\n    case lr.CLEARKEY:\n      return mt.CLEARKEY;\n  }\n}\nfunction fl(s) {\n  switch (s) {\n    case mt.FAIRPLAY:\n      return lr.FAIRPLAY;\n    case mt.PLAYREADY:\n      return lr.PLAYREADY;\n    case mt.WIDEVINE:\n      return lr.WIDEVINE;\n    case mt.CLEARKEY:\n      return lr.CLEARKEY;\n  }\n}\nfunction zn(s) {\n  const {\n    drmSystems: e,\n    widevineLicenseUrl: t\n  } = s, r = e ? [mt.FAIRPLAY, mt.WIDEVINE, mt.PLAYREADY, mt.CLEARKEY].filter((n) =&gt; !!e[n]) : [];\n  return !r[mt.WIDEVINE] &amp;&amp; t &amp;&amp; r.push(mt.WIDEVINE), r;\n}\nconst Yg = (function(s) {\n  return ra != null &amp;&amp; (s = ra.navigator) != null &amp;&amp; s.requestMediaKeySystemAccess ? self.navigator.requestMediaKeySystemAccess.bind(self.navigator) : null;\n})();\nfunction Gb(s, e, t, r) {\n  let n;\n  switch (s) {\n    case mt.FAIRPLAY:\n      n = [\"cenc\", \"sinf\"];\n      break;\n    case mt.WIDEVINE:\n    case mt.PLAYREADY:\n      n = [\"cenc\"];\n      break;\n    case mt.CLEARKEY:\n      n = [\"cenc\", \"keyids\"];\n      break;\n    default:\n      throw new Error(`Unknown key-system: ${s}`);\n  }\n  return Vb(n, e, t, r);\n}\nfunction Vb(s, e, t, r) {\n  return [{\n    initDataTypes: s,\n    persistentState: r.persistentState || \"optional\",\n    distinctiveIdentifier: r.distinctiveIdentifier || \"optional\",\n    sessionTypes: r.sessionTypes || [r.sessionType || \"temporary\"],\n    audioCapabilities: e.map((i) =&gt; ({\n      contentType: `audio/mp4; codecs=${i}`,\n      robustness: r.audioRobustness || \"\",\n      encryptionScheme: r.audioEncryptionScheme || null\n    })),\n    videoCapabilities: t.map((i) =&gt; ({\n      contentType: `video/mp4; codecs=${i}`,\n      robustness: r.videoRobustness || \"\",\n      encryptionScheme: r.videoEncryptionScheme || null\n    }))\n  }];\n}\nfunction jb(s) {\n  var e;\n  return !!s &amp;&amp; (s.sessionType === \"persistent-license\" || !!((e = s.sessionTypes) != null &amp;&amp; e.some((t) =&gt; t === \"persistent-license\")));\n}\nfunction Kb(s) {\n  const e = new Uint16Array(s.buffer, s.byteOffset, s.byteLength / 2), t = String.fromCharCode.apply(null, Array.from(e)), r = t.substring(t.indexOf(\"&lt;\"), t.length), o = new DOMParser().parseFromString(r, \"text/xml\").getElementsByTagName(\"KID\")[0];\n  if (o) {\n    const a = o.childNodes[0] ? o.childNodes[0].nodeValue : o.getAttribute(\"VALUE\");\n    if (a) {\n      const l = bu(a).subarray(0, 16);\n      return zg(l), l;\n    }\n  }\n  return null;\n}\nlet Wi = {};\nclass yi {\n  static clearKeyUriToKeyIdMap() {\n    Wi = {};\n  }\n  static setKeyIdForUri(e, t) {\n    Wi[e] = t;\n  }\n  constructor(e, t, r, n = [1], i = null, o) {\n    this.uri = void 0, this.method = void 0, this.keyFormat = void 0, this.keyFormatVersions = void 0, this.encrypted = void 0, this.isCommonEncryption = void 0, this.iv = null, this.key = null, this.keyId = null, this.pssh = null, this.method = e, this.uri = t, this.keyFormat = r, this.keyFormatVersions = n, this.iv = i, this.encrypted = e ? e !== \"NONE\" : !1, this.isCommonEncryption = this.encrypted &amp;&amp; !In(e), o != null &amp;&amp; o.startsWith(\"0x\") &amp;&amp; (this.keyId = new Uint8Array(Ig(o)));\n  }\n  matches(e) {\n    return e.uri === this.uri &amp;&amp; e.method === this.method &amp;&amp; e.encrypted === this.encrypted &amp;&amp; e.keyFormat === this.keyFormat &amp;&amp; xu(e.keyFormatVersions, this.keyFormatVersions) &amp;&amp; bh(e.iv, this.iv) &amp;&amp; bh(e.keyId, this.keyId);\n  }\n  isSupported() {\n    if (this.method) {\n      if (In(this.method) || this.method === \"NONE\")\n        return !0;\n      if (this.keyFormat === \"identity\")\n        return this.method === \"SAMPLE-AES\";\n      switch (this.keyFormat) {\n        case lr.FAIRPLAY:\n        case lr.WIDEVINE:\n        case lr.PLAYREADY:\n        case lr.CLEARKEY:\n          return [\"SAMPLE-AES\", \"SAMPLE-AES-CENC\", \"SAMPLE-AES-CTR\"].indexOf(this.method) !== -1;\n      }\n    }\n    return !1;\n  }\n  getDecryptData(e) {\n    if (!this.encrypted || !this.uri)\n      return null;\n    if (In(this.method)) {\n      let n = this.iv;\n      return n || (typeof e != \"number\" &amp;&amp; (rt.warn(`missing IV for initialization segment with method=\"${this.method}\" - compliance issue`), e = 0), n = Hb(e)), new yi(this.method, this.uri, \"identity\", this.keyFormatVersions, n);\n    }\n    if (this.pssh &amp;&amp; this.keyId)\n      return this;\n    const t = $b(this.uri);\n    if (t)\n      switch (this.keyFormat) {\n        case lr.WIDEVINE:\n          if (this.pssh = t, !this.keyId) {\n            const n = WS(t.buffer);\n            if (n.length) {\n              var r;\n              const i = n[0];\n              this.keyId = (r = i.kids) != null &amp;&amp; r.length ? i.kids[0] : null;\n            }\n          }\n          if (!this.keyId) {\n            const n = t.length - 22;\n            this.keyId = t.subarray(n, n + 16);\n          }\n          break;\n        case lr.PLAYREADY: {\n          const n = new Uint8Array([154, 4, 240, 121, 152, 64, 66, 134, 171, 146, 230, 91, 224, 136, 95, 149]);\n          this.pssh = qS(n, null, t), this.keyId = Kb(t);\n          break;\n        }\n        default: {\n          let n = t.subarray(0, 16);\n          if (n.length !== 16) {\n            const i = new Uint8Array(16);\n            i.set(n, 16 - n.length), n = i;\n          }\n          this.keyId = n;\n          break;\n        }\n      }\n    if (!this.keyId || this.keyId.byteLength !== 16) {\n      let n = Wi[this.uri];\n      if (!n) {\n        const i = Object.keys(Wi).length % Number.MAX_SAFE_INTEGER;\n        n = new Uint8Array(16), new DataView(n.buffer, 12, 4).setUint32(0, i), yi.setKeyIdForUri(this.uri, n);\n      }\n      this.keyId = n;\n    }\n    return this;\n  }\n}\nfunction Hb(s) {\n  const e = new Uint8Array(16);\n  for (let t = 12; t &lt; 16; t++)\n    e[t] = s &gt;&gt; 8 * (15 - t) &amp; 255;\n  return e;\n}\nconst Th = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\\r\\n]*)[\\r\\n]+/g, wh = /#EXT-X-MEDIA:(.*)/g, qb = /^#EXT(?:INF|-X-TARGETDURATION):/m, gl = new RegExp([\n  /#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source,\n  // duration (#EXTINF:&lt;duration&gt;,&lt;title&gt;), group 1 =&gt; duration, group 2 =&gt; title\n  /(?!#) *(\\S[^\\r\\n]*)/.source,\n  // segment URI, group 3 =&gt; the URI (note newline is not eaten)\n  /#.*/.source\n  // All other non-segment oriented tags will match with all groups empty\n].join(\"|\"), \"g\"), Wb = new RegExp([/#EXT-X-(PROGRAM-DATE-TIME|BYTERANGE|DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\\r?\\n?/.source].join(\"|\"));\nclass zr {\n  static findGroup(e, t) {\n    for (let r = 0; r &lt; e.length; r++) {\n      const n = e[r];\n      if (n.id === t)\n        return n;\n    }\n  }\n  static resolve(e, t) {\n    return hu.buildAbsoluteURL(t, e, {\n      alwaysNormalize: !0\n    });\n  }\n  static isMediaPlaylist(e) {\n    return qb.test(e);\n  }\n  static parseMasterPlaylist(e, t) {\n    const r = Eh(e), n = {\n      contentSteering: null,\n      levels: [],\n      playlistParsingError: null,\n      sessionData: null,\n      sessionKeys: null,\n      startTimeOffset: null,\n      variableList: null,\n      hasVariableRefs: r\n    }, i = [];\n    if (Th.lastIndex = 0, !e.startsWith(\"#EXTM3U\"))\n      return n.playlistParsingError = new Error(\"no EXTM3U delimiter\"), n;\n    let o;\n    for (; (o = Th.exec(e)) != null; )\n      if (o[1]) {\n        var a;\n        const c = new gt(o[1], n), u = dc(n, o[2]), d = {\n          attrs: c,\n          bitrate: c.decimalInteger(\"BANDWIDTH\") || c.decimalInteger(\"AVERAGE-BANDWIDTH\"),\n          name: c.NAME,\n          url: zr.resolve(u, t)\n        }, h = c.decimalResolution(\"RESOLUTION\");\n        h &amp;&amp; (d.width = h.width, d.height = h.height), _h(c.CODECS, d);\n        const f = c[\"SUPPLEMENTAL-CODECS\"];\n        f &amp;&amp; (d.supplemental = {}, _h(f, d.supplemental)), (a = d.unknownCodecs) != null &amp;&amp; a.length || i.push(d), n.levels.push(d);\n      } else if (o[3]) {\n        const c = o[3], u = o[4];\n        switch (c) {\n          case \"SESSION-DATA\": {\n            const d = new gt(u, n), h = d[\"DATA-ID\"];\n            h &amp;&amp; (n.sessionData === null &amp;&amp; (n.sessionData = {}), n.sessionData[h] = d);\n            break;\n          }\n          case \"SESSION-KEY\": {\n            const d = Ah(u, t, n);\n            d.encrypted &amp;&amp; d.isSupported() ? (n.sessionKeys === null &amp;&amp; (n.sessionKeys = []), n.sessionKeys.push(d)) : rt.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: \"${u}\"`);\n            break;\n          }\n          case \"DEFINE\": {\n            {\n              const d = new gt(u, n);\n              xh(n, d, t);\n            }\n            break;\n          }\n          case \"CONTENT-STEERING\": {\n            const d = new gt(u, n);\n            n.contentSteering = {\n              uri: zr.resolve(d[\"SERVER-URI\"], t),\n              pathwayId: d[\"PATHWAY-ID\"] || \".\"\n            };\n            break;\n          }\n          case \"START\": {\n            n.startTimeOffset = Ih(u);\n            break;\n          }\n        }\n      }\n    const l = i.length &gt; 0 &amp;&amp; i.length &lt; n.levels.length;\n    return n.levels = l ? i : n.levels, n.levels.length === 0 &amp;&amp; (n.playlistParsingError = new Error(\"no levels found in manifest\")), n;\n  }\n  static parseMasterPlaylistMedia(e, t, r) {\n    let n;\n    const i = {}, o = r.levels, a = {\n      AUDIO: o.map((c) =&gt; ({\n        id: c.attrs.AUDIO,\n        audioCodec: c.audioCodec\n      })),\n      SUBTITLES: o.map((c) =&gt; ({\n        id: c.attrs.SUBTITLES,\n        textCodec: c.textCodec\n      })),\n      \"CLOSED-CAPTIONS\": []\n    };\n    let l = 0;\n    for (wh.lastIndex = 0; (n = wh.exec(e)) !== null; ) {\n      const c = new gt(n[1], r), u = c.TYPE;\n      if (u) {\n        const d = a[u], h = i[u] || [];\n        i[u] = h;\n        const f = c.LANGUAGE, p = c[\"ASSOC-LANGUAGE\"], y = c.CHANNELS, E = c.CHARACTERISTICS, b = c[\"INSTREAM-ID\"], R = {\n          attrs: c,\n          bitrate: 0,\n          id: l++,\n          groupId: c[\"GROUP-ID\"] || \"\",\n          name: c.NAME || f || \"\",\n          type: u,\n          default: c.bool(\"DEFAULT\"),\n          autoselect: c.bool(\"AUTOSELECT\"),\n          forced: c.bool(\"FORCED\"),\n          lang: f,\n          url: c.URI ? zr.resolve(c.URI, t) : \"\"\n        };\n        if (p &amp;&amp; (R.assocLang = p), y &amp;&amp; (R.channels = y), E &amp;&amp; (R.characteristics = E), b &amp;&amp; (R.instreamId = b), d != null &amp;&amp; d.length) {\n          const A = zr.findGroup(d, R.groupId) || d[0];\n          Rh(R, A, \"audioCodec\"), Rh(R, A, \"textCodec\");\n        }\n        h.push(R);\n      }\n    }\n    return i;\n  }\n  static parseLevelPlaylist(e, t, r, n, i, o) {\n    var a;\n    const l = {\n      url: t\n    }, c = new Nb(t), u = c.fragments, d = [];\n    let h = null, f = 0, p = 0, y = 0, E = 0, b = 0, R = null, A = new ul(n, l), F, M, H, K = -1, j = !1, C = null, k;\n    if (gl.lastIndex = 0, c.m3u8 = e, c.hasVariableRefs = Eh(e), ((a = gl.exec(e)) == null ? void 0 : a[0]) !== \"#EXTM3U\")\n      return c.playlistParsingError = new Error(\"Missing format identifier #EXTM3U\"), c;\n    for (; (F = gl.exec(e)) !== null; ) {\n      j &amp;&amp; (j = !1, A = new ul(n, l), A.playlistOffset = y, A.setStart(y), A.sn = f, A.cc = E, b &amp;&amp; (A.bitrate = b), A.level = r, h &amp;&amp; (A.initSegment = h, h.rawProgramDateTime &amp;&amp; (A.rawProgramDateTime = h.rawProgramDateTime, h.rawProgramDateTime = null), C &amp;&amp; (A.setByteRange(C), C = null)));\n      const g = F[1];\n      if (g) {\n        A.duration = parseFloat(g);\n        const x = (\" \" + F[2]).slice(1);\n        A.title = x || null, A.tagList.push(x ? [\"INF\", g, x] : [\"INF\", g]);\n      } else if (F[3]) {\n        if (ue(A.duration)) {\n          A.playlistOffset = y, A.setStart(y), H &amp;&amp; Ch(A, H, c), A.sn = f, A.level = r, A.cc = E, u.push(A);\n          const x = (\" \" + F[3]).slice(1);\n          A.relurl = dc(c, x), fc(A, R, d), R = A, y += A.duration, f++, p = 0, j = !0;\n        }\n      } else {\n        if (F = F[0].match(Wb), !F) {\n          rt.warn(\"No matches on slow regex match for level playlist!\");\n          continue;\n        }\n        for (M = 1; M &lt; F.length &amp;&amp; F[M] === void 0; M++)\n          ;\n        const x = (\" \" + F[M]).slice(1), w = (\" \" + F[M + 1]).slice(1), D = F[M + 2] ? (\" \" + F[M + 2]).slice(1) : null;\n        switch (x) {\n          case \"BYTERANGE\":\n            R ? A.setByteRange(w, R) : A.setByteRange(w);\n            break;\n          case \"PROGRAM-DATE-TIME\":\n            A.rawProgramDateTime = w, A.tagList.push([\"PROGRAM-DATE-TIME\", w]), K === -1 &amp;&amp; (K = u.length);\n            break;\n          case \"PLAYLIST-TYPE\":\n            c.type &amp;&amp; ns(c, x, F), c.type = w.toUpperCase();\n            break;\n          case \"MEDIA-SEQUENCE\":\n            c.startSN !== 0 ? ns(c, x, F) : u.length &gt; 0 &amp;&amp; kh(c, x, F), f = c.startSN = parseInt(w);\n            break;\n          case \"SKIP\": {\n            c.skippedSegments &amp;&amp; ns(c, x, F);\n            const O = new gt(w, c), U = O.decimalInteger(\"SKIPPED-SEGMENTS\");\n            if (ue(U)) {\n              c.skippedSegments += U;\n              for (let L = U; L--; )\n                u.push(null);\n              f += U;\n            }\n            const V = O.enumeratedString(\"RECENTLY-REMOVED-DATERANGES\");\n            V &amp;&amp; (c.recentlyRemovedDateranges = (c.recentlyRemovedDateranges || []).concat(V.split(\"\t\")));\n            break;\n          }\n          case \"TARGETDURATION\":\n            c.targetduration !== 0 &amp;&amp; ns(c, x, F), c.targetduration = Math.max(parseInt(w), 1);\n            break;\n          case \"VERSION\":\n            c.version !== null &amp;&amp; ns(c, x, F), c.version = parseInt(w);\n            break;\n          case \"INDEPENDENT-SEGMENTS\":\n            break;\n          case \"ENDLIST\":\n            c.live || ns(c, x, F), c.live = !1;\n            break;\n          case \"#\":\n            (w || D) &amp;&amp; A.tagList.push(D ? [w, D] : [w]);\n            break;\n          case \"DISCONTINUITY\":\n            E++, A.tagList.push([\"DIS\"]);\n            break;\n          case \"GAP\":\n            A.gap = !0, A.tagList.push([x]);\n            break;\n          case \"BITRATE\":\n            A.tagList.push([x, w]), b = parseInt(w) * 1e3, ue(b) ? A.bitrate = b : b = 0;\n            break;\n          case \"DATERANGE\": {\n            const O = new gt(w, c), U = new Wg(O, c.dateRanges[O.ID], c.dateRangeTagCount);\n            c.dateRangeTagCount++, U.isValid || c.skippedSegments ? c.dateRanges[U.id] = U : rt.warn(`Ignoring invalid DATERANGE tag: \"${w}\"`), A.tagList.push([\"EXT-X-DATERANGE\", w]);\n            break;\n          }\n          case \"DEFINE\": {\n            {\n              const O = new gt(w, c);\n              \"IMPORT\" in O ? Db(c, O, o) : xh(c, O, t);\n            }\n            break;\n          }\n          case \"DISCONTINUITY-SEQUENCE\":\n            c.startCC !== 0 ? ns(c, x, F) : u.length &gt; 0 &amp;&amp; kh(c, x, F), c.startCC = E = parseInt(w);\n            break;\n          case \"KEY\": {\n            const O = Ah(w, t, c);\n            if (O.isSupported()) {\n              if (O.method === \"NONE\") {\n                H = void 0;\n                break;\n              }\n              H || (H = {});\n              const U = H[O.keyFormat];\n              U != null &amp;&amp; U.matches(O) || (U &amp;&amp; (H = nt({}, H)), H[O.keyFormat] = O);\n            } else\n              rt.warn(`[Keys] Ignoring unsupported EXT-X-KEY tag: \"${w}\"`);\n            break;\n          }\n          case \"START\":\n            c.startTimeOffset = Ih(w);\n            break;\n          case \"MAP\": {\n            const O = new gt(w, c);\n            if (A.duration) {\n              const U = new ul(n, l);\n              Lh(U, O, r, H), h = U, A.initSegment = h, h.rawProgramDateTime &amp;&amp; !A.rawProgramDateTime &amp;&amp; (A.rawProgramDateTime = h.rawProgramDateTime);\n            } else {\n              const U = A.byteRangeEndOffset;\n              if (U) {\n                const V = A.byteRangeStartOffset;\n                C = `${U - V}@${V}`;\n              } else\n                C = null;\n              Lh(A, O, r, H), h = A, j = !0;\n            }\n            h.cc = E;\n            break;\n          }\n          case \"SERVER-CONTROL\": {\n            k &amp;&amp; ns(c, x, F), k = new gt(w), c.canBlockReload = k.bool(\"CAN-BLOCK-RELOAD\"), c.canSkipUntil = k.optionalFloat(\"CAN-SKIP-UNTIL\", 0), c.canSkipDateRanges = c.canSkipUntil &gt; 0 &amp;&amp; k.bool(\"CAN-SKIP-DATERANGES\"), c.partHoldBack = k.optionalFloat(\"PART-HOLD-BACK\", 0), c.holdBack = k.optionalFloat(\"HOLD-BACK\", 0);\n            break;\n          }\n          case \"PART-INF\": {\n            c.partTarget &amp;&amp; ns(c, x, F);\n            const O = new gt(w);\n            c.partTarget = O.decimalFloatingPoint(\"PART-TARGET\");\n            break;\n          }\n          case \"PART\": {\n            let O = c.partList;\n            O || (O = c.partList = []);\n            const U = p &gt; 0 ? O[O.length - 1] : void 0, V = p++, L = new gt(w, c), m = new PS(L, A, l, V, U);\n            O.push(m), A.duration += m.duration;\n            break;\n          }\n          case \"PRELOAD-HINT\": {\n            const O = new gt(w, c);\n            c.preloadHint = O;\n            break;\n          }\n          case \"RENDITION-REPORT\": {\n            const O = new gt(w, c);\n            c.renditionReports = c.renditionReports || [], c.renditionReports.push(O);\n            break;\n          }\n          default:\n            rt.warn(`line parsed but not handled: ${F}`);\n            break;\n        }\n      }\n    }\n    R &amp;&amp; !R.relurl ? (u.pop(), y -= R.duration, c.partList &amp;&amp; (c.fragmentHint = R)) : c.partList &amp;&amp; (fc(A, R, d), A.cc = E, c.fragmentHint = A, H &amp;&amp; Ch(A, H, c)), c.targetduration || (c.playlistParsingError = new Error(\"Missing Target Duration\"));\n    const $ = u.length, W = u[0], _ = u[$ - 1];\n    if (y += c.skippedSegments * c.targetduration, y &gt; 0 &amp;&amp; $ &amp;&amp; _) {\n      c.averagetargetduration = y / $;\n      const g = _.sn;\n      c.endSN = g !== \"initSegment\" ? g : 0, c.live || (_.endList = !0), K &gt; 0 &amp;&amp; (Yb(u, K), W &amp;&amp; d.unshift(W));\n    }\n    return c.fragmentHint &amp;&amp; (y += c.fragmentHint.duration), c.totalduration = y, d.length &amp;&amp; c.dateRangeTagCount &amp;&amp; W &amp;&amp; Zg(d, c), c.endCC = E, c;\n  }\n}\nfunction Zg(s, e) {\n  let t = s.length;\n  if (!t)\n    if (e.hasProgramDateTime) {\n      const a = e.fragments[e.fragments.length - 1];\n      s.push(a), t++;\n    } else\n      return;\n  const r = s[t - 1], n = e.live ? 1 / 0 : e.totalduration, i = Object.keys(e.dateRanges);\n  for (let a = i.length; a--; ) {\n    const l = e.dateRanges[i[a]], c = l.startDate.getTime();\n    l.tagAnchor = r.ref;\n    for (let u = t; u--; ) {\n      var o;\n      if (((o = s[u]) == null ? void 0 : o.sn) &lt; e.startSN)\n        break;\n      const d = zb(e, c, s, u, n);\n      if (d !== -1) {\n        l.tagAnchor = e.fragments[d].ref;\n        break;\n      }\n    }\n  }\n}\nfunction zb(s, e, t, r, n) {\n  const i = t[r];\n  if (i) {\n    const a = i.programDateTime;\n    if (e &gt;= a || r === 0) {\n      var o;\n      const l = (((o = t[r + 1]) == null ? void 0 : o.start) || n) - i.start;\n      if (e &lt;= a + l * 1e3) {\n        const c = t[r].sn - s.startSN;\n        if (c &lt; 0)\n          return -1;\n        const u = s.fragments;\n        if (u.length &gt; t.length) {\n          const h = (t[r + 1] || u[u.length - 1]).sn - s.startSN;\n          for (let f = h; f &gt; c; f--) {\n            const p = u[f].programDateTime;\n            if (e &gt;= p &amp;&amp; e &lt; p + u[f].duration * 1e3)\n              return f;\n          }\n        }\n        return c;\n      }\n    }\n  }\n  return -1;\n}\nfunction Ah(s, e, t) {\n  var r, n;\n  const i = new gt(s, t), o = (r = i.METHOD) != null ? r : \"\", a = i.URI, l = i.hexadecimalInteger(\"IV\"), c = i.KEYFORMATVERSIONS, u = (n = i.KEYFORMAT) != null ? n : \"identity\";\n  a &amp;&amp; i.IV &amp;&amp; !l &amp;&amp; rt.error(`Invalid IV: ${i.IV}`);\n  const d = a ? zr.resolve(a, e) : \"\", h = (c || \"1\").split(\"/\").map(Number).filter(Number.isFinite);\n  return new yi(o, d, u, h, l, i.KEYID);\n}\nfunction Ih(s) {\n  const t = new gt(s).decimalFloatingPoint(\"TIME-OFFSET\");\n  return ue(t) ? t : null;\n}\nfunction _h(s, e) {\n  let t = (s || \"\").split(/[ ,]+/).filter((r) =&gt; r);\n  [\"video\", \"audio\", \"text\"].forEach((r) =&gt; {\n    const n = t.filter((i) =&gt; pu(i, r));\n    n.length &amp;&amp; (e[`${r}Codec`] = n.map((i) =&gt; i.split(\"/\")[0]).join(\",\"), t = t.filter((i) =&gt; n.indexOf(i) === -1));\n  }), e.unknownCodecs = t;\n}\nfunction Rh(s, e, t) {\n  const r = e[t];\n  r &amp;&amp; (s[t] = r);\n}\nfunction Yb(s, e) {\n  let t = s[e];\n  for (let r = e; r--; ) {\n    const n = s[r];\n    if (!n)\n      return;\n    n.programDateTime = t.programDateTime - n.duration * 1e3, t = n;\n  }\n}\nfunction fc(s, e, t) {\n  s.rawProgramDateTime ? t.push(s) : e != null &amp;&amp; e.programDateTime &amp;&amp; (s.programDateTime = e.endProgramDateTime);\n}\nfunction Lh(s, e, t, r) {\n  s.relurl = e.URI, e.BYTERANGE &amp;&amp; s.setByteRange(e.BYTERANGE), s.level = t, s.sn = \"initSegment\", r &amp;&amp; (s.levelkeys = r), s.initSegment = null;\n}\nfunction Ch(s, e, t) {\n  s.levelkeys = e;\n  const {\n    encryptedFragments: r\n  } = t;\n  (!r.length || r[r.length - 1].levelkeys !== e) &amp;&amp; Object.keys(e).some((n) =&gt; e[n].isCommonEncryption) &amp;&amp; r.push(s);\n}\nfunction ns(s, e, t) {\n  s.playlistParsingError = new Error(`#EXT-X-${e} must not appear more than once (${t[0]})`);\n}\nfunction kh(s, e, t) {\n  s.playlistParsingError = new Error(`#EXT-X-${e} must appear before the first Media Segment (${t[0]})`);\n}\nfunction pl(s, e) {\n  const t = e.startPTS;\n  if (ue(t)) {\n    let r = 0, n;\n    e.sn &gt; s.sn ? (r = t - s.start, n = s) : (r = s.start - t, n = e), n.duration !== r &amp;&amp; n.setDuration(r);\n  } else e.sn &gt; s.sn ? s.cc === e.cc &amp;&amp; s.minEndPTS ? e.setStart(s.start + (s.minEndPTS - s.start)) : e.setStart(s.start + s.duration) : e.setStart(Math.max(s.start - e.duration, 0));\n}\nfunction Xg(s, e, t, r, n, i, o) {\n  r - t &lt;= 0 &amp;&amp; (o.warn(\"Fragment should have a positive duration\", e), r = t + e.duration, i = n + e.duration);\n  let l = t, c = r;\n  const u = e.startPTS, d = e.endPTS;\n  if (ue(u)) {\n    const b = Math.abs(u - t);\n    s &amp;&amp; b &gt; s.totalduration ? o.warn(`media timestamps and playlist times differ by ${b}s for level ${e.level} ${s.url}`) : ue(e.deltaPTS) ? e.deltaPTS = Math.max(b, e.deltaPTS) : e.deltaPTS = b, l = Math.max(t, u), t = Math.min(t, u), n = e.startDTS !== void 0 ? Math.min(n, e.startDTS) : n, c = Math.min(r, d), r = Math.max(r, d), i = e.endDTS !== void 0 ? Math.max(i, e.endDTS) : i;\n  }\n  const h = t - e.start;\n  e.start !== 0 &amp;&amp; e.setStart(t), e.setDuration(r - e.start), e.startPTS = t, e.maxStartPTS = l, e.startDTS = n, e.endPTS = r, e.minEndPTS = c, e.endDTS = i;\n  const f = e.sn;\n  if (!s || f &lt; s.startSN || f &gt; s.endSN)\n    return 0;\n  let p;\n  const y = f - s.startSN, E = s.fragments;\n  for (E[y] = e, p = y; p &gt; 0; p--)\n    pl(E[p], E[p - 1]);\n  for (p = y; p &lt; E.length - 1; p++)\n    pl(E[p], E[p + 1]);\n  return s.fragmentHint &amp;&amp; pl(E[E.length - 1], s.fragmentHint), s.PTSKnown = s.alignedSliding = !0, h;\n}\nfunction Zb(s, e, t) {\n  if (s === e)\n    return;\n  let r = null;\n  const n = s.fragments;\n  for (let u = n.length - 1; u &gt;= 0; u--) {\n    const d = n[u].initSegment;\n    if (d) {\n      r = d;\n      break;\n    }\n  }\n  s.fragmentHint &amp;&amp; delete s.fragmentHint.endPTS;\n  let i;\n  Qb(s, e, (u, d, h, f) =&gt; {\n    if ((!e.startCC || e.skippedSegments) &amp;&amp; d.cc !== u.cc) {\n      const p = u.cc - d.cc;\n      for (let y = h; y &lt; f.length; y++)\n        f[y].cc += p;\n      e.endCC = f[f.length - 1].cc;\n    }\n    ue(u.startPTS) &amp;&amp; ue(u.endPTS) &amp;&amp; (d.setStart(d.startPTS = u.startPTS), d.startDTS = u.startDTS, d.maxStartPTS = u.maxStartPTS, d.endPTS = u.endPTS, d.endDTS = u.endDTS, d.minEndPTS = u.minEndPTS, d.setDuration(u.endPTS - u.startPTS), d.duration &amp;&amp; (i = d), e.PTSKnown = e.alignedSliding = !0), u.hasStreams &amp;&amp; (d.elementaryStreams = u.elementaryStreams), d.loader = u.loader, u.hasStats &amp;&amp; (d.stats = u.stats), u.initSegment &amp;&amp; (d.initSegment = u.initSegment, r = u.initSegment);\n  });\n  const o = e.fragments, a = e.fragmentHint ? o.concat(e.fragmentHint) : o;\n  if (r &amp;&amp; a.forEach((u) =&gt; {\n    var d;\n    u &amp;&amp; (!u.initSegment || u.initSegment.relurl === ((d = r) == null ? void 0 : d.relurl)) &amp;&amp; (u.initSegment = r);\n  }), e.skippedSegments) {\n    if (e.deltaUpdateFailed = o.some((u) =&gt; !u), e.deltaUpdateFailed) {\n      t.warn(\"[level-helper] Previous playlist missing segments skipped in delta playlist\");\n      for (let u = e.skippedSegments; u--; )\n        o.shift();\n      e.startSN = o[0].sn;\n    } else {\n      e.canSkipDateRanges &amp;&amp; (e.dateRanges = Xb(s.dateRanges, e, t));\n      const u = s.fragments.filter((d) =&gt; d.rawProgramDateTime);\n      if (s.hasProgramDateTime &amp;&amp; !e.hasProgramDateTime)\n        for (let d = 1; d &lt; a.length; d++)\n          a[d].programDateTime === null &amp;&amp; fc(a[d], a[d - 1], u);\n      Zg(u, e);\n    }\n    e.endCC = o[o.length - 1].cc;\n  }\n  if (!e.startCC) {\n    var l;\n    const u = ep(s, e.startSN - 1);\n    e.startCC = (l = u == null ? void 0 : u.cc) != null ? l : o[0].cc;\n  }\n  Jb(s.partList, e.partList, (u, d) =&gt; {\n    d.elementaryStreams = u.elementaryStreams, d.stats = u.stats;\n  }), i ? Xg(e, i, i.startPTS, i.endPTS, i.startDTS, i.endDTS, t) : Jg(s, e), o.length &amp;&amp; (e.totalduration = e.edge - o[0].start), e.driftStartTime = s.driftStartTime, e.driftStart = s.driftStart;\n  const c = e.advancedDateTime;\n  if (e.advanced &amp;&amp; c) {\n    const u = e.edge;\n    e.driftStart || (e.driftStartTime = c, e.driftStart = u), e.driftEndTime = c, e.driftEnd = u;\n  } else\n    e.driftEndTime = s.driftEndTime, e.driftEnd = s.driftEnd, e.advancedDateTime = s.advancedDateTime;\n  e.requestScheduled === -1 &amp;&amp; (e.requestScheduled = s.requestScheduled);\n}\nfunction Xb(s, e, t) {\n  const {\n    dateRanges: r,\n    recentlyRemovedDateranges: n\n  } = e, i = nt({}, s);\n  n &amp;&amp; n.forEach((l) =&gt; {\n    delete i[l];\n  });\n  const a = Object.keys(i).length;\n  return a ? (Object.keys(r).forEach((l) =&gt; {\n    const c = i[l], u = new Wg(r[l].attr, c);\n    u.isValid ? (i[l] = u, c || (u.tagOrder += a)) : t.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: \"${at(r[l].attr)}\"`);\n  }), i) : r;\n}\nfunction Jb(s, e, t) {\n  if (s &amp;&amp; e) {\n    let r = 0;\n    for (let n = 0, i = s.length; n &lt;= i; n++) {\n      const o = s[n], a = e[n + r];\n      o &amp;&amp; a &amp;&amp; o.index === a.index &amp;&amp; o.fragment.sn === a.fragment.sn ? t(o, a) : r--;\n    }\n  }\n}\nfunction Qb(s, e, t) {\n  const r = e.skippedSegments, n = Math.max(s.startSN, e.startSN) - e.startSN, i = (s.fragmentHint ? 1 : 0) + (r ? e.endSN : Math.min(s.endSN, e.endSN)) - e.startSN, o = e.startSN - s.startSN, a = e.fragmentHint ? e.fragments.concat(e.fragmentHint) : e.fragments, l = s.fragmentHint ? s.fragments.concat(s.fragmentHint) : s.fragments;\n  for (let c = n; c &lt;= i; c++) {\n    const u = l[o + c];\n    let d = a[c];\n    if (r &amp;&amp; !d &amp;&amp; u &amp;&amp; (d = e.fragments[c] = u), u &amp;&amp; d) {\n      t(u, d, c, a);\n      const h = u.relurl, f = d.relurl;\n      if (h &amp;&amp; eT(h, f)) {\n        e.playlistParsingError = Dh(`media sequence mismatch ${d.sn}:`, s, e, u, d);\n        return;\n      } else if (u.cc !== d.cc) {\n        e.playlistParsingError = Dh(`discontinuity sequence mismatch (${u.cc}!=${d.cc})`, s, e, u, d);\n        return;\n      }\n    }\n  }\n}\nfunction Dh(s, e, t, r, n) {\n  return new Error(`${s} ${n.url}\nPlaylist starting @${e.startSN}\n${e.m3u8}\n\nPlaylist starting @${t.startSN}\n${t.m3u8}`);\n}\nfunction Jg(s, e, t = !0) {\n  const r = e.startSN + e.skippedSegments - s.startSN, n = s.fragments, i = r &gt;= 0;\n  let o = 0;\n  if (i &amp;&amp; r &lt; n.length)\n    o = n[r].start;\n  else if (i &amp;&amp; e.startSN === s.endSN + 1)\n    o = s.fragmentEnd;\n  else if (i &amp;&amp; t)\n    o = s.fragmentStart + r * e.levelTargetDuration;\n  else if (!e.skippedSegments &amp;&amp; e.fragmentStart === 0)\n    o = s.fragmentStart;\n  else\n    return;\n  gc(e, o);\n}\nfunction gc(s, e) {\n  if (e) {\n    const t = s.fragments;\n    for (let r = s.skippedSegments; r &lt; t.length; r++)\n      t[r].addStart(e);\n    s.fragmentHint &amp;&amp; s.fragmentHint.addStart(e);\n  }\n}\nfunction Qg(s, e = 1 / 0) {\n  let t = 1e3 * s.targetduration;\n  if (s.updated) {\n    const r = s.fragments;\n    if (r.length &amp;&amp; t * 4 &gt; e) {\n      const i = r[r.length - 1].duration * 1e3;\n      i &lt; t &amp;&amp; (t = i);\n    }\n  } else\n    t /= 2;\n  return Math.round(t);\n}\nfunction ep(s, e, t) {\n  if (!s)\n    return null;\n  let r = s.fragments[e - s.startSN];\n  return r || (r = s.fragmentHint, r &amp;&amp; r.sn === e) ? r : e &lt; s.startSN &amp;&amp; t &amp;&amp; t.sn === e ? t : null;\n}\nfunction Ph(s, e, t) {\n  return s ? tp(s.partList, e, t) : null;\n}\nfunction tp(s, e, t) {\n  if (s)\n    for (let r = s.length; r--; ) {\n      const n = s[r];\n      if (n.index === t &amp;&amp; n.fragment.sn === e)\n        return n;\n    }\n  return null;\n}\nfunction rp(s) {\n  s.forEach((e, t) =&gt; {\n    var r;\n    (r = e.details) == null || r.fragments.forEach((n) =&gt; {\n      n.level = t, n.initSegment &amp;&amp; (n.initSegment.level = t);\n    });\n  });\n}\nfunction eT(s, e) {\n  return s !== e &amp;&amp; e ? Mh(s) !== Mh(e) : !1;\n}\nfunction Mh(s) {\n  return s.replace(/\\?[^?]*$/, \"\");\n}\nfunction Yn(s, e) {\n  for (let r = 0, n = s.length; r &lt; n; r++) {\n    var t;\n    if (((t = s[r]) == null ? void 0 : t.cc) === e)\n      return s[r];\n  }\n  return null;\n}\nfunction tT(s, e) {\n  return !!(s &amp;&amp; e.startCC &lt; s.endCC &amp;&amp; e.endCC &gt; s.startCC);\n}\nfunction Oh(s, e) {\n  const t = s.start + e;\n  s.startPTS = t, s.setStart(t), s.endPTS = t + s.duration;\n}\nfunction sp(s, e) {\n  const t = e.fragments;\n  for (let r = 0, n = t.length; r &lt; n; r++)\n    Oh(t[r], s);\n  e.fragmentHint &amp;&amp; Oh(e.fragmentHint, s), e.alignedSliding = !0;\n}\nfunction rT(s, e) {\n  s &amp;&amp; (np(e, s), e.alignedSliding || sa(e, s), !e.alignedSliding &amp;&amp; !e.skippedSegments &amp;&amp; Jg(s, e, !1));\n}\nfunction np(s, e) {\n  if (!tT(e, s))\n    return;\n  const t = Math.min(e.endCC, s.endCC), r = Yn(e.fragments, t), n = Yn(s.fragments, t);\n  if (!r || !n)\n    return;\n  rt.log(`Aligning playlist at start of dicontinuity sequence ${t}`);\n  const i = r.start - n.start;\n  sp(i, s);\n}\nfunction sa(s, e) {\n  if (!s.hasProgramDateTime || !e.hasProgramDateTime)\n    return;\n  const t = s.fragments, r = e.fragments;\n  if (!t.length || !r.length)\n    return;\n  let n, i;\n  const o = Math.min(e.endCC, s.endCC);\n  e.startCC &lt; o &amp;&amp; s.startCC &lt; o &amp;&amp; (n = Yn(r, o), i = Yn(t, o)), (!n || !i) &amp;&amp; (n = r[Math.floor(r.length / 2)], i = Yn(t, n.cc) || t[Math.floor(t.length / 2)]);\n  const a = n.programDateTime, l = i.programDateTime;\n  if (!a || !l)\n    return;\n  const c = (l - a) / 1e3 - (i.start - n.start);\n  sp(c, s);\n}\nfunction cr(s, e, t) {\n  pr(s, e, t), s.addEventListener(e, t);\n}\nfunction pr(s, e, t) {\n  s.removeEventListener(e, t);\n}\nconst sT = {\n  toString: function(s) {\n    let e = \"\";\n    const t = s.length;\n    for (let r = 0; r &lt; t; r++)\n      e += `[${s.start(r).toFixed(3)}-${s.end(r).toFixed(3)}]`;\n    return e;\n  }\n}, ne = {\n  STOPPED: \"STOPPED\",\n  IDLE: \"IDLE\",\n  KEY_LOADING: \"KEY_LOADING\",\n  FRAG_LOADING: \"FRAG_LOADING\",\n  FRAG_LOADING_WAITING_RETRY: \"FRAG_LOADING_WAITING_RETRY\",\n  WAITING_TRACK: \"WAITING_TRACK\",\n  PARSING: \"PARSING\",\n  PARSED: \"PARSED\",\n  ENDED: \"ENDED\",\n  ERROR: \"ERROR\",\n  WAITING_INIT_PTS: \"WAITING_INIT_PTS\",\n  WAITING_LEVEL: \"WAITING_LEVEL\"\n};\nclass Tu extends Hg {\n  constructor(e, t, r, n, i) {\n    super(n, e.logger), this.hls = void 0, this.fragPrevious = null, this.fragCurrent = null, this.fragmentTracker = void 0, this.transmuxer = null, this._state = ne.STOPPED, this.playlistType = void 0, this.media = null, this.mediaBuffer = null, this.config = void 0, this.bitrateTest = !1, this.lastCurrentTime = 0, this.nextLoadPosition = 0, this.startPosition = 0, this.startTimeOffset = null, this.retryDate = 0, this.levels = null, this.fragmentLoader = void 0, this.keyLoader = void 0, this.levelLastLoaded = null, this.startFragRequested = !1, this.decrypter = void 0, this.initPTS = [], this.buffering = !0, this.loadingParts = !1, this.loopSn = void 0, this.onMediaSeeking = () =&gt; {\n      const {\n        config: o,\n        fragCurrent: a,\n        media: l,\n        mediaBuffer: c,\n        state: u\n      } = this, d = l ? l.currentTime : 0, h = Ce.bufferInfo(c || l, d, o.maxBufferHole), f = !h.len;\n      if (this.log(`Media seeking to ${ue(d) ? d.toFixed(3) : d}, state: ${u}, ${f ? \"out of\" : \"in\"} buffer`), this.state === ne.ENDED)\n        this.resetLoadingState();\n      else if (a) {\n        const p = o.maxFragLookUpTolerance, y = a.start - p, E = a.start + a.duration + p;\n        if (f || E &lt; h.start || y &gt; h.end) {\n          const b = d &gt; E;\n          (d &lt; y || b) &amp;&amp; (b &amp;&amp; a.loader &amp;&amp; (this.log(`Cancelling fragment load for seek (sn: ${a.sn})`), a.abortRequests(), this.resetLoadingState()), this.fragPrevious = null);\n        }\n      }\n      if (l) {\n        this.fragmentTracker.removeFragmentsInRange(d, 1 / 0, this.playlistType, !0);\n        const p = this.lastCurrentTime;\n        if (d &gt; p &amp;&amp; (this.lastCurrentTime = d), !this.loadingParts) {\n          const y = Math.max(h.end, d), E = this.shouldLoadParts(this.getLevelDetails(), y);\n          E &amp;&amp; (this.log(`LL-Part loading ON after seeking to ${d.toFixed(2)} with buffer @${y.toFixed(2)}`), this.loadingParts = E);\n        }\n      }\n      this.hls.hasEnoughToStart || (this.log(`Setting ${f ? \"startPosition\" : \"nextLoadPosition\"} to ${d} for seek without enough to start`), this.nextLoadPosition = d, f &amp;&amp; (this.startPosition = d)), f &amp;&amp; this.state === ne.IDLE &amp;&amp; this.tickImmediate();\n    }, this.onMediaEnded = () =&gt; {\n      this.log(\"setting startPosition to 0 because media ended\"), this.startPosition = this.lastCurrentTime = 0;\n    }, this.playlistType = i, this.hls = e, this.fragmentLoader = new Cb(e.config), this.keyLoader = r, this.fragmentTracker = t, this.config = e.config, this.decrypter = new vu(e.config);\n  }\n  registerListeners() {\n    const {\n      hls: e\n    } = this;\n    e.on(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(I.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls: e\n    } = this;\n    e.off(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(I.ERROR, this.onError, this);\n  }\n  doTick() {\n    this.onTickEnd();\n  }\n  onTickEnd() {\n  }\n  startLoad(e) {\n  }\n  stopLoad() {\n    if (this.state === ne.STOPPED)\n      return;\n    this.fragmentLoader.abort(), this.keyLoader.abort(this.playlistType);\n    const e = this.fragCurrent;\n    e != null &amp;&amp; e.loader &amp;&amp; (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.resetTransmuxer(), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = ne.STOPPED;\n  }\n  get startPositionValue() {\n    const {\n      nextLoadPosition: e,\n      startPosition: t\n    } = this;\n    return t === -1 &amp;&amp; e ? e : t;\n  }\n  get bufferingEnabled() {\n    return this.buffering;\n  }\n  pauseBuffering() {\n    this.buffering = !1;\n  }\n  resumeBuffering() {\n    this.buffering = !0;\n  }\n  get inFlightFrag() {\n    return {\n      frag: this.fragCurrent,\n      state: this.state\n    };\n  }\n  _streamEnded(e, t) {\n    if (t.live || !this.media)\n      return !1;\n    const r = e.end || 0, n = this.config.timelineOffset || 0;\n    if (r &lt;= n)\n      return !1;\n    const i = e.buffered;\n    this.config.maxBufferHole &amp;&amp; i &amp;&amp; i.length &gt; 1 &amp;&amp; (e = Ce.bufferedInfo(i, e.start, 0));\n    const o = e.nextStart;\n    if (o &amp;&amp; o &gt; n &amp;&amp; o &lt; t.edge || this.media.currentTime &lt; e.start)\n      return !1;\n    const l = t.partList;\n    if (l != null &amp;&amp; l.length) {\n      const u = l[l.length - 1];\n      return Ce.isBuffered(this.media, u.start + u.duration / 2);\n    }\n    const c = t.fragments[t.fragments.length - 1].type;\n    return this.fragmentTracker.isEndListAppended(c);\n  }\n  getLevelDetails() {\n    if (this.levels &amp;&amp; this.levelLastLoaded !== null)\n      return this.levelLastLoaded.details;\n  }\n  get timelineOffset() {\n    const e = this.config.timelineOffset;\n    if (e) {\n      var t;\n      return ((t = this.getLevelDetails()) == null ? void 0 : t.appliedTimelineOffset) || e;\n    }\n    return 0;\n  }\n  onMediaAttached(e, t) {\n    const r = this.media = this.mediaBuffer = t.media;\n    cr(r, \"seeking\", this.onMediaSeeking), cr(r, \"ended\", this.onMediaEnded);\n    const n = this.config;\n    this.levels &amp;&amp; n.autoStartLoad &amp;&amp; this.state === ne.STOPPED &amp;&amp; this.startLoad(n.startPosition);\n  }\n  onMediaDetaching(e, t) {\n    const r = !!t.transferMedia, n = this.media;\n    if (n !== null) {\n      if (n.ended &amp;&amp; (this.log(\"MSE detaching and video ended, reset startPosition\"), this.startPosition = this.lastCurrentTime = 0), pr(n, \"seeking\", this.onMediaSeeking), pr(n, \"ended\", this.onMediaEnded), this.keyLoader &amp;&amp; !r &amp;&amp; this.keyLoader.detach(), this.media = this.mediaBuffer = null, this.loopSn = void 0, r) {\n        this.resetLoadingState(), this.resetTransmuxer();\n        return;\n      }\n      this.loadingParts = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad();\n    }\n  }\n  onManifestLoading() {\n    this.initPTS = [], this.levels = this.levelLastLoaded = this.fragCurrent = null, this.lastCurrentTime = this.startPosition = 0, this.startFragRequested = !1;\n  }\n  onError(e, t) {\n  }\n  onManifestLoaded(e, t) {\n    this.startTimeOffset = t.startTimeOffset;\n  }\n  onHandlerDestroying() {\n    this.stopLoad(), this.transmuxer &amp;&amp; (this.transmuxer.destroy(), this.transmuxer = null), super.onHandlerDestroying(), this.hls = this.onMediaSeeking = this.onMediaEnded = null;\n  }\n  onHandlerDestroyed() {\n    this.state = ne.STOPPED, this.fragmentLoader &amp;&amp; this.fragmentLoader.destroy(), this.keyLoader &amp;&amp; this.keyLoader.destroy(), this.decrypter &amp;&amp; this.decrypter.destroy(), this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null, super.onHandlerDestroyed();\n  }\n  loadFragment(e, t, r) {\n    this.startFragRequested = !0, this._loadFragForPlayback(e, t, r);\n  }\n  _loadFragForPlayback(e, t, r) {\n    const n = (i) =&gt; {\n      const o = i.frag;\n      if (this.fragContextChanged(o)) {\n        this.warn(`${o.type} sn: ${o.sn}${i.part ? \" part: \" + i.part.index : \"\"} of ${this.fragInfo(o, !1, i.part)}) was dropped during download.`), this.fragmentTracker.removeFragment(o);\n        return;\n      }\n      o.stats.chunkCount++, this._handleFragmentLoadProgress(i);\n    };\n    this._doFragLoad(e, t, r, n).then((i) =&gt; {\n      if (!i)\n        return;\n      const o = this.state, a = i.frag;\n      if (this.fragContextChanged(a)) {\n        (o === ne.FRAG_LOADING || !this.fragCurrent &amp;&amp; o === ne.PARSING) &amp;&amp; (this.fragmentTracker.removeFragment(a), this.state = ne.IDLE);\n        return;\n      }\n      \"payload\" in i &amp;&amp; (this.log(`Loaded ${a.type} sn: ${a.sn} of ${this.playlistLabel()} ${a.level}`), this.hls.trigger(I.FRAG_LOADED, i)), this._handleFragmentLoadComplete(i);\n    }).catch((i) =&gt; {\n      this.state === ne.STOPPED || this.state === ne.ERROR || (this.warn(`Frag error: ${(i == null ? void 0 : i.message) || i}`), this.resetFragmentLoading(e));\n    });\n  }\n  clearTrackerIfNeeded(e) {\n    var t;\n    const {\n      fragmentTracker: r\n    } = this;\n    if (r.getState(e) === Ht.APPENDING) {\n      const i = e.type, o = this.getFwdBufferInfo(this.mediaBuffer, i), a = Math.max(e.duration, o ? o.len : this.config.maxBufferLength), l = this.backtrackFragment;\n      ((l ? e.sn - l.sn : 0) === 1 || this.reduceMaxBufferLength(a, e.duration)) &amp;&amp; r.removeFragment(e);\n    } else ((t = this.mediaBuffer) == null ? void 0 : t.buffered.length) === 0 ? r.removeAllFragments() : r.hasParts(e.type) &amp;&amp; (r.detectPartialFragments({\n      frag: e,\n      part: null,\n      stats: e.stats,\n      id: e.type\n    }), r.getState(e) === Ht.PARTIAL &amp;&amp; r.removeFragment(e));\n  }\n  checkLiveUpdate(e) {\n    if (e.updated &amp;&amp; !e.live) {\n      const t = e.fragments[e.fragments.length - 1];\n      this.fragmentTracker.detectPartialFragments({\n        frag: t,\n        part: null,\n        stats: t.stats,\n        id: t.type\n      });\n    }\n    e.fragments[0] || (e.deltaUpdateFailed = !0);\n  }\n  waitForLive(e) {\n    const t = e.details;\n    return (t == null ? void 0 : t.live) &amp;&amp; t.type !== \"EVENT\" &amp;&amp; (this.levelLastLoaded !== e || t.expired);\n  }\n  flushMainBuffer(e, t, r = null) {\n    if (!(e - t))\n      return;\n    const n = {\n      startOffset: e,\n      endOffset: t,\n      type: r\n    };\n    this.hls.trigger(I.BUFFER_FLUSHING, n);\n  }\n  _loadInitSegment(e, t) {\n    this._doFragLoad(e, t).then((r) =&gt; {\n      const n = r == null ? void 0 : r.frag;\n      if (!n || this.fragContextChanged(n) || !this.levels)\n        throw new Error(\"init load aborted\");\n      return r;\n    }).then((r) =&gt; {\n      const {\n        hls: n\n      } = this, {\n        frag: i,\n        payload: o\n      } = r, a = i.decryptdata;\n      if (o &amp;&amp; o.byteLength &gt; 0 &amp;&amp; a != null &amp;&amp; a.key &amp;&amp; a.iv &amp;&amp; In(a.method)) {\n        const l = self.performance.now();\n        return this.decrypter.decrypt(new Uint8Array(o), a.key.buffer, a.iv.buffer, Su(a.method)).catch((c) =&gt; {\n          throw n.trigger(I.ERROR, {\n            type: ve.MEDIA_ERROR,\n            details: J.FRAG_DECRYPT_ERROR,\n            fatal: !1,\n            error: c,\n            reason: c.message,\n            frag: i\n          }), c;\n        }).then((c) =&gt; {\n          const u = self.performance.now();\n          return n.trigger(I.FRAG_DECRYPTED, {\n            frag: i,\n            payload: c,\n            stats: {\n              tstart: l,\n              tdecrypt: u\n            }\n          }), r.payload = c, this.completeInitSegmentLoad(r);\n        });\n      }\n      return this.completeInitSegmentLoad(r);\n    }).catch((r) =&gt; {\n      this.state === ne.STOPPED || this.state === ne.ERROR || (this.warn(r), this.resetFragmentLoading(e));\n    });\n  }\n  completeInitSegmentLoad(e) {\n    const {\n      levels: t\n    } = this;\n    if (!t)\n      throw new Error(\"init load aborted, missing levels\");\n    const r = e.frag.stats;\n    this.state !== ne.STOPPED &amp;&amp; (this.state = ne.IDLE), e.frag.data = new Uint8Array(e.payload), r.parsing.start = r.buffering.start = self.performance.now(), r.parsing.end = r.buffering.end = self.performance.now(), this.tick();\n  }\n  unhandledEncryptionError(e, t) {\n    var r, n;\n    const i = e.tracks;\n    if (i &amp;&amp; !t.encrypted &amp;&amp; ((r = i.audio) != null &amp;&amp; r.encrypted || (n = i.video) != null &amp;&amp; n.encrypted) &amp;&amp; (!this.config.emeEnabled || !this.keyLoader.emeController)) {\n      const o = this.media, a = new Error(`Encrypted track with no key in ${this.fragInfo(t)} (media ${o ? \"attached mediaKeys: \" + o.mediaKeys : \"detached\"})`);\n      return this.warn(a.message), !o || o.mediaKeys ? !1 : (this.hls.trigger(I.ERROR, {\n        type: ve.KEY_SYSTEM_ERROR,\n        details: J.KEY_SYSTEM_NO_KEYS,\n        fatal: !1,\n        error: a,\n        frag: t\n      }), this.resetTransmuxer(), !0);\n    }\n    return !1;\n  }\n  fragContextChanged(e) {\n    const {\n      fragCurrent: t\n    } = this;\n    return !e || !t || e.sn !== t.sn || e.level !== t.level;\n  }\n  fragBufferedComplete(e, t) {\n    const r = this.mediaBuffer ? this.mediaBuffer : this.media;\n    if (this.log(`Buffered ${e.type} sn: ${e.sn}${t ? \" part: \" + t.index : \"\"} of ${this.fragInfo(e, !1, t)} &gt; buffer:${r ? sT.toString(Ce.getBuffered(r)) : \"(detached)\"})`), Vt(e)) {\n      var n;\n      if (e.type !== pe.SUBTITLE) {\n        const o = e.elementaryStreams;\n        if (!Object.keys(o).some((a) =&gt; !!o[a])) {\n          this.state = ne.IDLE;\n          return;\n        }\n      }\n      const i = (n = this.levels) == null ? void 0 : n[e.level];\n      i != null &amp;&amp; i.fragmentError &amp;&amp; (this.log(`Resetting level fragment error count of ${i.fragmentError} on frag buffered`), i.fragmentError = 0);\n    }\n    this.state = ne.IDLE;\n  }\n  _handleFragmentLoadComplete(e) {\n    const {\n      transmuxer: t\n    } = this;\n    if (!t)\n      return;\n    const {\n      frag: r,\n      part: n,\n      partsLoaded: i\n    } = e, o = !i || i.length === 0 || i.some((l) =&gt; !l), a = new Eu(r.level, r.sn, r.stats.chunkCount + 1, 0, n ? n.index : -1, !o);\n    t.flush(a);\n  }\n  _handleFragmentLoadProgress(e) {\n  }\n  _doFragLoad(e, t, r = null, n) {\n    var i;\n    this.fragCurrent = e;\n    const o = t.details;\n    if (!this.levels || !o)\n      throw new Error(`frag load aborted, missing level${o ? \"\" : \" detail\"}s`);\n    let a = null;\n    if (e.encrypted &amp;&amp; !((i = e.decryptdata) != null &amp;&amp; i.key)) {\n      if (this.log(`Loading key for ${e.sn} of [${o.startSN}-${o.endSN}], ${this.playlistLabel()} ${e.level}`), this.state = ne.KEY_LOADING, this.fragCurrent = e, a = this.keyLoader.load(e).then((h) =&gt; {\n        if (!this.fragContextChanged(h.frag))\n          return this.hls.trigger(I.KEY_LOADED, h), this.state === ne.KEY_LOADING &amp;&amp; (this.state = ne.IDLE), h;\n      }), this.hls.trigger(I.KEY_LOADING, {\n        frag: e\n      }), this.fragCurrent === null)\n        return this.log(\"context changed in KEY_LOADING\"), Promise.resolve(null);\n    } else e.encrypted || (a = this.keyLoader.loadClear(e, o.encryptedFragments, this.startFragRequested), a &amp;&amp; this.log(\"[eme] blocking frag load until media-keys acquired\"));\n    const l = this.fragPrevious;\n    if (Vt(e) &amp;&amp; (!l || e.sn !== l.sn)) {\n      const h = this.shouldLoadParts(t.details, e.end);\n      h !== this.loadingParts &amp;&amp; (this.log(`LL-Part loading ${h ? \"ON\" : \"OFF\"} loading sn ${l == null ? void 0 : l.sn}-&gt;${e.sn}`), this.loadingParts = h);\n    }\n    if (r = Math.max(e.start, r || 0), this.loadingParts &amp;&amp; Vt(e)) {\n      const h = o.partList;\n      if (h &amp;&amp; n) {\n        r &gt; o.fragmentEnd &amp;&amp; o.fragmentHint &amp;&amp; (e = o.fragmentHint);\n        const f = this.getNextPart(h, e, r);\n        if (f &gt; -1) {\n          const p = h[f];\n          e = this.fragCurrent = p.fragment, this.log(`Loading ${e.type} sn: ${e.sn} part: ${p.index} (${f}/${h.length - 1}) of ${this.fragInfo(e, !1, p)}) cc: ${e.cc} [${o.startSN}-${o.endSN}], target: ${parseFloat(r.toFixed(3))}`), this.nextLoadPosition = p.start + p.duration, this.state = ne.FRAG_LOADING;\n          let y;\n          return a ? y = a.then((E) =&gt; !E || this.fragContextChanged(E.frag) ? null : this.doFragPartsLoad(e, p, t, n)).catch((E) =&gt; this.handleFragLoadError(E)) : y = this.doFragPartsLoad(e, p, t, n).catch((E) =&gt; this.handleFragLoadError(E)), this.hls.trigger(I.FRAG_LOADING, {\n            frag: e,\n            part: p,\n            targetBufferTime: r\n          }), this.fragCurrent === null ? Promise.reject(new Error(\"frag load aborted, context changed in FRAG_LOADING parts\")) : y;\n        } else if (!e.url || this.loadedEndOfParts(h, r))\n          return Promise.resolve(null);\n      }\n    }\n    if (Vt(e) &amp;&amp; this.loadingParts) {\n      var c;\n      this.log(`LL-Part loading OFF after next part miss @${r.toFixed(2)} Check buffer at sn: ${e.sn} loaded parts: ${(c = o.partList) == null ? void 0 : c.filter((h) =&gt; h.loaded).map((h) =&gt; `[${h.start}-${h.end}]`)}`), this.loadingParts = !1;\n    } else if (!e.url)\n      return Promise.resolve(null);\n    this.log(`Loading ${e.type} sn: ${e.sn} of ${this.fragInfo(e, !1)}) cc: ${e.cc} ${\"[\" + o.startSN + \"-\" + o.endSN + \"]\"}, target: ${parseFloat(r.toFixed(3))}`), ue(e.sn) &amp;&amp; !this.bitrateTest &amp;&amp; (this.nextLoadPosition = e.start + e.duration), this.state = ne.FRAG_LOADING;\n    const u = this.config.progressive;\n    let d;\n    return u &amp;&amp; a ? d = a.then((h) =&gt; !h || this.fragContextChanged(h.frag) ? null : this.fragmentLoader.load(e, n)).catch((h) =&gt; this.handleFragLoadError(h)) : d = Promise.all([this.fragmentLoader.load(e, u ? n : void 0), a]).then(([h]) =&gt; (!u &amp;&amp; n &amp;&amp; n(h), h)).catch((h) =&gt; this.handleFragLoadError(h)), this.hls.trigger(I.FRAG_LOADING, {\n      frag: e,\n      targetBufferTime: r\n    }), this.fragCurrent === null ? Promise.reject(new Error(\"frag load aborted, context changed in FRAG_LOADING\")) : d;\n  }\n  doFragPartsLoad(e, t, r, n) {\n    return new Promise((i, o) =&gt; {\n      var a;\n      const l = [], c = (a = r.details) == null ? void 0 : a.partList, u = (d) =&gt; {\n        this.fragmentLoader.loadPart(e, d, n).then((h) =&gt; {\n          l[d.index] = h;\n          const f = h.part;\n          this.hls.trigger(I.FRAG_LOADED, h);\n          const p = Ph(r.details, e.sn, d.index + 1) || tp(c, e.sn, d.index + 1);\n          if (p)\n            u(p);\n          else\n            return i({\n              frag: e,\n              part: f,\n              partsLoaded: l\n            });\n        }).catch(o);\n      };\n      u(t);\n    });\n  }\n  handleFragLoadError(e) {\n    if (\"data\" in e) {\n      const t = e.data;\n      t.frag &amp;&amp; t.details === J.INTERNAL_ABORTED ? this.handleFragLoadAborted(t.frag, t.part) : t.frag &amp;&amp; t.type === ve.KEY_SYSTEM_ERROR ? (t.frag.abortRequests(), this.resetStartWhenNotLoaded(), this.resetFragmentLoading(t.frag)) : this.hls.trigger(I.ERROR, t);\n    } else\n      this.hls.trigger(I.ERROR, {\n        type: ve.OTHER_ERROR,\n        details: J.INTERNAL_EXCEPTION,\n        err: e,\n        error: e,\n        fatal: !0\n      });\n    return null;\n  }\n  _handleTransmuxerFlush(e) {\n    const t = this.getCurrentContext(e);\n    if (!t || this.state !== ne.PARSING) {\n      !this.fragCurrent &amp;&amp; this.state !== ne.STOPPED &amp;&amp; this.state !== ne.ERROR &amp;&amp; (this.state = ne.IDLE);\n      return;\n    }\n    const {\n      frag: r,\n      part: n,\n      level: i\n    } = t, o = self.performance.now();\n    r.stats.parsing.end = o, n &amp;&amp; (n.stats.parsing.end = o);\n    const a = this.getLevelDetails(), c = a &amp;&amp; r.sn &gt; a.endSN || this.shouldLoadParts(a, r.end);\n    c !== this.loadingParts &amp;&amp; (this.log(`LL-Part loading ${c ? \"ON\" : \"OFF\"} after parsing segment ending @${r.end.toFixed(2)}`), this.loadingParts = c), this.updateLevelTiming(r, n, i, e.partial);\n  }\n  shouldLoadParts(e, t) {\n    if (this.config.lowLatencyMode) {\n      if (!e)\n        return this.loadingParts;\n      if (e.partList) {\n        var r;\n        const i = e.partList[0];\n        if (i.fragment.type === pe.SUBTITLE)\n          return !1;\n        const o = i.end + (((r = e.fragmentHint) == null ? void 0 : r.duration) || 0);\n        if (t &gt;= o) {\n          var n;\n          if ((this.hls.hasEnoughToStart ? ((n = this.media) == null ? void 0 : n.currentTime) || this.lastCurrentTime : this.getLoadPosition()) &gt; i.start - i.fragment.duration)\n            return !0;\n        }\n      }\n    }\n    return !1;\n  }\n  getCurrentContext(e) {\n    const {\n      levels: t,\n      fragCurrent: r\n    } = this, {\n      level: n,\n      sn: i,\n      part: o\n    } = e;\n    if (!(t != null &amp;&amp; t[n]))\n      return this.warn(`Levels object was unset while buffering fragment ${i} of ${this.playlistLabel()} ${n}. The current chunk will not be buffered.`), null;\n    const a = t[n], l = a.details, c = o &gt; -1 ? Ph(l, i, o) : null, u = c ? c.fragment : ep(l, i, r);\n    return u ? (r &amp;&amp; r !== u &amp;&amp; (u.stats = r.stats), {\n      frag: u,\n      part: c,\n      level: a\n    }) : null;\n  }\n  bufferFragmentData(e, t, r, n, i) {\n    if (this.state !== ne.PARSING)\n      return;\n    const {\n      data1: o,\n      data2: a\n    } = e;\n    let l = o;\n    if (a &amp;&amp; (l = _r(o, a)), !l.length)\n      return;\n    const c = this.initPTS[t.cc], u = c ? -c.baseTime / c.timescale : void 0, d = {\n      type: e.type,\n      frag: t,\n      part: r,\n      chunkMeta: n,\n      offset: u,\n      parent: t.type,\n      data: l\n    };\n    if (this.hls.trigger(I.BUFFER_APPENDING, d), e.dropped &amp;&amp; e.independent &amp;&amp; !r) {\n      if (i)\n        return;\n      this.flushBufferGap(t);\n    }\n  }\n  flushBufferGap(e) {\n    const t = this.media;\n    if (!t)\n      return;\n    if (!Ce.isBuffered(t, t.currentTime)) {\n      this.flushMainBuffer(0, e.start);\n      return;\n    }\n    const r = t.currentTime, n = Ce.bufferInfo(t, r, 0), i = e.duration, o = Math.min(this.config.maxFragLookUpTolerance * 2, i * 0.25), a = Math.max(Math.min(e.start - o, n.end - o), r + o);\n    e.start - a &gt; o &amp;&amp; this.flushMainBuffer(a, e.start);\n  }\n  getFwdBufferInfo(e, t) {\n    var r;\n    const n = this.getLoadPosition();\n    if (!ue(n))\n      return null;\n    const o = this.lastCurrentTime &gt; n || (r = this.media) != null &amp;&amp; r.paused ? 0 : this.config.maxBufferHole;\n    return this.getFwdBufferInfoAtPos(e, n, t, o);\n  }\n  getFwdBufferInfoAtPos(e, t, r, n) {\n    const i = Ce.bufferInfo(e, t, n);\n    if (i.len === 0 &amp;&amp; i.nextStart !== void 0) {\n      const o = this.fragmentTracker.getBufferedFrag(t, r);\n      if (o &amp;&amp; (i.nextStart &lt;= o.end || o.gap)) {\n        const a = Math.max(Math.min(i.nextStart, o.end) - t, n);\n        return Ce.bufferInfo(e, t, a);\n      }\n    }\n    return i;\n  }\n  getMaxBufferLength(e) {\n    const {\n      config: t\n    } = this;\n    let r;\n    return e ? r = Math.max(8 * t.maxBufferSize / e, t.maxBufferLength) : r = t.maxBufferLength, Math.min(r, t.maxMaxBufferLength);\n  }\n  reduceMaxBufferLength(e, t) {\n    const r = this.config, n = Math.max(Math.min(e - t, r.maxBufferLength), t), i = Math.max(e - t * 3, r.maxMaxBufferLength / 2, n);\n    return i &gt;= n ? (r.maxMaxBufferLength = i, this.warn(`Reduce max buffer length to ${i}s`), !0) : !1;\n  }\n  getAppendedFrag(e, t = pe.MAIN) {\n    const r = this.fragmentTracker ? this.fragmentTracker.getAppendedFrag(e, t) : null;\n    return r &amp;&amp; \"fragment\" in r ? r.fragment : r;\n  }\n  getNextFragment(e, t) {\n    const r = t.fragments, n = r.length;\n    if (!n)\n      return null;\n    const {\n      config: i\n    } = this, o = r[0].start, a = i.lowLatencyMode &amp;&amp; !!t.partList;\n    let l = null;\n    if (t.live) {\n      const d = i.initialLiveManifestSize;\n      if (n &lt; d)\n        return this.warn(`Not enough fragments to start playback (have: ${n}, need: ${d})`), null;\n      if (!t.PTSKnown &amp;&amp; !this.startFragRequested &amp;&amp; this.startPosition === -1 || e &lt; o) {\n        var c;\n        a &amp;&amp; !this.loadingParts &amp;&amp; (this.log(\"LL-Part loading ON for initial live fragment\"), this.loadingParts = !0), l = this.getInitialLiveFragment(t);\n        const h = this.hls.startPosition, f = this.hls.liveSyncPosition, p = l ? (h !== -1 &amp;&amp; h &gt;= o ? h : f) || l.start : e;\n        this.log(`Setting startPosition to ${p} to match start frag at live edge. mainStart: ${h} liveSyncPosition: ${f} frag.start: ${(c = l) == null ? void 0 : c.start}`), this.startPosition = this.nextLoadPosition = p;\n      }\n    } else e &lt;= o &amp;&amp; (l = r[0]);\n    if (!l) {\n      const d = this.loadingParts ? t.partEnd : t.fragmentEnd;\n      l = this.getFragmentAtPosition(e, d, t);\n    }\n    let u = this.filterReplacedPrimary(l, t);\n    if (!u &amp;&amp; l) {\n      const d = l.sn - t.startSN;\n      u = this.filterReplacedPrimary(r[d + 1] || null, t);\n    }\n    return this.mapToInitFragWhenRequired(u);\n  }\n  isLoopLoading(e, t) {\n    const r = this.fragmentTracker.getState(e);\n    return (r === Ht.OK || r === Ht.PARTIAL &amp;&amp; !!e.gap) &amp;&amp; this.nextLoadPosition &gt; t;\n  }\n  getNextFragmentLoopLoading(e, t, r, n, i) {\n    let o = null;\n    if (e.gap &amp;&amp; (o = this.getNextFragment(this.nextLoadPosition, t), o &amp;&amp; !o.gap &amp;&amp; r.nextStart)) {\n      const a = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, r.nextStart, n, 0);\n      if (a !== null &amp;&amp; r.len + a.len &gt;= i) {\n        const l = o.sn;\n        return this.loopSn !== l &amp;&amp; (this.log(`buffer full after gaps in \"${n}\" playlist starting at sn: ${l}`), this.loopSn = l), null;\n      }\n    }\n    return this.loopSn = void 0, o;\n  }\n  get primaryPrefetch() {\n    if (Bh(this.config)) {\n      var e;\n      if ((e = this.hls.interstitialsManager) == null || (e = e.playingItem) == null ? void 0 : e.event)\n        return !0;\n    }\n    return !1;\n  }\n  filterReplacedPrimary(e, t) {\n    if (!e)\n      return e;\n    if (Bh(this.config) &amp;&amp; e.type !== pe.SUBTITLE) {\n      const r = this.hls.interstitialsManager, n = r == null ? void 0 : r.bufferingItem;\n      if (n) {\n        const o = n.event;\n        if (o) {\n          if (o.appendInPlace || Math.abs(e.start - n.start) &gt; 1 || n.start === 0)\n            return null;\n        } else if (e.end &lt;= n.start &amp;&amp; (t == null ? void 0 : t.live) === !1 || e.start &gt; n.end &amp;&amp; n.nextEvent &amp;&amp; (n.nextEvent.appendInPlace || e.start - n.end &gt; 1))\n          return null;\n      }\n      const i = r == null ? void 0 : r.playerQueue;\n      if (i)\n        for (let o = i.length; o--; ) {\n          const a = i[o].interstitial;\n          if (a.appendInPlace &amp;&amp; e.start &gt;= a.startTime &amp;&amp; e.end &lt;= a.resumeTime)\n            return null;\n        }\n    }\n    return e;\n  }\n  mapToInitFragWhenRequired(e) {\n    return e != null &amp;&amp; e.initSegment &amp;&amp; !e.initSegment.data &amp;&amp; !this.bitrateTest ? e.initSegment : e;\n  }\n  getNextPart(e, t, r) {\n    let n = -1, i = !1, o = !0;\n    for (let a = 0, l = e.length; a &lt; l; a++) {\n      const c = e[a];\n      if (o = o &amp;&amp; !c.independent, n &gt; -1 &amp;&amp; r &lt; c.start)\n        break;\n      const u = c.loaded;\n      u ? n = -1 : (i || (c.independent || o) &amp;&amp; c.fragment === t) &amp;&amp; (c.fragment !== t &amp;&amp; this.warn(`Need buffer at ${r} but next unloaded part starts at ${c.start}`), n = a), i = u;\n    }\n    return n;\n  }\n  loadedEndOfParts(e, t) {\n    let r;\n    for (let n = e.length; n--; ) {\n      if (r = e[n], !r.loaded)\n        return !1;\n      if (t &gt; r.start)\n        return !0;\n    }\n    return !1;\n  }\n  /*\n   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the\n   \"sliding\" of the playlist, which is its offset from the start of playback. After sliding we can compute the real\n   start and end times for each fragment in the playlist (after which this method will not need to be called).\n  */\n  getInitialLiveFragment(e) {\n    const t = e.fragments, r = this.fragPrevious;\n    let n = null;\n    if (r) {\n      if (e.hasProgramDateTime &amp;&amp; (this.log(`Live playlist, switching playlist, load frag with same PDT: ${r.programDateTime}`), n = vb(t, r.endProgramDateTime, this.config.maxFragLookUpTolerance)), !n) {\n        const i = r.sn + 1;\n        if (i &gt;= e.startSN &amp;&amp; i &lt;= e.endSN) {\n          const o = t[i - e.startSN];\n          r.cc === o.cc &amp;&amp; (n = o, this.log(`Live playlist, switching playlist, load frag with next SN: ${n.sn}`));\n        }\n        n || (n = Vg(e, r.cc, r.end), n &amp;&amp; this.log(`Live playlist, switching playlist, load frag with same CC: ${n.sn}`));\n      }\n    } else {\n      const i = this.hls.liveSyncPosition;\n      i !== null &amp;&amp; (n = this.getFragmentAtPosition(i, this.bitrateTest ? e.fragmentEnd : e.edge, e));\n    }\n    return n;\n  }\n  /*\n  This method finds the best matching fragment given the provided position.\n   */\n  getFragmentAtPosition(e, t, r) {\n    const {\n      config: n\n    } = this;\n    let {\n      fragPrevious: i\n    } = this, {\n      fragments: o,\n      endSN: a\n    } = r;\n    const {\n      fragmentHint: l\n    } = r, {\n      maxFragLookUpTolerance: c\n    } = n, u = r.partList, d = !!(this.loadingParts &amp;&amp; u != null &amp;&amp; u.length &amp;&amp; l);\n    d &amp;&amp; !this.bitrateTest &amp;&amp; u[u.length - 1].fragment.sn === l.sn &amp;&amp; (o = o.concat(l), a = l.sn);\n    let h;\n    if (e &lt; t) {\n      var f;\n      const y = e &lt; this.lastCurrentTime || e &gt; t - c || (f = this.media) != null &amp;&amp; f.paused || !this.startFragRequested ? 0 : c;\n      h = Js(i, o, e, y);\n    } else\n      h = o[o.length - 1];\n    if (h) {\n      const p = h.sn - r.startSN, y = this.fragmentTracker.getState(h);\n      if ((y === Ht.OK || y === Ht.PARTIAL &amp;&amp; h.gap) &amp;&amp; (i = h), i &amp;&amp; h.sn === i.sn &amp;&amp; (!d || u[0].fragment.sn &gt; h.sn || !r.live) &amp;&amp; h.level === i.level) {\n        const b = o[p + 1];\n        h.sn &lt; a &amp;&amp; this.fragmentTracker.getState(b) !== Ht.OK ? h = b : h = null;\n      }\n    }\n    return h;\n  }\n  alignPlaylists(e, t, r) {\n    const n = e.fragments.length;\n    if (!n)\n      return this.warn(\"No fragments in live playlist\"), 0;\n    const i = e.fragmentStart, o = !t, a = e.alignedSliding &amp;&amp; ue(i);\n    if (o || !a &amp;&amp; !i) {\n      rT(r, e);\n      const l = e.fragmentStart;\n      return this.log(`Live playlist sliding: ${l.toFixed(2)} start-sn: ${t ? t.startSN : \"na\"}-&gt;${e.startSN} fragments: ${n}`), l;\n    }\n    return i;\n  }\n  waitForCdnTuneIn(e) {\n    return e.live &amp;&amp; e.canBlockReload &amp;&amp; e.partTarget &amp;&amp; e.tuneInGoal &gt; Math.max(e.partHoldBack, e.partTarget * 3);\n  }\n  setStartPosition(e, t) {\n    let r = this.startPosition;\n    r &lt; t &amp;&amp; (r = -1);\n    const n = this.timelineOffset;\n    if (r === -1) {\n      const i = this.startTimeOffset !== null, o = i ? this.startTimeOffset : e.startTimeOffset;\n      o !== null &amp;&amp; ue(o) ? (r = t + o, o &lt; 0 &amp;&amp; (r += e.edge), r = Math.min(Math.max(t, r), t + e.totalduration), this.log(`Setting startPosition to ${r} for start time offset ${o} found in ${i ? \"multivariant\" : \"media\"} playlist`), this.startPosition = r) : e.live ? (r = this.hls.liveSyncPosition || t, this.log(`Setting startPosition to -1 to start at live edge ${r}`), this.startPosition = -1) : (this.log(\"setting startPosition to 0 by default\"), this.startPosition = r = 0), this.lastCurrentTime = r + n;\n    }\n    this.nextLoadPosition = r + n;\n  }\n  getLoadPosition() {\n    var e;\n    const {\n      media: t\n    } = this;\n    let r = 0;\n    return (e = this.hls) != null &amp;&amp; e.hasEnoughToStart &amp;&amp; t ? r = t.currentTime : this.nextLoadPosition &gt;= 0 &amp;&amp; (r = this.nextLoadPosition), r;\n  }\n  handleFragLoadAborted(e, t) {\n    this.transmuxer &amp;&amp; e.type === this.playlistType &amp;&amp; Vt(e) &amp;&amp; e.stats.aborted &amp;&amp; (this.log(`Fragment ${e.sn}${t ? \" part \" + t.index : \"\"} of ${this.playlistLabel()} ${e.level} was aborted`), this.resetFragmentLoading(e));\n  }\n  resetFragmentLoading(e) {\n    (!this.fragCurrent || !this.fragContextChanged(e) &amp;&amp; this.state !== ne.FRAG_LOADING_WAITING_RETRY) &amp;&amp; (this.state = ne.IDLE);\n  }\n  onFragmentOrKeyLoadError(e, t) {\n    var r;\n    if (t.chunkMeta &amp;&amp; !t.frag) {\n      const b = this.getCurrentContext(t.chunkMeta);\n      b &amp;&amp; (t.frag = b.frag);\n    }\n    const n = t.frag;\n    if (!n || n.type !== e || !this.levels)\n      return;\n    if (this.fragContextChanged(n)) {\n      var i;\n      this.warn(`Frag load error must match current frag to retry ${n.url} &gt; ${(i = this.fragCurrent) == null ? void 0 : i.url}`);\n      return;\n    }\n    const o = t.details === J.FRAG_GAP;\n    o &amp;&amp; this.fragmentTracker.fragBuffered(n, !0);\n    const a = t.errorAction;\n    if (!a) {\n      this.state = ne.ERROR;\n      return;\n    }\n    const {\n      action: l,\n      flags: c,\n      retryCount: u = 0,\n      retryConfig: d\n    } = a, h = !!d, f = h &amp;&amp; l === Zt.RetryRequest, p = h &amp;&amp; !a.resolved &amp;&amp; c === vr.MoveAllAlternatesMatchingHost, y = (r = this.hls.latestLevelDetails) == null ? void 0 : r.live;\n    if (!f &amp;&amp; p &amp;&amp; Vt(n) &amp;&amp; !n.endList &amp;&amp; y &amp;&amp; !Kg(t))\n      this.resetFragmentErrors(e), this.treatAsGap(n), a.resolved = !0;\n    else if ((f || p) &amp;&amp; u &lt; d.maxNumRetry) {\n      var E;\n      const b = uc((E = t.response) == null ? void 0 : E.code), R = yu(d, u);\n      if (this.resetStartWhenNotLoaded(), this.retryDate = self.performance.now() + R, this.state = ne.FRAG_LOADING_WAITING_RETRY, a.resolved = !0, b) {\n        this.log(\"Waiting for connection (offline)\"), this.retryDate = 1 / 0, t.reason = \"offline\";\n        return;\n      }\n      this.warn(`Fragment ${n.sn} of ${e} ${n.level} errored with ${t.details}, retrying loading ${u + 1}/${d.maxNumRetry} in ${R}ms`);\n    } else if (d)\n      if (this.resetFragmentErrors(e), u &lt; d.maxNumRetry)\n        !o &amp;&amp; l !== Zt.RemoveAlternatePermanently &amp;&amp; (a.resolved = !0);\n      else {\n        this.warn(`${t.details} reached or exceeded max retry (${u})`);\n        return;\n      }\n    else l === Zt.SendAlternateToPenaltyBox ? this.state = ne.WAITING_LEVEL : this.state = ne.ERROR;\n    this.tickImmediate();\n  }\n  checkRetryDate() {\n    const e = self.performance.now(), t = this.retryDate, r = t === 1 / 0;\n    (!t || e &gt;= t || r &amp;&amp; !uc(0)) &amp;&amp; (r &amp;&amp; this.log(\"Connection restored (online)\"), this.resetStartWhenNotLoaded(), this.state = ne.IDLE);\n  }\n  reduceLengthAndFlushBuffer(e) {\n    if (this.state === ne.PARSING || this.state === ne.PARSED) {\n      const t = e.frag, r = e.parent, n = this.getFwdBufferInfo(this.mediaBuffer, r), i = n &amp;&amp; n.len &gt; 0.5;\n      i &amp;&amp; this.reduceMaxBufferLength(n.len, (t == null ? void 0 : t.duration) || 10);\n      const o = !i;\n      return o &amp;&amp; this.warn(`Buffer full error while media.currentTime (${this.getLoadPosition()}) is not buffered, flush ${r} buffer`), t &amp;&amp; (this.fragmentTracker.removeFragment(t), this.nextLoadPosition = t.start), this.resetLoadingState(), o;\n    }\n    return !1;\n  }\n  resetFragmentErrors(e) {\n    e === pe.AUDIO &amp;&amp; (this.fragCurrent = null), this.hls.hasEnoughToStart || (this.startFragRequested = !1), this.state !== ne.STOPPED &amp;&amp; (this.state = ne.IDLE);\n  }\n  afterBufferFlushed(e, t, r) {\n    if (!e)\n      return;\n    const n = Ce.getBuffered(e);\n    this.fragmentTracker.detectEvictedFragments(t, n, r), this.state === ne.ENDED &amp;&amp; this.resetLoadingState();\n  }\n  resetLoadingState() {\n    this.log(\"Reset loading state\"), this.fragCurrent = null, this.fragPrevious = null, this.state !== ne.STOPPED &amp;&amp; (this.state = ne.IDLE);\n  }\n  resetStartWhenNotLoaded() {\n    if (!this.hls.hasEnoughToStart) {\n      this.startFragRequested = !1;\n      const e = this.levelLastLoaded, t = e ? e.details : null;\n      t != null &amp;&amp; t.live ? (this.log(\"resetting startPosition for live start\"), this.startPosition = -1, this.setStartPosition(t, t.fragmentStart), this.resetLoadingState()) : this.nextLoadPosition = this.startPosition;\n    }\n  }\n  resetWhenMissingContext(e) {\n    this.log(`Loading context changed while buffering sn ${e.sn} of ${this.playlistLabel()} ${e.level === -1 ? \"&lt;removed&gt;\" : e.level}. This chunk will not be buffered.`), this.removeUnbufferedFrags(), this.resetStartWhenNotLoaded(), this.resetLoadingState();\n  }\n  removeUnbufferedFrags(e = 0) {\n    this.fragmentTracker.removeFragmentsInRange(e, 1 / 0, this.playlistType, !1, !0);\n  }\n  updateLevelTiming(e, t, r, n) {\n    const i = r.details;\n    if (!i) {\n      this.warn(\"level.details undefined\");\n      return;\n    }\n    if (!Object.keys(e.elementaryStreams).reduce((l, c) =&gt; {\n      const u = e.elementaryStreams[c];\n      if (u) {\n        const d = u.endPTS - u.startPTS;\n        if (d &lt;= 0)\n          return this.warn(`Could not parse fragment ${e.sn} ${c} duration reliably (${d})`), l || !1;\n        const h = n ? 0 : Xg(i, e, u.startPTS, u.endPTS, u.startDTS, u.endDTS, this);\n        return this.hls.trigger(I.LEVEL_PTS_UPDATED, {\n          details: i,\n          level: r,\n          drift: h,\n          type: c,\n          frag: e,\n          start: u.startPTS,\n          end: u.endPTS\n        }), !0;\n      }\n      return l;\n    }, !1)) {\n      var a;\n      if (r.fragmentError === 0 &amp;&amp; this.treatAsGap(e, r), ((a = this.transmuxer) == null ? void 0 : a.error) === null) {\n        const l = new Error(`Found no media in fragment ${e.sn} of ${this.playlistLabel()} ${e.level} resetting transmuxer to fallback to playlist timing`);\n        if (this.warn(l.message), this.hls.trigger(I.ERROR, {\n          type: ve.MEDIA_ERROR,\n          details: J.FRAG_PARSING_ERROR,\n          fatal: !1,\n          error: l,\n          frag: e,\n          reason: `Found no media in msn ${e.sn} of ${this.playlistLabel()} \"${r.url}\"`\n        }), !this.hls)\n          return;\n        this.resetTransmuxer();\n      }\n    }\n    this.state = ne.PARSED, this.log(`Parsed ${e.type} sn: ${e.sn}${t ? \" part: \" + t.index : \"\"} of ${this.fragInfo(e, !1, t)})`), this.hls.trigger(I.FRAG_PARSED, {\n      frag: e,\n      part: t\n    });\n  }\n  playlistLabel() {\n    return this.playlistType === pe.MAIN ? \"level\" : \"track\";\n  }\n  fragInfo(e, t = !0, r) {\n    var n, i;\n    return `${this.playlistLabel()} ${e.level} (${r ? \"part\" : \"frag\"}:[${((n = t &amp;&amp; !r ? e.startPTS : (r || e).start) != null ? n : NaN).toFixed(3)}-${((i = t &amp;&amp; !r ? e.endPTS : (r || e).end) != null ? i : NaN).toFixed(3)}]${r &amp;&amp; e.type === \"main\" ? \"INDEPENDENT=\" + (r.independent ? \"YES\" : \"NO\") : \"\"}`;\n  }\n  treatAsGap(e, t) {\n    t &amp;&amp; t.fragmentError++, e.gap = !0, this.fragmentTracker.removeFragment(e), this.fragmentTracker.fragBuffered(e, !0);\n  }\n  resetTransmuxer() {\n    var e;\n    (e = this.transmuxer) == null || e.reset();\n  }\n  recoverWorkerError(e) {\n    e.event === \"demuxerWorker\" &amp;&amp; (this.fragmentTracker.removeAllFragments(), this.transmuxer &amp;&amp; (this.transmuxer.destroy(), this.transmuxer = null), this.resetStartWhenNotLoaded(), this.resetLoadingState());\n  }\n  set state(e) {\n    const t = this._state;\n    t !== e &amp;&amp; (this._state = e, this.log(`${t}-&gt;${e}`));\n  }\n  get state() {\n    return this._state;\n  }\n}\nfunction Bh(s) {\n  return !!s.interstitialsController &amp;&amp; s.enableInterstitialPlayback !== !1;\n}\nclass ip {\n  constructor() {\n    this.chunks = [], this.dataLength = 0;\n  }\n  push(e) {\n    this.chunks.push(e), this.dataLength += e.length;\n  }\n  flush() {\n    const {\n      chunks: e,\n      dataLength: t\n    } = this;\n    let r;\n    if (e.length)\n      e.length === 1 ? r = e[0] : r = nT(e, t);\n    else return new Uint8Array(0);\n    return this.reset(), r;\n  }\n  reset() {\n    this.chunks.length = 0, this.dataLength = 0;\n  }\n}\nfunction nT(s, e) {\n  const t = new Uint8Array(e);\n  let r = 0;\n  for (let n = 0; n &lt; s.length; n++) {\n    const i = s[n];\n    t.set(i, r), r += i.length;\n  }\n  return t;\n}\nvar ml = { exports: {} }, Fh;\nfunction iT() {\n  return Fh || (Fh = 1, (function(s) {\n    var e = Object.prototype.hasOwnProperty, t = \"~\";\n    function r() {\n    }\n    Object.create &amp;&amp; (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (t = !1));\n    function n(l, c, u) {\n      this.fn = l, this.context = c, this.once = u || !1;\n    }\n    function i(l, c, u, d, h) {\n      if (typeof u != \"function\")\n        throw new TypeError(\"The listener must be a function\");\n      var f = new n(u, d || l, h), p = t ? t + c : c;\n      return l._events[p] ? l._events[p].fn ? l._events[p] = [l._events[p], f] : l._events[p].push(f) : (l._events[p] = f, l._eventsCount++), l;\n    }\n    function o(l, c) {\n      --l._eventsCount === 0 ? l._events = new r() : delete l._events[c];\n    }\n    function a() {\n      this._events = new r(), this._eventsCount = 0;\n    }\n    a.prototype.eventNames = function() {\n      var c = [], u, d;\n      if (this._eventsCount === 0) return c;\n      for (d in u = this._events)\n        e.call(u, d) &amp;&amp; c.push(t ? d.slice(1) : d);\n      return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(u)) : c;\n    }, a.prototype.listeners = function(c) {\n      var u = t ? t + c : c, d = this._events[u];\n      if (!d) return [];\n      if (d.fn) return [d.fn];\n      for (var h = 0, f = d.length, p = new Array(f); h &lt; f; h++)\n        p[h] = d[h].fn;\n      return p;\n    }, a.prototype.listenerCount = function(c) {\n      var u = t ? t + c : c, d = this._events[u];\n      return d ? d.fn ? 1 : d.length : 0;\n    }, a.prototype.emit = function(c, u, d, h, f, p) {\n      var y = t ? t + c : c;\n      if (!this._events[y]) return !1;\n      var E = this._events[y], b = arguments.length, R, A;\n      if (E.fn) {\n        switch (E.once &amp;&amp; this.removeListener(c, E.fn, void 0, !0), b) {\n          case 1:\n            return E.fn.call(E.context), !0;\n          case 2:\n            return E.fn.call(E.context, u), !0;\n          case 3:\n            return E.fn.call(E.context, u, d), !0;\n          case 4:\n            return E.fn.call(E.context, u, d, h), !0;\n          case 5:\n            return E.fn.call(E.context, u, d, h, f), !0;\n          case 6:\n            return E.fn.call(E.context, u, d, h, f, p), !0;\n        }\n        for (A = 1, R = new Array(b - 1); A &lt; b; A++)\n          R[A - 1] = arguments[A];\n        E.fn.apply(E.context, R);\n      } else {\n        var F = E.length, M;\n        for (A = 0; A &lt; F; A++)\n          switch (E[A].once &amp;&amp; this.removeListener(c, E[A].fn, void 0, !0), b) {\n            case 1:\n              E[A].fn.call(E[A].context);\n              break;\n            case 2:\n              E[A].fn.call(E[A].context, u);\n              break;\n            case 3:\n              E[A].fn.call(E[A].context, u, d);\n              break;\n            case 4:\n              E[A].fn.call(E[A].context, u, d, h);\n              break;\n            default:\n              if (!R) for (M = 1, R = new Array(b - 1); M &lt; b; M++)\n                R[M - 1] = arguments[M];\n              E[A].fn.apply(E[A].context, R);\n          }\n      }\n      return !0;\n    }, a.prototype.on = function(c, u, d) {\n      return i(this, c, u, d, !1);\n    }, a.prototype.once = function(c, u, d) {\n      return i(this, c, u, d, !0);\n    }, a.prototype.removeListener = function(c, u, d, h) {\n      var f = t ? t + c : c;\n      if (!this._events[f]) return this;\n      if (!u)\n        return o(this, f), this;\n      var p = this._events[f];\n      if (p.fn)\n        p.fn === u &amp;&amp; (!h || p.once) &amp;&amp; (!d || p.context === d) &amp;&amp; o(this, f);\n      else {\n        for (var y = 0, E = [], b = p.length; y &lt; b; y++)\n          (p[y].fn !== u || h &amp;&amp; !p[y].once || d &amp;&amp; p[y].context !== d) &amp;&amp; E.push(p[y]);\n        E.length ? this._events[f] = E.length === 1 ? E[0] : E : o(this, f);\n      }\n      return this;\n    }, a.prototype.removeAllListeners = function(c) {\n      var u;\n      return c ? (u = t ? t + c : c, this._events[u] &amp;&amp; o(this, u)) : (this._events = new r(), this._eventsCount = 0), this;\n    }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = t, a.EventEmitter = a, s.exports = a;\n  })(ml)), ml.exports;\n}\nvar oT = iT(), wu = /* @__PURE__ */ kS(oT);\nconst vi = \"1.6.12\", Nn = {};\nfunction aT() {\n  return typeof __HLS_WORKER_BUNDLE__ == \"function\";\n}\nfunction lT() {\n  const s = Nn[vi];\n  if (s)\n    return s.clientCount++, s;\n  const e = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {\n    type: \"text/javascript\"\n  }), t = self.URL.createObjectURL(e), n = {\n    worker: new self.Worker(t),\n    objectURL: t,\n    clientCount: 1\n  };\n  return Nn[vi] = n, n;\n}\nfunction cT(s) {\n  const e = Nn[s];\n  if (e)\n    return e.clientCount++, e;\n  const t = new self.URL(s, self.location.href).href, n = {\n    worker: new self.Worker(t),\n    scriptURL: t,\n    clientCount: 1\n  };\n  return Nn[s] = n, n;\n}\nfunction uT(s) {\n  const e = Nn[s || vi];\n  if (e &amp;&amp; e.clientCount-- === 1) {\n    const {\n      worker: r,\n      objectURL: n\n    } = e;\n    delete Nn[s || vi], n &amp;&amp; self.URL.revokeObjectURL(n), r.terminate();\n  }\n}\nfunction op(s, e) {\n  return e + 10 &lt;= s.length &amp;&amp; s[e] === 51 &amp;&amp; s[e + 1] === 68 &amp;&amp; s[e + 2] === 73 &amp;&amp; s[e + 3] &lt; 255 &amp;&amp; s[e + 4] &lt; 255 &amp;&amp; s[e + 6] &lt; 128 &amp;&amp; s[e + 7] &lt; 128 &amp;&amp; s[e + 8] &lt; 128 &amp;&amp; s[e + 9] &lt; 128;\n}\nfunction Au(s, e) {\n  return e + 10 &lt;= s.length &amp;&amp; s[e] === 73 &amp;&amp; s[e + 1] === 68 &amp;&amp; s[e + 2] === 51 &amp;&amp; s[e + 3] &lt; 255 &amp;&amp; s[e + 4] &lt; 255 &amp;&amp; s[e + 6] &lt; 128 &amp;&amp; s[e + 7] &lt; 128 &amp;&amp; s[e + 8] &lt; 128 &amp;&amp; s[e + 9] &lt; 128;\n}\nfunction va(s, e) {\n  let t = 0;\n  return t = (s[e] &amp; 127) &lt;&lt; 21, t |= (s[e + 1] &amp; 127) &lt;&lt; 14, t |= (s[e + 2] &amp; 127) &lt;&lt; 7, t |= s[e + 3] &amp; 127, t;\n}\nfunction Ei(s, e) {\n  const t = e;\n  let r = 0;\n  for (; Au(s, e); ) {\n    r += 10;\n    const n = va(s, e + 6);\n    r += n, op(s, e + 10) &amp;&amp; (r += 10), e += r;\n  }\n  if (r &gt; 0)\n    return s.subarray(t, t + r);\n}\nfunction dT(s, e, t, r) {\n  const n = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350], i = e[t + 2], o = i &gt;&gt; 2 &amp; 15;\n  if (o &gt; 12) {\n    const f = new Error(`invalid ADTS sampling index:${o}`);\n    s.emit(I.ERROR, I.ERROR, {\n      type: ve.MEDIA_ERROR,\n      details: J.FRAG_PARSING_ERROR,\n      fatal: !0,\n      error: f,\n      reason: f.message\n    });\n    return;\n  }\n  const a = (i &gt;&gt; 6 &amp; 3) + 1, l = e[t + 3] &gt;&gt; 6 &amp; 3 | (i &amp; 1) &lt;&lt; 2, c = \"mp4a.40.\" + a, u = n[o];\n  let d = o;\n  (a === 5 || a === 29) &amp;&amp; (d -= 3);\n  const h = [a &lt;&lt; 3 | (d &amp; 14) &gt;&gt; 1, (d &amp; 1) &lt;&lt; 7 | l &lt;&lt; 3];\n  return rt.log(`manifest codec:${r}, parsed codec:${c}, channels:${l}, rate:${u} (ADTS object type:${a} sampling index:${o})`), {\n    config: h,\n    samplerate: u,\n    channelCount: l,\n    codec: c,\n    parsedCodec: c,\n    manifestCodec: r\n  };\n}\nfunction ap(s, e) {\n  return s[e] === 255 &amp;&amp; (s[e + 1] &amp; 246) === 240;\n}\nfunction lp(s, e) {\n  return s[e + 1] &amp; 1 ? 7 : 9;\n}\nfunction Iu(s, e) {\n  return (s[e + 3] &amp; 3) &lt;&lt; 11 | s[e + 4] &lt;&lt; 3 | (s[e + 5] &amp; 224) &gt;&gt;&gt; 5;\n}\nfunction hT(s, e) {\n  return e + 5 &lt; s.length;\n}\nfunction na(s, e) {\n  return e + 1 &lt; s.length &amp;&amp; ap(s, e);\n}\nfunction fT(s, e) {\n  return hT(s, e) &amp;&amp; ap(s, e) &amp;&amp; Iu(s, e) &lt;= s.length - e;\n}\nfunction gT(s, e) {\n  if (na(s, e)) {\n    const t = lp(s, e);\n    if (e + t &gt;= s.length)\n      return !1;\n    const r = Iu(s, e);\n    if (r &lt;= t)\n      return !1;\n    const n = e + r;\n    return n === s.length || na(s, n);\n  }\n  return !1;\n}\nfunction cp(s, e, t, r, n) {\n  if (!s.samplerate) {\n    const i = dT(e, t, r, n);\n    if (!i)\n      return;\n    nt(s, i);\n  }\n}\nfunction up(s) {\n  return 1024 * 9e4 / s;\n}\nfunction pT(s, e) {\n  const t = lp(s, e);\n  if (e + t &lt;= s.length) {\n    const r = Iu(s, e) - t;\n    if (r &gt; 0)\n      return {\n        headerLength: t,\n        frameLength: r\n      };\n  }\n}\nfunction dp(s, e, t, r, n) {\n  const i = up(s.samplerate), o = r + n * i, a = pT(e, t);\n  let l;\n  if (a) {\n    const {\n      frameLength: d,\n      headerLength: h\n    } = a, f = h + d, p = Math.max(0, t + f - e.length);\n    p ? (l = new Uint8Array(f - h), l.set(e.subarray(t + h, e.length), 0)) : l = e.subarray(t + h, t + f);\n    const y = {\n      unit: l,\n      pts: o\n    };\n    return p || s.samples.push(y), {\n      sample: y,\n      length: f,\n      missing: p\n    };\n  }\n  const c = e.length - t;\n  return l = new Uint8Array(c), l.set(e.subarray(t, e.length), 0), {\n    sample: {\n      unit: l,\n      pts: o\n    },\n    length: c,\n    missing: -1\n  };\n}\nfunction mT(s, e) {\n  return Au(s, e) &amp;&amp; va(s, e + 6) + 10 &lt;= s.length - e;\n}\nfunction yT(s) {\n  return s instanceof ArrayBuffer ? s : s.byteOffset == 0 &amp;&amp; s.byteLength == s.buffer.byteLength ? s.buffer : new Uint8Array(s).buffer;\n}\nfunction yl(s, e = 0, t = 1 / 0) {\n  return vT(s, e, t, Uint8Array);\n}\nfunction vT(s, e, t, r) {\n  const n = ET(s);\n  let i = 1;\n  \"BYTES_PER_ELEMENT\" in r &amp;&amp; (i = r.BYTES_PER_ELEMENT);\n  const o = xT(s) ? s.byteOffset : 0, a = (o + s.byteLength) / i, l = (o + e) / i, c = Math.floor(Math.max(0, Math.min(l, a))), u = Math.floor(Math.min(c + Math.max(t, 0), a));\n  return new r(n, c, u - c);\n}\nfunction ET(s) {\n  return s instanceof ArrayBuffer ? s : s.buffer;\n}\nfunction xT(s) {\n  return s &amp;&amp; s.buffer instanceof ArrayBuffer &amp;&amp; s.byteLength !== void 0 &amp;&amp; s.byteOffset !== void 0;\n}\nfunction ST(s) {\n  const e = {\n    key: s.type,\n    description: \"\",\n    data: \"\",\n    mimeType: null,\n    pictureType: null\n  }, t = 3;\n  if (s.size &lt; 2)\n    return;\n  if (s.data[0] !== t) {\n    console.log(\"Ignore frame with unrecognized character encoding\");\n    return;\n  }\n  const r = s.data.subarray(1).indexOf(0);\n  if (r === -1)\n    return;\n  const n = Tr(yl(s.data, 1, r)), i = s.data[2 + r], o = s.data.subarray(3 + r).indexOf(0);\n  if (o === -1)\n    return;\n  const a = Tr(yl(s.data, 3 + r, o));\n  let l;\n  return n === \"--&gt;\" ? l = Tr(yl(s.data, 4 + r + o)) : l = yT(s.data.subarray(4 + r + o)), e.mimeType = n, e.pictureType = i, e.description = a, e.data = l, e;\n}\nfunction bT(s) {\n  if (s.size &lt; 2)\n    return;\n  const e = Tr(s.data, !0), t = new Uint8Array(s.data.subarray(e.length + 1));\n  return {\n    key: s.type,\n    info: e,\n    data: t.buffer\n  };\n}\nfunction TT(s) {\n  if (s.size &lt; 2)\n    return;\n  if (s.type === \"TXXX\") {\n    let t = 1;\n    const r = Tr(s.data.subarray(t), !0);\n    t += r.length + 1;\n    const n = Tr(s.data.subarray(t));\n    return {\n      key: s.type,\n      info: r,\n      data: n\n    };\n  }\n  const e = Tr(s.data.subarray(1));\n  return {\n    key: s.type,\n    info: \"\",\n    data: e\n  };\n}\nfunction wT(s) {\n  if (s.type === \"WXXX\") {\n    if (s.size &lt; 2)\n      return;\n    let t = 1;\n    const r = Tr(s.data.subarray(t), !0);\n    t += r.length + 1;\n    const n = Tr(s.data.subarray(t));\n    return {\n      key: s.type,\n      info: r,\n      data: n\n    };\n  }\n  const e = Tr(s.data);\n  return {\n    key: s.type,\n    info: \"\",\n    data: e\n  };\n}\nfunction AT(s) {\n  return s.type === \"PRIV\" ? bT(s) : s.type[0] === \"W\" ? wT(s) : s.type === \"APIC\" ? ST(s) : TT(s);\n}\nfunction IT(s) {\n  const e = String.fromCharCode(s[0], s[1], s[2], s[3]), t = va(s, 4), r = 10;\n  return {\n    type: e,\n    size: t,\n    data: s.subarray(r, r + t)\n  };\n}\nconst zi = 10, _T = 10;\nfunction hp(s) {\n  let e = 0;\n  const t = [];\n  for (; Au(s, e); ) {\n    const r = va(s, e + 6);\n    s[e + 5] &gt;&gt; 6 &amp; 1 &amp;&amp; (e += zi), e += zi;\n    const n = e + r;\n    for (; e + _T &lt; n; ) {\n      const i = IT(s.subarray(e)), o = AT(i);\n      o &amp;&amp; t.push(o), e += i.size + zi;\n    }\n    op(s, e) &amp;&amp; (e += zi);\n  }\n  return t;\n}\nfunction fp(s) {\n  return s &amp;&amp; s.key === \"PRIV\" &amp;&amp; s.info === \"com.apple.streaming.transportStreamTimestamp\";\n}\nfunction RT(s) {\n  if (s.data.byteLength === 8) {\n    const e = new Uint8Array(s.data), t = e[3] &amp; 1;\n    let r = (e[4] &lt;&lt; 23) + (e[5] &lt;&lt; 15) + (e[6] &lt;&lt; 7) + e[7];\n    return r /= 45, t &amp;&amp; (r += 4772185884e-2), Math.round(r);\n  }\n}\nfunction _u(s) {\n  const e = hp(s);\n  for (let t = 0; t &lt; e.length; t++) {\n    const r = e[t];\n    if (fp(r))\n      return RT(r);\n  }\n}\nlet br = /* @__PURE__ */ (function(s) {\n  return s.audioId3 = \"org.id3\", s.dateRange = \"com.apple.quicktime.HLS\", s.emsg = \"https://aomedia.org/emsg/ID3\", s.misbklv = \"urn:misb:KLV:bin:1910.1\", s;\n})({});\nfunction jr(s = \"\", e = 9e4) {\n  return {\n    type: s,\n    id: -1,\n    pid: -1,\n    inputTimeScale: e,\n    sequenceNumber: -1,\n    samples: [],\n    dropped: 0\n  };\n}\nclass Ru {\n  constructor() {\n    this._audioTrack = void 0, this._id3Track = void 0, this.frameIndex = 0, this.cachedData = null, this.basePTS = null, this.initPTS = null, this.lastPTS = null;\n  }\n  resetInitSegment(e, t, r, n) {\n    this._id3Track = {\n      type: \"id3\",\n      id: 3,\n      pid: -1,\n      inputTimeScale: 9e4,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0\n    };\n  }\n  resetTimeStamp(e) {\n    this.initPTS = e, this.resetContiguity();\n  }\n  resetContiguity() {\n    this.basePTS = null, this.lastPTS = null, this.frameIndex = 0;\n  }\n  canParse(e, t) {\n    return !1;\n  }\n  appendFrame(e, t, r) {\n  }\n  // feed incoming data to the front of the parsing pipeline\n  demux(e, t) {\n    this.cachedData &amp;&amp; (e = _r(this.cachedData, e), this.cachedData = null);\n    let r = Ei(e, 0), n = r ? r.length : 0, i;\n    const o = this._audioTrack, a = this._id3Track, l = r ? _u(r) : void 0, c = e.length;\n    for ((this.basePTS === null || this.frameIndex === 0 &amp;&amp; ue(l)) &amp;&amp; (this.basePTS = LT(l, t, this.initPTS), this.lastPTS = this.basePTS), this.lastPTS === null &amp;&amp; (this.lastPTS = this.basePTS), r &amp;&amp; r.length &gt; 0 &amp;&amp; a.samples.push({\n      pts: this.lastPTS,\n      dts: this.lastPTS,\n      data: r,\n      type: br.audioId3,\n      duration: Number.POSITIVE_INFINITY\n    }); n &lt; c; ) {\n      if (this.canParse(e, n)) {\n        const u = this.appendFrame(o, e, n);\n        u ? (this.frameIndex++, this.lastPTS = u.sample.pts, n += u.length, i = n) : n = c;\n      } else mT(e, n) ? (r = Ei(e, n), a.samples.push({\n        pts: this.lastPTS,\n        dts: this.lastPTS,\n        data: r,\n        type: br.audioId3,\n        duration: Number.POSITIVE_INFINITY\n      }), n += r.length, i = n) : n++;\n      if (n === c &amp;&amp; i !== c) {\n        const u = e.slice(i);\n        this.cachedData ? this.cachedData = _r(this.cachedData, u) : this.cachedData = u;\n      }\n    }\n    return {\n      audioTrack: o,\n      videoTrack: jr(),\n      id3Track: a,\n      textTrack: jr()\n    };\n  }\n  demuxSampleAes(e, t, r) {\n    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));\n  }\n  flush(e) {\n    const t = this.cachedData;\n    return t &amp;&amp; (this.cachedData = null, this.demux(t, 0)), {\n      audioTrack: this._audioTrack,\n      videoTrack: jr(),\n      id3Track: this._id3Track,\n      textTrack: jr()\n    };\n  }\n  destroy() {\n    this.cachedData = null, this._audioTrack = this._id3Track = void 0;\n  }\n}\nconst LT = (s, e, t) =&gt; {\n  if (ue(s))\n    return s * 90;\n  const r = t ? t.baseTime * 9e4 / t.timescale : 0;\n  return e * 9e4 + r;\n};\nlet Yi = null;\nconst CT = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160], kT = [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3], DT = [\n  // MPEG 2.5\n  [\n    0,\n    // Reserved\n    72,\n    // Layer3\n    144,\n    // Layer2\n    12\n    // Layer1\n  ],\n  // Reserved\n  [\n    0,\n    // Reserved\n    0,\n    // Layer3\n    0,\n    // Layer2\n    0\n    // Layer1\n  ],\n  // MPEG 2\n  [\n    0,\n    // Reserved\n    72,\n    // Layer3\n    144,\n    // Layer2\n    12\n    // Layer1\n  ],\n  // MPEG 1\n  [\n    0,\n    // Reserved\n    144,\n    // Layer3\n    144,\n    // Layer2\n    12\n    // Layer1\n  ]\n], PT = [\n  0,\n  // Reserved\n  1,\n  // Layer3\n  1,\n  // Layer2\n  4\n  // Layer1\n];\nfunction gp(s, e, t, r, n) {\n  if (t + 24 &gt; e.length)\n    return;\n  const i = pp(e, t);\n  if (i &amp;&amp; t + i.frameLength &lt;= e.length) {\n    const o = i.samplesPerFrame * 9e4 / i.sampleRate, a = r + n * o, l = {\n      unit: e.subarray(t, t + i.frameLength),\n      pts: a,\n      dts: a\n    };\n    return s.config = [], s.channelCount = i.channelCount, s.samplerate = i.sampleRate, s.samples.push(l), {\n      sample: l,\n      length: i.frameLength,\n      missing: 0\n    };\n  }\n}\nfunction pp(s, e) {\n  const t = s[e + 1] &gt;&gt; 3 &amp; 3, r = s[e + 1] &gt;&gt; 1 &amp; 3, n = s[e + 2] &gt;&gt; 4 &amp; 15, i = s[e + 2] &gt;&gt; 2 &amp; 3;\n  if (t !== 1 &amp;&amp; n !== 0 &amp;&amp; n !== 15 &amp;&amp; i !== 3) {\n    const o = s[e + 2] &gt;&gt; 1 &amp; 1, a = s[e + 3] &gt;&gt; 6, l = t === 3 ? 3 - r : r === 3 ? 3 : 4, c = CT[l * 14 + n - 1] * 1e3, d = kT[(t === 3 ? 0 : t === 2 ? 1 : 2) * 3 + i], h = a === 3 ? 1 : 2, f = DT[t][r], p = PT[r], y = f * 8 * p, E = Math.floor(f * c / d + o) * p;\n    if (Yi === null) {\n      const A = (navigator.userAgent || \"\").match(/Chrome\\/(\\d+)/i);\n      Yi = A ? parseInt(A[1]) : 0;\n    }\n    return !!Yi &amp;&amp; Yi &lt;= 87 &amp;&amp; r === 2 &amp;&amp; c &gt;= 224e3 &amp;&amp; a === 0 &amp;&amp; (s[e + 3] = s[e + 3] | 128), {\n      sampleRate: d,\n      channelCount: h,\n      frameLength: E,\n      samplesPerFrame: y\n    };\n  }\n}\nfunction Lu(s, e) {\n  return s[e] === 255 &amp;&amp; (s[e + 1] &amp; 224) === 224 &amp;&amp; (s[e + 1] &amp; 6) !== 0;\n}\nfunction mp(s, e) {\n  return e + 1 &lt; s.length &amp;&amp; Lu(s, e);\n}\nfunction MT(s, e) {\n  return Lu(s, e) &amp;&amp; 4 &lt;= s.length - e;\n}\nfunction yp(s, e) {\n  if (e + 1 &lt; s.length &amp;&amp; Lu(s, e)) {\n    const r = pp(s, e);\n    let n = 4;\n    r != null &amp;&amp; r.frameLength &amp;&amp; (n = r.frameLength);\n    const i = e + n;\n    return i === s.length || mp(s, i);\n  }\n  return !1;\n}\nclass OT extends Ru {\n  constructor(e, t) {\n    super(), this.observer = void 0, this.config = void 0, this.observer = e, this.config = t;\n  }\n  resetInitSegment(e, t, r, n) {\n    super.resetInitSegment(e, t, r, n), this._audioTrack = {\n      container: \"audio/adts\",\n      type: \"audio\",\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: \"aac\",\n      samples: [],\n      manifestCodec: t,\n      duration: n,\n      inputTimeScale: 9e4,\n      dropped: 0\n    };\n  }\n  // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\n  static probe(e, t) {\n    if (!e)\n      return !1;\n    const r = Ei(e, 0);\n    let n = (r == null ? void 0 : r.length) || 0;\n    if (yp(e, n))\n      return !1;\n    for (let i = e.length; n &lt; i; n++)\n      if (gT(e, n))\n        return t.log(\"ADTS sync word found !\"), !0;\n    return !1;\n  }\n  canParse(e, t) {\n    return fT(e, t);\n  }\n  appendFrame(e, t, r) {\n    cp(e, this.observer, t, r, e.manifestCodec);\n    const n = dp(e, t, r, this.basePTS, this.frameIndex);\n    if (n &amp;&amp; n.missing === 0)\n      return n;\n  }\n}\nconst vp = (s, e) =&gt; {\n  let t = 0, r = 5;\n  e += r;\n  const n = new Uint32Array(1), i = new Uint32Array(1), o = new Uint8Array(1);\n  for (; r &gt; 0; ) {\n    o[0] = s[e];\n    const a = Math.min(r, 8), l = 8 - a;\n    i[0] = 4278190080 &gt;&gt;&gt; 24 + l &lt;&lt; l, n[0] = (o[0] &amp; i[0]) &gt;&gt; l, t = t ? t &lt;&lt; a | n[0] : n[0], e += 1, r -= a;\n  }\n  return t;\n};\nclass BT extends Ru {\n  constructor(e) {\n    super(), this.observer = void 0, this.observer = e;\n  }\n  resetInitSegment(e, t, r, n) {\n    super.resetInitSegment(e, t, r, n), this._audioTrack = {\n      container: \"audio/ac-3\",\n      type: \"audio\",\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: \"ac3\",\n      samples: [],\n      manifestCodec: t,\n      duration: n,\n      inputTimeScale: 9e4,\n      dropped: 0\n    };\n  }\n  canParse(e, t) {\n    return t + 64 &lt; e.length;\n  }\n  appendFrame(e, t, r) {\n    const n = Ep(e, t, r, this.basePTS, this.frameIndex);\n    if (n !== -1)\n      return {\n        sample: e.samples[e.samples.length - 1],\n        length: n,\n        missing: 0\n      };\n  }\n  static probe(e) {\n    if (!e)\n      return !1;\n    const t = Ei(e, 0);\n    if (!t)\n      return !1;\n    const r = t.length;\n    return e[r] === 11 &amp;&amp; e[r + 1] === 119 &amp;&amp; _u(t) !== void 0 &amp;&amp; // check the bsid to confirm ac-3\n    vp(e, r) &lt; 16;\n  }\n}\nfunction Ep(s, e, t, r, n) {\n  if (t + 8 &gt; e.length || e[t] !== 11 || e[t + 1] !== 119)\n    return -1;\n  const i = e[t + 4] &gt;&gt; 6;\n  if (i &gt;= 3)\n    return -1;\n  const a = [48e3, 44100, 32e3][i], l = e[t + 4] &amp; 63, u = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920][l * 3 + i] * 2;\n  if (t + u &gt; e.length)\n    return -1;\n  const d = e[t + 6] &gt;&gt; 5;\n  let h = 0;\n  d === 2 ? h += 2 : (d &amp; 1 &amp;&amp; d !== 1 &amp;&amp; (h += 2), d &amp; 4 &amp;&amp; (h += 2));\n  const f = (e[t + 6] &lt;&lt; 8 | e[t + 7]) &gt;&gt; 12 - h &amp; 1, y = [2, 1, 2, 3, 3, 4, 4, 5][d] + f, E = e[t + 5] &gt;&gt; 3, b = e[t + 5] &amp; 7, R = new Uint8Array([i &lt;&lt; 6 | E &lt;&lt; 1 | b &gt;&gt; 2, (b &amp; 3) &lt;&lt; 6 | d &lt;&lt; 3 | f &lt;&lt; 2 | l &gt;&gt; 4, l &lt;&lt; 4 &amp; 224]), A = 1536 / a * 9e4, F = r + n * A, M = e.subarray(t, t + u);\n  return s.config = R, s.channelCount = y, s.samplerate = a, s.samples.push({\n    unit: M,\n    pts: F\n  }), u;\n}\nclass FT extends Ru {\n  resetInitSegment(e, t, r, n) {\n    super.resetInitSegment(e, t, r, n), this._audioTrack = {\n      container: \"audio/mpeg\",\n      type: \"audio\",\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: \"mp3\",\n      samples: [],\n      manifestCodec: t,\n      duration: n,\n      inputTimeScale: 9e4,\n      dropped: 0\n    };\n  }\n  static probe(e) {\n    if (!e)\n      return !1;\n    const t = Ei(e, 0);\n    let r = (t == null ? void 0 : t.length) || 0;\n    if (t &amp;&amp; e[r] === 11 &amp;&amp; e[r + 1] === 119 &amp;&amp; _u(t) !== void 0 &amp;&amp; // check the bsid to confirm ac-3 or ec-3 (not mp3)\n    vp(e, r) &lt;= 16)\n      return !1;\n    for (let n = e.length; r &lt; n; r++)\n      if (yp(e, r))\n        return rt.log(\"MPEG Audio sync word found !\"), !0;\n    return !1;\n  }\n  canParse(e, t) {\n    return MT(e, t);\n  }\n  appendFrame(e, t, r) {\n    if (this.basePTS !== null)\n      return gp(e, t, r, this.basePTS, this.frameIndex);\n  }\n}\nconst NT = /\\/emsg[-/]ID3/i;\nclass UT {\n  constructor(e, t) {\n    this.remainderData = null, this.timeOffset = 0, this.config = void 0, this.videoTrack = void 0, this.audioTrack = void 0, this.id3Track = void 0, this.txtTrack = void 0, this.config = t;\n  }\n  resetTimeStamp() {\n  }\n  resetInitSegment(e, t, r, n) {\n    const i = this.videoTrack = jr(\"video\", 1), o = this.audioTrack = jr(\"audio\", 1), a = this.txtTrack = jr(\"text\", 1);\n    if (this.id3Track = jr(\"id3\", 1), this.timeOffset = 0, !(e != null &amp;&amp; e.byteLength))\n      return;\n    const l = Dg(e);\n    if (l.video) {\n      const {\n        id: c,\n        timescale: u,\n        codec: d,\n        supplemental: h\n      } = l.video;\n      i.id = c, i.timescale = a.timescale = u, i.codec = d, i.supplemental = h;\n    }\n    if (l.audio) {\n      const {\n        id: c,\n        timescale: u,\n        codec: d\n      } = l.audio;\n      o.id = c, o.timescale = u, o.codec = d;\n    }\n    a.id = Lg.text, i.sampleDuration = 0, i.duration = o.duration = n;\n  }\n  resetContiguity() {\n    this.remainderData = null;\n  }\n  static probe(e) {\n    return BS(e);\n  }\n  demux(e, t) {\n    this.timeOffset = t;\n    let r = e;\n    const n = this.videoTrack, i = this.txtTrack;\n    if (this.config.progressive) {\n      this.remainderData &amp;&amp; (r = _r(this.remainderData, e));\n      const a = VS(r);\n      this.remainderData = a.remainder, n.samples = a.valid || new Uint8Array();\n    } else\n      n.samples = r;\n    const o = this.extractID3Track(n, t);\n    return i.samples = rh(t, n), {\n      videoTrack: n,\n      audioTrack: this.audioTrack,\n      id3Track: o,\n      textTrack: this.txtTrack\n    };\n  }\n  flush() {\n    const e = this.timeOffset, t = this.videoTrack, r = this.txtTrack;\n    t.samples = this.remainderData || new Uint8Array(), this.remainderData = null;\n    const n = this.extractID3Track(t, this.timeOffset);\n    return r.samples = rh(e, t), {\n      videoTrack: t,\n      audioTrack: jr(),\n      id3Track: n,\n      textTrack: jr()\n    };\n  }\n  extractID3Track(e, t) {\n    const r = this.id3Track;\n    if (e.samples.length) {\n      const n = Ge(e.samples, [\"emsg\"]);\n      n &amp;&amp; n.forEach((i) =&gt; {\n        const o = KS(i);\n        if (NT.test(o.schemeIdUri)) {\n          const a = Nh(o, t);\n          let l = o.eventDuration === 4294967295 ? Number.POSITIVE_INFINITY : o.eventDuration / o.timeScale;\n          l &lt;= 1e-3 &amp;&amp; (l = Number.POSITIVE_INFINITY);\n          const c = o.payload;\n          r.samples.push({\n            data: c,\n            len: c.byteLength,\n            dts: a,\n            pts: a,\n            type: br.emsg,\n            duration: l\n          });\n        } else if (this.config.enableEmsgKLVMetadata &amp;&amp; o.schemeIdUri.startsWith(\"urn:misb:KLV:bin:1910.1\")) {\n          const a = Nh(o, t);\n          r.samples.push({\n            data: o.payload,\n            len: o.payload.byteLength,\n            dts: a,\n            pts: a,\n            type: br.misbklv,\n            duration: Number.POSITIVE_INFINITY\n          });\n        }\n      });\n    }\n    return r;\n  }\n  demuxSampleAes(e, t, r) {\n    return Promise.reject(new Error(\"The MP4 demuxer does not support SAMPLE-AES decryption\"));\n  }\n  destroy() {\n    this.config = null, this.remainderData = null, this.videoTrack = this.audioTrack = this.id3Track = this.txtTrack = void 0;\n  }\n}\nfunction Nh(s, e) {\n  return ue(s.presentationTime) ? s.presentationTime / s.timeScale : e + s.presentationTimeDelta / s.timeScale;\n}\nclass $T {\n  constructor(e, t, r) {\n    this.keyData = void 0, this.decrypter = void 0, this.keyData = r, this.decrypter = new vu(t, {\n      removePKCS7Padding: !1\n    });\n  }\n  decryptBuffer(e) {\n    return this.decrypter.decrypt(e, this.keyData.key.buffer, this.keyData.iv.buffer, Os.cbc);\n  }\n  // AAC - encrypt all full 16 bytes blocks starting from offset 16\n  decryptAacSample(e, t, r) {\n    const n = e[t].unit;\n    if (n.length &lt;= 16)\n      return;\n    const i = n.subarray(16, n.length - n.length % 16), o = i.buffer.slice(i.byteOffset, i.byteOffset + i.length);\n    this.decryptBuffer(o).then((a) =&gt; {\n      const l = new Uint8Array(a);\n      n.set(l, 16), this.decrypter.isSync() || this.decryptAacSamples(e, t + 1, r);\n    }).catch(r);\n  }\n  decryptAacSamples(e, t, r) {\n    for (; ; t++) {\n      if (t &gt;= e.length) {\n        r();\n        return;\n      }\n      if (!(e[t].unit.length &lt; 32) &amp;&amp; (this.decryptAacSample(e, t, r), !this.decrypter.isSync()))\n        return;\n    }\n  }\n  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n  getAvcEncryptedData(e) {\n    const t = Math.floor((e.length - 48) / 160) * 16 + 16, r = new Int8Array(t);\n    let n = 0;\n    for (let i = 32; i &lt; e.length - 16; i += 160, n += 16)\n      r.set(e.subarray(i, i + 16), n);\n    return r;\n  }\n  getAvcDecryptedUnit(e, t) {\n    const r = new Uint8Array(t);\n    let n = 0;\n    for (let i = 32; i &lt; e.length - 16; i += 160, n += 16)\n      e.set(r.subarray(n, n + 16), i);\n    return e;\n  }\n  decryptAvcSample(e, t, r, n, i) {\n    const o = Mg(i.data), a = this.getAvcEncryptedData(o);\n    this.decryptBuffer(a.buffer).then((l) =&gt; {\n      i.data = this.getAvcDecryptedUnit(o, l), this.decrypter.isSync() || this.decryptAvcSamples(e, t, r + 1, n);\n    }).catch(n);\n  }\n  decryptAvcSamples(e, t, r, n) {\n    if (e instanceof Uint8Array)\n      throw new Error(\"Cannot decrypt samples of type Uint8Array\");\n    for (; ; t++, r = 0) {\n      if (t &gt;= e.length) {\n        n();\n        return;\n      }\n      const i = e[t].units;\n      for (; !(r &gt;= i.length); r++) {\n        const o = i[r];\n        if (!(o.data.length &lt;= 48 || o.type !== 1 &amp;&amp; o.type !== 5) &amp;&amp; (this.decryptAvcSample(e, t, r, n, o), !this.decrypter.isSync()))\n          return;\n      }\n    }\n  }\n}\nclass xp {\n  constructor() {\n    this.VideoSample = null;\n  }\n  createVideoSample(e, t, r) {\n    return {\n      key: e,\n      frame: !1,\n      pts: t,\n      dts: r,\n      units: [],\n      length: 0\n    };\n  }\n  getLastNalUnit(e) {\n    var t;\n    let r = this.VideoSample, n;\n    if ((!r || r.units.length === 0) &amp;&amp; (r = e[e.length - 1]), (t = r) != null &amp;&amp; t.units) {\n      const i = r.units;\n      n = i[i.length - 1];\n    }\n    return n;\n  }\n  pushAccessUnit(e, t) {\n    if (e.units.length &amp;&amp; e.frame) {\n      if (e.pts === void 0) {\n        const r = t.samples, n = r.length;\n        if (n) {\n          const i = r[n - 1];\n          e.pts = i.pts, e.dts = i.dts;\n        } else {\n          t.dropped++;\n          return;\n        }\n      }\n      t.samples.push(e);\n    }\n  }\n  parseNALu(e, t, r) {\n    const n = t.byteLength;\n    let i = e.naluState || 0;\n    const o = i, a = [];\n    let l = 0, c, u, d, h = -1, f = 0;\n    for (i === -1 &amp;&amp; (h = 0, f = this.getNALuType(t, 0), i = 0, l = 1); l &lt; n; ) {\n      if (c = t[l++], !i) {\n        i = c ? 0 : 1;\n        continue;\n      }\n      if (i === 1) {\n        i = c ? 0 : 2;\n        continue;\n      }\n      if (!c)\n        i = 3;\n      else if (c === 1) {\n        if (u = l - i - 1, h &gt;= 0) {\n          const p = {\n            data: t.subarray(h, u),\n            type: f\n          };\n          a.push(p);\n        } else {\n          const p = this.getLastNalUnit(e.samples);\n          p &amp;&amp; (o &amp;&amp; l &lt;= 4 - o &amp;&amp; p.state &amp;&amp; (p.data = p.data.subarray(0, p.data.byteLength - o)), u &gt; 0 &amp;&amp; (p.data = _r(p.data, t.subarray(0, u)), p.state = 0));\n        }\n        l &lt; n ? (d = this.getNALuType(t, l), h = l, f = d, i = 0) : i = -1;\n      } else\n        i = 0;\n    }\n    if (h &gt;= 0 &amp;&amp; i &gt;= 0) {\n      const p = {\n        data: t.subarray(h, n),\n        type: f,\n        state: i\n      };\n      a.push(p);\n    }\n    if (a.length === 0) {\n      const p = this.getLastNalUnit(e.samples);\n      p &amp;&amp; (p.data = _r(p.data, t));\n    }\n    return e.naluState = i, a;\n  }\n}\nclass Zn {\n  constructor(e) {\n    this.data = void 0, this.bytesAvailable = void 0, this.word = void 0, this.bitsAvailable = void 0, this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0;\n  }\n  // ():void\n  loadWord() {\n    const e = this.data, t = this.bytesAvailable, r = e.byteLength - t, n = new Uint8Array(4), i = Math.min(4, t);\n    if (i === 0)\n      throw new Error(\"no bytes available\");\n    n.set(e.subarray(r, r + i)), this.word = new DataView(n.buffer).getUint32(0), this.bitsAvailable = i * 8, this.bytesAvailable -= i;\n  }\n  // (count:int):void\n  skipBits(e) {\n    let t;\n    e = Math.min(e, this.bytesAvailable * 8 + this.bitsAvailable), this.bitsAvailable &gt; e ? (this.word &lt;&lt;= e, this.bitsAvailable -= e) : (e -= this.bitsAvailable, t = e &gt;&gt; 3, e -= t &lt;&lt; 3, this.bytesAvailable -= t, this.loadWord(), this.word &lt;&lt;= e, this.bitsAvailable -= e);\n  }\n  // (size:int):uint\n  readBits(e) {\n    let t = Math.min(this.bitsAvailable, e);\n    const r = this.word &gt;&gt;&gt; 32 - t;\n    if (e &gt; 32 &amp;&amp; rt.error(\"Cannot read more than 32 bits at a time\"), this.bitsAvailable -= t, this.bitsAvailable &gt; 0)\n      this.word &lt;&lt;= t;\n    else if (this.bytesAvailable &gt; 0)\n      this.loadWord();\n    else\n      throw new Error(\"no bits available\");\n    return t = e - t, t &gt; 0 &amp;&amp; this.bitsAvailable ? r &lt;&lt; t | this.readBits(t) : r;\n  }\n  // ():uint\n  skipLZ() {\n    let e;\n    for (e = 0; e &lt; this.bitsAvailable; ++e)\n      if ((this.word &amp; 2147483648 &gt;&gt;&gt; e) !== 0)\n        return this.word &lt;&lt;= e, this.bitsAvailable -= e, e;\n    return this.loadWord(), e + this.skipLZ();\n  }\n  // ():void\n  skipUEG() {\n    this.skipBits(1 + this.skipLZ());\n  }\n  // ():void\n  skipEG() {\n    this.skipBits(1 + this.skipLZ());\n  }\n  // ():uint\n  readUEG() {\n    const e = this.skipLZ();\n    return this.readBits(e + 1) - 1;\n  }\n  // ():int\n  readEG() {\n    const e = this.readUEG();\n    return 1 &amp; e ? 1 + e &gt;&gt;&gt; 1 : -1 * (e &gt;&gt;&gt; 1);\n  }\n  // Some convenience functions\n  // :Boolean\n  readBoolean() {\n    return this.readBits(1) === 1;\n  }\n  // ():int\n  readUByte() {\n    return this.readBits(8);\n  }\n  // ():int\n  readUShort() {\n    return this.readBits(16);\n  }\n  // ():int\n  readUInt() {\n    return this.readBits(32);\n  }\n}\nclass GT extends xp {\n  parsePES(e, t, r, n) {\n    const i = this.parseNALu(e, r.data, n);\n    let o = this.VideoSample, a, l = !1;\n    r.data = null, o &amp;&amp; i.length &amp;&amp; !e.audFound &amp;&amp; (this.pushAccessUnit(o, e), o = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts)), i.forEach((c) =&gt; {\n      var u, d;\n      switch (c.type) {\n        // NDR\n        case 1: {\n          let y = !1;\n          a = !0;\n          const E = c.data;\n          if (l &amp;&amp; E.length &gt; 4) {\n            const b = this.readSliceType(E);\n            (b === 2 || b === 4 || b === 7 || b === 9) &amp;&amp; (y = !0);\n          }\n          if (y) {\n            var h;\n            (h = o) != null &amp;&amp; h.frame &amp;&amp; !o.key &amp;&amp; (this.pushAccessUnit(o, e), o = this.VideoSample = null);\n          }\n          o || (o = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), o.frame = !0, o.key = y;\n          break;\n        }\n        case 5:\n          a = !0, (u = o) != null &amp;&amp; u.frame &amp;&amp; !o.key &amp;&amp; (this.pushAccessUnit(o, e), o = this.VideoSample = null), o || (o = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), o.key = !0, o.frame = !0;\n          break;\n        // SEI\n        case 6: {\n          a = !0, gu(c.data, 1, r.pts, t.samples);\n          break;\n        }\n        case 7: {\n          var f, p;\n          a = !0, l = !0;\n          const y = c.data, E = this.readSPS(y);\n          if (!e.sps || e.width !== E.width || e.height !== E.height || ((f = e.pixelRatio) == null ? void 0 : f[0]) !== E.pixelRatio[0] || ((p = e.pixelRatio) == null ? void 0 : p[1]) !== E.pixelRatio[1]) {\n            e.width = E.width, e.height = E.height, e.pixelRatio = E.pixelRatio, e.sps = [y];\n            const b = y.subarray(1, 4);\n            let R = \"avc1.\";\n            for (let A = 0; A &lt; 3; A++) {\n              let F = b[A].toString(16);\n              F.length &lt; 2 &amp;&amp; (F = \"0\" + F), R += F;\n            }\n            e.codec = R;\n          }\n          break;\n        }\n        // PPS\n        case 8:\n          a = !0, e.pps = [c.data];\n          break;\n        // AUD\n        case 9:\n          a = !0, e.audFound = !0, (d = o) != null &amp;&amp; d.frame &amp;&amp; (this.pushAccessUnit(o, e), o = null), o || (o = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts));\n          break;\n        // Filler Data\n        case 12:\n          a = !0;\n          break;\n        default:\n          a = !1;\n          break;\n      }\n      o &amp;&amp; a &amp;&amp; o.units.push(c);\n    }), n &amp;&amp; o &amp;&amp; (this.pushAccessUnit(o, e), this.VideoSample = null);\n  }\n  getNALuType(e, t) {\n    return e[t] &amp; 31;\n  }\n  readSliceType(e) {\n    const t = new Zn(e);\n    return t.readUByte(), t.readUEG(), t.readUEG();\n  }\n  /**\n   * The scaling list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count the number of entries in this scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */\n  skipScalingList(e, t) {\n    let r = 8, n = 8, i;\n    for (let o = 0; o &lt; e; o++)\n      n !== 0 &amp;&amp; (i = t.readEG(), n = (r + i + 256) % 256), r = n === 0 ? r : n;\n  }\n  /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @returns an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */\n  readSPS(e) {\n    const t = new Zn(e);\n    let r = 0, n = 0, i = 0, o = 0, a, l, c;\n    const u = t.readUByte.bind(t), d = t.readBits.bind(t), h = t.readUEG.bind(t), f = t.readBoolean.bind(t), p = t.skipBits.bind(t), y = t.skipEG.bind(t), E = t.skipUEG.bind(t), b = this.skipScalingList.bind(this);\n    u();\n    const R = u();\n    if (d(5), p(3), u(), E(), R === 100 || R === 110 || R === 122 || R === 244 || R === 44 || R === 83 || R === 86 || R === 118 || R === 128) {\n      const j = h();\n      if (j === 3 &amp;&amp; p(1), E(), E(), p(1), f())\n        for (l = j !== 3 ? 8 : 12, c = 0; c &lt; l; c++)\n          f() &amp;&amp; (c &lt; 6 ? b(16, t) : b(64, t));\n    }\n    E();\n    const A = h();\n    if (A === 0)\n      h();\n    else if (A === 1)\n      for (p(1), y(), y(), a = h(), c = 0; c &lt; a; c++)\n        y();\n    E(), p(1);\n    const F = h(), M = h(), H = d(1);\n    H === 0 &amp;&amp; p(1), p(1), f() &amp;&amp; (r = h(), n = h(), i = h(), o = h());\n    let K = [1, 1];\n    if (f() &amp;&amp; f())\n      switch (u()) {\n        case 1:\n          K = [1, 1];\n          break;\n        case 2:\n          K = [12, 11];\n          break;\n        case 3:\n          K = [10, 11];\n          break;\n        case 4:\n          K = [16, 11];\n          break;\n        case 5:\n          K = [40, 33];\n          break;\n        case 6:\n          K = [24, 11];\n          break;\n        case 7:\n          K = [20, 11];\n          break;\n        case 8:\n          K = [32, 11];\n          break;\n        case 9:\n          K = [80, 33];\n          break;\n        case 10:\n          K = [18, 11];\n          break;\n        case 11:\n          K = [15, 11];\n          break;\n        case 12:\n          K = [64, 33];\n          break;\n        case 13:\n          K = [160, 99];\n          break;\n        case 14:\n          K = [4, 3];\n          break;\n        case 15:\n          K = [3, 2];\n          break;\n        case 16:\n          K = [2, 1];\n          break;\n        case 255: {\n          K = [u() &lt;&lt; 8 | u(), u() &lt;&lt; 8 | u()];\n          break;\n        }\n      }\n    return {\n      width: Math.ceil((F + 1) * 16 - r * 2 - n * 2),\n      height: (2 - H) * (M + 1) * 16 - (H ? 2 : 4) * (i + o),\n      pixelRatio: K\n    };\n  }\n}\nclass VT extends xp {\n  constructor(...e) {\n    super(...e), this.initVPS = null;\n  }\n  parsePES(e, t, r, n) {\n    const i = this.parseNALu(e, r.data, n);\n    let o = this.VideoSample, a, l = !1;\n    r.data = null, o &amp;&amp; i.length &amp;&amp; !e.audFound &amp;&amp; (this.pushAccessUnit(o, e), o = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts)), i.forEach((c) =&gt; {\n      var u, d;\n      switch (c.type) {\n        // NON-IDR, NON RANDOM ACCESS SLICE\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 8:\n        case 9:\n          o || (o = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts)), o.frame = !0, a = !0;\n          break;\n        // CRA, BLA (random access picture)\n        case 16:\n        case 17:\n        case 18:\n        case 21:\n          if (a = !0, l) {\n            var h;\n            (h = o) != null &amp;&amp; h.frame &amp;&amp; !o.key &amp;&amp; (this.pushAccessUnit(o, e), o = this.VideoSample = null);\n          }\n          o || (o = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), o.key = !0, o.frame = !0;\n          break;\n        // IDR\n        case 19:\n        case 20:\n          a = !0, (u = o) != null &amp;&amp; u.frame &amp;&amp; !o.key &amp;&amp; (this.pushAccessUnit(o, e), o = this.VideoSample = null), o || (o = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), o.key = !0, o.frame = !0;\n          break;\n        // SEI\n        case 39:\n          a = !0, gu(\n            c.data,\n            2,\n            // NALu header size\n            r.pts,\n            t.samples\n          );\n          break;\n        // VPS\n        case 32:\n          a = !0, e.vps || (typeof e.params != \"object\" &amp;&amp; (e.params = {}), e.params = nt(e.params, this.readVPS(c.data)), this.initVPS = c.data), e.vps = [c.data];\n          break;\n        // SPS\n        case 33:\n          if (a = !0, l = !0, e.vps !== void 0 &amp;&amp; e.vps[0] !== this.initVPS &amp;&amp; e.sps !== void 0 &amp;&amp; !this.matchSPS(e.sps[0], c.data) &amp;&amp; (this.initVPS = e.vps[0], e.sps = e.pps = void 0), !e.sps) {\n            const f = this.readSPS(c.data);\n            e.width = f.width, e.height = f.height, e.pixelRatio = f.pixelRatio, e.codec = f.codecString, e.sps = [], typeof e.params != \"object\" &amp;&amp; (e.params = {});\n            for (const p in f.params)\n              e.params[p] = f.params[p];\n          }\n          this.pushParameterSet(e.sps, c.data, e.vps), o || (o = this.VideoSample = this.createVideoSample(!0, r.pts, r.dts)), o.key = !0;\n          break;\n        // PPS\n        case 34:\n          if (a = !0, typeof e.params == \"object\") {\n            if (!e.pps) {\n              e.pps = [];\n              const f = this.readPPS(c.data);\n              for (const p in f)\n                e.params[p] = f[p];\n            }\n            this.pushParameterSet(e.pps, c.data, e.vps);\n          }\n          break;\n        // ACCESS UNIT DELIMITER\n        case 35:\n          a = !0, e.audFound = !0, (d = o) != null &amp;&amp; d.frame &amp;&amp; (this.pushAccessUnit(o, e), o = null), o || (o = this.VideoSample = this.createVideoSample(!1, r.pts, r.dts));\n          break;\n        default:\n          a = !1;\n          break;\n      }\n      o &amp;&amp; a &amp;&amp; o.units.push(c);\n    }), n &amp;&amp; o &amp;&amp; (this.pushAccessUnit(o, e), this.VideoSample = null);\n  }\n  pushParameterSet(e, t, r) {\n    (r &amp;&amp; r[0] === this.initVPS || !r &amp;&amp; !e.length) &amp;&amp; e.push(t);\n  }\n  getNALuType(e, t) {\n    return (e[t] &amp; 126) &gt;&gt;&gt; 1;\n  }\n  ebsp2rbsp(e) {\n    const t = new Uint8Array(e.byteLength);\n    let r = 0;\n    for (let n = 0; n &lt; e.byteLength; n++)\n      n &gt;= 2 &amp;&amp; e[n] === 3 &amp;&amp; e[n - 1] === 0 &amp;&amp; e[n - 2] === 0 || (t[r] = e[n], r++);\n    return new Uint8Array(t.buffer, 0, r);\n  }\n  pushAccessUnit(e, t) {\n    super.pushAccessUnit(e, t), this.initVPS &amp;&amp; (this.initVPS = null);\n  }\n  readVPS(e) {\n    const t = new Zn(e);\n    t.readUByte(), t.readUByte(), t.readBits(4), t.skipBits(2), t.readBits(6);\n    const r = t.readBits(3), n = t.readBoolean();\n    return {\n      numTemporalLayers: r + 1,\n      temporalIdNested: n\n    };\n  }\n  readSPS(e) {\n    const t = new Zn(this.ebsp2rbsp(e));\n    t.readUByte(), t.readUByte(), t.readBits(4);\n    const r = t.readBits(3);\n    t.readBoolean();\n    const n = t.readBits(2), i = t.readBoolean(), o = t.readBits(5), a = t.readUByte(), l = t.readUByte(), c = t.readUByte(), u = t.readUByte(), d = t.readUByte(), h = t.readUByte(), f = t.readUByte(), p = t.readUByte(), y = t.readUByte(), E = t.readUByte(), b = t.readUByte(), R = [], A = [];\n    for (let ye = 0; ye &lt; r; ye++)\n      R.push(t.readBoolean()), A.push(t.readBoolean());\n    if (r &gt; 0)\n      for (let ye = r; ye &lt; 8; ye++)\n        t.readBits(2);\n    for (let ye = 0; ye &lt; r; ye++)\n      R[ye] &amp;&amp; (t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte(), t.readUByte()), A[ye] &amp;&amp; t.readUByte();\n    t.readUEG();\n    const F = t.readUEG();\n    F == 3 &amp;&amp; t.skipBits(1);\n    const M = t.readUEG(), H = t.readUEG(), K = t.readBoolean();\n    let j = 0, C = 0, k = 0, $ = 0;\n    K &amp;&amp; (j += t.readUEG(), C += t.readUEG(), k += t.readUEG(), $ += t.readUEG());\n    const W = t.readUEG(), _ = t.readUEG(), g = t.readUEG(), x = t.readBoolean();\n    for (let ye = x ? 0 : r; ye &lt;= r; ye++)\n      t.skipUEG(), t.skipUEG(), t.skipUEG();\n    if (t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG(), t.readBoolean() &amp;&amp; t.readBoolean())\n      for (let be = 0; be &lt; 4; be++)\n        for (let Fe = 0; Fe &lt; (be === 3 ? 2 : 6); Fe++)\n          if (!t.readBoolean())\n            t.readUEG();\n          else {\n            const we = Math.min(64, 1 &lt;&lt; 4 + (be &lt;&lt; 1));\n            be &gt; 1 &amp;&amp; t.readEG();\n            for (let Ne = 0; Ne &lt; we; Ne++)\n              t.readEG();\n          }\n    t.readBoolean(), t.readBoolean(), t.readBoolean() &amp;&amp; (t.readUByte(), t.skipUEG(), t.skipUEG(), t.readBoolean());\n    const O = t.readUEG();\n    let U = 0;\n    for (let ye = 0; ye &lt; O; ye++) {\n      let be = !1;\n      if (ye !== 0 &amp;&amp; (be = t.readBoolean()), be) {\n        ye === O &amp;&amp; t.readUEG(), t.readBoolean(), t.readUEG();\n        let Fe = 0;\n        for (let Xe = 0; Xe &lt;= U; Xe++) {\n          const we = t.readBoolean();\n          let Ne = !1;\n          we || (Ne = t.readBoolean()), (we || Ne) &amp;&amp; Fe++;\n        }\n        U = Fe;\n      } else {\n        const Fe = t.readUEG(), Xe = t.readUEG();\n        U = Fe + Xe;\n        for (let we = 0; we &lt; Fe; we++)\n          t.readUEG(), t.readBoolean();\n        for (let we = 0; we &lt; Xe; we++)\n          t.readUEG(), t.readBoolean();\n      }\n    }\n    if (t.readBoolean()) {\n      const ye = t.readUEG();\n      for (let be = 0; be &lt; ye; be++) {\n        for (let Fe = 0; Fe &lt; g + 4; Fe++)\n          t.readBits(1);\n        t.readBits(1);\n      }\n    }\n    let L = 0, m = 1, v = 1, P = !0, N = 1, Y = 0;\n    t.readBoolean(), t.readBoolean();\n    let ee = !1;\n    if (t.readBoolean()) {\n      if (t.readBoolean()) {\n        const dt = t.readUByte(), Je = [1, 12, 10, 16, 40, 24, 20, 32, 80, 18, 15, 64, 160, 4, 3, 2], Qe = [1, 11, 11, 11, 33, 11, 11, 11, 33, 11, 11, 33, 99, 3, 2, 1];\n        dt &gt; 0 &amp;&amp; dt &lt; 16 ? (m = Je[dt - 1], v = Qe[dt - 1]) : dt === 255 &amp;&amp; (m = t.readBits(16), v = t.readBits(16));\n      }\n      if (t.readBoolean() &amp;&amp; t.readBoolean(), t.readBoolean() &amp;&amp; (t.readBits(3), t.readBoolean(), t.readBoolean() &amp;&amp; (t.readUByte(), t.readUByte(), t.readUByte())), t.readBoolean() &amp;&amp; (t.readUEG(), t.readUEG()), t.readBoolean(), t.readBoolean(), t.readBoolean(), ee = t.readBoolean(), ee &amp;&amp; (t.skipUEG(), t.skipUEG(), t.skipUEG(), t.skipUEG()), t.readBoolean() &amp;&amp; (N = t.readBits(32), Y = t.readBits(32), t.readBoolean() &amp;&amp; t.readUEG(), t.readBoolean())) {\n        const Qe = t.readBoolean(), it = t.readBoolean();\n        let je = !1;\n        (Qe || it) &amp;&amp; (je = t.readBoolean(), je &amp;&amp; (t.readUByte(), t.readBits(5), t.readBoolean(), t.readBits(5)), t.readBits(4), t.readBits(4), je &amp;&amp; t.readBits(4), t.readBits(5), t.readBits(5), t.readBits(5));\n        for (let B = 0; B &lt;= r; B++) {\n          P = t.readBoolean();\n          const S = P || t.readBoolean();\n          let T = !1;\n          S ? t.readEG() : T = t.readBoolean();\n          const G = T ? 1 : t.readUEG() + 1;\n          if (Qe)\n            for (let Z = 0; Z &lt; G; Z++)\n              t.readUEG(), t.readUEG(), je &amp;&amp; (t.readUEG(), t.readUEG()), t.skipBits(1);\n          if (it)\n            for (let Z = 0; Z &lt; G; Z++)\n              t.readUEG(), t.readUEG(), je &amp;&amp; (t.readUEG(), t.readUEG()), t.skipBits(1);\n        }\n      }\n      t.readBoolean() &amp;&amp; (t.readBoolean(), t.readBoolean(), t.readBoolean(), L = t.readUEG());\n    }\n    let le = M, Te = H;\n    if (K) {\n      let ye = 1, be = 1;\n      F === 1 ? ye = be = 2 : F == 2 &amp;&amp; (ye = 2), le = M - ye * C - ye * j, Te = H - be * $ - be * k;\n    }\n    const De = n ? [\"A\", \"B\", \"C\"][n] : \"\", ze = a &lt;&lt; 24 | l &lt;&lt; 16 | c &lt;&lt; 8 | u;\n    let _e = 0;\n    for (let ye = 0; ye &lt; 32; ye++)\n      _e = (_e | (ze &gt;&gt; ye &amp; 1) &lt;&lt; 31 - ye) &gt;&gt;&gt; 0;\n    let xe = _e.toString(16);\n    return o === 1 &amp;&amp; xe === \"2\" &amp;&amp; (xe = \"6\"), {\n      codecString: `hvc1.${De}${o}.${xe}.${i ? \"H\" : \"L\"}${b}.B0`,\n      params: {\n        general_tier_flag: i,\n        general_profile_idc: o,\n        general_profile_space: n,\n        general_profile_compatibility_flags: [a, l, c, u],\n        general_constraint_indicator_flags: [d, h, f, p, y, E],\n        general_level_idc: b,\n        bit_depth: W + 8,\n        bit_depth_luma_minus8: W,\n        bit_depth_chroma_minus8: _,\n        min_spatial_segmentation_idc: L,\n        chroma_format_idc: F,\n        frame_rate: {\n          fixed: P,\n          fps: Y / N\n        }\n      },\n      width: le,\n      height: Te,\n      pixelRatio: [m, v]\n    };\n  }\n  readPPS(e) {\n    const t = new Zn(this.ebsp2rbsp(e));\n    t.readUByte(), t.readUByte(), t.skipUEG(), t.skipUEG(), t.skipBits(2), t.skipBits(3), t.skipBits(2), t.skipUEG(), t.skipUEG(), t.skipEG(), t.skipBits(2), t.readBoolean() &amp;&amp; t.skipUEG(), t.skipEG(), t.skipEG(), t.skipBits(4);\n    const n = t.readBoolean(), i = t.readBoolean();\n    let o = 1;\n    return i &amp;&amp; n ? o = 0 : i ? o = 3 : n &amp;&amp; (o = 2), {\n      parallelismType: o\n    };\n  }\n  matchSPS(e, t) {\n    return String.fromCharCode.apply(null, e).substr(3) === String.fromCharCode.apply(null, t).substr(3);\n  }\n}\nconst Wt = 188;\nclass Is {\n  constructor(e, t, r, n) {\n    this.logger = void 0, this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.sampleAes = null, this.pmtParsed = !1, this.audioCodec = void 0, this.videoCodec = void 0, this._pmtId = -1, this._videoTrack = void 0, this._audioTrack = void 0, this._id3Track = void 0, this._txtTrack = void 0, this.aacOverFlow = null, this.remainderData = null, this.videoParser = void 0, this.observer = e, this.config = t, this.typeSupported = r, this.logger = n, this.videoParser = null;\n  }\n  static probe(e, t) {\n    const r = Is.syncOffset(e);\n    return r &gt; 0 &amp;&amp; t.warn(`MPEG2-TS detected but first sync word found @ offset ${r}`), r !== -1;\n  }\n  static syncOffset(e) {\n    const t = e.length;\n    let r = Math.min(Wt * 5, t - Wt) + 1, n = 0;\n    for (; n &lt; r; ) {\n      let i = !1, o = -1, a = 0;\n      for (let l = n; l &lt; t; l += Wt)\n        if (e[l] === 71 &amp;&amp; (t - l === Wt || e[l + Wt] === 71)) {\n          if (a++, o === -1 &amp;&amp; (o = l, o !== 0 &amp;&amp; (r = Math.min(o + Wt * 99, e.length - Wt) + 1)), i || (i = pc(e, l) === 0), i &amp;&amp; a &gt; 1 &amp;&amp; (o === 0 &amp;&amp; a &gt; 2 || l + Wt &gt; r))\n            return o;\n        } else {\n          if (a)\n            return -1;\n          break;\n        }\n      n++;\n    }\n    return -1;\n  }\n  /**\n   * Creates a track model internal to demuxer used to drive remuxing input\n   */\n  static createTrack(e, t) {\n    return {\n      container: e === \"video\" || e === \"audio\" ? \"video/mp2t\" : void 0,\n      type: e,\n      id: Lg[e],\n      pid: -1,\n      inputTimeScale: 9e4,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0,\n      duration: e === \"audio\" ? t : void 0\n    };\n  }\n  /**\n   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n   * Resets all internal track instances of the demuxer.\n   */\n  resetInitSegment(e, t, r, n) {\n    this.pmtParsed = !1, this._pmtId = -1, this._videoTrack = Is.createTrack(\"video\"), this._videoTrack.duration = n, this._audioTrack = Is.createTrack(\"audio\", n), this._id3Track = Is.createTrack(\"id3\"), this._txtTrack = Is.createTrack(\"text\"), this._audioTrack.segmentCodec = \"aac\", this.videoParser = null, this.aacOverFlow = null, this.remainderData = null, this.audioCodec = t, this.videoCodec = r;\n  }\n  resetTimeStamp() {\n  }\n  resetContiguity() {\n    const {\n      _audioTrack: e,\n      _videoTrack: t,\n      _id3Track: r\n    } = this;\n    e &amp;&amp; (e.pesData = null), t &amp;&amp; (t.pesData = null), r &amp;&amp; (r.pesData = null), this.aacOverFlow = null, this.remainderData = null;\n  }\n  demux(e, t, r = !1, n = !1) {\n    r || (this.sampleAes = null);\n    let i;\n    const o = this._videoTrack, a = this._audioTrack, l = this._id3Track, c = this._txtTrack;\n    let u = o.pid, d = o.pesData, h = a.pid, f = l.pid, p = a.pesData, y = l.pesData, E = null, b = this.pmtParsed, R = this._pmtId, A = e.length;\n    if (this.remainderData &amp;&amp; (e = _r(this.remainderData, e), A = e.length, this.remainderData = null), A &lt; Wt &amp;&amp; !n)\n      return this.remainderData = e, {\n        audioTrack: a,\n        videoTrack: o,\n        id3Track: l,\n        textTrack: c\n      };\n    const F = Math.max(0, Is.syncOffset(e));\n    A -= (A - F) % Wt, A &lt; e.byteLength &amp;&amp; !n &amp;&amp; (this.remainderData = new Uint8Array(e.buffer, A, e.buffer.byteLength - A));\n    let M = 0;\n    for (let K = F; K &lt; A; K += Wt)\n      if (e[K] === 71) {\n        const j = !!(e[K + 1] &amp; 64), C = pc(e, K), k = (e[K + 3] &amp; 48) &gt;&gt; 4;\n        let $;\n        if (k &gt; 1) {\n          if ($ = K + 5 + e[K + 4], $ === K + Wt)\n            continue;\n        } else\n          $ = K + 4;\n        switch (C) {\n          case u:\n            j &amp;&amp; (d &amp;&amp; (i = gn(d, this.logger)) &amp;&amp; (this.readyVideoParser(o.segmentCodec), this.videoParser !== null &amp;&amp; this.videoParser.parsePES(o, c, i, !1)), d = {\n              data: [],\n              size: 0\n            }), d &amp;&amp; (d.data.push(e.subarray($, K + Wt)), d.size += K + Wt - $);\n            break;\n          case h:\n            if (j) {\n              if (p &amp;&amp; (i = gn(p, this.logger)))\n                switch (a.segmentCodec) {\n                  case \"aac\":\n                    this.parseAACPES(a, i);\n                    break;\n                  case \"mp3\":\n                    this.parseMPEGPES(a, i);\n                    break;\n                  case \"ac3\":\n                    this.parseAC3PES(a, i);\n                    break;\n                }\n              p = {\n                data: [],\n                size: 0\n              };\n            }\n            p &amp;&amp; (p.data.push(e.subarray($, K + Wt)), p.size += K + Wt - $);\n            break;\n          case f:\n            j &amp;&amp; (y &amp;&amp; (i = gn(y, this.logger)) &amp;&amp; this.parseID3PES(l, i), y = {\n              data: [],\n              size: 0\n            }), y &amp;&amp; (y.data.push(e.subarray($, K + Wt)), y.size += K + Wt - $);\n            break;\n          case 0:\n            j &amp;&amp; ($ += e[$] + 1), R = this._pmtId = jT(e, $);\n            break;\n          case R: {\n            j &amp;&amp; ($ += e[$] + 1);\n            const W = KT(e, $, this.typeSupported, r, this.observer, this.logger);\n            u = W.videoPid, u &gt; 0 &amp;&amp; (o.pid = u, o.segmentCodec = W.segmentVideoCodec), h = W.audioPid, h &gt; 0 &amp;&amp; (a.pid = h, a.segmentCodec = W.segmentAudioCodec), f = W.id3Pid, f &gt; 0 &amp;&amp; (l.pid = f), E !== null &amp;&amp; !b &amp;&amp; (this.logger.warn(`MPEG-TS PMT found at ${K} after unknown PID '${E}'. Backtracking to sync byte @${F} to parse all TS packets.`), E = null, K = F - 188), b = this.pmtParsed = !0;\n            break;\n          }\n          case 17:\n          case 8191:\n            break;\n          default:\n            E = C;\n            break;\n        }\n      } else\n        M++;\n    M &gt; 0 &amp;&amp; mc(this.observer, new Error(`Found ${M} TS packet/s that do not start with 0x47`), void 0, this.logger), o.pesData = d, a.pesData = p, l.pesData = y;\n    const H = {\n      audioTrack: a,\n      videoTrack: o,\n      id3Track: l,\n      textTrack: c\n    };\n    return n &amp;&amp; this.extractRemainingSamples(H), H;\n  }\n  flush() {\n    const {\n      remainderData: e\n    } = this;\n    this.remainderData = null;\n    let t;\n    return e ? t = this.demux(e, -1, !1, !0) : t = {\n      videoTrack: this._videoTrack,\n      audioTrack: this._audioTrack,\n      id3Track: this._id3Track,\n      textTrack: this._txtTrack\n    }, this.extractRemainingSamples(t), this.sampleAes ? this.decrypt(t, this.sampleAes) : t;\n  }\n  extractRemainingSamples(e) {\n    const {\n      audioTrack: t,\n      videoTrack: r,\n      id3Track: n,\n      textTrack: i\n    } = e, o = r.pesData, a = t.pesData, l = n.pesData;\n    let c;\n    if (o &amp;&amp; (c = gn(o, this.logger)) ? (this.readyVideoParser(r.segmentCodec), this.videoParser !== null &amp;&amp; (this.videoParser.parsePES(r, i, c, !0), r.pesData = null)) : r.pesData = o, a &amp;&amp; (c = gn(a, this.logger))) {\n      switch (t.segmentCodec) {\n        case \"aac\":\n          this.parseAACPES(t, c);\n          break;\n        case \"mp3\":\n          this.parseMPEGPES(t, c);\n          break;\n        case \"ac3\":\n          this.parseAC3PES(t, c);\n          break;\n      }\n      t.pesData = null;\n    } else\n      a != null &amp;&amp; a.size &amp;&amp; this.logger.log(\"last AAC PES packet truncated,might overlap between fragments\"), t.pesData = a;\n    l &amp;&amp; (c = gn(l, this.logger)) ? (this.parseID3PES(n, c), n.pesData = null) : n.pesData = l;\n  }\n  demuxSampleAes(e, t, r) {\n    const n = this.demux(e, r, !0, !this.config.progressive), i = this.sampleAes = new $T(this.observer, this.config, t);\n    return this.decrypt(n, i);\n  }\n  readyVideoParser(e) {\n    this.videoParser === null &amp;&amp; (e === \"avc\" ? this.videoParser = new GT() : e === \"hevc\" &amp;&amp; (this.videoParser = new VT()));\n  }\n  decrypt(e, t) {\n    return new Promise((r) =&gt; {\n      const {\n        audioTrack: n,\n        videoTrack: i\n      } = e;\n      n.samples &amp;&amp; n.segmentCodec === \"aac\" ? t.decryptAacSamples(n.samples, 0, () =&gt; {\n        i.samples ? t.decryptAvcSamples(i.samples, 0, 0, () =&gt; {\n          r(e);\n        }) : r(e);\n      }) : i.samples &amp;&amp; t.decryptAvcSamples(i.samples, 0, 0, () =&gt; {\n        r(e);\n      });\n    });\n  }\n  destroy() {\n    this.observer &amp;&amp; this.observer.removeAllListeners(), this.config = this.logger = this.observer = null, this.aacOverFlow = this.videoParser = this.remainderData = this.sampleAes = null, this._videoTrack = this._audioTrack = this._id3Track = this._txtTrack = void 0;\n  }\n  parseAACPES(e, t) {\n    let r = 0;\n    const n = this.aacOverFlow;\n    let i = t.data;\n    if (n) {\n      this.aacOverFlow = null;\n      const d = n.missing, h = n.sample.unit.byteLength;\n      if (d === -1)\n        i = _r(n.sample.unit, i);\n      else {\n        const f = h - d;\n        n.sample.unit.set(i.subarray(0, d), f), e.samples.push(n.sample), r = n.missing;\n      }\n    }\n    let o, a;\n    for (o = r, a = i.length; o &lt; a - 1 &amp;&amp; !na(i, o); o++)\n      ;\n    if (o !== r) {\n      let d;\n      const h = o &lt; a - 1;\n      if (h ? d = `AAC PES did not start with ADTS header,offset:${o}` : d = \"No ADTS header found in AAC PES\", mc(this.observer, new Error(d), h, this.logger), !h)\n        return;\n    }\n    cp(e, this.observer, i, o, this.audioCodec);\n    let l;\n    if (t.pts !== void 0)\n      l = t.pts;\n    else if (n) {\n      const d = up(e.samplerate);\n      l = n.sample.pts + d;\n    } else {\n      this.logger.warn(\"[tsdemuxer]: AAC PES unknown PTS\");\n      return;\n    }\n    let c = 0, u;\n    for (; o &lt; a; )\n      if (u = dp(e, i, o, l, c), o += u.length, u.missing) {\n        this.aacOverFlow = u;\n        break;\n      } else\n        for (c++; o &lt; a - 1 &amp;&amp; !na(i, o); o++)\n          ;\n  }\n  parseMPEGPES(e, t) {\n    const r = t.data, n = r.length;\n    let i = 0, o = 0;\n    const a = t.pts;\n    if (a === void 0) {\n      this.logger.warn(\"[tsdemuxer]: MPEG PES unknown PTS\");\n      return;\n    }\n    for (; o &lt; n; )\n      if (mp(r, o)) {\n        const l = gp(e, r, o, a, i);\n        if (l)\n          o += l.length, i++;\n        else\n          break;\n      } else\n        o++;\n  }\n  parseAC3PES(e, t) {\n    {\n      const r = t.data, n = t.pts;\n      if (n === void 0) {\n        this.logger.warn(\"[tsdemuxer]: AC3 PES unknown PTS\");\n        return;\n      }\n      const i = r.length;\n      let o = 0, a = 0, l;\n      for (; a &lt; i &amp;&amp; (l = Ep(e, r, a, n, o++)) &gt; 0; )\n        a += l;\n    }\n  }\n  parseID3PES(e, t) {\n    if (t.pts === void 0) {\n      this.logger.warn(\"[tsdemuxer]: ID3 PES unknown PTS\");\n      return;\n    }\n    const r = nt({}, t, {\n      type: this._videoTrack ? br.emsg : br.audioId3,\n      duration: Number.POSITIVE_INFINITY\n    });\n    e.samples.push(r);\n  }\n}\nfunction pc(s, e) {\n  return ((s[e + 1] &amp; 31) &lt;&lt; 8) + s[e + 2];\n}\nfunction jT(s, e) {\n  return (s[e + 10] &amp; 31) &lt;&lt; 8 | s[e + 11];\n}\nfunction KT(s, e, t, r, n, i) {\n  const o = {\n    audioPid: -1,\n    videoPid: -1,\n    id3Pid: -1,\n    segmentVideoCodec: \"avc\",\n    segmentAudioCodec: \"aac\"\n  }, a = (s[e + 1] &amp; 15) &lt;&lt; 8 | s[e + 2], l = e + 3 + a - 4, c = (s[e + 10] &amp; 15) &lt;&lt; 8 | s[e + 11];\n  for (e += 12 + c; e &lt; l; ) {\n    const u = pc(s, e), d = (s[e + 3] &amp; 15) &lt;&lt; 8 | s[e + 4];\n    switch (s[e]) {\n      case 207:\n        if (!r) {\n          vl(\"ADTS AAC\", i);\n          break;\n        }\n      /* falls through */\n      case 15:\n        o.audioPid === -1 &amp;&amp; (o.audioPid = u);\n        break;\n      // Packetized metadata (ID3)\n      case 21:\n        o.id3Pid === -1 &amp;&amp; (o.id3Pid = u);\n        break;\n      case 219:\n        if (!r) {\n          vl(\"H.264\", i);\n          break;\n        }\n      /* falls through */\n      case 27:\n        o.videoPid === -1 &amp;&amp; (o.videoPid = u);\n        break;\n      // ISO/IEC 11172-3 (MPEG-1 audio)\n      // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n      case 3:\n      case 4:\n        !t.mpeg &amp;&amp; !t.mp3 ? i.log(\"MPEG audio found, not supported in this browser\") : o.audioPid === -1 &amp;&amp; (o.audioPid = u, o.segmentAudioCodec = \"mp3\");\n        break;\n      case 193:\n        if (!r) {\n          vl(\"AC-3\", i);\n          break;\n        }\n      /* falls through */\n      case 129:\n        t.ac3 ? o.audioPid === -1 &amp;&amp; (o.audioPid = u, o.segmentAudioCodec = \"ac3\") : i.log(\"AC-3 audio found, not supported in this browser\");\n        break;\n      case 6:\n        if (o.audioPid === -1 &amp;&amp; d &gt; 0) {\n          let h = e + 5, f = d;\n          for (; f &gt; 2; ) {\n            switch (s[h]) {\n              case 106:\n                t.ac3 !== !0 ? i.log(\"AC-3 audio found, not supported in this browser for now\") : (o.audioPid = u, o.segmentAudioCodec = \"ac3\");\n                break;\n            }\n            const y = s[h + 1] + 2;\n            h += y, f -= y;\n          }\n        }\n        break;\n      case 194:\n      // SAMPLE-AES EC3\n      /* falls through */\n      case 135:\n        return mc(n, new Error(\"Unsupported EC-3 in M2TS found\"), void 0, i), o;\n      case 36:\n        o.videoPid === -1 &amp;&amp; (o.videoPid = u, o.segmentVideoCodec = \"hevc\", i.log(\"HEVC in M2TS found\"));\n        break;\n    }\n    e += d + 5;\n  }\n  return o;\n}\nfunction mc(s, e, t, r) {\n  r.warn(`parsing error: ${e.message}`), s.emit(I.ERROR, I.ERROR, {\n    type: ve.MEDIA_ERROR,\n    details: J.FRAG_PARSING_ERROR,\n    fatal: !1,\n    levelRetry: t,\n    error: e,\n    reason: e.message\n  });\n}\nfunction vl(s, e) {\n  e.log(`${s} with AES-128-CBC encryption found in unencrypted stream`);\n}\nfunction gn(s, e) {\n  let t = 0, r, n, i, o, a;\n  const l = s.data;\n  if (!s || s.size === 0)\n    return null;\n  for (; l[0].length &lt; 19 &amp;&amp; l.length &gt; 1; )\n    l[0] = _r(l[0], l[1]), l.splice(1, 1);\n  if (r = l[0], (r[0] &lt;&lt; 16) + (r[1] &lt;&lt; 8) + r[2] === 1) {\n    if (n = (r[4] &lt;&lt; 8) + r[5], n &amp;&amp; n &gt; s.size - 6)\n      return null;\n    const u = r[7];\n    u &amp; 192 &amp;&amp; (o = (r[9] &amp; 14) * 536870912 + // 1 &lt;&lt; 29\n    (r[10] &amp; 255) * 4194304 + // 1 &lt;&lt; 22\n    (r[11] &amp; 254) * 16384 + // 1 &lt;&lt; 14\n    (r[12] &amp; 255) * 128 + // 1 &lt;&lt; 7\n    (r[13] &amp; 254) / 2, u &amp; 64 ? (a = (r[14] &amp; 14) * 536870912 + // 1 &lt;&lt; 29\n    (r[15] &amp; 255) * 4194304 + // 1 &lt;&lt; 22\n    (r[16] &amp; 254) * 16384 + // 1 &lt;&lt; 14\n    (r[17] &amp; 255) * 128 + // 1 &lt;&lt; 7\n    (r[18] &amp; 254) / 2, o - a &gt; 60 * 9e4 &amp;&amp; (e.warn(`${Math.round((o - a) / 9e4)}s delta between PTS and DTS, align them`), o = a)) : a = o), i = r[8];\n    let d = i + 9;\n    if (s.size &lt;= d)\n      return null;\n    s.size -= d;\n    const h = new Uint8Array(s.size);\n    for (let f = 0, p = l.length; f &lt; p; f++) {\n      r = l[f];\n      let y = r.byteLength;\n      if (d)\n        if (d &gt; y) {\n          d -= y;\n          continue;\n        } else\n          r = r.subarray(d), y -= d, d = 0;\n      h.set(r, t), t += y;\n    }\n    return n &amp;&amp; (n -= i + 3), {\n      data: h,\n      pts: o,\n      dts: a,\n      len: n\n    };\n  }\n  return null;\n}\nclass HT {\n  static getSilentFrame(e, t) {\n    switch (e) {\n      case \"mp4a.40.2\":\n        if (t === 1)\n          return new Uint8Array([0, 200, 0, 128, 35, 128]);\n        if (t === 2)\n          return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]);\n        if (t === 3)\n          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]);\n        if (t === 4)\n          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]);\n        if (t === 5)\n          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]);\n        if (t === 6)\n          return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]);\n        break;\n      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n      default:\n        if (t === 1)\n          return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);\n        if (t === 2)\n          return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);\n        if (t === 3)\n          return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]);\n        break;\n    }\n  }\n}\nconst Ss = Math.pow(2, 32) - 1;\nclass X {\n  static init() {\n    X.types = {\n      avc1: [],\n      // codingname\n      avcC: [],\n      hvc1: [],\n      hvcC: [],\n      btrt: [],\n      dinf: [],\n      dref: [],\n      esds: [],\n      ftyp: [],\n      hdlr: [],\n      mdat: [],\n      mdhd: [],\n      mdia: [],\n      mfhd: [],\n      minf: [],\n      moof: [],\n      moov: [],\n      mp4a: [],\n      \".mp3\": [],\n      dac3: [],\n      \"ac-3\": [],\n      mvex: [],\n      mvhd: [],\n      pasp: [],\n      sdtp: [],\n      stbl: [],\n      stco: [],\n      stsc: [],\n      stsd: [],\n      stsz: [],\n      stts: [],\n      tfdt: [],\n      tfhd: [],\n      traf: [],\n      trak: [],\n      trun: [],\n      trex: [],\n      tkhd: [],\n      vmhd: [],\n      smhd: []\n    };\n    let e;\n    for (e in X.types)\n      X.types.hasOwnProperty(e) &amp;&amp; (X.types[e] = [e.charCodeAt(0), e.charCodeAt(1), e.charCodeAt(2), e.charCodeAt(3)]);\n    const t = new Uint8Array([\n      0,\n      // version 0\n      0,\n      0,\n      0,\n      // flags\n      0,\n      0,\n      0,\n      0,\n      // pre_defined\n      118,\n      105,\n      100,\n      101,\n      // handler_type: 'vide'\n      0,\n      0,\n      0,\n      0,\n      // reserved\n      0,\n      0,\n      0,\n      0,\n      // reserved\n      0,\n      0,\n      0,\n      0,\n      // reserved\n      86,\n      105,\n      100,\n      101,\n      111,\n      72,\n      97,\n      110,\n      100,\n      108,\n      101,\n      114,\n      0\n      // name: 'VideoHandler'\n    ]), r = new Uint8Array([\n      0,\n      // version 0\n      0,\n      0,\n      0,\n      // flags\n      0,\n      0,\n      0,\n      0,\n      // pre_defined\n      115,\n      111,\n      117,\n      110,\n      // handler_type: 'soun'\n      0,\n      0,\n      0,\n      0,\n      // reserved\n      0,\n      0,\n      0,\n      0,\n      // reserved\n      0,\n      0,\n      0,\n      0,\n      // reserved\n      83,\n      111,\n      117,\n      110,\n      100,\n      72,\n      97,\n      110,\n      100,\n      108,\n      101,\n      114,\n      0\n      // name: 'SoundHandler'\n    ]);\n    X.HDLR_TYPES = {\n      video: t,\n      audio: r\n    };\n    const n = new Uint8Array([\n      0,\n      // version 0\n      0,\n      0,\n      0,\n      // flags\n      0,\n      0,\n      0,\n      1,\n      // entry_count\n      0,\n      0,\n      0,\n      12,\n      // entry_size\n      117,\n      114,\n      108,\n      32,\n      // 'url' type\n      0,\n      // version 0\n      0,\n      0,\n      1\n      // entry_flags\n    ]), i = new Uint8Array([\n      0,\n      // version\n      0,\n      0,\n      0,\n      // flags\n      0,\n      0,\n      0,\n      0\n      // entry_count\n    ]);\n    X.STTS = X.STSC = X.STCO = i, X.STSZ = new Uint8Array([\n      0,\n      // version\n      0,\n      0,\n      0,\n      // flags\n      0,\n      0,\n      0,\n      0,\n      // sample_size\n      0,\n      0,\n      0,\n      0\n      // sample_count\n    ]), X.VMHD = new Uint8Array([\n      0,\n      // version\n      0,\n      0,\n      1,\n      // flags\n      0,\n      0,\n      // graphicsmode\n      0,\n      0,\n      0,\n      0,\n      0,\n      0\n      // opcolor\n    ]), X.SMHD = new Uint8Array([\n      0,\n      // version\n      0,\n      0,\n      0,\n      // flags\n      0,\n      0,\n      // balance\n      0,\n      0\n      // reserved\n    ]), X.STSD = new Uint8Array([\n      0,\n      // version 0\n      0,\n      0,\n      0,\n      // flags\n      0,\n      0,\n      0,\n      1\n    ]);\n    const o = new Uint8Array([105, 115, 111, 109]), a = new Uint8Array([97, 118, 99, 49]), l = new Uint8Array([0, 0, 0, 1]);\n    X.FTYP = X.box(X.types.ftyp, o, l, o, a), X.DINF = X.box(X.types.dinf, X.box(X.types.dref, n));\n  }\n  static box(e, ...t) {\n    let r = 8, n = t.length;\n    const i = n;\n    for (; n--; )\n      r += t[n].byteLength;\n    const o = new Uint8Array(r);\n    for (o[0] = r &gt;&gt; 24 &amp; 255, o[1] = r &gt;&gt; 16 &amp; 255, o[2] = r &gt;&gt; 8 &amp; 255, o[3] = r &amp; 255, o.set(e, 4), n = 0, r = 8; n &lt; i; n++)\n      o.set(t[n], r), r += t[n].byteLength;\n    return o;\n  }\n  static hdlr(e) {\n    return X.box(X.types.hdlr, X.HDLR_TYPES[e]);\n  }\n  static mdat(e) {\n    return X.box(X.types.mdat, e);\n  }\n  static mdhd(e, t) {\n    t *= e;\n    const r = Math.floor(t / (Ss + 1)), n = Math.floor(t % (Ss + 1));\n    return X.box(X.types.mdhd, new Uint8Array([\n      1,\n      // version 1\n      0,\n      0,\n      0,\n      // flags\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      2,\n      // creation_time\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      3,\n      // modification_time\n      e &gt;&gt; 24 &amp; 255,\n      e &gt;&gt; 16 &amp; 255,\n      e &gt;&gt; 8 &amp; 255,\n      e &amp; 255,\n      // timescale\n      r &gt;&gt; 24,\n      r &gt;&gt; 16 &amp; 255,\n      r &gt;&gt; 8 &amp; 255,\n      r &amp; 255,\n      n &gt;&gt; 24,\n      n &gt;&gt; 16 &amp; 255,\n      n &gt;&gt; 8 &amp; 255,\n      n &amp; 255,\n      85,\n      196,\n      // 'und' language (undetermined)\n      0,\n      0\n    ]));\n  }\n  static mdia(e) {\n    return X.box(X.types.mdia, X.mdhd(e.timescale || 0, e.duration || 0), X.hdlr(e.type), X.minf(e));\n  }\n  static mfhd(e) {\n    return X.box(X.types.mfhd, new Uint8Array([\n      0,\n      0,\n      0,\n      0,\n      // flags\n      e &gt;&gt; 24,\n      e &gt;&gt; 16 &amp; 255,\n      e &gt;&gt; 8 &amp; 255,\n      e &amp; 255\n      // sequence_number\n    ]));\n  }\n  static minf(e) {\n    return e.type === \"audio\" ? X.box(X.types.minf, X.box(X.types.smhd, X.SMHD), X.DINF, X.stbl(e)) : X.box(X.types.minf, X.box(X.types.vmhd, X.VMHD), X.DINF, X.stbl(e));\n  }\n  static moof(e, t, r) {\n    return X.box(X.types.moof, X.mfhd(e), X.traf(r, t));\n  }\n  static moov(e) {\n    let t = e.length;\n    const r = [];\n    for (; t--; )\n      r[t] = X.trak(e[t]);\n    return X.box.apply(null, [X.types.moov, X.mvhd(e[0].timescale || 0, e[0].duration || 0)].concat(r).concat(X.mvex(e)));\n  }\n  static mvex(e) {\n    let t = e.length;\n    const r = [];\n    for (; t--; )\n      r[t] = X.trex(e[t]);\n    return X.box.apply(null, [X.types.mvex, ...r]);\n  }\n  static mvhd(e, t) {\n    t *= e;\n    const r = Math.floor(t / (Ss + 1)), n = Math.floor(t % (Ss + 1)), i = new Uint8Array([\n      1,\n      // version 1\n      0,\n      0,\n      0,\n      // flags\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      2,\n      // creation_time\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      3,\n      // modification_time\n      e &gt;&gt; 24 &amp; 255,\n      e &gt;&gt; 16 &amp; 255,\n      e &gt;&gt; 8 &amp; 255,\n      e &amp; 255,\n      // timescale\n      r &gt;&gt; 24,\n      r &gt;&gt; 16 &amp; 255,\n      r &gt;&gt; 8 &amp; 255,\n      r &amp; 255,\n      n &gt;&gt; 24,\n      n &gt;&gt; 16 &amp; 255,\n      n &gt;&gt; 8 &amp; 255,\n      n &amp; 255,\n      0,\n      1,\n      0,\n      0,\n      // 1.0 rate\n      1,\n      0,\n      // 1.0 volume\n      0,\n      0,\n      // reserved\n      0,\n      0,\n      0,\n      0,\n      // reserved\n      0,\n      0,\n      0,\n      0,\n      // reserved\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      64,\n      0,\n      0,\n      0,\n      // transformation: unity matrix\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      // pre_defined\n      255,\n      255,\n      255,\n      255\n      // next_track_ID\n    ]);\n    return X.box(X.types.mvhd, i);\n  }\n  static sdtp(e) {\n    const t = e.samples || [], r = new Uint8Array(4 + t.length);\n    let n, i;\n    for (n = 0; n &lt; t.length; n++)\n      i = t[n].flags, r[n + 4] = i.dependsOn &lt;&lt; 4 | i.isDependedOn &lt;&lt; 2 | i.hasRedundancy;\n    return X.box(X.types.sdtp, r);\n  }\n  static stbl(e) {\n    return X.box(X.types.stbl, X.stsd(e), X.box(X.types.stts, X.STTS), X.box(X.types.stsc, X.STSC), X.box(X.types.stsz, X.STSZ), X.box(X.types.stco, X.STCO));\n  }\n  static avc1(e) {\n    let t = [], r = [], n, i, o;\n    for (n = 0; n &lt; e.sps.length; n++)\n      i = e.sps[n], o = i.byteLength, t.push(o &gt;&gt;&gt; 8 &amp; 255), t.push(o &amp; 255), t = t.concat(Array.prototype.slice.call(i));\n    for (n = 0; n &lt; e.pps.length; n++)\n      i = e.pps[n], o = i.byteLength, r.push(o &gt;&gt;&gt; 8 &amp; 255), r.push(o &amp; 255), r = r.concat(Array.prototype.slice.call(i));\n    const a = X.box(X.types.avcC, new Uint8Array([\n      1,\n      // version\n      t[3],\n      // profile\n      t[4],\n      // profile compat\n      t[5],\n      // level\n      255,\n      // lengthSizeMinusOne, hard-coded to 4 bytes\n      224 | e.sps.length\n      // 3bit reserved (111) + numOfSequenceParameterSets\n    ].concat(t).concat([\n      e.pps.length\n      // numOfPictureParameterSets\n    ]).concat(r))), l = e.width, c = e.height, u = e.pixelRatio[0], d = e.pixelRatio[1];\n    return X.box(\n      X.types.avc1,\n      new Uint8Array([\n        0,\n        0,\n        0,\n        // reserved\n        0,\n        0,\n        0,\n        // reserved\n        0,\n        1,\n        // data_reference_index\n        0,\n        0,\n        // pre_defined\n        0,\n        0,\n        // reserved\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        // pre_defined\n        l &gt;&gt; 8 &amp; 255,\n        l &amp; 255,\n        // width\n        c &gt;&gt; 8 &amp; 255,\n        c &amp; 255,\n        // height\n        0,\n        72,\n        0,\n        0,\n        // horizresolution\n        0,\n        72,\n        0,\n        0,\n        // vertresolution\n        0,\n        0,\n        0,\n        0,\n        // reserved\n        0,\n        1,\n        // frame_count\n        18,\n        100,\n        97,\n        105,\n        108,\n        // dailymotion/hls.js\n        121,\n        109,\n        111,\n        116,\n        105,\n        111,\n        110,\n        47,\n        104,\n        108,\n        115,\n        46,\n        106,\n        115,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        // compressorname\n        0,\n        24,\n        // depth = 24\n        17,\n        17\n      ]),\n      // pre_defined = -1\n      a,\n      X.box(X.types.btrt, new Uint8Array([\n        0,\n        28,\n        156,\n        128,\n        // bufferSizeDB\n        0,\n        45,\n        198,\n        192,\n        // maxBitrate\n        0,\n        45,\n        198,\n        192\n      ])),\n      // avgBitrate\n      X.box(X.types.pasp, new Uint8Array([\n        u &gt;&gt; 24,\n        // hSpacing\n        u &gt;&gt; 16 &amp; 255,\n        u &gt;&gt; 8 &amp; 255,\n        u &amp; 255,\n        d &gt;&gt; 24,\n        // vSpacing\n        d &gt;&gt; 16 &amp; 255,\n        d &gt;&gt; 8 &amp; 255,\n        d &amp; 255\n      ]))\n    );\n  }\n  static esds(e) {\n    const t = e.config;\n    return new Uint8Array([\n      0,\n      // version 0\n      0,\n      0,\n      0,\n      // flags\n      3,\n      // descriptor_type\n      25,\n      // length\n      0,\n      1,\n      // es_id\n      0,\n      // stream_priority\n      4,\n      // descriptor_type\n      17,\n      // length\n      64,\n      // codec : mpeg4_audio\n      21,\n      // stream_type\n      0,\n      0,\n      0,\n      // buffer_size\n      0,\n      0,\n      0,\n      0,\n      // maxBitrate\n      0,\n      0,\n      0,\n      0,\n      // avgBitrate\n      5,\n      // descriptor_type\n      2,\n      // length\n      ...t,\n      6,\n      1,\n      2\n      // GASpecificConfig)); // length + audio config descriptor\n    ]);\n  }\n  static audioStsd(e) {\n    const t = e.samplerate || 0;\n    return new Uint8Array([\n      0,\n      0,\n      0,\n      // reserved\n      0,\n      0,\n      0,\n      // reserved\n      0,\n      1,\n      // data_reference_index\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      // reserved\n      0,\n      e.channelCount || 0,\n      // channelcount\n      0,\n      16,\n      // sampleSize:16bits\n      0,\n      0,\n      0,\n      0,\n      // reserved2\n      t &gt;&gt; 8 &amp; 255,\n      t &amp; 255,\n      //\n      0,\n      0\n    ]);\n  }\n  static mp4a(e) {\n    return X.box(X.types.mp4a, X.audioStsd(e), X.box(X.types.esds, X.esds(e)));\n  }\n  static mp3(e) {\n    return X.box(X.types[\".mp3\"], X.audioStsd(e));\n  }\n  static ac3(e) {\n    return X.box(X.types[\"ac-3\"], X.audioStsd(e), X.box(X.types.dac3, e.config));\n  }\n  static stsd(e) {\n    const {\n      segmentCodec: t\n    } = e;\n    if (e.type === \"audio\") {\n      if (t === \"aac\")\n        return X.box(X.types.stsd, X.STSD, X.mp4a(e));\n      if (t === \"ac3\" &amp;&amp; e.config)\n        return X.box(X.types.stsd, X.STSD, X.ac3(e));\n      if (t === \"mp3\" &amp;&amp; e.codec === \"mp3\")\n        return X.box(X.types.stsd, X.STSD, X.mp3(e));\n    } else if (e.pps &amp;&amp; e.sps) {\n      if (t === \"avc\")\n        return X.box(X.types.stsd, X.STSD, X.avc1(e));\n      if (t === \"hevc\" &amp;&amp; e.vps)\n        return X.box(X.types.stsd, X.STSD, X.hvc1(e));\n    } else\n      throw new Error(\"video track missing pps or sps\");\n    throw new Error(`unsupported ${e.type} segment codec (${t}/${e.codec})`);\n  }\n  static tkhd(e) {\n    const t = e.id, r = (e.duration || 0) * (e.timescale || 0), n = e.width || 0, i = e.height || 0, o = Math.floor(r / (Ss + 1)), a = Math.floor(r % (Ss + 1));\n    return X.box(X.types.tkhd, new Uint8Array([\n      1,\n      // version 1\n      0,\n      0,\n      7,\n      // flags\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      2,\n      // creation_time\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      3,\n      // modification_time\n      t &gt;&gt; 24 &amp; 255,\n      t &gt;&gt; 16 &amp; 255,\n      t &gt;&gt; 8 &amp; 255,\n      t &amp; 255,\n      // track_ID\n      0,\n      0,\n      0,\n      0,\n      // reserved\n      o &gt;&gt; 24,\n      o &gt;&gt; 16 &amp; 255,\n      o &gt;&gt; 8 &amp; 255,\n      o &amp; 255,\n      a &gt;&gt; 24,\n      a &gt;&gt; 16 &amp; 255,\n      a &gt;&gt; 8 &amp; 255,\n      a &amp; 255,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      // reserved\n      0,\n      0,\n      // layer\n      0,\n      0,\n      // alternate_group\n      0,\n      0,\n      // non-audio track volume\n      0,\n      0,\n      // reserved\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      64,\n      0,\n      0,\n      0,\n      // transformation: unity matrix\n      n &gt;&gt; 8 &amp; 255,\n      n &amp; 255,\n      0,\n      0,\n      // width\n      i &gt;&gt; 8 &amp; 255,\n      i &amp; 255,\n      0,\n      0\n      // height\n    ]));\n  }\n  static traf(e, t) {\n    const r = X.sdtp(e), n = e.id, i = Math.floor(t / (Ss + 1)), o = Math.floor(t % (Ss + 1));\n    return X.box(\n      X.types.traf,\n      X.box(X.types.tfhd, new Uint8Array([\n        0,\n        // version 0\n        0,\n        0,\n        0,\n        // flags\n        n &gt;&gt; 24,\n        n &gt;&gt; 16 &amp; 255,\n        n &gt;&gt; 8 &amp; 255,\n        n &amp; 255\n        // track_ID\n      ])),\n      X.box(X.types.tfdt, new Uint8Array([\n        1,\n        // version 1\n        0,\n        0,\n        0,\n        // flags\n        i &gt;&gt; 24,\n        i &gt;&gt; 16 &amp; 255,\n        i &gt;&gt; 8 &amp; 255,\n        i &amp; 255,\n        o &gt;&gt; 24,\n        o &gt;&gt; 16 &amp; 255,\n        o &gt;&gt; 8 &amp; 255,\n        o &amp; 255\n      ])),\n      X.trun(e, r.length + 16 + // tfhd\n      20 + // tfdt\n      8 + // traf header\n      16 + // mfhd\n      8 + // moof header\n      8),\n      // mdat header\n      r\n    );\n  }\n  /**\n   * Generate a track box.\n   * @param track a track definition\n   */\n  static trak(e) {\n    return e.duration = e.duration || 4294967295, X.box(X.types.trak, X.tkhd(e), X.mdia(e));\n  }\n  static trex(e) {\n    const t = e.id;\n    return X.box(X.types.trex, new Uint8Array([\n      0,\n      // version 0\n      0,\n      0,\n      0,\n      // flags\n      t &gt;&gt; 24,\n      t &gt;&gt; 16 &amp; 255,\n      t &gt;&gt; 8 &amp; 255,\n      t &amp; 255,\n      // track_ID\n      0,\n      0,\n      0,\n      1,\n      // default_sample_description_index\n      0,\n      0,\n      0,\n      0,\n      // default_sample_duration\n      0,\n      0,\n      0,\n      0,\n      // default_sample_size\n      0,\n      1,\n      0,\n      1\n      // default_sample_flags\n    ]));\n  }\n  static trun(e, t) {\n    const r = e.samples || [], n = r.length, i = 12 + 16 * n, o = new Uint8Array(i);\n    let a, l, c, u, d, h;\n    for (t += 8 + i, o.set([\n      e.type === \"video\" ? 1 : 0,\n      // version 1 for video with signed-int sample_composition_time_offset\n      0,\n      15,\n      1,\n      // flags\n      n &gt;&gt;&gt; 24 &amp; 255,\n      n &gt;&gt;&gt; 16 &amp; 255,\n      n &gt;&gt;&gt; 8 &amp; 255,\n      n &amp; 255,\n      // sample_count\n      t &gt;&gt;&gt; 24 &amp; 255,\n      t &gt;&gt;&gt; 16 &amp; 255,\n      t &gt;&gt;&gt; 8 &amp; 255,\n      t &amp; 255\n      // data_offset\n    ], 0), a = 0; a &lt; n; a++)\n      l = r[a], c = l.duration, u = l.size, d = l.flags, h = l.cts, o.set([\n        c &gt;&gt;&gt; 24 &amp; 255,\n        c &gt;&gt;&gt; 16 &amp; 255,\n        c &gt;&gt;&gt; 8 &amp; 255,\n        c &amp; 255,\n        // sample_duration\n        u &gt;&gt;&gt; 24 &amp; 255,\n        u &gt;&gt;&gt; 16 &amp; 255,\n        u &gt;&gt;&gt; 8 &amp; 255,\n        u &amp; 255,\n        // sample_size\n        d.isLeading &lt;&lt; 2 | d.dependsOn,\n        d.isDependedOn &lt;&lt; 6 | d.hasRedundancy &lt;&lt; 4 | d.paddingValue &lt;&lt; 1 | d.isNonSync,\n        d.degradPrio &amp; 61440,\n        d.degradPrio &amp; 15,\n        // sample_flags\n        h &gt;&gt;&gt; 24 &amp; 255,\n        h &gt;&gt;&gt; 16 &amp; 255,\n        h &gt;&gt;&gt; 8 &amp; 255,\n        h &amp; 255\n        // sample_composition_time_offset\n      ], 12 + 16 * a);\n    return X.box(X.types.trun, o);\n  }\n  static initSegment(e) {\n    X.types || X.init();\n    const t = X.moov(e);\n    return _r(X.FTYP, t);\n  }\n  static hvc1(e) {\n    const t = e.params, r = [e.vps, e.sps, e.pps], n = 4, i = new Uint8Array([1, t.general_profile_space &lt;&lt; 6 | (t.general_tier_flag ? 32 : 0) | t.general_profile_idc, t.general_profile_compatibility_flags[0], t.general_profile_compatibility_flags[1], t.general_profile_compatibility_flags[2], t.general_profile_compatibility_flags[3], t.general_constraint_indicator_flags[0], t.general_constraint_indicator_flags[1], t.general_constraint_indicator_flags[2], t.general_constraint_indicator_flags[3], t.general_constraint_indicator_flags[4], t.general_constraint_indicator_flags[5], t.general_level_idc, 240 | t.min_spatial_segmentation_idc &gt;&gt; 8, 255 &amp; t.min_spatial_segmentation_idc, 252 | t.parallelismType, 252 | t.chroma_format_idc, 248 | t.bit_depth_luma_minus8, 248 | t.bit_depth_chroma_minus8, 0, parseInt(t.frame_rate.fps), n - 1 | t.temporal_id_nested &lt;&lt; 2 | t.num_temporal_layers &lt;&lt; 3 | (t.frame_rate.fixed ? 64 : 0), r.length]);\n    let o = i.length;\n    for (let p = 0; p &lt; r.length; p += 1) {\n      o += 3;\n      for (let y = 0; y &lt; r[p].length; y += 1)\n        o += 2 + r[p][y].length;\n    }\n    const a = new Uint8Array(o);\n    a.set(i, 0), o = i.length;\n    const l = r.length - 1;\n    for (let p = 0; p &lt; r.length; p += 1) {\n      a.set(new Uint8Array([32 + p | (p === l ? 128 : 0), 0, r[p].length]), o), o += 3;\n      for (let y = 0; y &lt; r[p].length; y += 1)\n        a.set(new Uint8Array([r[p][y].length &gt;&gt; 8, r[p][y].length &amp; 255]), o), o += 2, a.set(r[p][y], o), o += r[p][y].length;\n    }\n    const c = X.box(X.types.hvcC, a), u = e.width, d = e.height, h = e.pixelRatio[0], f = e.pixelRatio[1];\n    return X.box(\n      X.types.hvc1,\n      new Uint8Array([\n        0,\n        0,\n        0,\n        // reserved\n        0,\n        0,\n        0,\n        // reserved\n        0,\n        1,\n        // data_reference_index\n        0,\n        0,\n        // pre_defined\n        0,\n        0,\n        // reserved\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        // pre_defined\n        u &gt;&gt; 8 &amp; 255,\n        u &amp; 255,\n        // width\n        d &gt;&gt; 8 &amp; 255,\n        d &amp; 255,\n        // height\n        0,\n        72,\n        0,\n        0,\n        // horizresolution\n        0,\n        72,\n        0,\n        0,\n        // vertresolution\n        0,\n        0,\n        0,\n        0,\n        // reserved\n        0,\n        1,\n        // frame_count\n        18,\n        100,\n        97,\n        105,\n        108,\n        // dailymotion/hls.js\n        121,\n        109,\n        111,\n        116,\n        105,\n        111,\n        110,\n        47,\n        104,\n        108,\n        115,\n        46,\n        106,\n        115,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        0,\n        // compressorname\n        0,\n        24,\n        // depth = 24\n        17,\n        17\n      ]),\n      // pre_defined = -1\n      c,\n      X.box(X.types.btrt, new Uint8Array([\n        0,\n        28,\n        156,\n        128,\n        // bufferSizeDB\n        0,\n        45,\n        198,\n        192,\n        // maxBitrate\n        0,\n        45,\n        198,\n        192\n      ])),\n      // avgBitrate\n      X.box(X.types.pasp, new Uint8Array([\n        h &gt;&gt; 24,\n        // hSpacing\n        h &gt;&gt; 16 &amp; 255,\n        h &gt;&gt; 8 &amp; 255,\n        h &amp; 255,\n        f &gt;&gt; 24,\n        // vSpacing\n        f &gt;&gt; 16 &amp; 255,\n        f &gt;&gt; 8 &amp; 255,\n        f &amp; 255\n      ]))\n    );\n  }\n}\nX.types = void 0;\nX.HDLR_TYPES = void 0;\nX.STTS = void 0;\nX.STSC = void 0;\nX.STCO = void 0;\nX.STSZ = void 0;\nX.VMHD = void 0;\nX.SMHD = void 0;\nX.STSD = void 0;\nX.FTYP = void 0;\nX.DINF = void 0;\nconst Sp = 9e4;\nfunction Cu(s, e, t = 1, r = !1) {\n  const n = s * e * t;\n  return r ? Math.round(n) : n;\n}\nfunction qT(s, e, t = 1, r = !1) {\n  return Cu(s, e, 1 / t, r);\n}\nfunction qn(s, e = !1) {\n  return Cu(s, 1e3, 1 / Sp, e);\n}\nfunction WT(s, e = 1) {\n  return Cu(s, Sp, 1 / e);\n}\nconst zT = 10 * 1e3, YT = 1024, ZT = 1152, XT = 1536;\nlet pn = null, El = null;\nfunction Uh(s, e, t, r) {\n  return {\n    duration: e,\n    size: t,\n    cts: r,\n    flags: {\n      isLeading: 0,\n      isDependedOn: 0,\n      hasRedundancy: 0,\n      degradPrio: 0,\n      dependsOn: s ? 2 : 1,\n      isNonSync: s ? 0 : 1\n    }\n  };\n}\nclass mo extends Lr {\n  constructor(e, t, r, n) {\n    if (super(\"mp4-remuxer\", n), this.observer = void 0, this.config = void 0, this.typeSupported = void 0, this.ISGenerated = !1, this._initPTS = null, this._initDTS = null, this.nextVideoTs = null, this.nextAudioTs = null, this.videoSampleDuration = null, this.isAudioContiguous = !1, this.isVideoContiguous = !1, this.videoTrackConfig = void 0, this.observer = e, this.config = t, this.typeSupported = r, this.ISGenerated = !1, pn === null) {\n      const o = (navigator.userAgent || \"\").match(/Chrome\\/(\\d+)/i);\n      pn = o ? parseInt(o[1]) : 0;\n    }\n    if (El === null) {\n      const i = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n      El = i ? parseInt(i[1]) : 0;\n    }\n  }\n  destroy() {\n    this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;\n  }\n  resetTimeStamp(e) {\n    this.log(\"initPTS &amp; initDTS reset\"), this._initPTS = this._initDTS = e;\n  }\n  resetNextTimestamp() {\n    this.log(\"reset next timestamp\"), this.isVideoContiguous = !1, this.isAudioContiguous = !1;\n  }\n  resetInitSegment() {\n    this.log(\"ISGenerated flag reset\"), this.ISGenerated = !1, this.videoTrackConfig = void 0;\n  }\n  getVideoStartPts(e) {\n    let t = !1;\n    const r = e[0].pts, n = e.reduce((i, o) =&gt; {\n      let a = o.pts, l = a - i;\n      return l &lt; -4294967296 &amp;&amp; (t = !0, a = Ar(a, r), l = a - i), l &gt; 0 ? i : a;\n    }, r);\n    return t &amp;&amp; this.debug(\"PTS rollover detected\"), n;\n  }\n  remux(e, t, r, n, i, o, a, l) {\n    let c, u, d, h, f, p, y = i, E = i;\n    const b = e.pid &gt; -1, R = t.pid &gt; -1, A = t.samples.length, F = e.samples.length &gt; 0, M = a &amp;&amp; A &gt; 0 || A &gt; 1;\n    if ((!b || F) &amp;&amp; (!R || M) || this.ISGenerated || a) {\n      if (this.ISGenerated) {\n        var K, j, C, k;\n        const g = this.videoTrackConfig;\n        (g &amp;&amp; (t.width !== g.width || t.height !== g.height || ((K = t.pixelRatio) == null ? void 0 : K[0]) !== ((j = g.pixelRatio) == null ? void 0 : j[0]) || ((C = t.pixelRatio) == null ? void 0 : C[1]) !== ((k = g.pixelRatio) == null ? void 0 : k[1])) || !g &amp;&amp; M || this.nextAudioTs === null &amp;&amp; F) &amp;&amp; this.resetInitSegment();\n      }\n      this.ISGenerated || (d = this.generateIS(e, t, i, o));\n      const $ = this.isVideoContiguous;\n      let W = -1, _;\n      if (M &amp;&amp; (W = JT(t.samples), !$ &amp;&amp; this.config.forceKeyFrameOnDiscontinuity))\n        if (p = !0, W &gt; 0) {\n          this.warn(`Dropped ${W} out of ${A} video samples due to a missing keyframe`);\n          const g = this.getVideoStartPts(t.samples);\n          t.samples = t.samples.slice(W), t.dropped += W, E += (t.samples[0].pts - g) / t.inputTimeScale, _ = E;\n        } else W === -1 &amp;&amp; (this.warn(`No keyframe found out of ${A} video samples`), p = !1);\n      if (this.ISGenerated) {\n        if (F &amp;&amp; M) {\n          const g = this.getVideoStartPts(t.samples), w = (Ar(e.samples[0].pts, g) - g) / t.inputTimeScale;\n          y += Math.max(0, w), E += Math.max(0, -w);\n        }\n        if (F) {\n          if (e.samplerate || (this.warn(\"regenerate InitSegment as audio detected\"), d = this.generateIS(e, t, i, o)), u = this.remuxAudio(e, y, this.isAudioContiguous, o, R || M || l === pe.AUDIO ? E : void 0), M) {\n            const g = u ? u.endPTS - u.startPTS : 0;\n            t.inputTimeScale || (this.warn(\"regenerate InitSegment as video detected\"), d = this.generateIS(e, t, i, o)), c = this.remuxVideo(t, E, $, g);\n          }\n        } else M &amp;&amp; (c = this.remuxVideo(t, E, $, 0));\n        c &amp;&amp; (c.firstKeyFrame = W, c.independent = W !== -1, c.firstKeyFramePTS = _);\n      }\n    }\n    return this.ISGenerated &amp;&amp; this._initPTS &amp;&amp; this._initDTS &amp;&amp; (r.samples.length &amp;&amp; (f = bp(r, i, this._initPTS, this._initDTS)), n.samples.length &amp;&amp; (h = Tp(n, i, this._initPTS))), {\n      audio: u,\n      video: c,\n      initSegment: d,\n      independent: p,\n      text: h,\n      id3: f\n    };\n  }\n  generateIS(e, t, r, n) {\n    const i = e.samples, o = t.samples, a = this.typeSupported, l = {}, c = this._initPTS;\n    let u = !c || n, d = \"audio/mp4\", h, f, p, y = -1;\n    if (u &amp;&amp; (h = f = 1 / 0), e.config &amp;&amp; i.length) {\n      switch (e.timescale = e.samplerate, e.segmentCodec) {\n        case \"mp3\":\n          a.mpeg ? (d = \"audio/mpeg\", e.codec = \"\") : a.mp3 &amp;&amp; (e.codec = \"mp3\");\n          break;\n        case \"ac3\":\n          e.codec = \"ac-3\";\n          break;\n      }\n      l.audio = {\n        id: \"audio\",\n        container: d,\n        codec: e.codec,\n        initSegment: e.segmentCodec === \"mp3\" &amp;&amp; a.mpeg ? new Uint8Array(0) : X.initSegment([e]),\n        metadata: {\n          channelCount: e.channelCount\n        }\n      }, u &amp;&amp; (y = e.id, p = e.inputTimeScale, !c || p !== c.timescale ? h = f = i[0].pts - Math.round(p * r) : u = !1);\n    }\n    if (t.sps &amp;&amp; t.pps &amp;&amp; o.length) {\n      if (t.timescale = t.inputTimeScale, l.video = {\n        id: \"main\",\n        container: \"video/mp4\",\n        codec: t.codec,\n        initSegment: X.initSegment([t]),\n        metadata: {\n          width: t.width,\n          height: t.height\n        }\n      }, u)\n        if (y = t.id, p = t.inputTimeScale, !c || p !== c.timescale) {\n          const E = this.getVideoStartPts(o), b = Math.round(p * r);\n          f = Math.min(f, Ar(o[0].dts, E) - b), h = Math.min(h, E - b);\n        } else\n          u = !1;\n      this.videoTrackConfig = {\n        width: t.width,\n        height: t.height,\n        pixelRatio: t.pixelRatio\n      };\n    }\n    if (Object.keys(l).length)\n      return this.ISGenerated = !0, u ? (c &amp;&amp; this.warn(`Timestamps at playlist time: ${n ? \"\" : \"~\"}${r} ${h / p} != initPTS: ${c.baseTime / c.timescale} (${c.baseTime}/${c.timescale}) trackId: ${c.trackId}`), this.log(`Found initPTS at playlist time: ${r} offset: ${h / p} (${h}/${p}) trackId: ${y}`), this._initPTS = {\n        baseTime: h,\n        timescale: p,\n        trackId: y\n      }, this._initDTS = {\n        baseTime: f,\n        timescale: p,\n        trackId: y\n      }) : h = p = void 0, {\n        tracks: l,\n        initPTS: h,\n        timescale: p,\n        trackId: y\n      };\n  }\n  remuxVideo(e, t, r, n) {\n    const i = e.inputTimeScale, o = e.samples, a = [], l = o.length, c = this._initPTS, u = c.baseTime * i / c.timescale;\n    let d = this.nextVideoTs, h = 8, f = this.videoSampleDuration, p, y, E = Number.POSITIVE_INFINITY, b = Number.NEGATIVE_INFINITY, R = !1;\n    if (!r || d === null) {\n      const L = u + t * i, m = o[0].pts - Ar(o[0].dts, o[0].pts);\n      pn &amp;&amp; d !== null &amp;&amp; Math.abs(L - m - (d + u)) &lt; 15e3 ? r = !0 : d = L - m - u;\n    }\n    const A = d + u;\n    for (let L = 0; L &lt; l; L++) {\n      const m = o[L];\n      m.pts = Ar(m.pts, A), m.dts = Ar(m.dts, A), m.dts &lt; o[L &gt; 0 ? L - 1 : L].dts &amp;&amp; (R = !0);\n    }\n    R &amp;&amp; o.sort(function(L, m) {\n      const v = L.dts - m.dts, P = L.pts - m.pts;\n      return v || P;\n    }), p = o[0].dts, y = o[o.length - 1].dts;\n    const F = y - p, M = F ? Math.round(F / (l - 1)) : f || e.inputTimeScale / 30;\n    if (r) {\n      const L = p - A, m = L &gt; M, v = L &lt; -1;\n      if ((m || v) &amp;&amp; (m ? this.warn(`${(e.segmentCodec || \"\").toUpperCase()}: ${qn(L, !0)} ms (${L}dts) hole between fragments detected at ${t.toFixed(3)}`) : this.warn(`${(e.segmentCodec || \"\").toUpperCase()}: ${qn(-L, !0)} ms (${L}dts) overlapping between fragments detected at ${t.toFixed(3)}`), !v || A &gt;= o[0].pts || pn)) {\n        p = A;\n        const P = o[0].pts - L;\n        if (m)\n          o[0].dts = p, o[0].pts = P;\n        else {\n          let N = !0;\n          for (let Y = 0; Y &lt; o.length &amp;&amp; !(o[Y].dts &gt; P &amp;&amp; N); Y++) {\n            const ee = o[Y].pts;\n            if (o[Y].dts -= L, o[Y].pts -= L, Y &lt; o.length - 1) {\n              const ie = o[Y + 1].pts, le = o[Y].pts, Te = ie &lt;= le, De = ie &lt;= ee;\n              N = Te == De;\n            }\n          }\n        }\n        this.log(`Video: Initial PTS/DTS adjusted: ${qn(P, !0)}/${qn(p, !0)}, delta: ${qn(L, !0)} ms`);\n      }\n    }\n    p = Math.max(0, p);\n    let H = 0, K = 0, j = p;\n    for (let L = 0; L &lt; l; L++) {\n      const m = o[L], v = m.units, P = v.length;\n      let N = 0;\n      for (let Y = 0; Y &lt; P; Y++)\n        N += v[Y].data.length;\n      K += N, H += P, m.length = N, m.dts &lt; j ? (m.dts = j, j += M / 4 | 0 || 1) : j = m.dts, E = Math.min(m.pts, E), b = Math.max(m.pts, b);\n    }\n    y = o[l - 1].dts;\n    const C = K + 4 * H + 8;\n    let k;\n    try {\n      k = new Uint8Array(C);\n    } catch (L) {\n      this.observer.emit(I.ERROR, I.ERROR, {\n        type: ve.MUX_ERROR,\n        details: J.REMUX_ALLOC_ERROR,\n        fatal: !1,\n        error: L,\n        bytes: C,\n        reason: `fail allocating video mdat ${C}`\n      });\n      return;\n    }\n    const $ = new DataView(k.buffer);\n    $.setUint32(0, C), k.set(X.types.mdat, 4);\n    let W = !1, _ = Number.POSITIVE_INFINITY, g = Number.POSITIVE_INFINITY, x = Number.NEGATIVE_INFINITY, w = Number.NEGATIVE_INFINITY;\n    for (let L = 0; L &lt; l; L++) {\n      const m = o[L], v = m.units;\n      let P = 0;\n      for (let ee = 0, ie = v.length; ee &lt; ie; ee++) {\n        const le = v[ee], Te = le.data, De = le.data.byteLength;\n        $.setUint32(h, De), h += 4, k.set(Te, h), h += De, P += 4 + De;\n      }\n      let N;\n      if (L &lt; l - 1)\n        f = o[L + 1].dts - m.dts, N = o[L + 1].pts - m.pts;\n      else {\n        const ee = this.config, ie = L &gt; 0 ? m.dts - o[L - 1].dts : M;\n        if (N = L &gt; 0 ? m.pts - o[L - 1].pts : M, ee.stretchShortVideoTrack &amp;&amp; this.nextAudioTs !== null) {\n          const le = Math.floor(ee.maxBufferHole * i), Te = (n ? E + n * i : this.nextAudioTs + u) - m.pts;\n          Te &gt; le ? (f = Te - ie, f &lt; 0 ? f = ie : W = !0, this.log(`It is approximately ${Te / 90} ms to the next segment; using duration ${f / 90} ms for the last video frame.`)) : f = ie;\n        } else\n          f = ie;\n      }\n      const Y = Math.round(m.pts - m.dts);\n      _ = Math.min(_, f), x = Math.max(x, f), g = Math.min(g, N), w = Math.max(w, N), a.push(Uh(m.key, f, P, Y));\n    }\n    if (a.length) {\n      if (pn) {\n        if (pn &lt; 70) {\n          const L = a[0].flags;\n          L.dependsOn = 2, L.isNonSync = 0;\n        }\n      } else if (El &amp;&amp; w - g &lt; x - _ &amp;&amp; M / x &lt; 0.025 &amp;&amp; a[0].cts === 0) {\n        this.warn(\"Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.\");\n        let L = p;\n        for (let m = 0, v = a.length; m &lt; v; m++) {\n          const P = L + a[m].duration, N = L + a[m].cts;\n          if (m &lt; v - 1) {\n            const Y = P + a[m + 1].cts;\n            a[m].duration = Y - N;\n          } else\n            a[m].duration = m ? a[m - 1].duration : M;\n          a[m].cts = 0, L = P;\n        }\n      }\n    }\n    f = W || !f ? M : f;\n    const D = y + f;\n    this.nextVideoTs = d = D - u, this.videoSampleDuration = f, this.isVideoContiguous = !0;\n    const V = {\n      data1: X.moof(e.sequenceNumber++, p, nt(e, {\n        samples: a\n      })),\n      data2: k,\n      startPTS: (E - u) / i,\n      endPTS: (b + f - u) / i,\n      startDTS: (p - u) / i,\n      endDTS: d / i,\n      type: \"video\",\n      hasAudio: !1,\n      hasVideo: !0,\n      nb: a.length,\n      dropped: e.dropped\n    };\n    return e.samples = [], e.dropped = 0, V;\n  }\n  getSamplesPerFrame(e) {\n    switch (e.segmentCodec) {\n      case \"mp3\":\n        return ZT;\n      case \"ac3\":\n        return XT;\n      default:\n        return YT;\n    }\n  }\n  remuxAudio(e, t, r, n, i) {\n    const o = e.inputTimeScale, a = e.samplerate ? e.samplerate : o, l = o / a, c = this.getSamplesPerFrame(e), u = c * l, d = this._initPTS, h = e.segmentCodec === \"mp3\" &amp;&amp; this.typeSupported.mpeg, f = [], p = i !== void 0;\n    let y = e.samples, E = h ? 0 : 8, b = this.nextAudioTs || -1;\n    const R = d.baseTime * o / d.timescale, A = R + t * o;\n    if (this.isAudioContiguous = r = r || y.length &amp;&amp; b &gt; 0 &amp;&amp; (n &amp;&amp; Math.abs(A - (b + R)) &lt; 9e3 || Math.abs(Ar(y[0].pts, A) - (b + R)) &lt; 20 * u), y.forEach(function(w) {\n      w.pts = Ar(w.pts, A);\n    }), !r || b &lt; 0) {\n      if (y = y.filter((w) =&gt; w.pts &gt;= 0), !y.length)\n        return;\n      i === 0 ? b = 0 : n &amp;&amp; !p ? b = Math.max(0, A - R) : b = y[0].pts - R;\n    }\n    if (e.segmentCodec === \"aac\") {\n      const w = this.config.maxAudioFramesDrift;\n      for (let D = 0, O = b + R; D &lt; y.length; D++) {\n        const U = y[D], V = U.pts, L = V - O, m = Math.abs(1e3 * L / o);\n        if (L &lt;= -w * u &amp;&amp; p)\n          D === 0 &amp;&amp; (this.warn(`Audio frame @ ${(V / o).toFixed(3)}s overlaps marker by ${Math.round(1e3 * L / o)} ms.`), this.nextAudioTs = b = V - R, O = V);\n        else if (L &gt;= w * u &amp;&amp; m &lt; zT &amp;&amp; p) {\n          let v = Math.round(L / u);\n          for (O = V - v * u; O &lt; 0 &amp;&amp; v &amp;&amp; u; )\n            v--, O += u;\n          D === 0 &amp;&amp; (this.nextAudioTs = b = O - R), this.warn(`Injecting ${v} audio frames @ ${((O - R) / o).toFixed(3)}s due to ${Math.round(1e3 * L / o)} ms gap.`);\n          for (let P = 0; P &lt; v; P++) {\n            let N = HT.getSilentFrame(e.parsedCodec || e.manifestCodec || e.codec, e.channelCount);\n            N || (this.log(\"Unable to get silent frame for given audio codec; duplicating last frame instead.\"), N = U.unit.subarray()), y.splice(D, 0, {\n              unit: N,\n              pts: O\n            }), O += u, D++;\n          }\n        }\n        U.pts = O, O += u;\n      }\n    }\n    let F = null, M = null, H, K = 0, j = y.length;\n    for (; j--; )\n      K += y[j].unit.byteLength;\n    for (let w = 0, D = y.length; w &lt; D; w++) {\n      const O = y[w], U = O.unit;\n      let V = O.pts;\n      if (M !== null) {\n        const m = f[w - 1];\n        m.duration = Math.round((V - M) / l);\n      } else if (r &amp;&amp; e.segmentCodec === \"aac\" &amp;&amp; (V = b + R), F = V, K &gt; 0) {\n        K += E;\n        try {\n          H = new Uint8Array(K);\n        } catch (m) {\n          this.observer.emit(I.ERROR, I.ERROR, {\n            type: ve.MUX_ERROR,\n            details: J.REMUX_ALLOC_ERROR,\n            fatal: !1,\n            error: m,\n            bytes: K,\n            reason: `fail allocating audio mdat ${K}`\n          });\n          return;\n        }\n        h || (new DataView(H.buffer).setUint32(0, K), H.set(X.types.mdat, 4));\n      } else\n        return;\n      H.set(U, E);\n      const L = U.byteLength;\n      E += L, f.push(Uh(!0, c, L, 0)), M = V;\n    }\n    const C = f.length;\n    if (!C)\n      return;\n    const k = f[f.length - 1];\n    b = M - R, this.nextAudioTs = b + l * k.duration;\n    const $ = h ? new Uint8Array(0) : X.moof(e.sequenceNumber++, F / l, nt({}, e, {\n      samples: f\n    }));\n    e.samples = [];\n    const W = (F - R) / o, _ = b / o, x = {\n      data1: $,\n      data2: H,\n      startPTS: W,\n      endPTS: _,\n      startDTS: W,\n      endDTS: _,\n      type: \"audio\",\n      hasAudio: !0,\n      hasVideo: !1,\n      nb: C\n    };\n    return this.isAudioContiguous = !0, x;\n  }\n}\nfunction Ar(s, e) {\n  let t;\n  if (e === null)\n    return s;\n  for (e &lt; s ? t = -8589934592 : t = 8589934592; Math.abs(s - e) &gt; 4294967296; )\n    s += t;\n  return s;\n}\nfunction JT(s) {\n  for (let e = 0; e &lt; s.length; e++)\n    if (s[e].key)\n      return e;\n  return -1;\n}\nfunction bp(s, e, t, r) {\n  const n = s.samples.length;\n  if (!n)\n    return;\n  const i = s.inputTimeScale;\n  for (let a = 0; a &lt; n; a++) {\n    const l = s.samples[a];\n    l.pts = Ar(l.pts - t.baseTime * i / t.timescale, e * i) / i, l.dts = Ar(l.dts - r.baseTime * i / r.timescale, e * i) / i;\n  }\n  const o = s.samples;\n  return s.samples = [], {\n    samples: o\n  };\n}\nfunction Tp(s, e, t) {\n  const r = s.samples.length;\n  if (!r)\n    return;\n  const n = s.inputTimeScale;\n  for (let o = 0; o &lt; r; o++) {\n    const a = s.samples[o];\n    a.pts = Ar(a.pts - t.baseTime * n / t.timescale, e * n) / n;\n  }\n  s.samples.sort((o, a) =&gt; o.pts - a.pts);\n  const i = s.samples;\n  return s.samples = [], {\n    samples: i\n  };\n}\nclass QT extends Lr {\n  constructor(e, t, r, n) {\n    super(\"passthrough-remuxer\", n), this.emitInitSegment = !1, this.audioCodec = void 0, this.videoCodec = void 0, this.initData = void 0, this.initPTS = null, this.initTracks = void 0, this.lastEndTime = null, this.isVideoContiguous = !1;\n  }\n  destroy() {\n  }\n  resetTimeStamp(e) {\n    this.lastEndTime = null;\n    const t = this.initPTS;\n    t &amp;&amp; e &amp;&amp; t.baseTime === e.baseTime &amp;&amp; t.timescale === e.timescale || (this.initPTS = e);\n  }\n  resetNextTimestamp() {\n    this.isVideoContiguous = !1, this.lastEndTime = null;\n  }\n  resetInitSegment(e, t, r, n) {\n    this.audioCodec = t, this.videoCodec = r, this.generateInitSegment(e, n), this.emitInitSegment = !0;\n  }\n  generateInitSegment(e, t) {\n    let {\n      audioCodec: r,\n      videoCodec: n\n    } = this;\n    if (!(e != null &amp;&amp; e.byteLength)) {\n      this.initTracks = void 0, this.initData = void 0;\n      return;\n    }\n    const {\n      audio: i,\n      video: o\n    } = this.initData = Dg(e);\n    if (t)\n      $S(e, t);\n    else {\n      const l = i || o;\n      l != null &amp;&amp; l.encrypted &amp;&amp; this.warn(`Init segment with encrypted track with has no key (\"${l.codec}\")!`);\n    }\n    i &amp;&amp; (r = $h(i, ot.AUDIO, this)), o &amp;&amp; (n = $h(o, ot.VIDEO, this));\n    const a = {};\n    i &amp;&amp; o ? a.audiovideo = {\n      container: \"video/mp4\",\n      codec: r + \",\" + n,\n      supplemental: o.supplemental,\n      encrypted: o.encrypted,\n      initSegment: e,\n      id: \"main\"\n    } : i ? a.audio = {\n      container: \"audio/mp4\",\n      codec: r,\n      encrypted: i.encrypted,\n      initSegment: e,\n      id: \"audio\"\n    } : o ? a.video = {\n      container: \"video/mp4\",\n      codec: n,\n      supplemental: o.supplemental,\n      encrypted: o.encrypted,\n      initSegment: e,\n      id: \"main\"\n    } : this.warn(\"initSegment does not contain moov or trak boxes.\"), this.initTracks = a;\n  }\n  remux(e, t, r, n, i, o) {\n    var a, l;\n    let {\n      initPTS: c,\n      lastEndTime: u\n    } = this;\n    const d = {\n      audio: void 0,\n      video: void 0,\n      text: n,\n      id3: r,\n      initSegment: void 0\n    };\n    ue(u) || (u = this.lastEndTime = i || 0);\n    const h = t.samples;\n    if (!h.length)\n      return d;\n    const f = {\n      initPTS: void 0,\n      timescale: void 0,\n      trackId: void 0\n    };\n    let p = this.initData;\n    if ((a = p) != null &amp;&amp; a.length || (this.generateInitSegment(h), p = this.initData), !((l = p) != null &amp;&amp; l.length))\n      return this.warn(\"Failed to generate initSegment.\"), d;\n    this.emitInitSegment &amp;&amp; (f.tracks = this.initTracks, this.emitInitSegment = !1);\n    const y = GS(h, p, this), E = p.audio ? y[p.audio.id] : null, b = p.video ? y[p.video.id] : null, R = Zi(b, 1 / 0), A = Zi(E, 1 / 0), F = Zi(b, 0, !0), M = Zi(E, 0, !0);\n    let H = i, K = 0;\n    const j = E &amp;&amp; (!b || !c &amp;&amp; A &lt; R || c &amp;&amp; c.trackId === p.audio.id), C = j ? E : b;\n    if (C) {\n      const O = C.timescale, U = C.start - i * O, V = j ? p.audio.id : p.video.id;\n      H = C.start / O, K = j ? M - A : F - R, (o || !c) &amp;&amp; (e2(c, H, i, K) || O !== c.timescale) &amp;&amp; (c &amp;&amp; this.warn(`Timestamps at playlist time: ${o ? \"\" : \"~\"}${i} ${U / O} != initPTS: ${c.baseTime / c.timescale} (${c.baseTime}/${c.timescale}) trackId: ${c.trackId}`), this.log(`Found initPTS at playlist time: ${i} offset: ${H - i} (${U}/${O}) trackId: ${V}`), c = null, f.initPTS = U, f.timescale = O, f.trackId = V);\n    } else\n      this.warn(`No audio or video samples found for initPTS at playlist time: ${i}`);\n    c ? (f.initPTS = c.baseTime, f.timescale = c.timescale, f.trackId = c.trackId) : ((!f.timescale || f.trackId === void 0 || f.initPTS === void 0) &amp;&amp; (this.warn(\"Could not set initPTS\"), f.initPTS = H, f.timescale = 1, f.trackId = -1), this.initPTS = c = {\n      baseTime: f.initPTS,\n      timescale: f.timescale,\n      trackId: f.trackId\n    });\n    const k = H - c.baseTime / c.timescale, $ = k + K;\n    K &gt; 0 ? this.lastEndTime = $ : (this.warn(\"Duration parsed from mp4 should be greater than zero\"), this.resetNextTimestamp());\n    const W = !!p.audio, _ = !!p.video;\n    let g = \"\";\n    W &amp;&amp; (g += \"audio\"), _ &amp;&amp; (g += \"video\");\n    const x = (p.audio ? p.audio.encrypted : !1) || (p.video ? p.video.encrypted : !1), w = {\n      data1: h,\n      startPTS: k,\n      startDTS: k,\n      endPTS: $,\n      endDTS: $,\n      type: g,\n      hasAudio: W,\n      hasVideo: _,\n      nb: 1,\n      dropped: 0,\n      encrypted: x\n    };\n    d.audio = W &amp;&amp; !_ ? w : void 0, d.video = _ ? w : void 0;\n    const D = b == null ? void 0 : b.sampleCount;\n    if (D) {\n      const O = b.keyFrameIndex, U = O !== -1;\n      w.nb = D, w.dropped = O === 0 || this.isVideoContiguous ? 0 : U ? O : D, w.independent = U, w.firstKeyFrame = O, U &amp;&amp; b.keyFrameStart &amp;&amp; (w.firstKeyFramePTS = (b.keyFrameStart - c.baseTime) / c.timescale), this.isVideoContiguous || (d.independent = U), this.isVideoContiguous || (this.isVideoContiguous = U), w.dropped &amp;&amp; this.warn(`fmp4 does not start with IDR: firstIDR ${O}/${D} dropped: ${w.dropped} start: ${w.firstKeyFramePTS || \"NA\"}`);\n    }\n    return d.initSegment = f, d.id3 = bp(r, i, c, c), n.samples.length &amp;&amp; (d.text = Tp(n, i, c)), d;\n  }\n}\nfunction Zi(s, e, t = !1) {\n  return (s == null ? void 0 : s.start) !== void 0 ? (s.start + (t ? s.duration : 0)) / s.timescale : e;\n}\nfunction e2(s, e, t, r) {\n  if (s === null)\n    return !0;\n  const n = Math.max(r, 1), i = e - s.baseTime / s.timescale;\n  return Math.abs(i - t) &gt; n;\n}\nfunction $h(s, e, t) {\n  const r = s.codec;\n  return r &amp;&amp; r.length &gt; 4 ? r : e === ot.AUDIO ? r === \"ec-3\" || r === \"ac-3\" || r === \"alac\" ? r : r === \"fLaC\" || r === \"Opus\" ? Xo(r, !1) : (t.warn(`Unhandled audio codec \"${r}\" in mp4 MAP`), r || \"mp4a\") : (t.warn(`Unhandled video codec \"${r}\" in mp4 MAP`), r || \"avc1\");\n}\nlet ls;\ntry {\n  ls = self.performance.now.bind(self.performance);\n} catch {\n  ls = Date.now;\n}\nconst yo = [{\n  demux: UT,\n  remux: QT\n}, {\n  demux: Is,\n  remux: mo\n}, {\n  demux: OT,\n  remux: mo\n}, {\n  demux: FT,\n  remux: mo\n}];\nyo.splice(2, 0, {\n  demux: BT,\n  remux: mo\n});\nclass Gh {\n  constructor(e, t, r, n, i, o) {\n    this.asyncResult = !1, this.logger = void 0, this.observer = void 0, this.typeSupported = void 0, this.config = void 0, this.id = void 0, this.demuxer = void 0, this.remuxer = void 0, this.decrypter = void 0, this.probe = void 0, this.decryptionPromise = null, this.transmuxConfig = void 0, this.currentTransmuxState = void 0, this.observer = e, this.typeSupported = t, this.config = r, this.id = i, this.logger = o;\n  }\n  configure(e) {\n    this.transmuxConfig = e, this.decrypter &amp;&amp; this.decrypter.reset();\n  }\n  push(e, t, r, n) {\n    const i = r.transmuxing;\n    i.executeStart = ls();\n    let o = new Uint8Array(e);\n    const {\n      currentTransmuxState: a,\n      transmuxConfig: l\n    } = this;\n    n &amp;&amp; (this.currentTransmuxState = n);\n    const {\n      contiguous: c,\n      discontinuity: u,\n      trackSwitch: d,\n      accurateTimeOffset: h,\n      timeOffset: f,\n      initSegmentChange: p\n    } = n || a, {\n      audioCodec: y,\n      videoCodec: E,\n      defaultInitPts: b,\n      duration: R,\n      initSegmentData: A\n    } = l, F = t2(o, t);\n    if (F &amp;&amp; In(F.method)) {\n      const j = this.getDecrypter(), C = Su(F.method);\n      if (j.isSync()) {\n        let k = j.softwareDecrypt(o, F.key.buffer, F.iv.buffer, C);\n        if (r.part &gt; -1) {\n          const W = j.flush();\n          k = W &amp;&amp; W.buffer;\n        }\n        if (!k)\n          return i.executeEnd = ls(), xl(r);\n        o = new Uint8Array(k);\n      } else\n        return this.asyncResult = !0, this.decryptionPromise = j.webCryptoDecrypt(o, F.key.buffer, F.iv.buffer, C).then((k) =&gt; {\n          const $ = this.push(k, null, r);\n          return this.decryptionPromise = null, $;\n        }), this.decryptionPromise;\n    }\n    const M = this.needsProbing(u, d);\n    if (M) {\n      const j = this.configureTransmuxer(o);\n      if (j)\n        return this.logger.warn(`[transmuxer] ${j.message}`), this.observer.emit(I.ERROR, I.ERROR, {\n          type: ve.MEDIA_ERROR,\n          details: J.FRAG_PARSING_ERROR,\n          fatal: !1,\n          error: j,\n          reason: j.message\n        }), i.executeEnd = ls(), xl(r);\n    }\n    (u || d || p || M) &amp;&amp; this.resetInitSegment(A, y, E, R, t), (u || p || M) &amp;&amp; this.resetInitialTimestamp(b), c || this.resetContiguity();\n    const H = this.transmux(o, F, f, h, r);\n    this.asyncResult = xi(H);\n    const K = this.currentTransmuxState;\n    return K.contiguous = !0, K.discontinuity = !1, K.trackSwitch = !1, i.executeEnd = ls(), H;\n  }\n  // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\n  flush(e) {\n    const t = e.transmuxing;\n    t.executeStart = ls();\n    const {\n      decrypter: r,\n      currentTransmuxState: n,\n      decryptionPromise: i\n    } = this;\n    if (i)\n      return this.asyncResult = !0, i.then(() =&gt; this.flush(e));\n    const o = [], {\n      timeOffset: a\n    } = n;\n    if (r) {\n      const d = r.flush();\n      d &amp;&amp; o.push(this.push(d.buffer, null, e));\n    }\n    const {\n      demuxer: l,\n      remuxer: c\n    } = this;\n    if (!l || !c) {\n      t.executeEnd = ls();\n      const d = [xl(e)];\n      return this.asyncResult ? Promise.resolve(d) : d;\n    }\n    const u = l.flush(a);\n    return xi(u) ? (this.asyncResult = !0, u.then((d) =&gt; (this.flushRemux(o, d, e), o))) : (this.flushRemux(o, u, e), this.asyncResult ? Promise.resolve(o) : o);\n  }\n  flushRemux(e, t, r) {\n    const {\n      audioTrack: n,\n      videoTrack: i,\n      id3Track: o,\n      textTrack: a\n    } = t, {\n      accurateTimeOffset: l,\n      timeOffset: c\n    } = this.currentTransmuxState;\n    this.logger.log(`[transmuxer.ts]: Flushed ${this.id} sn: ${r.sn}${r.part &gt; -1 ? \" part: \" + r.part : \"\"} of ${this.id === pe.MAIN ? \"level\" : \"track\"} ${r.level}`);\n    const u = this.remuxer.remux(n, i, o, a, c, l, !0, this.id);\n    e.push({\n      remuxResult: u,\n      chunkMeta: r\n    }), r.transmuxing.executeEnd = ls();\n  }\n  resetInitialTimestamp(e) {\n    const {\n      demuxer: t,\n      remuxer: r\n    } = this;\n    !t || !r || (t.resetTimeStamp(e), r.resetTimeStamp(e));\n  }\n  resetContiguity() {\n    const {\n      demuxer: e,\n      remuxer: t\n    } = this;\n    !e || !t || (e.resetContiguity(), t.resetNextTimestamp());\n  }\n  resetInitSegment(e, t, r, n, i) {\n    const {\n      demuxer: o,\n      remuxer: a\n    } = this;\n    !o || !a || (o.resetInitSegment(e, t, r, n), a.resetInitSegment(e, t, r, i));\n  }\n  destroy() {\n    this.demuxer &amp;&amp; (this.demuxer.destroy(), this.demuxer = void 0), this.remuxer &amp;&amp; (this.remuxer.destroy(), this.remuxer = void 0);\n  }\n  transmux(e, t, r, n, i) {\n    let o;\n    return t &amp;&amp; t.method === \"SAMPLE-AES\" ? o = this.transmuxSampleAes(e, t, r, n, i) : o = this.transmuxUnencrypted(e, r, n, i), o;\n  }\n  transmuxUnencrypted(e, t, r, n) {\n    const {\n      audioTrack: i,\n      videoTrack: o,\n      id3Track: a,\n      textTrack: l\n    } = this.demuxer.demux(e, t, !1, !this.config.progressive);\n    return {\n      remuxResult: this.remuxer.remux(i, o, a, l, t, r, !1, this.id),\n      chunkMeta: n\n    };\n  }\n  transmuxSampleAes(e, t, r, n, i) {\n    return this.demuxer.demuxSampleAes(e, t, r).then((o) =&gt; ({\n      remuxResult: this.remuxer.remux(o.audioTrack, o.videoTrack, o.id3Track, o.textTrack, r, n, !1, this.id),\n      chunkMeta: i\n    }));\n  }\n  configureTransmuxer(e) {\n    const {\n      config: t,\n      observer: r,\n      typeSupported: n\n    } = this;\n    let i;\n    for (let d = 0, h = yo.length; d &lt; h; d++) {\n      var o;\n      if ((o = yo[d].demux) != null &amp;&amp; o.probe(e, this.logger)) {\n        i = yo[d];\n        break;\n      }\n    }\n    if (!i)\n      return new Error(\"Failed to find demuxer by probing fragment data\");\n    const a = this.demuxer, l = this.remuxer, c = i.remux, u = i.demux;\n    (!l || !(l instanceof c)) &amp;&amp; (this.remuxer = new c(r, t, n, this.logger)), (!a || !(a instanceof u)) &amp;&amp; (this.demuxer = new u(r, t, n, this.logger), this.probe = u.probe);\n  }\n  needsProbing(e, t) {\n    return !this.demuxer || !this.remuxer || e || t;\n  }\n  getDecrypter() {\n    let e = this.decrypter;\n    return e || (e = this.decrypter = new vu(this.config)), e;\n  }\n}\nfunction t2(s, e) {\n  let t = null;\n  return s.byteLength &gt; 0 &amp;&amp; (e == null ? void 0 : e.key) != null &amp;&amp; e.iv !== null &amp;&amp; e.method != null &amp;&amp; (t = e), t;\n}\nconst xl = (s) =&gt; ({\n  remuxResult: {},\n  chunkMeta: s\n});\nfunction xi(s) {\n  return \"then\" in s &amp;&amp; s.then instanceof Function;\n}\nclass r2 {\n  constructor(e, t, r, n, i) {\n    this.audioCodec = void 0, this.videoCodec = void 0, this.initSegmentData = void 0, this.duration = void 0, this.defaultInitPts = void 0, this.audioCodec = e, this.videoCodec = t, this.initSegmentData = r, this.duration = n, this.defaultInitPts = i || null;\n  }\n}\nclass s2 {\n  constructor(e, t, r, n, i, o) {\n    this.discontinuity = void 0, this.contiguous = void 0, this.accurateTimeOffset = void 0, this.trackSwitch = void 0, this.timeOffset = void 0, this.initSegmentChange = void 0, this.discontinuity = e, this.contiguous = t, this.accurateTimeOffset = r, this.trackSwitch = n, this.timeOffset = i, this.initSegmentChange = o;\n  }\n}\nlet Vh = 0;\nclass wp {\n  constructor(e, t, r, n) {\n    this.error = null, this.hls = void 0, this.id = void 0, this.instanceNo = Vh++, this.observer = void 0, this.frag = null, this.part = null, this.useWorker = void 0, this.workerContext = null, this.transmuxer = null, this.onTransmuxComplete = void 0, this.onFlush = void 0, this.onWorkerMessage = (l) =&gt; {\n      const c = l.data, u = this.hls;\n      if (!(!u || !(c != null &amp;&amp; c.event) || c.instanceNo !== this.instanceNo))\n        switch (c.event) {\n          case \"init\": {\n            var d;\n            const h = (d = this.workerContext) == null ? void 0 : d.objectURL;\n            h &amp;&amp; self.URL.revokeObjectURL(h);\n            break;\n          }\n          case \"transmuxComplete\": {\n            this.handleTransmuxComplete(c.data);\n            break;\n          }\n          case \"flush\": {\n            this.onFlush(c.data);\n            break;\n          }\n          // pass logs from the worker thread to the main logger\n          case \"workerLog\": {\n            u.logger[c.data.logType] &amp;&amp; u.logger[c.data.logType](c.data.message);\n            break;\n          }\n          default: {\n            c.data = c.data || {}, c.data.frag = this.frag, c.data.part = this.part, c.data.id = this.id, u.trigger(c.event, c.data);\n            break;\n          }\n        }\n    }, this.onWorkerError = (l) =&gt; {\n      if (!this.hls)\n        return;\n      const c = new Error(`${l.message}  (${l.filename}:${l.lineno})`);\n      this.hls.config.enableWorker = !1, this.hls.logger.warn(`Error in \"${this.id}\" Web Worker, fallback to inline`), this.hls.trigger(I.ERROR, {\n        type: ve.OTHER_ERROR,\n        details: J.INTERNAL_EXCEPTION,\n        fatal: !1,\n        event: \"demuxerWorker\",\n        error: c\n      });\n    };\n    const i = e.config;\n    this.hls = e, this.id = t, this.useWorker = !!i.enableWorker, this.onTransmuxComplete = r, this.onFlush = n;\n    const o = (l, c) =&gt; {\n      c = c || {}, c.frag = this.frag || void 0, l === I.ERROR &amp;&amp; (c = c, c.parent = this.id, c.part = this.part, this.error = c.error), this.hls.trigger(l, c);\n    };\n    this.observer = new wu(), this.observer.on(I.FRAG_DECRYPTED, o), this.observer.on(I.ERROR, o);\n    const a = ih(i.preferManagedMediaSource);\n    if (this.useWorker &amp;&amp; typeof Worker &lt; \"u\") {\n      const l = this.hls.logger;\n      if (i.workerPath || aT()) {\n        try {\n          i.workerPath ? (l.log(`loading Web Worker ${i.workerPath} for \"${t}\"`), this.workerContext = cT(i.workerPath)) : (l.log(`injecting Web Worker for \"${t}\"`), this.workerContext = lT());\n          const {\n            worker: u\n          } = this.workerContext;\n          u.addEventListener(\"message\", this.onWorkerMessage), u.addEventListener(\"error\", this.onWorkerError), u.postMessage({\n            instanceNo: this.instanceNo,\n            cmd: \"init\",\n            typeSupported: a,\n            id: t,\n            config: at(i)\n          });\n        } catch (u) {\n          l.warn(`Error setting up \"${t}\" Web Worker, fallback to inline`, u), this.terminateWorker(), this.error = null, this.transmuxer = new Gh(this.observer, a, i, \"\", t, e.logger);\n        }\n        return;\n      }\n    }\n    this.transmuxer = new Gh(this.observer, a, i, \"\", t, e.logger);\n  }\n  reset() {\n    if (this.frag = null, this.part = null, this.workerContext) {\n      const e = this.instanceNo;\n      this.instanceNo = Vh++;\n      const t = this.hls.config, r = ih(t.preferManagedMediaSource);\n      this.workerContext.worker.postMessage({\n        instanceNo: this.instanceNo,\n        cmd: \"reset\",\n        resetNo: e,\n        typeSupported: r,\n        id: this.id,\n        config: at(t)\n      });\n    }\n  }\n  terminateWorker() {\n    if (this.workerContext) {\n      const {\n        worker: e\n      } = this.workerContext;\n      this.workerContext = null, e.removeEventListener(\"message\", this.onWorkerMessage), e.removeEventListener(\"error\", this.onWorkerError), uT(this.hls.config.workerPath);\n    }\n  }\n  destroy() {\n    if (this.workerContext)\n      this.terminateWorker(), this.onWorkerMessage = this.onWorkerError = null;\n    else {\n      const t = this.transmuxer;\n      t &amp;&amp; (t.destroy(), this.transmuxer = null);\n    }\n    const e = this.observer;\n    e &amp;&amp; e.removeAllListeners(), this.frag = null, this.part = null, this.observer = null, this.hls = null;\n  }\n  push(e, t, r, n, i, o, a, l, c, u) {\n    var d, h;\n    c.transmuxing.start = self.performance.now();\n    const {\n      instanceNo: f,\n      transmuxer: p\n    } = this, y = o ? o.start : i.start, E = i.decryptdata, b = this.frag, R = !(b &amp;&amp; i.cc === b.cc), A = !(b &amp;&amp; c.level === b.level), F = b ? c.sn - b.sn : -1, M = this.part ? c.part - this.part.index : -1, H = F === 0 &amp;&amp; c.id &gt; 1 &amp;&amp; c.id === (b == null ? void 0 : b.stats.chunkCount), K = !A &amp;&amp; (F === 1 || F === 0 &amp;&amp; (M === 1 || H &amp;&amp; M &lt;= 0)), j = self.performance.now();\n    (A || F || i.stats.parsing.start === 0) &amp;&amp; (i.stats.parsing.start = j), o &amp;&amp; (M || !K) &amp;&amp; (o.stats.parsing.start = j);\n    const C = !(b &amp;&amp; ((d = i.initSegment) == null ? void 0 : d.url) === ((h = b.initSegment) == null ? void 0 : h.url)), k = new s2(R, K, l, A, y, C);\n    if (!K || R || C) {\n      this.hls.logger.log(`[transmuxer-interface]: Starting new transmux session for ${i.type} sn: ${c.sn}${c.part &gt; -1 ? \" part: \" + c.part : \"\"} ${this.id === pe.MAIN ? \"level\" : \"track\"}: ${c.level} id: ${c.id}\n        discontinuity: ${R}\n        trackSwitch: ${A}\n        contiguous: ${K}\n        accurateTimeOffset: ${l}\n        timeOffset: ${y}\n        initSegmentChange: ${C}`);\n      const $ = new r2(r, n, t, a, u);\n      this.configureTransmuxer($);\n    }\n    if (this.frag = i, this.part = o, this.workerContext)\n      this.workerContext.worker.postMessage({\n        instanceNo: f,\n        cmd: \"demux\",\n        data: e,\n        decryptdata: E,\n        chunkMeta: c,\n        state: k\n      }, e instanceof ArrayBuffer ? [e] : []);\n    else if (p) {\n      const $ = p.push(e, E, c, k);\n      xi($) ? $.then((W) =&gt; {\n        this.handleTransmuxComplete(W);\n      }).catch((W) =&gt; {\n        this.transmuxerError(W, c, \"transmuxer-interface push error\");\n      }) : this.handleTransmuxComplete($);\n    }\n  }\n  flush(e) {\n    e.transmuxing.start = self.performance.now();\n    const {\n      instanceNo: t,\n      transmuxer: r\n    } = this;\n    if (this.workerContext)\n      this.workerContext.worker.postMessage({\n        instanceNo: t,\n        cmd: \"flush\",\n        chunkMeta: e\n      });\n    else if (r) {\n      const n = r.flush(e);\n      xi(n) ? n.then((i) =&gt; {\n        this.handleFlushResult(i, e);\n      }).catch((i) =&gt; {\n        this.transmuxerError(i, e, \"transmuxer-interface flush error\");\n      }) : this.handleFlushResult(n, e);\n    }\n  }\n  transmuxerError(e, t, r) {\n    this.hls &amp;&amp; (this.error = e, this.hls.trigger(I.ERROR, {\n      type: ve.MEDIA_ERROR,\n      details: J.FRAG_PARSING_ERROR,\n      chunkMeta: t,\n      frag: this.frag || void 0,\n      part: this.part || void 0,\n      fatal: !1,\n      error: e,\n      err: e,\n      reason: r\n    }));\n  }\n  handleFlushResult(e, t) {\n    e.forEach((r) =&gt; {\n      this.handleTransmuxComplete(r);\n    }), this.onFlush(t);\n  }\n  configureTransmuxer(e) {\n    const {\n      instanceNo: t,\n      transmuxer: r\n    } = this;\n    this.workerContext ? this.workerContext.worker.postMessage({\n      instanceNo: t,\n      cmd: \"configure\",\n      config: e\n    }) : r &amp;&amp; r.configure(e);\n  }\n  handleTransmuxComplete(e) {\n    e.chunkMeta.transmuxing.end = self.performance.now(), this.onTransmuxComplete(e);\n  }\n}\nconst jh = 100;\nclass n2 extends Tu {\n  constructor(e, t, r) {\n    super(e, t, r, \"audio-stream-controller\", pe.AUDIO), this.mainAnchor = null, this.mainFragLoading = null, this.audioOnly = !1, this.bufferedTrack = null, this.switchingTrack = null, this.trackId = -1, this.waitingData = null, this.mainDetails = null, this.flushing = !1, this.bufferFlushed = !1, this.cachedTrackLoadedData = null, this.registerListeners();\n  }\n  onHandlerDestroying() {\n    this.unregisterListeners(), super.onHandlerDestroying(), this.resetItem();\n  }\n  resetItem() {\n    this.mainDetails = this.mainAnchor = this.mainFragLoading = this.bufferedTrack = this.switchingTrack = this.waitingData = this.cachedTrackLoadedData = null;\n  }\n  registerListeners() {\n    super.registerListeners();\n    const {\n      hls: e\n    } = this;\n    e.on(I.LEVEL_LOADED, this.onLevelLoaded, this), e.on(I.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.on(I.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(I.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(I.BUFFER_RESET, this.onBufferReset, this), e.on(I.BUFFER_CREATED, this.onBufferCreated, this), e.on(I.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(I.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(I.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(I.FRAG_LOADING, this.onFragLoading, this), e.on(I.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  unregisterListeners() {\n    const {\n      hls: e\n    } = this;\n    e &amp;&amp; (super.unregisterListeners(), e.off(I.LEVEL_LOADED, this.onLevelLoaded, this), e.off(I.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this), e.off(I.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(I.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(I.BUFFER_RESET, this.onBufferReset, this), e.off(I.BUFFER_CREATED, this.onBufferCreated, this), e.off(I.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(I.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(I.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(I.FRAG_LOADING, this.onFragLoading, this), e.off(I.FRAG_BUFFERED, this.onFragBuffered, this));\n  }\n  // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value\n  onInitPtsFound(e, {\n    frag: t,\n    id: r,\n    initPTS: n,\n    timescale: i,\n    trackId: o\n  }) {\n    if (r === pe.MAIN) {\n      const a = t.cc, l = this.fragCurrent;\n      if (this.initPTS[a] = {\n        baseTime: n,\n        timescale: i,\n        trackId: o\n      }, this.log(`InitPTS for cc: ${a} found from main: ${n / i} (${n}/${i}) trackId: ${o}`), this.mainAnchor = t, this.state === ne.WAITING_INIT_PTS) {\n        const c = this.waitingData;\n        (!c &amp;&amp; !this.loadingParts || c &amp;&amp; c.frag.cc !== a) &amp;&amp; this.syncWithAnchor(t, c == null ? void 0 : c.frag);\n      } else !this.hls.hasEnoughToStart &amp;&amp; l &amp;&amp; l.cc !== a ? (l.abortRequests(), this.syncWithAnchor(t, l)) : this.state === ne.IDLE &amp;&amp; this.tick();\n    }\n  }\n  getLoadPosition() {\n    return !this.startFragRequested &amp;&amp; this.nextLoadPosition &gt;= 0 ? this.nextLoadPosition : super.getLoadPosition();\n  }\n  syncWithAnchor(e, t) {\n    var r;\n    const n = ((r = this.mainFragLoading) == null ? void 0 : r.frag) || null;\n    if (t &amp;&amp; (n == null ? void 0 : n.cc) === t.cc)\n      return;\n    const i = (n || e).cc, o = this.getLevelDetails(), a = this.getLoadPosition(), l = Vg(o, i, a);\n    l &amp;&amp; (this.log(`Syncing with main frag at ${l.start} cc ${l.cc}`), this.startFragRequested = !1, this.nextLoadPosition = l.start, this.resetLoadingState(), this.state === ne.IDLE &amp;&amp; this.doTickIdle());\n  }\n  startLoad(e, t) {\n    if (!this.levels) {\n      this.startPosition = e, this.state = ne.STOPPED;\n      return;\n    }\n    const r = this.lastCurrentTime;\n    this.stopLoad(), this.setInterval(jh), r &gt; 0 &amp;&amp; e === -1 ? (this.log(`Override startPosition with lastCurrentTime @${r.toFixed(3)}`), e = r, this.state = ne.IDLE) : this.state = ne.WAITING_TRACK, this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = t ? -1 : e, this.tick();\n  }\n  doTick() {\n    switch (this.state) {\n      case ne.IDLE:\n        this.doTickIdle();\n        break;\n      case ne.WAITING_TRACK: {\n        const {\n          levels: e,\n          trackId: t\n        } = this, r = e == null ? void 0 : e[t], n = r == null ? void 0 : r.details;\n        if (n &amp;&amp; !this.waitForLive(r)) {\n          if (this.waitForCdnTuneIn(n))\n            break;\n          this.state = ne.WAITING_INIT_PTS;\n        }\n        break;\n      }\n      case ne.FRAG_LOADING_WAITING_RETRY: {\n        this.checkRetryDate();\n        break;\n      }\n      case ne.WAITING_INIT_PTS: {\n        const e = this.waitingData;\n        if (e) {\n          const {\n            frag: t,\n            part: r,\n            cache: n,\n            complete: i\n          } = e, o = this.mainAnchor;\n          if (this.initPTS[t.cc] !== void 0) {\n            this.waitingData = null, this.state = ne.FRAG_LOADING;\n            const a = n.flush().buffer, l = {\n              frag: t,\n              part: r,\n              payload: a,\n              networkDetails: null\n            };\n            this._handleFragmentLoadProgress(l), i &amp;&amp; super._handleFragmentLoadComplete(l);\n          } else o &amp;&amp; o.cc !== e.frag.cc &amp;&amp; this.syncWithAnchor(o, e.frag);\n        } else\n          this.state = ne.IDLE;\n      }\n    }\n    this.onTickEnd();\n  }\n  resetLoadingState() {\n    const e = this.waitingData;\n    e &amp;&amp; (this.fragmentTracker.removeFragment(e.frag), this.waitingData = null), super.resetLoadingState();\n  }\n  onTickEnd() {\n    const {\n      media: e\n    } = this;\n    e != null &amp;&amp; e.readyState &amp;&amp; (this.lastCurrentTime = e.currentTime);\n  }\n  doTickIdle() {\n    var e;\n    const {\n      hls: t,\n      levels: r,\n      media: n,\n      trackId: i\n    } = this, o = t.config;\n    if (!this.buffering || !n &amp;&amp; !this.primaryPrefetch &amp;&amp; (this.startFragRequested || !o.startFragPrefetch) || !(r != null &amp;&amp; r[i]))\n      return;\n    const a = r[i], l = a.details;\n    if (!l || this.waitForLive(a) || this.waitForCdnTuneIn(l)) {\n      this.state = ne.WAITING_TRACK, this.startFragRequested = !1;\n      return;\n    }\n    const c = this.mediaBuffer ? this.mediaBuffer : this.media;\n    this.bufferFlushed &amp;&amp; c &amp;&amp; (this.bufferFlushed = !1, this.afterBufferFlushed(c, ot.AUDIO, pe.AUDIO));\n    const u = this.getFwdBufferInfo(c, pe.AUDIO);\n    if (u === null)\n      return;\n    if (!this.switchingTrack &amp;&amp; this._streamEnded(u, l)) {\n      t.trigger(I.BUFFER_EOS, {\n        type: \"audio\"\n      }), this.state = ne.ENDED;\n      return;\n    }\n    const d = u.len, h = t.maxBufferLength, f = l.fragments, p = f[0].start, y = this.getLoadPosition(), E = this.flushing ? y : u.end;\n    if (this.switchingTrack &amp;&amp; n) {\n      const A = y;\n      l.PTSKnown &amp;&amp; A &lt; p &amp;&amp; (u.end &gt; p || u.nextStart) &amp;&amp; (this.log(\"Alt audio track ahead of main track, seek to start of alt audio track\"), n.currentTime = p + 0.05);\n    }\n    if (d &gt;= h &amp;&amp; !this.switchingTrack &amp;&amp; E &lt; f[f.length - 1].start)\n      return;\n    let b = this.getNextFragment(E, l);\n    if (b &amp;&amp; this.isLoopLoading(b, E) &amp;&amp; (b = this.getNextFragmentLoopLoading(b, l, u, pe.MAIN, h)), !b) {\n      this.bufferFlushed = !0;\n      return;\n    }\n    let R = ((e = this.mainFragLoading) == null ? void 0 : e.frag) || null;\n    if (!this.audioOnly &amp;&amp; this.startFragRequested &amp;&amp; R &amp;&amp; Vt(b) &amp;&amp; !b.endList &amp;&amp; (!l.live || !this.loadingParts &amp;&amp; E &lt; this.hls.liveSyncPosition) &amp;&amp; (this.fragmentTracker.getState(R) === Ht.OK &amp;&amp; (this.mainFragLoading = R = null), R &amp;&amp; Vt(R))) {\n      if (b.start &gt; R.end) {\n        const F = this.fragmentTracker.getFragAtPos(E, pe.MAIN);\n        F &amp;&amp; F.end &gt; R.end &amp;&amp; (R = F, this.mainFragLoading = {\n          frag: F,\n          targetBufferTime: null\n        });\n      }\n      if (b.start &gt; R.end)\n        return;\n    }\n    this.loadFragment(b, a, E);\n  }\n  onMediaDetaching(e, t) {\n    this.bufferFlushed = this.flushing = !1, super.onMediaDetaching(e, t);\n  }\n  onAudioTracksUpdated(e, {\n    audioTracks: t\n  }) {\n    this.resetTransmuxer(), this.levels = t.map((r) =&gt; new mi(r));\n  }\n  onAudioTrackSwitching(e, t) {\n    const r = !!t.url;\n    this.trackId = t.id;\n    const {\n      fragCurrent: n\n    } = this;\n    n &amp;&amp; (n.abortRequests(), this.removeUnbufferedFrags(n.start)), this.resetLoadingState(), r ? (this.switchingTrack = t, this.flushAudioIfNeeded(t), this.state !== ne.STOPPED &amp;&amp; (this.setInterval(jh), this.state = ne.IDLE, this.tick())) : (this.resetTransmuxer(), this.switchingTrack = null, this.bufferedTrack = t, this.clearInterval());\n  }\n  onManifestLoading() {\n    super.onManifestLoading(), this.bufferFlushed = this.flushing = this.audioOnly = !1, this.resetItem(), this.trackId = -1;\n  }\n  onLevelLoaded(e, t) {\n    this.mainDetails = t.details;\n    const r = this.cachedTrackLoadedData;\n    r &amp;&amp; (this.cachedTrackLoadedData = null, this.onAudioTrackLoaded(I.AUDIO_TRACK_LOADED, r));\n  }\n  onAudioTrackLoaded(e, t) {\n    var r;\n    const {\n      levels: n\n    } = this, {\n      details: i,\n      id: o,\n      groupId: a,\n      track: l\n    } = t;\n    if (!n) {\n      this.warn(`Audio tracks reset while loading track ${o} \"${l.name}\" of \"${a}\"`);\n      return;\n    }\n    const c = this.mainDetails;\n    if (!c || i.endCC &gt; c.endCC || c.expired) {\n      this.cachedTrackLoadedData = t, this.state !== ne.STOPPED &amp;&amp; (this.state = ne.WAITING_TRACK);\n      return;\n    }\n    this.cachedTrackLoadedData = null, this.log(`Audio track ${o} \"${l.name}\" of \"${a}\" loaded [${i.startSN},${i.endSN}]${i.lastPartSn ? `[part-${i.lastPartSn}-${i.lastPartIndex}]` : \"\"},duration:${i.totalduration}`);\n    const u = n[o];\n    let d = 0;\n    if (i.live || (r = u.details) != null &amp;&amp; r.live) {\n      if (this.checkLiveUpdate(i), i.deltaUpdateFailed)\n        return;\n      if (u.details) {\n        var h;\n        d = this.alignPlaylists(i, u.details, (h = this.levelLastLoaded) == null ? void 0 : h.details);\n      }\n      i.alignedSliding || (np(i, c), i.alignedSliding || sa(i, c), d = i.fragmentStart);\n    }\n    u.details = i, this.levelLastLoaded = u, this.startFragRequested || this.setStartPosition(c, d), this.hls.trigger(I.AUDIO_TRACK_UPDATED, {\n      details: i,\n      id: o,\n      groupId: t.groupId\n    }), this.state === ne.WAITING_TRACK &amp;&amp; !this.waitForCdnTuneIn(i) &amp;&amp; (this.state = ne.IDLE), this.tick();\n  }\n  _handleFragmentLoadProgress(e) {\n    var t;\n    const r = e.frag, {\n      part: n,\n      payload: i\n    } = e, {\n      config: o,\n      trackId: a,\n      levels: l\n    } = this;\n    if (!l) {\n      this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${r.sn} of level ${r.level} will not be buffered`);\n      return;\n    }\n    const c = l[a];\n    if (!c) {\n      this.warn(\"Audio track is undefined on fragment load progress\");\n      return;\n    }\n    const u = c.details;\n    if (!u) {\n      this.warn(\"Audio track details undefined on fragment load progress\"), this.removeUnbufferedFrags(r.start);\n      return;\n    }\n    const d = o.defaultAudioCodec || c.audioCodec || \"mp4a.40.2\";\n    let h = this.transmuxer;\n    h || (h = this.transmuxer = new wp(this.hls, pe.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)));\n    const f = this.initPTS[r.cc], p = (t = r.initSegment) == null ? void 0 : t.data;\n    if (f !== void 0) {\n      const E = n ? n.index : -1, b = E !== -1, R = new Eu(r.level, r.sn, r.stats.chunkCount, i.byteLength, E, b);\n      h.push(i, p, d, \"\", r, n, u.totalduration, !1, R, f);\n    } else {\n      this.log(`Unknown video PTS for cc ${r.cc}, waiting for video PTS before demuxing audio frag ${r.sn} of [${u.startSN} ,${u.endSN}],track ${a}`);\n      const {\n        cache: y\n      } = this.waitingData = this.waitingData || {\n        frag: r,\n        part: n,\n        cache: new ip(),\n        complete: !1\n      };\n      y.push(new Uint8Array(i)), this.state !== ne.STOPPED &amp;&amp; (this.state = ne.WAITING_INIT_PTS);\n    }\n  }\n  _handleFragmentLoadComplete(e) {\n    if (this.waitingData) {\n      this.waitingData.complete = !0;\n      return;\n    }\n    super._handleFragmentLoadComplete(e);\n  }\n  onBufferReset() {\n    this.mediaBuffer = null;\n  }\n  onBufferCreated(e, t) {\n    this.bufferFlushed = this.flushing = !1;\n    const r = t.tracks.audio;\n    r &amp;&amp; (this.mediaBuffer = r.buffer || null);\n  }\n  onFragLoading(e, t) {\n    !this.audioOnly &amp;&amp; t.frag.type === pe.MAIN &amp;&amp; Vt(t.frag) &amp;&amp; (this.mainFragLoading = t, this.state === ne.IDLE &amp;&amp; this.tick());\n  }\n  onFragBuffered(e, t) {\n    const {\n      frag: r,\n      part: n\n    } = t;\n    if (r.type !== pe.AUDIO) {\n      !this.audioOnly &amp;&amp; r.type === pe.MAIN &amp;&amp; !r.elementaryStreams.video &amp;&amp; !r.elementaryStreams.audiovideo &amp;&amp; (this.audioOnly = !0, this.mainFragLoading = null);\n      return;\n    }\n    if (this.fragContextChanged(r)) {\n      this.warn(`Fragment ${r.sn}${n ? \" p: \" + n.index : \"\"} of level ${r.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : \"false\"}`);\n      return;\n    }\n    if (Vt(r)) {\n      this.fragPrevious = r;\n      const i = this.switchingTrack;\n      i &amp;&amp; (this.bufferedTrack = i, this.switchingTrack = null, this.hls.trigger(I.AUDIO_TRACK_SWITCHED, tt({}, i)));\n    }\n    this.fragBufferedComplete(r, n), this.media &amp;&amp; this.tick();\n  }\n  onError(e, t) {\n    var r;\n    if (t.fatal) {\n      this.state = ne.ERROR;\n      return;\n    }\n    switch (t.details) {\n      case J.FRAG_GAP:\n      case J.FRAG_PARSING_ERROR:\n      case J.FRAG_DECRYPT_ERROR:\n      case J.FRAG_LOAD_ERROR:\n      case J.FRAG_LOAD_TIMEOUT:\n      case J.KEY_LOAD_ERROR:\n      case J.KEY_LOAD_TIMEOUT:\n        this.onFragmentOrKeyLoadError(pe.AUDIO, t);\n        break;\n      case J.AUDIO_TRACK_LOAD_ERROR:\n      case J.AUDIO_TRACK_LOAD_TIMEOUT:\n      case J.LEVEL_PARSING_ERROR:\n        !t.levelRetry &amp;&amp; this.state === ne.WAITING_TRACK &amp;&amp; ((r = t.context) == null ? void 0 : r.type) === Ke.AUDIO_TRACK &amp;&amp; (this.state = ne.IDLE);\n        break;\n      case J.BUFFER_ADD_CODEC_ERROR:\n      case J.BUFFER_APPEND_ERROR:\n        if (t.parent !== \"audio\")\n          return;\n        this.reduceLengthAndFlushBuffer(t) || this.resetLoadingState();\n        break;\n      case J.BUFFER_FULL_ERROR:\n        if (t.parent !== \"audio\")\n          return;\n        this.reduceLengthAndFlushBuffer(t) &amp;&amp; (this.bufferedTrack = null, super.flushMainBuffer(0, Number.POSITIVE_INFINITY, \"audio\"));\n        break;\n      case J.INTERNAL_EXCEPTION:\n        this.recoverWorkerError(t);\n        break;\n    }\n  }\n  onBufferFlushing(e, {\n    type: t\n  }) {\n    t !== ot.VIDEO &amp;&amp; (this.flushing = !0);\n  }\n  onBufferFlushed(e, {\n    type: t\n  }) {\n    if (t !== ot.VIDEO) {\n      this.flushing = !1, this.bufferFlushed = !0, this.state === ne.ENDED &amp;&amp; (this.state = ne.IDLE);\n      const r = this.mediaBuffer || this.media;\n      r &amp;&amp; (this.afterBufferFlushed(r, t, pe.AUDIO), this.tick());\n    }\n  }\n  _handleTransmuxComplete(e) {\n    var t;\n    const r = \"audio\", {\n      hls: n\n    } = this, {\n      remuxResult: i,\n      chunkMeta: o\n    } = e, a = this.getCurrentContext(o);\n    if (!a) {\n      this.resetWhenMissingContext(o);\n      return;\n    }\n    const {\n      frag: l,\n      part: c,\n      level: u\n    } = a, {\n      details: d\n    } = u, {\n      audio: h,\n      text: f,\n      id3: p,\n      initSegment: y\n    } = i;\n    if (this.fragContextChanged(l) || !d) {\n      this.fragmentTracker.removeFragment(l);\n      return;\n    }\n    if (this.state = ne.PARSING, this.switchingTrack &amp;&amp; h &amp;&amp; this.completeAudioSwitch(this.switchingTrack), y != null &amp;&amp; y.tracks) {\n      const E = l.initSegment || l;\n      if (this.unhandledEncryptionError(y, l))\n        return;\n      this._bufferInitSegment(u, y.tracks, E, o), n.trigger(I.FRAG_PARSING_INIT_SEGMENT, {\n        frag: E,\n        id: r,\n        tracks: y.tracks\n      });\n    }\n    if (h) {\n      const {\n        startPTS: E,\n        endPTS: b,\n        startDTS: R,\n        endDTS: A\n      } = h;\n      c &amp;&amp; (c.elementaryStreams[ot.AUDIO] = {\n        startPTS: E,\n        endPTS: b,\n        startDTS: R,\n        endDTS: A\n      }), l.setElementaryStreamInfo(ot.AUDIO, E, b, R, A), this.bufferFragmentData(h, l, c, o);\n    }\n    if (p != null &amp;&amp; (t = p.samples) != null &amp;&amp; t.length) {\n      const E = nt({\n        id: r,\n        frag: l,\n        details: d\n      }, p);\n      n.trigger(I.FRAG_PARSING_METADATA, E);\n    }\n    if (f) {\n      const E = nt({\n        id: r,\n        frag: l,\n        details: d\n      }, f);\n      n.trigger(I.FRAG_PARSING_USERDATA, E);\n    }\n  }\n  _bufferInitSegment(e, t, r, n) {\n    if (this.state !== ne.PARSING || (t.video &amp;&amp; delete t.video, t.audiovideo &amp;&amp; delete t.audiovideo, !t.audio))\n      return;\n    const i = t.audio;\n    i.id = pe.AUDIO;\n    const o = e.audioCodec;\n    this.log(`Init audio buffer, container:${i.container}, codecs[level/parsed]=[${o}/${i.codec}]`), o &amp;&amp; o.split(\",\").length === 1 &amp;&amp; (i.levelCodec = o), this.hls.trigger(I.BUFFER_CODECS, t);\n    const a = i.initSegment;\n    if (a != null &amp;&amp; a.byteLength) {\n      const l = {\n        type: \"audio\",\n        frag: r,\n        part: null,\n        chunkMeta: n,\n        parent: r.type,\n        data: a\n      };\n      this.hls.trigger(I.BUFFER_APPENDING, l);\n    }\n    this.tickImmediate();\n  }\n  loadFragment(e, t, r) {\n    const n = this.fragmentTracker.getState(e);\n    if (this.switchingTrack || n === Ht.NOT_LOADED || n === Ht.PARTIAL) {\n      var i;\n      if (!Vt(e))\n        this._loadInitSegment(e, t);\n      else if ((i = t.details) != null &amp;&amp; i.live &amp;&amp; !this.initPTS[e.cc]) {\n        this.log(`Waiting for video PTS in continuity counter ${e.cc} of live stream before loading audio fragment ${e.sn} of level ${this.trackId}`), this.state = ne.WAITING_INIT_PTS;\n        const o = this.mainDetails;\n        o &amp;&amp; o.fragmentStart !== t.details.fragmentStart &amp;&amp; sa(t.details, o);\n      } else\n        super.loadFragment(e, t, r);\n    } else\n      this.clearTrackerIfNeeded(e);\n  }\n  flushAudioIfNeeded(e) {\n    if (this.media &amp;&amp; this.bufferedTrack) {\n      const {\n        name: t,\n        lang: r,\n        assocLang: n,\n        characteristics: i,\n        audioCodec: o,\n        channels: a\n      } = this.bufferedTrack;\n      qs({\n        name: t,\n        lang: r,\n        assocLang: n,\n        characteristics: i,\n        audioCodec: o,\n        channels: a\n      }, e, Us) || (Qo(e.url, this.hls) ? (this.log(\"Switching audio track : flushing all audio\"), super.flushMainBuffer(0, Number.POSITIVE_INFINITY, \"audio\"), this.bufferedTrack = null) : this.bufferedTrack = e);\n    }\n  }\n  completeAudioSwitch(e) {\n    const {\n      hls: t\n    } = this;\n    this.flushAudioIfNeeded(e), this.bufferedTrack = e, this.switchingTrack = null, t.trigger(I.AUDIO_TRACK_SWITCHED, tt({}, e));\n  }\n}\nclass ku extends Lr {\n  constructor(e, t) {\n    super(t, e.logger), this.hls = void 0, this.canLoad = !1, this.timer = -1, this.hls = e;\n  }\n  destroy() {\n    this.clearTimer(), this.hls = this.log = this.warn = null;\n  }\n  clearTimer() {\n    this.timer !== -1 &amp;&amp; (self.clearTimeout(this.timer), this.timer = -1);\n  }\n  startLoad() {\n    this.canLoad = !0, this.loadPlaylist();\n  }\n  stopLoad() {\n    this.canLoad = !1, this.clearTimer();\n  }\n  switchParams(e, t, r) {\n    const n = t == null ? void 0 : t.renditionReports;\n    if (n) {\n      let i = -1;\n      for (let o = 0; o &lt; n.length; o++) {\n        const a = n[o];\n        let l;\n        try {\n          l = new self.URL(a.URI, t.url).href;\n        } catch (c) {\n          this.warn(`Could not construct new URL for Rendition Report: ${c}`), l = a.URI || \"\";\n        }\n        if (l === e) {\n          i = o;\n          break;\n        } else l === e.substring(0, l.length) &amp;&amp; (i = o);\n      }\n      if (i !== -1) {\n        const o = n[i], a = parseInt(o[\"LAST-MSN\"]) || t.lastPartSn;\n        let l = parseInt(o[\"LAST-PART\"]) || t.lastPartIndex;\n        if (this.hls.config.lowLatencyMode) {\n          const u = Math.min(t.age - t.partTarget, t.targetduration);\n          l &gt;= 0 &amp;&amp; u &gt; t.partTarget &amp;&amp; (l += 1);\n        }\n        const c = r &amp;&amp; oh(r);\n        return new ah(a, l &gt;= 0 ? l : void 0, c);\n      }\n    }\n  }\n  loadPlaylist(e) {\n    this.clearTimer();\n  }\n  loadingPlaylist(e, t) {\n    this.clearTimer();\n  }\n  shouldLoadPlaylist(e) {\n    return this.canLoad &amp;&amp; !!e &amp;&amp; !!e.url &amp;&amp; (!e.details || e.details.live);\n  }\n  getUrlWithDirectives(e, t) {\n    if (t)\n      try {\n        return t.addDirectives(e);\n      } catch (r) {\n        this.warn(`Could not construct new URL with HLS Delivery Directives: ${r}`);\n      }\n    return e;\n  }\n  playlistLoaded(e, t, r) {\n    const {\n      details: n,\n      stats: i\n    } = t, o = self.performance.now(), a = i.loading.first ? Math.max(0, o - i.loading.first) : 0;\n    n.advancedDateTime = Date.now() - a;\n    const l = this.hls.config.timelineOffset;\n    if (l !== n.appliedTimelineOffset) {\n      const u = Math.max(l || 0, 0);\n      n.appliedTimelineOffset = u, n.fragments.forEach((d) =&gt; {\n        d.setStart(d.playlistOffset + u);\n      });\n    }\n    if (n.live || r != null &amp;&amp; r.live) {\n      const u = \"levelInfo\" in t ? t.levelInfo : t.track;\n      if (n.reloaded(r), r &amp;&amp; n.fragments.length &gt; 0) {\n        Zb(r, n, this);\n        const R = n.playlistParsingError;\n        if (R) {\n          this.warn(R);\n          const A = this.hls;\n          if (!A.config.ignorePlaylistParsingErrors) {\n            var c;\n            const {\n              networkDetails: F\n            } = t;\n            A.trigger(I.ERROR, {\n              type: ve.NETWORK_ERROR,\n              details: J.LEVEL_PARSING_ERROR,\n              fatal: !1,\n              url: n.url,\n              error: R,\n              reason: R.message,\n              level: t.level || void 0,\n              parent: (c = n.fragments[0]) == null ? void 0 : c.type,\n              networkDetails: F,\n              stats: i\n            });\n            return;\n          }\n          n.playlistParsingError = null;\n        }\n      }\n      n.requestScheduled === -1 &amp;&amp; (n.requestScheduled = i.loading.start);\n      const d = this.hls.mainForwardBufferInfo, h = d ? d.end - d.len : 0, f = (n.edge - h) * 1e3, p = Qg(n, f);\n      if (n.requestScheduled + p &lt; o ? n.requestScheduled = o : n.requestScheduled += p, this.log(`live playlist ${e} ${n.advanced ? \"REFRESHED \" + n.lastPartSn + \"-\" + n.lastPartIndex : n.updated ? \"UPDATED\" : \"MISSED\"}`), !this.canLoad || !n.live)\n        return;\n      let y, E, b;\n      if (n.canBlockReload &amp;&amp; n.endSN &amp;&amp; n.advanced) {\n        const R = this.hls.config.lowLatencyMode, A = n.lastPartSn, F = n.endSN, M = n.lastPartIndex, H = M !== -1, K = A === F;\n        H ? K ? (E = F + 1, b = R ? 0 : M) : (E = A, b = R ? M + 1 : n.maxPartIndex) : E = F + 1;\n        const j = n.age, C = j + n.ageHeader;\n        let k = Math.min(C - n.partTarget, n.targetduration * 1.5);\n        if (k &gt; 0) {\n          if (C &gt; n.targetduration * 3)\n            this.log(`Playlist last advanced ${j.toFixed(2)}s ago. Omitting segment and part directives.`), E = void 0, b = void 0;\n          else if (r != null &amp;&amp; r.tuneInGoal &amp;&amp; C - n.partTarget &gt; r.tuneInGoal)\n            this.warn(`CDN Tune-in goal increased from: ${r.tuneInGoal} to: ${k} with playlist age: ${n.age}`), k = 0;\n          else {\n            const $ = Math.floor(k / n.targetduration);\n            if (E += $, b !== void 0) {\n              const W = Math.round(k % n.targetduration / n.partTarget);\n              b += W;\n            }\n            this.log(`CDN Tune-in age: ${n.ageHeader}s last advanced ${j.toFixed(2)}s goal: ${k} skip sn ${$} to part ${b}`);\n          }\n          n.tuneInGoal = k;\n        }\n        if (y = this.getDeliveryDirectives(n, t.deliveryDirectives, E, b), R || !K) {\n          n.requestScheduled = o, this.loadingPlaylist(u, y);\n          return;\n        }\n      } else (n.canBlockReload || n.canSkipUntil) &amp;&amp; (y = this.getDeliveryDirectives(n, t.deliveryDirectives, E, b));\n      y &amp;&amp; E !== void 0 &amp;&amp; n.canBlockReload &amp;&amp; (n.requestScheduled = i.loading.first + Math.max(p - a * 2, p / 2)), this.scheduleLoading(u, y, n);\n    } else\n      this.clearTimer();\n  }\n  scheduleLoading(e, t, r) {\n    const n = r || e.details;\n    if (!n) {\n      this.loadingPlaylist(e, t);\n      return;\n    }\n    const i = self.performance.now(), o = n.requestScheduled;\n    if (i &gt;= o) {\n      this.loadingPlaylist(e, t);\n      return;\n    }\n    const a = o - i;\n    this.log(`reload live playlist ${e.name || e.bitrate + \"bps\"} in ${Math.round(a)} ms`), this.clearTimer(), this.timer = self.setTimeout(() =&gt; this.loadingPlaylist(e, t), a);\n  }\n  getDeliveryDirectives(e, t, r, n) {\n    let i = oh(e);\n    return t != null &amp;&amp; t.skip &amp;&amp; e.deltaUpdateFailed &amp;&amp; (r = t.msn, n = t.part, i = go.No), new ah(r, n, i);\n  }\n  checkRetry(e) {\n    const t = e.details, r = ea(e), n = e.errorAction, {\n      action: i,\n      retryCount: o = 0,\n      retryConfig: a\n    } = n || {}, l = !!n &amp;&amp; !!a &amp;&amp; (i === Zt.RetryRequest || !n.resolved &amp;&amp; i === Zt.SendAlternateToPenaltyBox);\n    if (l) {\n      var c;\n      if (o &gt;= a.maxNumRetry)\n        return !1;\n      if (r &amp;&amp; (c = e.context) != null &amp;&amp; c.deliveryDirectives)\n        this.warn(`Retrying playlist loading ${o + 1}/${a.maxNumRetry} after \"${t}\" without delivery-directives`), this.loadPlaylist();\n      else {\n        const u = yu(a, o);\n        this.clearTimer(), this.timer = self.setTimeout(() =&gt; this.loadPlaylist(), u), this.warn(`Retrying playlist loading ${o + 1}/${a.maxNumRetry} after \"${t}\" in ${u}ms`);\n      }\n      e.levelRetry = !0, n.resolved = !0;\n    }\n    return l;\n  }\n}\nfunction Ap(s, e) {\n  if (s.length !== e.length)\n    return !1;\n  for (let t = 0; t &lt; s.length; t++)\n    if (!Si(s[t].attrs, e[t].attrs))\n      return !1;\n  return !0;\n}\nfunction Si(s, e, t) {\n  const r = s[\"STABLE-RENDITION-ID\"];\n  return r &amp;&amp; !t ? r === e[\"STABLE-RENDITION-ID\"] : !(t || [\"LANGUAGE\", \"NAME\", \"CHARACTERISTICS\", \"AUTOSELECT\", \"DEFAULT\", \"FORCED\", \"ASSOC-LANGUAGE\"]).some((n) =&gt; s[n] !== e[n]);\n}\nfunction yc(s, e) {\n  return e.label.toLowerCase() === s.name.toLowerCase() &amp;&amp; (!e.language || e.language.toLowerCase() === (s.lang || \"\").toLowerCase());\n}\nclass i2 extends ku {\n  constructor(e) {\n    super(e, \"audio-track-controller\"), this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.registerListeners();\n  }\n  registerListeners() {\n    const {\n      hls: e\n    } = this;\n    e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.MANIFEST_PARSED, this.onManifestParsed, this), e.on(I.LEVEL_LOADING, this.onLevelLoading, this), e.on(I.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(I.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.on(I.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls: e\n    } = this;\n    e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.MANIFEST_PARSED, this.onManifestParsed, this), e.off(I.LEVEL_LOADING, this.onLevelLoading, this), e.off(I.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(I.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this), e.off(I.ERROR, this.onError, this);\n  }\n  destroy() {\n    this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, super.destroy();\n  }\n  onManifestLoading() {\n    this.tracks = [], this.tracksInGroup = [], this.groupIds = null, this.currentTrack = null, this.trackId = -1, this.selectDefaultTrack = !0;\n  }\n  onManifestParsed(e, t) {\n    this.tracks = t.audioTracks || [];\n  }\n  onAudioTrackLoaded(e, t) {\n    const {\n      id: r,\n      groupId: n,\n      details: i\n    } = t, o = this.tracksInGroup[r];\n    if (!o || o.groupId !== n) {\n      this.warn(`Audio track with id:${r} and group:${n} not found in active group ${o == null ? void 0 : o.groupId}`);\n      return;\n    }\n    const a = o.details;\n    o.details = t.details, this.log(`Audio track ${r} \"${o.name}\" lang:${o.lang} group:${n} loaded [${i.startSN}-${i.endSN}]`), r === this.trackId &amp;&amp; this.playlistLoaded(r, t, a);\n  }\n  onLevelLoading(e, t) {\n    this.switchLevel(t.level);\n  }\n  onLevelSwitching(e, t) {\n    this.switchLevel(t.level);\n  }\n  switchLevel(e) {\n    const t = this.hls.levels[e];\n    if (!t)\n      return;\n    const r = t.audioGroups || null, n = this.groupIds;\n    let i = this.currentTrack;\n    if (!r || (n == null ? void 0 : n.length) !== (r == null ? void 0 : r.length) || r != null &amp;&amp; r.some((a) =&gt; (n == null ? void 0 : n.indexOf(a)) === -1)) {\n      this.groupIds = r, this.trackId = -1, this.currentTrack = null;\n      const a = this.tracks.filter((h) =&gt; !r || r.indexOf(h.groupId) !== -1);\n      if (a.length)\n        this.selectDefaultTrack &amp;&amp; !a.some((h) =&gt; h.default) &amp;&amp; (this.selectDefaultTrack = !1), a.forEach((h, f) =&gt; {\n          h.id = f;\n        });\n      else if (!i &amp;&amp; !this.tracksInGroup.length)\n        return;\n      this.tracksInGroup = a;\n      const l = this.hls.config.audioPreference;\n      if (!i &amp;&amp; l) {\n        const h = Wr(l, a, Us);\n        if (h &gt; -1)\n          i = a[h];\n        else {\n          const f = Wr(l, this.tracks);\n          i = this.tracks[f];\n        }\n      }\n      let c = this.findTrackId(i);\n      c === -1 &amp;&amp; i &amp;&amp; (c = this.findTrackId(null));\n      const u = {\n        audioTracks: a\n      };\n      this.log(`Updating audio tracks, ${a.length} track(s) found in group(s): ${r == null ? void 0 : r.join(\",\")}`), this.hls.trigger(I.AUDIO_TRACKS_UPDATED, u);\n      const d = this.trackId;\n      if (c !== -1 &amp;&amp; d === -1)\n        this.setAudioTrack(c);\n      else if (a.length &amp;&amp; d === -1) {\n        var o;\n        const h = new Error(`No audio track selected for current audio group-ID(s): ${(o = this.groupIds) == null ? void 0 : o.join(\",\")} track count: ${a.length}`);\n        this.warn(h.message), this.hls.trigger(I.ERROR, {\n          type: ve.MEDIA_ERROR,\n          details: J.AUDIO_TRACK_LOAD_ERROR,\n          fatal: !0,\n          error: h\n        });\n      }\n    }\n  }\n  onError(e, t) {\n    t.fatal || !t.context || t.context.type === Ke.AUDIO_TRACK &amp;&amp; t.context.id === this.trackId &amp;&amp; (!this.groupIds || this.groupIds.indexOf(t.context.groupId) !== -1) &amp;&amp; this.checkRetry(t);\n  }\n  get allAudioTracks() {\n    return this.tracks;\n  }\n  get audioTracks() {\n    return this.tracksInGroup;\n  }\n  get audioTrack() {\n    return this.trackId;\n  }\n  set audioTrack(e) {\n    this.selectDefaultTrack = !1, this.setAudioTrack(e);\n  }\n  setAudioOption(e) {\n    const t = this.hls;\n    if (t.config.audioPreference = e, e) {\n      const r = this.allAudioTracks;\n      if (this.selectDefaultTrack = !1, r.length) {\n        const n = this.currentTrack;\n        if (n &amp;&amp; qs(e, n, Us))\n          return n;\n        const i = Wr(e, this.tracksInGroup, Us);\n        if (i &gt; -1) {\n          const o = this.tracksInGroup[i];\n          return this.setAudioTrack(i), o;\n        } else if (n) {\n          let o = t.loadLevel;\n          o === -1 &amp;&amp; (o = t.firstAutoLevel);\n          const a = mb(e, t.levels, r, o, Us);\n          if (a === -1)\n            return null;\n          t.nextLoadLevel = a;\n        }\n        if (e.channels || e.audioCodec) {\n          const o = Wr(e, r);\n          if (o &gt; -1)\n            return r[o];\n        }\n      }\n    }\n    return null;\n  }\n  setAudioTrack(e) {\n    const t = this.tracksInGroup;\n    if (e &lt; 0 || e &gt;= t.length) {\n      this.warn(`Invalid audio track id: ${e}`);\n      return;\n    }\n    this.selectDefaultTrack = !1;\n    const r = this.currentTrack, n = t[e], i = n.details &amp;&amp; !n.details.live;\n    if (e === this.trackId &amp;&amp; n === r &amp;&amp; i || (this.log(`Switching to audio-track ${e} \"${n.name}\" lang:${n.lang} group:${n.groupId} channels:${n.channels}`), this.trackId = e, this.currentTrack = n, this.hls.trigger(I.AUDIO_TRACK_SWITCHING, tt({}, n)), i))\n      return;\n    const o = this.switchParams(n.url, r == null ? void 0 : r.details, n.details);\n    this.loadPlaylist(o);\n  }\n  findTrackId(e) {\n    const t = this.tracksInGroup;\n    for (let r = 0; r &lt; t.length; r++) {\n      const n = t[r];\n      if (!(this.selectDefaultTrack &amp;&amp; !n.default) &amp;&amp; (!e || qs(e, n, Us)))\n        return r;\n    }\n    if (e) {\n      const {\n        name: r,\n        lang: n,\n        assocLang: i,\n        characteristics: o,\n        audioCodec: a,\n        channels: l\n      } = e;\n      for (let c = 0; c &lt; t.length; c++) {\n        const u = t[c];\n        if (qs({\n          name: r,\n          lang: n,\n          assocLang: i,\n          characteristics: o,\n          audioCodec: a,\n          channels: l\n        }, u, Us))\n          return c;\n      }\n      for (let c = 0; c &lt; t.length; c++) {\n        const u = t[c];\n        if (Si(e.attrs, u.attrs, [\"LANGUAGE\", \"ASSOC-LANGUAGE\", \"CHARACTERISTICS\"]))\n          return c;\n      }\n      for (let c = 0; c &lt; t.length; c++) {\n        const u = t[c];\n        if (Si(e.attrs, u.attrs, [\"LANGUAGE\"]))\n          return c;\n      }\n    }\n    return -1;\n  }\n  loadPlaylist(e) {\n    super.loadPlaylist();\n    const t = this.currentTrack;\n    this.shouldLoadPlaylist(t) &amp;&amp; Qo(t.url, this.hls) &amp;&amp; this.scheduleLoading(t, e);\n  }\n  loadingPlaylist(e, t) {\n    super.loadingPlaylist(e, t);\n    const r = e.id, n = e.groupId, i = this.getUrlWithDirectives(e.url, t), o = e.details, a = o == null ? void 0 : o.age;\n    this.log(`Loading audio-track ${r} \"${e.name}\" lang:${e.lang} group:${n}${(t == null ? void 0 : t.msn) !== void 0 ? \" at sn \" + t.msn + \" part \" + t.part : \"\"}${a &amp;&amp; o.live ? \" age \" + a.toFixed(1) + (o.type &amp;&amp; \" \" + o.type || \"\") : \"\"} ${i}`), this.hls.trigger(I.AUDIO_TRACK_LOADING, {\n      url: i,\n      id: r,\n      groupId: n,\n      deliveryDirectives: t || null,\n      track: e\n    });\n  }\n}\nclass o2 {\n  constructor(e) {\n    this.tracks = void 0, this.queues = {\n      video: [],\n      audio: [],\n      audiovideo: []\n    }, this.tracks = e;\n  }\n  destroy() {\n    this.tracks = this.queues = null;\n  }\n  append(e, t, r) {\n    if (this.queues === null || this.tracks === null)\n      return;\n    const n = this.queues[t];\n    n.push(e), n.length === 1 &amp;&amp; !r &amp;&amp; this.executeNext(t);\n  }\n  appendBlocker(e) {\n    return new Promise((t) =&gt; {\n      const r = {\n        label: \"async-blocker\",\n        execute: t,\n        onStart: () =&gt; {\n        },\n        onComplete: () =&gt; {\n        },\n        onError: () =&gt; {\n        }\n      };\n      this.append(r, e);\n    });\n  }\n  prependBlocker(e) {\n    return new Promise((t) =&gt; {\n      if (this.queues) {\n        const r = {\n          label: \"async-blocker-prepend\",\n          execute: t,\n          onStart: () =&gt; {\n          },\n          onComplete: () =&gt; {\n          },\n          onError: () =&gt; {\n          }\n        };\n        this.queues[e].unshift(r);\n      }\n    });\n  }\n  removeBlockers() {\n    this.queues !== null &amp;&amp; [this.queues.video, this.queues.audio, this.queues.audiovideo].forEach((e) =&gt; {\n      var t;\n      const r = (t = e[0]) == null ? void 0 : t.label;\n      (r === \"async-blocker\" || r === \"async-blocker-prepend\") &amp;&amp; (e[0].execute(), e.splice(0, 1));\n    });\n  }\n  unblockAudio(e) {\n    if (this.queues === null)\n      return;\n    this.queues.audio[0] === e &amp;&amp; this.shiftAndExecuteNext(\"audio\");\n  }\n  executeNext(e) {\n    if (this.queues === null || this.tracks === null)\n      return;\n    const t = this.queues[e];\n    if (t.length) {\n      const n = t[0];\n      try {\n        n.execute();\n      } catch (i) {\n        var r;\n        if (n.onError(i), this.queues === null || this.tracks === null)\n          return;\n        const o = (r = this.tracks[e]) == null ? void 0 : r.buffer;\n        o != null &amp;&amp; o.updating || this.shiftAndExecuteNext(e);\n      }\n    }\n  }\n  shiftAndExecuteNext(e) {\n    this.queues !== null &amp;&amp; (this.queues[e].shift(), this.executeNext(e));\n  }\n  current(e) {\n    var t;\n    return ((t = this.queues) == null ? void 0 : t[e][0]) || null;\n  }\n  toString() {\n    const {\n      queues: e,\n      tracks: t\n    } = this;\n    return e === null || t === null ? \"&lt;destroyed&gt;\" : `\n${this.list(\"video\")}\n${this.list(\"audio\")}\n${this.list(\"audiovideo\")}}`;\n  }\n  list(e) {\n    var t, r;\n    return (t = this.queues) != null &amp;&amp; t[e] || (r = this.tracks) != null &amp;&amp; r[e] ? `${e}: (${this.listSbInfo(e)}) ${this.listOps(e)}` : \"\";\n  }\n  listSbInfo(e) {\n    var t;\n    const r = (t = this.tracks) == null ? void 0 : t[e], n = r == null ? void 0 : r.buffer;\n    return n ? `SourceBuffer${n.updating ? \" updating\" : \"\"}${r.ended ? \" ended\" : \"\"}${r.ending ? \" ending\" : \"\"}` : \"none\";\n  }\n  listOps(e) {\n    var t;\n    return ((t = this.queues) == null ? void 0 : t[e].map((r) =&gt; r.label).join(\", \")) || \"\";\n  }\n}\nconst Kh = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\\.[^.,]+)+/, Ip = \"HlsJsTrackRemovedError\";\nclass a2 extends Error {\n  constructor(e) {\n    super(e), this.name = Ip;\n  }\n}\nclass l2 extends Lr {\n  constructor(e, t) {\n    super(\"buffer-controller\", e.logger), this.hls = void 0, this.fragmentTracker = void 0, this.details = null, this._objectUrl = null, this.operationQueue = null, this.bufferCodecEventsTotal = 0, this.media = null, this.mediaSource = null, this.lastMpegAudioChunk = null, this.blockedAudioAppend = null, this.lastVideoAppendEnd = 0, this.appendSource = void 0, this.transferData = void 0, this.overrides = void 0, this.appendErrors = {\n      audio: 0,\n      video: 0,\n      audiovideo: 0\n    }, this.tracks = {}, this.sourceBuffers = [[null, null], [null, null]], this._onEndStreaming = (r) =&gt; {\n      var n;\n      this.hls &amp;&amp; ((n = this.mediaSource) == null ? void 0 : n.readyState) === \"open\" &amp;&amp; this.hls.pauseBuffering();\n    }, this._onStartStreaming = (r) =&gt; {\n      this.hls &amp;&amp; this.hls.resumeBuffering();\n    }, this._onMediaSourceOpen = (r) =&gt; {\n      const {\n        media: n,\n        mediaSource: i\n      } = this;\n      r &amp;&amp; this.log(\"Media source opened\"), !(!n || !i) &amp;&amp; (i.removeEventListener(\"sourceopen\", this._onMediaSourceOpen), n.removeEventListener(\"emptied\", this._onMediaEmptied), this.updateDuration(), this.hls.trigger(I.MEDIA_ATTACHED, {\n        media: n,\n        mediaSource: i\n      }), this.mediaSource !== null &amp;&amp; this.checkPendingTracks());\n    }, this._onMediaSourceClose = () =&gt; {\n      this.log(\"Media source closed\");\n    }, this._onMediaSourceEnded = () =&gt; {\n      this.log(\"Media source ended\");\n    }, this._onMediaEmptied = () =&gt; {\n      const {\n        mediaSrc: r,\n        _objectUrl: n\n      } = this;\n      r !== n &amp;&amp; this.error(`Media element src was set while attaching MediaSource (${n} &gt; ${r})`);\n    }, this.hls = e, this.fragmentTracker = t, this.appendSource = CS(Ms(e.config.preferManagedMediaSource)), this.initTracks(), this.registerListeners();\n  }\n  hasSourceTypes() {\n    return Object.keys(this.tracks).length &gt; 0;\n  }\n  destroy() {\n    this.unregisterListeners(), this.details = null, this.lastMpegAudioChunk = this.blockedAudioAppend = null, this.transferData = this.overrides = void 0, this.operationQueue &amp;&amp; (this.operationQueue.destroy(), this.operationQueue = null), this.hls = this.fragmentTracker = null, this._onMediaSourceOpen = this._onMediaSourceClose = null, this._onMediaSourceEnded = null, this._onStartStreaming = this._onEndStreaming = null;\n  }\n  registerListeners() {\n    const {\n      hls: e\n    } = this;\n    e.on(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.MANIFEST_PARSED, this.onManifestParsed, this), e.on(I.BUFFER_RESET, this.onBufferReset, this), e.on(I.BUFFER_APPENDING, this.onBufferAppending, this), e.on(I.BUFFER_CODECS, this.onBufferCodecs, this), e.on(I.BUFFER_EOS, this.onBufferEos, this), e.on(I.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(I.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(I.FRAG_PARSED, this.onFragParsed, this), e.on(I.FRAG_CHANGED, this.onFragChanged, this), e.on(I.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls: e\n    } = this;\n    e.off(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.MANIFEST_PARSED, this.onManifestParsed, this), e.off(I.BUFFER_RESET, this.onBufferReset, this), e.off(I.BUFFER_APPENDING, this.onBufferAppending, this), e.off(I.BUFFER_CODECS, this.onBufferCodecs, this), e.off(I.BUFFER_EOS, this.onBufferEos, this), e.off(I.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(I.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(I.FRAG_PARSED, this.onFragParsed, this), e.off(I.FRAG_CHANGED, this.onFragChanged, this), e.off(I.ERROR, this.onError, this);\n  }\n  transferMedia() {\n    const {\n      media: e,\n      mediaSource: t\n    } = this;\n    if (!e)\n      return null;\n    const r = {};\n    if (this.operationQueue) {\n      const i = this.isUpdating();\n      i || this.operationQueue.removeBlockers();\n      const o = this.isQueued();\n      (i || o) &amp;&amp; this.warn(`Transfering MediaSource with${o ? \" operations in queue\" : \"\"}${i ? \" updating SourceBuffer(s)\" : \"\"} ${this.operationQueue}`), this.operationQueue.destroy();\n    }\n    const n = this.transferData;\n    return !this.sourceBufferCount &amp;&amp; n &amp;&amp; n.mediaSource === t ? nt(r, n.tracks) : this.sourceBuffers.forEach((i) =&gt; {\n      const [o] = i;\n      o &amp;&amp; (r[o] = nt({}, this.tracks[o]), this.removeBuffer(o)), i[0] = i[1] = null;\n    }), {\n      media: e,\n      mediaSource: t,\n      tracks: r\n    };\n  }\n  initTracks() {\n    const e = {};\n    this.sourceBuffers = [[null, null], [null, null]], this.tracks = e, this.resetQueue(), this.resetAppendErrors(), this.lastMpegAudioChunk = this.blockedAudioAppend = null, this.lastVideoAppendEnd = 0;\n  }\n  onManifestLoading() {\n    this.bufferCodecEventsTotal = 0, this.details = null;\n  }\n  onManifestParsed(e, t) {\n    var r;\n    let n = 2;\n    (t.audio &amp;&amp; !t.video || !t.altAudio) &amp;&amp; (n = 1), this.bufferCodecEventsTotal = n, this.log(`${n} bufferCodec event(s) expected.`), (r = this.transferData) != null &amp;&amp; r.mediaSource &amp;&amp; this.sourceBufferCount &amp;&amp; n &amp;&amp; this.bufferCreated();\n  }\n  onMediaAttaching(e, t) {\n    const r = this.media = t.media;\n    this.transferData = this.overrides = void 0;\n    const n = Ms(this.appendSource);\n    if (n) {\n      const i = !!t.mediaSource;\n      (i || t.overrides) &amp;&amp; (this.transferData = t, this.overrides = t.overrides);\n      const o = this.mediaSource = t.mediaSource || new n();\n      if (this.assignMediaSource(o), i)\n        this._objectUrl = r.src, this.attachTransferred();\n      else {\n        const a = this._objectUrl = self.URL.createObjectURL(o);\n        if (this.appendSource)\n          try {\n            r.removeAttribute(\"src\");\n            const l = self.ManagedMediaSource;\n            r.disableRemotePlayback = r.disableRemotePlayback || l &amp;&amp; o instanceof l, Hh(r), c2(r, a), r.load();\n          } catch {\n            r.src = a;\n          }\n        else\n          r.src = a;\n      }\n      r.addEventListener(\"emptied\", this._onMediaEmptied);\n    }\n  }\n  assignMediaSource(e) {\n    var t, r;\n    this.log(`${((t = this.transferData) == null ? void 0 : t.mediaSource) === e ? \"transferred\" : \"created\"} media source: ${(r = e.constructor) == null ? void 0 : r.name}`), e.addEventListener(\"sourceopen\", this._onMediaSourceOpen), e.addEventListener(\"sourceended\", this._onMediaSourceEnded), e.addEventListener(\"sourceclose\", this._onMediaSourceClose), this.appendSource &amp;&amp; (e.addEventListener(\"startstreaming\", this._onStartStreaming), e.addEventListener(\"endstreaming\", this._onEndStreaming));\n  }\n  attachTransferred() {\n    const e = this.media, t = this.transferData;\n    if (!t || !e)\n      return;\n    const r = this.tracks, n = t.tracks, i = n ? Object.keys(n) : null, o = i ? i.length : 0, a = () =&gt; {\n      Promise.resolve().then(() =&gt; {\n        this.media &amp;&amp; this.mediaSourceOpenOrEnded &amp;&amp; this._onMediaSourceOpen();\n      });\n    };\n    if (n &amp;&amp; i &amp;&amp; o) {\n      if (!this.tracksReady) {\n        this.hls.config.startFragPrefetch = !0, this.log(\"attachTransferred: waiting for SourceBuffer track info\");\n        return;\n      }\n      if (this.log(`attachTransferred: (bufferCodecEventsTotal ${this.bufferCodecEventsTotal})\nrequired tracks: ${at(r, (l, c) =&gt; l === \"initSegment\" ? void 0 : c)};\ntransfer tracks: ${at(n, (l, c) =&gt; l === \"initSegment\" ? void 0 : c)}}`), !Ag(n, r)) {\n        t.mediaSource = null, t.tracks = void 0;\n        const l = e.currentTime, c = this.details, u = Math.max(l, (c == null ? void 0 : c.fragments[0].start) || 0);\n        if (u - l &gt; 1) {\n          this.log(`attachTransferred: waiting for playback to reach new tracks start time ${l} -&gt; ${u}`);\n          return;\n        }\n        this.warn(`attachTransferred: resetting MediaSource for incompatible tracks (\"${Object.keys(n)}\"-&gt;\"${Object.keys(r)}\") start time: ${u} currentTime: ${l}`), this.onMediaDetaching(I.MEDIA_DETACHING, {}), this.onMediaAttaching(I.MEDIA_ATTACHING, t), e.currentTime = u;\n        return;\n      }\n      this.transferData = void 0, i.forEach((l) =&gt; {\n        const c = l, u = n[c];\n        if (u) {\n          const d = u.buffer;\n          if (d) {\n            const h = this.fragmentTracker, f = u.id;\n            if (h.hasFragments(f) || h.hasParts(f)) {\n              const E = Ce.getBuffered(d);\n              h.detectEvictedFragments(c, E, f, null, !0);\n            }\n            const p = Sl(c), y = [c, d];\n            this.sourceBuffers[p] = y, d.updating &amp;&amp; this.operationQueue &amp;&amp; this.operationQueue.prependBlocker(c), this.trackSourceBuffer(c, u);\n          }\n        }\n      }), a(), this.bufferCreated();\n    } else\n      this.log(\"attachTransferred: MediaSource w/o SourceBuffers\"), a();\n  }\n  get mediaSourceOpenOrEnded() {\n    var e;\n    const t = (e = this.mediaSource) == null ? void 0 : e.readyState;\n    return t === \"open\" || t === \"ended\";\n  }\n  onMediaDetaching(e, t) {\n    const r = !!t.transferMedia;\n    this.transferData = this.overrides = void 0;\n    const {\n      media: n,\n      mediaSource: i,\n      _objectUrl: o\n    } = this;\n    if (i) {\n      if (this.log(`media source ${r ? \"transferring\" : \"detaching\"}`), r)\n        this.sourceBuffers.forEach(([a]) =&gt; {\n          a &amp;&amp; this.removeBuffer(a);\n        }), this.resetQueue();\n      else {\n        if (this.mediaSourceOpenOrEnded) {\n          const a = i.readyState === \"open\";\n          try {\n            const l = i.sourceBuffers;\n            for (let c = l.length; c--; )\n              a &amp;&amp; l[c].abort(), i.removeSourceBuffer(l[c]);\n            a &amp;&amp; i.endOfStream();\n          } catch (l) {\n            this.warn(`onMediaDetaching: ${l.message} while calling endOfStream`);\n          }\n        }\n        this.sourceBufferCount &amp;&amp; this.onBufferReset();\n      }\n      i.removeEventListener(\"sourceopen\", this._onMediaSourceOpen), i.removeEventListener(\"sourceended\", this._onMediaSourceEnded), i.removeEventListener(\"sourceclose\", this._onMediaSourceClose), this.appendSource &amp;&amp; (i.removeEventListener(\"startstreaming\", this._onStartStreaming), i.removeEventListener(\"endstreaming\", this._onEndStreaming)), this.mediaSource = null, this._objectUrl = null;\n    }\n    n &amp;&amp; (n.removeEventListener(\"emptied\", this._onMediaEmptied), r || (o &amp;&amp; self.URL.revokeObjectURL(o), this.mediaSrc === o ? (n.removeAttribute(\"src\"), this.appendSource &amp;&amp; Hh(n), n.load()) : this.warn(\"media|source.src was changed by a third party - skip cleanup\")), this.media = null), this.hls.trigger(I.MEDIA_DETACHED, t);\n  }\n  onBufferReset() {\n    this.sourceBuffers.forEach(([e]) =&gt; {\n      e &amp;&amp; this.resetBuffer(e);\n    }), this.initTracks();\n  }\n  resetBuffer(e) {\n    var t;\n    const r = (t = this.tracks[e]) == null ? void 0 : t.buffer;\n    if (this.removeBuffer(e), r)\n      try {\n        var n;\n        (n = this.mediaSource) != null &amp;&amp; n.sourceBuffers.length &amp;&amp; this.mediaSource.removeSourceBuffer(r);\n      } catch (i) {\n        this.warn(`onBufferReset ${e}`, i);\n      }\n    delete this.tracks[e];\n  }\n  removeBuffer(e) {\n    this.removeBufferListeners(e), this.sourceBuffers[Sl(e)] = [null, null];\n    const t = this.tracks[e];\n    t &amp;&amp; (t.buffer = void 0);\n  }\n  resetQueue() {\n    this.operationQueue &amp;&amp; this.operationQueue.destroy(), this.operationQueue = new o2(this.tracks);\n  }\n  onBufferCodecs(e, t) {\n    var r;\n    const n = this.tracks, i = Object.keys(t);\n    this.log(`BUFFER_CODECS: \"${i}\" (current SB count ${this.sourceBufferCount})`);\n    const o = \"audiovideo\" in t &amp;&amp; (n.audio || n.video) || n.audiovideo &amp;&amp; (\"audio\" in t || \"video\" in t), a = !o &amp;&amp; this.sourceBufferCount &amp;&amp; this.media &amp;&amp; i.some((l) =&gt; !n[l]);\n    if (o || a) {\n      this.warn(`Unsupported transition between \"${Object.keys(n)}\" and \"${i}\" SourceBuffers`);\n      return;\n    }\n    i.forEach((l) =&gt; {\n      var c, u;\n      const d = t[l], {\n        id: h,\n        codec: f,\n        levelCodec: p,\n        container: y,\n        metadata: E,\n        supplemental: b\n      } = d;\n      let R = n[l];\n      const A = (c = this.transferData) == null || (c = c.tracks) == null ? void 0 : c[l], F = A != null &amp;&amp; A.buffer ? A : R, M = (F == null ? void 0 : F.pendingCodec) || (F == null ? void 0 : F.codec), H = F == null ? void 0 : F.levelCodec;\n      R || (R = n[l] = {\n        buffer: void 0,\n        listeners: [],\n        codec: f,\n        supplemental: b,\n        container: y,\n        levelCodec: p,\n        metadata: E,\n        id: h\n      });\n      const K = fo(M, H), j = K == null ? void 0 : K.replace(Kh, \"$1\");\n      let C = fo(f, p);\n      const k = (u = C) == null ? void 0 : u.replace(Kh, \"$1\");\n      C &amp;&amp; K &amp;&amp; j !== k &amp;&amp; (l.slice(0, 5) === \"audio\" &amp;&amp; (C = Xo(C, this.appendSource)), this.log(`switching codec ${M} to ${C}`), C !== (R.pendingCodec || R.codec) &amp;&amp; (R.pendingCodec = C), R.container = y, this.appendChangeType(l, y, C));\n    }), (this.tracksReady || this.sourceBufferCount) &amp;&amp; (t.tracks = this.sourceBufferTracks), !this.sourceBufferCount &amp;&amp; (this.bufferCodecEventsTotal &gt; 1 &amp;&amp; !this.tracks.video &amp;&amp; !t.video &amp;&amp; ((r = t.audio) == null ? void 0 : r.id) === \"main\" &amp;&amp; (this.log(\"Main audio-only\"), this.bufferCodecEventsTotal = 1), this.mediaSourceOpenOrEnded &amp;&amp; this.checkPendingTracks());\n  }\n  get sourceBufferTracks() {\n    return Object.keys(this.tracks).reduce((e, t) =&gt; {\n      const r = this.tracks[t];\n      return e[t] = {\n        id: r.id,\n        container: r.container,\n        codec: r.codec,\n        levelCodec: r.levelCodec\n      }, e;\n    }, {});\n  }\n  appendChangeType(e, t, r) {\n    const n = `${t};codecs=${r}`, i = {\n      label: `change-type=${n}`,\n      execute: () =&gt; {\n        const o = this.tracks[e];\n        if (o) {\n          const a = o.buffer;\n          a != null &amp;&amp; a.changeType &amp;&amp; (this.log(`changing ${e} sourceBuffer type to ${n}`), a.changeType(n), o.codec = r, o.container = t);\n        }\n        this.shiftAndExecuteNext(e);\n      },\n      onStart: () =&gt; {\n      },\n      onComplete: () =&gt; {\n      },\n      onError: (o) =&gt; {\n        this.warn(`Failed to change ${e} SourceBuffer type`, o);\n      }\n    };\n    this.append(i, e, this.isPending(this.tracks[e]));\n  }\n  blockAudio(e) {\n    var t;\n    const r = e.start, n = r + e.duration * 0.05;\n    if (((t = this.fragmentTracker.getAppendedFrag(r, pe.MAIN)) == null ? void 0 : t.gap) === !0)\n      return;\n    const o = {\n      label: \"block-audio\",\n      execute: () =&gt; {\n        var a;\n        const l = this.tracks.video;\n        (this.lastVideoAppendEnd &gt; n || l != null &amp;&amp; l.buffer &amp;&amp; Ce.isBuffered(l.buffer, n) || ((a = this.fragmentTracker.getAppendedFrag(n, pe.MAIN)) == null ? void 0 : a.gap) === !0) &amp;&amp; (this.blockedAudioAppend = null, this.shiftAndExecuteNext(\"audio\"));\n      },\n      onStart: () =&gt; {\n      },\n      onComplete: () =&gt; {\n      },\n      onError: (a) =&gt; {\n        this.warn(\"Error executing block-audio operation\", a);\n      }\n    };\n    this.blockedAudioAppend = {\n      op: o,\n      frag: e\n    }, this.append(o, \"audio\", !0);\n  }\n  unblockAudio() {\n    const {\n      blockedAudioAppend: e,\n      operationQueue: t\n    } = this;\n    e &amp;&amp; t &amp;&amp; (this.blockedAudioAppend = null, t.unblockAudio(e.op));\n  }\n  onBufferAppending(e, t) {\n    const {\n      tracks: r\n    } = this, {\n      data: n,\n      type: i,\n      parent: o,\n      frag: a,\n      part: l,\n      chunkMeta: c,\n      offset: u\n    } = t, d = c.buffering[i], {\n      sn: h,\n      cc: f\n    } = a, p = self.performance.now();\n    d.start = p;\n    const y = a.stats.buffering, E = l ? l.stats.buffering : null;\n    y.start === 0 &amp;&amp; (y.start = p), E &amp;&amp; E.start === 0 &amp;&amp; (E.start = p);\n    const b = r.audio;\n    let R = !1;\n    i === \"audio\" &amp;&amp; (b == null ? void 0 : b.container) === \"audio/mpeg\" &amp;&amp; (R = !this.lastMpegAudioChunk || c.id === 1 || this.lastMpegAudioChunk.sn !== c.sn, this.lastMpegAudioChunk = c);\n    const A = r.video, F = A == null ? void 0 : A.buffer;\n    if (F &amp;&amp; h !== \"initSegment\") {\n      const K = l || a, j = this.blockedAudioAppend;\n      if (i === \"audio\" &amp;&amp; o !== \"main\" &amp;&amp; !this.blockedAudioAppend &amp;&amp; !(A.ending || A.ended)) {\n        const k = K.start + K.duration * 0.05, $ = F.buffered, W = this.currentOp(\"video\");\n        !$.length &amp;&amp; !W ? this.blockAudio(K) : !W &amp;&amp; !Ce.isBuffered(F, k) &amp;&amp; this.lastVideoAppendEnd &lt; k &amp;&amp; this.blockAudio(K);\n      } else if (i === \"video\") {\n        const C = K.end;\n        if (j) {\n          const k = j.frag.start;\n          (C &gt; k || C &lt; this.lastVideoAppendEnd || Ce.isBuffered(F, k)) &amp;&amp; this.unblockAudio();\n        }\n        this.lastVideoAppendEnd = C;\n      }\n    }\n    const M = (l || a).start, H = {\n      label: `append-${i}`,\n      execute: () =&gt; {\n        var K;\n        d.executeStart = self.performance.now();\n        const j = (K = this.tracks[i]) == null ? void 0 : K.buffer;\n        j &amp;&amp; (R ? this.updateTimestampOffset(j, M, 0.1, i, h, f) : u !== void 0 &amp;&amp; ue(u) &amp;&amp; this.updateTimestampOffset(j, u, 1e-6, i, h, f)), this.appendExecutor(n, i);\n      },\n      onStart: () =&gt; {\n      },\n      onComplete: () =&gt; {\n        const K = self.performance.now();\n        d.executeEnd = d.end = K, y.first === 0 &amp;&amp; (y.first = K), E &amp;&amp; E.first === 0 &amp;&amp; (E.first = K);\n        const j = {};\n        this.sourceBuffers.forEach(([C, k]) =&gt; {\n          C &amp;&amp; (j[C] = Ce.getBuffered(k));\n        }), this.appendErrors[i] = 0, i === \"audio\" || i === \"video\" ? this.appendErrors.audiovideo = 0 : (this.appendErrors.audio = 0, this.appendErrors.video = 0), this.hls.trigger(I.BUFFER_APPENDED, {\n          type: i,\n          frag: a,\n          part: l,\n          chunkMeta: c,\n          parent: a.type,\n          timeRanges: j\n        });\n      },\n      onError: (K) =&gt; {\n        var j;\n        const C = {\n          type: ve.MEDIA_ERROR,\n          parent: a.type,\n          details: J.BUFFER_APPEND_ERROR,\n          sourceBufferName: i,\n          frag: a,\n          part: l,\n          chunkMeta: c,\n          error: K,\n          err: K,\n          fatal: !1\n        }, k = (j = this.media) == null ? void 0 : j.error;\n        if (K.code === DOMException.QUOTA_EXCEEDED_ERR || K.name == \"QuotaExceededError\" || \"quota\" in K)\n          C.details = J.BUFFER_FULL_ERROR;\n        else if (K.code === DOMException.INVALID_STATE_ERR &amp;&amp; this.mediaSourceOpenOrEnded &amp;&amp; !k)\n          C.errorAction = An(!0);\n        else if (K.name === Ip &amp;&amp; this.sourceBufferCount === 0)\n          C.errorAction = An(!0);\n        else {\n          const $ = ++this.appendErrors[i];\n          this.warn(`Failed ${$}/${this.hls.config.appendErrorMaxRetry} times to append segment in \"${i}\" sourceBuffer (${k || \"no media error\"})`), ($ &gt;= this.hls.config.appendErrorMaxRetry || k) &amp;&amp; (C.fatal = !0);\n        }\n        this.hls.trigger(I.ERROR, C);\n      }\n    };\n    this.log(`queuing \"${i}\" append sn: ${h}${l ? \" p: \" + l.index : \"\"} of ${a.type === pe.MAIN ? \"level\" : \"track\"} ${a.level} cc: ${f}`), this.append(H, i, this.isPending(this.tracks[i]));\n  }\n  getFlushOp(e, t, r) {\n    return this.log(`queuing \"${e}\" remove ${t}-${r}`), {\n      label: \"remove\",\n      execute: () =&gt; {\n        this.removeExecutor(e, t, r);\n      },\n      onStart: () =&gt; {\n      },\n      onComplete: () =&gt; {\n        this.hls.trigger(I.BUFFER_FLUSHED, {\n          type: e\n        });\n      },\n      onError: (n) =&gt; {\n        this.warn(`Failed to remove ${t}-${r} from \"${e}\" SourceBuffer`, n);\n      }\n    };\n  }\n  onBufferFlushing(e, t) {\n    const {\n      type: r,\n      startOffset: n,\n      endOffset: i\n    } = t;\n    r ? this.append(this.getFlushOp(r, n, i), r) : this.sourceBuffers.forEach(([o]) =&gt; {\n      o &amp;&amp; this.append(this.getFlushOp(o, n, i), o);\n    });\n  }\n  onFragParsed(e, t) {\n    const {\n      frag: r,\n      part: n\n    } = t, i = [], o = n ? n.elementaryStreams : r.elementaryStreams;\n    o[ot.AUDIOVIDEO] ? i.push(\"audiovideo\") : (o[ot.AUDIO] &amp;&amp; i.push(\"audio\"), o[ot.VIDEO] &amp;&amp; i.push(\"video\"));\n    const a = () =&gt; {\n      const l = self.performance.now();\n      r.stats.buffering.end = l, n &amp;&amp; (n.stats.buffering.end = l);\n      const c = n ? n.stats : r.stats;\n      this.hls.trigger(I.FRAG_BUFFERED, {\n        frag: r,\n        part: n,\n        stats: c,\n        id: r.type\n      });\n    };\n    i.length === 0 &amp;&amp; this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${r.type} level: ${r.level} sn: ${r.sn}`), this.blockBuffers(a, i).catch((l) =&gt; {\n      this.warn(`Fragment buffered callback ${l}`), this.stepOperationQueue(this.sourceBufferTypes);\n    });\n  }\n  onFragChanged(e, t) {\n    this.trimBuffers();\n  }\n  get bufferedToEnd() {\n    return this.sourceBufferCount &gt; 0 &amp;&amp; !this.sourceBuffers.some(([e]) =&gt; {\n      if (e) {\n        const t = this.tracks[e];\n        if (t)\n          return !t.ended || t.ending;\n      }\n      return !1;\n    });\n  }\n  // on BUFFER_EOS mark matching sourcebuffer(s) as \"ending\" and \"ended\" and queue endOfStream after remaining operations(s)\n  // an undefined data.type will mark all buffers as EOS.\n  onBufferEos(e, t) {\n    var r;\n    this.sourceBuffers.forEach(([o]) =&gt; {\n      if (o) {\n        const a = this.tracks[o];\n        (!t.type || t.type === o) &amp;&amp; (a.ending = !0, a.ended || (a.ended = !0, this.log(`${o} buffer reached EOS`)));\n      }\n    });\n    const n = ((r = this.overrides) == null ? void 0 : r.endOfStream) !== !1;\n    this.sourceBufferCount &gt; 0 &amp;&amp; !this.sourceBuffers.some(([o]) =&gt; {\n      var a;\n      return o &amp;&amp; !((a = this.tracks[o]) != null &amp;&amp; a.ended);\n    }) ? n ? (this.log(\"Queueing EOS\"), this.blockUntilOpen(() =&gt; {\n      this.tracksEnded();\n      const {\n        mediaSource: o\n      } = this;\n      if (!o || o.readyState !== \"open\") {\n        o &amp;&amp; this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${o.readyState}`);\n        return;\n      }\n      this.log(\"Calling mediaSource.endOfStream()\"), o.endOfStream(), this.hls.trigger(I.BUFFERED_TO_END, void 0);\n    })) : (this.tracksEnded(), this.hls.trigger(I.BUFFERED_TO_END, void 0)) : t.type === \"video\" &amp;&amp; this.unblockAudio();\n  }\n  tracksEnded() {\n    this.sourceBuffers.forEach(([e]) =&gt; {\n      if (e !== null) {\n        const t = this.tracks[e];\n        t &amp;&amp; (t.ending = !1);\n      }\n    });\n  }\n  onLevelUpdated(e, {\n    details: t\n  }) {\n    t.fragments.length &amp;&amp; (this.details = t, this.updateDuration());\n  }\n  updateDuration() {\n    this.blockUntilOpen(() =&gt; {\n      const e = this.getDurationAndRange();\n      e &amp;&amp; this.updateMediaSource(e);\n    });\n  }\n  onError(e, t) {\n    if (t.details === J.BUFFER_APPEND_ERROR &amp;&amp; t.frag) {\n      var r;\n      const n = (r = t.errorAction) == null ? void 0 : r.nextAutoLevel;\n      ue(n) &amp;&amp; n !== t.frag.level &amp;&amp; this.resetAppendErrors();\n    }\n  }\n  resetAppendErrors() {\n    this.appendErrors = {\n      audio: 0,\n      video: 0,\n      audiovideo: 0\n    };\n  }\n  trimBuffers() {\n    const {\n      hls: e,\n      details: t,\n      media: r\n    } = this;\n    if (!r || t === null || !this.sourceBufferCount)\n      return;\n    const n = e.config, i = r.currentTime, o = t.levelTargetDuration, a = t.live &amp;&amp; n.liveBackBufferLength !== null ? n.liveBackBufferLength : n.backBufferLength;\n    if (ue(a) &amp;&amp; a &gt;= 0) {\n      const c = Math.max(a, o), u = Math.floor(i / o) * o - c;\n      this.flushBackBuffer(i, o, u);\n    }\n    const l = n.frontBufferFlushThreshold;\n    if (ue(l) &amp;&amp; l &gt; 0) {\n      const c = Math.max(n.maxBufferLength, l), u = Math.max(c, o), d = Math.floor(i / o) * o + u;\n      this.flushFrontBuffer(i, o, d);\n    }\n  }\n  flushBackBuffer(e, t, r) {\n    this.sourceBuffers.forEach(([n, i]) =&gt; {\n      if (i) {\n        const a = Ce.getBuffered(i);\n        if (a.length &gt; 0 &amp;&amp; r &gt; a.start(0)) {\n          var o;\n          this.hls.trigger(I.BACK_BUFFER_REACHED, {\n            bufferEnd: r\n          });\n          const l = this.tracks[n];\n          if ((o = this.details) != null &amp;&amp; o.live)\n            this.hls.trigger(I.LIVE_BACK_BUFFER_REACHED, {\n              bufferEnd: r\n            });\n          else if (l != null &amp;&amp; l.ended) {\n            this.log(`Cannot flush ${n} back buffer while SourceBuffer is in ended state`);\n            return;\n          }\n          this.hls.trigger(I.BUFFER_FLUSHING, {\n            startOffset: 0,\n            endOffset: r,\n            type: n\n          });\n        }\n      }\n    });\n  }\n  flushFrontBuffer(e, t, r) {\n    this.sourceBuffers.forEach(([n, i]) =&gt; {\n      if (i) {\n        const o = Ce.getBuffered(i), a = o.length;\n        if (a &lt; 2)\n          return;\n        const l = o.start(a - 1), c = o.end(a - 1);\n        if (r &gt; l || e &gt;= l &amp;&amp; e &lt;= c)\n          return;\n        this.hls.trigger(I.BUFFER_FLUSHING, {\n          startOffset: l,\n          endOffset: 1 / 0,\n          type: n\n        });\n      }\n    });\n  }\n  /**\n   * Update Media Source duration to current level duration or override to Infinity if configuration parameter\n   * 'liveDurationInfinity` is set to `true`\n   * More details: https://github.com/video-dev/hls.js/issues/355\n   */\n  getDurationAndRange() {\n    var e;\n    const {\n      details: t,\n      mediaSource: r\n    } = this;\n    if (!t || !this.media || (r == null ? void 0 : r.readyState) !== \"open\")\n      return null;\n    const n = t.edge;\n    if (t.live &amp;&amp; this.hls.config.liveDurationInfinity) {\n      if (t.fragments.length &amp;&amp; r.setLiveSeekableRange) {\n        const c = Math.max(0, t.fragmentStart), u = Math.max(c, n);\n        return {\n          duration: 1 / 0,\n          start: c,\n          end: u\n        };\n      }\n      return {\n        duration: 1 / 0\n      };\n    }\n    const i = (e = this.overrides) == null ? void 0 : e.duration;\n    if (i)\n      return ue(i) ? {\n        duration: i\n      } : null;\n    const o = this.media.duration, a = ue(r.duration) ? r.duration : 0;\n    return n &gt; a &amp;&amp; n &gt; o || !ue(o) ? {\n      duration: n\n    } : null;\n  }\n  updateMediaSource({\n    duration: e,\n    start: t,\n    end: r\n  }) {\n    const n = this.mediaSource;\n    !this.media || !n || n.readyState !== \"open\" || (n.duration !== e &amp;&amp; (ue(e) &amp;&amp; this.log(`Updating MediaSource duration to ${e.toFixed(3)}`), n.duration = e), t !== void 0 &amp;&amp; r !== void 0 &amp;&amp; (this.log(`MediaSource duration is set to ${n.duration}. Setting seekable range to ${t}-${r}.`), n.setLiveSeekableRange(t, r)));\n  }\n  get tracksReady() {\n    const e = this.pendingTrackCount;\n    return e &gt; 0 &amp;&amp; (e &gt;= this.bufferCodecEventsTotal || this.isPending(this.tracks.audiovideo));\n  }\n  checkPendingTracks() {\n    const {\n      bufferCodecEventsTotal: e,\n      pendingTrackCount: t,\n      tracks: r\n    } = this;\n    if (this.log(`checkPendingTracks (pending: ${t} codec events expected: ${e}) ${at(r)}`), this.tracksReady) {\n      var n;\n      const i = (n = this.transferData) == null ? void 0 : n.tracks;\n      i &amp;&amp; Object.keys(i).length ? this.attachTransferred() : this.createSourceBuffers();\n    }\n  }\n  bufferCreated() {\n    if (this.sourceBufferCount) {\n      const e = {};\n      this.sourceBuffers.forEach(([t, r]) =&gt; {\n        if (t) {\n          const n = this.tracks[t];\n          e[t] = {\n            buffer: r,\n            container: n.container,\n            codec: n.codec,\n            supplemental: n.supplemental,\n            levelCodec: n.levelCodec,\n            id: n.id,\n            metadata: n.metadata\n          };\n        }\n      }), this.hls.trigger(I.BUFFER_CREATED, {\n        tracks: e\n      }), this.log(`SourceBuffers created. Running queue: ${this.operationQueue}`), this.sourceBuffers.forEach(([t]) =&gt; {\n        this.executeNext(t);\n      });\n    } else {\n      const e = new Error(\"could not create source buffer for media codec(s)\");\n      this.hls.trigger(I.ERROR, {\n        type: ve.MEDIA_ERROR,\n        details: J.BUFFER_INCOMPATIBLE_CODECS_ERROR,\n        fatal: !0,\n        error: e,\n        reason: e.message\n      });\n    }\n  }\n  createSourceBuffers() {\n    const {\n      tracks: e,\n      sourceBuffers: t,\n      mediaSource: r\n    } = this;\n    if (!r)\n      throw new Error(\"createSourceBuffers called when mediaSource was null\");\n    for (const i in e) {\n      const o = i, a = e[o];\n      if (this.isPending(a)) {\n        const l = this.getTrackCodec(a, o), c = `${a.container};codecs=${l}`;\n        a.codec = l, this.log(`creating sourceBuffer(${c})${this.currentOp(o) ? \" Queued\" : \"\"} ${at(a)}`);\n        try {\n          const u = r.addSourceBuffer(c), d = Sl(o), h = [o, u];\n          t[d] = h, a.buffer = u;\n        } catch (u) {\n          var n;\n          this.error(`error while trying to add sourceBuffer: ${u.message}`), this.shiftAndExecuteNext(o), (n = this.operationQueue) == null || n.removeBlockers(), delete this.tracks[o], this.hls.trigger(I.ERROR, {\n            type: ve.MEDIA_ERROR,\n            details: J.BUFFER_ADD_CODEC_ERROR,\n            fatal: !1,\n            error: u,\n            sourceBufferName: o,\n            mimeType: c,\n            parent: a.id\n          });\n          return;\n        }\n        this.trackSourceBuffer(o, a);\n      }\n    }\n    this.bufferCreated();\n  }\n  getTrackCodec(e, t) {\n    const r = e.supplemental;\n    let n = e.codec;\n    r &amp;&amp; (t === \"video\" || t === \"audiovideo\") &amp;&amp; gi(r, \"video\") &amp;&amp; (n = XS(n, r));\n    const i = fo(n, e.levelCodec);\n    return i ? t.slice(0, 5) === \"audio\" ? Xo(i, this.appendSource) : i : \"\";\n  }\n  trackSourceBuffer(e, t) {\n    const r = t.buffer;\n    if (!r)\n      return;\n    const n = this.getTrackCodec(t, e);\n    this.tracks[e] = {\n      buffer: r,\n      codec: n,\n      container: t.container,\n      levelCodec: t.levelCodec,\n      supplemental: t.supplemental,\n      metadata: t.metadata,\n      id: t.id,\n      listeners: []\n    }, this.removeBufferListeners(e), this.addBufferListener(e, \"updatestart\", this.onSBUpdateStart), this.addBufferListener(e, \"updateend\", this.onSBUpdateEnd), this.addBufferListener(e, \"error\", this.onSBUpdateError), this.appendSource &amp;&amp; this.addBufferListener(e, \"bufferedchange\", (i, o) =&gt; {\n      const a = o.removedRanges;\n      a != null &amp;&amp; a.length &amp;&amp; this.hls.trigger(I.BUFFER_FLUSHED, {\n        type: i\n      });\n    });\n  }\n  get mediaSrc() {\n    var e, t;\n    const r = ((e = this.media) == null || (t = e.querySelector) == null ? void 0 : t.call(e, \"source\")) || this.media;\n    return r == null ? void 0 : r.src;\n  }\n  onSBUpdateStart(e) {\n    const t = this.currentOp(e);\n    t &amp;&amp; t.onStart();\n  }\n  onSBUpdateEnd(e) {\n    var t;\n    if (((t = this.mediaSource) == null ? void 0 : t.readyState) === \"closed\") {\n      this.resetBuffer(e);\n      return;\n    }\n    const r = this.currentOp(e);\n    r &amp;&amp; (r.onComplete(), this.shiftAndExecuteNext(e));\n  }\n  onSBUpdateError(e, t) {\n    var r;\n    const n = new Error(`${e} SourceBuffer error. MediaSource readyState: ${(r = this.mediaSource) == null ? void 0 : r.readyState}`);\n    this.error(`${n}`, t), this.hls.trigger(I.ERROR, {\n      type: ve.MEDIA_ERROR,\n      details: J.BUFFER_APPENDING_ERROR,\n      sourceBufferName: e,\n      error: n,\n      fatal: !1\n    });\n    const i = this.currentOp(e);\n    i &amp;&amp; i.onError(n);\n  }\n  updateTimestampOffset(e, t, r, n, i, o) {\n    const a = t - e.timestampOffset;\n    Math.abs(a) &gt;= r &amp;&amp; (this.log(`Updating ${n} SourceBuffer timestampOffset to ${t} (sn: ${i} cc: ${o})`), e.timestampOffset = t);\n  }\n  // This method must result in an updateend event; if remove is not called, onSBUpdateEnd must be called manually\n  removeExecutor(e, t, r) {\n    const {\n      media: n,\n      mediaSource: i\n    } = this, o = this.tracks[e], a = o == null ? void 0 : o.buffer;\n    if (!n || !i || !a) {\n      this.warn(`Attempting to remove from the ${e} SourceBuffer, but it does not exist`), this.shiftAndExecuteNext(e);\n      return;\n    }\n    const l = ue(n.duration) ? n.duration : 1 / 0, c = ue(i.duration) ? i.duration : 1 / 0, u = Math.max(0, t), d = Math.min(r, l, c);\n    d &gt; u &amp;&amp; (!o.ending || o.ended) ? (o.ended = !1, this.log(`Removing [${u},${d}] from the ${e} SourceBuffer`), a.remove(u, d)) : this.shiftAndExecuteNext(e);\n  }\n  // This method must result in an updateend event; if append is not called, onSBUpdateEnd must be called manually\n  appendExecutor(e, t) {\n    const r = this.tracks[t], n = r == null ? void 0 : r.buffer;\n    if (!n)\n      throw new a2(`Attempting to append to the ${t} SourceBuffer, but it does not exist`);\n    r.ending = !1, r.ended = !1, n.appendBuffer(e);\n  }\n  blockUntilOpen(e) {\n    if (this.isUpdating() || this.isQueued())\n      this.blockBuffers(e).catch((t) =&gt; {\n        this.warn(`SourceBuffer blocked callback ${t}`), this.stepOperationQueue(this.sourceBufferTypes);\n      });\n    else\n      try {\n        e();\n      } catch (t) {\n        this.warn(`Callback run without blocking ${this.operationQueue} ${t}`);\n      }\n  }\n  isUpdating() {\n    return this.sourceBuffers.some(([e, t]) =&gt; e &amp;&amp; t.updating);\n  }\n  isQueued() {\n    return this.sourceBuffers.some(([e]) =&gt; e &amp;&amp; !!this.currentOp(e));\n  }\n  isPending(e) {\n    return !!e &amp;&amp; !e.buffer;\n  }\n  // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises\n  // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue\n  // upon completion, since we already do it here\n  blockBuffers(e, t = this.sourceBufferTypes) {\n    if (!t.length)\n      return this.log(\"Blocking operation requested, but no SourceBuffers exist\"), Promise.resolve().then(e);\n    const {\n      operationQueue: r\n    } = this, n = t.map((o) =&gt; this.appendBlocker(o));\n    return t.length &gt; 1 &amp;&amp; !!this.blockedAudioAppend &amp;&amp; this.unblockAudio(), Promise.all(n).then((o) =&gt; {\n      r === this.operationQueue &amp;&amp; (e(), this.stepOperationQueue(this.sourceBufferTypes));\n    });\n  }\n  stepOperationQueue(e) {\n    e.forEach((t) =&gt; {\n      var r;\n      const n = (r = this.tracks[t]) == null ? void 0 : r.buffer;\n      !n || n.updating || this.shiftAndExecuteNext(t);\n    });\n  }\n  append(e, t, r) {\n    this.operationQueue &amp;&amp; this.operationQueue.append(e, t, r);\n  }\n  appendBlocker(e) {\n    if (this.operationQueue)\n      return this.operationQueue.appendBlocker(e);\n  }\n  currentOp(e) {\n    return this.operationQueue ? this.operationQueue.current(e) : null;\n  }\n  executeNext(e) {\n    e &amp;&amp; this.operationQueue &amp;&amp; this.operationQueue.executeNext(e);\n  }\n  shiftAndExecuteNext(e) {\n    this.operationQueue &amp;&amp; this.operationQueue.shiftAndExecuteNext(e);\n  }\n  get pendingTrackCount() {\n    return Object.keys(this.tracks).reduce((e, t) =&gt; e + (this.isPending(this.tracks[t]) ? 1 : 0), 0);\n  }\n  get sourceBufferCount() {\n    return this.sourceBuffers.reduce((e, [t]) =&gt; e + (t ? 1 : 0), 0);\n  }\n  get sourceBufferTypes() {\n    return this.sourceBuffers.map(([e]) =&gt; e).filter((e) =&gt; !!e);\n  }\n  addBufferListener(e, t, r) {\n    const n = this.tracks[e];\n    if (!n)\n      return;\n    const i = n.buffer;\n    if (!i)\n      return;\n    const o = r.bind(this, e);\n    n.listeners.push({\n      event: t,\n      listener: o\n    }), i.addEventListener(t, o);\n  }\n  removeBufferListeners(e) {\n    const t = this.tracks[e];\n    if (!t)\n      return;\n    const r = t.buffer;\n    r &amp;&amp; (t.listeners.forEach((n) =&gt; {\n      r.removeEventListener(n.event, n.listener);\n    }), t.listeners.length = 0);\n  }\n}\nfunction Hh(s) {\n  const e = s.querySelectorAll(\"source\");\n  [].slice.call(e).forEach((t) =&gt; {\n    s.removeChild(t);\n  });\n}\nfunction c2(s, e) {\n  const t = self.document.createElement(\"source\");\n  t.type = \"video/mp4\", t.src = e, s.appendChild(t);\n}\nfunction Sl(s) {\n  return s === \"audio\" ? 1 : 0;\n}\nclass Du {\n  constructor(e) {\n    this.hls = void 0, this.autoLevelCapping = void 0, this.firstLevel = void 0, this.media = void 0, this.restrictedLevels = void 0, this.timer = void 0, this.clientRect = void 0, this.streamController = void 0, this.hls = e, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.firstLevel = -1, this.media = null, this.restrictedLevels = [], this.timer = void 0, this.clientRect = null, this.registerListeners();\n  }\n  setStreamController(e) {\n    this.streamController = e;\n  }\n  destroy() {\n    this.hls &amp;&amp; this.unregisterListener(), this.timer &amp;&amp; this.stopCapping(), this.media = null, this.clientRect = null, this.hls = this.streamController = null;\n  }\n  registerListeners() {\n    const {\n      hls: e\n    } = this;\n    e.on(I.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.on(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(I.MANIFEST_PARSED, this.onManifestParsed, this), e.on(I.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(I.BUFFER_CODECS, this.onBufferCodecs, this), e.on(I.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  unregisterListener() {\n    const {\n      hls: e\n    } = this;\n    e.off(I.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this), e.off(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(I.MANIFEST_PARSED, this.onManifestParsed, this), e.off(I.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(I.BUFFER_CODECS, this.onBufferCodecs, this), e.off(I.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  onFpsDropLevelCapping(e, t) {\n    const r = this.hls.levels[t.droppedLevel];\n    this.isLevelAllowed(r) &amp;&amp; this.restrictedLevels.push({\n      bitrate: r.bitrate,\n      height: r.height,\n      width: r.width\n    });\n  }\n  onMediaAttaching(e, t) {\n    this.media = t.media instanceof HTMLVideoElement ? t.media : null, this.clientRect = null, this.timer &amp;&amp; this.hls.levels.length &amp;&amp; this.detectPlayerSize();\n  }\n  onManifestParsed(e, t) {\n    const r = this.hls;\n    this.restrictedLevels = [], this.firstLevel = t.firstLevel, r.config.capLevelToPlayerSize &amp;&amp; t.video &amp;&amp; this.startCapping();\n  }\n  onLevelsUpdated(e, t) {\n    this.timer &amp;&amp; ue(this.autoLevelCapping) &amp;&amp; this.detectPlayerSize();\n  }\n  // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted\n  // to the first level\n  onBufferCodecs(e, t) {\n    this.hls.config.capLevelToPlayerSize &amp;&amp; t.video &amp;&amp; this.startCapping();\n  }\n  onMediaDetaching() {\n    this.stopCapping(), this.media = null;\n  }\n  detectPlayerSize() {\n    if (this.media) {\n      if (this.mediaHeight &lt;= 0 || this.mediaWidth &lt;= 0) {\n        this.clientRect = null;\n        return;\n      }\n      const e = this.hls.levels;\n      if (e.length) {\n        const t = this.hls, r = this.getMaxLevel(e.length - 1);\n        r !== this.autoLevelCapping &amp;&amp; t.logger.log(`Setting autoLevelCapping to ${r}: ${e[r].height}p@${e[r].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`), t.autoLevelCapping = r, t.autoLevelEnabled &amp;&amp; t.autoLevelCapping &gt; this.autoLevelCapping &amp;&amp; this.streamController &amp;&amp; this.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping;\n      }\n    }\n  }\n  /*\n   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)\n   */\n  getMaxLevel(e) {\n    const t = this.hls.levels;\n    if (!t.length)\n      return -1;\n    const r = t.filter((n, i) =&gt; this.isLevelAllowed(n) &amp;&amp; i &lt;= e);\n    return this.clientRect = null, Du.getMaxLevelByMediaSize(r, this.mediaWidth, this.mediaHeight);\n  }\n  startCapping() {\n    this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, self.clearInterval(this.timer), this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize());\n  }\n  stopCapping() {\n    this.restrictedLevels = [], this.firstLevel = -1, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer &amp;&amp; (self.clearInterval(this.timer), this.timer = void 0);\n  }\n  getDimensions() {\n    if (this.clientRect)\n      return this.clientRect;\n    const e = this.media, t = {\n      width: 0,\n      height: 0\n    };\n    if (e) {\n      const r = e.getBoundingClientRect();\n      t.width = r.width, t.height = r.height, !t.width &amp;&amp; !t.height &amp;&amp; (t.width = r.right - r.left || e.width || 0, t.height = r.bottom - r.top || e.height || 0);\n    }\n    return this.clientRect = t, t;\n  }\n  get mediaWidth() {\n    return this.getDimensions().width * this.contentScaleFactor;\n  }\n  get mediaHeight() {\n    return this.getDimensions().height * this.contentScaleFactor;\n  }\n  get contentScaleFactor() {\n    let e = 1;\n    if (!this.hls.config.ignoreDevicePixelRatio)\n      try {\n        e = self.devicePixelRatio;\n      } catch {\n      }\n    return Math.min(e, this.hls.config.maxDevicePixelRatio);\n  }\n  isLevelAllowed(e) {\n    return !this.restrictedLevels.some((r) =&gt; e.bitrate === r.bitrate &amp;&amp; e.width === r.width &amp;&amp; e.height === r.height);\n  }\n  static getMaxLevelByMediaSize(e, t, r) {\n    if (!(e != null &amp;&amp; e.length))\n      return -1;\n    const n = (a, l) =&gt; l ? a.width !== l.width || a.height !== l.height : !0;\n    let i = e.length - 1;\n    const o = Math.max(t, r);\n    for (let a = 0; a &lt; e.length; a += 1) {\n      const l = e[a];\n      if ((l.width &gt;= o || l.height &gt;= o) &amp;&amp; n(l, e[a + 1])) {\n        i = a;\n        break;\n      }\n    }\n    return i;\n  }\n}\nconst u2 = {\n  /**\n   * text file, such as a manifest or playlist\n   */\n  MANIFEST: \"m\",\n  /**\n   * audio only\n   */\n  AUDIO: \"a\",\n  /**\n   * video only\n   */\n  VIDEO: \"v\",\n  /**\n   * muxed audio and video\n   */\n  MUXED: \"av\",\n  /**\n   * init segment\n   */\n  INIT: \"i\",\n  /**\n   * caption or subtitle\n   */\n  CAPTION: \"c\",\n  /**\n   * ISOBMFF timed text track\n   */\n  TIMED_TEXT: \"tt\",\n  /**\n   * cryptographic key, license or certificate.\n   */\n  KEY: \"k\",\n  /**\n   * other\n   */\n  OTHER: \"o\"\n}, hr = u2, d2 = {\n  /**\n   * HTTP Live Streaming (HLS)\n   */\n  HLS: \"h\"\n}, h2 = d2;\nclass Jr {\n  constructor(e, t) {\n    Array.isArray(e) &amp;&amp; (e = e.map((r) =&gt; r instanceof Jr ? r : new Jr(r))), this.value = e, this.params = t;\n  }\n}\nconst f2 = \"Dict\";\nfunction g2(s) {\n  return Array.isArray(s) ? JSON.stringify(s) : s instanceof Map ? \"Map{}\" : s instanceof Set ? \"Set{}\" : typeof s == \"object\" ? JSON.stringify(s) : String(s);\n}\nfunction p2(s, e, t, r) {\n  return new Error(`failed to ${s} \"${g2(e)}\" as ${t}`, {\n    cause: r\n  });\n}\nfunction Qr(s, e, t) {\n  return p2(\"serialize\", s, e, t);\n}\nclass _p {\n  constructor(e) {\n    this.description = e;\n  }\n}\nconst qh = \"Bare Item\", m2 = \"Boolean\";\nfunction y2(s) {\n  if (typeof s != \"boolean\")\n    throw Qr(s, m2);\n  return s ? \"?1\" : \"?0\";\n}\nfunction v2(s) {\n  return btoa(String.fromCharCode(...s));\n}\nconst E2 = \"Byte Sequence\";\nfunction x2(s) {\n  if (ArrayBuffer.isView(s) === !1)\n    throw Qr(s, E2);\n  return `:${v2(s)}:`;\n}\nconst S2 = \"Integer\";\nfunction b2(s) {\n  return s &lt; -999999999999999 || 999999999999999 &lt; s;\n}\nfunction Rp(s) {\n  if (b2(s))\n    throw Qr(s, S2);\n  return s.toString();\n}\nfunction T2(s) {\n  return `@${Rp(s.getTime() / 1e3)}`;\n}\nfunction Lp(s, e) {\n  if (s &lt; 0)\n    return -Lp(-s, e);\n  const t = Math.pow(10, e);\n  if (Math.abs(s * t % 1 - 0.5) &lt; Number.EPSILON) {\n    const n = Math.floor(s * t);\n    return (n % 2 === 0 ? n : n + 1) / t;\n  } else\n    return Math.round(s * t) / t;\n}\nconst w2 = \"Decimal\";\nfunction A2(s) {\n  const e = Lp(s, 3);\n  if (Math.floor(Math.abs(e)).toString().length &gt; 12)\n    throw Qr(s, w2);\n  const t = e.toString();\n  return t.includes(\".\") ? t : `${t}.0`;\n}\nconst I2 = \"String\", _2 = /[\\x00-\\x1f\\x7f]+/;\nfunction R2(s) {\n  if (_2.test(s))\n    throw Qr(s, I2);\n  return `\"${s.replace(/\\\\/g, \"\\\\\\\\\").replace(/\"/g, '\\\\\"')}\"`;\n}\nfunction L2(s) {\n  return s.description || s.toString().slice(7, -1);\n}\nconst C2 = \"Token\";\nfunction Wh(s) {\n  const e = L2(s);\n  if (/^([a-zA-Z*])([!#$%&amp;'*+\\-.^_`|~\\w:/]*)$/.test(e) === !1)\n    throw Qr(e, C2);\n  return e;\n}\nfunction vc(s) {\n  switch (typeof s) {\n    case \"number\":\n      if (!ue(s))\n        throw Qr(s, qh);\n      return Number.isInteger(s) ? Rp(s) : A2(s);\n    case \"string\":\n      return R2(s);\n    case \"symbol\":\n      return Wh(s);\n    case \"boolean\":\n      return y2(s);\n    case \"object\":\n      if (s instanceof Date)\n        return T2(s);\n      if (s instanceof Uint8Array)\n        return x2(s);\n      if (s instanceof _p)\n        return Wh(s);\n    default:\n      throw Qr(s, qh);\n  }\n}\nconst k2 = \"Key\";\nfunction Ec(s) {\n  if (/^[a-z*][a-z0-9\\-_.*]*$/.test(s) === !1)\n    throw Qr(s, k2);\n  return s;\n}\nfunction Pu(s) {\n  return s == null ? \"\" : Object.entries(s).map(([e, t]) =&gt; t === !0 ? `;${Ec(e)}` : `;${Ec(e)}=${vc(t)}`).join(\"\");\n}\nfunction Cp(s) {\n  return s instanceof Jr ? `${vc(s.value)}${Pu(s.params)}` : vc(s);\n}\nfunction D2(s) {\n  return `(${s.value.map(Cp).join(\" \")})${Pu(s.params)}`;\n}\nfunction P2(s, e = {\n  whitespace: !0\n}) {\n  if (typeof s != \"object\" || s == null)\n    throw Qr(s, f2);\n  const t = s instanceof Map ? s.entries() : Object.entries(s), r = e != null &amp;&amp; e.whitespace ? \" \" : \"\";\n  return Array.from(t).map(([n, i]) =&gt; {\n    i instanceof Jr || (i = new Jr(i));\n    let o = Ec(n);\n    return i.value === !0 ? o += Pu(i.params) : (o += \"=\", Array.isArray(i.value) ? o += D2(i) : o += Cp(i)), o;\n  }).join(`,${r}`);\n}\nfunction kp(s, e) {\n  return P2(s, e);\n}\nconst $r = \"CMCD-Object\", yt = \"CMCD-Request\", Fs = \"CMCD-Session\", bs = \"CMCD-Status\", M2 = {\n  // Object\n  br: $r,\n  ab: $r,\n  d: $r,\n  ot: $r,\n  tb: $r,\n  tpb: $r,\n  lb: $r,\n  tab: $r,\n  lab: $r,\n  url: $r,\n  // Request\n  pb: yt,\n  bl: yt,\n  tbl: yt,\n  dl: yt,\n  ltc: yt,\n  mtp: yt,\n  nor: yt,\n  nrr: yt,\n  rc: yt,\n  sn: yt,\n  sta: yt,\n  su: yt,\n  ttfb: yt,\n  ttfbb: yt,\n  ttlb: yt,\n  cmsdd: yt,\n  cmsds: yt,\n  smrt: yt,\n  df: yt,\n  cs: yt,\n  // TODO: Which header to put the `ts` field is not defined yet.\n  ts: yt,\n  // Session\n  cid: Fs,\n  pr: Fs,\n  sf: Fs,\n  sid: Fs,\n  st: Fs,\n  v: Fs,\n  msd: Fs,\n  // Status\n  bs,\n  bsd: bs,\n  cdn: bs,\n  rtp: bs,\n  bg: bs,\n  pt: bs,\n  ec: bs,\n  e: bs\n}, O2 = {\n  /**\n   * keys whose values vary with each request.\n   */\n  REQUEST: yt\n};\nfunction B2(s) {\n  return Object.keys(s).reduce((e, t) =&gt; {\n    var r;\n    return (r = s[t]) === null || r === void 0 || r.forEach((n) =&gt; e[n] = t), e;\n  }, {});\n}\nfunction F2(s, e) {\n  const t = {};\n  if (!s)\n    return t;\n  const r = Object.keys(s), n = e ? B2(e) : {};\n  return r.reduce((i, o) =&gt; {\n    var a;\n    const l = M2[o] || n[o] || O2.REQUEST, c = (a = i[l]) !== null &amp;&amp; a !== void 0 ? a : i[l] = {};\n    return c[o] = s[o], i;\n  }, t);\n}\nfunction N2(s) {\n  return [\"ot\", \"sf\", \"st\", \"e\", \"sta\"].includes(s);\n}\nfunction U2(s) {\n  return typeof s == \"number\" ? ue(s) : s != null &amp;&amp; s !== \"\" &amp;&amp; s !== !1;\n}\nconst Dp = \"event\";\nfunction $2(s, e) {\n  const t = new URL(s), r = new URL(e);\n  if (t.origin !== r.origin)\n    return s;\n  const n = t.pathname.split(\"/\").slice(1), i = r.pathname.split(\"/\").slice(1, -1);\n  for (; n[0] === i[0]; )\n    n.shift(), i.shift();\n  for (; i.length; )\n    i.shift(), n.unshift(\"..\");\n  return n.join(\"/\") + t.search + t.hash;\n}\nconst vo = (s) =&gt; Math.round(s), xc = (s, e) =&gt; Array.isArray(s) ? s.map((t) =&gt; xc(t, e)) : s instanceof Jr &amp;&amp; typeof s.value == \"string\" ? new Jr(xc(s.value, e), s.params) : (e.baseUrl &amp;&amp; (s = $2(s, e.baseUrl)), e.version === 1 ? encodeURIComponent(s) : s), Xi = (s) =&gt; vo(s / 100) * 100, G2 = (s, e) =&gt; {\n  let t = s;\n  return e.version &gt;= 2 &amp;&amp; (s instanceof Jr &amp;&amp; typeof s.value == \"string\" ? t = new Jr([s]) : typeof s == \"string\" &amp;&amp; (t = [s])), xc(t, e);\n}, V2 = {\n  /**\n   * Bitrate (kbps) rounded integer\n   */\n  br: vo,\n  /**\n   * Duration (milliseconds) rounded integer\n   */\n  d: vo,\n  /**\n   * Buffer Length (milliseconds) rounded nearest 100ms\n   */\n  bl: Xi,\n  /**\n   * Deadline (milliseconds) rounded nearest 100ms\n   */\n  dl: Xi,\n  /**\n   * Measured Throughput (kbps) rounded nearest 100kbps\n   */\n  mtp: Xi,\n  /**\n   * Next Object Request URL encoded\n   */\n  nor: G2,\n  /**\n   * Requested maximum throughput (kbps) rounded nearest 100kbps\n   */\n  rtp: Xi,\n  /**\n   * Top Bitrate (kbps) rounded integer\n   */\n  tb: vo\n}, Pp = \"request\", Mp = \"response\", Mu = [\"ab\", \"bg\", \"bl\", \"br\", \"bs\", \"bsd\", \"cdn\", \"cid\", \"cs\", \"df\", \"ec\", \"lab\", \"lb\", \"ltc\", \"msd\", \"mtp\", \"pb\", \"pr\", \"pt\", \"sf\", \"sid\", \"sn\", \"st\", \"sta\", \"tab\", \"tb\", \"tbl\", \"tpb\", \"ts\", \"v\"], j2 = [\"e\"], K2 = /^[a-zA-Z0-9-.]+-[a-zA-Z0-9-.]+$/;\nfunction Ea(s) {\n  return K2.test(s);\n}\nfunction H2(s) {\n  return Mu.includes(s) || j2.includes(s) || Ea(s);\n}\nconst Op = [\"d\", \"dl\", \"nor\", \"ot\", \"rtp\", \"su\"];\nfunction q2(s) {\n  return Mu.includes(s) || Op.includes(s) || Ea(s);\n}\nconst W2 = [\"cmsdd\", \"cmsds\", \"rc\", \"smrt\", \"ttfb\", \"ttfbb\", \"ttlb\", \"url\"];\nfunction z2(s) {\n  return Mu.includes(s) || Op.includes(s) || W2.includes(s) || Ea(s);\n}\nconst Y2 = [\"bl\", \"br\", \"bs\", \"cid\", \"d\", \"dl\", \"mtp\", \"nor\", \"nrr\", \"ot\", \"pr\", \"rtp\", \"sf\", \"sid\", \"st\", \"su\", \"tb\", \"v\"];\nfunction Z2(s) {\n  return Y2.includes(s) || Ea(s);\n}\nconst X2 = {\n  [Mp]: z2,\n  [Dp]: H2,\n  [Pp]: q2\n};\nfunction Bp(s, e = {}) {\n  const t = {};\n  if (s == null || typeof s != \"object\")\n    return t;\n  const r = e.version || s.v || 1, n = e.reportingMode || Pp, i = r === 1 ? Z2 : X2[n];\n  let o = Object.keys(s).filter(i);\n  const a = e.filter;\n  typeof a == \"function\" &amp;&amp; (o = o.filter(a));\n  const l = n === Mp || n === Dp;\n  l &amp;&amp; !o.includes(\"ts\") &amp;&amp; o.push(\"ts\"), r &gt; 1 &amp;&amp; !o.includes(\"v\") &amp;&amp; o.push(\"v\");\n  const c = nt({}, V2, e.formatters), u = {\n    version: r,\n    reportingMode: n,\n    baseUrl: e.baseUrl\n  };\n  return o.sort().forEach((d) =&gt; {\n    let h = s[d];\n    const f = c[d];\n    if (typeof f == \"function\" &amp;&amp; (h = f(h, u)), d === \"v\") {\n      if (r === 1)\n        return;\n      h = r;\n    }\n    d == \"pr\" &amp;&amp; h === 1 || (l &amp;&amp; d === \"ts\" &amp;&amp; !ue(h) &amp;&amp; (h = Date.now()), U2(h) &amp;&amp; (N2(d) &amp;&amp; typeof h == \"string\" &amp;&amp; (h = new _p(h)), t[d] = h));\n  }), t;\n}\nfunction J2(s, e = {}) {\n  const t = {};\n  if (!s)\n    return t;\n  const r = Bp(s, e), n = F2(r, e == null ? void 0 : e.customHeaderMap);\n  return Object.entries(n).reduce((i, [o, a]) =&gt; {\n    const l = kp(a, {\n      whitespace: !1\n    });\n    return l &amp;&amp; (i[o] = l), i;\n  }, t);\n}\nfunction Q2(s, e, t) {\n  return nt(s, J2(e, t));\n}\nconst ew = \"CMCD\";\nfunction tw(s, e = {}) {\n  return s ? kp(Bp(s, e), {\n    whitespace: !1\n  }) : \"\";\n}\nfunction rw(s, e = {}) {\n  if (!s)\n    return \"\";\n  const t = tw(s, e);\n  return encodeURIComponent(t);\n}\nfunction sw(s, e = {}) {\n  if (!s)\n    return \"\";\n  const t = rw(s, e);\n  return `${ew}=${t}`;\n}\nconst zh = /CMCD=[^&amp;#]+/;\nfunction nw(s, e, t) {\n  const r = sw(e, t);\n  if (!r)\n    return s;\n  if (zh.test(s))\n    return s.replace(zh, r);\n  const n = s.includes(\"?\") ? \"&amp;\" : \"?\";\n  return `${s}${n}${r}`;\n}\nclass iw {\n  constructor(e) {\n    this.hls = void 0, this.config = void 0, this.media = void 0, this.sid = void 0, this.cid = void 0, this.useHeaders = !1, this.includeKeys = void 0, this.initialized = !1, this.starved = !1, this.buffering = !0, this.audioBuffer = void 0, this.videoBuffer = void 0, this.onWaiting = () =&gt; {\n      this.initialized &amp;&amp; (this.starved = !0), this.buffering = !0;\n    }, this.onPlaying = () =&gt; {\n      this.initialized || (this.initialized = !0), this.buffering = !1;\n    }, this.applyPlaylistData = (n) =&gt; {\n      try {\n        this.apply(n, {\n          ot: hr.MANIFEST,\n          su: !this.initialized\n        });\n      } catch (i) {\n        this.hls.logger.warn(\"Could not generate manifest CMCD data.\", i);\n      }\n    }, this.applyFragmentData = (n) =&gt; {\n      try {\n        const {\n          frag: i,\n          part: o\n        } = n, a = this.hls.levels[i.level], l = this.getObjectType(i), c = {\n          d: (o || i).duration * 1e3,\n          ot: l\n        };\n        (l === hr.VIDEO || l === hr.AUDIO || l == hr.MUXED) &amp;&amp; (c.br = a.bitrate / 1e3, c.tb = this.getTopBandwidth(l) / 1e3, c.bl = this.getBufferLength(l));\n        const u = o ? this.getNextPart(o) : this.getNextFrag(i);\n        u != null &amp;&amp; u.url &amp;&amp; u.url !== i.url &amp;&amp; (c.nor = u.url), this.apply(n, c);\n      } catch (i) {\n        this.hls.logger.warn(\"Could not generate segment CMCD data.\", i);\n      }\n    }, this.hls = e;\n    const t = this.config = e.config, {\n      cmcd: r\n    } = t;\n    r != null &amp;&amp; (t.pLoader = this.createPlaylistLoader(), t.fLoader = this.createFragmentLoader(), this.sid = r.sessionId || e.sessionId, this.cid = r.contentId, this.useHeaders = r.useHeaders === !0, this.includeKeys = r.includeKeys, this.registerListeners());\n  }\n  registerListeners() {\n    const e = this.hls;\n    e.on(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(I.MEDIA_DETACHED, this.onMediaDetached, this), e.on(I.BUFFER_CREATED, this.onBufferCreated, this);\n  }\n  unregisterListeners() {\n    const e = this.hls;\n    e.off(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(I.MEDIA_DETACHED, this.onMediaDetached, this), e.off(I.BUFFER_CREATED, this.onBufferCreated, this);\n  }\n  destroy() {\n    this.unregisterListeners(), this.onMediaDetached(), this.hls = this.config = this.audioBuffer = this.videoBuffer = null, this.onWaiting = this.onPlaying = this.media = null;\n  }\n  onMediaAttached(e, t) {\n    this.media = t.media, this.media.addEventListener(\"waiting\", this.onWaiting), this.media.addEventListener(\"playing\", this.onPlaying);\n  }\n  onMediaDetached() {\n    this.media &amp;&amp; (this.media.removeEventListener(\"waiting\", this.onWaiting), this.media.removeEventListener(\"playing\", this.onPlaying), this.media = null);\n  }\n  onBufferCreated(e, t) {\n    var r, n;\n    this.audioBuffer = (r = t.tracks.audio) == null ? void 0 : r.buffer, this.videoBuffer = (n = t.tracks.video) == null ? void 0 : n.buffer;\n  }\n  /**\n   * Create baseline CMCD data\n   */\n  createData() {\n    var e;\n    return {\n      v: 1,\n      sf: h2.HLS,\n      sid: this.sid,\n      cid: this.cid,\n      pr: (e = this.media) == null ? void 0 : e.playbackRate,\n      mtp: this.hls.bandwidthEstimate / 1e3\n    };\n  }\n  /**\n   * Apply CMCD data to a request.\n   */\n  apply(e, t = {}) {\n    nt(t, this.createData());\n    const r = t.ot === hr.INIT || t.ot === hr.VIDEO || t.ot === hr.MUXED;\n    this.starved &amp;&amp; r &amp;&amp; (t.bs = !0, t.su = !0, this.starved = !1), t.su == null &amp;&amp; (t.su = this.buffering);\n    const {\n      includeKeys: n\n    } = this;\n    n &amp;&amp; (t = Object.keys(t).reduce((o, a) =&gt; (n.includes(a) &amp;&amp; (o[a] = t[a]), o), {}));\n    const i = {\n      baseUrl: e.url\n    };\n    this.useHeaders ? (e.headers || (e.headers = {}), Q2(e.headers, t, i)) : e.url = nw(e.url, t, i);\n  }\n  getNextFrag(e) {\n    var t;\n    const r = (t = this.hls.levels[e.level]) == null ? void 0 : t.details;\n    if (r) {\n      const n = e.sn - r.startSN;\n      return r.fragments[n + 1];\n    }\n  }\n  getNextPart(e) {\n    var t;\n    const {\n      index: r,\n      fragment: n\n    } = e, i = (t = this.hls.levels[n.level]) == null || (t = t.details) == null ? void 0 : t.partList;\n    if (i) {\n      const {\n        sn: o\n      } = n;\n      for (let a = i.length - 1; a &gt;= 0; a--) {\n        const l = i[a];\n        if (l.index === r &amp;&amp; l.fragment.sn === o)\n          return i[a + 1];\n      }\n    }\n  }\n  /**\n   * The CMCD object type.\n   */\n  getObjectType(e) {\n    const {\n      type: t\n    } = e;\n    if (t === \"subtitle\")\n      return hr.TIMED_TEXT;\n    if (e.sn === \"initSegment\")\n      return hr.INIT;\n    if (t === \"audio\")\n      return hr.AUDIO;\n    if (t === \"main\")\n      return this.hls.audioTracks.length ? hr.VIDEO : hr.MUXED;\n  }\n  /**\n   * Get the highest bitrate.\n   */\n  getTopBandwidth(e) {\n    let t = 0, r;\n    const n = this.hls;\n    if (e === hr.AUDIO)\n      r = n.audioTracks;\n    else {\n      const i = n.maxAutoLevel, o = i &gt; -1 ? i + 1 : n.levels.length;\n      r = n.levels.slice(0, o);\n    }\n    return r.forEach((i) =&gt; {\n      i.bitrate &gt; t &amp;&amp; (t = i.bitrate);\n    }), t &gt; 0 ? t : NaN;\n  }\n  /**\n   * Get the buffer length for a media type in milliseconds\n   */\n  getBufferLength(e) {\n    const t = this.media, r = e === hr.AUDIO ? this.audioBuffer : this.videoBuffer;\n    return !r || !t ? NaN : Ce.bufferInfo(r, t.currentTime, this.config.maxBufferHole).len * 1e3;\n  }\n  /**\n   * Create a playlist loader\n   */\n  createPlaylistLoader() {\n    const {\n      pLoader: e\n    } = this.config, t = this.applyPlaylistData, r = e || this.config.loader;\n    return class {\n      constructor(i) {\n        this.loader = void 0, this.loader = new r(i);\n      }\n      get stats() {\n        return this.loader.stats;\n      }\n      get context() {\n        return this.loader.context;\n      }\n      destroy() {\n        this.loader.destroy();\n      }\n      abort() {\n        this.loader.abort();\n      }\n      load(i, o, a) {\n        t(i), this.loader.load(i, o, a);\n      }\n    };\n  }\n  /**\n   * Create a playlist loader\n   */\n  createFragmentLoader() {\n    const {\n      fLoader: e\n    } = this.config, t = this.applyFragmentData, r = e || this.config.loader;\n    return class {\n      constructor(i) {\n        this.loader = void 0, this.loader = new r(i);\n      }\n      get stats() {\n        return this.loader.stats;\n      }\n      get context() {\n        return this.loader.context;\n      }\n      destroy() {\n        this.loader.destroy();\n      }\n      abort() {\n        this.loader.abort();\n      }\n      load(i, o, a) {\n        t(i), this.loader.load(i, o, a);\n      }\n    };\n  }\n}\nconst ow = 3e5;\nclass aw extends Lr {\n  constructor(e) {\n    super(\"content-steering\", e.logger), this.hls = void 0, this.loader = null, this.uri = null, this.pathwayId = \".\", this._pathwayPriority = null, this.timeToLoad = 300, this.reloadTimer = -1, this.updated = 0, this.started = !1, this.enabled = !0, this.levels = null, this.audioTracks = null, this.subtitleTracks = null, this.penalizedPathways = {}, this.hls = e, this.registerListeners();\n  }\n  registerListeners() {\n    const e = this.hls;\n    e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(I.MANIFEST_PARSED, this.onManifestParsed, this), e.on(I.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const e = this.hls;\n    e &amp;&amp; (e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(I.MANIFEST_PARSED, this.onManifestParsed, this), e.off(I.ERROR, this.onError, this));\n  }\n  pathways() {\n    return (this.levels || []).reduce((e, t) =&gt; (e.indexOf(t.pathwayId) === -1 &amp;&amp; e.push(t.pathwayId), e), []);\n  }\n  get pathwayPriority() {\n    return this._pathwayPriority;\n  }\n  set pathwayPriority(e) {\n    this.updatePathwayPriority(e);\n  }\n  startLoad() {\n    if (this.started = !0, this.clearTimeout(), this.enabled &amp;&amp; this.uri) {\n      if (this.updated) {\n        const e = this.timeToLoad * 1e3 - (performance.now() - this.updated);\n        if (e &gt; 0) {\n          this.scheduleRefresh(this.uri, e);\n          return;\n        }\n      }\n      this.loadSteeringManifest(this.uri);\n    }\n  }\n  stopLoad() {\n    this.started = !1, this.loader &amp;&amp; (this.loader.destroy(), this.loader = null), this.clearTimeout();\n  }\n  clearTimeout() {\n    this.reloadTimer !== -1 &amp;&amp; (self.clearTimeout(this.reloadTimer), this.reloadTimer = -1);\n  }\n  destroy() {\n    this.unregisterListeners(), this.stopLoad(), this.hls = null, this.levels = this.audioTracks = this.subtitleTracks = null;\n  }\n  removeLevel(e) {\n    const t = this.levels;\n    t &amp;&amp; (this.levels = t.filter((r) =&gt; r !== e));\n  }\n  onManifestLoading() {\n    this.stopLoad(), this.enabled = !0, this.timeToLoad = 300, this.updated = 0, this.uri = null, this.pathwayId = \".\", this.levels = this.audioTracks = this.subtitleTracks = null;\n  }\n  onManifestLoaded(e, t) {\n    const {\n      contentSteering: r\n    } = t;\n    r !== null &amp;&amp; (this.pathwayId = r.pathwayId, this.uri = r.uri, this.started &amp;&amp; this.startLoad());\n  }\n  onManifestParsed(e, t) {\n    this.audioTracks = t.audioTracks, this.subtitleTracks = t.subtitleTracks;\n  }\n  onError(e, t) {\n    const {\n      errorAction: r\n    } = t;\n    if ((r == null ? void 0 : r.action) === Zt.SendAlternateToPenaltyBox &amp;&amp; r.flags === vr.MoveAllAlternatesMatchingHost) {\n      const n = this.levels;\n      let i = this._pathwayPriority, o = this.pathwayId;\n      if (t.context) {\n        const {\n          groupId: a,\n          pathwayId: l,\n          type: c\n        } = t.context;\n        a &amp;&amp; n ? o = this.getPathwayForGroupId(a, c, o) : l &amp;&amp; (o = l);\n      }\n      o in this.penalizedPathways || (this.penalizedPathways[o] = performance.now()), !i &amp;&amp; n &amp;&amp; (i = this.pathways()), i &amp;&amp; i.length &gt; 1 &amp;&amp; (this.updatePathwayPriority(i), r.resolved = this.pathwayId !== o), t.details === J.BUFFER_APPEND_ERROR &amp;&amp; !t.fatal ? r.resolved = !0 : r.resolved || this.warn(`Could not resolve ${t.details} (\"${t.error.message}\") with content-steering for Pathway: ${o} levels: ${n &amp;&amp; n.length} priorities: ${at(i)} penalized: ${at(this.penalizedPathways)}`);\n    }\n  }\n  filterParsedLevels(e) {\n    this.levels = e;\n    let t = this.getLevelsForPathway(this.pathwayId);\n    if (t.length === 0) {\n      const r = e[0].pathwayId;\n      this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to \"${r}\"`), t = this.getLevelsForPathway(r), this.pathwayId = r;\n    }\n    return t.length !== e.length &amp;&amp; this.log(`Found ${t.length}/${e.length} levels in Pathway \"${this.pathwayId}\"`), t;\n  }\n  getLevelsForPathway(e) {\n    return this.levels === null ? [] : this.levels.filter((t) =&gt; e === t.pathwayId);\n  }\n  updatePathwayPriority(e) {\n    this._pathwayPriority = e;\n    let t;\n    const r = this.penalizedPathways, n = performance.now();\n    Object.keys(r).forEach((i) =&gt; {\n      n - r[i] &gt; ow &amp;&amp; delete r[i];\n    });\n    for (let i = 0; i &lt; e.length; i++) {\n      const o = e[i];\n      if (o in r)\n        continue;\n      if (o === this.pathwayId)\n        return;\n      const a = this.hls.nextLoadLevel, l = this.hls.levels[a];\n      if (t = this.getLevelsForPathway(o), t.length &gt; 0) {\n        this.log(`Setting Pathway to \"${o}\"`), this.pathwayId = o, rp(t), this.hls.trigger(I.LEVELS_UPDATED, {\n          levels: t\n        });\n        const c = this.hls.levels[a];\n        l &amp;&amp; c &amp;&amp; this.levels &amp;&amp; (c.attrs[\"STABLE-VARIANT-ID\"] !== l.attrs[\"STABLE-VARIANT-ID\"] &amp;&amp; c.bitrate !== l.bitrate &amp;&amp; this.log(`Unstable Pathways change from bitrate ${l.bitrate} to ${c.bitrate}`), this.hls.nextLoadLevel = a);\n        break;\n      }\n    }\n  }\n  getPathwayForGroupId(e, t, r) {\n    const n = this.getLevelsForPathway(r).concat(this.levels || []);\n    for (let i = 0; i &lt; n.length; i++)\n      if (t === Ke.AUDIO_TRACK &amp;&amp; n[i].hasAudioGroup(e) || t === Ke.SUBTITLE_TRACK &amp;&amp; n[i].hasSubtitleGroup(e))\n        return n[i].pathwayId;\n    return r;\n  }\n  clonePathways(e) {\n    const t = this.levels;\n    if (!t)\n      return;\n    const r = {}, n = {};\n    e.forEach((i) =&gt; {\n      const {\n        ID: o,\n        \"BASE-ID\": a,\n        \"URI-REPLACEMENT\": l\n      } = i;\n      if (t.some((u) =&gt; u.pathwayId === o))\n        return;\n      const c = this.getLevelsForPathway(a).map((u) =&gt; {\n        const d = new gt(u.attrs);\n        d[\"PATHWAY-ID\"] = o;\n        const h = d.AUDIO &amp;&amp; `${d.AUDIO}_clone_${o}`, f = d.SUBTITLES &amp;&amp; `${d.SUBTITLES}_clone_${o}`;\n        h &amp;&amp; (r[d.AUDIO] = h, d.AUDIO = h), f &amp;&amp; (n[d.SUBTITLES] = f, d.SUBTITLES = f);\n        const p = Fp(u.uri, d[\"STABLE-VARIANT-ID\"], \"PER-VARIANT-URIS\", l), y = new mi({\n          attrs: d,\n          audioCodec: u.audioCodec,\n          bitrate: u.bitrate,\n          height: u.height,\n          name: u.name,\n          url: p,\n          videoCodec: u.videoCodec,\n          width: u.width\n        });\n        if (u.audioGroups)\n          for (let E = 1; E &lt; u.audioGroups.length; E++)\n            y.addGroupId(\"audio\", `${u.audioGroups[E]}_clone_${o}`);\n        if (u.subtitleGroups)\n          for (let E = 1; E &lt; u.subtitleGroups.length; E++)\n            y.addGroupId(\"text\", `${u.subtitleGroups[E]}_clone_${o}`);\n        return y;\n      });\n      t.push(...c), Yh(this.audioTracks, r, l, o), Yh(this.subtitleTracks, n, l, o);\n    });\n  }\n  loadSteeringManifest(e) {\n    const t = this.hls.config, r = t.loader;\n    this.loader &amp;&amp; this.loader.destroy(), this.loader = new r(t);\n    let n;\n    try {\n      n = new self.URL(e);\n    } catch {\n      this.enabled = !1, this.log(`Failed to parse Steering Manifest URI: ${e}`);\n      return;\n    }\n    if (n.protocol !== \"data:\") {\n      const u = (this.hls.bandwidthEstimate || t.abrEwmaDefaultEstimate) | 0;\n      n.searchParams.set(\"_HLS_pathway\", this.pathwayId), n.searchParams.set(\"_HLS_throughput\", \"\" + u);\n    }\n    const i = {\n      responseType: \"json\",\n      url: n.href\n    }, o = t.steeringManifestLoadPolicy.default, a = o.errorRetry || o.timeoutRetry || {}, l = {\n      loadPolicy: o,\n      timeout: o.maxLoadTimeMs,\n      maxRetry: a.maxNumRetry || 0,\n      retryDelay: a.retryDelayMs || 0,\n      maxRetryDelay: a.maxRetryDelayMs || 0\n    }, c = {\n      onSuccess: (u, d, h, f) =&gt; {\n        this.log(`Loaded steering manifest: \"${n}\"`);\n        const p = u.data;\n        if ((p == null ? void 0 : p.VERSION) !== 1) {\n          this.log(`Steering VERSION ${p.VERSION} not supported!`);\n          return;\n        }\n        this.updated = performance.now(), this.timeToLoad = p.TTL;\n        const {\n          \"RELOAD-URI\": y,\n          \"PATHWAY-CLONES\": E,\n          \"PATHWAY-PRIORITY\": b\n        } = p;\n        if (y)\n          try {\n            this.uri = new self.URL(y, n).href;\n          } catch {\n            this.enabled = !1, this.log(`Failed to parse Steering Manifest RELOAD-URI: ${y}`);\n            return;\n          }\n        this.scheduleRefresh(this.uri || h.url), E &amp;&amp; this.clonePathways(E);\n        const R = {\n          steeringManifest: p,\n          url: n.toString()\n        };\n        this.hls.trigger(I.STEERING_MANIFEST_LOADED, R), b &amp;&amp; this.updatePathwayPriority(b);\n      },\n      onError: (u, d, h, f) =&gt; {\n        if (this.log(`Error loading steering manifest: ${u.code} ${u.text} (${d.url})`), this.stopLoad(), u.code === 410) {\n          this.enabled = !1, this.log(`Steering manifest ${d.url} no longer available`);\n          return;\n        }\n        let p = this.timeToLoad * 1e3;\n        if (u.code === 429) {\n          const y = this.loader;\n          if (typeof (y == null ? void 0 : y.getResponseHeader) == \"function\") {\n            const E = y.getResponseHeader(\"Retry-After\");\n            E &amp;&amp; (p = parseFloat(E) * 1e3);\n          }\n          this.log(`Steering manifest ${d.url} rate limited`);\n          return;\n        }\n        this.scheduleRefresh(this.uri || d.url, p);\n      },\n      onTimeout: (u, d, h) =&gt; {\n        this.log(`Timeout loading steering manifest (${d.url})`), this.scheduleRefresh(this.uri || d.url);\n      }\n    };\n    this.log(`Requesting steering manifest: ${n}`), this.loader.load(i, l, c);\n  }\n  scheduleRefresh(e, t = this.timeToLoad * 1e3) {\n    this.clearTimeout(), this.reloadTimer = self.setTimeout(() =&gt; {\n      var r;\n      const n = (r = this.hls) == null ? void 0 : r.media;\n      if (n &amp;&amp; !n.ended) {\n        this.loadSteeringManifest(e);\n        return;\n      }\n      this.scheduleRefresh(e, this.timeToLoad * 1e3);\n    }, t);\n  }\n}\nfunction Yh(s, e, t, r) {\n  s &amp;&amp; Object.keys(e).forEach((n) =&gt; {\n    const i = s.filter((o) =&gt; o.groupId === n).map((o) =&gt; {\n      const a = nt({}, o);\n      return a.details = void 0, a.attrs = new gt(a.attrs), a.url = a.attrs.URI = Fp(o.url, o.attrs[\"STABLE-RENDITION-ID\"], \"PER-RENDITION-URIS\", t), a.groupId = a.attrs[\"GROUP-ID\"] = e[n], a.attrs[\"PATHWAY-ID\"] = r, a;\n    });\n    s.push(...i);\n  });\n}\nfunction Fp(s, e, t, r) {\n  const {\n    HOST: n,\n    PARAMS: i,\n    [t]: o\n  } = r;\n  let a;\n  e &amp;&amp; (a = o == null ? void 0 : o[e], a &amp;&amp; (s = a));\n  const l = new self.URL(s);\n  return n &amp;&amp; !a &amp;&amp; (l.host = n), i &amp;&amp; Object.keys(i).sort().forEach((c) =&gt; {\n    c &amp;&amp; l.searchParams.set(c, i[c]);\n  }), l.href;\n}\nclass _n extends Lr {\n  constructor(e) {\n    super(\"eme\", e.logger), this.hls = void 0, this.config = void 0, this.media = null, this.keyFormatPromise = null, this.keySystemAccessPromises = {}, this._requestLicenseFailureCount = 0, this.mediaKeySessions = [], this.keyIdToKeySessionPromise = {}, this.mediaKeys = null, this.setMediaKeysQueue = _n.CDMCleanupPromise ? [_n.CDMCleanupPromise] : [], this.bannedKeyIds = {}, this.onMediaEncrypted = (t) =&gt; {\n      const {\n        initDataType: r,\n        initData: n\n      } = t, i = `\"${t.type}\" event: init data type: \"${r}\"`;\n      if (this.debug(i), n !== null) {\n        if (!this.keyFormatPromise) {\n          let o = Object.keys(this.keySystemAccessPromises);\n          o.length || (o = zn(this.config));\n          const a = o.map(fl).filter((l) =&gt; !!l);\n          this.keyFormatPromise = this.getKeyFormatPromise(a);\n        }\n        this.keyFormatPromise.then((o) =&gt; {\n          const a = po(o);\n          if (r !== \"sinf\" || a !== mt.FAIRPLAY) {\n            this.log(`Ignoring \"${t.type}\" event with init data type: \"${r}\" for selected key-system ${a}`);\n            return;\n          }\n          let l;\n          try {\n            const f = jt(new Uint8Array(n)), p = bu(JSON.parse(f).sinf), y = Pg(p);\n            if (!y)\n              throw new Error(\"'schm' box missing or not cbcs/cenc with schi &gt; tenc\");\n            l = new Uint8Array(y.subarray(8, 24));\n          } catch (f) {\n            this.warn(`${i} Failed to parse sinf: ${f}`);\n            return;\n          }\n          const c = fr(l), {\n            keyIdToKeySessionPromise: u,\n            mediaKeySessions: d\n          } = this;\n          let h = u[c];\n          for (let f = 0; f &lt; d.length; f++) {\n            const p = d[f], y = p.decryptdata;\n            if (!y.keyId)\n              continue;\n            const E = fr(y.keyId);\n            if (xu(l, y.keyId) || y.uri.replace(/-/g, \"\").indexOf(c) !== -1) {\n              if (h = u[E], !h)\n                continue;\n              if (y.pssh)\n                break;\n              delete u[E], y.pssh = new Uint8Array(n), y.keyId = l, h = u[c] = h.then(() =&gt; this.generateRequestWithPreferredKeySession(p, r, n, \"encrypted-event-key-match\")), h.catch((b) =&gt; this.handleError(b));\n              break;\n            }\n          }\n          h || this.handleError(new Error(`Key ID ${c} not encountered in playlist. Key-system sessions ${d.length}.`));\n        }).catch((o) =&gt; this.handleError(o));\n      }\n    }, this.onWaitingForKey = (t) =&gt; {\n      this.log(`\"${t.type}\" event`);\n    }, this.hls = e, this.config = e.config, this.registerListeners();\n  }\n  destroy() {\n    this.onDestroying(), this.onMediaDetached();\n    const e = this.config;\n    e.requestMediaKeySystemAccessFunc = null, e.licenseXhrSetup = e.licenseResponseCallback = void 0, e.drmSystems = e.drmSystemOptions = {}, this.hls = this.config = this.keyIdToKeySessionPromise = null, this.onMediaEncrypted = this.onWaitingForKey = null;\n  }\n  registerListeners() {\n    this.hls.on(I.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.on(I.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.on(I.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.on(I.MANIFEST_LOADED, this.onManifestLoaded, this), this.hls.on(I.DESTROYING, this.onDestroying, this);\n  }\n  unregisterListeners() {\n    this.hls.off(I.MEDIA_ATTACHED, this.onMediaAttached, this), this.hls.off(I.MEDIA_DETACHED, this.onMediaDetached, this), this.hls.off(I.MANIFEST_LOADING, this.onManifestLoading, this), this.hls.off(I.MANIFEST_LOADED, this.onManifestLoaded, this), this.hls.off(I.DESTROYING, this.onDestroying, this);\n  }\n  getLicenseServerUrl(e) {\n    const {\n      drmSystems: t,\n      widevineLicenseUrl: r\n    } = this.config, n = t == null ? void 0 : t[e];\n    if (n)\n      return n.licenseUrl;\n    if (e === mt.WIDEVINE &amp;&amp; r)\n      return r;\n  }\n  getLicenseServerUrlOrThrow(e) {\n    const t = this.getLicenseServerUrl(e);\n    if (t === void 0)\n      throw new Error(`no license server URL configured for key-system \"${e}\"`);\n    return t;\n  }\n  getServerCertificateUrl(e) {\n    const {\n      drmSystems: t\n    } = this.config, r = t == null ? void 0 : t[e];\n    if (r)\n      return r.serverCertificateUrl;\n    this.log(`No Server Certificate in config.drmSystems[\"${e}\"]`);\n  }\n  attemptKeySystemAccess(e) {\n    const t = this.hls.levels, r = (o, a, l) =&gt; !!o &amp;&amp; l.indexOf(o) === a, n = t.map((o) =&gt; o.audioCodec).filter(r), i = t.map((o) =&gt; o.videoCodec).filter(r);\n    return n.length + i.length === 0 &amp;&amp; i.push(\"avc1.42e01e\"), new Promise((o, a) =&gt; {\n      const l = (c) =&gt; {\n        const u = c.shift();\n        this.getMediaKeysPromise(u, n, i).then((d) =&gt; o({\n          keySystem: u,\n          mediaKeys: d\n        })).catch((d) =&gt; {\n          c.length ? l(c) : d instanceof yr ? a(d) : a(new yr({\n            type: ve.KEY_SYSTEM_ERROR,\n            details: J.KEY_SYSTEM_NO_ACCESS,\n            error: d,\n            fatal: !0\n          }, d.message));\n        });\n      };\n      l(e);\n    });\n  }\n  requestMediaKeySystemAccess(e, t) {\n    const {\n      requestMediaKeySystemAccessFunc: r\n    } = this.config;\n    if (typeof r != \"function\") {\n      let n = `Configured requestMediaKeySystemAccess is not a function ${r}`;\n      return Yg === null &amp;&amp; self.location.protocol === \"http:\" &amp;&amp; (n = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`), Promise.reject(new Error(n));\n    }\n    return r(e, t);\n  }\n  getMediaKeysPromise(e, t, r) {\n    var n;\n    const i = Gb(e, t, r, this.config.drmSystemOptions || {});\n    let o = this.keySystemAccessPromises[e], a = (n = o) == null ? void 0 : n.keySystemAccess;\n    if (!a) {\n      this.log(`Requesting encrypted media \"${e}\" key-system access with config: ${at(i)}`), a = this.requestMediaKeySystemAccess(e, i);\n      const l = o = this.keySystemAccessPromises[e] = {\n        keySystemAccess: a\n      };\n      return a.catch((c) =&gt; {\n        this.log(`Failed to obtain access to key-system \"${e}\": ${c}`);\n      }), a.then((c) =&gt; {\n        this.log(`Access for key-system \"${c.keySystem}\" obtained`);\n        const u = this.fetchServerCertificate(e);\n        this.log(`Create media-keys for \"${e}\"`);\n        const d = l.mediaKeys = c.createMediaKeys().then((h) =&gt; (this.log(`Media-keys created for \"${e}\"`), l.hasMediaKeys = !0, u.then((f) =&gt; f ? this.setMediaKeysServerCertificate(h, e, f) : h)));\n        return d.catch((h) =&gt; {\n          this.error(`Failed to create media-keys for \"${e}\"}: ${h}`);\n        }), d;\n      });\n    }\n    return a.then(() =&gt; o.mediaKeys);\n  }\n  createMediaKeySessionContext({\n    decryptdata: e,\n    keySystem: t,\n    mediaKeys: r\n  }) {\n    this.log(`Creating key-system session \"${t}\" keyId: ${fr(e.keyId || [])} keyUri: ${e.uri}`);\n    const n = r.createSession(), i = {\n      decryptdata: e,\n      keySystem: t,\n      mediaKeys: r,\n      mediaKeysSession: n,\n      keyStatus: \"status-pending\"\n    };\n    return this.mediaKeySessions.push(i), i;\n  }\n  renewKeySession(e) {\n    const t = e.decryptdata;\n    if (t.pssh) {\n      const r = this.createMediaKeySessionContext(e), n = Ji(t), i = \"cenc\";\n      this.keyIdToKeySessionPromise[n] = this.generateRequestWithPreferredKeySession(r, i, t.pssh.buffer, \"expired\");\n    } else\n      this.warn(\"Could not renew expired session. Missing pssh initData.\");\n    this.removeSession(e);\n  }\n  updateKeySession(e, t) {\n    const r = e.mediaKeysSession;\n    return this.log(`Updating key-session \"${r.sessionId}\" for keyId ${fr(e.decryptdata.keyId || [])}\n      } (data length: ${t.byteLength})`), r.update(t);\n  }\n  getSelectedKeySystemFormats() {\n    return Object.keys(this.keySystemAccessPromises).map((e) =&gt; ({\n      keySystem: e,\n      hasMediaKeys: this.keySystemAccessPromises[e].hasMediaKeys\n    })).filter(({\n      hasMediaKeys: e\n    }) =&gt; !!e).map(({\n      keySystem: e\n    }) =&gt; fl(e)).filter((e) =&gt; !!e);\n  }\n  getKeySystemAccess(e) {\n    return this.getKeySystemSelectionPromise(e).then(({\n      keySystem: t,\n      mediaKeys: r\n    }) =&gt; this.attemptSetMediaKeys(t, r));\n  }\n  selectKeySystem(e) {\n    return new Promise((t, r) =&gt; {\n      this.getKeySystemSelectionPromise(e).then(({\n        keySystem: n\n      }) =&gt; {\n        const i = fl(n);\n        i ? t(i) : r(new Error(`Unable to find format for key-system \"${n}\"`));\n      }).catch(r);\n    });\n  }\n  selectKeySystemFormat(e) {\n    const t = Object.keys(e.levelkeys || {});\n    return this.keyFormatPromise || (this.log(`Selecting key-system from fragment (sn: ${e.sn} ${e.type}: ${e.level}) key formats ${t.join(\", \")}`), this.keyFormatPromise = this.getKeyFormatPromise(t)), this.keyFormatPromise;\n  }\n  getKeyFormatPromise(e) {\n    const t = zn(this.config), r = e.map(po).filter((n) =&gt; !!n &amp;&amp; t.indexOf(n) !== -1);\n    return this.selectKeySystem(r);\n  }\n  getKeyStatus(e) {\n    const {\n      mediaKeySessions: t\n    } = this;\n    for (let r = 0; r &lt; t.length; r++) {\n      const n = lw(e, t[r]);\n      if (n)\n        return n;\n    }\n  }\n  loadKey(e) {\n    const t = e.keyInfo.decryptdata, r = Ji(t), n = this.bannedKeyIds[r];\n    if (n || this.getKeyStatus(t) === \"internal-error\") {\n      const a = Zh(n || \"internal-error\", t);\n      return this.handleError(a, e.frag), Promise.reject(a);\n    }\n    const i = `(keyId: ${r} format: \"${t.keyFormat}\" method: ${t.method} uri: ${t.uri})`;\n    this.log(`Starting session for key ${i}`);\n    const o = this.keyIdToKeySessionPromise[r];\n    if (!o) {\n      const a = this.getKeySystemForKeyPromise(t).then(({\n        keySystem: l,\n        mediaKeys: c\n      }) =&gt; (this.throwIfDestroyed(), this.log(`Handle encrypted media sn: ${e.frag.sn} ${e.frag.type}: ${e.frag.level} using key ${i}`), this.attemptSetMediaKeys(l, c).then(() =&gt; (this.throwIfDestroyed(), this.createMediaKeySessionContext({\n        keySystem: l,\n        mediaKeys: c,\n        decryptdata: t\n      }))))).then((l) =&gt; {\n        const c = \"cenc\", u = t.pssh ? t.pssh.buffer : null;\n        return this.generateRequestWithPreferredKeySession(l, c, u, \"playlist-key\");\n      });\n      return a.catch((l) =&gt; this.handleError(l, e.frag)), this.keyIdToKeySessionPromise[r] = a, a;\n    }\n    return o.catch((a) =&gt; {\n      if (a instanceof yr) {\n        const l = tt({}, a.data);\n        this.getKeyStatus(t) === \"internal-error\" &amp;&amp; (l.decryptdata = t);\n        const c = new yr(l, a.message);\n        this.handleError(c, e.frag);\n      }\n    }), o;\n  }\n  throwIfDestroyed(e = \"Invalid state\") {\n    if (!this.hls)\n      throw new Error(\"invalid state\");\n  }\n  handleError(e, t) {\n    if (this.hls)\n      if (e instanceof yr) {\n        t &amp;&amp; (e.data.frag = t);\n        const r = e.data.decryptdata;\n        this.error(`${e.message}${r ? ` (${fr(r.keyId || [])})` : \"\"}`), this.hls.trigger(I.ERROR, e.data);\n      } else\n        this.error(e.message), this.hls.trigger(I.ERROR, {\n          type: ve.KEY_SYSTEM_ERROR,\n          details: J.KEY_SYSTEM_NO_KEYS,\n          error: e,\n          fatal: !0\n        });\n  }\n  getKeySystemForKeyPromise(e) {\n    const t = Ji(e), r = this.keyIdToKeySessionPromise[t];\n    if (!r) {\n      const n = po(e.keyFormat), i = n ? [n] : zn(this.config);\n      return this.attemptKeySystemAccess(i);\n    }\n    return r;\n  }\n  getKeySystemSelectionPromise(e) {\n    if (e.length || (e = zn(this.config)), e.length === 0)\n      throw new yr({\n        type: ve.KEY_SYSTEM_ERROR,\n        details: J.KEY_SYSTEM_NO_CONFIGURED_LICENSE,\n        fatal: !0\n      }, `Missing key-system license configuration options ${at({\n        drmSystems: this.config.drmSystems\n      })}`);\n    return this.attemptKeySystemAccess(e);\n  }\n  attemptSetMediaKeys(e, t) {\n    if (this.mediaKeys === t)\n      return Promise.resolve();\n    const r = this.setMediaKeysQueue.slice();\n    this.log(`Setting media-keys for \"${e}\"`);\n    const n = Promise.all(r).then(() =&gt; {\n      if (!this.media)\n        throw this.mediaKeys = null, new Error(\"Attempted to set mediaKeys without media element attached\");\n      return this.media.setMediaKeys(t);\n    });\n    return this.mediaKeys = t, this.setMediaKeysQueue.push(n), n.then(() =&gt; {\n      this.log(`Media-keys set for \"${e}\"`), r.push(n), this.setMediaKeysQueue = this.setMediaKeysQueue.filter((i) =&gt; r.indexOf(i) === -1);\n    });\n  }\n  generateRequestWithPreferredKeySession(e, t, r, n) {\n    var i;\n    const o = (i = this.config.drmSystems) == null || (i = i[e.keySystem]) == null ? void 0 : i.generateRequest;\n    if (o)\n      try {\n        const p = o.call(this.hls, t, r, e);\n        if (!p)\n          throw new Error(\"Invalid response from configured generateRequest filter\");\n        t = p.initDataType, r = p.initData ? p.initData : null, e.decryptdata.pssh = r ? new Uint8Array(r) : null;\n      } catch (p) {\n        if (this.warn(p.message), this.hls &amp;&amp; this.hls.config.debug)\n          throw p;\n      }\n    if (r === null)\n      return this.log(`Skipping key-session request for \"${n}\" (no initData)`), Promise.resolve(e);\n    const a = Ji(e.decryptdata), l = e.decryptdata.uri;\n    this.log(`Generating key-session request for \"${n}\" keyId: ${a} URI: ${l} (init data type: ${t} length: ${r.byteLength})`);\n    const c = new wu(), u = e._onmessage = (p) =&gt; {\n      const y = e.mediaKeysSession;\n      if (!y) {\n        c.emit(\"error\", new Error(\"invalid state\"));\n        return;\n      }\n      const {\n        messageType: E,\n        message: b\n      } = p;\n      this.log(`\"${E}\" message event for session \"${y.sessionId}\" message size: ${b.byteLength}`), E === \"license-request\" || E === \"license-renewal\" ? this.renewLicense(e, b).catch((R) =&gt; {\n        c.eventNames().length ? c.emit(\"error\", R) : this.handleError(R);\n      }) : E === \"license-release\" ? e.keySystem === mt.FAIRPLAY &amp;&amp; this.updateKeySession(e, hc(\"acknowledged\")).then(() =&gt; this.removeSession(e)).catch((R) =&gt; this.handleError(R)) : this.warn(`unhandled media key message type \"${E}\"`);\n    }, d = (p, y) =&gt; {\n      y.keyStatus = p;\n      let E;\n      p.startsWith(\"usable\") ? c.emit(\"resolved\") : p === \"internal-error\" || p === \"output-restricted\" || p === \"output-downscaled\" ? E = Zh(p, y.decryptdata) : p === \"expired\" ? E = new Error(`key expired (keyId: ${a})`) : p === \"released\" ? E = new Error(\"key released\") : p === \"status-pending\" || this.warn(`unhandled key status change \"${p}\" (keyId: ${a})`), E &amp;&amp; (c.eventNames().length ? c.emit(\"error\", E) : this.handleError(E));\n    }, h = e._onkeystatuseschange = (p) =&gt; {\n      if (!e.mediaKeysSession) {\n        c.emit(\"error\", new Error(\"invalid state\"));\n        return;\n      }\n      const E = this.getKeyStatuses(e);\n      if (!Object.keys(E).some((F) =&gt; E[F] !== \"status-pending\"))\n        return;\n      if (E[a] === \"expired\") {\n        this.log(`Expired key ${at(E)} in key-session \"${e.mediaKeysSession.sessionId}\"`), this.renewKeySession(e);\n        return;\n      }\n      let R = E[a];\n      if (R)\n        d(R, e);\n      else {\n        var A;\n        e.keyStatusTimeouts || (e.keyStatusTimeouts = {}), (A = e.keyStatusTimeouts)[a] || (A[a] = self.setTimeout(() =&gt; {\n          if (!e.mediaKeysSession || !this.mediaKeys)\n            return;\n          const M = this.getKeyStatus(e.decryptdata);\n          if (M &amp;&amp; M !== \"status-pending\")\n            return this.log(`No status for keyId ${a} in key-session \"${e.mediaKeysSession.sessionId}\". Using session key-status ${M} from other session.`), d(M, e);\n          this.log(`key status for ${a} in key-session \"${e.mediaKeysSession.sessionId}\" timed out after 0ms`), R = \"internal-error\", d(R, e);\n        }, 0)), this.log(`No status for keyId ${a} (${at(E)}).`);\n      }\n    };\n    cr(e.mediaKeysSession, \"message\", u), cr(e.mediaKeysSession, \"keystatuseschange\", h);\n    const f = new Promise((p, y) =&gt; {\n      c.on(\"error\", y), c.on(\"resolved\", p);\n    });\n    return e.mediaKeysSession.generateRequest(t, r).then(() =&gt; {\n      this.log(`Request generated for key-session \"${e.mediaKeysSession.sessionId}\" keyId: ${a} URI: ${l}`);\n    }).catch((p) =&gt; {\n      throw new yr({\n        type: ve.KEY_SYSTEM_ERROR,\n        details: J.KEY_SYSTEM_NO_SESSION,\n        error: p,\n        decryptdata: e.decryptdata,\n        fatal: !1\n      }, `Error generating key-session request: ${p}`);\n    }).then(() =&gt; f).catch((p) =&gt; (c.removeAllListeners(), this.removeSession(e).then(() =&gt; {\n      throw p;\n    }))).then(() =&gt; (c.removeAllListeners(), e));\n  }\n  getKeyStatuses(e) {\n    const t = {};\n    return e.mediaKeysSession.keyStatuses.forEach((r, n) =&gt; {\n      if (typeof n == \"string\" &amp;&amp; typeof r == \"object\") {\n        const a = n;\n        n = r, r = a;\n      }\n      const i = \"buffer\" in n ? new Uint8Array(n.buffer, n.byteOffset, n.byteLength) : new Uint8Array(n);\n      e.keySystem === mt.PLAYREADY &amp;&amp; i.length === 16 &amp;&amp; zg(i);\n      const o = fr(i);\n      r === \"internal-error\" &amp;&amp; (this.bannedKeyIds[o] = r), this.log(`key status change \"${r}\" for keyStatuses keyId: ${o} key-session \"${e.mediaKeysSession.sessionId}\"`), t[o] = r;\n    }), t;\n  }\n  fetchServerCertificate(e) {\n    const t = this.config, r = t.loader, n = new r(t), i = this.getServerCertificateUrl(e);\n    return i ? (this.log(`Fetching server certificate for \"${e}\"`), new Promise((o, a) =&gt; {\n      const l = {\n        responseType: \"arraybuffer\",\n        url: i\n      }, c = t.certLoadPolicy.default, u = {\n        loadPolicy: c,\n        timeout: c.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0\n      }, d = {\n        onSuccess: (h, f, p, y) =&gt; {\n          o(h.data);\n        },\n        onError: (h, f, p, y) =&gt; {\n          a(new yr({\n            type: ve.KEY_SYSTEM_ERROR,\n            details: J.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n            fatal: !0,\n            networkDetails: p,\n            response: tt({\n              url: l.url,\n              data: void 0\n            }, h)\n          }, `\"${e}\" certificate request failed (${i}). Status: ${h.code} (${h.text})`));\n        },\n        onTimeout: (h, f, p) =&gt; {\n          a(new yr({\n            type: ve.KEY_SYSTEM_ERROR,\n            details: J.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n            fatal: !0,\n            networkDetails: p,\n            response: {\n              url: l.url,\n              data: void 0\n            }\n          }, `\"${e}\" certificate request timed out (${i})`));\n        },\n        onAbort: (h, f, p) =&gt; {\n          a(new Error(\"aborted\"));\n        }\n      };\n      n.load(l, u, d);\n    })) : Promise.resolve();\n  }\n  setMediaKeysServerCertificate(e, t, r) {\n    return new Promise((n, i) =&gt; {\n      e.setServerCertificate(r).then((o) =&gt; {\n        this.log(`setServerCertificate ${o ? \"success\" : \"not supported by CDM\"} (${r.byteLength}) on \"${t}\"`), n(e);\n      }).catch((o) =&gt; {\n        i(new yr({\n          type: ve.KEY_SYSTEM_ERROR,\n          details: J.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,\n          error: o,\n          fatal: !0\n        }, o.message));\n      });\n    });\n  }\n  renewLicense(e, t) {\n    return this.requestLicense(e, new Uint8Array(t)).then((r) =&gt; this.updateKeySession(e, new Uint8Array(r)).catch((n) =&gt; {\n      throw new yr({\n        type: ve.KEY_SYSTEM_ERROR,\n        details: J.KEY_SYSTEM_SESSION_UPDATE_FAILED,\n        decryptdata: e.decryptdata,\n        error: n,\n        fatal: !1\n      }, n.message);\n    }));\n  }\n  unpackPlayReadyKeyMessage(e, t) {\n    const r = String.fromCharCode.apply(null, new Uint16Array(t.buffer));\n    if (!r.includes(\"PlayReadyKeyMessage\"))\n      return e.setRequestHeader(\"Content-Type\", \"text/xml; charset=utf-8\"), t;\n    const n = new DOMParser().parseFromString(r, \"application/xml\"), i = n.querySelectorAll(\"HttpHeader\");\n    if (i.length &gt; 0) {\n      let u;\n      for (let d = 0, h = i.length; d &lt; h; d++) {\n        var o, a;\n        u = i[d];\n        const f = (o = u.querySelector(\"name\")) == null ? void 0 : o.textContent, p = (a = u.querySelector(\"value\")) == null ? void 0 : a.textContent;\n        f &amp;&amp; p &amp;&amp; e.setRequestHeader(f, p);\n      }\n    }\n    const l = n.querySelector(\"Challenge\"), c = l == null ? void 0 : l.textContent;\n    if (!c)\n      throw new Error(\"Cannot find &lt;Challenge&gt; in key message\");\n    return hc(atob(c));\n  }\n  setupLicenseXHR(e, t, r, n) {\n    const i = this.config.licenseXhrSetup;\n    return i ? Promise.resolve().then(() =&gt; {\n      if (!r.decryptdata)\n        throw new Error(\"Key removed\");\n      return i.call(this.hls, e, t, r, n);\n    }).catch((o) =&gt; {\n      if (!r.decryptdata)\n        throw o;\n      return e.open(\"POST\", t, !0), i.call(this.hls, e, t, r, n);\n    }).then((o) =&gt; (e.readyState || e.open(\"POST\", t, !0), {\n      xhr: e,\n      licenseChallenge: o || n\n    })) : (e.open(\"POST\", t, !0), Promise.resolve({\n      xhr: e,\n      licenseChallenge: n\n    }));\n  }\n  requestLicense(e, t) {\n    const r = this.config.keyLoadPolicy.default;\n    return new Promise((n, i) =&gt; {\n      const o = this.getLicenseServerUrlOrThrow(e.keySystem);\n      this.log(`Sending license request to URL: ${o}`);\n      const a = new XMLHttpRequest();\n      a.responseType = \"arraybuffer\", a.onreadystatechange = () =&gt; {\n        if (!this.hls || !e.mediaKeysSession)\n          return i(new Error(\"invalid state\"));\n        if (a.readyState === 4)\n          if (a.status === 200) {\n            this._requestLicenseFailureCount = 0;\n            let l = a.response;\n            this.log(`License received ${l instanceof ArrayBuffer ? l.byteLength : l}`);\n            const c = this.config.licenseResponseCallback;\n            if (c)\n              try {\n                l = c.call(this.hls, a, o, e);\n              } catch (u) {\n                this.error(u);\n              }\n            n(l);\n          } else {\n            const l = r.errorRetry, c = l ? l.maxNumRetry : 0;\n            if (this._requestLicenseFailureCount++, this._requestLicenseFailureCount &gt; c || a.status &gt;= 400 &amp;&amp; a.status &lt; 500)\n              i(new yr({\n                type: ve.KEY_SYSTEM_ERROR,\n                details: J.KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n                decryptdata: e.decryptdata,\n                fatal: !0,\n                networkDetails: a,\n                response: {\n                  url: o,\n                  data: void 0,\n                  code: a.status,\n                  text: a.statusText\n                }\n              }, `License Request XHR failed (${o}). Status: ${a.status} (${a.statusText})`));\n            else {\n              const u = c - this._requestLicenseFailureCount + 1;\n              this.warn(`Retrying license request, ${u} attempts left`), this.requestLicense(e, t).then(n, i);\n            }\n          }\n      }, e.licenseXhr &amp;&amp; e.licenseXhr.readyState !== XMLHttpRequest.DONE &amp;&amp; e.licenseXhr.abort(), e.licenseXhr = a, this.setupLicenseXHR(a, o, e, t).then(({\n        xhr: l,\n        licenseChallenge: c\n      }) =&gt; {\n        e.keySystem == mt.PLAYREADY &amp;&amp; (c = this.unpackPlayReadyKeyMessage(l, c)), l.send(c);\n      }).catch(i);\n    });\n  }\n  onDestroying() {\n    this.unregisterListeners(), this._clear();\n  }\n  onMediaAttached(e, t) {\n    if (!this.config.emeEnabled)\n      return;\n    const r = t.media;\n    this.media = r, cr(r, \"encrypted\", this.onMediaEncrypted), cr(r, \"waitingforkey\", this.onWaitingForKey);\n  }\n  onMediaDetached() {\n    const e = this.media;\n    e &amp;&amp; (pr(e, \"encrypted\", this.onMediaEncrypted), pr(e, \"waitingforkey\", this.onWaitingForKey), this.media = null, this.mediaKeys = null);\n  }\n  _clear() {\n    var e;\n    if (this._requestLicenseFailureCount = 0, this.keyIdToKeySessionPromise = {}, this.bannedKeyIds = {}, !this.mediaKeys &amp;&amp; !this.mediaKeySessions.length)\n      return;\n    const t = this.media, r = this.mediaKeySessions.slice();\n    this.mediaKeySessions = [], this.mediaKeys = null, yi.clearKeyUriToKeyIdMap();\n    const n = r.length;\n    _n.CDMCleanupPromise = Promise.all(r.map((i) =&gt; this.removeSession(i)).concat((t == null || (e = t.setMediaKeys(null)) == null ? void 0 : e.catch((i) =&gt; {\n      this.log(`Could not clear media keys: ${i}`), this.hls &amp;&amp; this.hls.trigger(I.ERROR, {\n        type: ve.OTHER_ERROR,\n        details: J.KEY_SYSTEM_DESTROY_MEDIA_KEYS_ERROR,\n        fatal: !1,\n        error: new Error(`Could not clear media keys: ${i}`)\n      });\n    })) || Promise.resolve())).catch((i) =&gt; {\n      this.log(`Could not close sessions and clear media keys: ${i}`), this.hls &amp;&amp; this.hls.trigger(I.ERROR, {\n        type: ve.OTHER_ERROR,\n        details: J.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,\n        fatal: !1,\n        error: new Error(`Could not close sessions and clear media keys: ${i}`)\n      });\n    }).then(() =&gt; {\n      n &amp;&amp; this.log(\"finished closing key sessions and clearing media keys\");\n    });\n  }\n  onManifestLoading() {\n    this.keyFormatPromise = null, this.bannedKeyIds = {};\n  }\n  onManifestLoaded(e, {\n    sessionKeys: t\n  }) {\n    if (!(!t || !this.config.emeEnabled) &amp;&amp; !this.keyFormatPromise) {\n      const r = t.reduce((n, i) =&gt; (n.indexOf(i.keyFormat) === -1 &amp;&amp; n.push(i.keyFormat), n), []);\n      this.log(`Selecting key-system from session-keys ${r.join(\", \")}`), this.keyFormatPromise = this.getKeyFormatPromise(r);\n    }\n  }\n  removeSession(e) {\n    const {\n      mediaKeysSession: t,\n      licenseXhr: r,\n      decryptdata: n\n    } = e;\n    if (t) {\n      this.log(`Remove licenses and keys and close session \"${t.sessionId}\" keyId: ${fr((n == null ? void 0 : n.keyId) || [])}`), e._onmessage &amp;&amp; (t.removeEventListener(\"message\", e._onmessage), e._onmessage = void 0), e._onkeystatuseschange &amp;&amp; (t.removeEventListener(\"keystatuseschange\", e._onkeystatuseschange), e._onkeystatuseschange = void 0), r &amp;&amp; r.readyState !== XMLHttpRequest.DONE &amp;&amp; r.abort(), e.mediaKeysSession = e.decryptdata = e.licenseXhr = void 0;\n      const i = this.mediaKeySessions.indexOf(e);\n      i &gt; -1 &amp;&amp; this.mediaKeySessions.splice(i, 1);\n      const {\n        keyStatusTimeouts: o\n      } = e;\n      o &amp;&amp; Object.keys(o).forEach((c) =&gt; self.clearTimeout(o[c]));\n      const {\n        drmSystemOptions: a\n      } = this.config;\n      return (jb(a) ? new Promise((c, u) =&gt; {\n        self.setTimeout(() =&gt; u(new Error(\"MediaKeySession.remove() timeout\")), 8e3), t.remove().then(c).catch(u);\n      }) : Promise.resolve()).catch((c) =&gt; {\n        this.log(`Could not remove session: ${c}`), this.hls &amp;&amp; this.hls.trigger(I.ERROR, {\n          type: ve.OTHER_ERROR,\n          details: J.KEY_SYSTEM_DESTROY_REMOVE_SESSION_ERROR,\n          fatal: !1,\n          error: new Error(`Could not remove session: ${c}`)\n        });\n      }).then(() =&gt; t.close()).catch((c) =&gt; {\n        this.log(`Could not close session: ${c}`), this.hls &amp;&amp; this.hls.trigger(I.ERROR, {\n          type: ve.OTHER_ERROR,\n          details: J.KEY_SYSTEM_DESTROY_CLOSE_SESSION_ERROR,\n          fatal: !1,\n          error: new Error(`Could not close session: ${c}`)\n        });\n      });\n    }\n    return Promise.resolve();\n  }\n}\n_n.CDMCleanupPromise = void 0;\nfunction Ji(s) {\n  if (!s)\n    throw new Error(\"Could not read keyId of undefined decryptdata\");\n  if (s.keyId === null)\n    throw new Error(\"keyId is null\");\n  return fr(s.keyId);\n}\nfunction lw(s, e) {\n  if (s.keyId &amp;&amp; e.mediaKeysSession.keyStatuses.has(s.keyId))\n    return e.mediaKeysSession.keyStatuses.get(s.keyId);\n  if (s.matches(e.decryptdata))\n    return e.keyStatus;\n}\nclass yr extends Error {\n  constructor(e, t) {\n    super(t), this.data = void 0, e.error || (e.error = new Error(t)), this.data = e, e.err = e.error;\n  }\n}\nfunction Zh(s, e) {\n  const t = s === \"output-restricted\", r = t ? J.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED : J.KEY_SYSTEM_STATUS_INTERNAL_ERROR;\n  return new yr({\n    type: ve.KEY_SYSTEM_ERROR,\n    details: r,\n    fatal: !1,\n    decryptdata: e\n  }, t ? \"HDCP level output restricted\" : `key status changed to \"${s}\"`);\n}\nclass cw {\n  constructor(e) {\n    this.hls = void 0, this.isVideoPlaybackQualityAvailable = !1, this.timer = void 0, this.media = null, this.lastTime = void 0, this.lastDroppedFrames = 0, this.lastDecodedFrames = 0, this.streamController = void 0, this.hls = e, this.registerListeners();\n  }\n  setStreamController(e) {\n    this.streamController = e;\n  }\n  registerListeners() {\n    this.hls.on(I.MEDIA_ATTACHING, this.onMediaAttaching, this), this.hls.on(I.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  unregisterListeners() {\n    this.hls.off(I.MEDIA_ATTACHING, this.onMediaAttaching, this), this.hls.off(I.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  destroy() {\n    this.timer &amp;&amp; clearInterval(this.timer), this.unregisterListeners(), this.isVideoPlaybackQualityAvailable = !1, this.media = null;\n  }\n  onMediaAttaching(e, t) {\n    const r = this.hls.config;\n    if (r.capLevelOnFPSDrop) {\n      const n = t.media instanceof self.HTMLVideoElement ? t.media : null;\n      this.media = n, n &amp;&amp; typeof n.getVideoPlaybackQuality == \"function\" &amp;&amp; (this.isVideoPlaybackQualityAvailable = !0), self.clearInterval(this.timer), this.timer = self.setInterval(this.checkFPSInterval.bind(this), r.fpsDroppedMonitoringPeriod);\n    }\n  }\n  onMediaDetaching() {\n    this.media = null;\n  }\n  checkFPS(e, t, r) {\n    const n = performance.now();\n    if (t) {\n      if (this.lastTime) {\n        const i = n - this.lastTime, o = r - this.lastDroppedFrames, a = t - this.lastDecodedFrames, l = 1e3 * o / i, c = this.hls;\n        if (c.trigger(I.FPS_DROP, {\n          currentDropped: o,\n          currentDecoded: a,\n          totalDroppedFrames: r\n        }), l &gt; 0 &amp;&amp; o &gt; c.config.fpsDroppedMonitoringThreshold * a) {\n          let u = c.currentLevel;\n          c.logger.warn(\"drop FPS ratio greater than max allowed value for currentLevel: \" + u), u &gt; 0 &amp;&amp; (c.autoLevelCapping === -1 || c.autoLevelCapping &gt;= u) &amp;&amp; (u = u - 1, c.trigger(I.FPS_DROP_LEVEL_CAPPING, {\n            level: u,\n            droppedLevel: c.currentLevel\n          }), c.autoLevelCapping = u, this.streamController.nextLevelSwitch());\n        }\n      }\n      this.lastTime = n, this.lastDroppedFrames = r, this.lastDecodedFrames = t;\n    }\n  }\n  checkFPSInterval() {\n    const e = this.media;\n    if (e)\n      if (this.isVideoPlaybackQualityAvailable) {\n        const t = e.getVideoPlaybackQuality();\n        this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames);\n      } else\n        this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount);\n  }\n}\nfunction Np(s, e) {\n  let t;\n  try {\n    t = new Event(\"addtrack\");\n  } catch {\n    t = document.createEvent(\"Event\"), t.initEvent(\"addtrack\", !1, !1);\n  }\n  t.track = s, e.dispatchEvent(t);\n}\nfunction Up(s, e) {\n  const t = s.mode;\n  if (t === \"disabled\" &amp;&amp; (s.mode = \"hidden\"), s.cues &amp;&amp; !s.cues.getCueById(e.id))\n    try {\n      if (s.addCue(e), !s.cues.getCueById(e.id))\n        throw new Error(`addCue is failed for: ${e}`);\n    } catch (r) {\n      rt.debug(`[texttrack-utils]: ${r}`);\n      try {\n        const n = new self.TextTrackCue(e.startTime, e.endTime, e.text);\n        n.id = e.id, s.addCue(n);\n      } catch (n) {\n        rt.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${n}`);\n      }\n    }\n  t === \"disabled\" &amp;&amp; (s.mode = t);\n}\nfunction Sn(s, e) {\n  const t = s.mode;\n  if (t === \"disabled\" &amp;&amp; (s.mode = \"hidden\"), s.cues)\n    for (let r = s.cues.length; r--; )\n      e &amp;&amp; s.cues[r].removeEventListener(\"enter\", e), s.removeCue(s.cues[r]);\n  t === \"disabled\" &amp;&amp; (s.mode = t);\n}\nfunction Sc(s, e, t, r) {\n  const n = s.mode;\n  if (n === \"disabled\" &amp;&amp; (s.mode = \"hidden\"), s.cues &amp;&amp; s.cues.length &gt; 0) {\n    const i = dw(s.cues, e, t);\n    for (let o = 0; o &lt; i.length; o++)\n      (!r || r(i[o])) &amp;&amp; s.removeCue(i[o]);\n  }\n  n === \"disabled\" &amp;&amp; (s.mode = n);\n}\nfunction uw(s, e) {\n  if (e &lt;= s[0].startTime)\n    return 0;\n  const t = s.length - 1;\n  if (e &gt; s[t].endTime)\n    return -1;\n  let r = 0, n = t, i;\n  for (; r &lt;= n; )\n    if (i = Math.floor((n + r) / 2), e &lt; s[i].startTime)\n      n = i - 1;\n    else if (e &gt; s[i].startTime &amp;&amp; r &lt; t)\n      r = i + 1;\n    else\n      return i;\n  return s[r].startTime - e &lt; e - s[n].startTime ? r : n;\n}\nfunction dw(s, e, t) {\n  const r = [], n = uw(s, e);\n  if (n &gt; -1)\n    for (let i = n, o = s.length; i &lt; o; i++) {\n      const a = s[i];\n      if (a.startTime &gt;= e &amp;&amp; a.endTime &lt;= t)\n        r.push(a);\n      else if (a.startTime &gt; t)\n        return r;\n    }\n  return r;\n}\nfunction Eo(s) {\n  const e = [];\n  for (let t = 0; t &lt; s.length; t++) {\n    const r = s[t];\n    (r.kind === \"subtitles\" || r.kind === \"captions\") &amp;&amp; r.label &amp;&amp; e.push(s[t]);\n  }\n  return e;\n}\nclass hw extends ku {\n  constructor(e) {\n    super(e, \"subtitle-track-controller\"), this.media = null, this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0, this.queuedDefaultTrack = -1, this.useTextTrackPolling = !1, this.subtitlePollingInterval = -1, this._subtitleDisplay = !0, this.asyncPollTrackChange = () =&gt; this.pollTrackChange(0), this.onTextTracksChanged = () =&gt; {\n      if (this.useTextTrackPolling || self.clearInterval(this.subtitlePollingInterval), !this.media || !this.hls.config.renderTextTracksNatively)\n        return;\n      let t = null;\n      const r = Eo(this.media.textTracks);\n      for (let i = 0; i &lt; r.length; i++)\n        if (r[i].mode === \"hidden\")\n          t = r[i];\n        else if (r[i].mode === \"showing\") {\n          t = r[i];\n          break;\n        }\n      const n = this.findTrackForTextTrack(t);\n      this.subtitleTrack !== n &amp;&amp; this.setSubtitleTrack(n);\n    }, this.registerListeners();\n  }\n  destroy() {\n    this.unregisterListeners(), this.tracks.length = 0, this.tracksInGroup.length = 0, this.currentTrack = null, this.onTextTracksChanged = this.asyncPollTrackChange = null, super.destroy();\n  }\n  get subtitleDisplay() {\n    return this._subtitleDisplay;\n  }\n  set subtitleDisplay(e) {\n    this._subtitleDisplay = e, this.trackId &gt; -1 &amp;&amp; this.toggleTrackModes();\n  }\n  registerListeners() {\n    const {\n      hls: e\n    } = this;\n    e.on(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.MANIFEST_PARSED, this.onManifestParsed, this), e.on(I.LEVEL_LOADING, this.onLevelLoading, this), e.on(I.LEVEL_SWITCHING, this.onLevelSwitching, this), e.on(I.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(I.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls: e\n    } = this;\n    e.off(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.MANIFEST_PARSED, this.onManifestParsed, this), e.off(I.LEVEL_LOADING, this.onLevelLoading, this), e.off(I.LEVEL_SWITCHING, this.onLevelSwitching, this), e.off(I.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(I.ERROR, this.onError, this);\n  }\n  // Listen for subtitle track change, then extract the current track ID.\n  onMediaAttached(e, t) {\n    this.media = t.media, this.media &amp;&amp; (this.queuedDefaultTrack &gt; -1 &amp;&amp; (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = -1), this.useTextTrackPolling = !(this.media.textTracks &amp;&amp; \"onchange\" in this.media.textTracks), this.useTextTrackPolling ? this.pollTrackChange(500) : this.media.textTracks.addEventListener(\"change\", this.asyncPollTrackChange));\n  }\n  pollTrackChange(e) {\n    self.clearInterval(this.subtitlePollingInterval), this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, e);\n  }\n  onMediaDetaching(e, t) {\n    const r = this.media;\n    if (!r)\n      return;\n    const n = !!t.transferMedia;\n    if (self.clearInterval(this.subtitlePollingInterval), this.useTextTrackPolling || r.textTracks.removeEventListener(\"change\", this.asyncPollTrackChange), this.trackId &gt; -1 &amp;&amp; (this.queuedDefaultTrack = this.trackId), this.subtitleTrack = -1, this.media = null, n)\n      return;\n    Eo(r.textTracks).forEach((o) =&gt; {\n      Sn(o);\n    });\n  }\n  onManifestLoading() {\n    this.tracks = [], this.groupIds = null, this.tracksInGroup = [], this.trackId = -1, this.currentTrack = null, this.selectDefaultTrack = !0;\n  }\n  // Fired whenever a new manifest is loaded.\n  onManifestParsed(e, t) {\n    this.tracks = t.subtitleTracks;\n  }\n  onSubtitleTrackLoaded(e, t) {\n    const {\n      id: r,\n      groupId: n,\n      details: i\n    } = t, o = this.tracksInGroup[r];\n    if (!o || o.groupId !== n) {\n      this.warn(`Subtitle track with id:${r} and group:${n} not found in active group ${o == null ? void 0 : o.groupId}`);\n      return;\n    }\n    const a = o.details;\n    o.details = t.details, this.log(`Subtitle track ${r} \"${o.name}\" lang:${o.lang} group:${n} loaded [${i.startSN}-${i.endSN}]`), r === this.trackId &amp;&amp; this.playlistLoaded(r, t, a);\n  }\n  onLevelLoading(e, t) {\n    this.switchLevel(t.level);\n  }\n  onLevelSwitching(e, t) {\n    this.switchLevel(t.level);\n  }\n  switchLevel(e) {\n    const t = this.hls.levels[e];\n    if (!t)\n      return;\n    const r = t.subtitleGroups || null, n = this.groupIds;\n    let i = this.currentTrack;\n    if (!r || (n == null ? void 0 : n.length) !== (r == null ? void 0 : r.length) || r != null &amp;&amp; r.some((o) =&gt; (n == null ? void 0 : n.indexOf(o)) === -1)) {\n      this.groupIds = r, this.trackId = -1, this.currentTrack = null;\n      const o = this.tracks.filter((u) =&gt; !r || r.indexOf(u.groupId) !== -1);\n      if (o.length)\n        this.selectDefaultTrack &amp;&amp; !o.some((u) =&gt; u.default) &amp;&amp; (this.selectDefaultTrack = !1), o.forEach((u, d) =&gt; {\n          u.id = d;\n        });\n      else if (!i &amp;&amp; !this.tracksInGroup.length)\n        return;\n      this.tracksInGroup = o;\n      const a = this.hls.config.subtitlePreference;\n      if (!i &amp;&amp; a) {\n        this.selectDefaultTrack = !1;\n        const u = Wr(a, o);\n        if (u &gt; -1)\n          i = o[u];\n        else {\n          const d = Wr(a, this.tracks);\n          i = this.tracks[d];\n        }\n      }\n      let l = this.findTrackId(i);\n      l === -1 &amp;&amp; i &amp;&amp; (l = this.findTrackId(null));\n      const c = {\n        subtitleTracks: o\n      };\n      this.log(`Updating subtitle tracks, ${o.length} track(s) found in \"${r == null ? void 0 : r.join(\",\")}\" group-id`), this.hls.trigger(I.SUBTITLE_TRACKS_UPDATED, c), l !== -1 &amp;&amp; this.trackId === -1 &amp;&amp; this.setSubtitleTrack(l);\n    }\n  }\n  findTrackId(e) {\n    const t = this.tracksInGroup, r = this.selectDefaultTrack;\n    for (let n = 0; n &lt; t.length; n++) {\n      const i = t[n];\n      if (!(r &amp;&amp; !i.default || !r &amp;&amp; !e) &amp;&amp; (!e || qs(i, e)))\n        return n;\n    }\n    if (e) {\n      for (let n = 0; n &lt; t.length; n++) {\n        const i = t[n];\n        if (Si(e.attrs, i.attrs, [\"LANGUAGE\", \"ASSOC-LANGUAGE\", \"CHARACTERISTICS\"]))\n          return n;\n      }\n      for (let n = 0; n &lt; t.length; n++) {\n        const i = t[n];\n        if (Si(e.attrs, i.attrs, [\"LANGUAGE\"]))\n          return n;\n      }\n    }\n    return -1;\n  }\n  findTrackForTextTrack(e) {\n    if (e) {\n      const t = this.tracksInGroup;\n      for (let r = 0; r &lt; t.length; r++) {\n        const n = t[r];\n        if (yc(n, e))\n          return r;\n      }\n    }\n    return -1;\n  }\n  onError(e, t) {\n    t.fatal || !t.context || t.context.type === Ke.SUBTITLE_TRACK &amp;&amp; t.context.id === this.trackId &amp;&amp; (!this.groupIds || this.groupIds.indexOf(t.context.groupId) !== -1) &amp;&amp; this.checkRetry(t);\n  }\n  get allSubtitleTracks() {\n    return this.tracks;\n  }\n  /** get alternate subtitle tracks list from playlist **/\n  get subtitleTracks() {\n    return this.tracksInGroup;\n  }\n  /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/\n  get subtitleTrack() {\n    return this.trackId;\n  }\n  set subtitleTrack(e) {\n    this.selectDefaultTrack = !1, this.setSubtitleTrack(e);\n  }\n  setSubtitleOption(e) {\n    if (this.hls.config.subtitlePreference = e, e) {\n      if (e.id === -1)\n        return this.setSubtitleTrack(-1), null;\n      const t = this.allSubtitleTracks;\n      if (this.selectDefaultTrack = !1, t.length) {\n        const r = this.currentTrack;\n        if (r &amp;&amp; qs(e, r))\n          return r;\n        const n = Wr(e, this.tracksInGroup);\n        if (n &gt; -1) {\n          const i = this.tracksInGroup[n];\n          return this.setSubtitleTrack(n), i;\n        } else {\n          if (r)\n            return null;\n          {\n            const i = Wr(e, t);\n            if (i &gt; -1)\n              return t[i];\n          }\n        }\n      }\n    }\n    return null;\n  }\n  loadPlaylist(e) {\n    super.loadPlaylist(), this.shouldLoadPlaylist(this.currentTrack) &amp;&amp; this.scheduleLoading(this.currentTrack, e);\n  }\n  loadingPlaylist(e, t) {\n    super.loadingPlaylist(e, t);\n    const r = e.id, n = e.groupId, i = this.getUrlWithDirectives(e.url, t), o = e.details, a = o == null ? void 0 : o.age;\n    this.log(`Loading subtitle ${r} \"${e.name}\" lang:${e.lang} group:${n}${(t == null ? void 0 : t.msn) !== void 0 ? \" at sn \" + t.msn + \" part \" + t.part : \"\"}${a &amp;&amp; o.live ? \" age \" + a.toFixed(1) + (o.type &amp;&amp; \" \" + o.type || \"\") : \"\"} ${i}`), this.hls.trigger(I.SUBTITLE_TRACK_LOADING, {\n      url: i,\n      id: r,\n      groupId: n,\n      deliveryDirectives: t || null,\n      track: e\n    });\n  }\n  /**\n   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.\n   * This operates on the DOM textTracks.\n   * A value of -1 will disable all subtitle tracks.\n   */\n  toggleTrackModes() {\n    const {\n      media: e\n    } = this;\n    if (!e)\n      return;\n    const t = Eo(e.textTracks), r = this.currentTrack;\n    let n;\n    if (r &amp;&amp; (n = t.filter((i) =&gt; yc(r, i))[0], n || this.warn(`Unable to find subtitle TextTrack with name \"${r.name}\" and language \"${r.lang}\"`)), [].slice.call(t).forEach((i) =&gt; {\n      i.mode !== \"disabled\" &amp;&amp; i !== n &amp;&amp; (i.mode = \"disabled\");\n    }), n) {\n      const i = this.subtitleDisplay ? \"showing\" : \"hidden\";\n      n.mode !== i &amp;&amp; (n.mode = i);\n    }\n  }\n  /**\n   * This method is responsible for validating the subtitle index and periodically reloading if live.\n   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.\n   */\n  setSubtitleTrack(e) {\n    const t = this.tracksInGroup;\n    if (!this.media) {\n      this.queuedDefaultTrack = e;\n      return;\n    }\n    if (e &lt; -1 || e &gt;= t.length || !ue(e)) {\n      this.warn(`Invalid subtitle track id: ${e}`);\n      return;\n    }\n    this.selectDefaultTrack = !1;\n    const r = this.currentTrack, n = t[e] || null;\n    if (this.trackId = e, this.currentTrack = n, this.toggleTrackModes(), !n) {\n      this.hls.trigger(I.SUBTITLE_TRACK_SWITCH, {\n        id: e\n      });\n      return;\n    }\n    const i = !!n.details &amp;&amp; !n.details.live;\n    if (e === this.trackId &amp;&amp; n === r &amp;&amp; i)\n      return;\n    this.log(`Switching to subtitle-track ${e}` + (n ? ` \"${n.name}\" lang:${n.lang} group:${n.groupId}` : \"\"));\n    const {\n      id: o,\n      groupId: a = \"\",\n      name: l,\n      type: c,\n      url: u\n    } = n;\n    this.hls.trigger(I.SUBTITLE_TRACK_SWITCH, {\n      id: o,\n      groupId: a,\n      name: l,\n      type: c,\n      url: u\n    });\n    const d = this.switchParams(n.url, r == null ? void 0 : r.details, n.details);\n    this.loadPlaylist(d);\n  }\n}\nfunction fw() {\n  try {\n    return crypto.randomUUID();\n  } catch {\n    try {\n      const e = URL.createObjectURL(new Blob()), t = e.toString();\n      return URL.revokeObjectURL(e), t.slice(t.lastIndexOf(\"/\") + 1);\n    } catch {\n      let t = (/* @__PURE__ */ new Date()).getTime();\n      return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (n) =&gt; {\n        const i = (t + Math.random() * 16) % 16 | 0;\n        return t = Math.floor(t / 16), (n == \"x\" ? i : i &amp; 3 | 8).toString(16);\n      });\n    }\n  }\n}\nfunction Xn(s) {\n  let e = 5381, t = s.length;\n  for (; t; )\n    e = e * 33 ^ s.charCodeAt(--t);\n  return (e &gt;&gt;&gt; 0).toString();\n}\nconst Rn = 0.025;\nlet ia = /* @__PURE__ */ (function(s) {\n  return s[s.Point = 0] = \"Point\", s[s.Range = 1] = \"Range\", s;\n})({});\nfunction gw(s, e, t) {\n  return `${s.identifier}-${t + 1}-${Xn(e)}`;\n}\nclass pw {\n  constructor(e, t) {\n    this.base = void 0, this._duration = null, this._timelineStart = null, this.appendInPlaceDisabled = void 0, this.appendInPlaceStarted = void 0, this.dateRange = void 0, this.hasPlayed = !1, this.cumulativeDuration = 0, this.resumeOffset = NaN, this.playoutLimit = NaN, this.restrictions = {\n      skip: !1,\n      jump: !1\n    }, this.snapOptions = {\n      out: !1,\n      in: !1\n    }, this.assetList = [], this.assetListLoader = void 0, this.assetListResponse = null, this.resumeAnchor = void 0, this.error = void 0, this.resetOnResume = void 0, this.base = t, this.dateRange = e, this.setDateRange(e);\n  }\n  setDateRange(e) {\n    this.dateRange = e, this.resumeOffset = e.attr.optionalFloat(\"X-RESUME-OFFSET\", this.resumeOffset), this.playoutLimit = e.attr.optionalFloat(\"X-PLAYOUT-LIMIT\", this.playoutLimit), this.restrictions = e.attr.enumeratedStringList(\"X-RESTRICT\", this.restrictions), this.snapOptions = e.attr.enumeratedStringList(\"X-SNAP\", this.snapOptions);\n  }\n  reset() {\n    var e;\n    this.appendInPlaceStarted = !1, (e = this.assetListLoader) == null || e.destroy(), this.assetListLoader = void 0, this.supplementsPrimary || (this.assetListResponse = null, this.assetList = [], this._duration = null);\n  }\n  isAssetPastPlayoutLimit(e) {\n    var t;\n    if (e &gt; 0 &amp;&amp; e &gt;= this.assetList.length)\n      return !0;\n    const r = this.playoutLimit;\n    return e &lt;= 0 || isNaN(r) ? !1 : r === 0 ? !0 : (((t = this.assetList[e]) == null ? void 0 : t.startOffset) || 0) &gt; r;\n  }\n  findAssetIndex(e) {\n    return this.assetList.indexOf(e);\n  }\n  get identifier() {\n    return this.dateRange.id;\n  }\n  get startDate() {\n    return this.dateRange.startDate;\n  }\n  get startTime() {\n    const e = this.dateRange.startTime;\n    if (this.snapOptions.out) {\n      const t = this.dateRange.tagAnchor;\n      if (t)\n        return bl(e, t);\n    }\n    return e;\n  }\n  get startOffset() {\n    return this.cue.pre ? 0 : this.startTime;\n  }\n  get startIsAligned() {\n    if (this.startTime === 0 || this.snapOptions.out)\n      return !0;\n    const e = this.dateRange.tagAnchor;\n    if (e) {\n      const t = this.dateRange.startTime, r = bl(t, e);\n      return t - r &lt; 0.1;\n    }\n    return !1;\n  }\n  get resumptionOffset() {\n    const e = this.resumeOffset, t = ue(e) ? e : this.duration;\n    return this.cumulativeDuration + t;\n  }\n  get resumeTime() {\n    const e = this.startOffset + this.resumptionOffset;\n    if (this.snapOptions.in) {\n      const t = this.resumeAnchor;\n      if (t)\n        return bl(e, t);\n    }\n    return e;\n  }\n  get appendInPlace() {\n    return this.appendInPlaceStarted ? !0 : this.appendInPlaceDisabled ? !1 : !!(!this.cue.once &amp;&amp; !this.cue.pre &amp;&amp; // preroll starts at startPosition before startPosition is known (live)\n    this.startIsAligned &amp;&amp; (isNaN(this.playoutLimit) &amp;&amp; isNaN(this.resumeOffset) || this.resumeOffset &amp;&amp; this.duration &amp;&amp; Math.abs(this.resumeOffset - this.duration) &lt; Rn));\n  }\n  set appendInPlace(e) {\n    if (this.appendInPlaceStarted) {\n      this.resetOnResume = !e;\n      return;\n    }\n    this.appendInPlaceDisabled = !e;\n  }\n  // Extended timeline start time\n  get timelineStart() {\n    return this._timelineStart !== null ? this._timelineStart : this.startTime;\n  }\n  set timelineStart(e) {\n    this._timelineStart = e;\n  }\n  get duration() {\n    const e = this.playoutLimit;\n    let t;\n    return this._duration !== null ? t = this._duration : this.dateRange.duration ? t = this.dateRange.duration : t = this.dateRange.plannedDuration || 0, !isNaN(e) &amp;&amp; e &lt; t &amp;&amp; (t = e), t;\n  }\n  set duration(e) {\n    this._duration = e;\n  }\n  get cue() {\n    return this.dateRange.cue;\n  }\n  get timelineOccupancy() {\n    return this.dateRange.attr[\"X-TIMELINE-OCCUPIES\"] === \"RANGE\" ? ia.Range : ia.Point;\n  }\n  get supplementsPrimary() {\n    return this.dateRange.attr[\"X-TIMELINE-STYLE\"] === \"PRIMARY\";\n  }\n  get contentMayVary() {\n    return this.dateRange.attr[\"X-CONTENT-MAY-VARY\"] !== \"NO\";\n  }\n  get assetUrl() {\n    return this.dateRange.attr[\"X-ASSET-URI\"];\n  }\n  get assetListUrl() {\n    return this.dateRange.attr[\"X-ASSET-LIST\"];\n  }\n  get baseUrl() {\n    return this.base.url;\n  }\n  get assetListLoaded() {\n    return this.assetList.length &gt; 0 || this.assetListResponse !== null;\n  }\n  toString() {\n    return mw(this);\n  }\n}\nfunction bl(s, e) {\n  return s - e.start &lt; e.duration / 2 &amp;&amp; !(Math.abs(s - (e.start + e.duration)) &lt; Rn) ? e.start : e.start + e.duration;\n}\nfunction $p(s, e, t) {\n  const r = new self.URL(s, t);\n  return r.protocol !== \"data:\" &amp;&amp; r.searchParams.set(\"_HLS_primary_id\", e), r;\n}\nfunction Tl(s, e) {\n  for (; (t = s.assetList[++e]) != null &amp;&amp; t.error; )\n    var t;\n  return e;\n}\nfunction mw(s) {\n  return `[\"${s.identifier}\" ${s.cue.pre ? \"&lt;pre&gt;\" : s.cue.post ? \"&lt;post&gt;\" : \"\"}${s.timelineStart.toFixed(2)}-${s.resumeTime.toFixed(2)}]`;\n}\nfunction vn(s) {\n  const e = s.timelineStart, t = s.duration || 0;\n  return `[\"${s.identifier}\" ${e.toFixed(2)}-${(e + t).toFixed(2)}]`;\n}\nclass yw {\n  constructor(e, t, r, n) {\n    this.hls = void 0, this.interstitial = void 0, this.assetItem = void 0, this.tracks = null, this.hasDetails = !1, this.mediaAttached = null, this._currentTime = void 0, this._bufferedEosTime = void 0, this.checkPlayout = () =&gt; {\n      this.reachedPlayout(this.currentTime) &amp;&amp; this.hls &amp;&amp; this.hls.trigger(I.PLAYOUT_LIMIT_REACHED, {});\n    };\n    const i = this.hls = new e(t);\n    this.interstitial = r, this.assetItem = n;\n    const o = () =&gt; {\n      this.hasDetails = !0;\n    };\n    i.once(I.LEVEL_LOADED, o), i.once(I.AUDIO_TRACK_LOADED, o), i.once(I.SUBTITLE_TRACK_LOADED, o), i.on(I.MEDIA_ATTACHING, (a, {\n      media: l\n    }) =&gt; {\n      this.removeMediaListeners(), this.mediaAttached = l, this.interstitial.playoutLimit &amp;&amp; (l.addEventListener(\"timeupdate\", this.checkPlayout), this.appendInPlace &amp;&amp; i.on(I.BUFFER_APPENDED, () =&gt; {\n        const u = this.bufferedEnd;\n        this.reachedPlayout(u) &amp;&amp; (this._bufferedEosTime = u, i.trigger(I.BUFFERED_TO_END, void 0));\n      }));\n    });\n  }\n  get appendInPlace() {\n    return this.interstitial.appendInPlace;\n  }\n  loadSource() {\n    const e = this.hls;\n    if (e)\n      if (e.url)\n        e.levels.length &amp;&amp; !e.started &amp;&amp; e.startLoad(-1, !0);\n      else {\n        let t = this.assetItem.uri;\n        try {\n          t = $p(t, e.config.primarySessionId || \"\").href;\n        } catch {\n        }\n        e.loadSource(t);\n      }\n  }\n  bufferedInPlaceToEnd(e) {\n    var t;\n    if (!this.appendInPlace)\n      return !1;\n    if ((t = this.hls) != null &amp;&amp; t.bufferedToEnd)\n      return !0;\n    if (!e)\n      return !1;\n    const r = Math.min(this._bufferedEosTime || 1 / 0, this.duration), n = this.timelineOffset, i = Ce.bufferInfo(e, n, 0);\n    return this.getAssetTime(i.end) &gt;= r - 0.02;\n  }\n  reachedPlayout(e) {\n    const r = this.interstitial.playoutLimit;\n    return this.startOffset + e &gt;= r;\n  }\n  get destroyed() {\n    var e;\n    return !((e = this.hls) != null &amp;&amp; e.userConfig);\n  }\n  get assetId() {\n    return this.assetItem.identifier;\n  }\n  get interstitialId() {\n    return this.assetItem.parentIdentifier;\n  }\n  get media() {\n    var e;\n    return ((e = this.hls) == null ? void 0 : e.media) || null;\n  }\n  get bufferedEnd() {\n    const e = this.media || this.mediaAttached;\n    if (!e)\n      return this._bufferedEosTime ? this._bufferedEosTime : this.currentTime;\n    const t = Ce.bufferInfo(e, e.currentTime, 1e-3);\n    return this.getAssetTime(t.end);\n  }\n  get currentTime() {\n    const e = this.media || this.mediaAttached;\n    return e ? this.getAssetTime(e.currentTime) : this._currentTime || 0;\n  }\n  get duration() {\n    const e = this.assetItem.duration;\n    if (!e)\n      return 0;\n    const t = this.interstitial.playoutLimit;\n    if (t) {\n      const r = t - this.startOffset;\n      if (r &gt; 0 &amp;&amp; r &lt; e)\n        return r;\n    }\n    return e;\n  }\n  get remaining() {\n    const e = this.duration;\n    return e ? Math.max(0, e - this.currentTime) : 0;\n  }\n  get startOffset() {\n    return this.assetItem.startOffset;\n  }\n  get timelineOffset() {\n    var e;\n    return ((e = this.hls) == null ? void 0 : e.config.timelineOffset) || 0;\n  }\n  set timelineOffset(e) {\n    const t = this.timelineOffset;\n    if (e !== t) {\n      const r = e - t;\n      if (Math.abs(r) &gt; 1 / 9e4 &amp;&amp; this.hls) {\n        if (this.hasDetails)\n          throw new Error(\"Cannot set timelineOffset after playlists are loaded\");\n        this.hls.config.timelineOffset = e;\n      }\n    }\n  }\n  getAssetTime(e) {\n    const t = this.timelineOffset, r = this.duration;\n    return Math.min(Math.max(0, e - t), r);\n  }\n  removeMediaListeners() {\n    const e = this.mediaAttached;\n    e &amp;&amp; (this._currentTime = e.currentTime, this.bufferSnapShot(), e.removeEventListener(\"timeupdate\", this.checkPlayout));\n  }\n  bufferSnapShot() {\n    if (this.mediaAttached) {\n      var e;\n      (e = this.hls) != null &amp;&amp; e.bufferedToEnd &amp;&amp; (this._bufferedEosTime = this.bufferedEnd);\n    }\n  }\n  destroy() {\n    this.removeMediaListeners(), this.hls &amp;&amp; this.hls.destroy(), this.hls = null, this.tracks = this.mediaAttached = this.checkPlayout = null;\n  }\n  attachMedia(e) {\n    var t;\n    this.loadSource(), (t = this.hls) == null || t.attachMedia(e);\n  }\n  detachMedia() {\n    var e;\n    this.removeMediaListeners(), this.mediaAttached = null, (e = this.hls) == null || e.detachMedia();\n  }\n  resumeBuffering() {\n    var e;\n    (e = this.hls) == null || e.resumeBuffering();\n  }\n  pauseBuffering() {\n    var e;\n    (e = this.hls) == null || e.pauseBuffering();\n  }\n  transferMedia() {\n    var e;\n    return this.bufferSnapShot(), ((e = this.hls) == null ? void 0 : e.transferMedia()) || null;\n  }\n  resetDetails() {\n    const e = this.hls;\n    if (e &amp;&amp; this.hasDetails) {\n      e.stopLoad();\n      const t = (r) =&gt; delete r.details;\n      e.levels.forEach(t), e.allAudioTracks.forEach(t), e.allSubtitleTracks.forEach(t), this.hasDetails = !1;\n    }\n  }\n  on(e, t, r) {\n    var n;\n    (n = this.hls) == null || n.on(e, t);\n  }\n  once(e, t, r) {\n    var n;\n    (n = this.hls) == null || n.once(e, t);\n  }\n  off(e, t, r) {\n    var n;\n    (n = this.hls) == null || n.off(e, t);\n  }\n  toString() {\n    var e;\n    return `HlsAssetPlayer: ${vn(this.assetItem)} ${(e = this.hls) == null ? void 0 : e.sessionId} ${this.appendInPlace ? \"append-in-place\" : \"\"}`;\n  }\n}\nconst Xh = 0.033;\nclass vw extends Lr {\n  constructor(e, t) {\n    super(\"interstitials-sched\", t), this.onScheduleUpdate = void 0, this.eventMap = {}, this.events = null, this.items = null, this.durations = {\n      primary: 0,\n      playout: 0,\n      integrated: 0\n    }, this.onScheduleUpdate = e;\n  }\n  destroy() {\n    this.reset(), this.onScheduleUpdate = null;\n  }\n  reset() {\n    this.eventMap = {}, this.setDurations(0, 0, 0), this.events &amp;&amp; this.events.forEach((e) =&gt; e.reset()), this.events = this.items = null;\n  }\n  resetErrorsInRange(e, t) {\n    return this.events ? this.events.reduce((r, n) =&gt; e &lt;= n.startOffset &amp;&amp; t &gt; n.startOffset ? (delete n.error, r + 1) : r, 0) : 0;\n  }\n  get duration() {\n    const e = this.items;\n    return e ? e[e.length - 1].end : 0;\n  }\n  get length() {\n    return this.items ? this.items.length : 0;\n  }\n  getEvent(e) {\n    return e &amp;&amp; this.eventMap[e] || null;\n  }\n  hasEvent(e) {\n    return e in this.eventMap;\n  }\n  findItemIndex(e, t) {\n    if (e.event)\n      return this.findEventIndex(e.event.identifier);\n    let r = -1;\n    e.nextEvent ? r = this.findEventIndex(e.nextEvent.identifier) - 1 : e.previousEvent &amp;&amp; (r = this.findEventIndex(e.previousEvent.identifier) + 1);\n    const n = this.items;\n    if (n)\n      for (n[r] || (t === void 0 &amp;&amp; (t = e.start), r = this.findItemIndexAtTime(t)); r &gt;= 0 &amp;&amp; (i = n[r]) != null &amp;&amp; i.event; ) {\n        var i;\n        r--;\n      }\n    return r;\n  }\n  findItemIndexAtTime(e, t) {\n    const r = this.items;\n    if (r)\n      for (let n = 0; n &lt; r.length; n++) {\n        let i = r[n];\n        if (t &amp;&amp; t !== \"primary\" &amp;&amp; (i = i[t]), e === i.start || e &gt; i.start &amp;&amp; e &lt; i.end)\n          return n;\n      }\n    return -1;\n  }\n  findJumpRestrictedIndex(e, t) {\n    const r = this.items;\n    if (r)\n      for (let n = e; n &lt;= t &amp;&amp; r[n]; n++) {\n        const i = r[n].event;\n        if (i != null &amp;&amp; i.restrictions.jump &amp;&amp; !i.appendInPlace)\n          return n;\n      }\n    return -1;\n  }\n  findEventIndex(e) {\n    const t = this.items;\n    if (t)\n      for (let n = t.length; n--; ) {\n        var r;\n        if (((r = t[n].event) == null ? void 0 : r.identifier) === e)\n          return n;\n      }\n    return -1;\n  }\n  findAssetIndex(e, t) {\n    const r = e.assetList, n = r.length;\n    if (n &gt; 1)\n      for (let i = 0; i &lt; n; i++) {\n        const o = r[i];\n        if (!o.error) {\n          const a = o.timelineStart;\n          if (t === a || t &gt; a &amp;&amp; (t &lt; a + (o.duration || 0) || i === n - 1))\n            return i;\n        }\n      }\n    return 0;\n  }\n  get assetIdAtEnd() {\n    var e;\n    const t = (e = this.items) == null || (e = e[this.length - 1]) == null ? void 0 : e.event;\n    if (t) {\n      const r = t.assetList, n = r[r.length - 1];\n      if (n)\n        return n.identifier;\n    }\n    return null;\n  }\n  parseInterstitialDateRanges(e, t) {\n    const r = e.main.details, {\n      dateRanges: n\n    } = r, i = this.events, o = this.parseDateRanges(n, {\n      url: r.url\n    }, t), a = Object.keys(n), l = i ? i.filter((c) =&gt; !a.includes(c.identifier)) : [];\n    o.length &amp;&amp; o.sort((c, u) =&gt; {\n      const d = c.cue.pre, h = c.cue.post, f = u.cue.pre, p = u.cue.post;\n      if (d &amp;&amp; !f)\n        return -1;\n      if (f &amp;&amp; !d || h &amp;&amp; !p)\n        return 1;\n      if (p &amp;&amp; !h)\n        return -1;\n      if (!d &amp;&amp; !f &amp;&amp; !h &amp;&amp; !p) {\n        const y = c.startTime, E = u.startTime;\n        if (y !== E)\n          return y - E;\n      }\n      return c.dateRange.tagOrder - u.dateRange.tagOrder;\n    }), this.events = o, l.forEach((c) =&gt; {\n      this.removeEvent(c);\n    }), this.updateSchedule(e, l);\n  }\n  updateSchedule(e, t = [], r = !1) {\n    const n = this.events || [];\n    if (n.length || t.length || this.length &lt; 2) {\n      const i = this.items, o = this.parseSchedule(n, e);\n      (r || t.length || (i == null ? void 0 : i.length) !== o.length || o.some((l, c) =&gt; Math.abs(l.playout.start - i[c].playout.start) &gt; 5e-3 || Math.abs(l.playout.end - i[c].playout.end) &gt; 5e-3)) &amp;&amp; (this.items = o, this.onScheduleUpdate(t, i));\n    }\n  }\n  parseDateRanges(e, t, r) {\n    const n = [], i = Object.keys(e);\n    for (let o = 0; o &lt; i.length; o++) {\n      const a = i[o], l = e[a];\n      if (l.isInterstitial) {\n        let c = this.eventMap[a];\n        c ? c.setDateRange(l) : (c = new pw(l, t), this.eventMap[a] = c, r === !1 &amp;&amp; (c.appendInPlace = r)), n.push(c);\n      }\n    }\n    return n;\n  }\n  parseSchedule(e, t) {\n    const r = [], n = t.main.details, i = n.live ? 1 / 0 : n.edge;\n    let o = 0;\n    if (e = e.filter((l) =&gt; !l.error &amp;&amp; !(l.cue.once &amp;&amp; l.hasPlayed)), e.length) {\n      this.resolveOffsets(e, t);\n      let l = 0, c = 0;\n      if (e.forEach((u, d) =&gt; {\n        const h = u.cue.pre, f = u.cue.post, p = e[d - 1] || null, y = u.appendInPlace, E = f ? i : u.startOffset, b = u.duration, R = u.timelineOccupancy === ia.Range ? b : 0, A = u.resumptionOffset, F = (p == null ? void 0 : p.startTime) === E, M = E + u.cumulativeDuration;\n        let H = y ? M + b : E + A;\n        if (h || !f &amp;&amp; E &lt;= 0) {\n          const j = c;\n          c += R, u.timelineStart = M;\n          const C = o;\n          o += b, r.push({\n            event: u,\n            start: M,\n            end: H,\n            playout: {\n              start: C,\n              end: o\n            },\n            integrated: {\n              start: j,\n              end: c\n            }\n          });\n        } else if (E &lt;= i) {\n          if (!F) {\n            const k = E - l;\n            if (k &gt; Xh) {\n              const $ = l, W = c;\n              c += k;\n              const _ = o;\n              o += k;\n              const g = {\n                previousEvent: e[d - 1] || null,\n                nextEvent: u,\n                start: $,\n                end: $ + k,\n                playout: {\n                  start: _,\n                  end: o\n                },\n                integrated: {\n                  start: W,\n                  end: c\n                }\n              };\n              r.push(g);\n            } else k &gt; 0 &amp;&amp; p &amp;&amp; (p.cumulativeDuration += k, r[r.length - 1].end = E);\n          }\n          f &amp;&amp; (H = M), u.timelineStart = M;\n          const j = c;\n          c += R;\n          const C = o;\n          o += b, r.push({\n            event: u,\n            start: M,\n            end: H,\n            playout: {\n              start: C,\n              end: o\n            },\n            integrated: {\n              start: j,\n              end: c\n            }\n          });\n        } else\n          return;\n        const K = u.resumeTime;\n        f || K &gt; i ? l = i : l = K;\n      }), l &lt; i) {\n        var a;\n        const u = l, d = c, h = i - l;\n        c += h;\n        const f = o;\n        o += h, r.push({\n          previousEvent: ((a = r[r.length - 1]) == null ? void 0 : a.event) || null,\n          nextEvent: null,\n          start: l,\n          end: u + h,\n          playout: {\n            start: f,\n            end: o\n          },\n          integrated: {\n            start: d,\n            end: c\n          }\n        });\n      }\n      this.setDurations(i, o, c);\n    } else\n      r.push({\n        previousEvent: null,\n        nextEvent: null,\n        start: 0,\n        end: i,\n        playout: {\n          start: 0,\n          end: i\n        },\n        integrated: {\n          start: 0,\n          end: i\n        }\n      }), this.setDurations(i, i, i);\n    return r;\n  }\n  setDurations(e, t, r) {\n    this.durations = {\n      primary: e,\n      playout: t,\n      integrated: r\n    };\n  }\n  resolveOffsets(e, t) {\n    const r = t.main.details, n = r.live ? 1 / 0 : r.edge;\n    let i = 0, o = -1;\n    e.forEach((a, l) =&gt; {\n      const c = a.cue.pre, u = a.cue.post, d = c ? 0 : u ? n : a.startTime;\n      this.updateAssetDurations(a), o === d ? a.cumulativeDuration = i : (i = 0, o = d), !u &amp;&amp; a.snapOptions.in &amp;&amp; (a.resumeAnchor = Js(null, r.fragments, a.startOffset + a.resumptionOffset, 0, 0) || void 0), a.appendInPlace &amp;&amp; !a.appendInPlaceStarted &amp;&amp; (this.primaryCanResumeInPlaceAt(a, t) || (a.appendInPlace = !1)), !a.appendInPlace &amp;&amp; l + 1 &lt; e.length &amp;&amp; e[l + 1].startTime - e[l].resumeTime &lt; Xh &amp;&amp; (e[l + 1].appendInPlace = !1, e[l + 1].appendInPlace &amp;&amp; this.warn(`Could not change append strategy for abutting event ${a}`));\n      const f = ue(a.resumeOffset) ? a.resumeOffset : a.duration;\n      i += f;\n    });\n  }\n  primaryCanResumeInPlaceAt(e, t) {\n    const r = e.resumeTime, n = e.startTime + e.resumptionOffset;\n    return Math.abs(r - n) &gt; Rn ? (this.log(`\"${e.identifier}\" resumption ${r} not aligned with estimated timeline end ${n}`), !1) : !Object.keys(t).some((o) =&gt; {\n      const a = t[o].details, l = a.edge;\n      if (r &gt;= l)\n        return this.log(`\"${e.identifier}\" resumption ${r} past ${o} playlist end ${l}`), !1;\n      const c = Js(null, a.fragments, r);\n      if (!c)\n        return this.log(`\"${e.identifier}\" resumption ${r} does not align with any fragments in ${o} playlist (${a.fragStart}-${a.fragmentEnd})`), !0;\n      const u = o === \"audio\" ? 0.175 : 0;\n      return Math.abs(c.start - r) &lt; Rn + u || Math.abs(c.end - r) &lt; Rn + u ? !1 : (this.log(`\"${e.identifier}\" resumption ${r} not aligned with ${o} fragment bounds (${c.start}-${c.end} sn: ${c.sn} cc: ${c.cc})`), !0);\n    });\n  }\n  updateAssetDurations(e) {\n    if (!e.assetListLoaded)\n      return;\n    const t = e.timelineStart;\n    let r = 0, n = !1, i = !1;\n    for (let o = 0; o &lt; e.assetList.length; o++) {\n      const a = e.assetList[o], l = t + r;\n      a.startOffset = r, a.timelineStart = l, n || (n = a.duration === null), i || (i = !!a.error);\n      const c = a.error ? 0 : a.duration || 0;\n      r += c;\n    }\n    n &amp;&amp; !i ? e.duration = Math.max(r, e.duration) : e.duration = r;\n  }\n  removeEvent(e) {\n    e.reset(), delete this.eventMap[e.identifier];\n  }\n}\nfunction kr(s) {\n  return `[${s.event ? '\"' + s.event.identifier + '\"' : \"primary\"}: ${s.start.toFixed(2)}-${s.end.toFixed(2)}]`;\n}\nclass Ew {\n  constructor(e) {\n    this.hls = void 0, this.hls = e;\n  }\n  destroy() {\n    this.hls = null;\n  }\n  loadAssetList(e, t) {\n    const r = e.assetListUrl;\n    let n;\n    try {\n      n = $p(r, this.hls.sessionId, e.baseUrl);\n    } catch (h) {\n      const f = this.assignAssetListError(e, J.ASSET_LIST_LOAD_ERROR, h, r);\n      this.hls.trigger(I.ERROR, f);\n      return;\n    }\n    t &amp;&amp; n.protocol !== \"data:\" &amp;&amp; n.searchParams.set(\"_HLS_start_offset\", \"\" + t);\n    const i = this.hls.config, o = i.loader, a = new o(i), l = {\n      responseType: \"json\",\n      url: n.href\n    }, c = i.interstitialAssetListLoadPolicy.default, u = {\n      loadPolicy: c,\n      timeout: c.maxLoadTimeMs,\n      maxRetry: 0,\n      retryDelay: 0,\n      maxRetryDelay: 0\n    }, d = {\n      onSuccess: (h, f, p, y) =&gt; {\n        const E = h.data, b = E == null ? void 0 : E.ASSETS;\n        if (!Array.isArray(b)) {\n          const R = this.assignAssetListError(e, J.ASSET_LIST_PARSING_ERROR, new Error(\"Invalid interstitial asset list\"), p.url, f, y);\n          this.hls.trigger(I.ERROR, R);\n          return;\n        }\n        e.assetListResponse = E, this.hls.trigger(I.ASSET_LIST_LOADED, {\n          event: e,\n          assetListResponse: E,\n          networkDetails: y\n        });\n      },\n      onError: (h, f, p, y) =&gt; {\n        const E = this.assignAssetListError(e, J.ASSET_LIST_LOAD_ERROR, new Error(`Error loading X-ASSET-LIST: HTTP status ${h.code} ${h.text} (${f.url})`), f.url, y, p);\n        this.hls.trigger(I.ERROR, E);\n      },\n      onTimeout: (h, f, p) =&gt; {\n        const y = this.assignAssetListError(e, J.ASSET_LIST_LOAD_TIMEOUT, new Error(`Timeout loading X-ASSET-LIST (${f.url})`), f.url, h, p);\n        this.hls.trigger(I.ERROR, y);\n      }\n    };\n    return a.load(l, u, d), this.hls.trigger(I.ASSET_LIST_LOADING, {\n      event: e\n    }), a;\n  }\n  assignAssetListError(e, t, r, n, i, o) {\n    return e.error = r, {\n      type: ve.NETWORK_ERROR,\n      details: t,\n      fatal: !1,\n      interstitial: e,\n      url: n,\n      error: r,\n      networkDetails: o,\n      stats: i\n    };\n  }\n}\nfunction Jh(s) {\n  s == null || s.play().catch(() =&gt; {\n  });\n}\nfunction Qi(s, e) {\n  return `[${s}] Advancing timeline position to ${e}`;\n}\nclass xw extends Lr {\n  constructor(e, t) {\n    super(\"interstitials\", e.logger), this.HlsPlayerClass = void 0, this.hls = void 0, this.assetListLoader = void 0, this.mediaSelection = null, this.altSelection = null, this.media = null, this.detachedData = null, this.requiredTracks = null, this.manager = null, this.playerQueue = [], this.bufferedPos = -1, this.timelinePos = -1, this.schedule = void 0, this.playingItem = null, this.bufferingItem = null, this.waitingItem = null, this.endedItem = null, this.playingAsset = null, this.endedAsset = null, this.bufferingAsset = null, this.shouldPlay = !1, this.onPlay = () =&gt; {\n      this.shouldPlay = !0;\n    }, this.onPause = () =&gt; {\n      this.shouldPlay = !1;\n    }, this.onSeeking = () =&gt; {\n      const r = this.currentTime;\n      if (r === void 0 || this.playbackDisabled || !this.schedule)\n        return;\n      const n = r - this.timelinePos;\n      if (Math.abs(n) &lt; 1 / 7056e5)\n        return;\n      const o = n &lt;= -0.01;\n      this.timelinePos = r, this.bufferedPos = r;\n      const a = this.playingItem;\n      if (!a) {\n        this.checkBuffer();\n        return;\n      }\n      if (o &amp;&amp; this.schedule.resetErrorsInRange(r, r - n) &amp;&amp; this.updateSchedule(!0), this.checkBuffer(), o &amp;&amp; r &lt; a.start || r &gt;= a.end) {\n        var l;\n        const f = this.findItemIndex(a);\n        let p = this.schedule.findItemIndexAtTime(r);\n        if (p === -1 &amp;&amp; (p = f + (o ? -1 : 1), this.log(`seeked ${o ? \"back \" : \"\"}to position not covered by schedule ${r} (resolving from ${f} to ${p})`)), !this.isInterstitial(a) &amp;&amp; (l = this.media) != null &amp;&amp; l.paused &amp;&amp; (this.shouldPlay = !1), !o &amp;&amp; p &gt; f) {\n          const y = this.schedule.findJumpRestrictedIndex(f + 1, p);\n          if (y &gt; f) {\n            this.setSchedulePosition(y);\n            return;\n          }\n        }\n        this.setSchedulePosition(p);\n        return;\n      }\n      const c = this.playingAsset;\n      if (!c) {\n        if (this.playingLastItem &amp;&amp; this.isInterstitial(a)) {\n          const f = a.event.assetList[0];\n          f &amp;&amp; (this.endedItem = this.playingItem, this.playingItem = null, this.setScheduleToAssetAtTime(r, f));\n        }\n        return;\n      }\n      const u = c.timelineStart, d = c.duration || 0;\n      if (o &amp;&amp; r &lt; u || r &gt;= u + d) {\n        var h;\n        (h = a.event) != null &amp;&amp; h.appendInPlace &amp;&amp; (this.clearInterstitial(a.event, a), this.flushFrontBuffer(r)), this.setScheduleToAssetAtTime(r, c);\n      }\n    }, this.onTimeupdate = () =&gt; {\n      const r = this.currentTime;\n      if (r === void 0 || this.playbackDisabled)\n        return;\n      if (r &gt; this.timelinePos)\n        this.timelinePos = r, r &gt; this.bufferedPos &amp;&amp; this.checkBuffer();\n      else\n        return;\n      const n = this.playingItem;\n      if (!n || this.playingLastItem)\n        return;\n      if (r &gt;= n.end) {\n        this.timelinePos = n.end;\n        const a = this.findItemIndex(n);\n        this.setSchedulePosition(a + 1);\n      }\n      const i = this.playingAsset;\n      if (!i)\n        return;\n      const o = i.timelineStart + (i.duration || 0);\n      r &gt;= o &amp;&amp; this.setScheduleToAssetAtTime(r, i);\n    }, this.onScheduleUpdate = (r, n) =&gt; {\n      const i = this.schedule;\n      if (!i)\n        return;\n      const o = this.playingItem, a = i.events || [], l = i.items || [], c = i.durations, u = r.map((y) =&gt; y.identifier), d = !!(a.length || u.length);\n      (d || n) &amp;&amp; this.log(`INTERSTITIALS_UPDATED (${a.length}): ${a}\nSchedule: ${l.map((y) =&gt; kr(y))} pos: ${this.timelinePos}`), u.length &amp;&amp; this.log(`Removed events ${u}`);\n      let h = null, f = null;\n      o &amp;&amp; (h = this.updateItem(o, this.timelinePos), this.itemsMatch(o, h) ? this.playingItem = h : this.waitingItem = this.endedItem = null), this.waitingItem = this.updateItem(this.waitingItem), this.endedItem = this.updateItem(this.endedItem);\n      const p = this.bufferingItem;\n      if (p &amp;&amp; (f = this.updateItem(p, this.bufferedPos), this.itemsMatch(p, f) ? this.bufferingItem = f : p.event &amp;&amp; (this.bufferingItem = this.playingItem, this.clearInterstitial(p.event, null))), r.forEach((y) =&gt; {\n        y.assetList.forEach((E) =&gt; {\n          this.clearAssetPlayer(E.identifier, null);\n        });\n      }), this.playerQueue.forEach((y) =&gt; {\n        if (y.interstitial.appendInPlace) {\n          const E = y.assetItem.timelineStart, b = y.timelineOffset - E;\n          if (b)\n            try {\n              y.timelineOffset = E;\n            } catch (R) {\n              Math.abs(b) &gt; Rn &amp;&amp; this.warn(`${R} (\"${y.assetId}\" ${y.timelineOffset}-&gt;${E})`);\n            }\n        }\n      }), d || n) {\n        if (this.hls.trigger(I.INTERSTITIALS_UPDATED, {\n          events: a.slice(0),\n          schedule: l.slice(0),\n          durations: c,\n          removedIds: u\n        }), this.isInterstitial(o) &amp;&amp; u.includes(o.event.identifier)) {\n          this.warn(`Interstitial \"${o.event.identifier}\" removed while playing`), this.primaryFallback(o.event);\n          return;\n        }\n        o &amp;&amp; this.trimInPlace(h, o), p &amp;&amp; f !== h &amp;&amp; this.trimInPlace(f, p), this.checkBuffer();\n      }\n    }, this.hls = e, this.HlsPlayerClass = t, this.assetListLoader = new Ew(e), this.schedule = new vw(this.onScheduleUpdate, e.logger), this.registerListeners();\n  }\n  registerListeners() {\n    const e = this.hls;\n    e &amp;&amp; (e.on(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(I.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(I.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this), e.on(I.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(I.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this), e.on(I.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this), e.on(I.ASSET_LIST_LOADED, this.onAssetListLoaded, this), e.on(I.BUFFER_APPENDED, this.onBufferAppended, this), e.on(I.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(I.BUFFERED_TO_END, this.onBufferedToEnd, this), e.on(I.MEDIA_ENDED, this.onMediaEnded, this), e.on(I.ERROR, this.onError, this), e.on(I.DESTROYING, this.onDestroying, this));\n  }\n  unregisterListeners() {\n    const e = this.hls;\n    e &amp;&amp; (e.off(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(I.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(I.AUDIO_TRACK_UPDATED, this.onAudioTrackUpdated, this), e.off(I.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(I.SUBTITLE_TRACK_UPDATED, this.onSubtitleTrackUpdated, this), e.off(I.EVENT_CUE_ENTER, this.onInterstitialCueEnter, this), e.off(I.ASSET_LIST_LOADED, this.onAssetListLoaded, this), e.off(I.BUFFER_CODECS, this.onBufferCodecs, this), e.off(I.BUFFER_APPENDED, this.onBufferAppended, this), e.off(I.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(I.BUFFERED_TO_END, this.onBufferedToEnd, this), e.off(I.MEDIA_ENDED, this.onMediaEnded, this), e.off(I.ERROR, this.onError, this), e.off(I.DESTROYING, this.onDestroying, this));\n  }\n  startLoad() {\n    this.resumeBuffering();\n  }\n  stopLoad() {\n    this.pauseBuffering();\n  }\n  resumeBuffering() {\n    var e;\n    (e = this.getBufferingPlayer()) == null || e.resumeBuffering();\n  }\n  pauseBuffering() {\n    var e;\n    (e = this.getBufferingPlayer()) == null || e.pauseBuffering();\n  }\n  destroy() {\n    this.unregisterListeners(), this.stopLoad(), this.assetListLoader &amp;&amp; this.assetListLoader.destroy(), this.emptyPlayerQueue(), this.clearScheduleState(), this.schedule &amp;&amp; this.schedule.destroy(), this.media = this.detachedData = this.mediaSelection = this.requiredTracks = this.altSelection = this.schedule = this.manager = null, this.hls = this.HlsPlayerClass = this.log = null, this.assetListLoader = null, this.onPlay = this.onPause = this.onSeeking = this.onTimeupdate = null, this.onScheduleUpdate = null;\n  }\n  onDestroying() {\n    const e = this.primaryMedia || this.media;\n    e &amp;&amp; this.removeMediaListeners(e);\n  }\n  removeMediaListeners(e) {\n    pr(e, \"play\", this.onPlay), pr(e, \"pause\", this.onPause), pr(e, \"seeking\", this.onSeeking), pr(e, \"timeupdate\", this.onTimeupdate);\n  }\n  onMediaAttaching(e, t) {\n    const r = this.media = t.media;\n    cr(r, \"seeking\", this.onSeeking), cr(r, \"timeupdate\", this.onTimeupdate), cr(r, \"play\", this.onPlay), cr(r, \"pause\", this.onPause);\n  }\n  onMediaAttached(e, t) {\n    const r = this.effectivePlayingItem, n = this.detachedData;\n    if (this.detachedData = null, r === null)\n      this.checkStart();\n    else if (!n) {\n      this.clearScheduleState();\n      const i = this.findItemIndex(r);\n      this.setSchedulePosition(i);\n    }\n  }\n  clearScheduleState() {\n    this.log(\"clear schedule state\"), this.playingItem = this.bufferingItem = this.waitingItem = this.endedItem = this.playingAsset = this.endedAsset = this.bufferingAsset = null;\n  }\n  onMediaDetaching(e, t) {\n    const r = !!t.transferMedia, n = this.media;\n    if (this.media = null, !r &amp;&amp; (n &amp;&amp; this.removeMediaListeners(n), this.detachedData)) {\n      const i = this.getBufferingPlayer();\n      i &amp;&amp; (this.log(`Removing schedule state for detachedData and ${i}`), this.playingAsset = this.endedAsset = this.bufferingAsset = this.bufferingItem = this.waitingItem = this.detachedData = null, i.detachMedia()), this.shouldPlay = !1;\n    }\n  }\n  get interstitialsManager() {\n    if (!this.hls)\n      return null;\n    if (this.manager)\n      return this.manager;\n    const e = this, t = () =&gt; e.bufferingItem || e.waitingItem, r = (d) =&gt; d &amp;&amp; e.getAssetPlayer(d.identifier), n = (d, h, f, p, y) =&gt; {\n      if (d) {\n        let E = d[h].start;\n        const b = d.event;\n        if (b) {\n          if (h === \"playout\" || b.timelineOccupancy !== ia.Point) {\n            const R = r(f);\n            (R == null ? void 0 : R.interstitial) === b &amp;&amp; (E += R.assetItem.startOffset + R[y]);\n          }\n        } else {\n          const R = p === \"bufferedPos\" ? o() : e[p];\n          E += R - d.start;\n        }\n        return E;\n      }\n      return 0;\n    }, i = (d, h) =&gt; {\n      var f;\n      if (d !== 0 &amp;&amp; h !== \"primary\" &amp;&amp; (f = e.schedule) != null &amp;&amp; f.length) {\n        var p;\n        const y = e.schedule.findItemIndexAtTime(d), E = (p = e.schedule.items) == null ? void 0 : p[y];\n        if (E) {\n          const b = E[h].start - E.start;\n          return d + b;\n        }\n      }\n      return d;\n    }, o = () =&gt; {\n      const d = e.bufferedPos;\n      return d === Number.MAX_VALUE ? a(\"primary\") : Math.max(d, 0);\n    }, a = (d) =&gt; {\n      var h, f;\n      return (h = e.primaryDetails) != null &amp;&amp; h.live ? e.primaryDetails.edge : ((f = e.schedule) == null ? void 0 : f.durations[d]) || 0;\n    }, l = (d, h) =&gt; {\n      var f, p;\n      const y = e.effectivePlayingItem;\n      if (y != null &amp;&amp; (f = y.event) != null &amp;&amp; f.restrictions.skip || !e.schedule)\n        return;\n      e.log(`seek to ${d} \"${h}\"`);\n      const E = e.effectivePlayingItem, b = e.schedule.findItemIndexAtTime(d, h), R = (p = e.schedule.items) == null ? void 0 : p[b], A = e.getBufferingPlayer(), F = A == null ? void 0 : A.interstitial, M = F == null ? void 0 : F.appendInPlace, H = E &amp;&amp; e.itemsMatch(E, R);\n      if (E &amp;&amp; (M || H)) {\n        const K = r(e.playingAsset), j = (K == null ? void 0 : K.media) || e.primaryMedia;\n        if (j) {\n          const C = h === \"primary\" ? j.currentTime : n(E, h, e.playingAsset, \"timelinePos\", \"currentTime\"), k = d - C, $ = (M ? C : j.currentTime) + k;\n          if ($ &gt;= 0 &amp;&amp; (!K || M || $ &lt;= K.duration)) {\n            j.currentTime = $;\n            return;\n          }\n        }\n      }\n      if (R) {\n        let K = d;\n        if (h !== \"primary\") {\n          const C = R[h].start, k = d - C;\n          K = R.start + k;\n        }\n        const j = !e.isInterstitial(R);\n        if ((!e.isInterstitial(E) || E.event.appendInPlace) &amp;&amp; (j || R.event.appendInPlace)) {\n          const C = e.media || (M ? A == null ? void 0 : A.media : null);\n          C &amp;&amp; (C.currentTime = K);\n        } else if (E) {\n          const C = e.findItemIndex(E);\n          if (b &gt; C) {\n            const $ = e.schedule.findJumpRestrictedIndex(C + 1, b);\n            if ($ &gt; C) {\n              e.setSchedulePosition($);\n              return;\n            }\n          }\n          let k = 0;\n          if (j)\n            e.timelinePos = K, e.checkBuffer();\n          else {\n            const $ = R.event.assetList, W = d - (R[h] || R).start;\n            for (let _ = $.length; _--; ) {\n              const g = $[_];\n              if (g.duration &amp;&amp; W &gt;= g.startOffset &amp;&amp; W &lt; g.startOffset + g.duration) {\n                k = _;\n                break;\n              }\n            }\n          }\n          e.setSchedulePosition(b, k);\n        }\n      }\n    }, c = () =&gt; {\n      const d = e.effectivePlayingItem;\n      if (e.isInterstitial(d))\n        return d;\n      const h = t();\n      return e.isInterstitial(h) ? h : null;\n    }, u = {\n      get bufferedEnd() {\n        const d = t(), h = e.bufferingItem;\n        if (h &amp;&amp; h === d) {\n          var f;\n          return n(h, \"playout\", e.bufferingAsset, \"bufferedPos\", \"bufferedEnd\") - h.playout.start || ((f = e.bufferingAsset) == null ? void 0 : f.startOffset) || 0;\n        }\n        return 0;\n      },\n      get currentTime() {\n        const d = c(), h = e.effectivePlayingItem;\n        return h &amp;&amp; h === d ? n(h, \"playout\", e.effectivePlayingAsset, \"timelinePos\", \"currentTime\") - h.playout.start : 0;\n      },\n      set currentTime(d) {\n        const h = c(), f = e.effectivePlayingItem;\n        f &amp;&amp; f === h &amp;&amp; l(d + f.playout.start, \"playout\");\n      },\n      get duration() {\n        const d = c();\n        return d ? d.playout.end - d.playout.start : 0;\n      },\n      get assetPlayers() {\n        var d;\n        const h = (d = c()) == null ? void 0 : d.event.assetList;\n        return h ? h.map((f) =&gt; e.getAssetPlayer(f.identifier)) : [];\n      },\n      get playingIndex() {\n        var d;\n        const h = (d = c()) == null ? void 0 : d.event;\n        return h &amp;&amp; e.effectivePlayingAsset ? h.findAssetIndex(e.effectivePlayingAsset) : -1;\n      },\n      get scheduleItem() {\n        return c();\n      }\n    };\n    return this.manager = {\n      get events() {\n        var d;\n        return ((d = e.schedule) == null || (d = d.events) == null ? void 0 : d.slice(0)) || [];\n      },\n      get schedule() {\n        var d;\n        return ((d = e.schedule) == null || (d = d.items) == null ? void 0 : d.slice(0)) || [];\n      },\n      get interstitialPlayer() {\n        return c() ? u : null;\n      },\n      get playerQueue() {\n        return e.playerQueue.slice(0);\n      },\n      get bufferingAsset() {\n        return e.bufferingAsset;\n      },\n      get bufferingItem() {\n        return t();\n      },\n      get bufferingIndex() {\n        const d = t();\n        return e.findItemIndex(d);\n      },\n      get playingAsset() {\n        return e.effectivePlayingAsset;\n      },\n      get playingItem() {\n        return e.effectivePlayingItem;\n      },\n      get playingIndex() {\n        const d = e.effectivePlayingItem;\n        return e.findItemIndex(d);\n      },\n      primary: {\n        get bufferedEnd() {\n          return o();\n        },\n        get currentTime() {\n          const d = e.timelinePos;\n          return d &gt; 0 ? d : 0;\n        },\n        set currentTime(d) {\n          l(d, \"primary\");\n        },\n        get duration() {\n          return a(\"primary\");\n        },\n        get seekableStart() {\n          var d;\n          return ((d = e.primaryDetails) == null ? void 0 : d.fragmentStart) || 0;\n        }\n      },\n      integrated: {\n        get bufferedEnd() {\n          return n(t(), \"integrated\", e.bufferingAsset, \"bufferedPos\", \"bufferedEnd\");\n        },\n        get currentTime() {\n          return n(e.effectivePlayingItem, \"integrated\", e.effectivePlayingAsset, \"timelinePos\", \"currentTime\");\n        },\n        set currentTime(d) {\n          l(d, \"integrated\");\n        },\n        get duration() {\n          return a(\"integrated\");\n        },\n        get seekableStart() {\n          var d;\n          return i(((d = e.primaryDetails) == null ? void 0 : d.fragmentStart) || 0, \"integrated\");\n        }\n      },\n      skip: () =&gt; {\n        const d = e.effectivePlayingItem, h = d == null ? void 0 : d.event;\n        if (h &amp;&amp; !h.restrictions.skip) {\n          const f = e.findItemIndex(d);\n          if (h.appendInPlace) {\n            const p = d.playout.start + d.event.duration;\n            l(p + 1e-3, \"playout\");\n          } else\n            e.advanceAfterAssetEnded(h, f, 1 / 0);\n        }\n      }\n    };\n  }\n  // Schedule getters\n  get effectivePlayingItem() {\n    return this.waitingItem || this.playingItem || this.endedItem;\n  }\n  get effectivePlayingAsset() {\n    return this.playingAsset || this.endedAsset;\n  }\n  get playingLastItem() {\n    var e;\n    const t = this.playingItem, r = (e = this.schedule) == null ? void 0 : e.items;\n    return !this.playbackStarted || !t || !r ? !1 : this.findItemIndex(t) === r.length - 1;\n  }\n  get playbackStarted() {\n    return this.effectivePlayingItem !== null;\n  }\n  // Media getters and event callbacks\n  get currentTime() {\n    var e, t;\n    if (this.mediaSelection === null)\n      return;\n    const r = this.waitingItem || this.playingItem;\n    if (this.isInterstitial(r) &amp;&amp; !r.event.appendInPlace)\n      return;\n    let n = this.media;\n    !n &amp;&amp; (e = this.bufferingItem) != null &amp;&amp; (e = e.event) != null &amp;&amp; e.appendInPlace &amp;&amp; (n = this.primaryMedia);\n    const i = (t = n) == null ? void 0 : t.currentTime;\n    if (!(i === void 0 || !ue(i)))\n      return i;\n  }\n  get primaryMedia() {\n    var e;\n    return this.media || ((e = this.detachedData) == null ? void 0 : e.media) || null;\n  }\n  isInterstitial(e) {\n    return !!(e != null &amp;&amp; e.event);\n  }\n  retreiveMediaSource(e, t) {\n    const r = this.getAssetPlayer(e);\n    r &amp;&amp; this.transferMediaFromPlayer(r, t);\n  }\n  transferMediaFromPlayer(e, t) {\n    const r = e.interstitial.appendInPlace, n = e.media;\n    if (r &amp;&amp; n === this.primaryMedia) {\n      if (this.bufferingAsset = null, (!t || this.isInterstitial(t) &amp;&amp; !t.event.appendInPlace) &amp;&amp; t &amp;&amp; n) {\n        this.detachedData = {\n          media: n\n        };\n        return;\n      }\n      const i = e.transferMedia();\n      this.log(`transfer MediaSource from ${e} ${at(i)}`), this.detachedData = i;\n    } else t &amp;&amp; n &amp;&amp; (this.shouldPlay || (this.shouldPlay = !n.paused));\n  }\n  transferMediaTo(e, t) {\n    var r, n;\n    if (e.media === t)\n      return;\n    let i = null;\n    const o = this.hls, a = e !== o, l = a &amp;&amp; e.interstitial.appendInPlace, c = (r = this.detachedData) == null ? void 0 : r.mediaSource;\n    let u;\n    if (o.media)\n      l &amp;&amp; (i = o.transferMedia(), this.detachedData = i), u = \"Primary\";\n    else if (c) {\n      const p = this.getBufferingPlayer();\n      p ? (i = p.transferMedia(), u = `${p}`) : u = \"detached MediaSource\";\n    } else\n      u = \"detached media\";\n    if (!i) {\n      if (c)\n        i = this.detachedData, this.log(`using detachedData: MediaSource ${at(i)}`);\n      else if (!this.detachedData || o.media === t) {\n        const p = this.playerQueue;\n        p.length &gt; 1 &amp;&amp; p.forEach((y) =&gt; {\n          if (a &amp;&amp; y.interstitial.appendInPlace !== l) {\n            const E = y.interstitial;\n            this.clearInterstitial(y.interstitial, null), E.appendInPlace = !1, E.appendInPlace &amp;&amp; this.warn(`Could not change append strategy for queued assets ${E}`);\n          }\n        }), this.hls.detachMedia(), this.detachedData = {\n          media: t\n        };\n      }\n    }\n    const d = i &amp;&amp; \"mediaSource\" in i &amp;&amp; ((n = i.mediaSource) == null ? void 0 : n.readyState) !== \"closed\", h = d &amp;&amp; i ? i : t;\n    this.log(`${d ? \"transfering MediaSource\" : \"attaching media\"} to ${a ? e : \"Primary\"} from ${u} (media.currentTime: ${t.currentTime})`);\n    const f = this.schedule;\n    if (h === i &amp;&amp; f) {\n      const p = a &amp;&amp; e.assetId === f.assetIdAtEnd;\n      h.overrides = {\n        duration: f.duration,\n        endOfStream: !a || p,\n        cueRemoval: !a\n      };\n    }\n    e.attachMedia(h);\n  }\n  onInterstitialCueEnter() {\n    this.onTimeupdate();\n  }\n  // Scheduling methods\n  checkStart() {\n    const e = this.schedule, t = e == null ? void 0 : e.events;\n    if (!t || this.playbackDisabled || !this.media)\n      return;\n    this.bufferedPos === -1 &amp;&amp; (this.bufferedPos = 0);\n    const r = this.timelinePos, n = this.effectivePlayingItem;\n    if (r === -1) {\n      const i = this.hls.startPosition;\n      if (this.log(Qi(\"checkStart\", i)), this.timelinePos = i, t.length &amp;&amp; t[0].cue.pre) {\n        const o = e.findEventIndex(t[0].identifier);\n        this.setSchedulePosition(o);\n      } else if (i &gt;= 0 || !this.primaryLive) {\n        const o = this.timelinePos = i &gt; 0 ? i : 0, a = e.findItemIndexAtTime(o);\n        this.setSchedulePosition(a);\n      }\n    } else if (n &amp;&amp; !this.playingItem) {\n      const i = e.findItemIndex(n);\n      this.setSchedulePosition(i);\n    }\n  }\n  advanceAssetBuffering(e, t) {\n    const r = e.event, n = r.findAssetIndex(t), i = Tl(r, n);\n    if (!r.isAssetPastPlayoutLimit(i))\n      this.bufferedToEvent(e, i);\n    else if (this.schedule) {\n      var o;\n      const a = (o = this.schedule.items) == null ? void 0 : o[this.findItemIndex(e) + 1];\n      a &amp;&amp; this.bufferedToItem(a);\n    }\n  }\n  advanceAfterAssetEnded(e, t, r) {\n    const n = Tl(e, r);\n    if (e.isAssetPastPlayoutLimit(n)) {\n      if (this.schedule) {\n        const i = this.schedule.items;\n        if (i) {\n          const o = t + 1, a = i.length;\n          if (o &gt;= a) {\n            this.setSchedulePosition(-1);\n            return;\n          }\n          const l = e.resumeTime;\n          this.timelinePos &lt; l &amp;&amp; (this.log(Qi(\"advanceAfterAssetEnded\", l)), this.timelinePos = l, e.appendInPlace &amp;&amp; this.advanceInPlace(l), this.checkBuffer(this.bufferedPos &lt; l)), this.setSchedulePosition(o);\n        }\n      }\n    } else {\n      if (e.appendInPlace) {\n        const i = e.assetList[n];\n        i &amp;&amp; this.advanceInPlace(i.timelineStart);\n      }\n      this.setSchedulePosition(t, n);\n    }\n  }\n  setScheduleToAssetAtTime(e, t) {\n    const r = this.schedule;\n    if (!r)\n      return;\n    const n = t.parentIdentifier, i = r.getEvent(n);\n    if (i) {\n      const o = r.findEventIndex(n), a = r.findAssetIndex(i, e);\n      this.advanceAfterAssetEnded(i, o, a - 1);\n    }\n  }\n  setSchedulePosition(e, t) {\n    var r;\n    const n = (r = this.schedule) == null ? void 0 : r.items;\n    if (!n || this.playbackDisabled)\n      return;\n    const i = e &gt;= 0 ? n[e] : null;\n    this.log(`setSchedulePosition ${e}, ${t} (${i &amp;&amp; kr(i)}) pos: ${this.timelinePos}`);\n    const o = this.waitingItem || this.playingItem, a = this.playingLastItem;\n    if (this.isInterstitial(o)) {\n      const u = o.event, d = this.playingAsset, h = d == null ? void 0 : d.identifier, f = h ? this.getAssetPlayer(h) : null;\n      if (f &amp;&amp; h &amp;&amp; (!this.eventItemsMatch(o, i) || t !== void 0 &amp;&amp; h !== u.assetList[t].identifier)) {\n        var l;\n        const p = u.findAssetIndex(d);\n        if (this.log(`INTERSTITIAL_ASSET_ENDED ${p + 1}/${u.assetList.length} ${vn(d)}`), this.endedAsset = d, this.playingAsset = null, this.hls.trigger(I.INTERSTITIAL_ASSET_ENDED, {\n          asset: d,\n          assetListIndex: p,\n          event: u,\n          schedule: n.slice(0),\n          scheduleIndex: e,\n          player: f\n        }), o !== this.playingItem) {\n          this.itemsMatch(o, this.playingItem) &amp;&amp; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          !this.playingAsset &amp;&amp; this.advanceAfterAssetEnded(u, this.findItemIndex(this.playingItem), p);\n          return;\n        }\n        this.retreiveMediaSource(h, i), f.media &amp;&amp; !((l = this.detachedData) != null &amp;&amp; l.mediaSource) &amp;&amp; f.detachMedia();\n      }\n      if (!this.eventItemsMatch(o, i) &amp;&amp; (this.endedItem = o, this.playingItem = null, this.log(`INTERSTITIAL_ENDED ${u} ${kr(o)}`), u.hasPlayed = !0, this.hls.trigger(I.INTERSTITIAL_ENDED, {\n        event: u,\n        schedule: n.slice(0),\n        scheduleIndex: e\n      }), u.cue.once)) {\n        var c;\n        this.updateSchedule();\n        const p = (c = this.schedule) == null ? void 0 : c.items;\n        if (i &amp;&amp; p) {\n          const y = this.findItemIndex(i);\n          this.advanceSchedule(y, p, t, o, a);\n        }\n        return;\n      }\n    }\n    this.advanceSchedule(e, n, t, o, a);\n  }\n  advanceSchedule(e, t, r, n, i) {\n    const o = this.schedule;\n    if (!o)\n      return;\n    const a = t[e] || null, l = this.primaryMedia, c = this.playerQueue;\n    if (c.length &amp;&amp; c.forEach((u) =&gt; {\n      const d = u.interstitial, h = o.findEventIndex(d.identifier);\n      (h &lt; e || h &gt; e + 1) &amp;&amp; this.clearInterstitial(d, a);\n    }), this.isInterstitial(a)) {\n      this.timelinePos = Math.min(Math.max(this.timelinePos, a.start), a.end);\n      const u = a.event;\n      if (r === void 0) {\n        r = o.findAssetIndex(u, this.timelinePos);\n        const p = Tl(u, r - 1);\n        if (u.isAssetPastPlayoutLimit(p) || u.appendInPlace &amp;&amp; this.timelinePos === a.end) {\n          this.advanceAfterAssetEnded(u, e, r);\n          return;\n        }\n        r = p;\n      }\n      const d = this.waitingItem;\n      this.assetsBuffered(a, l) || this.setBufferingItem(a);\n      let h = this.preloadAssets(u, r);\n      if (this.eventItemsMatch(a, d || n) || (this.waitingItem = a, this.log(`INTERSTITIAL_STARTED ${kr(a)} ${u.appendInPlace ? \"append in place\" : \"\"}`), this.hls.trigger(I.INTERSTITIAL_STARTED, {\n        event: u,\n        schedule: t.slice(0),\n        scheduleIndex: e\n      })), !u.assetListLoaded) {\n        this.log(`Waiting for ASSET-LIST to complete loading ${u}`);\n        return;\n      }\n      if (u.assetListLoader &amp;&amp; (u.assetListLoader.destroy(), u.assetListLoader = void 0), !l) {\n        this.log(`Waiting for attachMedia to start Interstitial ${u}`);\n        return;\n      }\n      this.waitingItem = this.endedItem = null, this.playingItem = a;\n      const f = u.assetList[r];\n      if (!f) {\n        this.advanceAfterAssetEnded(u, e, r || 0);\n        return;\n      }\n      if (h || (h = this.getAssetPlayer(f.identifier)), h === null || h.destroyed) {\n        const p = u.assetList.length;\n        this.warn(`asset ${r + 1}/${p} player destroyed ${u}`), h = this.createAssetPlayer(u, f, r), h.loadSource();\n      }\n      if (!this.eventItemsMatch(a, this.bufferingItem) &amp;&amp; u.appendInPlace &amp;&amp; this.isAssetBuffered(f))\n        return;\n      this.startAssetPlayer(h, r, t, e, l), this.shouldPlay &amp;&amp; Jh(h.media);\n    } else a ? (this.resumePrimary(a, e, n), this.shouldPlay &amp;&amp; Jh(this.hls.media)) : i &amp;&amp; this.isInterstitial(n) &amp;&amp; (this.endedItem = null, this.playingItem = n, n.event.appendInPlace || this.attachPrimary(o.durations.primary, null));\n  }\n  get playbackDisabled() {\n    return this.hls.config.enableInterstitialPlayback === !1;\n  }\n  get primaryDetails() {\n    var e;\n    return (e = this.mediaSelection) == null ? void 0 : e.main.details;\n  }\n  get primaryLive() {\n    var e;\n    return !!((e = this.primaryDetails) != null &amp;&amp; e.live);\n  }\n  resumePrimary(e, t, r) {\n    var n, i;\n    if (this.playingItem = e, this.playingAsset = this.endedAsset = null, this.waitingItem = this.endedItem = null, this.bufferedToItem(e), this.log(`resuming ${kr(e)}`), !((n = this.detachedData) != null &amp;&amp; n.mediaSource)) {\n      let a = this.timelinePos;\n      (a &lt; e.start || a &gt;= e.end) &amp;&amp; (a = this.getPrimaryResumption(e, t), this.log(Qi(\"resumePrimary\", a)), this.timelinePos = a), this.attachPrimary(a, e);\n    }\n    if (!r)\n      return;\n    const o = (i = this.schedule) == null ? void 0 : i.items;\n    o &amp;&amp; (this.log(`INTERSTITIALS_PRIMARY_RESUMED ${kr(e)}`), this.hls.trigger(I.INTERSTITIALS_PRIMARY_RESUMED, {\n      schedule: o.slice(0),\n      scheduleIndex: t\n    }), this.checkBuffer());\n  }\n  getPrimaryResumption(e, t) {\n    const r = e.start;\n    if (this.primaryLive) {\n      const n = this.primaryDetails;\n      if (t === 0)\n        return this.hls.startPosition;\n      if (n &amp;&amp; (r &lt; n.fragmentStart || r &gt; n.edge))\n        return this.hls.liveSyncPosition || -1;\n    }\n    return r;\n  }\n  isAssetBuffered(e) {\n    const t = this.getAssetPlayer(e.identifier);\n    return t != null &amp;&amp; t.hls ? t.hls.bufferedToEnd : Ce.bufferInfo(this.primaryMedia, this.timelinePos, 0).end + 1 &gt;= e.timelineStart + (e.duration || 0);\n  }\n  attachPrimary(e, t, r) {\n    t ? this.setBufferingItem(t) : this.bufferingItem = this.playingItem, this.bufferingAsset = null;\n    const n = this.primaryMedia;\n    if (!n)\n      return;\n    const i = this.hls;\n    i.media ? this.checkBuffer() : (this.transferMediaTo(i, n), r &amp;&amp; this.startLoadingPrimaryAt(e, r)), r || (this.log(Qi(\"attachPrimary\", e)), this.timelinePos = e, this.startLoadingPrimaryAt(e, r));\n  }\n  startLoadingPrimaryAt(e, t) {\n    var r;\n    const n = this.hls;\n    !n.loadingEnabled || !n.media || Math.abs((((r = n.mainForwardBufferInfo) == null ? void 0 : r.start) || n.media.currentTime) - e) &gt; 0.5 ? n.startLoad(e, t) : n.bufferingEnabled || n.resumeBuffering();\n  }\n  // HLS.js event callbacks\n  onManifestLoading() {\n    var e;\n    this.stopLoad(), (e = this.schedule) == null || e.reset(), this.emptyPlayerQueue(), this.clearScheduleState(), this.shouldPlay = !1, this.bufferedPos = this.timelinePos = -1, this.mediaSelection = this.altSelection = this.manager = this.requiredTracks = null, this.hls.off(I.BUFFER_CODECS, this.onBufferCodecs, this), this.hls.on(I.BUFFER_CODECS, this.onBufferCodecs, this);\n  }\n  onLevelUpdated(e, t) {\n    if (t.level === -1 || !this.schedule)\n      return;\n    const r = this.hls.levels[t.level];\n    if (!r.details)\n      return;\n    const n = tt(tt({}, this.mediaSelection || this.altSelection), {}, {\n      main: r\n    });\n    this.mediaSelection = n, this.schedule.parseInterstitialDateRanges(n, this.hls.config.interstitialAppendInPlace), !this.effectivePlayingItem &amp;&amp; this.schedule.items &amp;&amp; this.checkStart();\n  }\n  onAudioTrackUpdated(e, t) {\n    const r = this.hls.audioTracks[t.id], n = this.mediaSelection;\n    if (!n) {\n      this.altSelection = tt(tt({}, this.altSelection), {}, {\n        audio: r\n      });\n      return;\n    }\n    const i = tt(tt({}, n), {}, {\n      audio: r\n    });\n    this.mediaSelection = i;\n  }\n  onSubtitleTrackUpdated(e, t) {\n    const r = this.hls.subtitleTracks[t.id], n = this.mediaSelection;\n    if (!n) {\n      this.altSelection = tt(tt({}, this.altSelection), {}, {\n        subtitles: r\n      });\n      return;\n    }\n    const i = tt(tt({}, n), {}, {\n      subtitles: r\n    });\n    this.mediaSelection = i;\n  }\n  onAudioTrackSwitching(e, t) {\n    const r = ch(t);\n    this.playerQueue.forEach(({\n      hls: n\n    }) =&gt; n &amp;&amp; (n.setAudioOption(t) || n.setAudioOption(r)));\n  }\n  onSubtitleTrackSwitch(e, t) {\n    const r = ch(t);\n    this.playerQueue.forEach(({\n      hls: n\n    }) =&gt; n &amp;&amp; (n.setSubtitleOption(t) || t.id !== -1 &amp;&amp; n.setSubtitleOption(r)));\n  }\n  onBufferCodecs(e, t) {\n    const r = t.tracks;\n    r &amp;&amp; (this.requiredTracks = r);\n  }\n  onBufferAppended(e, t) {\n    this.checkBuffer();\n  }\n  onBufferFlushed(e, t) {\n    const r = this.playingItem;\n    if (r &amp;&amp; !this.itemsMatch(r, this.bufferingItem) &amp;&amp; !this.isInterstitial(r)) {\n      const n = this.timelinePos;\n      this.bufferedPos = n, this.checkBuffer();\n    }\n  }\n  onBufferedToEnd(e) {\n    if (!this.schedule)\n      return;\n    const t = this.schedule.events;\n    if (this.bufferedPos &lt; Number.MAX_VALUE &amp;&amp; t) {\n      for (let n = 0; n &lt; t.length; n++) {\n        const i = t[n];\n        if (i.cue.post) {\n          var r;\n          const o = this.schedule.findEventIndex(i.identifier), a = (r = this.schedule.items) == null ? void 0 : r[o];\n          this.isInterstitial(a) &amp;&amp; this.eventItemsMatch(a, this.bufferingItem) &amp;&amp; this.bufferedToItem(a, 0);\n          break;\n        }\n      }\n      this.bufferedPos = Number.MAX_VALUE;\n    }\n  }\n  onMediaEnded(e) {\n    const t = this.playingItem;\n    if (!this.playingLastItem &amp;&amp; t) {\n      const r = this.findItemIndex(t);\n      this.setSchedulePosition(r + 1);\n    } else\n      this.shouldPlay = !1;\n  }\n  updateItem(e, t) {\n    var r;\n    const n = (r = this.schedule) == null ? void 0 : r.items;\n    if (e &amp;&amp; n) {\n      const i = this.findItemIndex(e, t);\n      return n[i] || null;\n    }\n    return null;\n  }\n  trimInPlace(e, t) {\n    if (this.isInterstitial(e) &amp;&amp; e.event.appendInPlace &amp;&amp; t.end - e.end &gt; 0.25) {\n      e.event.assetList.forEach((i, o) =&gt; {\n        e.event.isAssetPastPlayoutLimit(o) &amp;&amp; this.clearAssetPlayer(i.identifier, null);\n      });\n      const r = e.end + 0.25, n = Ce.bufferInfo(this.primaryMedia, r, 0);\n      (n.end &gt; r || (n.nextStart || 0) &gt; r) &amp;&amp; (this.log(`trim buffered interstitial ${kr(e)} (was ${kr(t)})`), this.attachPrimary(r, null, !0), this.flushFrontBuffer(r));\n    }\n  }\n  itemsMatch(e, t) {\n    return !!t &amp;&amp; (e === t || e.event &amp;&amp; t.event &amp;&amp; this.eventItemsMatch(e, t) || !e.event &amp;&amp; !t.event &amp;&amp; this.findItemIndex(e) === this.findItemIndex(t));\n  }\n  eventItemsMatch(e, t) {\n    var r;\n    return !!t &amp;&amp; (e === t || e.event.identifier === ((r = t.event) == null ? void 0 : r.identifier));\n  }\n  findItemIndex(e, t) {\n    return e &amp;&amp; this.schedule ? this.schedule.findItemIndex(e, t) : -1;\n  }\n  updateSchedule(e = !1) {\n    var t;\n    const r = this.mediaSelection;\n    r &amp;&amp; ((t = this.schedule) == null || t.updateSchedule(r, [], e));\n  }\n  // Schedule buffer control\n  checkBuffer(e) {\n    var t;\n    const r = (t = this.schedule) == null ? void 0 : t.items;\n    if (!r)\n      return;\n    const n = Ce.bufferInfo(this.primaryMedia, this.timelinePos, 0);\n    e &amp;&amp; (this.bufferedPos = this.timelinePos), e || (e = n.len &lt; 1), this.updateBufferedPos(n.end, r, e);\n  }\n  updateBufferedPos(e, t, r) {\n    const n = this.schedule, i = this.bufferingItem;\n    if (this.bufferedPos &gt; e || !n)\n      return;\n    if (t.length === 1 &amp;&amp; this.itemsMatch(t[0], i)) {\n      this.bufferedPos = e;\n      return;\n    }\n    const o = this.playingItem, a = this.findItemIndex(o);\n    let l = n.findItemIndexAtTime(e);\n    if (this.bufferedPos &lt; e) {\n      var c;\n      const u = this.findItemIndex(i), d = Math.min(u + 1, t.length - 1), h = t[d];\n      if ((l === -1 &amp;&amp; i &amp;&amp; e &gt;= i.end || (c = h.event) != null &amp;&amp; c.appendInPlace &amp;&amp; e + 0.01 &gt;= h.start) &amp;&amp; (l = d), this.isInterstitial(i)) {\n        const f = i.event;\n        if (d - a &gt; 1 &amp;&amp; f.appendInPlace === !1 || f.assetList.length === 0 &amp;&amp; f.assetListLoader)\n          return;\n      }\n      if (this.bufferedPos = e, l &gt; u &amp;&amp; l &gt; a)\n        this.bufferedToItem(h);\n      else {\n        const f = this.primaryDetails;\n        this.primaryLive &amp;&amp; f &amp;&amp; e &gt; f.edge - f.targetduration &amp;&amp; h.start &lt; f.edge + this.hls.config.interstitialLiveLookAhead &amp;&amp; this.isInterstitial(h) &amp;&amp; this.preloadAssets(h.event, 0);\n      }\n    } else r &amp;&amp; o &amp;&amp; !this.itemsMatch(o, i) &amp;&amp; (l === a ? this.bufferedToItem(o) : l === a + 1 &amp;&amp; this.bufferedToItem(t[l]));\n  }\n  assetsBuffered(e, t) {\n    return e.event.assetList.length === 0 ? !1 : !e.event.assetList.some((n) =&gt; {\n      const i = this.getAssetPlayer(n.identifier);\n      return !(i != null &amp;&amp; i.bufferedInPlaceToEnd(t));\n    });\n  }\n  setBufferingItem(e) {\n    const t = this.bufferingItem, r = this.schedule;\n    if (!this.itemsMatch(e, t) &amp;&amp; r) {\n      const {\n        items: n,\n        events: i\n      } = r;\n      if (!n || !i)\n        return t;\n      const o = this.isInterstitial(e), a = this.getBufferingPlayer();\n      this.bufferingItem = e, this.bufferedPos = Math.max(e.start, Math.min(e.end, this.timelinePos));\n      const l = a ? a.remaining : t ? t.end - this.timelinePos : 0;\n      if (this.log(`INTERSTITIALS_BUFFERED_TO_BOUNDARY ${kr(e)}` + (t ? ` (${l.toFixed(2)} remaining)` : \"\")), !this.playbackDisabled)\n        if (o) {\n          const c = r.findAssetIndex(e.event, this.bufferedPos);\n          e.event.assetList.forEach((u, d) =&gt; {\n            const h = this.getAssetPlayer(u.identifier);\n            h &amp;&amp; (d === c &amp;&amp; h.loadSource(), h.resumeBuffering());\n          });\n        } else\n          this.hls.resumeBuffering(), this.playerQueue.forEach((c) =&gt; c.pauseBuffering());\n      this.hls.trigger(I.INTERSTITIALS_BUFFERED_TO_BOUNDARY, {\n        events: i.slice(0),\n        schedule: n.slice(0),\n        bufferingIndex: this.findItemIndex(e),\n        playingIndex: this.findItemIndex(this.playingItem)\n      });\n    } else this.bufferingItem !== e &amp;&amp; (this.bufferingItem = e);\n    return t;\n  }\n  bufferedToItem(e, t = 0) {\n    const r = this.setBufferingItem(e);\n    if (!this.playbackDisabled) {\n      if (this.isInterstitial(e))\n        this.bufferedToEvent(e, t);\n      else if (r !== null) {\n        this.bufferingAsset = null;\n        const n = this.detachedData;\n        n ? n.mediaSource ? this.attachPrimary(e.start, e, !0) : this.preloadPrimary(e) : this.preloadPrimary(e);\n      }\n    }\n  }\n  preloadPrimary(e) {\n    const t = this.findItemIndex(e), r = this.getPrimaryResumption(e, t);\n    this.startLoadingPrimaryAt(r);\n  }\n  bufferedToEvent(e, t) {\n    const r = e.event, n = r.assetList.length === 0 &amp;&amp; !r.assetListLoader, i = r.cue.once;\n    if (n || !i) {\n      const o = this.preloadAssets(r, t);\n      if (o != null &amp;&amp; o.interstitial.appendInPlace) {\n        const a = this.primaryMedia;\n        a &amp;&amp; this.bufferAssetPlayer(o, a);\n      }\n    }\n  }\n  preloadAssets(e, t) {\n    const r = e.assetUrl, n = e.assetList.length, i = n === 0 &amp;&amp; !e.assetListLoader, o = e.cue.once;\n    if (i) {\n      const l = e.timelineStart;\n      if (e.appendInPlace) {\n        var a;\n        const h = this.playingItem;\n        !this.isInterstitial(h) &amp;&amp; (h == null || (a = h.nextEvent) == null ? void 0 : a.identifier) === e.identifier &amp;&amp; this.flushFrontBuffer(l + 0.25);\n      }\n      let c, u = 0;\n      if (!this.playingItem &amp;&amp; this.primaryLive &amp;&amp; (u = this.hls.startPosition, u === -1 &amp;&amp; (u = this.hls.liveSyncPosition || 0)), u &amp;&amp; !(e.cue.pre || e.cue.post)) {\n        const h = u - l;\n        h &gt; 0 &amp;&amp; (c = Math.round(h * 1e3) / 1e3);\n      }\n      if (this.log(`Load interstitial asset ${t + 1}/${r ? 1 : n} ${e}${c ? ` live-start: ${u} start-offset: ${c}` : \"\"}`), r)\n        return this.createAsset(e, 0, 0, l, e.duration, r);\n      const d = this.assetListLoader.loadAssetList(e, c);\n      d &amp;&amp; (e.assetListLoader = d);\n    } else if (!o &amp;&amp; n) {\n      for (let c = t; c &lt; n; c++) {\n        const u = e.assetList[c], d = this.getAssetPlayerQueueIndex(u.identifier);\n        (d === -1 || this.playerQueue[d].destroyed) &amp;&amp; !u.error &amp;&amp; this.createAssetPlayer(e, u, c);\n      }\n      const l = e.assetList[t];\n      if (l) {\n        const c = this.getAssetPlayer(l.identifier);\n        return c &amp;&amp; c.loadSource(), c;\n      }\n    }\n    return null;\n  }\n  flushFrontBuffer(e) {\n    const t = this.requiredTracks;\n    if (!t)\n      return;\n    this.log(`Removing front buffer starting at ${e}`), Object.keys(t).forEach((n) =&gt; {\n      this.hls.trigger(I.BUFFER_FLUSHING, {\n        startOffset: e,\n        endOffset: 1 / 0,\n        type: n\n      });\n    });\n  }\n  // Interstitial Asset Player control\n  getAssetPlayerQueueIndex(e) {\n    const t = this.playerQueue;\n    for (let r = 0; r &lt; t.length; r++)\n      if (e === t[r].assetId)\n        return r;\n    return -1;\n  }\n  getAssetPlayer(e) {\n    const t = this.getAssetPlayerQueueIndex(e);\n    return this.playerQueue[t] || null;\n  }\n  getBufferingPlayer() {\n    const {\n      playerQueue: e,\n      primaryMedia: t\n    } = this;\n    if (t) {\n      for (let r = 0; r &lt; e.length; r++)\n        if (e[r].media === t)\n          return e[r];\n    }\n    return null;\n  }\n  createAsset(e, t, r, n, i, o) {\n    const a = {\n      parentIdentifier: e.identifier,\n      identifier: gw(e, o, t),\n      duration: i,\n      startOffset: r,\n      timelineStart: n,\n      uri: o\n    };\n    return this.createAssetPlayer(e, a, t);\n  }\n  createAssetPlayer(e, t, r) {\n    const n = this.hls, i = n.userConfig;\n    let o = i.videoPreference;\n    const a = n.loadLevelObj || n.levels[n.currentLevel];\n    (o || a) &amp;&amp; (o = nt({}, o), a.videoCodec &amp;&amp; (o.videoCodec = a.videoCodec), a.videoRange &amp;&amp; (o.allowedVideoRanges = [a.videoRange]));\n    const l = n.audioTracks[n.audioTrack], c = n.subtitleTracks[n.subtitleTrack];\n    let u = 0;\n    if (this.primaryLive || e.appendInPlace) {\n      const F = this.timelinePos - t.timelineStart;\n      if (F &gt; 1) {\n        const M = t.duration;\n        M &amp;&amp; F &lt; M &amp;&amp; (u = F);\n      }\n    }\n    const d = t.identifier, h = tt(tt({}, i), {}, {\n      maxMaxBufferLength: Math.min(180, n.config.maxMaxBufferLength),\n      autoStartLoad: !0,\n      startFragPrefetch: !0,\n      primarySessionId: n.sessionId,\n      assetPlayerId: d,\n      abrEwmaDefaultEstimate: n.bandwidthEstimate,\n      interstitialsController: void 0,\n      startPosition: u,\n      liveDurationInfinity: !1,\n      testBandwidth: !1,\n      videoPreference: o,\n      audioPreference: l || i.audioPreference,\n      subtitlePreference: c || i.subtitlePreference\n    });\n    e.appendInPlace &amp;&amp; (e.appendInPlaceStarted = !0, t.timelineStart &amp;&amp; (h.timelineOffset = t.timelineStart));\n    const f = h.cmcd;\n    f != null &amp;&amp; f.sessionId &amp;&amp; f.contentId &amp;&amp; (h.cmcd = nt({}, f, {\n      contentId: Xn(t.uri)\n    })), this.getAssetPlayer(d) &amp;&amp; this.warn(`Duplicate date range identifier ${e} and asset ${d}`);\n    const p = new yw(this.HlsPlayerClass, h, e, t);\n    this.playerQueue.push(p), e.assetList[r] = t;\n    let y = !0;\n    const E = (F) =&gt; {\n      if (F.live) {\n        var M;\n        const j = new Error(`Interstitials MUST be VOD assets ${e}`), C = {\n          fatal: !0,\n          type: ve.OTHER_ERROR,\n          details: J.INTERSTITIAL_ASSET_ITEM_ERROR,\n          error: j\n        }, k = ((M = this.schedule) == null ? void 0 : M.findEventIndex(e.identifier)) || -1;\n        this.handleAssetItemError(C, e, k, r, j.message);\n        return;\n      }\n      const H = F.edge - F.fragmentStart, K = t.duration;\n      (y || K === null || H &gt; K) &amp;&amp; (y = !1, this.log(`Interstitial asset \"${d}\" duration change ${K} &gt; ${H}`), t.duration = H, this.updateSchedule());\n    };\n    p.on(I.LEVEL_UPDATED, (F, {\n      details: M\n    }) =&gt; E(M)), p.on(I.LEVEL_PTS_UPDATED, (F, {\n      details: M\n    }) =&gt; E(M)), p.on(I.EVENT_CUE_ENTER, () =&gt; this.onInterstitialCueEnter());\n    const b = (F, M) =&gt; {\n      const H = this.getAssetPlayer(d);\n      if (H &amp;&amp; M.tracks) {\n        H.off(I.BUFFER_CODECS, b), H.tracks = M.tracks;\n        const K = this.primaryMedia;\n        this.bufferingAsset === H.assetItem &amp;&amp; K &amp;&amp; !H.media &amp;&amp; this.bufferAssetPlayer(H, K);\n      }\n    };\n    p.on(I.BUFFER_CODECS, b);\n    const R = () =&gt; {\n      var F;\n      const M = this.getAssetPlayer(d);\n      if (this.log(`buffered to end of asset ${M}`), !M || !this.schedule)\n        return;\n      const H = this.schedule.findEventIndex(e.identifier), K = (F = this.schedule.items) == null ? void 0 : F[H];\n      this.isInterstitial(K) &amp;&amp; this.advanceAssetBuffering(K, t);\n    };\n    p.on(I.BUFFERED_TO_END, R);\n    const A = (F) =&gt; () =&gt; {\n      if (!this.getAssetPlayer(d) || !this.schedule)\n        return;\n      this.shouldPlay = !0;\n      const H = this.schedule.findEventIndex(e.identifier);\n      this.advanceAfterAssetEnded(e, H, F);\n    };\n    return p.once(I.MEDIA_ENDED, A(r)), p.once(I.PLAYOUT_LIMIT_REACHED, A(1 / 0)), p.on(I.ERROR, (F, M) =&gt; {\n      if (!this.schedule)\n        return;\n      const H = this.getAssetPlayer(d);\n      if (M.details === J.BUFFER_STALLED_ERROR) {\n        if (H != null &amp;&amp; H.appendInPlace) {\n          this.handleInPlaceStall(e);\n          return;\n        }\n        this.onTimeupdate(), this.checkBuffer(!0);\n        return;\n      }\n      this.handleAssetItemError(M, e, this.schedule.findEventIndex(e.identifier), r, `Asset player error ${M.error} ${e}`);\n    }), p.on(I.DESTROYING, () =&gt; {\n      if (!this.getAssetPlayer(d) || !this.schedule)\n        return;\n      const M = new Error(`Asset player destroyed unexpectedly ${d}`), H = {\n        fatal: !0,\n        type: ve.OTHER_ERROR,\n        details: J.INTERSTITIAL_ASSET_ITEM_ERROR,\n        error: M\n      };\n      this.handleAssetItemError(H, e, this.schedule.findEventIndex(e.identifier), r, M.message);\n    }), this.log(`INTERSTITIAL_ASSET_PLAYER_CREATED ${vn(t)}`), this.hls.trigger(I.INTERSTITIAL_ASSET_PLAYER_CREATED, {\n      asset: t,\n      assetListIndex: r,\n      event: e,\n      player: p\n    }), p;\n  }\n  clearInterstitial(e, t) {\n    e.assetList.forEach((r) =&gt; {\n      this.clearAssetPlayer(r.identifier, t);\n    }), e.reset();\n  }\n  resetAssetPlayer(e) {\n    const t = this.getAssetPlayerQueueIndex(e);\n    if (t !== -1) {\n      this.log(`reset asset player \"${e}\" after error`);\n      const r = this.playerQueue[t];\n      this.transferMediaFromPlayer(r, null), r.resetDetails();\n    }\n  }\n  clearAssetPlayer(e, t) {\n    const r = this.getAssetPlayerQueueIndex(e);\n    if (r !== -1) {\n      const n = this.playerQueue[r];\n      this.log(`clear ${n} toSegment: ${t &amp;&amp; kr(t)}`), this.transferMediaFromPlayer(n, t), this.playerQueue.splice(r, 1), n.destroy();\n    }\n  }\n  emptyPlayerQueue() {\n    let e;\n    for (; e = this.playerQueue.pop(); )\n      e.destroy();\n    this.playerQueue = [];\n  }\n  startAssetPlayer(e, t, r, n, i) {\n    const {\n      interstitial: o,\n      assetItem: a,\n      assetId: l\n    } = e, c = o.assetList.length, u = this.playingAsset;\n    this.endedAsset = null, this.playingAsset = a, (!u || u.identifier !== l) &amp;&amp; (u &amp;&amp; (this.clearAssetPlayer(u.identifier, r[n]), delete u.error), this.log(`INTERSTITIAL_ASSET_STARTED ${t + 1}/${c} ${vn(a)}`), this.hls.trigger(I.INTERSTITIAL_ASSET_STARTED, {\n      asset: a,\n      assetListIndex: t,\n      event: o,\n      schedule: r.slice(0),\n      scheduleIndex: n,\n      player: e\n    })), this.bufferAssetPlayer(e, i);\n  }\n  bufferAssetPlayer(e, t) {\n    var r, n;\n    if (!this.schedule)\n      return;\n    const {\n      interstitial: i,\n      assetItem: o\n    } = e, a = this.schedule.findEventIndex(i.identifier), l = (r = this.schedule.items) == null ? void 0 : r[a];\n    if (!l)\n      return;\n    e.loadSource(), this.setBufferingItem(l), this.bufferingAsset = o;\n    const c = this.getBufferingPlayer();\n    if (c === e)\n      return;\n    const u = i.appendInPlace;\n    if (u &amp;&amp; (c == null ? void 0 : c.interstitial.appendInPlace) === !1)\n      return;\n    const d = (c == null ? void 0 : c.tracks) || ((n = this.detachedData) == null ? void 0 : n.tracks) || this.requiredTracks;\n    if (u &amp;&amp; o !== this.playingAsset) {\n      if (!e.tracks) {\n        this.log(`Waiting for track info before buffering ${e}`);\n        return;\n      }\n      if (d &amp;&amp; !Ag(d, e.tracks)) {\n        const h = new Error(`Asset ${vn(o)} SourceBuffer tracks ('${Object.keys(e.tracks)}') are not compatible with primary content tracks ('${Object.keys(d)}')`), f = {\n          fatal: !0,\n          type: ve.OTHER_ERROR,\n          details: J.INTERSTITIAL_ASSET_ITEM_ERROR,\n          error: h\n        }, p = i.findAssetIndex(o);\n        this.handleAssetItemError(f, i, a, p, h.message);\n        return;\n      }\n    }\n    this.transferMediaTo(e, t);\n  }\n  handleInPlaceStall(e) {\n    const t = this.schedule, r = this.primaryMedia;\n    if (!t || !r)\n      return;\n    const n = r.currentTime, i = t.findAssetIndex(e, n), o = e.assetList[i];\n    if (o) {\n      const a = this.getAssetPlayer(o.identifier);\n      if (a) {\n        const l = a.currentTime || n - o.timelineStart, c = a.duration - l;\n        if (this.warn(`Stalled at ${l} of ${l + c} in ${a} ${e} (media.currentTime: ${n})`), l &amp;&amp; (c / r.playbackRate &lt; 0.5 || a.bufferedInPlaceToEnd(r)) &amp;&amp; a.hls) {\n          const u = t.findEventIndex(e.identifier);\n          this.advanceAfterAssetEnded(e, u, i);\n        }\n      }\n    }\n  }\n  advanceInPlace(e) {\n    const t = this.primaryMedia;\n    t &amp;&amp; t.currentTime &lt; e &amp;&amp; (t.currentTime = e);\n  }\n  handleAssetItemError(e, t, r, n, i) {\n    if (e.details === J.BUFFER_STALLED_ERROR)\n      return;\n    const o = t.assetList[n] || null;\n    if (this.warn(`INTERSTITIAL_ASSET_ERROR ${o &amp;&amp; vn(o)} ${e.error}`), !this.schedule)\n      return;\n    const a = (o == null ? void 0 : o.identifier) || \"\", l = this.getAssetPlayerQueueIndex(a), c = this.playerQueue[l] || null, u = this.schedule.items, d = nt({}, e, {\n      fatal: !1,\n      errorAction: An(!0),\n      asset: o,\n      assetListIndex: n,\n      event: t,\n      schedule: u,\n      scheduleIndex: r,\n      player: c\n    });\n    if (this.hls.trigger(I.INTERSTITIAL_ASSET_ERROR, d), !e.fatal)\n      return;\n    const h = this.playingAsset, f = this.bufferingAsset, p = new Error(i);\n    if (o &amp;&amp; (this.clearAssetPlayer(a, null), o.error = p), !t.assetList.some((y) =&gt; !y.error))\n      t.error = p;\n    else\n      for (let y = n; y &lt; t.assetList.length; y++)\n        this.resetAssetPlayer(t.assetList[y].identifier);\n    this.updateSchedule(!0), t.error ? this.primaryFallback(t) : h &amp;&amp; h.identifier === a ? this.advanceAfterAssetEnded(t, r, n) : f &amp;&amp; f.identifier === a &amp;&amp; this.isInterstitial(this.bufferingItem) &amp;&amp; this.advanceAssetBuffering(this.bufferingItem, f);\n  }\n  primaryFallback(e) {\n    const t = e.timelineStart, r = this.effectivePlayingItem;\n    if (r) {\n      this.log(`Fallback to primary from event \"${e.identifier}\" start: ${t} pos: ${this.timelinePos} playing: ${kr(r)} error: ${e.error}`);\n      let n = this.timelinePos;\n      n === -1 &amp;&amp; (n = this.hls.startPosition);\n      const i = this.updateItem(r, n);\n      if (this.itemsMatch(r, i) &amp;&amp; this.clearInterstitial(e, null), e.appendInPlace &amp;&amp; (this.attachPrimary(t, null), this.flushFrontBuffer(t)), !this.schedule)\n        return;\n      const o = this.schedule.findItemIndexAtTime(n);\n      this.setSchedulePosition(o);\n    } else\n      this.checkStart();\n  }\n  // Asset List loading\n  onAssetListLoaded(e, t) {\n    var r, n;\n    const i = t.event, o = i.identifier, a = t.assetListResponse.ASSETS;\n    if (!((r = this.schedule) != null &amp;&amp; r.hasEvent(o)))\n      return;\n    const l = i.timelineStart, c = i.duration;\n    let u = 0;\n    a.forEach((y, E) =&gt; {\n      const b = parseFloat(y.DURATION);\n      this.createAsset(i, E, u, l + u, b, y.URI), u += b;\n    }), i.duration = u, this.log(`Loaded asset-list with duration: ${u} (was: ${c}) ${i}`);\n    const d = this.waitingItem, h = (d == null ? void 0 : d.event.identifier) === o;\n    this.updateSchedule();\n    const f = (n = this.bufferingItem) == null ? void 0 : n.event;\n    if (h) {\n      var p;\n      const y = this.schedule.findEventIndex(o), E = (p = this.schedule.items) == null ? void 0 : p[y];\n      if (E) {\n        if (!this.playingItem &amp;&amp; this.timelinePos &gt; E.end &amp;&amp; this.schedule.findItemIndexAtTime(this.timelinePos) !== y) {\n          i.error = new Error(`Interstitial no longer within playback range ${this.timelinePos} ${i}`), this.updateSchedule(!0), this.primaryFallback(i);\n          return;\n        }\n        this.setBufferingItem(E);\n      }\n      this.setSchedulePosition(y);\n    } else if ((f == null ? void 0 : f.identifier) === o) {\n      const y = i.assetList[0];\n      if (y) {\n        const E = this.getAssetPlayer(y.identifier);\n        if (f.appendInPlace) {\n          const b = this.primaryMedia;\n          E &amp;&amp; b &amp;&amp; this.bufferAssetPlayer(E, b);\n        } else E &amp;&amp; E.loadSource();\n      }\n    }\n  }\n  onError(e, t) {\n    if (this.schedule)\n      switch (t.details) {\n        case J.ASSET_LIST_PARSING_ERROR:\n        case J.ASSET_LIST_LOAD_ERROR:\n        case J.ASSET_LIST_LOAD_TIMEOUT: {\n          const r = t.interstitial;\n          r &amp;&amp; (this.updateSchedule(!0), this.primaryFallback(r));\n          break;\n        }\n        case J.BUFFER_STALLED_ERROR: {\n          const r = this.endedItem || this.waitingItem || this.playingItem;\n          if (this.isInterstitial(r) &amp;&amp; r.event.appendInPlace) {\n            this.handleInPlaceStall(r.event);\n            return;\n          }\n          this.log(`Primary player stall @${this.timelinePos} bufferedPos: ${this.bufferedPos}`), this.onTimeupdate(), this.checkBuffer(!0);\n          break;\n        }\n      }\n  }\n}\nconst Qh = 500;\nclass Sw extends Tu {\n  constructor(e, t, r) {\n    super(e, t, r, \"subtitle-stream-controller\", pe.SUBTITLE), this.currentTrackId = -1, this.tracksBuffered = [], this.mainDetails = null, this.registerListeners();\n  }\n  onHandlerDestroying() {\n    this.unregisterListeners(), super.onHandlerDestroying(), this.mainDetails = null;\n  }\n  registerListeners() {\n    super.registerListeners();\n    const {\n      hls: e\n    } = this;\n    e.on(I.LEVEL_LOADED, this.onLevelLoaded, this), e.on(I.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(I.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.on(I.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.on(I.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.on(I.BUFFER_FLUSHING, this.onBufferFlushing, this);\n  }\n  unregisterListeners() {\n    super.unregisterListeners();\n    const {\n      hls: e\n    } = this;\n    e.off(I.LEVEL_LOADED, this.onLevelLoaded, this), e.off(I.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(I.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this), e.off(I.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this), e.off(I.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this), e.off(I.BUFFER_FLUSHING, this.onBufferFlushing, this);\n  }\n  startLoad(e, t) {\n    this.stopLoad(), this.state = ne.IDLE, this.setInterval(Qh), this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = t ? -1 : e, this.tick();\n  }\n  onManifestLoading() {\n    super.onManifestLoading(), this.mainDetails = null;\n  }\n  onMediaDetaching(e, t) {\n    this.tracksBuffered = [], super.onMediaDetaching(e, t);\n  }\n  onLevelLoaded(e, t) {\n    this.mainDetails = t.details;\n  }\n  onSubtitleFragProcessed(e, t) {\n    const {\n      frag: r,\n      success: n\n    } = t;\n    if (this.fragContextChanged(r) || (Vt(r) &amp;&amp; (this.fragPrevious = r), this.state = ne.IDLE), !n)\n      return;\n    const i = this.tracksBuffered[this.currentTrackId];\n    if (!i)\n      return;\n    let o;\n    const a = r.start;\n    for (let c = 0; c &lt; i.length; c++)\n      if (a &gt;= i[c].start &amp;&amp; a &lt;= i[c].end) {\n        o = i[c];\n        break;\n      }\n    const l = r.start + r.duration;\n    o ? o.end = l : (o = {\n      start: a,\n      end: l\n    }, i.push(o)), this.fragmentTracker.fragBuffered(r), this.fragBufferedComplete(r, null), this.media &amp;&amp; this.tick();\n  }\n  onBufferFlushing(e, t) {\n    const {\n      startOffset: r,\n      endOffset: n\n    } = t;\n    if (r === 0 &amp;&amp; n !== Number.POSITIVE_INFINITY) {\n      const i = n - 1;\n      if (i &lt;= 0)\n        return;\n      t.endOffsetSubtitles = Math.max(0, i), this.tracksBuffered.forEach((o) =&gt; {\n        for (let a = 0; a &lt; o.length; ) {\n          if (o[a].end &lt;= i) {\n            o.shift();\n            continue;\n          } else if (o[a].start &lt; i)\n            o[a].start = i;\n          else\n            break;\n          a++;\n        }\n      }), this.fragmentTracker.removeFragmentsInRange(r, i, pe.SUBTITLE);\n    }\n  }\n  // If something goes wrong, proceed to next frag, if we were processing one.\n  onError(e, t) {\n    const r = t.frag;\n    (r == null ? void 0 : r.type) === pe.SUBTITLE &amp;&amp; (t.details === J.FRAG_GAP &amp;&amp; this.fragmentTracker.fragBuffered(r, !0), this.fragCurrent &amp;&amp; this.fragCurrent.abortRequests(), this.state !== ne.STOPPED &amp;&amp; (this.state = ne.IDLE));\n  }\n  // Got all new subtitle levels.\n  onSubtitleTracksUpdated(e, {\n    subtitleTracks: t\n  }) {\n    if (this.levels &amp;&amp; Ap(this.levels, t)) {\n      this.levels = t.map((r) =&gt; new mi(r));\n      return;\n    }\n    this.tracksBuffered = [], this.levels = t.map((r) =&gt; {\n      const n = new mi(r);\n      return this.tracksBuffered[n.id] = [], n;\n    }), this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, pe.SUBTITLE), this.fragPrevious = null, this.mediaBuffer = null;\n  }\n  onSubtitleTrackSwitch(e, t) {\n    var r;\n    if (this.currentTrackId = t.id, !((r = this.levels) != null &amp;&amp; r.length) || this.currentTrackId === -1) {\n      this.clearInterval();\n      return;\n    }\n    const n = this.levels[this.currentTrackId];\n    n != null &amp;&amp; n.details ? this.mediaBuffer = this.mediaBufferTimeRanges : this.mediaBuffer = null, n &amp;&amp; this.state !== ne.STOPPED &amp;&amp; this.setInterval(Qh);\n  }\n  // Got a new set of subtitle fragments.\n  onSubtitleTrackLoaded(e, t) {\n    var r;\n    const {\n      currentTrackId: n,\n      levels: i\n    } = this, {\n      details: o,\n      id: a\n    } = t;\n    if (!i) {\n      this.warn(`Subtitle tracks were reset while loading level ${a}`);\n      return;\n    }\n    const l = i[a];\n    if (a &gt;= i.length || !l)\n      return;\n    this.log(`Subtitle track ${a} loaded [${o.startSN},${o.endSN}]${o.lastPartSn ? `[part-${o.lastPartSn}-${o.lastPartIndex}]` : \"\"},duration:${o.totalduration}`), this.mediaBuffer = this.mediaBufferTimeRanges;\n    let c = 0;\n    if (o.live || (r = l.details) != null &amp;&amp; r.live) {\n      if (o.deltaUpdateFailed)\n        return;\n      const d = this.mainDetails;\n      if (!d) {\n        this.startFragRequested = !1;\n        return;\n      }\n      const h = d.fragments[0];\n      if (!l.details)\n        o.hasProgramDateTime &amp;&amp; d.hasProgramDateTime ? (sa(o, d), c = o.fragmentStart) : h &amp;&amp; (c = h.start, gc(o, c));\n      else {\n        var u;\n        c = this.alignPlaylists(o, l.details, (u = this.levelLastLoaded) == null ? void 0 : u.details), c === 0 &amp;&amp; h &amp;&amp; (c = h.start, gc(o, c));\n      }\n      d &amp;&amp; !this.startFragRequested &amp;&amp; this.setStartPosition(d, c);\n    }\n    l.details = o, this.levelLastLoaded = l, a === n &amp;&amp; (this.hls.trigger(I.SUBTITLE_TRACK_UPDATED, {\n      details: o,\n      id: a,\n      groupId: t.groupId\n    }), this.tick(), o.live &amp;&amp; !this.fragCurrent &amp;&amp; this.media &amp;&amp; this.state === ne.IDLE &amp;&amp; (Js(null, o.fragments, this.media.currentTime, 0) || (this.warn(\"Subtitle playlist not aligned with playback\"), l.details = void 0)));\n  }\n  _handleFragmentLoadComplete(e) {\n    const {\n      frag: t,\n      payload: r\n    } = e, n = t.decryptdata, i = this.hls;\n    if (!this.fragContextChanged(t) &amp;&amp; r &amp;&amp; r.byteLength &gt; 0 &amp;&amp; n != null &amp;&amp; n.key &amp;&amp; n.iv &amp;&amp; In(n.method)) {\n      const o = performance.now();\n      this.decrypter.decrypt(new Uint8Array(r), n.key.buffer, n.iv.buffer, Su(n.method)).catch((a) =&gt; {\n        throw i.trigger(I.ERROR, {\n          type: ve.MEDIA_ERROR,\n          details: J.FRAG_DECRYPT_ERROR,\n          fatal: !1,\n          error: a,\n          reason: a.message,\n          frag: t\n        }), a;\n      }).then((a) =&gt; {\n        const l = performance.now();\n        i.trigger(I.FRAG_DECRYPTED, {\n          frag: t,\n          payload: a,\n          stats: {\n            tstart: o,\n            tdecrypt: l\n          }\n        });\n      }).catch((a) =&gt; {\n        this.warn(`${a.name}: ${a.message}`), this.state = ne.IDLE;\n      });\n    }\n  }\n  doTick() {\n    if (!this.media) {\n      this.state = ne.IDLE;\n      return;\n    }\n    if (this.state === ne.IDLE) {\n      const {\n        currentTrackId: e,\n        levels: t\n      } = this, r = t == null ? void 0 : t[e];\n      if (!r || !t.length || !r.details || this.waitForLive(r))\n        return;\n      const {\n        config: n\n      } = this, i = this.getLoadPosition(), o = Ce.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], i, n.maxBufferHole), {\n        end: a,\n        len: l\n      } = o, c = r.details, u = this.hls.maxBufferLength + c.levelTargetDuration;\n      if (l &gt; u)\n        return;\n      const d = c.fragments, h = d.length, f = c.edge;\n      let p = null;\n      const y = this.fragPrevious;\n      if (a &lt; f) {\n        const R = n.maxFragLookUpTolerance, A = a &gt; f - R ? 0 : R;\n        p = Js(y, d, Math.max(d[0].start, a), A), !p &amp;&amp; y &amp;&amp; y.start &lt; d[0].start &amp;&amp; (p = d[0]);\n      } else\n        p = d[h - 1];\n      if (p = this.filterReplacedPrimary(p, r.details), !p)\n        return;\n      const E = p.sn - c.startSN, b = d[E - 1];\n      if (b &amp;&amp; b.cc === p.cc &amp;&amp; this.fragmentTracker.getState(b) === Ht.NOT_LOADED &amp;&amp; (p = b), this.fragmentTracker.getState(p) === Ht.NOT_LOADED) {\n        const R = this.mapToInitFragWhenRequired(p);\n        R &amp;&amp; this.loadFragment(R, r, a);\n      }\n    }\n  }\n  loadFragment(e, t, r) {\n    Vt(e) ? super.loadFragment(e, t, r) : this._loadInitSegment(e, t);\n  }\n  get mediaBufferTimeRanges() {\n    return new bw(this.tracksBuffered[this.currentTrackId] || []);\n  }\n}\nclass bw {\n  constructor(e) {\n    this.buffered = void 0;\n    const t = (r, n, i) =&gt; {\n      if (n = n &gt;&gt;&gt; 0, n &gt; i - 1)\n        throw new DOMException(`Failed to execute '${r}' on 'TimeRanges': The index provided (${n}) is greater than the maximum bound (${i})`);\n      return e[n][r];\n    };\n    this.buffered = {\n      get length() {\n        return e.length;\n      },\n      end(r) {\n        return t(\"end\", r, e.length);\n      },\n      start(r) {\n        return t(\"start\", r, e.length);\n      }\n    };\n  }\n}\nconst Tw = {\n  42: 225,\n  // lowercase a, acute accent\n  92: 233,\n  // lowercase e, acute accent\n  94: 237,\n  // lowercase i, acute accent\n  95: 243,\n  // lowercase o, acute accent\n  96: 250,\n  // lowercase u, acute accent\n  123: 231,\n  // lowercase c with cedilla\n  124: 247,\n  // division symbol\n  125: 209,\n  // uppercase N tilde\n  126: 241,\n  // lowercase n tilde\n  127: 9608,\n  // Full block\n  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n  // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n  128: 174,\n  // Registered symbol (R)\n  129: 176,\n  // degree sign\n  130: 189,\n  // 1/2 symbol\n  131: 191,\n  // Inverted (open) question mark\n  132: 8482,\n  // Trademark symbol (TM)\n  133: 162,\n  // Cents symbol\n  134: 163,\n  // Pounds sterling\n  135: 9834,\n  // Music 8'th note\n  136: 224,\n  // lowercase a, grave accent\n  137: 32,\n  // transparent space (regular)\n  138: 232,\n  // lowercase e, grave accent\n  139: 226,\n  // lowercase a, circumflex accent\n  140: 234,\n  // lowercase e, circumflex accent\n  141: 238,\n  // lowercase i, circumflex accent\n  142: 244,\n  // lowercase o, circumflex accent\n  143: 251,\n  // lowercase u, circumflex accent\n  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n  144: 193,\n  // capital letter A with acute\n  145: 201,\n  // capital letter E with acute\n  146: 211,\n  // capital letter O with acute\n  147: 218,\n  // capital letter U with acute\n  148: 220,\n  // capital letter U with diaresis\n  149: 252,\n  // lowercase letter U with diaeresis\n  150: 8216,\n  // opening single quote\n  151: 161,\n  // inverted exclamation mark\n  152: 42,\n  // asterisk\n  153: 8217,\n  // closing single quote\n  154: 9473,\n  // box drawings heavy horizontal\n  155: 169,\n  // copyright sign\n  156: 8480,\n  // Service mark\n  157: 8226,\n  // (round) bullet\n  158: 8220,\n  // Left double quotation mark\n  159: 8221,\n  // Right double quotation mark\n  160: 192,\n  // uppercase A, grave accent\n  161: 194,\n  // uppercase A, circumflex\n  162: 199,\n  // uppercase C with cedilla\n  163: 200,\n  // uppercase E, grave accent\n  164: 202,\n  // uppercase E, circumflex\n  165: 203,\n  // capital letter E with diaresis\n  166: 235,\n  // lowercase letter e with diaresis\n  167: 206,\n  // uppercase I, circumflex\n  168: 207,\n  // uppercase I, with diaresis\n  169: 239,\n  // lowercase i, with diaresis\n  170: 212,\n  // uppercase O, circumflex\n  171: 217,\n  // uppercase U, grave accent\n  172: 249,\n  // lowercase u, grave accent\n  173: 219,\n  // uppercase U, circumflex\n  174: 171,\n  // left-pointing double angle quotation mark\n  175: 187,\n  // right-pointing double angle quotation mark\n  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n  176: 195,\n  // Uppercase A, tilde\n  177: 227,\n  // Lowercase a, tilde\n  178: 205,\n  // Uppercase I, acute accent\n  179: 204,\n  // Uppercase I, grave accent\n  180: 236,\n  // Lowercase i, grave accent\n  181: 210,\n  // Uppercase O, grave accent\n  182: 242,\n  // Lowercase o, grave accent\n  183: 213,\n  // Uppercase O, tilde\n  184: 245,\n  // Lowercase o, tilde\n  185: 123,\n  // Open curly brace\n  186: 125,\n  // Closing curly brace\n  187: 92,\n  // Backslash\n  188: 94,\n  // Caret\n  189: 95,\n  // Underscore\n  190: 124,\n  // Pipe (vertical line)\n  191: 8764,\n  // Tilde operator\n  192: 196,\n  // Uppercase A, umlaut\n  193: 228,\n  // Lowercase A, umlaut\n  194: 214,\n  // Uppercase O, umlaut\n  195: 246,\n  // Lowercase o, umlaut\n  196: 223,\n  // Esszett (sharp S)\n  197: 165,\n  // Yen symbol\n  198: 164,\n  // Generic currency sign\n  199: 9475,\n  // Box drawings heavy vertical\n  200: 197,\n  // Uppercase A, ring\n  201: 229,\n  // Lowercase A, ring\n  202: 216,\n  // Uppercase O, stroke\n  203: 248,\n  // Lowercase o, strok\n  204: 9487,\n  // Box drawings heavy down and right\n  205: 9491,\n  // Box drawings heavy down and left\n  206: 9495,\n  // Box drawings heavy up and right\n  207: 9499\n  // Box drawings heavy up and left\n}, Gp = (s) =&gt; String.fromCharCode(Tw[s] || s), Dr = 15, is = 100, ww = {\n  17: 1,\n  18: 3,\n  21: 5,\n  22: 7,\n  23: 9,\n  16: 11,\n  19: 12,\n  20: 14\n}, Aw = {\n  17: 2,\n  18: 4,\n  21: 6,\n  22: 8,\n  23: 10,\n  19: 13,\n  20: 15\n}, Iw = {\n  25: 1,\n  26: 3,\n  29: 5,\n  30: 7,\n  31: 9,\n  24: 11,\n  27: 12,\n  28: 14\n}, _w = {\n  25: 2,\n  26: 4,\n  29: 6,\n  30: 8,\n  31: 10,\n  27: 13,\n  28: 15\n}, Rw = [\"white\", \"green\", \"blue\", \"cyan\", \"red\", \"yellow\", \"magenta\", \"black\", \"transparent\"];\nclass Lw {\n  constructor() {\n    this.time = null, this.verboseLevel = 0;\n  }\n  log(e, t) {\n    if (this.verboseLevel &gt;= e) {\n      const r = typeof t == \"function\" ? t() : t;\n      rt.log(`${this.time} [${e}] ${r}`);\n    }\n  }\n}\nconst Ns = function(e) {\n  const t = [];\n  for (let r = 0; r &lt; e.length; r++)\n    t.push(e[r].toString(16));\n  return t;\n};\nclass Vp {\n  constructor() {\n    this.foreground = \"white\", this.underline = !1, this.italics = !1, this.background = \"black\", this.flash = !1;\n  }\n  reset() {\n    this.foreground = \"white\", this.underline = !1, this.italics = !1, this.background = \"black\", this.flash = !1;\n  }\n  setStyles(e) {\n    const t = [\"foreground\", \"underline\", \"italics\", \"background\", \"flash\"];\n    for (let r = 0; r &lt; t.length; r++) {\n      const n = t[r];\n      e.hasOwnProperty(n) &amp;&amp; (this[n] = e[n]);\n    }\n  }\n  isDefault() {\n    return this.foreground === \"white\" &amp;&amp; !this.underline &amp;&amp; !this.italics &amp;&amp; this.background === \"black\" &amp;&amp; !this.flash;\n  }\n  equals(e) {\n    return this.foreground === e.foreground &amp;&amp; this.underline === e.underline &amp;&amp; this.italics === e.italics &amp;&amp; this.background === e.background &amp;&amp; this.flash === e.flash;\n  }\n  copy(e) {\n    this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash;\n  }\n  toString() {\n    return \"color=\" + this.foreground + \", underline=\" + this.underline + \", italics=\" + this.italics + \", background=\" + this.background + \", flash=\" + this.flash;\n  }\n}\nclass Cw {\n  constructor() {\n    this.uchar = \" \", this.penState = new Vp();\n  }\n  reset() {\n    this.uchar = \" \", this.penState.reset();\n  }\n  setChar(e, t) {\n    this.uchar = e, this.penState.copy(t);\n  }\n  setPenState(e) {\n    this.penState.copy(e);\n  }\n  equals(e) {\n    return this.uchar === e.uchar &amp;&amp; this.penState.equals(e.penState);\n  }\n  copy(e) {\n    this.uchar = e.uchar, this.penState.copy(e.penState);\n  }\n  isEmpty() {\n    return this.uchar === \" \" &amp;&amp; this.penState.isDefault();\n  }\n}\nclass kw {\n  constructor(e) {\n    this.chars = [], this.pos = 0, this.currPenState = new Vp(), this.cueStartTime = null, this.logger = void 0;\n    for (let t = 0; t &lt; is; t++)\n      this.chars.push(new Cw());\n    this.logger = e;\n  }\n  equals(e) {\n    for (let t = 0; t &lt; is; t++)\n      if (!this.chars[t].equals(e.chars[t]))\n        return !1;\n    return !0;\n  }\n  copy(e) {\n    for (let t = 0; t &lt; is; t++)\n      this.chars[t].copy(e.chars[t]);\n  }\n  isEmpty() {\n    let e = !0;\n    for (let t = 0; t &lt; is; t++)\n      if (!this.chars[t].isEmpty()) {\n        e = !1;\n        break;\n      }\n    return e;\n  }\n  /**\n   *  Set the cursor to a valid column.\n   */\n  setCursor(e) {\n    this.pos !== e &amp;&amp; (this.pos = e), this.pos &lt; 0 ? (this.logger.log(3, \"Negative cursor position \" + this.pos), this.pos = 0) : this.pos &gt; is &amp;&amp; (this.logger.log(3, \"Too large cursor position \" + this.pos), this.pos = is);\n  }\n  /**\n   * Move the cursor relative to current position.\n   */\n  moveCursor(e) {\n    const t = this.pos + e;\n    if (e &gt; 1)\n      for (let r = this.pos + 1; r &lt; t + 1; r++)\n        this.chars[r].setPenState(this.currPenState);\n    this.setCursor(t);\n  }\n  /**\n   * Backspace, move one step back and clear character.\n   */\n  backSpace() {\n    this.moveCursor(-1), this.chars[this.pos].setChar(\" \", this.currPenState);\n  }\n  insertChar(e) {\n    e &gt;= 144 &amp;&amp; this.backSpace();\n    const t = Gp(e);\n    if (this.pos &gt;= is) {\n      this.logger.log(0, () =&gt; \"Cannot insert \" + e.toString(16) + \" (\" + t + \") at position \" + this.pos + \". Skipping it!\");\n      return;\n    }\n    this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1);\n  }\n  clearFromPos(e) {\n    let t;\n    for (t = e; t &lt; is; t++)\n      this.chars[t].reset();\n  }\n  clear() {\n    this.clearFromPos(0), this.pos = 0, this.currPenState.reset();\n  }\n  clearToEndOfRow() {\n    this.clearFromPos(this.pos);\n  }\n  getTextString() {\n    const e = [];\n    let t = !0;\n    for (let r = 0; r &lt; is; r++) {\n      const n = this.chars[r].uchar;\n      n !== \" \" &amp;&amp; (t = !1), e.push(n);\n    }\n    return t ? \"\" : e.join(\"\");\n  }\n  setPenStyles(e) {\n    this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState);\n  }\n}\nclass wl {\n  constructor(e) {\n    this.rows = [], this.currRow = Dr - 1, this.nrRollUpRows = null, this.lastOutputScreen = null, this.logger = void 0;\n    for (let t = 0; t &lt; Dr; t++)\n      this.rows.push(new kw(e));\n    this.logger = e;\n  }\n  reset() {\n    for (let e = 0; e &lt; Dr; e++)\n      this.rows[e].clear();\n    this.currRow = Dr - 1;\n  }\n  equals(e) {\n    let t = !0;\n    for (let r = 0; r &lt; Dr; r++)\n      if (!this.rows[r].equals(e.rows[r])) {\n        t = !1;\n        break;\n      }\n    return t;\n  }\n  copy(e) {\n    for (let t = 0; t &lt; Dr; t++)\n      this.rows[t].copy(e.rows[t]);\n  }\n  isEmpty() {\n    let e = !0;\n    for (let t = 0; t &lt; Dr; t++)\n      if (!this.rows[t].isEmpty()) {\n        e = !1;\n        break;\n      }\n    return e;\n  }\n  backSpace() {\n    this.rows[this.currRow].backSpace();\n  }\n  clearToEndOfRow() {\n    this.rows[this.currRow].clearToEndOfRow();\n  }\n  /**\n   * Insert a character (without styling) in the current row.\n   */\n  insertChar(e) {\n    this.rows[this.currRow].insertChar(e);\n  }\n  setPen(e) {\n    this.rows[this.currRow].setPenStyles(e);\n  }\n  moveCursor(e) {\n    this.rows[this.currRow].moveCursor(e);\n  }\n  setCursor(e) {\n    this.logger.log(2, \"setCursor: \" + e), this.rows[this.currRow].setCursor(e);\n  }\n  setPAC(e) {\n    this.logger.log(2, () =&gt; \"pacData = \" + at(e));\n    let t = e.row - 1;\n    if (this.nrRollUpRows &amp;&amp; t &lt; this.nrRollUpRows - 1 &amp;&amp; (t = this.nrRollUpRows - 1), this.nrRollUpRows &amp;&amp; this.currRow !== t) {\n      for (let a = 0; a &lt; Dr; a++)\n        this.rows[a].clear();\n      const i = this.currRow + 1 - this.nrRollUpRows, o = this.lastOutputScreen;\n      if (o) {\n        const a = o.rows[i].cueStartTime, l = this.logger.time;\n        if (a !== null &amp;&amp; l !== null &amp;&amp; a &lt; l)\n          for (let c = 0; c &lt; this.nrRollUpRows; c++)\n            this.rows[t - this.nrRollUpRows + c + 1].copy(o.rows[i + c]);\n      }\n    }\n    this.currRow = t;\n    const r = this.rows[this.currRow];\n    if (e.indent !== null) {\n      const i = e.indent, o = Math.max(i - 1, 0);\n      r.setCursor(e.indent), e.color = r.chars[o].penState.foreground;\n    }\n    const n = {\n      foreground: e.color,\n      underline: e.underline,\n      italics: e.italics,\n      background: \"black\",\n      flash: !1\n    };\n    this.setPen(n);\n  }\n  /**\n   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n   */\n  setBkgData(e) {\n    this.logger.log(2, () =&gt; \"bkgData = \" + at(e)), this.backSpace(), this.setPen(e), this.insertChar(32);\n  }\n  setRollUpRows(e) {\n    this.nrRollUpRows = e;\n  }\n  rollUp() {\n    if (this.nrRollUpRows === null) {\n      this.logger.log(3, \"roll_up but nrRollUpRows not set yet\");\n      return;\n    }\n    this.logger.log(1, () =&gt; this.getDisplayText());\n    const e = this.currRow + 1 - this.nrRollUpRows, t = this.rows.splice(e, 1)[0];\n    t.clear(), this.rows.splice(this.currRow, 0, t), this.logger.log(2, \"Rolling up\");\n  }\n  /**\n   * Get all non-empty rows with as unicode text.\n   */\n  getDisplayText(e) {\n    e = e || !1;\n    const t = [];\n    let r = \"\", n = -1;\n    for (let i = 0; i &lt; Dr; i++) {\n      const o = this.rows[i].getTextString();\n      o &amp;&amp; (n = i + 1, e ? t.push(\"Row \" + n + \": '\" + o + \"'\") : t.push(o.trim()));\n    }\n    return t.length &gt; 0 &amp;&amp; (e ? r = \"[\" + t.join(\" | \") + \"]\" : r = t.join(`\n`)), r;\n  }\n  getTextAndFormat() {\n    return this.rows;\n  }\n}\nclass ef {\n  constructor(e, t, r) {\n    this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.logger = void 0, this.chNr = e, this.outputFilter = t, this.mode = null, this.verbose = 0, this.displayedMemory = new wl(r), this.nonDisplayedMemory = new wl(r), this.lastOutputScreen = new wl(r), this.currRollUpRow = this.displayedMemory.rows[Dr - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null, this.logger = r;\n  }\n  reset() {\n    this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.outputFilter.reset(), this.currRollUpRow = this.displayedMemory.rows[Dr - 1], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null;\n  }\n  getHandler() {\n    return this.outputFilter;\n  }\n  setHandler(e) {\n    this.outputFilter = e;\n  }\n  setPAC(e) {\n    this.writeScreen.setPAC(e);\n  }\n  setBkgData(e) {\n    this.writeScreen.setBkgData(e);\n  }\n  setMode(e) {\n    e !== this.mode &amp;&amp; (this.mode = e, this.logger.log(2, () =&gt; \"MODE=\" + e), this.mode === \"MODE_POP-ON\" ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), this.mode !== \"MODE_ROLL-UP\" &amp;&amp; (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e);\n  }\n  insertChars(e) {\n    for (let r = 0; r &lt; e.length; r++)\n      this.writeScreen.insertChar(e[r]);\n    const t = this.writeScreen === this.displayedMemory ? \"DISP\" : \"NON_DISP\";\n    this.logger.log(2, () =&gt; t + \": \" + this.writeScreen.getDisplayText(!0)), (this.mode === \"MODE_PAINT-ON\" || this.mode === \"MODE_ROLL-UP\") &amp;&amp; (this.logger.log(1, () =&gt; \"DISPLAYED: \" + this.displayedMemory.getDisplayText(!0)), this.outputDataUpdate());\n  }\n  ccRCL() {\n    this.logger.log(2, \"RCL - Resume Caption Loading\"), this.setMode(\"MODE_POP-ON\");\n  }\n  ccBS() {\n    this.logger.log(2, \"BS - BackSpace\"), this.mode !== \"MODE_TEXT\" &amp;&amp; (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory &amp;&amp; this.outputDataUpdate());\n  }\n  ccAOF() {\n  }\n  ccAON() {\n  }\n  ccDER() {\n    this.logger.log(2, \"DER- Delete to End of Row\"), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate();\n  }\n  ccRU(e) {\n    this.logger.log(2, \"RU(\" + e + \") - Roll Up\"), this.writeScreen = this.displayedMemory, this.setMode(\"MODE_ROLL-UP\"), this.writeScreen.setRollUpRows(e);\n  }\n  ccFON() {\n    this.logger.log(2, \"FON - Flash On\"), this.writeScreen.setPen({\n      flash: !0\n    });\n  }\n  ccRDC() {\n    this.logger.log(2, \"RDC - Resume Direct Captioning\"), this.setMode(\"MODE_PAINT-ON\");\n  }\n  ccTR() {\n    this.logger.log(2, \"TR\"), this.setMode(\"MODE_TEXT\");\n  }\n  ccRTD() {\n    this.logger.log(2, \"RTD\"), this.setMode(\"MODE_TEXT\");\n  }\n  ccEDM() {\n    this.logger.log(2, \"EDM - Erase Displayed Memory\"), this.displayedMemory.reset(), this.outputDataUpdate(!0);\n  }\n  ccCR() {\n    this.logger.log(2, \"CR - Carriage Return\"), this.writeScreen.rollUp(), this.outputDataUpdate(!0);\n  }\n  ccENM() {\n    this.logger.log(2, \"ENM - Erase Non-displayed Memory\"), this.nonDisplayedMemory.reset();\n  }\n  ccEOC() {\n    if (this.logger.log(2, \"EOC - End Of Caption\"), this.mode === \"MODE_POP-ON\") {\n      const e = this.displayedMemory;\n      this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, this.logger.log(1, () =&gt; \"DISP: \" + this.displayedMemory.getDisplayText());\n    }\n    this.outputDataUpdate(!0);\n  }\n  ccTO(e) {\n    this.logger.log(2, \"TO(\" + e + \") - Tab Offset\"), this.writeScreen.moveCursor(e);\n  }\n  ccMIDROW(e) {\n    const t = {\n      flash: !1\n    };\n    if (t.underline = e % 2 === 1, t.italics = e &gt;= 46, t.italics)\n      t.foreground = \"white\";\n    else {\n      const r = Math.floor(e / 2) - 16, n = [\"white\", \"green\", \"blue\", \"cyan\", \"red\", \"yellow\", \"magenta\"];\n      t.foreground = n[r];\n    }\n    this.logger.log(2, \"MIDROW: \" + at(t)), this.writeScreen.setPen(t);\n  }\n  outputDataUpdate(e = !1) {\n    const t = this.logger.time;\n    t !== null &amp;&amp; this.outputFilter &amp;&amp; (this.cueStartTime === null &amp;&amp; !this.displayedMemory.isEmpty() ? this.cueStartTime = t : this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), e &amp;&amp; this.outputFilter.dispatchCue &amp;&amp; this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t), this.lastOutputScreen.copy(this.displayedMemory));\n  }\n  cueSplitAtTime(e) {\n    this.outputFilter &amp;&amp; (this.displayedMemory.isEmpty() || (this.outputFilter.newCue &amp;&amp; this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e));\n  }\n}\nclass tf {\n  constructor(e, t, r) {\n    this.channels = void 0, this.currentChannel = 0, this.cmdHistory = Pw(), this.logger = void 0;\n    const n = this.logger = new Lw();\n    this.channels = [null, new ef(e, t, n), new ef(e + 1, r, n)];\n  }\n  getHandler(e) {\n    return this.channels[e].getHandler();\n  }\n  setHandler(e, t) {\n    this.channels[e].setHandler(t);\n  }\n  /**\n   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n   */\n  addData(e, t) {\n    this.logger.time = e;\n    for (let r = 0; r &lt; t.length; r += 2) {\n      const n = t[r] &amp; 127, i = t[r + 1] &amp; 127;\n      let o = !1, a = null;\n      if (n === 0 &amp;&amp; i === 0)\n        continue;\n      this.logger.log(3, () =&gt; \"[\" + Ns([t[r], t[r + 1]]) + \"] -&gt; (\" + Ns([n, i]) + \")\");\n      const l = this.cmdHistory;\n      if (n &gt;= 16 &amp;&amp; n &lt;= 31) {\n        if (Dw(n, i, l)) {\n          eo(null, null, l), this.logger.log(3, () =&gt; \"Repeated command (\" + Ns([n, i]) + \") is dropped\");\n          continue;\n        }\n        eo(n, i, this.cmdHistory), o = this.parseCmd(n, i), o || (o = this.parseMidrow(n, i)), o || (o = this.parsePAC(n, i)), o || (o = this.parseBackgroundAttributes(n, i));\n      } else\n        eo(null, null, l);\n      if (!o &amp;&amp; (a = this.parseChars(n, i), a)) {\n        const u = this.currentChannel;\n        u &amp;&amp; u &gt; 0 ? this.channels[u].insertChars(a) : this.logger.log(2, \"No channel found yet. TEXT-MODE?\");\n      }\n      !o &amp;&amp; !a &amp;&amp; this.logger.log(2, () =&gt; \"Couldn't parse cleaned data \" + Ns([n, i]) + \" orig: \" + Ns([t[r], t[r + 1]]));\n    }\n  }\n  /**\n   * Parse Command.\n   * @returns True if a command was found\n   */\n  parseCmd(e, t) {\n    const r = (e === 20 || e === 28 || e === 21 || e === 29) &amp;&amp; t &gt;= 32 &amp;&amp; t &lt;= 47, n = (e === 23 || e === 31) &amp;&amp; t &gt;= 33 &amp;&amp; t &lt;= 35;\n    if (!(r || n))\n      return !1;\n    const i = e === 20 || e === 21 || e === 23 ? 1 : 2, o = this.channels[i];\n    return e === 20 || e === 21 || e === 28 || e === 29 ? t === 32 ? o.ccRCL() : t === 33 ? o.ccBS() : t === 34 ? o.ccAOF() : t === 35 ? o.ccAON() : t === 36 ? o.ccDER() : t === 37 ? o.ccRU(2) : t === 38 ? o.ccRU(3) : t === 39 ? o.ccRU(4) : t === 40 ? o.ccFON() : t === 41 ? o.ccRDC() : t === 42 ? o.ccTR() : t === 43 ? o.ccRTD() : t === 44 ? o.ccEDM() : t === 45 ? o.ccCR() : t === 46 ? o.ccENM() : t === 47 &amp;&amp; o.ccEOC() : o.ccTO(t - 32), this.currentChannel = i, !0;\n  }\n  /**\n   * Parse midrow styling command\n   */\n  parseMidrow(e, t) {\n    let r = 0;\n    if ((e === 17 || e === 25) &amp;&amp; t &gt;= 32 &amp;&amp; t &lt;= 47) {\n      if (e === 17 ? r = 1 : r = 2, r !== this.currentChannel)\n        return this.logger.log(0, \"Mismatch channel in midrow parsing\"), !1;\n      const n = this.channels[r];\n      return n ? (n.ccMIDROW(t), this.logger.log(3, () =&gt; \"MIDROW (\" + Ns([e, t]) + \")\"), !0) : !1;\n    }\n    return !1;\n  }\n  /**\n   * Parse Preable Access Codes (Table 53).\n   * @returns {Boolean} Tells if PAC found\n   */\n  parsePAC(e, t) {\n    let r;\n    const n = (e &gt;= 17 &amp;&amp; e &lt;= 23 || e &gt;= 25 &amp;&amp; e &lt;= 31) &amp;&amp; t &gt;= 64 &amp;&amp; t &lt;= 127, i = (e === 16 || e === 24) &amp;&amp; t &gt;= 64 &amp;&amp; t &lt;= 95;\n    if (!(n || i))\n      return !1;\n    const o = e &lt;= 23 ? 1 : 2;\n    t &gt;= 64 &amp;&amp; t &lt;= 95 ? r = o === 1 ? ww[e] : Iw[e] : r = o === 1 ? Aw[e] : _w[e];\n    const a = this.channels[o];\n    return a ? (a.setPAC(this.interpretPAC(r, t)), this.currentChannel = o, !0) : !1;\n  }\n  /**\n   * Interpret the second byte of the pac, and return the information.\n   * @returns pacData with style parameters\n   */\n  interpretPAC(e, t) {\n    let r;\n    const n = {\n      color: null,\n      italics: !1,\n      indent: null,\n      underline: !1,\n      row: e\n    };\n    return t &gt; 95 ? r = t - 96 : r = t - 64, n.underline = (r &amp; 1) === 1, r &lt;= 13 ? n.color = [\"white\", \"green\", \"blue\", \"cyan\", \"red\", \"yellow\", \"magenta\", \"white\"][Math.floor(r / 2)] : r &lt;= 15 ? (n.italics = !0, n.color = \"white\") : n.indent = Math.floor((r - 16) / 2) * 4, n;\n  }\n  /**\n   * Parse characters.\n   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n   */\n  parseChars(e, t) {\n    let r, n = null, i = null;\n    if (e &gt;= 25 ? (r = 2, i = e - 8) : (r = 1, i = e), i &gt;= 17 &amp;&amp; i &lt;= 19) {\n      let o;\n      i === 17 ? o = t + 80 : i === 18 ? o = t + 112 : o = t + 144, this.logger.log(2, () =&gt; \"Special char '\" + Gp(o) + \"' in channel \" + r), n = [o];\n    } else e &gt;= 32 &amp;&amp; e &lt;= 127 &amp;&amp; (n = t === 0 ? [e] : [e, t]);\n    return n &amp;&amp; this.logger.log(3, () =&gt; \"Char codes =  \" + Ns(n).join(\",\")), n;\n  }\n  /**\n   * Parse extended background attributes as well as new foreground color black.\n   * @returns True if background attributes are found\n   */\n  parseBackgroundAttributes(e, t) {\n    const r = (e === 16 || e === 24) &amp;&amp; t &gt;= 32 &amp;&amp; t &lt;= 47, n = (e === 23 || e === 31) &amp;&amp; t &gt;= 45 &amp;&amp; t &lt;= 47;\n    if (!(r || n))\n      return !1;\n    let i;\n    const o = {};\n    e === 16 || e === 24 ? (i = Math.floor((t - 32) / 2), o.background = Rw[i], t % 2 === 1 &amp;&amp; (o.background = o.background + \"_semi\")) : t === 45 ? o.background = \"transparent\" : (o.foreground = \"black\", t === 47 &amp;&amp; (o.underline = !0));\n    const a = e &lt;= 23 ? 1 : 2;\n    return this.channels[a].setBkgData(o), !0;\n  }\n  /**\n   * Reset state of parser and its channels.\n   */\n  reset() {\n    for (let e = 0; e &lt; Object.keys(this.channels).length; e++) {\n      const t = this.channels[e];\n      t &amp;&amp; t.reset();\n    }\n    eo(null, null, this.cmdHistory);\n  }\n  /**\n   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n   */\n  cueSplitAtTime(e) {\n    for (let t = 0; t &lt; this.channels.length; t++) {\n      const r = this.channels[t];\n      r &amp;&amp; r.cueSplitAtTime(e);\n    }\n  }\n}\nfunction eo(s, e, t) {\n  t.a = s, t.b = e;\n}\nfunction Dw(s, e, t) {\n  return t.a === s &amp;&amp; t.b === e;\n}\nfunction Pw() {\n  return {\n    a: null,\n    b: null\n  };\n}\nvar Ou = (function() {\n  if (ra != null &amp;&amp; ra.VTTCue)\n    return self.VTTCue;\n  const s = [\"\", \"lr\", \"rl\"], e = [\"start\", \"middle\", \"end\", \"left\", \"right\"];\n  function t(a, l) {\n    if (typeof l != \"string\" || !Array.isArray(a))\n      return !1;\n    const c = l.toLowerCase();\n    return ~a.indexOf(c) ? c : !1;\n  }\n  function r(a) {\n    return t(s, a);\n  }\n  function n(a) {\n    return t(e, a);\n  }\n  function i(a, ...l) {\n    let c = 1;\n    for (; c &lt; arguments.length; c++) {\n      const u = arguments[c];\n      for (const d in u)\n        a[d] = u[d];\n    }\n    return a;\n  }\n  function o(a, l, c) {\n    const u = this, d = {\n      enumerable: !0\n    };\n    u.hasBeenReset = !1;\n    let h = \"\", f = !1, p = a, y = l, E = c, b = null, R = \"\", A = !0, F = \"auto\", M = \"start\", H = 50, K = \"middle\", j = 50, C = \"middle\";\n    Object.defineProperty(u, \"id\", i({}, d, {\n      get: function() {\n        return h;\n      },\n      set: function(k) {\n        h = \"\" + k;\n      }\n    })), Object.defineProperty(u, \"pauseOnExit\", i({}, d, {\n      get: function() {\n        return f;\n      },\n      set: function(k) {\n        f = !!k;\n      }\n    })), Object.defineProperty(u, \"startTime\", i({}, d, {\n      get: function() {\n        return p;\n      },\n      set: function(k) {\n        if (typeof k != \"number\")\n          throw new TypeError(\"Start time must be set to a number.\");\n        p = k, this.hasBeenReset = !0;\n      }\n    })), Object.defineProperty(u, \"endTime\", i({}, d, {\n      get: function() {\n        return y;\n      },\n      set: function(k) {\n        if (typeof k != \"number\")\n          throw new TypeError(\"End time must be set to a number.\");\n        y = k, this.hasBeenReset = !0;\n      }\n    })), Object.defineProperty(u, \"text\", i({}, d, {\n      get: function() {\n        return E;\n      },\n      set: function(k) {\n        E = \"\" + k, this.hasBeenReset = !0;\n      }\n    })), Object.defineProperty(u, \"region\", i({}, d, {\n      get: function() {\n        return b;\n      },\n      set: function(k) {\n        b = k, this.hasBeenReset = !0;\n      }\n    })), Object.defineProperty(u, \"vertical\", i({}, d, {\n      get: function() {\n        return R;\n      },\n      set: function(k) {\n        const $ = r(k);\n        if ($ === !1)\n          throw new SyntaxError(\"An invalid or illegal string was specified.\");\n        R = $, this.hasBeenReset = !0;\n      }\n    })), Object.defineProperty(u, \"snapToLines\", i({}, d, {\n      get: function() {\n        return A;\n      },\n      set: function(k) {\n        A = !!k, this.hasBeenReset = !0;\n      }\n    })), Object.defineProperty(u, \"line\", i({}, d, {\n      get: function() {\n        return F;\n      },\n      set: function(k) {\n        if (typeof k != \"number\" &amp;&amp; k !== \"auto\")\n          throw new SyntaxError(\"An invalid number or illegal string was specified.\");\n        F = k, this.hasBeenReset = !0;\n      }\n    })), Object.defineProperty(u, \"lineAlign\", i({}, d, {\n      get: function() {\n        return M;\n      },\n      set: function(k) {\n        const $ = n(k);\n        if (!$)\n          throw new SyntaxError(\"An invalid or illegal string was specified.\");\n        M = $, this.hasBeenReset = !0;\n      }\n    })), Object.defineProperty(u, \"position\", i({}, d, {\n      get: function() {\n        return H;\n      },\n      set: function(k) {\n        if (k &lt; 0 || k &gt; 100)\n          throw new Error(\"Position must be between 0 and 100.\");\n        H = k, this.hasBeenReset = !0;\n      }\n    })), Object.defineProperty(u, \"positionAlign\", i({}, d, {\n      get: function() {\n        return K;\n      },\n      set: function(k) {\n        const $ = n(k);\n        if (!$)\n          throw new SyntaxError(\"An invalid or illegal string was specified.\");\n        K = $, this.hasBeenReset = !0;\n      }\n    })), Object.defineProperty(u, \"size\", i({}, d, {\n      get: function() {\n        return j;\n      },\n      set: function(k) {\n        if (k &lt; 0 || k &gt; 100)\n          throw new Error(\"Size must be between 0 and 100.\");\n        j = k, this.hasBeenReset = !0;\n      }\n    })), Object.defineProperty(u, \"align\", i({}, d, {\n      get: function() {\n        return C;\n      },\n      set: function(k) {\n        const $ = n(k);\n        if (!$)\n          throw new SyntaxError(\"An invalid or illegal string was specified.\");\n        C = $, this.hasBeenReset = !0;\n      }\n    })), u.displayState = void 0;\n  }\n  return o.prototype.getCueAsHTML = function() {\n    return self.WebVTT.convertCueToDOMTree(self, this.text);\n  }, o;\n})();\nclass Mw {\n  decode(e, t) {\n    if (!e)\n      return \"\";\n    if (typeof e != \"string\")\n      throw new Error(\"Error - expected string data.\");\n    return decodeURIComponent(encodeURIComponent(e));\n  }\n}\nfunction jp(s) {\n  function e(r, n, i, o) {\n    return (r | 0) * 3600 + (n | 0) * 60 + (i | 0) + parseFloat(o || 0);\n  }\n  const t = s.match(/^(?:(\\d+):)?(\\d{2}):(\\d{2})(\\.\\d+)?/);\n  return t ? parseFloat(t[2]) &gt; 59 ? e(t[2], t[3], 0, t[4]) : e(t[1], t[2], t[3], t[4]) : null;\n}\nclass Ow {\n  constructor() {\n    this.values = /* @__PURE__ */ Object.create(null);\n  }\n  // Only accept the first assignment to any key.\n  set(e, t) {\n    !this.get(e) &amp;&amp; t !== \"\" &amp;&amp; (this.values[e] = t);\n  }\n  // Return the value for a key, or a default value.\n  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n  // a number of possible default values as properties where 'defaultKey' is\n  // the key of the property that will be chosen; otherwise it's assumed to be\n  // a single value.\n  get(e, t, r) {\n    return r ? this.has(e) ? this.values[e] : t[r] : this.has(e) ? this.values[e] : t;\n  }\n  // Check whether we have a value for a key.\n  has(e) {\n    return e in this.values;\n  }\n  // Accept a setting if its one of the given alternatives.\n  alt(e, t, r) {\n    for (let n = 0; n &lt; r.length; ++n)\n      if (t === r[n]) {\n        this.set(e, t);\n        break;\n      }\n  }\n  // Accept a setting if its a valid (signed) integer.\n  integer(e, t) {\n    /^-?\\d+$/.test(t) &amp;&amp; this.set(e, parseInt(t, 10));\n  }\n  // Accept a setting if its a valid percentage.\n  percent(e, t) {\n    if (/^([\\d]{1,3})(\\.[\\d]*)?%$/.test(t)) {\n      const r = parseFloat(t);\n      if (r &gt;= 0 &amp;&amp; r &lt;= 100)\n        return this.set(e, r), !0;\n    }\n    return !1;\n  }\n}\nfunction Kp(s, e, t, r) {\n  const n = r ? s.split(r) : [s];\n  for (const i in n) {\n    if (typeof n[i] != \"string\")\n      continue;\n    const o = n[i].split(t);\n    if (o.length !== 2)\n      continue;\n    const a = o[0], l = o[1];\n    e(a, l);\n  }\n}\nconst bc = new Ou(0, 0, \"\"), to = bc.align === \"middle\" ? \"middle\" : \"center\";\nfunction Bw(s, e, t) {\n  const r = s;\n  function n() {\n    const a = jp(s);\n    if (a === null)\n      throw new Error(\"Malformed timestamp: \" + r);\n    return s = s.replace(/^[^\\sa-zA-Z-]+/, \"\"), a;\n  }\n  function i(a, l) {\n    const c = new Ow();\n    Kp(a, function(h, f) {\n      let p;\n      switch (h) {\n        case \"region\":\n          for (let y = t.length - 1; y &gt;= 0; y--)\n            if (t[y].id === f) {\n              c.set(h, t[y].region);\n              break;\n            }\n          break;\n        case \"vertical\":\n          c.alt(h, f, [\"rl\", \"lr\"]);\n          break;\n        case \"line\":\n          p = f.split(\",\"), c.integer(h, p[0]), c.percent(h, p[0]) &amp;&amp; c.set(\"snapToLines\", !1), c.alt(h, p[0], [\"auto\"]), p.length === 2 &amp;&amp; c.alt(\"lineAlign\", p[1], [\"start\", to, \"end\"]);\n          break;\n        case \"position\":\n          p = f.split(\",\"), c.percent(h, p[0]), p.length === 2 &amp;&amp; c.alt(\"positionAlign\", p[1], [\"start\", to, \"end\", \"line-left\", \"line-right\", \"auto\"]);\n          break;\n        case \"size\":\n          c.percent(h, f);\n          break;\n        case \"align\":\n          c.alt(h, f, [\"start\", to, \"end\", \"left\", \"right\"]);\n          break;\n      }\n    }, /:/, /\\s/), l.region = c.get(\"region\", null), l.vertical = c.get(\"vertical\", \"\");\n    let u = c.get(\"line\", \"auto\");\n    u === \"auto\" &amp;&amp; bc.line === -1 &amp;&amp; (u = -1), l.line = u, l.lineAlign = c.get(\"lineAlign\", \"start\"), l.snapToLines = c.get(\"snapToLines\", !0), l.size = c.get(\"size\", 100), l.align = c.get(\"align\", to);\n    let d = c.get(\"position\", \"auto\");\n    d === \"auto\" &amp;&amp; bc.position === 50 &amp;&amp; (d = l.align === \"start\" || l.align === \"left\" ? 0 : l.align === \"end\" || l.align === \"right\" ? 100 : 50), l.position = d;\n  }\n  function o() {\n    s = s.replace(/^\\s+/, \"\");\n  }\n  if (o(), e.startTime = n(), o(), s.slice(0, 3) !== \"--&gt;\")\n    throw new Error(\"Malformed time stamp (time stamps must be separated by '--&gt;'): \" + r);\n  s = s.slice(3), o(), e.endTime = n(), o(), i(s, e);\n}\nfunction Hp(s) {\n  return s.replace(/&lt;br(?: \\/)?&gt;/gi, `\n`);\n}\nclass Fw {\n  constructor() {\n    this.state = \"INITIAL\", this.buffer = \"\", this.decoder = new Mw(), this.regionList = [], this.cue = null, this.oncue = void 0, this.onparsingerror = void 0, this.onflush = void 0;\n  }\n  parse(e) {\n    const t = this;\n    e &amp;&amp; (t.buffer += t.decoder.decode(e, {\n      stream: !0\n    }));\n    function r() {\n      let i = t.buffer, o = 0;\n      for (i = Hp(i); o &lt; i.length &amp;&amp; i[o] !== \"\\r\" &amp;&amp; i[o] !== `\n`; )\n        ++o;\n      const a = i.slice(0, o);\n      return i[o] === \"\\r\" &amp;&amp; ++o, i[o] === `\n` &amp;&amp; ++o, t.buffer = i.slice(o), a;\n    }\n    function n(i) {\n      Kp(i, function(o, a) {\n      }, /:/);\n    }\n    try {\n      let i = \"\";\n      if (t.state === \"INITIAL\") {\n        if (!/\\r\\n|\\n/.test(t.buffer))\n          return this;\n        i = r();\n        const a = i.match(/^()?WEBVTT([ \\t].*)?$/);\n        if (!(a != null &amp;&amp; a[0]))\n          throw new Error(\"Malformed WebVTT signature.\");\n        t.state = \"HEADER\";\n      }\n      let o = !1;\n      for (; t.buffer; ) {\n        if (!/\\r\\n|\\n/.test(t.buffer))\n          return this;\n        switch (o ? o = !1 : i = r(), t.state) {\n          case \"HEADER\":\n            /:/.test(i) ? n(i) : i || (t.state = \"ID\");\n            continue;\n          case \"NOTE\":\n            i || (t.state = \"ID\");\n            continue;\n          case \"ID\":\n            if (/^NOTE($|[ \\t])/.test(i)) {\n              t.state = \"NOTE\";\n              break;\n            }\n            if (!i)\n              continue;\n            if (t.cue = new Ou(0, 0, \"\"), t.state = \"CUE\", i.indexOf(\"--&gt;\") === -1) {\n              t.cue.id = i;\n              continue;\n            }\n          // Process line as start of a cue.\n          /* falls through */\n          case \"CUE\":\n            if (!t.cue) {\n              t.state = \"BADCUE\";\n              continue;\n            }\n            try {\n              Bw(i, t.cue, t.regionList);\n            } catch {\n              t.cue = null, t.state = \"BADCUE\";\n              continue;\n            }\n            t.state = \"CUETEXT\";\n            continue;\n          case \"CUETEXT\":\n            {\n              const a = i.indexOf(\"--&gt;\") !== -1;\n              if (!i || a &amp;&amp; (o = !0)) {\n                t.oncue &amp;&amp; t.cue &amp;&amp; t.oncue(t.cue), t.cue = null, t.state = \"ID\";\n                continue;\n              }\n              if (t.cue === null)\n                continue;\n              t.cue.text &amp;&amp; (t.cue.text += `\n`), t.cue.text += i;\n            }\n            continue;\n          case \"BADCUE\":\n            i || (t.state = \"ID\");\n        }\n      }\n    } catch {\n      t.state === \"CUETEXT\" &amp;&amp; t.cue &amp;&amp; t.oncue &amp;&amp; t.oncue(t.cue), t.cue = null, t.state = t.state === \"INITIAL\" ? \"BADWEBVTT\" : \"BADCUE\";\n    }\n    return this;\n  }\n  flush() {\n    const e = this;\n    try {\n      if ((e.cue || e.state === \"HEADER\") &amp;&amp; (e.buffer += `\n\n`, e.parse()), e.state === \"INITIAL\" || e.state === \"BADWEBVTT\")\n        throw new Error(\"Malformed WebVTT signature.\");\n    } catch (t) {\n      e.onparsingerror &amp;&amp; e.onparsingerror(t);\n    }\n    return e.onflush &amp;&amp; e.onflush(), this;\n  }\n}\nconst Nw = /\\r\\n|\\n\\r|\\n|\\r/g, Al = function(e, t, r = 0) {\n  return e.slice(r, r + t.length) === t;\n}, Uw = function(e) {\n  let t = parseInt(e.slice(-3));\n  const r = parseInt(e.slice(-6, -4)), n = parseInt(e.slice(-9, -7)), i = e.length &gt; 9 ? parseInt(e.substring(0, e.indexOf(\":\"))) : 0;\n  if (!ue(t) || !ue(r) || !ue(n) || !ue(i))\n    throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`);\n  return t += 1e3 * r, t += 60 * 1e3 * n, t += 3600 * 1e3 * i, t;\n};\nfunction Bu(s, e, t) {\n  return Xn(s.toString()) + Xn(e.toString()) + Xn(t);\n}\nconst $w = function(e, t, r) {\n  let n = e[t], i = e[n.prevCC];\n  if (!i || !i.new &amp;&amp; n.new) {\n    e.ccOffset = e.presentationOffset = n.start, n.new = !1;\n    return;\n  }\n  for (; (o = i) != null &amp;&amp; o.new; ) {\n    var o;\n    e.ccOffset += n.start - i.start, n.new = !1, n = i, i = e[n.prevCC];\n  }\n  e.presentationOffset = r;\n};\nfunction Gw(s, e, t, r, n, i, o) {\n  const a = new Fw(), l = Tr(new Uint8Array(s)).trim().replace(Nw, `\n`).split(`\n`), c = [], u = e ? WT(e.baseTime, e.timescale) : 0;\n  let d = \"00:00.000\", h = 0, f = 0, p, y = !0;\n  a.oncue = function(E) {\n    const b = t[r];\n    let R = t.ccOffset;\n    const A = (h - u) / 9e4;\n    if (b != null &amp;&amp; b.new &amp;&amp; (f !== void 0 ? R = t.ccOffset = b.start : $w(t, r, A)), A) {\n      if (!e) {\n        p = new Error(\"Missing initPTS for VTT MPEGTS\");\n        return;\n      }\n      R = A - t.presentationOffset;\n    }\n    const F = E.endTime - E.startTime, M = Ar((E.startTime + R - f) * 9e4, n * 9e4) / 9e4;\n    E.startTime = Math.max(M, 0), E.endTime = Math.max(M + F, 0);\n    const H = E.text.trim();\n    E.text = decodeURIComponent(encodeURIComponent(H)), E.id || (E.id = Bu(E.startTime, E.endTime, H)), E.endTime &gt; 0 &amp;&amp; c.push(E);\n  }, a.onparsingerror = function(E) {\n    p = E;\n  }, a.onflush = function() {\n    if (p) {\n      o(p);\n      return;\n    }\n    i(c);\n  }, l.forEach((E) =&gt; {\n    if (y)\n      if (Al(E, \"X-TIMESTAMP-MAP=\")) {\n        y = !1, E.slice(16).split(\",\").forEach((b) =&gt; {\n          Al(b, \"LOCAL:\") ? d = b.slice(6) : Al(b, \"MPEGTS:\") &amp;&amp; (h = parseInt(b.slice(7)));\n        });\n        try {\n          f = Uw(d) / 1e3;\n        } catch (b) {\n          p = b;\n        }\n        return;\n      } else E === \"\" &amp;&amp; (y = !1);\n    a.parse(E + `\n`);\n  }), a.flush();\n}\nconst Il = \"stpp.ttml.im1t\", qp = /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/, Wp = /^(\\d*(?:\\.\\d*)?)(h|m|s|ms|f|t)$/, Vw = {\n  left: \"start\",\n  center: \"center\",\n  right: \"end\",\n  start: \"start\",\n  end: \"end\"\n};\nfunction rf(s, e, t, r) {\n  const n = Ge(new Uint8Array(s), [\"mdat\"]);\n  if (n.length === 0) {\n    r(new Error(\"Could not parse IMSC1 mdat\"));\n    return;\n  }\n  const i = n.map((a) =&gt; Tr(a)), o = qT(e.baseTime, 1, e.timescale);\n  try {\n    i.forEach((a) =&gt; t(jw(a, o)));\n  } catch (a) {\n    r(a);\n  }\n}\nfunction jw(s, e) {\n  const n = new DOMParser().parseFromString(s, \"text/xml\").getElementsByTagName(\"tt\")[0];\n  if (!n)\n    throw new Error(\"Invalid ttml\");\n  const i = {\n    frameRate: 30,\n    subFrameRate: 1,\n    frameRateMultiplier: 0,\n    tickRate: 0\n  }, o = Object.keys(i).reduce((d, h) =&gt; (d[h] = n.getAttribute(`ttp:${h}`) || i[h], d), {}), a = n.getAttribute(\"xml:space\") !== \"preserve\", l = sf(_l(n, \"styling\", \"style\")), c = sf(_l(n, \"layout\", \"region\")), u = _l(n, \"body\", \"[begin]\");\n  return [].map.call(u, (d) =&gt; {\n    const h = zp(d, a);\n    if (!h || !d.hasAttribute(\"begin\"))\n      return null;\n    const f = Ll(d.getAttribute(\"begin\"), o), p = Ll(d.getAttribute(\"dur\"), o);\n    let y = Ll(d.getAttribute(\"end\"), o);\n    if (f === null)\n      throw nf(d);\n    if (y === null) {\n      if (p === null)\n        throw nf(d);\n      y = f + p;\n    }\n    const E = new Ou(f - e, y - e, h);\n    E.id = Bu(E.startTime, E.endTime, E.text);\n    const b = c[d.getAttribute(\"region\")], R = l[d.getAttribute(\"style\")], A = Kw(b, R, l), {\n      textAlign: F\n    } = A;\n    if (F) {\n      const M = Vw[F];\n      M &amp;&amp; (E.lineAlign = M), E.align = F;\n    }\n    return nt(E, A), E;\n  }).filter((d) =&gt; d !== null);\n}\nfunction _l(s, e, t) {\n  const r = s.getElementsByTagName(e)[0];\n  return r ? [].slice.call(r.querySelectorAll(t)) : [];\n}\nfunction sf(s) {\n  return s.reduce((e, t) =&gt; {\n    const r = t.getAttribute(\"xml:id\");\n    return r &amp;&amp; (e[r] = t), e;\n  }, {});\n}\nfunction zp(s, e) {\n  return [].slice.call(s.childNodes).reduce((t, r, n) =&gt; {\n    var i;\n    return r.nodeName === \"br\" &amp;&amp; n ? t + `\n` : (i = r.childNodes) != null &amp;&amp; i.length ? zp(r, e) : e ? t + r.textContent.trim().replace(/\\s+/g, \" \") : t + r.textContent;\n  }, \"\");\n}\nfunction Kw(s, e, t) {\n  const r = \"http://www.w3.org/ns/ttml#styling\";\n  let n = null;\n  const i = [\n    \"displayAlign\",\n    \"textAlign\",\n    \"color\",\n    \"backgroundColor\",\n    \"fontSize\",\n    \"fontFamily\"\n    // 'fontWeight',\n    // 'lineHeight',\n    // 'wrapOption',\n    // 'fontStyle',\n    // 'direction',\n    // 'writingMode'\n  ], o = s != null &amp;&amp; s.hasAttribute(\"style\") ? s.getAttribute(\"style\") : null;\n  return o &amp;&amp; t.hasOwnProperty(o) &amp;&amp; (n = t[o]), i.reduce((a, l) =&gt; {\n    const c = Rl(e, r, l) || Rl(s, r, l) || Rl(n, r, l);\n    return c &amp;&amp; (a[l] = c), a;\n  }, {});\n}\nfunction Rl(s, e, t) {\n  return s &amp;&amp; s.hasAttributeNS(e, t) ? s.getAttributeNS(e, t) : null;\n}\nfunction nf(s) {\n  return new Error(`Could not parse ttml timestamp ${s}`);\n}\nfunction Ll(s, e) {\n  if (!s)\n    return null;\n  let t = jp(s);\n  return t === null &amp;&amp; (qp.test(s) ? t = Hw(s, e) : Wp.test(s) &amp;&amp; (t = qw(s, e))), t;\n}\nfunction Hw(s, e) {\n  const t = qp.exec(s), r = (t[4] | 0) + (t[5] | 0) / e.subFrameRate;\n  return (t[1] | 0) * 3600 + (t[2] | 0) * 60 + (t[3] | 0) + r / e.frameRate;\n}\nfunction qw(s, e) {\n  const t = Wp.exec(s), r = Number(t[1]);\n  switch (t[2]) {\n    case \"h\":\n      return r * 3600;\n    case \"m\":\n      return r * 60;\n    case \"ms\":\n      return r * 1e3;\n    case \"f\":\n      return r / e.frameRate;\n    case \"t\":\n      return r / e.tickRate;\n  }\n  return r;\n}\nclass ro {\n  constructor(e, t) {\n    this.timelineController = void 0, this.cueRanges = [], this.trackName = void 0, this.startTime = null, this.endTime = null, this.screen = null, this.timelineController = e, this.trackName = t;\n  }\n  dispatchCue() {\n    this.startTime !== null &amp;&amp; (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges), this.startTime = null);\n  }\n  newCue(e, t, r) {\n    (this.startTime === null || this.startTime &gt; e) &amp;&amp; (this.startTime = e), this.endTime = t, this.screen = r, this.timelineController.createCaptionsTrack(this.trackName);\n  }\n  reset() {\n    this.cueRanges = [], this.startTime = null;\n  }\n}\nclass Ww {\n  constructor(e) {\n    this.hls = void 0, this.media = null, this.config = void 0, this.enabled = !0, this.Cues = void 0, this.textTracks = [], this.tracks = [], this.initPTS = [], this.unparsedVttFrags = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.cea608Parser1 = void 0, this.cea608Parser2 = void 0, this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = af(), this.captionsProperties = void 0, this.hls = e, this.config = e.config, this.Cues = e.config.cueHandler, this.captionsProperties = {\n      textTrack1: {\n        label: this.config.captionsTextTrack1Label,\n        languageCode: this.config.captionsTextTrack1LanguageCode\n      },\n      textTrack2: {\n        label: this.config.captionsTextTrack2Label,\n        languageCode: this.config.captionsTextTrack2LanguageCode\n      },\n      textTrack3: {\n        label: this.config.captionsTextTrack3Label,\n        languageCode: this.config.captionsTextTrack3LanguageCode\n      },\n      textTrack4: {\n        label: this.config.captionsTextTrack4Label,\n        languageCode: this.config.captionsTextTrack4LanguageCode\n      }\n    }, e.on(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(I.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.on(I.FRAG_LOADING, this.onFragLoading, this), e.on(I.FRAG_LOADED, this.onFragLoaded, this), e.on(I.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.on(I.FRAG_DECRYPTED, this.onFragDecrypted, this), e.on(I.INIT_PTS_FOUND, this.onInitPtsFound, this), e.on(I.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.on(I.BUFFER_FLUSHING, this.onBufferFlushing, this);\n  }\n  destroy() {\n    const {\n      hls: e\n    } = this;\n    e.off(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(I.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this), e.off(I.FRAG_LOADING, this.onFragLoading, this), e.off(I.FRAG_LOADED, this.onFragLoaded, this), e.off(I.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this), e.off(I.FRAG_DECRYPTED, this.onFragDecrypted, this), e.off(I.INIT_PTS_FOUND, this.onInitPtsFound, this), e.off(I.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this), e.off(I.BUFFER_FLUSHING, this.onBufferFlushing, this), this.hls = this.config = this.media = null, this.cea608Parser1 = this.cea608Parser2 = void 0;\n  }\n  initCea608Parsers() {\n    const e = new ro(this, \"textTrack1\"), t = new ro(this, \"textTrack2\"), r = new ro(this, \"textTrack3\"), n = new ro(this, \"textTrack4\");\n    this.cea608Parser1 = new tf(1, e, t), this.cea608Parser2 = new tf(3, r, n);\n  }\n  addCues(e, t, r, n, i) {\n    let o = !1;\n    for (let a = i.length; a--; ) {\n      const l = i[a], c = zw(l[0], l[1], t, r);\n      if (c &gt;= 0 &amp;&amp; (l[0] = Math.min(l[0], t), l[1] = Math.max(l[1], r), o = !0, c / (r - t) &gt; 0.5))\n        return;\n    }\n    if (o || i.push([t, r]), this.config.renderTextTracksNatively) {\n      const a = this.captionsTracks[e];\n      this.Cues.newCue(a, t, r, n);\n    } else {\n      const a = this.Cues.newCue(null, t, r, n);\n      this.hls.trigger(I.CUES_PARSED, {\n        type: \"captions\",\n        cues: a,\n        track: e\n      });\n    }\n  }\n  // Triggered when an initial PTS is found; used for synchronisation of WebVTT.\n  onInitPtsFound(e, {\n    frag: t,\n    id: r,\n    initPTS: n,\n    timescale: i,\n    trackId: o\n  }) {\n    const {\n      unparsedVttFrags: a\n    } = this;\n    r === pe.MAIN &amp;&amp; (this.initPTS[t.cc] = {\n      baseTime: n,\n      timescale: i,\n      trackId: o\n    }), a.length &amp;&amp; (this.unparsedVttFrags = [], a.forEach((l) =&gt; {\n      this.initPTS[l.frag.cc] ? this.onFragLoaded(I.FRAG_LOADED, l) : this.hls.trigger(I.SUBTITLE_FRAG_PROCESSED, {\n        success: !1,\n        frag: l.frag,\n        error: new Error(\"Subtitle discontinuity domain does not match main\")\n      });\n    }));\n  }\n  getExistingTrack(e, t) {\n    const {\n      media: r\n    } = this;\n    if (r)\n      for (let n = 0; n &lt; r.textTracks.length; n++) {\n        const i = r.textTracks[n];\n        if (of(i, {\n          name: e,\n          lang: t,\n          characteristics: \"transcribes-spoken-dialog,describes-music-and-sound\"\n        }))\n          return i;\n      }\n    return null;\n  }\n  createCaptionsTrack(e) {\n    this.config.renderTextTracksNatively ? this.createNativeTrack(e) : this.createNonNativeTrack(e);\n  }\n  createNativeTrack(e) {\n    if (this.captionsTracks[e])\n      return;\n    const {\n      captionsProperties: t,\n      captionsTracks: r,\n      media: n\n    } = this, {\n      label: i,\n      languageCode: o\n    } = t[e], a = this.getExistingTrack(i, o);\n    if (a)\n      r[e] = a, Sn(r[e]), Np(r[e], n);\n    else {\n      const l = this.createTextTrack(\"captions\", i, o);\n      l &amp;&amp; (l[e] = !0, r[e] = l);\n    }\n  }\n  createNonNativeTrack(e) {\n    if (this.nonNativeCaptionsTracks[e])\n      return;\n    const t = this.captionsProperties[e];\n    if (!t)\n      return;\n    const r = t.label, n = {\n      _id: e,\n      label: r,\n      kind: \"captions\",\n      default: t.media ? !!t.media.default : !1,\n      closedCaptions: t.media\n    };\n    this.nonNativeCaptionsTracks[e] = n, this.hls.trigger(I.NON_NATIVE_TEXT_TRACKS_FOUND, {\n      tracks: [n]\n    });\n  }\n  createTextTrack(e, t, r) {\n    const n = this.media;\n    if (n)\n      return n.addTextTrack(e, t, r);\n  }\n  onMediaAttaching(e, t) {\n    this.media = t.media, t.mediaSource || this._cleanTracks();\n  }\n  onMediaDetaching(e, t) {\n    const r = !!t.transferMedia;\n    if (this.media = null, r)\n      return;\n    const {\n      captionsTracks: n\n    } = this;\n    Object.keys(n).forEach((i) =&gt; {\n      Sn(n[i]), delete n[i];\n    }), this.nonNativeCaptionsTracks = {};\n  }\n  onManifestLoading() {\n    this.lastCc = -1, this.lastSn = -1, this.lastPartIndex = -1, this.prevCC = -1, this.vttCCs = af(), this._cleanTracks(), this.tracks = [], this.captionsTracks = {}, this.nonNativeCaptionsTracks = {}, this.textTracks = [], this.unparsedVttFrags = [], this.initPTS = [], this.cea608Parser1 &amp;&amp; this.cea608Parser2 &amp;&amp; (this.cea608Parser1.reset(), this.cea608Parser2.reset());\n  }\n  _cleanTracks() {\n    const {\n      media: e\n    } = this;\n    if (!e)\n      return;\n    const t = e.textTracks;\n    if (t)\n      for (let r = 0; r &lt; t.length; r++)\n        Sn(t[r]);\n  }\n  onSubtitleTracksUpdated(e, t) {\n    const r = t.subtitleTracks || [], n = r.some((i) =&gt; i.textCodec === Il);\n    if (this.config.enableWebVTT || n &amp;&amp; this.config.enableIMSC1) {\n      if (Ap(this.tracks, r)) {\n        this.tracks = r;\n        return;\n      }\n      if (this.textTracks = [], this.tracks = r, this.config.renderTextTracksNatively) {\n        const o = this.media, a = o ? Eo(o.textTracks) : null;\n        if (this.tracks.forEach((l, c) =&gt; {\n          let u;\n          if (a) {\n            let d = null;\n            for (let h = 0; h &lt; a.length; h++)\n              if (a[h] &amp;&amp; of(a[h], l)) {\n                d = a[h], a[h] = null;\n                break;\n              }\n            d &amp;&amp; (u = d);\n          }\n          if (u)\n            Sn(u);\n          else {\n            const d = Yp(l);\n            u = this.createTextTrack(d, l.name, l.lang), u &amp;&amp; (u.mode = \"disabled\");\n          }\n          u &amp;&amp; this.textTracks.push(u);\n        }), a != null &amp;&amp; a.length) {\n          const l = a.filter((c) =&gt; c !== null).map((c) =&gt; c.label);\n          l.length &amp;&amp; this.hls.logger.warn(`Media element contains unused subtitle tracks: ${l.join(\", \")}. Replace media element for each source to clear TextTracks and captions menu.`);\n        }\n      } else if (this.tracks.length) {\n        const o = this.tracks.map((a) =&gt; ({\n          label: a.name,\n          kind: a.type.toLowerCase(),\n          default: a.default,\n          subtitleTrack: a\n        }));\n        this.hls.trigger(I.NON_NATIVE_TEXT_TRACKS_FOUND, {\n          tracks: o\n        });\n      }\n    }\n  }\n  onManifestLoaded(e, t) {\n    this.config.enableCEA708Captions &amp;&amp; t.captions &amp;&amp; t.captions.forEach((r) =&gt; {\n      const n = /(?:CC|SERVICE)([1-4])/.exec(r.instreamId);\n      if (!n)\n        return;\n      const i = `textTrack${n[1]}`, o = this.captionsProperties[i];\n      o &amp;&amp; (o.label = r.name, r.lang &amp;&amp; (o.languageCode = r.lang), o.media = r);\n    });\n  }\n  closedCaptionsForLevel(e) {\n    const t = this.hls.levels[e.level];\n    return t == null ? void 0 : t.attrs[\"CLOSED-CAPTIONS\"];\n  }\n  onFragLoading(e, t) {\n    if (this.enabled &amp;&amp; t.frag.type === pe.MAIN) {\n      var r, n;\n      const {\n        cea608Parser1: i,\n        cea608Parser2: o,\n        lastSn: a\n      } = this, {\n        cc: l,\n        sn: c\n      } = t.frag, u = (r = (n = t.part) == null ? void 0 : n.index) != null ? r : -1;\n      i &amp;&amp; o &amp;&amp; (c !== a + 1 || c === a &amp;&amp; u !== this.lastPartIndex + 1 || l !== this.lastCc) &amp;&amp; (i.reset(), o.reset()), this.lastCc = l, this.lastSn = c, this.lastPartIndex = u;\n    }\n  }\n  onFragLoaded(e, t) {\n    const {\n      frag: r,\n      payload: n\n    } = t;\n    if (r.type === pe.SUBTITLE)\n      if (n.byteLength) {\n        const i = r.decryptdata, o = \"stats\" in t;\n        if (i == null || !i.encrypted || o) {\n          const a = this.tracks[r.level], l = this.vttCCs;\n          l[r.cc] || (l[r.cc] = {\n            start: r.start,\n            prevCC: this.prevCC,\n            new: !0\n          }, this.prevCC = r.cc), a &amp;&amp; a.textCodec === Il ? this._parseIMSC1(r, n) : this._parseVTTs(t);\n        }\n      } else\n        this.hls.trigger(I.SUBTITLE_FRAG_PROCESSED, {\n          success: !1,\n          frag: r,\n          error: new Error(\"Empty subtitle payload\")\n        });\n  }\n  _parseIMSC1(e, t) {\n    const r = this.hls;\n    rf(t, this.initPTS[e.cc], (n) =&gt; {\n      this._appendCues(n, e.level), r.trigger(I.SUBTITLE_FRAG_PROCESSED, {\n        success: !0,\n        frag: e\n      });\n    }, (n) =&gt; {\n      r.logger.log(`Failed to parse IMSC1: ${n}`), r.trigger(I.SUBTITLE_FRAG_PROCESSED, {\n        success: !1,\n        frag: e,\n        error: n\n      });\n    });\n  }\n  _parseVTTs(e) {\n    var t;\n    const {\n      frag: r,\n      payload: n\n    } = e, {\n      initPTS: i,\n      unparsedVttFrags: o\n    } = this, a = i.length - 1;\n    if (!i[r.cc] &amp;&amp; a === -1) {\n      o.push(e);\n      return;\n    }\n    const l = this.hls, c = (t = r.initSegment) != null &amp;&amp; t.data ? _r(r.initSegment.data, new Uint8Array(n)).buffer : n;\n    Gw(c, this.initPTS[r.cc], this.vttCCs, r.cc, r.start, (u) =&gt; {\n      this._appendCues(u, r.level), l.trigger(I.SUBTITLE_FRAG_PROCESSED, {\n        success: !0,\n        frag: r\n      });\n    }, (u) =&gt; {\n      const d = u.message === \"Missing initPTS for VTT MPEGTS\";\n      d ? o.push(e) : this._fallbackToIMSC1(r, n), l.logger.log(`Failed to parse VTT cue: ${u}`), !(d &amp;&amp; a &gt; r.cc) &amp;&amp; l.trigger(I.SUBTITLE_FRAG_PROCESSED, {\n        success: !1,\n        frag: r,\n        error: u\n      });\n    });\n  }\n  _fallbackToIMSC1(e, t) {\n    const r = this.tracks[e.level];\n    r.textCodec || rf(t, this.initPTS[e.cc], () =&gt; {\n      r.textCodec = Il, this._parseIMSC1(e, t);\n    }, () =&gt; {\n      r.textCodec = \"wvtt\";\n    });\n  }\n  _appendCues(e, t) {\n    const r = this.hls;\n    if (this.config.renderTextTracksNatively) {\n      const n = this.textTracks[t];\n      if (!n || n.mode === \"disabled\")\n        return;\n      e.forEach((i) =&gt; Up(n, i));\n    } else {\n      const n = this.tracks[t];\n      if (!n)\n        return;\n      const i = n.default ? \"default\" : \"subtitles\" + t;\n      r.trigger(I.CUES_PARSED, {\n        type: \"subtitles\",\n        cues: e,\n        track: i\n      });\n    }\n  }\n  onFragDecrypted(e, t) {\n    const {\n      frag: r\n    } = t;\n    r.type === pe.SUBTITLE &amp;&amp; this.onFragLoaded(I.FRAG_LOADED, t);\n  }\n  onSubtitleTracksCleared() {\n    this.tracks = [], this.captionsTracks = {};\n  }\n  onFragParsingUserdata(e, t) {\n    if (!this.enabled || !this.config.enableCEA708Captions)\n      return;\n    const {\n      frag: r,\n      samples: n\n    } = t;\n    if (!(r.type === pe.MAIN &amp;&amp; this.closedCaptionsForLevel(r) === \"NONE\"))\n      for (let i = 0; i &lt; n.length; i++) {\n        const o = n[i].bytes;\n        if (o) {\n          this.cea608Parser1 || this.initCea608Parsers();\n          const a = this.extractCea608Data(o);\n          this.cea608Parser1.addData(n[i].pts, a[0]), this.cea608Parser2.addData(n[i].pts, a[1]);\n        }\n      }\n  }\n  onBufferFlushing(e, {\n    startOffset: t,\n    endOffset: r,\n    endOffsetSubtitles: n,\n    type: i\n  }) {\n    const {\n      media: o\n    } = this;\n    if (!(!o || o.currentTime &lt; r)) {\n      if (!i || i === \"video\") {\n        const {\n          captionsTracks: a\n        } = this;\n        Object.keys(a).forEach((l) =&gt; Sc(a[l], t, r));\n      }\n      if (this.config.renderTextTracksNatively &amp;&amp; t === 0 &amp;&amp; n !== void 0) {\n        const {\n          textTracks: a\n        } = this;\n        Object.keys(a).forEach((l) =&gt; Sc(a[l], t, n));\n      }\n    }\n  }\n  extractCea608Data(e) {\n    const t = [[], []], r = e[0] &amp; 31;\n    let n = 2;\n    for (let i = 0; i &lt; r; i++) {\n      const o = e[n++], a = 127 &amp; e[n++], l = 127 &amp; e[n++];\n      if (a === 0 &amp;&amp; l === 0)\n        continue;\n      if ((4 &amp; o) !== 0) {\n        const u = 3 &amp; o;\n        (u === 0 || u === 1) &amp;&amp; (t[u].push(a), t[u].push(l));\n      }\n    }\n    return t;\n  }\n}\nfunction Yp(s) {\n  return s.characteristics &amp;&amp; /transcribes-spoken-dialog/gi.test(s.characteristics) &amp;&amp; /describes-music-and-sound/gi.test(s.characteristics) ? \"captions\" : \"subtitles\";\n}\nfunction of(s, e) {\n  return !!s &amp;&amp; s.kind === Yp(e) &amp;&amp; yc(e, s);\n}\nfunction zw(s, e, t, r) {\n  return Math.min(e, r) - Math.max(s, t);\n}\nfunction af() {\n  return {\n    ccOffset: 0,\n    presentationOffset: 0,\n    0: {\n      start: 0,\n      prevCC: -1,\n      new: !0\n    }\n  };\n}\nconst Yw = /\\s/, Zw = {\n  newCue(s, e, t, r) {\n    const n = [];\n    let i, o, a, l, c;\n    const u = self.VTTCue || self.TextTrackCue;\n    for (let h = 0; h &lt; r.rows.length; h++)\n      if (i = r.rows[h], a = !0, l = 0, c = \"\", !i.isEmpty()) {\n        var d;\n        for (let y = 0; y &lt; i.chars.length; y++)\n          Yw.test(i.chars[y].uchar) &amp;&amp; a ? l++ : (c += i.chars[y].uchar, a = !1);\n        i.cueStartTime = e, e === t &amp;&amp; (t += 1e-4), l &gt;= 16 ? l-- : l++;\n        const f = Hp(c.trim()), p = Bu(e, t, f);\n        s != null &amp;&amp; (d = s.cues) != null &amp;&amp; d.getCueById(p) || (o = new u(e, t, f), o.id = p, o.line = h + 1, o.align = \"left\", o.position = 10 + Math.min(80, Math.floor(l * 8 / 32) * 10), n.push(o));\n      }\n    return s &amp;&amp; n.length &amp;&amp; (n.sort((h, f) =&gt; h.line === \"auto\" || f.line === \"auto\" ? 0 : h.line &gt; 8 &amp;&amp; f.line &gt; 8 ? f.line - h.line : h.line - f.line), n.forEach((h) =&gt; Up(s, h))), n;\n  }\n};\nfunction Xw() {\n  if (\n    // @ts-ignore\n    self.fetch &amp;&amp; self.AbortController &amp;&amp; self.ReadableStream &amp;&amp; self.Request\n  )\n    try {\n      return new self.ReadableStream({}), !0;\n    } catch {\n    }\n  return !1;\n}\nconst Jw = /(\\d+)-(\\d+)\\/(\\d+)/;\nclass lf {\n  constructor(e) {\n    this.fetchSetup = void 0, this.requestTimeout = void 0, this.request = null, this.response = null, this.controller = void 0, this.context = null, this.config = null, this.callbacks = null, this.stats = void 0, this.loader = null, this.fetchSetup = e.fetchSetup || rA, this.controller = new self.AbortController(), this.stats = new fu();\n  }\n  destroy() {\n    this.loader = this.callbacks = this.context = this.config = this.request = null, this.abortInternal(), this.response = null, this.fetchSetup = this.controller = this.stats = null;\n  }\n  abortInternal() {\n    this.controller &amp;&amp; !this.stats.loading.end &amp;&amp; (this.stats.aborted = !0, this.controller.abort());\n  }\n  abort() {\n    var e;\n    this.abortInternal(), (e = this.callbacks) != null &amp;&amp; e.onAbort &amp;&amp; this.callbacks.onAbort(this.stats, this.context, this.response);\n  }\n  load(e, t, r) {\n    const n = this.stats;\n    if (n.loading.start)\n      throw new Error(\"Loader can only be used once.\");\n    n.loading.start = self.performance.now();\n    const i = Qw(e, this.controller.signal), o = e.responseType === \"arraybuffer\", a = o ? \"byteLength\" : \"length\", {\n      maxTimeToFirstByteMs: l,\n      maxLoadTimeMs: c\n    } = t.loadPolicy;\n    this.context = e, this.config = t, this.callbacks = r, this.request = this.fetchSetup(e, i), self.clearTimeout(this.requestTimeout), t.timeout = l &amp;&amp; ue(l) ? l : c, this.requestTimeout = self.setTimeout(() =&gt; {\n      this.callbacks &amp;&amp; (this.abortInternal(), this.callbacks.onTimeout(n, e, this.response));\n    }, t.timeout), (xi(this.request) ? this.request.then(self.fetch) : self.fetch(this.request)).then((d) =&gt; {\n      var h;\n      this.response = this.loader = d;\n      const f = Math.max(self.performance.now(), n.loading.start);\n      if (self.clearTimeout(this.requestTimeout), t.timeout = c, this.requestTimeout = self.setTimeout(() =&gt; {\n        this.callbacks &amp;&amp; (this.abortInternal(), this.callbacks.onTimeout(n, e, this.response));\n      }, c - (f - n.loading.start)), !d.ok) {\n        const {\n          status: y,\n          statusText: E\n        } = d;\n        throw new sA(E || \"fetch, bad network response\", y, d);\n      }\n      n.loading.first = f, n.total = tA(d.headers) || n.total;\n      const p = (h = this.callbacks) == null ? void 0 : h.onProgress;\n      return p &amp;&amp; ue(t.highWaterMark) ? this.loadProgressively(d, n, e, t.highWaterMark, p) : o ? d.arrayBuffer() : e.responseType === \"json\" ? d.json() : d.text();\n    }).then((d) =&gt; {\n      var h, f;\n      const p = this.response;\n      if (!p)\n        throw new Error(\"loader destroyed\");\n      self.clearTimeout(this.requestTimeout), n.loading.end = Math.max(self.performance.now(), n.loading.first);\n      const y = d[a];\n      y &amp;&amp; (n.loaded = n.total = y);\n      const E = {\n        url: p.url,\n        data: d,\n        code: p.status\n      }, b = (h = this.callbacks) == null ? void 0 : h.onProgress;\n      b &amp;&amp; !ue(t.highWaterMark) &amp;&amp; b(n, e, d, p), (f = this.callbacks) == null || f.onSuccess(E, n, e, p);\n    }).catch((d) =&gt; {\n      var h;\n      if (self.clearTimeout(this.requestTimeout), n.aborted)\n        return;\n      const f = d &amp;&amp; d.code || 0, p = d ? d.message : null;\n      (h = this.callbacks) == null || h.onError({\n        code: f,\n        text: p\n      }, e, d ? d.details : null, n);\n    });\n  }\n  getCacheAge() {\n    let e = null;\n    if (this.response) {\n      const t = this.response.headers.get(\"age\");\n      e = t ? parseFloat(t) : null;\n    }\n    return e;\n  }\n  getResponseHeader(e) {\n    return this.response ? this.response.headers.get(e) : null;\n  }\n  loadProgressively(e, t, r, n = 0, i) {\n    const o = new ip(), a = e.body.getReader(), l = () =&gt; a.read().then((c) =&gt; {\n      if (c.done)\n        return o.dataLength &amp;&amp; i(t, r, o.flush().buffer, e), Promise.resolve(new ArrayBuffer(0));\n      const u = c.value, d = u.length;\n      return t.loaded += d, d &lt; n || o.dataLength ? (o.push(u), o.dataLength &gt;= n &amp;&amp; i(t, r, o.flush().buffer, e)) : i(t, r, u.buffer, e), l();\n    }).catch(() =&gt; Promise.reject());\n    return l();\n  }\n}\nfunction Qw(s, e) {\n  const t = {\n    method: \"GET\",\n    mode: \"cors\",\n    credentials: \"same-origin\",\n    signal: e,\n    headers: new self.Headers(nt({}, s.headers))\n  };\n  return s.rangeEnd &amp;&amp; t.headers.set(\"Range\", \"bytes=\" + s.rangeStart + \"-\" + String(s.rangeEnd - 1)), t;\n}\nfunction eA(s) {\n  const e = Jw.exec(s);\n  if (e)\n    return parseInt(e[2]) - parseInt(e[1]) + 1;\n}\nfunction tA(s) {\n  const e = s.get(\"Content-Range\");\n  if (e) {\n    const r = eA(e);\n    if (ue(r))\n      return r;\n  }\n  const t = s.get(\"Content-Length\");\n  if (t)\n    return parseInt(t);\n}\nfunction rA(s, e) {\n  return new self.Request(s.url, e);\n}\nclass sA extends Error {\n  constructor(e, t, r) {\n    super(e), this.code = void 0, this.details = void 0, this.code = t, this.details = r;\n  }\n}\nconst nA = /^age:\\s*[\\d.]+\\s*$/im;\nclass Zp {\n  constructor(e) {\n    this.xhrSetup = void 0, this.requestTimeout = void 0, this.retryTimeout = void 0, this.retryDelay = void 0, this.config = null, this.callbacks = null, this.context = null, this.loader = null, this.stats = void 0, this.xhrSetup = e &amp;&amp; e.xhrSetup || null, this.stats = new fu(), this.retryDelay = 0;\n  }\n  destroy() {\n    this.callbacks = null, this.abortInternal(), this.loader = null, this.config = null, this.context = null, this.xhrSetup = null;\n  }\n  abortInternal() {\n    const e = this.loader;\n    self.clearTimeout(this.requestTimeout), self.clearTimeout(this.retryTimeout), e &amp;&amp; (e.onreadystatechange = null, e.onprogress = null, e.readyState !== 4 &amp;&amp; (this.stats.aborted = !0, e.abort()));\n  }\n  abort() {\n    var e;\n    this.abortInternal(), (e = this.callbacks) != null &amp;&amp; e.onAbort &amp;&amp; this.callbacks.onAbort(this.stats, this.context, this.loader);\n  }\n  load(e, t, r) {\n    if (this.stats.loading.start)\n      throw new Error(\"Loader can only be used once.\");\n    this.stats.loading.start = self.performance.now(), this.context = e, this.config = t, this.callbacks = r, this.loadInternal();\n  }\n  loadInternal() {\n    const {\n      config: e,\n      context: t\n    } = this;\n    if (!e || !t)\n      return;\n    const r = this.loader = new self.XMLHttpRequest(), n = this.stats;\n    n.loading.first = 0, n.loaded = 0, n.aborted = !1;\n    const i = this.xhrSetup;\n    i ? Promise.resolve().then(() =&gt; {\n      if (!(this.loader !== r || this.stats.aborted))\n        return i(r, t.url);\n    }).catch((o) =&gt; {\n      if (!(this.loader !== r || this.stats.aborted))\n        return r.open(\"GET\", t.url, !0), i(r, t.url);\n    }).then(() =&gt; {\n      this.loader !== r || this.stats.aborted || this.openAndSendXhr(r, t, e);\n    }).catch((o) =&gt; {\n      var a;\n      (a = this.callbacks) == null || a.onError({\n        code: r.status,\n        text: o.message\n      }, t, r, n);\n    }) : this.openAndSendXhr(r, t, e);\n  }\n  openAndSendXhr(e, t, r) {\n    e.readyState || e.open(\"GET\", t.url, !0);\n    const n = t.headers, {\n      maxTimeToFirstByteMs: i,\n      maxLoadTimeMs: o\n    } = r.loadPolicy;\n    if (n)\n      for (const a in n)\n        e.setRequestHeader(a, n[a]);\n    t.rangeEnd &amp;&amp; e.setRequestHeader(\"Range\", \"bytes=\" + t.rangeStart + \"-\" + (t.rangeEnd - 1)), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = t.responseType, self.clearTimeout(this.requestTimeout), r.timeout = i &amp;&amp; ue(i) ? i : o, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), r.timeout), e.send();\n  }\n  readystatechange() {\n    const {\n      context: e,\n      loader: t,\n      stats: r\n    } = this;\n    if (!e || !t)\n      return;\n    const n = t.readyState, i = this.config;\n    if (!r.aborted &amp;&amp; n &gt;= 2 &amp;&amp; (r.loading.first === 0 &amp;&amp; (r.loading.first = Math.max(self.performance.now(), r.loading.start), i.timeout !== i.loadPolicy.maxLoadTimeMs &amp;&amp; (self.clearTimeout(this.requestTimeout), i.timeout = i.loadPolicy.maxLoadTimeMs, this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), i.loadPolicy.maxLoadTimeMs - (r.loading.first - r.loading.start)))), n === 4)) {\n      self.clearTimeout(this.requestTimeout), t.onreadystatechange = null, t.onprogress = null;\n      const c = t.status, u = t.responseType === \"text\" ? t.responseText : null;\n      if (c &gt;= 200 &amp;&amp; c &lt; 300) {\n        const p = u ?? t.response;\n        if (p != null) {\n          var o, a;\n          r.loading.end = Math.max(self.performance.now(), r.loading.first);\n          const y = t.responseType === \"arraybuffer\" ? p.byteLength : p.length;\n          r.loaded = r.total = y, r.bwEstimate = r.total * 8e3 / (r.loading.end - r.loading.first);\n          const E = (o = this.callbacks) == null ? void 0 : o.onProgress;\n          E &amp;&amp; E(r, e, p, t);\n          const b = {\n            url: t.responseURL,\n            data: p,\n            code: c\n          };\n          (a = this.callbacks) == null || a.onSuccess(b, r, e, t);\n          return;\n        }\n      }\n      const d = i.loadPolicy.errorRetry, h = r.retry, f = {\n        url: e.url,\n        data: void 0,\n        code: c\n      };\n      if (ta(d, h, !1, f))\n        this.retry(d);\n      else {\n        var l;\n        rt.error(`${c} while loading ${e.url}`), (l = this.callbacks) == null || l.onError({\n          code: c,\n          text: t.statusText\n        }, e, t, r);\n      }\n    }\n  }\n  loadtimeout() {\n    if (!this.config) return;\n    const e = this.config.loadPolicy.timeoutRetry, t = this.stats.retry;\n    if (ta(e, t, !0))\n      this.retry(e);\n    else {\n      var r;\n      rt.warn(`timeout while loading ${(r = this.context) == null ? void 0 : r.url}`);\n      const n = this.callbacks;\n      n &amp;&amp; (this.abortInternal(), n.onTimeout(this.stats, this.context, this.loader));\n    }\n  }\n  retry(e) {\n    const {\n      context: t,\n      stats: r\n    } = this;\n    this.retryDelay = yu(e, r.retry), r.retry++, rt.warn(`${status ? \"HTTP Status \" + status : \"Timeout\"} while loading ${t == null ? void 0 : t.url}, retrying ${r.retry}/${e.maxNumRetry} in ${this.retryDelay}ms`), this.abortInternal(), this.loader = null, self.clearTimeout(this.retryTimeout), this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);\n  }\n  loadprogress(e) {\n    const t = this.stats;\n    t.loaded = e.loaded, e.lengthComputable &amp;&amp; (t.total = e.total);\n  }\n  getCacheAge() {\n    let e = null;\n    if (this.loader &amp;&amp; nA.test(this.loader.getAllResponseHeaders())) {\n      const t = this.loader.getResponseHeader(\"age\");\n      e = t ? parseFloat(t) : null;\n    }\n    return e;\n  }\n  getResponseHeader(e) {\n    return this.loader &amp;&amp; new RegExp(`^${e}:\\\\s*[\\\\d.]+\\\\s*$`, \"im\").test(this.loader.getAllResponseHeaders()) ? this.loader.getResponseHeader(e) : null;\n  }\n}\nconst iA = {\n  maxTimeToFirstByteMs: 8e3,\n  maxLoadTimeMs: 2e4,\n  timeoutRetry: null,\n  errorRetry: null\n}, oA = tt(tt({\n  autoStartLoad: !0,\n  // used by stream-controller\n  startPosition: -1,\n  // used by stream-controller\n  defaultAudioCodec: void 0,\n  // used by stream-controller\n  debug: !1,\n  // used by logger\n  capLevelOnFPSDrop: !1,\n  // used by fps-controller\n  capLevelToPlayerSize: !1,\n  // used by cap-level-controller\n  ignoreDevicePixelRatio: !1,\n  // used by cap-level-controller\n  maxDevicePixelRatio: Number.POSITIVE_INFINITY,\n  // used by cap-level-controller\n  preferManagedMediaSource: !0,\n  initialLiveManifestSize: 1,\n  // used by stream-controller\n  maxBufferLength: 30,\n  // used by stream-controller\n  backBufferLength: 1 / 0,\n  // used by buffer-controller\n  frontBufferFlushThreshold: 1 / 0,\n  startOnSegmentBoundary: !1,\n  // used by stream-controller\n  maxBufferSize: 60 * 1e3 * 1e3,\n  // used by stream-controller\n  maxFragLookUpTolerance: 0.25,\n  // used by stream-controller\n  maxBufferHole: 0.1,\n  // used by stream-controller and gap-controller\n  detectStallWithCurrentTimeMs: 1250,\n  // used by gap-controller\n  highBufferWatchdogPeriod: 2,\n  // used by gap-controller\n  nudgeOffset: 0.1,\n  // used by gap-controller\n  nudgeMaxRetry: 3,\n  // used by gap-controller\n  nudgeOnVideoHole: !0,\n  // used by gap-controller\n  liveSyncMode: \"edge\",\n  // used by stream-controller\n  liveSyncDurationCount: 3,\n  // used by latency-controller\n  liveSyncOnStallIncrease: 1,\n  // used by latency-controller\n  liveMaxLatencyDurationCount: 1 / 0,\n  // used by latency-controller\n  liveSyncDuration: void 0,\n  // used by latency-controller\n  liveMaxLatencyDuration: void 0,\n  // used by latency-controller\n  maxLiveSyncPlaybackRate: 1,\n  // used by latency-controller\n  liveDurationInfinity: !1,\n  // used by buffer-controller\n  /**\n   * @deprecated use backBufferLength\n   */\n  liveBackBufferLength: null,\n  // used by buffer-controller\n  maxMaxBufferLength: 600,\n  // used by stream-controller\n  enableWorker: !0,\n  // used by transmuxer\n  workerPath: null,\n  // used by transmuxer\n  enableSoftwareAES: !0,\n  // used by decrypter\n  startLevel: void 0,\n  // used by level-controller\n  startFragPrefetch: !1,\n  // used by stream-controller\n  fpsDroppedMonitoringPeriod: 5e3,\n  // used by fps-controller\n  fpsDroppedMonitoringThreshold: 0.2,\n  // used by fps-controller\n  appendErrorMaxRetry: 3,\n  // used by buffer-controller\n  ignorePlaylistParsingErrors: !1,\n  loader: Zp,\n  // loader: FetchLoader,\n  fLoader: void 0,\n  // used by fragment-loader\n  pLoader: void 0,\n  // used by playlist-loader\n  xhrSetup: void 0,\n  // used by xhr-loader\n  licenseXhrSetup: void 0,\n  // used by eme-controller\n  licenseResponseCallback: void 0,\n  // used by eme-controller\n  abrController: yb,\n  bufferController: l2,\n  capLevelController: Du,\n  errorController: bb,\n  fpsController: cw,\n  stretchShortVideoTrack: !1,\n  // used by mp4-remuxer\n  maxAudioFramesDrift: 1,\n  // used by mp4-remuxer\n  forceKeyFrameOnDiscontinuity: !0,\n  // used by ts-demuxer\n  abrEwmaFastLive: 3,\n  // used by abr-controller\n  abrEwmaSlowLive: 9,\n  // used by abr-controller\n  abrEwmaFastVoD: 3,\n  // used by abr-controller\n  abrEwmaSlowVoD: 9,\n  // used by abr-controller\n  abrEwmaDefaultEstimate: 5e5,\n  // 500 kbps  // used by abr-controller\n  abrEwmaDefaultEstimateMax: 5e6,\n  // 5 mbps\n  abrBandWidthFactor: 0.95,\n  // used by abr-controller\n  abrBandWidthUpFactor: 0.7,\n  // used by abr-controller\n  abrMaxWithRealBitrate: !1,\n  // used by abr-controller\n  maxStarvationDelay: 4,\n  // used by abr-controller\n  maxLoadingDelay: 4,\n  // used by abr-controller\n  minAutoBitrate: 0,\n  // used by hls\n  emeEnabled: !1,\n  // used by eme-controller\n  widevineLicenseUrl: void 0,\n  // used by eme-controller\n  drmSystems: {},\n  // used by eme-controller\n  drmSystemOptions: {},\n  // used by eme-controller\n  requestMediaKeySystemAccessFunc: Yg,\n  // used by eme-controller\n  requireKeySystemAccessOnStart: !1,\n  // used by eme-controller\n  testBandwidth: !0,\n  progressive: !1,\n  lowLatencyMode: !0,\n  cmcd: void 0,\n  enableDateRangeMetadataCues: !0,\n  enableEmsgMetadataCues: !0,\n  enableEmsgKLVMetadata: !1,\n  enableID3MetadataCues: !0,\n  enableInterstitialPlayback: !0,\n  interstitialAppendInPlace: !0,\n  interstitialLiveLookAhead: 10,\n  useMediaCapabilities: !0,\n  preserveManualLevelOnError: !1,\n  certLoadPolicy: {\n    default: iA\n  },\n  keyLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 8e3,\n      maxLoadTimeMs: 2e4,\n      timeoutRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1e3,\n        maxRetryDelayMs: 2e4,\n        backoff: \"linear\"\n      },\n      errorRetry: {\n        maxNumRetry: 8,\n        retryDelayMs: 1e3,\n        maxRetryDelayMs: 2e4,\n        backoff: \"linear\"\n      }\n    }\n  },\n  manifestLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 1 / 0,\n      maxLoadTimeMs: 2e4,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1e3,\n        maxRetryDelayMs: 8e3\n      }\n    }\n  },\n  playlistLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 1e4,\n      maxLoadTimeMs: 2e4,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 1e3,\n        maxRetryDelayMs: 8e3\n      }\n    }\n  },\n  fragLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 1e4,\n      maxLoadTimeMs: 12e4,\n      timeoutRetry: {\n        maxNumRetry: 4,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 6,\n        retryDelayMs: 1e3,\n        maxRetryDelayMs: 8e3\n      }\n    }\n  },\n  steeringManifestLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 1e4,\n      maxLoadTimeMs: 2e4,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1e3,\n        maxRetryDelayMs: 8e3\n      }\n    }\n  },\n  interstitialAssetListLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 1e4,\n      maxLoadTimeMs: 3e4,\n      timeoutRetry: {\n        maxNumRetry: 0,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 0,\n        retryDelayMs: 1e3,\n        maxRetryDelayMs: 8e3\n      }\n    }\n  },\n  // These default settings are deprecated in favor of the above policies\n  // and are maintained for backwards compatibility\n  manifestLoadingTimeOut: 1e4,\n  manifestLoadingMaxRetry: 1,\n  manifestLoadingRetryDelay: 1e3,\n  manifestLoadingMaxRetryTimeout: 64e3,\n  levelLoadingTimeOut: 1e4,\n  levelLoadingMaxRetry: 4,\n  levelLoadingRetryDelay: 1e3,\n  levelLoadingMaxRetryTimeout: 64e3,\n  fragLoadingTimeOut: 2e4,\n  fragLoadingMaxRetry: 6,\n  fragLoadingRetryDelay: 1e3,\n  fragLoadingMaxRetryTimeout: 64e3\n}, aA()), {}, {\n  subtitleStreamController: Sw,\n  subtitleTrackController: hw,\n  timelineController: Ww,\n  audioStreamController: n2,\n  audioTrackController: i2,\n  emeController: _n,\n  cmcdController: iw,\n  contentSteeringController: aw,\n  interstitialsController: xw\n});\nfunction aA() {\n  return {\n    cueHandler: Zw,\n    // used by timeline-controller\n    enableWebVTT: !0,\n    // used by timeline-controller\n    enableIMSC1: !0,\n    // used by timeline-controller\n    enableCEA708Captions: !0,\n    // used by timeline-controller\n    captionsTextTrack1Label: \"English\",\n    // used by timeline-controller\n    captionsTextTrack1LanguageCode: \"en\",\n    // used by timeline-controller\n    captionsTextTrack2Label: \"Spanish\",\n    // used by timeline-controller\n    captionsTextTrack2LanguageCode: \"es\",\n    // used by timeline-controller\n    captionsTextTrack3Label: \"Unknown CC\",\n    // used by timeline-controller\n    captionsTextTrack3LanguageCode: \"\",\n    // used by timeline-controller\n    captionsTextTrack4Label: \"Unknown CC\",\n    // used by timeline-controller\n    captionsTextTrack4LanguageCode: \"\",\n    // used by timeline-controller\n    renderTextTracksNatively: !0\n  };\n}\nfunction lA(s, e, t) {\n  if ((e.liveSyncDurationCount || e.liveMaxLatencyDurationCount) &amp;&amp; (e.liveSyncDuration || e.liveMaxLatencyDuration))\n    throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n  if (e.liveMaxLatencyDurationCount !== void 0 &amp;&amp; (e.liveSyncDurationCount === void 0 || e.liveMaxLatencyDurationCount &lt;= e.liveSyncDurationCount))\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n  if (e.liveMaxLatencyDuration !== void 0 &amp;&amp; (e.liveSyncDuration === void 0 || e.liveMaxLatencyDuration &lt;= e.liveSyncDuration))\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n  const r = Tc(s), n = [\"manifest\", \"level\", \"frag\"], i = [\"TimeOut\", \"MaxRetry\", \"RetryDelay\", \"MaxRetryTimeout\"];\n  return n.forEach((o) =&gt; {\n    const a = `${o === \"level\" ? \"playlist\" : o}LoadPolicy`, l = e[a] === void 0, c = [];\n    i.forEach((u) =&gt; {\n      const d = `${o}Loading${u}`, h = e[d];\n      if (h !== void 0 &amp;&amp; l) {\n        c.push(d);\n        const f = r[a].default;\n        switch (e[a] = {\n          default: f\n        }, u) {\n          case \"TimeOut\":\n            f.maxLoadTimeMs = h, f.maxTimeToFirstByteMs = h;\n            break;\n          case \"MaxRetry\":\n            f.errorRetry.maxNumRetry = h, f.timeoutRetry.maxNumRetry = h;\n            break;\n          case \"RetryDelay\":\n            f.errorRetry.retryDelayMs = h, f.timeoutRetry.retryDelayMs = h;\n            break;\n          case \"MaxRetryTimeout\":\n            f.errorRetry.maxRetryDelayMs = h, f.timeoutRetry.maxRetryDelayMs = h;\n            break;\n        }\n      }\n    }), c.length &amp;&amp; t.warn(`hls.js config: \"${c.join('\", \"')}\" setting(s) are deprecated, use \"${a}\": ${at(e[a])}`);\n  }), tt(tt({}, r), e);\n}\nfunction Tc(s) {\n  return s &amp;&amp; typeof s == \"object\" ? Array.isArray(s) ? s.map(Tc) : Object.keys(s).reduce((e, t) =&gt; (e[t] = Tc(s[t]), e), {}) : s;\n}\nfunction cA(s, e) {\n  const t = s.loader;\n  t !== lf &amp;&amp; t !== Zp ? (e.log(\"[config]: Custom loader detected, cannot enable progressive streaming\"), s.progressive = !1) : Xw() &amp;&amp; (s.loader = lf, s.progressive = !0, s.enableSoftwareAES = !0, e.log(\"[config]: Progressive streaming enabled, using FetchLoader\"));\n}\nconst xo = 2, uA = 0.1, dA = 0.05, hA = 100;\nclass fA extends Hg {\n  constructor(e, t) {\n    super(\"gap-controller\", e.logger), this.hls = void 0, this.fragmentTracker = void 0, this.media = null, this.mediaSource = void 0, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1, this.buffered = {}, this.lastCurrentTime = 0, this.ended = 0, this.waiting = 0, this.onMediaPlaying = () =&gt; {\n      this.ended = 0, this.waiting = 0;\n    }, this.onMediaWaiting = () =&gt; {\n      var r;\n      (r = this.media) != null &amp;&amp; r.seeking || (this.waiting = self.performance.now(), this.tick());\n    }, this.onMediaEnded = () =&gt; {\n      if (this.hls) {\n        var r;\n        this.ended = ((r = this.media) == null ? void 0 : r.currentTime) || 1, this.hls.trigger(I.MEDIA_ENDED, {\n          stalled: !1\n        });\n      }\n    }, this.hls = e, this.fragmentTracker = t, this.registerListeners();\n  }\n  registerListeners() {\n    const {\n      hls: e\n    } = this;\n    e &amp;&amp; (e.on(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(I.BUFFER_APPENDED, this.onBufferAppended, this));\n  }\n  unregisterListeners() {\n    const {\n      hls: e\n    } = this;\n    e &amp;&amp; (e.off(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(I.BUFFER_APPENDED, this.onBufferAppended, this));\n  }\n  destroy() {\n    super.destroy(), this.unregisterListeners(), this.media = this.hls = this.fragmentTracker = null, this.mediaSource = void 0;\n  }\n  onMediaAttached(e, t) {\n    this.setInterval(hA), this.mediaSource = t.mediaSource;\n    const r = this.media = t.media;\n    cr(r, \"playing\", this.onMediaPlaying), cr(r, \"waiting\", this.onMediaWaiting), cr(r, \"ended\", this.onMediaEnded);\n  }\n  onMediaDetaching(e, t) {\n    this.clearInterval();\n    const {\n      media: r\n    } = this;\n    r &amp;&amp; (pr(r, \"playing\", this.onMediaPlaying), pr(r, \"waiting\", this.onMediaWaiting), pr(r, \"ended\", this.onMediaEnded), this.media = null), this.mediaSource = void 0;\n  }\n  onBufferAppended(e, t) {\n    this.buffered = t.timeRanges;\n  }\n  get hasBuffered() {\n    return Object.keys(this.buffered).length &gt; 0;\n  }\n  tick() {\n    var e;\n    if (!((e = this.media) != null &amp;&amp; e.readyState) || !this.hasBuffered)\n      return;\n    const t = this.media.currentTime;\n    this.poll(t, this.lastCurrentTime), this.lastCurrentTime = t;\n  }\n  /**\n   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.\n   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).\n   *\n   * @param lastCurrentTime - Previously read playhead position\n   */\n  poll(e, t) {\n    var r, n;\n    const i = (r = this.hls) == null ? void 0 : r.config;\n    if (!i)\n      return;\n    const o = this.media;\n    if (!o)\n      return;\n    const {\n      seeking: a\n    } = o, l = this.seeking &amp;&amp; !a, c = !this.seeking &amp;&amp; a, u = o.paused &amp;&amp; !a || o.ended || o.playbackRate === 0;\n    if (this.seeking = a, e !== t) {\n      t &amp;&amp; (this.ended = 0), this.moved = !0, a || (this.nudgeRetry = 0, i.nudgeOnVideoHole &amp;&amp; !u &amp;&amp; e &gt; t &amp;&amp; this.nudgeOnVideoHole(e, t)), this.waiting === 0 &amp;&amp; this.stallResolved(e);\n      return;\n    }\n    if (c || l) {\n      l &amp;&amp; this.stallResolved(e);\n      return;\n    }\n    if (u) {\n      this.nudgeRetry = 0, this.stallResolved(e), !this.ended &amp;&amp; o.ended &amp;&amp; this.hls &amp;&amp; (this.ended = e || 1, this.hls.trigger(I.MEDIA_ENDED, {\n        stalled: !1\n      }));\n      return;\n    }\n    if (!Ce.getBuffered(o).length) {\n      this.nudgeRetry = 0;\n      return;\n    }\n    const d = Ce.bufferInfo(o, e, 0), h = d.nextStart || 0, f = this.fragmentTracker;\n    if (a &amp;&amp; f &amp;&amp; this.hls) {\n      const H = cf(this.hls.inFlightFragments, e), K = d.len &gt; xo, j = !h || H || h - e &gt; xo &amp;&amp; !f.getPartialFragment(e);\n      if (K || j)\n        return;\n      this.moved = !1;\n    }\n    const p = (n = this.hls) == null ? void 0 : n.latestLevelDetails;\n    if (!this.moved &amp;&amp; this.stalled !== null &amp;&amp; f) {\n      if (!(d.len &gt; 0) &amp;&amp; !h)\n        return;\n      const K = Math.max(h, d.start || 0) - e, C = !!(p != null &amp;&amp; p.live) ? p.targetduration * 2 : xo, k = so(e, f);\n      if (K &gt; 0 &amp;&amp; (K &lt;= C || k)) {\n        o.paused || this._trySkipBufferHole(k);\n        return;\n      }\n    }\n    const y = i.detectStallWithCurrentTimeMs, E = self.performance.now(), b = this.waiting;\n    let R = this.stalled;\n    if (R === null)\n      if (b &gt; 0 &amp;&amp; E - b &lt; y)\n        R = this.stalled = b;\n      else {\n        this.stalled = E;\n        return;\n      }\n    const A = E - R;\n    if (!a &amp;&amp; (A &gt;= y || b) &amp;&amp; this.hls) {\n      var F;\n      if (((F = this.mediaSource) == null ? void 0 : F.readyState) === \"ended\" &amp;&amp; !(p != null &amp;&amp; p.live) &amp;&amp; Math.abs(e - ((p == null ? void 0 : p.edge) || 0)) &lt; 1) {\n        if (this.ended)\n          return;\n        this.ended = e || 1, this.hls.trigger(I.MEDIA_ENDED, {\n          stalled: !0\n        });\n        return;\n      }\n      if (this._reportStall(d), !this.media || !this.hls)\n        return;\n    }\n    const M = Ce.bufferInfo(o, e, i.maxBufferHole);\n    this._tryFixBufferStall(M, A, e);\n  }\n  stallResolved(e) {\n    const t = this.stalled;\n    if (t &amp;&amp; this.hls &amp;&amp; (this.stalled = null, this.stallReported)) {\n      const r = self.performance.now() - t;\n      this.log(`playback not stuck anymore @${e}, after ${Math.round(r)}ms`), this.stallReported = !1, this.waiting = 0, this.hls.trigger(I.STALL_RESOLVED, {});\n    }\n  }\n  nudgeOnVideoHole(e, t) {\n    var r;\n    const n = this.buffered.video;\n    if (this.hls &amp;&amp; this.media &amp;&amp; this.fragmentTracker &amp;&amp; (r = this.buffered.audio) != null &amp;&amp; r.length &amp;&amp; n &amp;&amp; n.length &gt; 1 &amp;&amp; e &gt; n.end(0)) {\n      const i = Ce.bufferedInfo(Ce.timeRangesToArray(this.buffered.audio), e, 0);\n      if (i.len &gt; 1 &amp;&amp; t &gt;= i.start) {\n        const o = Ce.timeRangesToArray(n), a = Ce.bufferedInfo(o, t, 0).bufferedIndex;\n        if (a &gt; -1 &amp;&amp; a &lt; o.length - 1) {\n          const l = Ce.bufferedInfo(o, e, 0).bufferedIndex, c = o[a].end, u = o[a + 1].start;\n          if ((l === -1 || l &gt; a) &amp;&amp; u - c &lt; 1 &amp;&amp; // `maxBufferHole` may be too small and setting it to 0 should not disable this feature\n          e - c &lt; 2) {\n            const d = new Error(`nudging playhead to flush pipeline after video hole. currentTime: ${e} hole: ${c} -&gt; ${u} buffered index: ${l}`);\n            this.warn(d.message), this.media.currentTime += 1e-6;\n            let h = so(e, this.fragmentTracker);\n            h &amp;&amp; \"fragment\" in h ? h = h.fragment : h || (h = void 0);\n            const f = Ce.bufferInfo(this.media, e, 0);\n            this.hls.trigger(I.ERROR, {\n              type: ve.MEDIA_ERROR,\n              details: J.BUFFER_SEEK_OVER_HOLE,\n              fatal: !1,\n              error: d,\n              reason: d.message,\n              frag: h,\n              buffer: f.len,\n              bufferInfo: f\n            });\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Detects and attempts to fix known buffer stalling issues.\n   * @param bufferInfo - The properties of the current buffer.\n   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.\n   * @private\n   */\n  _tryFixBufferStall(e, t, r) {\n    var n, i;\n    const {\n      fragmentTracker: o,\n      media: a\n    } = this, l = (n = this.hls) == null ? void 0 : n.config;\n    if (!a || !o || !l)\n      return;\n    const c = (i = this.hls) == null ? void 0 : i.latestLevelDetails, u = so(r, o);\n    if ((u || c != null &amp;&amp; c.live &amp;&amp; r &lt; c.fragmentStart) &amp;&amp; (this._trySkipBufferHole(u) || !this.media))\n      return;\n    const d = e.buffered, h = this.adjacentTraversal(e, r);\n    (d &amp;&amp; d.length &gt; 1 &amp;&amp; e.len &gt; l.maxBufferHole || e.nextStart &amp;&amp; (e.nextStart - r &lt; l.maxBufferHole || h)) &amp;&amp; (t &gt; l.highBufferWatchdogPeriod * 1e3 || this.waiting) &amp;&amp; (this.warn(\"Trying to nudge playhead over buffer-hole\"), this._tryNudgeBuffer(e));\n  }\n  adjacentTraversal(e, t) {\n    const r = this.fragmentTracker, n = e.nextStart;\n    if (r &amp;&amp; n) {\n      const i = r.getFragAtPos(t, pe.MAIN), o = r.getFragAtPos(n, pe.MAIN);\n      if (i &amp;&amp; o)\n        return o.sn - i.sn &lt; 2;\n    }\n    return !1;\n  }\n  /**\n   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.\n   * @param bufferLen - The playhead distance from the end of the current buffer segment.\n   * @private\n   */\n  _reportStall(e) {\n    const {\n      hls: t,\n      media: r,\n      stallReported: n,\n      stalled: i\n    } = this;\n    if (!n &amp;&amp; i !== null &amp;&amp; r &amp;&amp; t) {\n      this.stallReported = !0;\n      const o = new Error(`Playback stalling at @${r.currentTime} due to low buffer (${at(e)})`);\n      this.warn(o.message), t.trigger(I.ERROR, {\n        type: ve.MEDIA_ERROR,\n        details: J.BUFFER_STALLED_ERROR,\n        fatal: !1,\n        error: o,\n        buffer: e.len,\n        bufferInfo: e,\n        stalled: {\n          start: i\n        }\n      });\n    }\n  }\n  /**\n   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments\n   * @param appended - The fragment or part found at the current time (where playback is stalling).\n   * @private\n   */\n  _trySkipBufferHole(e) {\n    var t;\n    const {\n      fragmentTracker: r,\n      media: n\n    } = this, i = (t = this.hls) == null ? void 0 : t.config;\n    if (!n || !r || !i)\n      return 0;\n    const o = n.currentTime, a = Ce.bufferInfo(n, o, 0), l = o &lt; a.start ? a.start : a.nextStart;\n    if (l &amp;&amp; this.hls) {\n      const u = a.len &lt;= i.maxBufferHole, d = a.len &gt; 0 &amp;&amp; a.len &lt; 1 &amp;&amp; n.readyState &lt; 3, h = l - o;\n      if (h &gt; 0 &amp;&amp; (u || d)) {\n        if (h &gt; i.maxBufferHole) {\n          let p = !1;\n          if (o === 0) {\n            const y = r.getAppendedFrag(0, pe.MAIN);\n            y &amp;&amp; l &lt; y.end &amp;&amp; (p = !0);\n          }\n          if (!p &amp;&amp; e) {\n            var c;\n            if (!((c = this.hls.loadLevelObj) != null &amp;&amp; c.details) || cf(this.hls.inFlightFragments, l))\n              return 0;\n            let E = !1, b = e.end;\n            for (; b &lt; l; ) {\n              const R = so(b, r);\n              if (R)\n                b += R.duration;\n              else {\n                E = !0;\n                break;\n              }\n            }\n            if (E)\n              return 0;\n          }\n        }\n        const f = Math.max(l + dA, o + uA);\n        if (this.warn(`skipping hole, adjusting currentTime from ${o} to ${f}`), this.moved = !0, n.currentTime = f, !(e != null &amp;&amp; e.gap)) {\n          const p = new Error(`fragment loaded with buffer holes, seeking from ${o} to ${f}`), y = {\n            type: ve.MEDIA_ERROR,\n            details: J.BUFFER_SEEK_OVER_HOLE,\n            fatal: !1,\n            error: p,\n            reason: p.message,\n            buffer: a.len,\n            bufferInfo: a\n          };\n          e &amp;&amp; (\"fragment\" in e ? y.part = e : y.frag = e), this.hls.trigger(I.ERROR, y);\n        }\n        return f;\n      }\n    }\n    return 0;\n  }\n  /**\n   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.\n   * @private\n   */\n  _tryNudgeBuffer(e) {\n    const {\n      hls: t,\n      media: r,\n      nudgeRetry: n\n    } = this, i = t == null ? void 0 : t.config;\n    if (!r || !i)\n      return 0;\n    const o = r.currentTime;\n    if (this.nudgeRetry++, n &lt; i.nudgeMaxRetry) {\n      const a = o + (n + 1) * i.nudgeOffset, l = new Error(`Nudging 'currentTime' from ${o} to ${a}`);\n      this.warn(l.message), r.currentTime = a, t.trigger(I.ERROR, {\n        type: ve.MEDIA_ERROR,\n        details: J.BUFFER_NUDGE_ON_STALL,\n        error: l,\n        fatal: !1,\n        buffer: e.len,\n        bufferInfo: e\n      });\n    } else {\n      const a = new Error(`Playhead still not moving while enough data buffered @${o} after ${i.nudgeMaxRetry} nudges`);\n      this.error(a.message), t.trigger(I.ERROR, {\n        type: ve.MEDIA_ERROR,\n        details: J.BUFFER_STALLED_ERROR,\n        error: a,\n        fatal: !0,\n        buffer: e.len,\n        bufferInfo: e\n      });\n    }\n  }\n}\nfunction cf(s, e) {\n  const t = uf(s.main);\n  if (t &amp;&amp; t.start &lt;= e)\n    return t;\n  const r = uf(s.audio);\n  return r &amp;&amp; r.start &lt;= e ? r : null;\n}\nfunction uf(s) {\n  if (!s)\n    return null;\n  switch (s.state) {\n    case ne.IDLE:\n    case ne.STOPPED:\n    case ne.ENDED:\n    case ne.ERROR:\n      return null;\n  }\n  return s.frag;\n}\nfunction so(s, e) {\n  return e.getAppendedFrag(s, pe.MAIN) || e.getPartialFragment(s);\n}\nconst gA = 0.25;\nfunction wc() {\n  if (!(typeof self &gt; \"u\"))\n    return self.VTTCue || self.TextTrackCue;\n}\nfunction Cl(s, e, t, r, n) {\n  let i = new s(e, t, \"\");\n  try {\n    i.value = r, n &amp;&amp; (i.type = n);\n  } catch {\n    i = new s(e, t, at(n ? tt({\n      type: n\n    }, r) : r));\n  }\n  return i;\n}\nconst no = (() =&gt; {\n  const s = wc();\n  try {\n    s &amp;&amp; new s(0, Number.POSITIVE_INFINITY, \"\");\n  } catch {\n    return Number.MAX_VALUE;\n  }\n  return Number.POSITIVE_INFINITY;\n})();\nclass pA {\n  constructor(e) {\n    this.hls = void 0, this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.removeCues = !0, this.assetCue = void 0, this.onEventCueEnter = () =&gt; {\n      this.hls &amp;&amp; this.hls.trigger(I.EVENT_CUE_ENTER, {});\n    }, this.hls = e, this._registerListeners();\n  }\n  destroy() {\n    this._unregisterListeners(), this.id3Track = null, this.media = null, this.dateRangeCuesAppended = {}, this.hls = this.onEventCueEnter = null;\n  }\n  _registerListeners() {\n    const {\n      hls: e\n    } = this;\n    e &amp;&amp; (e.on(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.on(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.on(I.BUFFER_FLUSHING, this.onBufferFlushing, this), e.on(I.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(I.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this));\n  }\n  _unregisterListeners() {\n    const {\n      hls: e\n    } = this;\n    e &amp;&amp; (e.off(I.MEDIA_ATTACHING, this.onMediaAttaching, this), e.off(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this), e.off(I.BUFFER_FLUSHING, this.onBufferFlushing, this), e.off(I.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(I.LEVEL_PTS_UPDATED, this.onLevelPtsUpdated, this));\n  }\n  // Add ID3 metatadata text track.\n  onMediaAttaching(e, t) {\n    var r;\n    this.media = t.media, ((r = t.overrides) == null ? void 0 : r.cueRemoval) === !1 &amp;&amp; (this.removeCues = !1);\n  }\n  onMediaAttached() {\n    var e;\n    const t = (e = this.hls) == null ? void 0 : e.latestLevelDetails;\n    t &amp;&amp; this.updateDateRangeCues(t);\n  }\n  onMediaDetaching(e, t) {\n    this.media = null, !t.transferMedia &amp;&amp; (this.id3Track &amp;&amp; (this.removeCues &amp;&amp; Sn(this.id3Track, this.onEventCueEnter), this.id3Track = null), this.dateRangeCuesAppended = {});\n  }\n  onManifestLoading() {\n    this.dateRangeCuesAppended = {};\n  }\n  createTrack(e) {\n    const t = this.getID3Track(e.textTracks);\n    return t.mode = \"hidden\", t;\n  }\n  getID3Track(e) {\n    if (this.media) {\n      for (let t = 0; t &lt; e.length; t++) {\n        const r = e[t];\n        if (r.kind === \"metadata\" &amp;&amp; r.label === \"id3\")\n          return Np(r, this.media), r;\n      }\n      return this.media.addTextTrack(\"metadata\", \"id3\");\n    }\n  }\n  onFragParsingMetadata(e, t) {\n    if (!this.media || !this.hls)\n      return;\n    const {\n      enableEmsgMetadataCues: r,\n      enableID3MetadataCues: n\n    } = this.hls.config;\n    if (!r &amp;&amp; !n)\n      return;\n    const {\n      samples: i\n    } = t;\n    this.id3Track || (this.id3Track = this.createTrack(this.media));\n    const o = wc();\n    if (o)\n      for (let a = 0; a &lt; i.length; a++) {\n        const l = i[a].type;\n        if (l === br.emsg &amp;&amp; !r || !n)\n          continue;\n        const c = hp(i[a].data), u = i[a].pts;\n        let d = u + i[a].duration;\n        d &gt; no &amp;&amp; (d = no), d - u &lt;= 0 &amp;&amp; (d = u + gA);\n        for (let f = 0; f &lt; c.length; f++) {\n          const p = c[f];\n          if (!fp(p)) {\n            this.updateId3CueEnds(u, l);\n            const y = Cl(o, u, d, p, l);\n            y &amp;&amp; this.id3Track.addCue(y);\n          }\n        }\n      }\n  }\n  updateId3CueEnds(e, t) {\n    var r;\n    const n = (r = this.id3Track) == null ? void 0 : r.cues;\n    if (n)\n      for (let i = n.length; i--; ) {\n        const o = n[i];\n        o.type === t &amp;&amp; o.startTime &lt; e &amp;&amp; o.endTime === no &amp;&amp; (o.endTime = e);\n      }\n  }\n  onBufferFlushing(e, {\n    startOffset: t,\n    endOffset: r,\n    type: n\n  }) {\n    const {\n      id3Track: i,\n      hls: o\n    } = this;\n    if (!o)\n      return;\n    const {\n      config: {\n        enableEmsgMetadataCues: a,\n        enableID3MetadataCues: l\n      }\n    } = o;\n    if (i &amp;&amp; (a || l)) {\n      let c;\n      n === \"audio\" ? c = (u) =&gt; u.type === br.audioId3 &amp;&amp; l : n === \"video\" ? c = (u) =&gt; u.type === br.emsg &amp;&amp; a : c = (u) =&gt; u.type === br.audioId3 &amp;&amp; l || u.type === br.emsg &amp;&amp; a, Sc(i, t, r, c);\n    }\n  }\n  onLevelUpdated(e, {\n    details: t\n  }) {\n    this.updateDateRangeCues(t, !0);\n  }\n  onLevelPtsUpdated(e, t) {\n    Math.abs(t.drift) &gt; 0.01 &amp;&amp; this.updateDateRangeCues(t.details);\n  }\n  updateDateRangeCues(e, t) {\n    if (!this.hls || !this.media)\n      return;\n    const {\n      assetPlayerId: r,\n      timelineOffset: n,\n      enableDateRangeMetadataCues: i,\n      interstitialsController: o\n    } = this.hls.config;\n    if (!i)\n      return;\n    const a = wc();\n    if (r &amp;&amp; n &amp;&amp; !o) {\n      const {\n        fragmentStart: y,\n        fragmentEnd: E\n      } = e;\n      let b = this.assetCue;\n      b ? (b.startTime = y, b.endTime = E) : a &amp;&amp; (b = this.assetCue = Cl(a, y, E, {\n        assetPlayerId: this.hls.config.assetPlayerId\n      }, \"hlsjs.interstitial.asset\"), b &amp;&amp; (b.id = r, this.id3Track || (this.id3Track = this.createTrack(this.media)), this.id3Track.addCue(b), b.addEventListener(\"enter\", this.onEventCueEnter)));\n    }\n    if (!e.hasProgramDateTime)\n      return;\n    const {\n      id3Track: l\n    } = this, {\n      dateRanges: c\n    } = e, u = Object.keys(c);\n    let d = this.dateRangeCuesAppended;\n    if (l &amp;&amp; t) {\n      var h;\n      if ((h = l.cues) != null &amp;&amp; h.length) {\n        const y = Object.keys(d).filter((E) =&gt; !u.includes(E));\n        for (let E = y.length; E--; ) {\n          var f;\n          const b = y[E], R = (f = d[b]) == null ? void 0 : f.cues;\n          delete d[b], R &amp;&amp; Object.keys(R).forEach((A) =&gt; {\n            const F = R[A];\n            if (F) {\n              F.removeEventListener(\"enter\", this.onEventCueEnter);\n              try {\n                l.removeCue(F);\n              } catch {\n              }\n            }\n          });\n        }\n      } else\n        d = this.dateRangeCuesAppended = {};\n    }\n    const p = e.fragments[e.fragments.length - 1];\n    if (!(u.length === 0 || !ue(p == null ? void 0 : p.programDateTime))) {\n      this.id3Track || (this.id3Track = this.createTrack(this.media));\n      for (let y = 0; y &lt; u.length; y++) {\n        const E = u[y], b = c[E], R = b.startTime, A = d[E], F = (A == null ? void 0 : A.cues) || {};\n        let M = (A == null ? void 0 : A.durationKnown) || !1, H = no;\n        const {\n          duration: K,\n          endDate: j\n        } = b;\n        if (j &amp;&amp; K !== null)\n          H = R + K, M = !0;\n        else if (b.endOnNext &amp;&amp; !M) {\n          const k = u.reduce(($, W) =&gt; {\n            if (W !== b.id) {\n              const _ = c[W];\n              if (_.class === b.class &amp;&amp; _.startDate &gt; b.startDate &amp;&amp; (!$ || b.startDate &lt; $.startDate))\n                return _;\n            }\n            return $;\n          }, null);\n          k &amp;&amp; (H = k.startTime, M = !0);\n        }\n        const C = Object.keys(b.attr);\n        for (let k = 0; k &lt; C.length; k++) {\n          const $ = C[k];\n          if (!Ob($))\n            continue;\n          const W = F[$];\n          if (W)\n            M &amp;&amp; !(A != null &amp;&amp; A.durationKnown) ? W.endTime = H : Math.abs(W.startTime - R) &gt; 0.01 &amp;&amp; (W.startTime = R, W.endTime = H);\n          else if (a) {\n            let _ = b.attr[$];\n            Bb($) &amp;&amp; (_ = Ig(_));\n            const x = Cl(a, R, H, {\n              key: $,\n              data: _\n            }, br.dateRange);\n            x &amp;&amp; (x.id = E, this.id3Track.addCue(x), F[$] = x, o &amp;&amp; ($ === \"X-ASSET-LIST\" || $ === \"X-ASSET-URL\") &amp;&amp; x.addEventListener(\"enter\", this.onEventCueEnter));\n          }\n        }\n        d[E] = {\n          cues: F,\n          dateRange: b,\n          durationKnown: M\n        };\n      }\n    }\n  }\n}\nclass mA {\n  constructor(e) {\n    this.hls = void 0, this.config = void 0, this.media = null, this.currentTime = 0, this.stallCount = 0, this._latency = null, this._targetLatencyUpdated = !1, this.onTimeupdate = () =&gt; {\n      const {\n        media: t\n      } = this, r = this.levelDetails;\n      if (!t || !r)\n        return;\n      this.currentTime = t.currentTime;\n      const n = this.computeLatency();\n      if (n === null)\n        return;\n      this._latency = n;\n      const {\n        lowLatencyMode: i,\n        maxLiveSyncPlaybackRate: o\n      } = this.config;\n      if (!i || o === 1 || !r.live)\n        return;\n      const a = this.targetLatency;\n      if (a === null)\n        return;\n      const l = n - a, c = Math.min(this.maxLatency, a + r.targetduration);\n      if (l &lt; c &amp;&amp; l &gt; 0.05 &amp;&amp; this.forwardBufferLength &gt; 1) {\n        const d = Math.min(2, Math.max(1, o)), h = Math.round(2 / (1 + Math.exp(-0.75 * l - this.edgeStalled)) * 20) / 20, f = Math.min(d, Math.max(1, h));\n        this.changeMediaPlaybackRate(t, f);\n      } else t.playbackRate !== 1 &amp;&amp; t.playbackRate !== 0 &amp;&amp; this.changeMediaPlaybackRate(t, 1);\n    }, this.hls = e, this.config = e.config, this.registerListeners();\n  }\n  get levelDetails() {\n    var e;\n    return ((e = this.hls) == null ? void 0 : e.latestLevelDetails) || null;\n  }\n  get latency() {\n    return this._latency || 0;\n  }\n  get maxLatency() {\n    const {\n      config: e\n    } = this;\n    if (e.liveMaxLatencyDuration !== void 0)\n      return e.liveMaxLatencyDuration;\n    const t = this.levelDetails;\n    return t ? e.liveMaxLatencyDurationCount * t.targetduration : 0;\n  }\n  get targetLatency() {\n    const e = this.levelDetails;\n    if (e === null || this.hls === null)\n      return null;\n    const {\n      holdBack: t,\n      partHoldBack: r,\n      targetduration: n\n    } = e, {\n      liveSyncDuration: i,\n      liveSyncDurationCount: o,\n      lowLatencyMode: a\n    } = this.config, l = this.hls.userConfig;\n    let c = a &amp;&amp; r || t;\n    (this._targetLatencyUpdated || l.liveSyncDuration || l.liveSyncDurationCount || c === 0) &amp;&amp; (c = i !== void 0 ? i : o * n);\n    const u = n;\n    return c + Math.min(this.stallCount * this.config.liveSyncOnStallIncrease, u);\n  }\n  set targetLatency(e) {\n    this.stallCount = 0, this.config.liveSyncDuration = e, this._targetLatencyUpdated = !0;\n  }\n  get liveSyncPosition() {\n    const e = this.estimateLiveEdge(), t = this.targetLatency;\n    if (e === null || t === null)\n      return null;\n    const r = this.levelDetails;\n    if (r === null)\n      return null;\n    const n = r.edge, i = e - t - this.edgeStalled, o = n - r.totalduration, a = n - (this.config.lowLatencyMode &amp;&amp; r.partTarget || r.targetduration);\n    return Math.min(Math.max(o, i), a);\n  }\n  get drift() {\n    const e = this.levelDetails;\n    return e === null ? 1 : e.drift;\n  }\n  get edgeStalled() {\n    const e = this.levelDetails;\n    if (e === null)\n      return 0;\n    const t = (this.config.lowLatencyMode &amp;&amp; e.partTarget || e.targetduration) * 3;\n    return Math.max(e.age - t, 0);\n  }\n  get forwardBufferLength() {\n    const {\n      media: e\n    } = this, t = this.levelDetails;\n    if (!e || !t)\n      return 0;\n    const r = e.buffered.length;\n    return (r ? e.buffered.end(r - 1) : t.edge) - this.currentTime;\n  }\n  destroy() {\n    this.unregisterListeners(), this.onMediaDetaching(), this.hls = null;\n  }\n  registerListeners() {\n    const {\n      hls: e\n    } = this;\n    e &amp;&amp; (e.on(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.on(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.LEVEL_UPDATED, this.onLevelUpdated, this), e.on(I.ERROR, this.onError, this));\n  }\n  unregisterListeners() {\n    const {\n      hls: e\n    } = this;\n    e &amp;&amp; (e.off(I.MEDIA_ATTACHED, this.onMediaAttached, this), e.off(I.MEDIA_DETACHING, this.onMediaDetaching, this), e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.LEVEL_UPDATED, this.onLevelUpdated, this), e.off(I.ERROR, this.onError, this));\n  }\n  onMediaAttached(e, t) {\n    this.media = t.media, this.media.addEventListener(\"timeupdate\", this.onTimeupdate);\n  }\n  onMediaDetaching() {\n    this.media &amp;&amp; (this.media.removeEventListener(\"timeupdate\", this.onTimeupdate), this.media = null);\n  }\n  onManifestLoading() {\n    this._latency = null, this.stallCount = 0;\n  }\n  onLevelUpdated(e, {\n    details: t\n  }) {\n    t.advanced &amp;&amp; this.onTimeupdate(), !t.live &amp;&amp; this.media &amp;&amp; this.media.removeEventListener(\"timeupdate\", this.onTimeupdate);\n  }\n  onError(e, t) {\n    var r;\n    t.details === J.BUFFER_STALLED_ERROR &amp;&amp; (this.stallCount++, this.hls &amp;&amp; (r = this.levelDetails) != null &amp;&amp; r.live &amp;&amp; this.hls.logger.warn(\"[latency-controller]: Stall detected, adjusting target latency\"));\n  }\n  changeMediaPlaybackRate(e, t) {\n    var r, n;\n    e.playbackRate !== t &amp;&amp; ((r = this.hls) == null || r.logger.debug(`[latency-controller]: latency=${this.latency.toFixed(3)}, targetLatency=${(n = this.targetLatency) == null ? void 0 : n.toFixed(3)}, forwardBufferLength=${this.forwardBufferLength.toFixed(3)}: adjusting playback rate from ${e.playbackRate} to ${t}`), e.playbackRate = t);\n  }\n  estimateLiveEdge() {\n    const e = this.levelDetails;\n    return e === null ? null : e.edge + e.age;\n  }\n  computeLatency() {\n    const e = this.estimateLiveEdge();\n    return e === null ? null : e - this.currentTime;\n  }\n}\nclass yA extends ku {\n  constructor(e, t) {\n    super(e, \"level-controller\"), this._levels = [], this._firstLevel = -1, this._maxAutoLevel = -1, this._startLevel = void 0, this.currentLevel = null, this.currentLevelIndex = -1, this.manualLevelIndex = -1, this.steering = void 0, this.onParsedComplete = void 0, this.steering = t, this._registerListeners();\n  }\n  _registerListeners() {\n    const {\n      hls: e\n    } = this;\n    e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.MANIFEST_LOADED, this.onManifestLoaded, this), e.on(I.LEVEL_LOADED, this.onLevelLoaded, this), e.on(I.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(I.FRAG_BUFFERED, this.onFragBuffered, this), e.on(I.ERROR, this.onError, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls: e\n    } = this;\n    e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.MANIFEST_LOADED, this.onManifestLoaded, this), e.off(I.LEVEL_LOADED, this.onLevelLoaded, this), e.off(I.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(I.FRAG_BUFFERED, this.onFragBuffered, this), e.off(I.ERROR, this.onError, this);\n  }\n  destroy() {\n    this._unregisterListeners(), this.steering = null, this.resetLevels(), super.destroy();\n  }\n  stopLoad() {\n    this._levels.forEach((t) =&gt; {\n      t.loadError = 0, t.fragmentError = 0;\n    }), super.stopLoad();\n  }\n  resetLevels() {\n    this._startLevel = void 0, this.manualLevelIndex = -1, this.currentLevelIndex = -1, this.currentLevel = null, this._levels = [], this._maxAutoLevel = -1;\n  }\n  onManifestLoading(e, t) {\n    this.resetLevels();\n  }\n  onManifestLoaded(e, t) {\n    const r = this.hls.config.preferManagedMediaSource, n = [], i = {}, o = {};\n    let a = !1, l = !1, c = !1;\n    t.levels.forEach((u) =&gt; {\n      const d = u.attrs;\n      let {\n        audioCodec: h,\n        videoCodec: f\n      } = u;\n      h &amp;&amp; (u.audioCodec = h = Xo(h, r) || void 0), f &amp;&amp; (f = u.videoCodec = JS(f));\n      const {\n        width: p,\n        height: y,\n        unknownCodecs: E\n      } = u, b = (E == null ? void 0 : E.length) || 0;\n      if (a || (a = !!(p &amp;&amp; y)), l || (l = !!f), c || (c = !!h), b || h &amp;&amp; !this.isAudioSupported(h) || f &amp;&amp; !this.isVideoSupported(f)) {\n        this.log(`Some or all CODECS not supported \"${d.CODECS}\"`);\n        return;\n      }\n      const {\n        CODECS: R,\n        \"FRAME-RATE\": A,\n        \"HDCP-LEVEL\": F,\n        \"PATHWAY-ID\": M,\n        RESOLUTION: H,\n        \"VIDEO-RANGE\": K\n      } = d, C = `${`${M || \".\"}-`}${u.bitrate}-${H}-${A}-${R}-${K}-${F}`;\n      if (i[C])\n        if (i[C].uri !== u.url &amp;&amp; !u.attrs[\"PATHWAY-ID\"]) {\n          const k = o[C] += 1;\n          u.attrs[\"PATHWAY-ID\"] = new Array(k + 1).join(\".\");\n          const $ = this.createLevel(u);\n          i[C] = $, n.push($);\n        } else\n          i[C].addGroupId(\"audio\", d.AUDIO), i[C].addGroupId(\"text\", d.SUBTITLES);\n      else {\n        const k = this.createLevel(u);\n        i[C] = k, o[C] = 1, n.push(k);\n      }\n    }), this.filterAndSortMediaOptions(n, t, a, l, c);\n  }\n  createLevel(e) {\n    const t = new mi(e), r = e.supplemental;\n    if (r != null &amp;&amp; r.videoCodec &amp;&amp; !this.isVideoSupported(r.videoCodec)) {\n      const n = new Error(`SUPPLEMENTAL-CODECS not supported \"${r.videoCodec}\"`);\n      this.log(n.message), t.supportedResult = Fg(n, []);\n    }\n    return t;\n  }\n  isAudioSupported(e) {\n    return gi(e, \"audio\", this.hls.config.preferManagedMediaSource);\n  }\n  isVideoSupported(e) {\n    return gi(e, \"video\", this.hls.config.preferManagedMediaSource);\n  }\n  filterAndSortMediaOptions(e, t, r, n, i) {\n    var o;\n    let a = [], l = [], c = e;\n    const u = ((o = t.stats) == null ? void 0 : o.parsing) || {};\n    if ((r || n) &amp;&amp; i &amp;&amp; (c = c.filter(({\n      videoCodec: R,\n      videoRange: A,\n      width: F,\n      height: M\n    }) =&gt; (!!R || !!(F &amp;&amp; M)) &amp;&amp; lb(A))), c.length === 0) {\n      Promise.resolve().then(() =&gt; {\n        if (this.hls) {\n          let R = \"no level with compatible codecs found in manifest\", A = R;\n          t.levels.length &amp;&amp; (A = `one or more CODECS in variant not supported: ${at(t.levels.map((M) =&gt; M.attrs.CODECS).filter((M, H, K) =&gt; K.indexOf(M) === H))}`, this.warn(A), R += ` (${A})`);\n          const F = new Error(R);\n          this.hls.trigger(I.ERROR, {\n            type: ve.MEDIA_ERROR,\n            details: J.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n            fatal: !0,\n            url: t.url,\n            error: F,\n            reason: A\n          });\n        }\n      }), u.end = performance.now();\n      return;\n    }\n    t.audioTracks &amp;&amp; (a = t.audioTracks.filter((R) =&gt; !R.audioCodec || this.isAudioSupported(R.audioCodec)), df(a)), t.subtitles &amp;&amp; (l = t.subtitles, df(l));\n    const d = c.slice(0);\n    c.sort((R, A) =&gt; {\n      if (R.attrs[\"HDCP-LEVEL\"] !== A.attrs[\"HDCP-LEVEL\"])\n        return (R.attrs[\"HDCP-LEVEL\"] || \"\") &gt; (A.attrs[\"HDCP-LEVEL\"] || \"\") ? 1 : -1;\n      if (r &amp;&amp; R.height !== A.height)\n        return R.height - A.height;\n      if (R.frameRate !== A.frameRate)\n        return R.frameRate - A.frameRate;\n      if (R.videoRange !== A.videoRange)\n        return Jo.indexOf(R.videoRange) - Jo.indexOf(A.videoRange);\n      if (R.videoCodec !== A.videoCodec) {\n        const F = sh(R.videoCodec), M = sh(A.videoCodec);\n        if (F !== M)\n          return M - F;\n      }\n      if (R.uri === A.uri &amp;&amp; R.codecSet !== A.codecSet) {\n        const F = Zo(R.codecSet), M = Zo(A.codecSet);\n        if (F !== M)\n          return M - F;\n      }\n      return R.averageBitrate !== A.averageBitrate ? R.averageBitrate - A.averageBitrate : 0;\n    });\n    let h = d[0];\n    if (this.steering &amp;&amp; (c = this.steering.filterParsedLevels(c), c.length !== d.length)) {\n      for (let R = 0; R &lt; d.length; R++)\n        if (d[R].pathwayId === c[0].pathwayId) {\n          h = d[R];\n          break;\n        }\n    }\n    this._levels = c;\n    for (let R = 0; R &lt; c.length; R++)\n      if (c[R] === h) {\n        var f;\n        this._firstLevel = R;\n        const A = h.bitrate, F = this.hls.bandwidthEstimate;\n        if (this.log(`manifest loaded, ${c.length} level(s) found, first bitrate: ${A}`), ((f = this.hls.userConfig) == null ? void 0 : f.abrEwmaDefaultEstimate) === void 0) {\n          const M = Math.min(A, this.hls.config.abrEwmaDefaultEstimateMax);\n          M &gt; F &amp;&amp; F === this.hls.abrEwmaDefaultEstimate &amp;&amp; (this.hls.bandwidthEstimate = M);\n        }\n        break;\n      }\n    const p = i &amp;&amp; !n, y = this.hls.config, E = !!(y.audioStreamController &amp;&amp; y.audioTrackController), b = {\n      levels: c,\n      audioTracks: a,\n      subtitleTracks: l,\n      sessionData: t.sessionData,\n      sessionKeys: t.sessionKeys,\n      firstLevel: this._firstLevel,\n      stats: t.stats,\n      audio: i,\n      video: n,\n      altAudio: E &amp;&amp; !p &amp;&amp; a.some((R) =&gt; !!R.url)\n    };\n    u.end = performance.now(), this.hls.trigger(I.MANIFEST_PARSED, b);\n  }\n  get levels() {\n    return this._levels.length === 0 ? null : this._levels;\n  }\n  get loadLevelObj() {\n    return this.currentLevel;\n  }\n  get level() {\n    return this.currentLevelIndex;\n  }\n  set level(e) {\n    const t = this._levels;\n    if (t.length === 0)\n      return;\n    if (e &lt; 0 || e &gt;= t.length) {\n      const u = new Error(\"invalid level idx\"), d = e &lt; 0;\n      if (this.hls.trigger(I.ERROR, {\n        type: ve.OTHER_ERROR,\n        details: J.LEVEL_SWITCH_ERROR,\n        level: e,\n        fatal: d,\n        error: u,\n        reason: u.message\n      }), d)\n        return;\n      e = Math.min(e, t.length - 1);\n    }\n    const r = this.currentLevelIndex, n = this.currentLevel, i = n ? n.attrs[\"PATHWAY-ID\"] : void 0, o = t[e], a = o.attrs[\"PATHWAY-ID\"];\n    if (this.currentLevelIndex = e, this.currentLevel = o, r === e &amp;&amp; n &amp;&amp; i === a)\n      return;\n    this.log(`Switching to level ${e} (${o.height ? o.height + \"p \" : \"\"}${o.videoRange ? o.videoRange + \" \" : \"\"}${o.codecSet ? o.codecSet + \" \" : \"\"}@${o.bitrate})${a ? \" with Pathway \" + a : \"\"} from level ${r}${i ? \" with Pathway \" + i : \"\"}`);\n    const l = {\n      level: e,\n      attrs: o.attrs,\n      details: o.details,\n      bitrate: o.bitrate,\n      averageBitrate: o.averageBitrate,\n      maxBitrate: o.maxBitrate,\n      realBitrate: o.realBitrate,\n      width: o.width,\n      height: o.height,\n      codecSet: o.codecSet,\n      audioCodec: o.audioCodec,\n      videoCodec: o.videoCodec,\n      audioGroups: o.audioGroups,\n      subtitleGroups: o.subtitleGroups,\n      loaded: o.loaded,\n      loadError: o.loadError,\n      fragmentError: o.fragmentError,\n      name: o.name,\n      id: o.id,\n      uri: o.uri,\n      url: o.url,\n      urlId: 0,\n      audioGroupIds: o.audioGroupIds,\n      textGroupIds: o.textGroupIds\n    };\n    this.hls.trigger(I.LEVEL_SWITCHING, l);\n    const c = o.details;\n    if (!c || c.live) {\n      const u = this.switchParams(o.uri, n == null ? void 0 : n.details, c);\n      this.loadPlaylist(u);\n    }\n  }\n  get manualLevel() {\n    return this.manualLevelIndex;\n  }\n  set manualLevel(e) {\n    this.manualLevelIndex = e, this._startLevel === void 0 &amp;&amp; (this._startLevel = e), e !== -1 &amp;&amp; (this.level = e);\n  }\n  get firstLevel() {\n    return this._firstLevel;\n  }\n  set firstLevel(e) {\n    this._firstLevel = e;\n  }\n  get startLevel() {\n    if (this._startLevel === void 0) {\n      const e = this.hls.config.startLevel;\n      return e !== void 0 ? e : this.hls.firstAutoLevel;\n    }\n    return this._startLevel;\n  }\n  set startLevel(e) {\n    this._startLevel = e;\n  }\n  get pathways() {\n    return this.steering ? this.steering.pathways() : [];\n  }\n  get pathwayPriority() {\n    return this.steering ? this.steering.pathwayPriority : null;\n  }\n  set pathwayPriority(e) {\n    if (this.steering) {\n      const t = this.steering.pathways(), r = e.filter((n) =&gt; t.indexOf(n) !== -1);\n      if (e.length &lt; 1) {\n        this.warn(`pathwayPriority ${e} should contain at least one pathway from list: ${t}`);\n        return;\n      }\n      this.steering.pathwayPriority = r;\n    }\n  }\n  onError(e, t) {\n    t.fatal || !t.context || t.context.type === Ke.LEVEL &amp;&amp; t.context.level === this.level &amp;&amp; this.checkRetry(t);\n  }\n  // reset errors on the successful load of a fragment\n  onFragBuffered(e, {\n    frag: t\n  }) {\n    if (t !== void 0 &amp;&amp; t.type === pe.MAIN) {\n      const r = t.elementaryStreams;\n      if (!Object.keys(r).some((i) =&gt; !!r[i]))\n        return;\n      const n = this._levels[t.level];\n      n != null &amp;&amp; n.loadError &amp;&amp; (this.log(`Resetting level error count of ${n.loadError} on frag buffered`), n.loadError = 0);\n    }\n  }\n  onLevelLoaded(e, t) {\n    var r;\n    const {\n      level: n,\n      details: i\n    } = t, o = t.levelInfo;\n    if (!o) {\n      var a;\n      this.warn(`Invalid level index ${n}`), (a = t.deliveryDirectives) != null &amp;&amp; a.skip &amp;&amp; (i.deltaUpdateFailed = !0);\n      return;\n    }\n    if (o === this.currentLevel || t.withoutMultiVariant) {\n      o.fragmentError === 0 &amp;&amp; (o.loadError = 0);\n      let l = o.details;\n      l === t.details &amp;&amp; l.advanced &amp;&amp; (l = void 0), this.playlistLoaded(n, t, l);\n    } else (r = t.deliveryDirectives) != null &amp;&amp; r.skip &amp;&amp; (i.deltaUpdateFailed = !0);\n  }\n  loadPlaylist(e) {\n    super.loadPlaylist(), this.shouldLoadPlaylist(this.currentLevel) &amp;&amp; this.scheduleLoading(this.currentLevel, e);\n  }\n  loadingPlaylist(e, t) {\n    super.loadingPlaylist(e, t);\n    const r = this.getUrlWithDirectives(e.uri, t), n = this.currentLevelIndex, i = e.attrs[\"PATHWAY-ID\"], o = e.details, a = o == null ? void 0 : o.age;\n    this.log(`Loading level index ${n}${(t == null ? void 0 : t.msn) !== void 0 ? \" at sn \" + t.msn + \" part \" + t.part : \"\"}${i ? \" Pathway \" + i : \"\"}${a &amp;&amp; o.live ? \" age \" + a.toFixed(1) + (o.type &amp;&amp; \" \" + o.type || \"\") : \"\"} ${r}`), this.hls.trigger(I.LEVEL_LOADING, {\n      url: r,\n      level: n,\n      levelInfo: e,\n      pathwayId: e.attrs[\"PATHWAY-ID\"],\n      id: 0,\n      // Deprecated Level urlId\n      deliveryDirectives: t || null\n    });\n  }\n  get nextLoadLevel() {\n    return this.manualLevelIndex !== -1 ? this.manualLevelIndex : this.hls.nextAutoLevel;\n  }\n  set nextLoadLevel(e) {\n    this.level = e, this.manualLevelIndex === -1 &amp;&amp; (this.hls.nextAutoLevel = e);\n  }\n  removeLevel(e) {\n    var t;\n    if (this._levels.length === 1)\n      return;\n    const r = this._levels.filter((i, o) =&gt; o !== e ? !0 : (this.steering &amp;&amp; this.steering.removeLevel(i), i === this.currentLevel &amp;&amp; (this.currentLevel = null, this.currentLevelIndex = -1, i.details &amp;&amp; i.details.fragments.forEach((a) =&gt; a.level = -1)), !1));\n    rp(r), this._levels = r, this.currentLevelIndex &gt; -1 &amp;&amp; (t = this.currentLevel) != null &amp;&amp; t.details &amp;&amp; (this.currentLevelIndex = this.currentLevel.details.fragments[0].level), this.manualLevelIndex &gt; -1 &amp;&amp; (this.manualLevelIndex = this.currentLevelIndex);\n    const n = r.length - 1;\n    this._firstLevel = Math.min(this._firstLevel, n), this._startLevel &amp;&amp; (this._startLevel = Math.min(this._startLevel, n)), this.hls.trigger(I.LEVELS_UPDATED, {\n      levels: r\n    });\n  }\n  onLevelsUpdated(e, {\n    levels: t\n  }) {\n    this._levels = t;\n  }\n  checkMaxAutoUpdated() {\n    const {\n      autoLevelCapping: e,\n      maxAutoLevel: t,\n      maxHdcpLevel: r\n    } = this.hls;\n    this._maxAutoLevel !== t &amp;&amp; (this._maxAutoLevel = t, this.hls.trigger(I.MAX_AUTO_LEVEL_UPDATED, {\n      autoLevelCapping: e,\n      levels: this.levels,\n      maxAutoLevel: t,\n      minAutoLevel: this.hls.minAutoLevel,\n      maxHdcpLevel: r\n    }));\n  }\n}\nfunction df(s) {\n  const e = {};\n  s.forEach((t) =&gt; {\n    const r = t.groupId || \"\";\n    t.id = e[r] = e[r] || 0, e[r]++;\n  });\n}\nfunction Xp() {\n  return self.SourceBuffer || self.WebKitSourceBuffer;\n}\nfunction Jp() {\n  if (!Ms())\n    return !1;\n  const e = Xp();\n  return !e || e.prototype &amp;&amp; typeof e.prototype.appendBuffer == \"function\" &amp;&amp; typeof e.prototype.remove == \"function\";\n}\nfunction vA() {\n  if (!Jp())\n    return !1;\n  const s = Ms();\n  return typeof (s == null ? void 0 : s.isTypeSupported) == \"function\" &amp;&amp; ([\"avc1.42E01E,mp4a.40.2\", \"av01.0.01M.08\", \"vp09.00.50.08\"].some((e) =&gt; s.isTypeSupported(pi(e, \"video\"))) || [\"mp4a.40.2\", \"fLaC\"].some((e) =&gt; s.isTypeSupported(pi(e, \"audio\"))));\n}\nfunction EA() {\n  var s;\n  const e = Xp();\n  return typeof (e == null || (s = e.prototype) == null ? void 0 : s.changeType) == \"function\";\n}\nconst xA = 100;\nclass SA extends Tu {\n  constructor(e, t, r) {\n    super(e, t, r, \"stream-controller\", pe.MAIN), this.audioCodecSwap = !1, this.level = -1, this._forceStartLoad = !1, this._hasEnoughToStart = !1, this.altAudio = 0, this.audioOnly = !1, this.fragPlaying = null, this.fragLastKbps = 0, this.couldBacktrack = !1, this.backtrackFragment = null, this.audioCodecSwitch = !1, this.videoBuffer = null, this.onMediaPlaying = () =&gt; {\n      this.tick();\n    }, this.onMediaSeeked = () =&gt; {\n      const n = this.media, i = n ? n.currentTime : null;\n      if (i === null || !ue(i) || (this.log(`Media seeked to ${i.toFixed(3)}`), !this.getBufferedFrag(i)))\n        return;\n      const o = this.getFwdBufferInfoAtPos(n, i, pe.MAIN, 0);\n      if (o === null || o.len === 0) {\n        this.warn(`Main forward buffer length at ${i} on \"seeked\" event ${o ? o.len : \"empty\"})`);\n        return;\n      }\n      this.tick();\n    }, this.registerListeners();\n  }\n  registerListeners() {\n    super.registerListeners();\n    const {\n      hls: e\n    } = this;\n    e.on(I.MANIFEST_PARSED, this.onManifestParsed, this), e.on(I.LEVEL_LOADING, this.onLevelLoading, this), e.on(I.LEVEL_LOADED, this.onLevelLoaded, this), e.on(I.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.on(I.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.on(I.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.on(I.BUFFER_CREATED, this.onBufferCreated, this), e.on(I.BUFFER_FLUSHED, this.onBufferFlushed, this), e.on(I.LEVELS_UPDATED, this.onLevelsUpdated, this), e.on(I.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  unregisterListeners() {\n    super.unregisterListeners();\n    const {\n      hls: e\n    } = this;\n    e.off(I.MANIFEST_PARSED, this.onManifestParsed, this), e.off(I.LEVEL_LOADED, this.onLevelLoaded, this), e.off(I.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this), e.off(I.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this), e.off(I.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this), e.off(I.BUFFER_CREATED, this.onBufferCreated, this), e.off(I.BUFFER_FLUSHED, this.onBufferFlushed, this), e.off(I.LEVELS_UPDATED, this.onLevelsUpdated, this), e.off(I.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  onHandlerDestroying() {\n    this.onMediaPlaying = this.onMediaSeeked = null, this.unregisterListeners(), super.onHandlerDestroying();\n  }\n  startLoad(e, t) {\n    if (this.levels) {\n      const {\n        lastCurrentTime: r,\n        hls: n\n      } = this;\n      if (this.stopLoad(), this.setInterval(xA), this.level = -1, !this.startFragRequested) {\n        let i = n.startLevel;\n        i === -1 &amp;&amp; (n.config.testBandwidth &amp;&amp; this.levels.length &gt; 1 ? (i = 0, this.bitrateTest = !0) : i = n.firstAutoLevel), n.nextLoadLevel = i, this.level = n.loadLevel, this._hasEnoughToStart = !!t;\n      }\n      r &gt; 0 &amp;&amp; e === -1 &amp;&amp; !t &amp;&amp; (this.log(`Override startPosition with lastCurrentTime @${r.toFixed(3)}`), e = r), this.state = ne.IDLE, this.nextLoadPosition = this.lastCurrentTime = e + this.timelineOffset, this.startPosition = t ? -1 : e, this.tick();\n    } else\n      this._forceStartLoad = !0, this.state = ne.STOPPED;\n  }\n  stopLoad() {\n    this._forceStartLoad = !1, super.stopLoad();\n  }\n  doTick() {\n    switch (this.state) {\n      case ne.WAITING_LEVEL: {\n        const {\n          levels: e,\n          level: t\n        } = this, r = e == null ? void 0 : e[t], n = r == null ? void 0 : r.details;\n        if (n &amp;&amp; (!n.live || this.levelLastLoaded === r &amp;&amp; !this.waitForLive(r))) {\n          if (this.waitForCdnTuneIn(n))\n            break;\n          this.state = ne.IDLE;\n          break;\n        } else if (this.hls.nextLoadLevel !== this.level) {\n          this.state = ne.IDLE;\n          break;\n        }\n        break;\n      }\n      case ne.FRAG_LOADING_WAITING_RETRY:\n        this.checkRetryDate();\n        break;\n    }\n    this.state === ne.IDLE &amp;&amp; this.doTickIdle(), this.onTickEnd();\n  }\n  onTickEnd() {\n    var e;\n    super.onTickEnd(), (e = this.media) != null &amp;&amp; e.readyState &amp;&amp; this.media.seeking === !1 &amp;&amp; (this.lastCurrentTime = this.media.currentTime), this.checkFragmentChanged();\n  }\n  doTickIdle() {\n    const {\n      hls: e,\n      levelLastLoaded: t,\n      levels: r,\n      media: n\n    } = this;\n    if (t === null || !n &amp;&amp; !this.primaryPrefetch &amp;&amp; (this.startFragRequested || !e.config.startFragPrefetch) || this.altAudio &amp;&amp; this.audioOnly)\n      return;\n    const i = this.buffering ? e.nextLoadLevel : e.loadLevel;\n    if (!(r != null &amp;&amp; r[i]))\n      return;\n    const o = r[i], a = this.getMainFwdBufferInfo();\n    if (a === null)\n      return;\n    const l = this.getLevelDetails();\n    if (l &amp;&amp; this._streamEnded(a, l)) {\n      const y = {};\n      this.altAudio === 2 &amp;&amp; (y.type = \"video\"), this.hls.trigger(I.BUFFER_EOS, y), this.state = ne.ENDED;\n      return;\n    }\n    if (!this.buffering)\n      return;\n    e.loadLevel !== i &amp;&amp; e.manualLevel === -1 &amp;&amp; this.log(`Adapting to level ${i} from level ${this.level}`), this.level = e.nextLoadLevel = i;\n    const c = o.details;\n    if (!c || this.state === ne.WAITING_LEVEL || this.waitForLive(o)) {\n      this.level = i, this.state = ne.WAITING_LEVEL, this.startFragRequested = !1;\n      return;\n    }\n    const u = a.len, d = this.getMaxBufferLength(o.maxBitrate);\n    if (u &gt;= d)\n      return;\n    this.backtrackFragment &amp;&amp; this.backtrackFragment.start &gt; a.end &amp;&amp; (this.backtrackFragment = null);\n    const h = this.backtrackFragment ? this.backtrackFragment.start : a.end;\n    let f = this.getNextFragment(h, c);\n    if (this.couldBacktrack &amp;&amp; !this.fragPrevious &amp;&amp; f &amp;&amp; Vt(f) &amp;&amp; this.fragmentTracker.getState(f) !== Ht.OK) {\n      var p;\n      const E = ((p = this.backtrackFragment) != null ? p : f).sn - c.startSN, b = c.fragments[E - 1];\n      b &amp;&amp; f.cc === b.cc &amp;&amp; (f = b, this.fragmentTracker.removeFragment(b));\n    } else this.backtrackFragment &amp;&amp; a.len &amp;&amp; (this.backtrackFragment = null);\n    if (f &amp;&amp; this.isLoopLoading(f, h)) {\n      if (!f.gap) {\n        const E = this.audioOnly &amp;&amp; !this.altAudio ? ot.AUDIO : ot.VIDEO, b = (E === ot.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n        b &amp;&amp; this.afterBufferFlushed(b, E, pe.MAIN);\n      }\n      f = this.getNextFragmentLoopLoading(f, c, a, pe.MAIN, d);\n    }\n    f &amp;&amp; (f.initSegment &amp;&amp; !f.initSegment.data &amp;&amp; !this.bitrateTest &amp;&amp; (f = f.initSegment), this.loadFragment(f, o, h));\n  }\n  loadFragment(e, t, r) {\n    const n = this.fragmentTracker.getState(e);\n    n === Ht.NOT_LOADED || n === Ht.PARTIAL ? Vt(e) ? this.bitrateTest ? (this.log(`Fragment ${e.sn} of level ${e.level} is being downloaded to test bitrate and will not be buffered`), this._loadBitrateTestFrag(e, t)) : super.loadFragment(e, t, r) : this._loadInitSegment(e, t) : this.clearTrackerIfNeeded(e);\n  }\n  getBufferedFrag(e) {\n    return this.fragmentTracker.getBufferedFrag(e, pe.MAIN);\n  }\n  followingBufferedFrag(e) {\n    return e ? this.getBufferedFrag(e.end + 0.5) : null;\n  }\n  /*\n    on immediate level switch :\n     - pause playback if playing\n     - cancel any pending load request\n     - and trigger a buffer flush\n  */\n  immediateLevelSwitch() {\n    this.abortCurrentFrag(), this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n  }\n  /**\n   * try to switch ASAP without breaking video playback:\n   * in order to ensure smooth but quick level switching,\n   * we need to find the next flushable buffer range\n   * we should take into account new segment fetch time\n   */\n  nextLevelSwitch() {\n    const {\n      levels: e,\n      media: t\n    } = this;\n    if (t != null &amp;&amp; t.readyState) {\n      let r;\n      const n = this.getAppendedFrag(t.currentTime);\n      n &amp;&amp; n.start &gt; 1 &amp;&amp; this.flushMainBuffer(0, n.start - 1);\n      const i = this.getLevelDetails();\n      if (i != null &amp;&amp; i.live) {\n        const a = this.getMainFwdBufferInfo();\n        if (!a || a.len &lt; i.targetduration * 2)\n          return;\n      }\n      if (!t.paused &amp;&amp; e) {\n        const a = this.hls.nextLoadLevel, l = e[a], c = this.fragLastKbps;\n        c &amp;&amp; this.fragCurrent ? r = this.fragCurrent.duration * l.maxBitrate / (1e3 * c) + 1 : r = 0;\n      } else\n        r = 0;\n      const o = this.getBufferedFrag(t.currentTime + r);\n      if (o) {\n        const a = this.followingBufferedFrag(o);\n        if (a) {\n          this.abortCurrentFrag();\n          const l = a.maxStartPTS ? a.maxStartPTS : a.start, c = a.duration, u = Math.max(o.end, l + Math.min(Math.max(c - this.config.maxFragLookUpTolerance, c * (this.couldBacktrack ? 0.5 : 0.125)), c * (this.couldBacktrack ? 0.75 : 0.25)));\n          this.flushMainBuffer(u, Number.POSITIVE_INFINITY);\n        }\n      }\n    }\n  }\n  abortCurrentFrag() {\n    const e = this.fragCurrent;\n    switch (this.fragCurrent = null, this.backtrackFragment = null, e &amp;&amp; (e.abortRequests(), this.fragmentTracker.removeFragment(e)), this.state) {\n      case ne.KEY_LOADING:\n      case ne.FRAG_LOADING:\n      case ne.FRAG_LOADING_WAITING_RETRY:\n      case ne.PARSING:\n      case ne.PARSED:\n        this.state = ne.IDLE;\n        break;\n    }\n    this.nextLoadPosition = this.getLoadPosition();\n  }\n  flushMainBuffer(e, t) {\n    super.flushMainBuffer(e, t, this.altAudio === 2 ? \"video\" : null);\n  }\n  onMediaAttached(e, t) {\n    super.onMediaAttached(e, t);\n    const r = t.media;\n    cr(r, \"playing\", this.onMediaPlaying), cr(r, \"seeked\", this.onMediaSeeked);\n  }\n  onMediaDetaching(e, t) {\n    const {\n      media: r\n    } = this;\n    r &amp;&amp; (pr(r, \"playing\", this.onMediaPlaying), pr(r, \"seeked\", this.onMediaSeeked)), this.videoBuffer = null, this.fragPlaying = null, super.onMediaDetaching(e, t), !t.transferMedia &amp;&amp; (this._hasEnoughToStart = !1);\n  }\n  onManifestLoading() {\n    super.onManifestLoading(), this.log(\"Trigger BUFFER_RESET\"), this.hls.trigger(I.BUFFER_RESET, void 0), this.couldBacktrack = !1, this.fragLastKbps = 0, this.fragPlaying = this.backtrackFragment = null, this.altAudio = 0, this.audioOnly = !1;\n  }\n  onManifestParsed(e, t) {\n    let r = !1, n = !1;\n    for (let i = 0; i &lt; t.levels.length; i++) {\n      const o = t.levels[i].audioCodec;\n      o &amp;&amp; (r = r || o.indexOf(\"mp4a.40.2\") !== -1, n = n || o.indexOf(\"mp4a.40.5\") !== -1);\n    }\n    this.audioCodecSwitch = r &amp;&amp; n &amp;&amp; !EA(), this.audioCodecSwitch &amp;&amp; this.log(\"Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC\"), this.levels = t.levels, this.startFragRequested = !1;\n  }\n  onLevelLoading(e, t) {\n    const {\n      levels: r\n    } = this;\n    if (!r || this.state !== ne.IDLE)\n      return;\n    const n = t.levelInfo;\n    (!n.details || n.details.live &amp;&amp; (this.levelLastLoaded !== n || n.details.expired) || this.waitForCdnTuneIn(n.details)) &amp;&amp; (this.state = ne.WAITING_LEVEL);\n  }\n  onLevelLoaded(e, t) {\n    var r;\n    const {\n      levels: n,\n      startFragRequested: i\n    } = this, o = t.level, a = t.details, l = a.totalduration;\n    if (!n) {\n      this.warn(`Levels were reset while loading level ${o}`);\n      return;\n    }\n    this.log(`Level ${o} loaded [${a.startSN},${a.endSN}]${a.lastPartSn ? `[part-${a.lastPartSn}-${a.lastPartIndex}]` : \"\"}, cc [${a.startCC}, ${a.endCC}] duration:${l}`);\n    const c = t.levelInfo, u = this.fragCurrent;\n    u &amp;&amp; (this.state === ne.FRAG_LOADING || this.state === ne.FRAG_LOADING_WAITING_RETRY) &amp;&amp; u.level !== t.level &amp;&amp; u.loader &amp;&amp; this.abortCurrentFrag();\n    let d = 0;\n    if (a.live || (r = c.details) != null &amp;&amp; r.live) {\n      var h;\n      if (this.checkLiveUpdate(a), a.deltaUpdateFailed)\n        return;\n      d = this.alignPlaylists(a, c.details, (h = this.levelLastLoaded) == null ? void 0 : h.details);\n    }\n    if (c.details = a, this.levelLastLoaded = c, i || this.setStartPosition(a, d), this.hls.trigger(I.LEVEL_UPDATED, {\n      details: a,\n      level: o\n    }), this.state === ne.WAITING_LEVEL) {\n      if (this.waitForCdnTuneIn(a))\n        return;\n      this.state = ne.IDLE;\n    }\n    i &amp;&amp; a.live &amp;&amp; this.synchronizeToLiveEdge(a), this.tick();\n  }\n  synchronizeToLiveEdge(e) {\n    const {\n      config: t,\n      media: r\n    } = this;\n    if (!r)\n      return;\n    const n = this.hls.liveSyncPosition, i = this.getLoadPosition(), o = e.fragmentStart, a = e.edge, l = i &gt;= o - t.maxFragLookUpTolerance &amp;&amp; i &lt;= a;\n    if (n !== null &amp;&amp; r.duration &gt; n &amp;&amp; (i &lt; n || !l)) {\n      const u = t.liveMaxLatencyDuration !== void 0 ? t.liveMaxLatencyDuration : t.liveMaxLatencyDurationCount * e.targetduration;\n      if ((!l &amp;&amp; r.readyState &lt; 4 || i &lt; a - u) &amp;&amp; (this._hasEnoughToStart || (this.nextLoadPosition = n), r.readyState))\n        if (this.warn(`Playback: ${i.toFixed(3)} is located too far from the end of live sliding playlist: ${a}, reset currentTime to : ${n.toFixed(3)}`), this.config.liveSyncMode === \"buffered\") {\n          var c;\n          const d = Ce.bufferInfo(r, n, 0);\n          if (!((c = d.buffered) != null &amp;&amp; c.length)) {\n            r.currentTime = n;\n            return;\n          }\n          if (d.start &lt;= i) {\n            r.currentTime = n;\n            return;\n          }\n          const {\n            nextStart: f\n          } = Ce.bufferedInfo(d.buffered, i, 0);\n          f &amp;&amp; (r.currentTime = f);\n        } else\n          r.currentTime = n;\n    }\n  }\n  _handleFragmentLoadProgress(e) {\n    var t;\n    const r = e.frag, {\n      part: n,\n      payload: i\n    } = e, {\n      levels: o\n    } = this;\n    if (!o) {\n      this.warn(`Levels were reset while fragment load was in progress. Fragment ${r.sn} of level ${r.level} will not be buffered`);\n      return;\n    }\n    const a = o[r.level];\n    if (!a) {\n      this.warn(`Level ${r.level} not found on progress`);\n      return;\n    }\n    const l = a.details;\n    if (!l) {\n      this.warn(`Dropping fragment ${r.sn} of level ${r.level} after level details were reset`), this.fragmentTracker.removeFragment(r);\n      return;\n    }\n    const c = a.videoCodec, u = l.PTSKnown || !l.live, d = (t = r.initSegment) == null ? void 0 : t.data, h = this._getAudioCodec(a), f = this.transmuxer = this.transmuxer || new wp(this.hls, pe.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this)), p = n ? n.index : -1, y = p !== -1, E = new Eu(r.level, r.sn, r.stats.chunkCount, i.byteLength, p, y), b = this.initPTS[r.cc];\n    f.push(i, d, h, c, r, n, l.totalduration, u, E, b);\n  }\n  onAudioTrackSwitching(e, t) {\n    const r = this.hls, n = this.altAudio === 2;\n    if (Qo(t.url, r))\n      this.altAudio = 1;\n    else {\n      if (this.mediaBuffer !== this.media) {\n        this.log(\"Switching on main audio, use media.buffered to schedule main fragment loading\"), this.mediaBuffer = this.media;\n        const o = this.fragCurrent;\n        o &amp;&amp; (this.log(\"Switching to main audio track, cancel main fragment load\"), o.abortRequests(), this.fragmentTracker.removeFragment(o)), this.resetTransmuxer(), this.resetLoadingState();\n      } else this.audioOnly &amp;&amp; this.resetTransmuxer();\n      if (n) {\n        this.fragmentTracker.removeAllFragments(), r.once(I.BUFFER_FLUSHED, () =&gt; {\n          this.hls &amp;&amp; this.hls.trigger(I.AUDIO_TRACK_SWITCHED, t);\n        }), r.trigger(I.BUFFER_FLUSHING, {\n          startOffset: 0,\n          endOffset: Number.POSITIVE_INFINITY,\n          type: null\n        });\n        return;\n      }\n      r.trigger(I.AUDIO_TRACK_SWITCHED, t);\n    }\n  }\n  onAudioTrackSwitched(e, t) {\n    const r = Qo(t.url, this.hls);\n    if (r) {\n      const n = this.videoBuffer;\n      n &amp;&amp; this.mediaBuffer !== n &amp;&amp; (this.log(\"Switching on alternate audio, use video.buffered to schedule main fragment loading\"), this.mediaBuffer = n);\n    }\n    this.altAudio = r ? 2 : 0, this.tick();\n  }\n  onBufferCreated(e, t) {\n    const r = t.tracks;\n    let n, i, o = !1;\n    for (const a in r) {\n      const l = r[a];\n      if (l.id === \"main\") {\n        if (i = a, n = l, a === \"video\") {\n          const c = r[a];\n          c &amp;&amp; (this.videoBuffer = c.buffer);\n        }\n      } else\n        o = !0;\n    }\n    o &amp;&amp; n ? (this.log(`Alternate track found, use ${i}.buffered to schedule main fragment loading`), this.mediaBuffer = n.buffer) : this.mediaBuffer = this.media;\n  }\n  onFragBuffered(e, t) {\n    const {\n      frag: r,\n      part: n\n    } = t, i = r.type === pe.MAIN;\n    if (i) {\n      if (this.fragContextChanged(r)) {\n        this.warn(`Fragment ${r.sn}${n ? \" p: \" + n.index : \"\"} of level ${r.level} finished buffering, but was aborted. state: ${this.state}`), this.state === ne.PARSED &amp;&amp; (this.state = ne.IDLE);\n        return;\n      }\n      const a = n ? n.stats : r.stats;\n      this.fragLastKbps = Math.round(8 * a.total / (a.buffering.end - a.loading.first)), Vt(r) &amp;&amp; (this.fragPrevious = r), this.fragBufferedComplete(r, n);\n    }\n    const o = this.media;\n    o &amp;&amp; (!this._hasEnoughToStart &amp;&amp; Ce.getBuffered(o).length &amp;&amp; (this._hasEnoughToStart = !0, this.seekToStartPos()), i &amp;&amp; this.tick());\n  }\n  get hasEnoughToStart() {\n    return this._hasEnoughToStart;\n  }\n  onError(e, t) {\n    var r;\n    if (t.fatal) {\n      this.state = ne.ERROR;\n      return;\n    }\n    switch (t.details) {\n      case J.FRAG_GAP:\n      case J.FRAG_PARSING_ERROR:\n      case J.FRAG_DECRYPT_ERROR:\n      case J.FRAG_LOAD_ERROR:\n      case J.FRAG_LOAD_TIMEOUT:\n      case J.KEY_LOAD_ERROR:\n      case J.KEY_LOAD_TIMEOUT:\n        this.onFragmentOrKeyLoadError(pe.MAIN, t);\n        break;\n      case J.LEVEL_LOAD_ERROR:\n      case J.LEVEL_LOAD_TIMEOUT:\n      case J.LEVEL_PARSING_ERROR:\n        !t.levelRetry &amp;&amp; this.state === ne.WAITING_LEVEL &amp;&amp; ((r = t.context) == null ? void 0 : r.type) === Ke.LEVEL &amp;&amp; (this.state = ne.IDLE);\n        break;\n      case J.BUFFER_ADD_CODEC_ERROR:\n      case J.BUFFER_APPEND_ERROR:\n        if (t.parent !== \"main\")\n          return;\n        this.reduceLengthAndFlushBuffer(t) &amp;&amp; this.resetLoadingState();\n        break;\n      case J.BUFFER_FULL_ERROR:\n        if (t.parent !== \"main\")\n          return;\n        this.reduceLengthAndFlushBuffer(t) &amp;&amp; (!this.config.interstitialsController &amp;&amp; this.config.assetPlayerId ? this._hasEnoughToStart = !0 : this.flushMainBuffer(0, Number.POSITIVE_INFINITY));\n        break;\n      case J.INTERNAL_EXCEPTION:\n        this.recoverWorkerError(t);\n        break;\n    }\n  }\n  onFragLoadEmergencyAborted() {\n    this.state = ne.IDLE, this._hasEnoughToStart || (this.startFragRequested = !1, this.nextLoadPosition = this.lastCurrentTime), this.tickImmediate();\n  }\n  onBufferFlushed(e, {\n    type: t\n  }) {\n    if (t !== ot.AUDIO || !this.altAudio) {\n      const r = (t === ot.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n      r &amp;&amp; (this.afterBufferFlushed(r, t, pe.MAIN), this.tick());\n    }\n  }\n  onLevelsUpdated(e, t) {\n    this.level &gt; -1 &amp;&amp; this.fragCurrent &amp;&amp; (this.level = this.fragCurrent.level, this.level === -1 &amp;&amp; this.resetWhenMissingContext(this.fragCurrent)), this.levels = t.levels;\n  }\n  swapAudioCodec() {\n    this.audioCodecSwap = !this.audioCodecSwap;\n  }\n  /**\n   * Seeks to the set startPosition if not equal to the mediaElement's current time.\n   */\n  seekToStartPos() {\n    const {\n      media: e\n    } = this;\n    if (!e)\n      return;\n    const t = e.currentTime;\n    let r = this.startPosition;\n    if (r &gt;= 0 &amp;&amp; t &lt; r) {\n      if (e.seeking) {\n        this.log(`could not seek to ${r}, already seeking at ${t}`);\n        return;\n      }\n      const n = this.timelineOffset;\n      n &amp;&amp; r &amp;&amp; (r += n);\n      const i = this.getLevelDetails(), o = Ce.getBuffered(e), a = o.length ? o.start(0) : 0, l = a - r, c = Math.max(this.config.maxBufferHole, this.config.maxFragLookUpTolerance);\n      (this.config.startOnSegmentBoundary || l &gt; 0 &amp;&amp; (l &lt; c || this.loadingParts &amp;&amp; l &lt; 2 * ((i == null ? void 0 : i.partTarget) || 0))) &amp;&amp; (this.log(`adjusting start position by ${l} to match buffer start`), r += l, this.startPosition = r), t &lt; r &amp;&amp; (this.log(`seek to target start position ${r} from current time ${t} buffer start ${a}`), e.currentTime = r);\n    }\n  }\n  _getAudioCodec(e) {\n    let t = this.config.defaultAudioCodec || e.audioCodec;\n    return this.audioCodecSwap &amp;&amp; t &amp;&amp; (this.log(\"Swapping audio codec\"), t.indexOf(\"mp4a.40.5\") !== -1 ? t = \"mp4a.40.2\" : t = \"mp4a.40.5\"), t;\n  }\n  _loadBitrateTestFrag(e, t) {\n    e.bitrateTest = !0, this._doFragLoad(e, t).then((r) =&gt; {\n      const {\n        hls: n\n      } = this, i = r == null ? void 0 : r.frag;\n      if (!i || this.fragContextChanged(i))\n        return;\n      t.fragmentError = 0, this.state = ne.IDLE, this.startFragRequested = !1, this.bitrateTest = !1;\n      const o = i.stats;\n      o.parsing.start = o.parsing.end = o.buffering.start = o.buffering.end = self.performance.now(), n.trigger(I.FRAG_LOADED, r), i.bitrateTest = !1;\n    }).catch((r) =&gt; {\n      this.state === ne.STOPPED || this.state === ne.ERROR || (this.warn(r), this.resetFragmentLoading(e));\n    });\n  }\n  _handleTransmuxComplete(e) {\n    const t = this.playlistType, {\n      hls: r\n    } = this, {\n      remuxResult: n,\n      chunkMeta: i\n    } = e, o = this.getCurrentContext(i);\n    if (!o) {\n      this.resetWhenMissingContext(i);\n      return;\n    }\n    const {\n      frag: a,\n      part: l,\n      level: c\n    } = o, {\n      video: u,\n      text: d,\n      id3: h,\n      initSegment: f\n    } = n, {\n      details: p\n    } = c, y = this.altAudio ? void 0 : n.audio;\n    if (this.fragContextChanged(a)) {\n      this.fragmentTracker.removeFragment(a);\n      return;\n    }\n    if (this.state = ne.PARSING, f) {\n      const E = f.tracks;\n      if (E) {\n        const F = a.initSegment || a;\n        if (this.unhandledEncryptionError(f, a))\n          return;\n        this._bufferInitSegment(c, E, F, i), r.trigger(I.FRAG_PARSING_INIT_SEGMENT, {\n          frag: F,\n          id: t,\n          tracks: E\n        });\n      }\n      const b = f.initPTS, R = f.timescale, A = this.initPTS[a.cc];\n      if (ue(b) &amp;&amp; (!A || A.baseTime !== b || A.timescale !== R)) {\n        const F = f.trackId;\n        this.initPTS[a.cc] = {\n          baseTime: b,\n          timescale: R,\n          trackId: F\n        }, r.trigger(I.INIT_PTS_FOUND, {\n          frag: a,\n          id: t,\n          initPTS: b,\n          timescale: R,\n          trackId: F\n        });\n      }\n    }\n    if (u &amp;&amp; p) {\n      y &amp;&amp; u.type === \"audiovideo\" &amp;&amp; this.logMuxedErr(a);\n      const E = p.fragments[a.sn - 1 - p.startSN], b = a.sn === p.startSN, R = !E || a.cc &gt; E.cc;\n      if (n.independent !== !1) {\n        const {\n          startPTS: A,\n          endPTS: F,\n          startDTS: M,\n          endDTS: H\n        } = u;\n        if (l)\n          l.elementaryStreams[u.type] = {\n            startPTS: A,\n            endPTS: F,\n            startDTS: M,\n            endDTS: H\n          };\n        else if (u.firstKeyFrame &amp;&amp; u.independent &amp;&amp; i.id === 1 &amp;&amp; !R &amp;&amp; (this.couldBacktrack = !0), u.dropped &amp;&amp; u.independent) {\n          const K = this.getMainFwdBufferInfo(), j = (K ? K.end : this.getLoadPosition()) + this.config.maxBufferHole, C = u.firstKeyFramePTS ? u.firstKeyFramePTS : A;\n          if (!b &amp;&amp; j &lt; C - this.config.maxBufferHole &amp;&amp; !R) {\n            this.backtrack(a);\n            return;\n          } else R &amp;&amp; (a.gap = !0);\n          a.setElementaryStreamInfo(u.type, a.start, F, a.start, H, !0);\n        } else b &amp;&amp; A - (p.appliedTimelineOffset || 0) &gt; xo &amp;&amp; (a.gap = !0);\n        a.setElementaryStreamInfo(u.type, A, F, M, H), this.backtrackFragment &amp;&amp; (this.backtrackFragment = a), this.bufferFragmentData(u, a, l, i, b || R);\n      } else if (b || R)\n        a.gap = !0;\n      else {\n        this.backtrack(a);\n        return;\n      }\n    }\n    if (y) {\n      const {\n        startPTS: E,\n        endPTS: b,\n        startDTS: R,\n        endDTS: A\n      } = y;\n      l &amp;&amp; (l.elementaryStreams[ot.AUDIO] = {\n        startPTS: E,\n        endPTS: b,\n        startDTS: R,\n        endDTS: A\n      }), a.setElementaryStreamInfo(ot.AUDIO, E, b, R, A), this.bufferFragmentData(y, a, l, i);\n    }\n    if (p &amp;&amp; h != null &amp;&amp; h.samples.length) {\n      const E = {\n        id: t,\n        frag: a,\n        details: p,\n        samples: h.samples\n      };\n      r.trigger(I.FRAG_PARSING_METADATA, E);\n    }\n    if (p &amp;&amp; d) {\n      const E = {\n        id: t,\n        frag: a,\n        details: p,\n        samples: d.samples\n      };\n      r.trigger(I.FRAG_PARSING_USERDATA, E);\n    }\n  }\n  logMuxedErr(e) {\n    this.warn(`${Vt(e) ? \"Media\" : \"Init\"} segment with muxed audiovideo where only video expected: ${e.url}`);\n  }\n  _bufferInitSegment(e, t, r, n) {\n    if (this.state !== ne.PARSING)\n      return;\n    this.audioOnly = !!t.audio &amp;&amp; !t.video, this.altAudio &amp;&amp; !this.audioOnly &amp;&amp; (delete t.audio, t.audiovideo &amp;&amp; this.logMuxedErr(r));\n    const {\n      audio: i,\n      video: o,\n      audiovideo: a\n    } = t;\n    if (i) {\n      const c = e.audioCodec;\n      let u = fo(i.codec, c);\n      u === \"mp4a\" &amp;&amp; (u = \"mp4a.40.5\");\n      const d = navigator.userAgent.toLowerCase();\n      if (this.audioCodecSwitch) {\n        u &amp;&amp; (u.indexOf(\"mp4a.40.5\") !== -1 ? u = \"mp4a.40.2\" : u = \"mp4a.40.5\");\n        const h = i.metadata;\n        h &amp;&amp; \"channelCount\" in h &amp;&amp; (h.channelCount || 1) !== 1 &amp;&amp; d.indexOf(\"firefox\") === -1 &amp;&amp; (u = \"mp4a.40.5\");\n      }\n      u &amp;&amp; u.indexOf(\"mp4a.40.5\") !== -1 &amp;&amp; d.indexOf(\"android\") !== -1 &amp;&amp; i.container !== \"audio/mpeg\" &amp;&amp; (u = \"mp4a.40.2\", this.log(`Android: force audio codec to ${u}`)), c &amp;&amp; c !== u &amp;&amp; this.log(`Swapping manifest audio codec \"${c}\" for \"${u}\"`), i.levelCodec = u, i.id = pe.MAIN, this.log(`Init audio buffer, container:${i.container}, codecs[selected/level/parsed]=[${u || \"\"}/${c || \"\"}/${i.codec}]`), delete t.audiovideo;\n    }\n    if (o) {\n      o.levelCodec = e.videoCodec, o.id = pe.MAIN;\n      const c = o.codec;\n      if ((c == null ? void 0 : c.length) === 4)\n        switch (c) {\n          case \"hvc1\":\n          case \"hev1\":\n            o.codec = \"hvc1.1.6.L120.90\";\n            break;\n          case \"av01\":\n            o.codec = \"av01.0.04M.08\";\n            break;\n          case \"avc1\":\n            o.codec = \"avc1.42e01e\";\n            break;\n        }\n      this.log(`Init video buffer, container:${o.container}, codecs[level/parsed]=[${e.videoCodec || \"\"}/${c}]${o.codec !== c ? \" parsed-corrected=\" + o.codec : \"\"}${o.supplemental ? \" supplemental=\" + o.supplemental : \"\"}`), delete t.audiovideo;\n    }\n    a &amp;&amp; (this.log(`Init audiovideo buffer, container:${a.container}, codecs[level/parsed]=[${e.codecs}/${a.codec}]`), delete t.video, delete t.audio);\n    const l = Object.keys(t);\n    if (l.length) {\n      if (this.hls.trigger(I.BUFFER_CODECS, t), !this.hls)\n        return;\n      l.forEach((c) =&gt; {\n        const d = t[c].initSegment;\n        d != null &amp;&amp; d.byteLength &amp;&amp; this.hls.trigger(I.BUFFER_APPENDING, {\n          type: c,\n          data: d,\n          frag: r,\n          part: null,\n          chunkMeta: n,\n          parent: r.type\n        });\n      });\n    }\n    this.tickImmediate();\n  }\n  getMainFwdBufferInfo() {\n    const e = this.mediaBuffer &amp;&amp; this.altAudio === 2 ? this.mediaBuffer : this.media;\n    return this.getFwdBufferInfo(e, pe.MAIN);\n  }\n  get maxBufferLength() {\n    const {\n      levels: e,\n      level: t\n    } = this, r = e == null ? void 0 : e[t];\n    return r ? this.getMaxBufferLength(r.maxBitrate) : this.config.maxBufferLength;\n  }\n  backtrack(e) {\n    this.couldBacktrack = !0, this.backtrackFragment = e, this.resetTransmuxer(), this.flushBufferGap(e), this.fragmentTracker.removeFragment(e), this.fragPrevious = null, this.nextLoadPosition = e.start, this.state = ne.IDLE;\n  }\n  checkFragmentChanged() {\n    const e = this.media;\n    let t = null;\n    if (e &amp;&amp; e.readyState &gt; 1 &amp;&amp; e.seeking === !1) {\n      const r = e.currentTime;\n      if (Ce.isBuffered(e, r) ? t = this.getAppendedFrag(r) : Ce.isBuffered(e, r + 0.1) &amp;&amp; (t = this.getAppendedFrag(r + 0.1)), t) {\n        this.backtrackFragment = null;\n        const n = this.fragPlaying, i = t.level;\n        (!n || t.sn !== n.sn || n.level !== i) &amp;&amp; (this.fragPlaying = t, this.hls.trigger(I.FRAG_CHANGED, {\n          frag: t\n        }), (!n || n.level !== i) &amp;&amp; this.hls.trigger(I.LEVEL_SWITCHED, {\n          level: i\n        }));\n      }\n    }\n  }\n  get nextLevel() {\n    const e = this.nextBufferedFrag;\n    return e ? e.level : -1;\n  }\n  get currentFrag() {\n    var e;\n    if (this.fragPlaying)\n      return this.fragPlaying;\n    const t = ((e = this.media) == null ? void 0 : e.currentTime) || this.lastCurrentTime;\n    return ue(t) ? this.getAppendedFrag(t) : null;\n  }\n  get currentProgramDateTime() {\n    var e;\n    const t = ((e = this.media) == null ? void 0 : e.currentTime) || this.lastCurrentTime;\n    if (ue(t)) {\n      const r = this.getLevelDetails(), n = this.currentFrag || (r ? Js(null, r.fragments, t) : null);\n      if (n) {\n        const i = n.programDateTime;\n        if (i !== null) {\n          const o = i + (t - n.start) * 1e3;\n          return new Date(o);\n        }\n      }\n    }\n    return null;\n  }\n  get currentLevel() {\n    const e = this.currentFrag;\n    return e ? e.level : -1;\n  }\n  get nextBufferedFrag() {\n    const e = this.currentFrag;\n    return e ? this.followingBufferedFrag(e) : null;\n  }\n  get forceStartLoad() {\n    return this._forceStartLoad;\n  }\n}\nclass bA extends Lr {\n  constructor(e, t) {\n    super(\"key-loader\", t), this.config = void 0, this.keyIdToKeyInfo = {}, this.emeController = null, this.config = e;\n  }\n  abort(e) {\n    for (const r in this.keyIdToKeyInfo) {\n      const n = this.keyIdToKeyInfo[r].loader;\n      if (n) {\n        var t;\n        if (e &amp;&amp; e !== ((t = n.context) == null ? void 0 : t.frag.type))\n          return;\n        n.abort();\n      }\n    }\n  }\n  detach() {\n    for (const e in this.keyIdToKeyInfo) {\n      const t = this.keyIdToKeyInfo[e];\n      (t.mediaKeySessionContext || t.decryptdata.isCommonEncryption) &amp;&amp; delete this.keyIdToKeyInfo[e];\n    }\n  }\n  destroy() {\n    this.detach();\n    for (const e in this.keyIdToKeyInfo) {\n      const t = this.keyIdToKeyInfo[e].loader;\n      t &amp;&amp; t.destroy();\n    }\n    this.keyIdToKeyInfo = {};\n  }\n  createKeyLoadError(e, t = J.KEY_LOAD_ERROR, r, n, i) {\n    return new as({\n      type: ve.NETWORK_ERROR,\n      details: t,\n      fatal: !1,\n      frag: e,\n      response: i,\n      error: r,\n      networkDetails: n\n    });\n  }\n  loadClear(e, t, r) {\n    if (this.emeController &amp;&amp; this.config.emeEnabled &amp;&amp; !this.emeController.getSelectedKeySystemFormats().length) {\n      if (t.length)\n        for (let n = 0, i = t.length; n &lt; i; n++) {\n          const o = t[n];\n          if (e.cc &lt;= o.cc &amp;&amp; (!Vt(e) || !Vt(o) || e.sn &lt; o.sn) || !r &amp;&amp; n == i - 1)\n            return this.emeController.selectKeySystemFormat(o).then((a) =&gt; {\n              if (!this.emeController)\n                return;\n              o.setKeyFormat(a);\n              const l = po(a);\n              if (l)\n                return this.emeController.getKeySystemAccess([l]);\n            });\n        }\n      if (this.config.requireKeySystemAccessOnStart) {\n        const n = zn(this.config);\n        if (n.length)\n          return this.emeController.getKeySystemAccess(n);\n      }\n    }\n    return null;\n  }\n  load(e) {\n    return !e.decryptdata &amp;&amp; e.encrypted &amp;&amp; this.emeController &amp;&amp; this.config.emeEnabled ? this.emeController.selectKeySystemFormat(e).then((t) =&gt; this.loadInternal(e, t)) : this.loadInternal(e);\n  }\n  loadInternal(e, t) {\n    var r, n;\n    t &amp;&amp; e.setKeyFormat(t);\n    const i = e.decryptdata;\n    if (!i) {\n      const c = new Error(t ? `Expected frag.decryptdata to be defined after setting format ${t}` : `Missing decryption data on fragment in onKeyLoading (emeEnabled with controller: ${this.emeController &amp;&amp; this.config.emeEnabled})`);\n      return Promise.reject(this.createKeyLoadError(e, J.KEY_LOAD_ERROR, c));\n    }\n    const o = i.uri;\n    if (!o)\n      return Promise.reject(this.createKeyLoadError(e, J.KEY_LOAD_ERROR, new Error(`Invalid key URI: \"${o}\"`)));\n    const a = kl(i);\n    let l = this.keyIdToKeyInfo[a];\n    if ((r = l) != null &amp;&amp; r.decryptdata.key)\n      return i.key = l.decryptdata.key, Promise.resolve({\n        frag: e,\n        keyInfo: l\n      });\n    if (this.emeController &amp;&amp; (n = l) != null &amp;&amp; n.keyLoadPromise)\n      switch (this.emeController.getKeyStatus(l.decryptdata)) {\n        case \"usable\":\n        case \"usable-in-future\":\n          return l.keyLoadPromise.then((u) =&gt; {\n            const {\n              keyInfo: d\n            } = u;\n            return i.key = d.decryptdata.key, {\n              frag: e,\n              keyInfo: d\n            };\n          });\n      }\n    switch (this.log(`${this.keyIdToKeyInfo[a] ? \"Rel\" : \"L\"}oading${i.keyId ? \" keyId: \" + fr(i.keyId) : \"\"} URI: ${i.uri} from ${e.type} ${e.level}`), l = this.keyIdToKeyInfo[a] = {\n      decryptdata: i,\n      keyLoadPromise: null,\n      loader: null,\n      mediaKeySessionContext: null\n    }, i.method) {\n      case \"SAMPLE-AES\":\n      case \"SAMPLE-AES-CENC\":\n      case \"SAMPLE-AES-CTR\":\n        return i.keyFormat === \"identity\" ? this.loadKeyHTTP(l, e) : this.loadKeyEME(l, e);\n      case \"AES-128\":\n      case \"AES-256\":\n      case \"AES-256-CTR\":\n        return this.loadKeyHTTP(l, e);\n      default:\n        return Promise.reject(this.createKeyLoadError(e, J.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: \"${i.method}\"`)));\n    }\n  }\n  loadKeyEME(e, t) {\n    const r = {\n      frag: t,\n      keyInfo: e\n    };\n    if (this.emeController &amp;&amp; this.config.emeEnabled) {\n      const n = this.emeController.loadKey(r);\n      return (e.keyLoadPromise = n.then((i) =&gt; (e.mediaKeySessionContext = i, r))).catch((i) =&gt; {\n        throw e.keyLoadPromise = null, \"data\" in i &amp;&amp; (i.data.frag = t), i;\n      });\n    }\n    return Promise.resolve(r);\n  }\n  loadKeyHTTP(e, t) {\n    const r = this.config, n = r.loader, i = new n(r);\n    return t.keyLoader = e.loader = i, e.keyLoadPromise = new Promise((o, a) =&gt; {\n      const l = {\n        keyInfo: e,\n        frag: t,\n        responseType: \"arraybuffer\",\n        url: e.decryptdata.uri\n      }, c = r.keyLoadPolicy.default, u = {\n        loadPolicy: c,\n        timeout: c.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0\n      }, d = {\n        onSuccess: (h, f, p, y) =&gt; {\n          const {\n            frag: E,\n            keyInfo: b\n          } = p, R = kl(b.decryptdata);\n          if (!E.decryptdata || b !== this.keyIdToKeyInfo[R])\n            return a(this.createKeyLoadError(E, J.KEY_LOAD_ERROR, new Error(\"after key load, decryptdata unset or changed\"), y));\n          b.decryptdata.key = E.decryptdata.key = new Uint8Array(h.data), E.keyLoader = null, b.loader = null, o({\n            frag: E,\n            keyInfo: b\n          });\n        },\n        onError: (h, f, p, y) =&gt; {\n          this.resetLoader(f), a(this.createKeyLoadError(t, J.KEY_LOAD_ERROR, new Error(`HTTP Error ${h.code} loading key ${h.text}`), p, tt({\n            url: l.url,\n            data: void 0\n          }, h)));\n        },\n        onTimeout: (h, f, p) =&gt; {\n          this.resetLoader(f), a(this.createKeyLoadError(t, J.KEY_LOAD_TIMEOUT, new Error(\"key loading timed out\"), p));\n        },\n        onAbort: (h, f, p) =&gt; {\n          this.resetLoader(f), a(this.createKeyLoadError(t, J.INTERNAL_ABORTED, new Error(\"key loading aborted\"), p));\n        }\n      };\n      i.load(l, u, d);\n    });\n  }\n  resetLoader(e) {\n    const {\n      frag: t,\n      keyInfo: r,\n      url: n\n    } = e, i = r.loader;\n    t.keyLoader === i &amp;&amp; (t.keyLoader = null, r.loader = null);\n    const o = kl(r.decryptdata) || n;\n    delete this.keyIdToKeyInfo[o], i &amp;&amp; i.destroy();\n  }\n}\nfunction kl(s) {\n  if (s.keyFormat !== lr.FAIRPLAY) {\n    const e = s.keyId;\n    if (e)\n      return fr(e);\n  }\n  return s.uri;\n}\nfunction hf(s) {\n  const {\n    type: e\n  } = s;\n  switch (e) {\n    case Ke.AUDIO_TRACK:\n      return pe.AUDIO;\n    case Ke.SUBTITLE_TRACK:\n      return pe.SUBTITLE;\n    default:\n      return pe.MAIN;\n  }\n}\nfunction Dl(s, e) {\n  let t = s.url;\n  return (t === void 0 || t.indexOf(\"data:\") === 0) &amp;&amp; (t = e.url), t;\n}\nclass TA {\n  constructor(e) {\n    this.hls = void 0, this.loaders = /* @__PURE__ */ Object.create(null), this.variableList = null, this.onManifestLoaded = this.checkAutostartLoad, this.hls = e, this.registerListeners();\n  }\n  startLoad(e) {\n  }\n  stopLoad() {\n    this.destroyInternalLoaders();\n  }\n  registerListeners() {\n    const {\n      hls: e\n    } = this;\n    e.on(I.MANIFEST_LOADING, this.onManifestLoading, this), e.on(I.LEVEL_LOADING, this.onLevelLoading, this), e.on(I.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.on(I.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this), e.on(I.LEVELS_UPDATED, this.onLevelsUpdated, this);\n  }\n  unregisterListeners() {\n    const {\n      hls: e\n    } = this;\n    e.off(I.MANIFEST_LOADING, this.onManifestLoading, this), e.off(I.LEVEL_LOADING, this.onLevelLoading, this), e.off(I.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this), e.off(I.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this), e.off(I.LEVELS_UPDATED, this.onLevelsUpdated, this);\n  }\n  /**\n   * Returns defaults or configured loader-type overloads (pLoader and loader config params)\n   */\n  createInternalLoader(e) {\n    const t = this.hls.config, r = t.pLoader, n = t.loader, i = r || n, o = new i(t);\n    return this.loaders[e.type] = o, o;\n  }\n  getInternalLoader(e) {\n    return this.loaders[e.type];\n  }\n  resetInternalLoader(e) {\n    this.loaders[e] &amp;&amp; delete this.loaders[e];\n  }\n  /**\n   * Call `destroy` on all internal loader instances mapped (one per context type)\n   */\n  destroyInternalLoaders() {\n    for (const e in this.loaders) {\n      const t = this.loaders[e];\n      t &amp;&amp; t.destroy(), this.resetInternalLoader(e);\n    }\n  }\n  destroy() {\n    this.variableList = null, this.unregisterListeners(), this.destroyInternalLoaders();\n  }\n  onManifestLoading(e, t) {\n    const {\n      url: r\n    } = t;\n    this.variableList = null, this.load({\n      id: null,\n      level: 0,\n      responseType: \"text\",\n      type: Ke.MANIFEST,\n      url: r,\n      deliveryDirectives: null,\n      levelOrTrack: null\n    });\n  }\n  onLevelLoading(e, t) {\n    const {\n      id: r,\n      level: n,\n      pathwayId: i,\n      url: o,\n      deliveryDirectives: a,\n      levelInfo: l\n    } = t;\n    this.load({\n      id: r,\n      level: n,\n      pathwayId: i,\n      responseType: \"text\",\n      type: Ke.LEVEL,\n      url: o,\n      deliveryDirectives: a,\n      levelOrTrack: l\n    });\n  }\n  onAudioTrackLoading(e, t) {\n    const {\n      id: r,\n      groupId: n,\n      url: i,\n      deliveryDirectives: o,\n      track: a\n    } = t;\n    this.load({\n      id: r,\n      groupId: n,\n      level: null,\n      responseType: \"text\",\n      type: Ke.AUDIO_TRACK,\n      url: i,\n      deliveryDirectives: o,\n      levelOrTrack: a\n    });\n  }\n  onSubtitleTrackLoading(e, t) {\n    const {\n      id: r,\n      groupId: n,\n      url: i,\n      deliveryDirectives: o,\n      track: a\n    } = t;\n    this.load({\n      id: r,\n      groupId: n,\n      level: null,\n      responseType: \"text\",\n      type: Ke.SUBTITLE_TRACK,\n      url: i,\n      deliveryDirectives: o,\n      levelOrTrack: a\n    });\n  }\n  onLevelsUpdated(e, t) {\n    const r = this.loaders[Ke.LEVEL];\n    if (r) {\n      const n = r.context;\n      n &amp;&amp; !t.levels.some((i) =&gt; i === n.levelOrTrack) &amp;&amp; (r.abort(), delete this.loaders[Ke.LEVEL]);\n    }\n  }\n  load(e) {\n    var t;\n    const r = this.hls.config;\n    let n = this.getInternalLoader(e);\n    if (n) {\n      const c = this.hls.logger, u = n.context;\n      if (u &amp;&amp; u.levelOrTrack === e.levelOrTrack &amp;&amp; (u.url === e.url || u.deliveryDirectives &amp;&amp; !e.deliveryDirectives)) {\n        u.url === e.url ? c.log(`[playlist-loader]: ignore ${e.url} ongoing request`) : c.log(`[playlist-loader]: ignore ${e.url} in favor of ${u.url}`);\n        return;\n      }\n      c.log(`[playlist-loader]: aborting previous loader for type: ${e.type}`), n.abort();\n    }\n    let i;\n    if (e.type === Ke.MANIFEST ? i = r.manifestLoadPolicy.default : i = nt({}, r.playlistLoadPolicy.default, {\n      timeoutRetry: null,\n      errorRetry: null\n    }), n = this.createInternalLoader(e), ue((t = e.deliveryDirectives) == null ? void 0 : t.part)) {\n      let c;\n      if (e.type === Ke.LEVEL &amp;&amp; e.level !== null ? c = this.hls.levels[e.level].details : e.type === Ke.AUDIO_TRACK &amp;&amp; e.id !== null ? c = this.hls.audioTracks[e.id].details : e.type === Ke.SUBTITLE_TRACK &amp;&amp; e.id !== null &amp;&amp; (c = this.hls.subtitleTracks[e.id].details), c) {\n        const u = c.partTarget, d = c.targetduration;\n        if (u &amp;&amp; d) {\n          const h = Math.max(u * 3, d * 0.8) * 1e3;\n          i = nt({}, i, {\n            maxTimeToFirstByteMs: Math.min(h, i.maxTimeToFirstByteMs),\n            maxLoadTimeMs: Math.min(h, i.maxTimeToFirstByteMs)\n          });\n        }\n      }\n    }\n    const o = i.errorRetry || i.timeoutRetry || {}, a = {\n      loadPolicy: i,\n      timeout: i.maxLoadTimeMs,\n      maxRetry: o.maxNumRetry || 0,\n      retryDelay: o.retryDelayMs || 0,\n      maxRetryDelay: o.maxRetryDelayMs || 0\n    }, l = {\n      onSuccess: (c, u, d, h) =&gt; {\n        const f = this.getInternalLoader(d);\n        this.resetInternalLoader(d.type);\n        const p = c.data;\n        u.parsing.start = performance.now(), zr.isMediaPlaylist(p) || d.type !== Ke.MANIFEST ? this.handleTrackOrLevelPlaylist(c, u, d, h || null, f) : this.handleMasterPlaylist(c, u, d, h);\n      },\n      onError: (c, u, d, h) =&gt; {\n        this.handleNetworkError(u, d, !1, c, h);\n      },\n      onTimeout: (c, u, d) =&gt; {\n        this.handleNetworkError(u, d, !0, void 0, c);\n      }\n    };\n    n.load(e, a, l);\n  }\n  checkAutostartLoad() {\n    if (!this.hls)\n      return;\n    const {\n      config: {\n        autoStartLoad: e,\n        startPosition: t\n      },\n      forceStartLoad: r\n    } = this.hls;\n    (e || r) &amp;&amp; (this.hls.logger.log(`${e ? \"auto\" : \"force\"} startLoad with configured startPosition ${t}`), this.hls.startLoad(t));\n  }\n  handleMasterPlaylist(e, t, r, n) {\n    const i = this.hls, o = e.data, a = Dl(e, r), l = zr.parseMasterPlaylist(o, a);\n    if (l.playlistParsingError) {\n      t.parsing.end = performance.now(), this.handleManifestParsingError(e, r, l.playlistParsingError, n, t);\n      return;\n    }\n    const {\n      contentSteering: c,\n      levels: u,\n      sessionData: d,\n      sessionKeys: h,\n      startTimeOffset: f,\n      variableList: p\n    } = l;\n    this.variableList = p, u.forEach((R) =&gt; {\n      const {\n        unknownCodecs: A\n      } = R;\n      if (A) {\n        const {\n          preferManagedMediaSource: F\n        } = this.hls.config;\n        let {\n          audioCodec: M,\n          videoCodec: H\n        } = R;\n        for (let K = A.length; K--; ) {\n          const j = A[K];\n          gi(j, \"audio\", F) ? (R.audioCodec = M = M ? `${M},${j}` : j, Fn.audio[M.substring(0, 4)] = 2, A.splice(K, 1)) : gi(j, \"video\", F) &amp;&amp; (R.videoCodec = H = H ? `${H},${j}` : j, Fn.video[H.substring(0, 4)] = 2, A.splice(K, 1));\n        }\n      }\n    });\n    const {\n      AUDIO: y = [],\n      SUBTITLES: E,\n      \"CLOSED-CAPTIONS\": b\n    } = zr.parseMasterPlaylistMedia(o, a, l);\n    y.length &amp;&amp; !y.some((A) =&gt; !A.url) &amp;&amp; u[0].audioCodec &amp;&amp; !u[0].attrs.AUDIO &amp;&amp; (this.hls.logger.log(\"[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one\"), y.unshift({\n      type: \"main\",\n      name: \"main\",\n      groupId: \"main\",\n      default: !1,\n      autoselect: !1,\n      forced: !1,\n      id: -1,\n      attrs: new gt({}),\n      bitrate: 0,\n      url: \"\"\n    })), i.trigger(I.MANIFEST_LOADED, {\n      levels: u,\n      audioTracks: y,\n      subtitles: E,\n      captions: b,\n      contentSteering: c,\n      url: a,\n      stats: t,\n      networkDetails: n,\n      sessionData: d,\n      sessionKeys: h,\n      startTimeOffset: f,\n      variableList: p\n    });\n  }\n  handleTrackOrLevelPlaylist(e, t, r, n, i) {\n    const o = this.hls, {\n      id: a,\n      level: l,\n      type: c\n    } = r, u = Dl(e, r), d = ue(l) ? l : ue(a) ? a : 0, h = hf(r), f = zr.parseLevelPlaylist(e.data, u, d, h, 0, this.variableList);\n    if (c === Ke.MANIFEST) {\n      const p = {\n        attrs: new gt({}),\n        bitrate: 0,\n        details: f,\n        name: \"\",\n        url: u\n      };\n      f.requestScheduled = t.loading.start + Qg(f, 0), o.trigger(I.MANIFEST_LOADED, {\n        levels: [p],\n        audioTracks: [],\n        url: u,\n        stats: t,\n        networkDetails: n,\n        sessionData: null,\n        sessionKeys: null,\n        contentSteering: null,\n        startTimeOffset: null,\n        variableList: null\n      });\n    }\n    t.parsing.end = performance.now(), r.levelDetails = f, this.handlePlaylistLoaded(f, e, t, r, n, i);\n  }\n  handleManifestParsingError(e, t, r, n, i) {\n    this.hls.trigger(I.ERROR, {\n      type: ve.NETWORK_ERROR,\n      details: J.MANIFEST_PARSING_ERROR,\n      fatal: t.type === Ke.MANIFEST,\n      url: e.url,\n      err: r,\n      error: r,\n      reason: r.message,\n      response: e,\n      context: t,\n      networkDetails: n,\n      stats: i\n    });\n  }\n  handleNetworkError(e, t, r = !1, n, i) {\n    let o = `A network ${r ? \"timeout\" : \"error\" + (n ? \" (status \" + n.code + \")\" : \"\")} occurred while loading ${e.type}`;\n    e.type === Ke.LEVEL ? o += `: ${e.level} id: ${e.id}` : (e.type === Ke.AUDIO_TRACK || e.type === Ke.SUBTITLE_TRACK) &amp;&amp; (o += ` id: ${e.id} group-id: \"${e.groupId}\"`);\n    const a = new Error(o);\n    this.hls.logger.warn(`[playlist-loader]: ${o}`);\n    let l = J.UNKNOWN, c = !1;\n    const u = this.getInternalLoader(e);\n    switch (e.type) {\n      case Ke.MANIFEST:\n        l = r ? J.MANIFEST_LOAD_TIMEOUT : J.MANIFEST_LOAD_ERROR, c = !0;\n        break;\n      case Ke.LEVEL:\n        l = r ? J.LEVEL_LOAD_TIMEOUT : J.LEVEL_LOAD_ERROR, c = !1;\n        break;\n      case Ke.AUDIO_TRACK:\n        l = r ? J.AUDIO_TRACK_LOAD_TIMEOUT : J.AUDIO_TRACK_LOAD_ERROR, c = !1;\n        break;\n      case Ke.SUBTITLE_TRACK:\n        l = r ? J.SUBTITLE_TRACK_LOAD_TIMEOUT : J.SUBTITLE_LOAD_ERROR, c = !1;\n        break;\n    }\n    u &amp;&amp; this.resetInternalLoader(e.type);\n    const d = {\n      type: ve.NETWORK_ERROR,\n      details: l,\n      fatal: c,\n      url: e.url,\n      loader: u,\n      context: e,\n      error: a,\n      networkDetails: t,\n      stats: i\n    };\n    if (n) {\n      const h = (t == null ? void 0 : t.url) || e.url;\n      d.response = tt({\n        url: h,\n        data: void 0\n      }, n);\n    }\n    this.hls.trigger(I.ERROR, d);\n  }\n  handlePlaylistLoaded(e, t, r, n, i, o) {\n    const a = this.hls, {\n      type: l,\n      level: c,\n      levelOrTrack: u,\n      id: d,\n      groupId: h,\n      deliveryDirectives: f\n    } = n, p = Dl(t, n), y = hf(n);\n    let E = typeof n.level == \"number\" &amp;&amp; y === pe.MAIN ? c : void 0;\n    const b = e.playlistParsingError;\n    if (b) {\n      if (this.hls.logger.warn(`${b} ${e.url}`), !a.config.ignorePlaylistParsingErrors) {\n        a.trigger(I.ERROR, {\n          type: ve.NETWORK_ERROR,\n          details: J.LEVEL_PARSING_ERROR,\n          fatal: !1,\n          url: p,\n          error: b,\n          reason: b.message,\n          response: t,\n          context: n,\n          level: E,\n          parent: y,\n          networkDetails: i,\n          stats: r\n        });\n        return;\n      }\n      e.playlistParsingError = null;\n    }\n    if (!e.fragments.length) {\n      const R = e.playlistParsingError = new Error(\"No Segments found in Playlist\");\n      a.trigger(I.ERROR, {\n        type: ve.NETWORK_ERROR,\n        details: J.LEVEL_EMPTY_ERROR,\n        fatal: !1,\n        url: p,\n        error: R,\n        reason: R.message,\n        response: t,\n        context: n,\n        level: E,\n        parent: y,\n        networkDetails: i,\n        stats: r\n      });\n      return;\n    }\n    switch (e.live &amp;&amp; o &amp;&amp; (o.getCacheAge &amp;&amp; (e.ageHeader = o.getCacheAge() || 0), (!o.getCacheAge || isNaN(e.ageHeader)) &amp;&amp; (e.ageHeader = 0)), l) {\n      case Ke.MANIFEST:\n      case Ke.LEVEL:\n        if (E) {\n          if (!u)\n            E = 0;\n          else if (u !== a.levels[E]) {\n            const R = a.levels.indexOf(u);\n            R &gt; -1 &amp;&amp; (E = R);\n          }\n        }\n        a.trigger(I.LEVEL_LOADED, {\n          details: e,\n          levelInfo: u || a.levels[0],\n          level: E || 0,\n          id: d || 0,\n          stats: r,\n          networkDetails: i,\n          deliveryDirectives: f,\n          withoutMultiVariant: l === Ke.MANIFEST\n        });\n        break;\n      case Ke.AUDIO_TRACK:\n        a.trigger(I.AUDIO_TRACK_LOADED, {\n          details: e,\n          track: u,\n          id: d || 0,\n          groupId: h || \"\",\n          stats: r,\n          networkDetails: i,\n          deliveryDirectives: f\n        });\n        break;\n      case Ke.SUBTITLE_TRACK:\n        a.trigger(I.SUBTITLE_TRACK_LOADED, {\n          details: e,\n          track: u,\n          id: d || 0,\n          groupId: h || \"\",\n          stats: r,\n          networkDetails: i,\n          deliveryDirectives: f\n        });\n        break;\n    }\n  }\n}\nclass Hr {\n  /**\n   * Get the video-dev/hls.js package version.\n   */\n  static get version() {\n    return vi;\n  }\n  /**\n   * Check if the required MediaSource Extensions are available.\n   */\n  static isMSESupported() {\n    return Jp();\n  }\n  /**\n   * Check if MediaSource Extensions are available and isTypeSupported checks pass for any baseline codecs.\n   */\n  static isSupported() {\n    return vA();\n  }\n  /**\n   * Get the MediaSource global used for MSE playback (ManagedMediaSource, MediaSource, or WebKitMediaSource).\n   */\n  static getMediaSource() {\n    return Ms();\n  }\n  static get Events() {\n    return I;\n  }\n  static get MetadataSchema() {\n    return br;\n  }\n  static get ErrorTypes() {\n    return ve;\n  }\n  static get ErrorDetails() {\n    return J;\n  }\n  /**\n   * Get the default configuration applied to new instances.\n   */\n  static get DefaultConfig() {\n    return Hr.defaultConfig ? Hr.defaultConfig : oA;\n  }\n  /**\n   * Replace the default configuration applied to new instances.\n   */\n  static set DefaultConfig(e) {\n    Hr.defaultConfig = e;\n  }\n  /**\n   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.\n   * @param userConfig - Configuration options applied over `Hls.DefaultConfig`\n   */\n  constructor(e = {}) {\n    this.config = void 0, this.userConfig = void 0, this.logger = void 0, this.coreComponents = void 0, this.networkControllers = void 0, this._emitter = new wu(), this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.abrController = void 0, this.bufferController = void 0, this.capLevelController = void 0, this.latencyController = void 0, this.levelController = void 0, this.streamController = void 0, this.audioStreamController = void 0, this.subtititleStreamController = void 0, this.audioTrackController = void 0, this.subtitleTrackController = void 0, this.interstitialsController = void 0, this.gapController = void 0, this.emeController = void 0, this.cmcdController = void 0, this._media = null, this._url = null, this._sessionId = void 0, this.triggeringException = void 0, this.started = !1;\n    const t = this.logger = LS(e.debug || !1, \"Hls instance\", e.assetPlayerId), r = this.config = lA(Hr.DefaultConfig, e, t);\n    this.userConfig = e, r.progressive &amp;&amp; cA(r, t);\n    const {\n      abrController: n,\n      bufferController: i,\n      capLevelController: o,\n      errorController: a,\n      fpsController: l\n    } = r, c = new a(this), u = this.abrController = new n(this), d = new Tb(this), h = r.interstitialsController, f = h ? this.interstitialsController = new h(this, Hr) : null, p = this.bufferController = new i(this, d), y = this.capLevelController = new o(this), E = new l(this), b = new TA(this), R = r.contentSteeringController, A = R ? new R(this) : null, F = this.levelController = new yA(this, A), M = new pA(this), H = new bA(this.config, this.logger), K = this.streamController = new SA(this, d, H), j = this.gapController = new fA(this, d);\n    y.setStreamController(K), E.setStreamController(K);\n    const C = [b, F, K];\n    f &amp;&amp; C.splice(1, 0, f), A &amp;&amp; C.splice(1, 0, A), this.networkControllers = C;\n    const k = [u, p, j, y, E, M, d];\n    this.audioTrackController = this.createController(r.audioTrackController, C);\n    const $ = r.audioStreamController;\n    $ &amp;&amp; C.push(this.audioStreamController = new $(this, d, H)), this.subtitleTrackController = this.createController(r.subtitleTrackController, C);\n    const W = r.subtitleStreamController;\n    W &amp;&amp; C.push(this.subtititleStreamController = new W(this, d, H)), this.createController(r.timelineController, k), H.emeController = this.emeController = this.createController(r.emeController, k), this.cmcdController = this.createController(r.cmcdController, k), this.latencyController = this.createController(mA, k), this.coreComponents = k, C.push(c);\n    const _ = c.onErrorOut;\n    typeof _ == \"function\" &amp;&amp; this.on(I.ERROR, _, c), this.on(I.MANIFEST_LOADED, b.onManifestLoaded, b);\n  }\n  createController(e, t) {\n    if (e) {\n      const r = new e(this);\n      return t &amp;&amp; t.push(r), r;\n    }\n    return null;\n  }\n  // Delegate the EventEmitter through the public API of Hls.js\n  on(e, t, r = this) {\n    this._emitter.on(e, t, r);\n  }\n  once(e, t, r = this) {\n    this._emitter.once(e, t, r);\n  }\n  removeAllListeners(e) {\n    this._emitter.removeAllListeners(e);\n  }\n  off(e, t, r = this, n) {\n    this._emitter.off(e, t, r, n);\n  }\n  listeners(e) {\n    return this._emitter.listeners(e);\n  }\n  emit(e, t, r) {\n    return this._emitter.emit(e, t, r);\n  }\n  trigger(e, t) {\n    if (this.config.debug)\n      return this.emit(e, e, t);\n    try {\n      return this.emit(e, e, t);\n    } catch (r) {\n      if (this.logger.error(\"An internal error happened while handling event \" + e + '. Error message: \"' + r.message + '\". Here is a stacktrace:', r), !this.triggeringException) {\n        this.triggeringException = !0;\n        const n = e === I.ERROR;\n        this.trigger(I.ERROR, {\n          type: ve.OTHER_ERROR,\n          details: J.INTERNAL_EXCEPTION,\n          fatal: n,\n          event: e,\n          error: r\n        }), this.triggeringException = !1;\n      }\n    }\n    return !1;\n  }\n  listenerCount(e) {\n    return this._emitter.listenerCount(e);\n  }\n  /**\n   * Dispose of the instance\n   */\n  destroy() {\n    this.logger.log(\"destroy\"), this.trigger(I.DESTROYING, void 0), this.detachMedia(), this.removeAllListeners(), this._autoLevelCapping = -1, this._url = null, this.networkControllers.forEach((t) =&gt; t.destroy()), this.networkControllers.length = 0, this.coreComponents.forEach((t) =&gt; t.destroy()), this.coreComponents.length = 0;\n    const e = this.config;\n    e.xhrSetup = e.fetchSetup = void 0, this.userConfig = null;\n  }\n  /**\n   * Attaches Hls.js to a media element\n   */\n  attachMedia(e) {\n    if (!e || \"media\" in e &amp;&amp; !e.media) {\n      const i = new Error(`attachMedia failed: invalid argument (${e})`);\n      this.trigger(I.ERROR, {\n        type: ve.OTHER_ERROR,\n        details: J.ATTACH_MEDIA_ERROR,\n        fatal: !0,\n        error: i\n      });\n      return;\n    }\n    this.logger.log(\"attachMedia\"), this._media &amp;&amp; (this.logger.warn(\"media must be detached before attaching\"), this.detachMedia());\n    const t = \"media\" in e, r = t ? e.media : e, n = t ? e : {\n      media: r\n    };\n    this._media = r, this.trigger(I.MEDIA_ATTACHING, n);\n  }\n  /**\n   * Detach Hls.js from the media\n   */\n  detachMedia() {\n    this.logger.log(\"detachMedia\"), this.trigger(I.MEDIA_DETACHING, {}), this._media = null;\n  }\n  /**\n   * Detach HTMLMediaElement, MediaSource, and SourceBuffers without reset, for attaching to another instance\n   */\n  transferMedia() {\n    this._media = null;\n    const e = this.bufferController.transferMedia();\n    return this.trigger(I.MEDIA_DETACHING, {\n      transferMedia: e\n    }), e;\n  }\n  /**\n   * Set the source URL. Can be relative or absolute.\n   */\n  loadSource(e) {\n    this.stopLoad();\n    const t = this.media, r = this._url, n = this._url = hu.buildAbsoluteURL(self.location.href, e, {\n      alwaysNormalize: !0\n    });\n    this._autoLevelCapping = -1, this._maxHdcpLevel = null, this.logger.log(`loadSource:${n}`), t &amp;&amp; r &amp;&amp; (r !== n || this.bufferController.hasSourceTypes()) &amp;&amp; (this.detachMedia(), this.attachMedia(t)), this.trigger(I.MANIFEST_LOADING, {\n      url: e\n    });\n  }\n  /**\n   * Gets the currently loaded URL\n   */\n  get url() {\n    return this._url;\n  }\n  /**\n   * Whether or not enough has been buffered to seek to start position or use `media.currentTime` to determine next load position\n   */\n  get hasEnoughToStart() {\n    return this.streamController.hasEnoughToStart;\n  }\n  /**\n   * Get the startPosition set on startLoad(position) or on autostart with config.startPosition\n   */\n  get startPosition() {\n    return this.streamController.startPositionValue;\n  }\n  /**\n   * Start loading data from the stream source.\n   * Depending on default config, client starts loading automatically when a source is set.\n   *\n   * @param startPosition - Set the start position to stream from.\n   * Defaults to -1 (None: starts from earliest point)\n   */\n  startLoad(e = -1, t) {\n    this.logger.log(`startLoad(${e + (t ? \", &lt;skip seek to start&gt;\" : \"\")})`), this.started = !0, this.resumeBuffering();\n    for (let r = 0; r &lt; this.networkControllers.length &amp;&amp; (this.networkControllers[r].startLoad(e, t), !(!this.started || !this.networkControllers)); r++)\n      ;\n  }\n  /**\n   * Stop loading of any stream data.\n   */\n  stopLoad() {\n    this.logger.log(\"stopLoad\"), this.started = !1;\n    for (let e = 0; e &lt; this.networkControllers.length &amp;&amp; (this.networkControllers[e].stopLoad(), !(this.started || !this.networkControllers)); e++)\n      ;\n  }\n  /**\n   * Returns whether loading, toggled with `startLoad()` and `stopLoad()`, is active or not`.\n   */\n  get loadingEnabled() {\n    return this.started;\n  }\n  /**\n   * Returns state of fragment loading toggled by calling `pauseBuffering()` and `resumeBuffering()`.\n   */\n  get bufferingEnabled() {\n    return this.streamController.bufferingEnabled;\n  }\n  /**\n   * Resumes stream controller segment loading after `pauseBuffering` has been called.\n   */\n  resumeBuffering() {\n    this.bufferingEnabled || (this.logger.log(\"resume buffering\"), this.networkControllers.forEach((e) =&gt; {\n      e.resumeBuffering &amp;&amp; e.resumeBuffering();\n    }));\n  }\n  /**\n   * Prevents stream controller from loading new segments until `resumeBuffering` is called.\n   * This allows for media buffering to be paused without interupting playlist loading.\n   */\n  pauseBuffering() {\n    this.bufferingEnabled &amp;&amp; (this.logger.log(\"pause buffering\"), this.networkControllers.forEach((e) =&gt; {\n      e.pauseBuffering &amp;&amp; e.pauseBuffering();\n    }));\n  }\n  get inFlightFragments() {\n    const e = {\n      [pe.MAIN]: this.streamController.inFlightFrag\n    };\n    return this.audioStreamController &amp;&amp; (e[pe.AUDIO] = this.audioStreamController.inFlightFrag), this.subtititleStreamController &amp;&amp; (e[pe.SUBTITLE] = this.subtititleStreamController.inFlightFrag), e;\n  }\n  /**\n   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)\n   */\n  swapAudioCodec() {\n    this.logger.log(\"swapAudioCodec\"), this.streamController.swapAudioCodec();\n  }\n  /**\n   * When the media-element fails, this allows to detach and then re-attach it\n   * as one call (convenience method).\n   *\n   * Automatic recovery of media-errors by this process is configurable.\n   */\n  recoverMediaError() {\n    this.logger.log(\"recoverMediaError\");\n    const e = this._media, t = e == null ? void 0 : e.currentTime;\n    this.detachMedia(), e &amp;&amp; (this.attachMedia(e), t &amp;&amp; this.startLoad(t));\n  }\n  removeLevel(e) {\n    this.levelController.removeLevel(e);\n  }\n  /**\n   * @returns a UUID for this player instance\n   */\n  get sessionId() {\n    let e = this._sessionId;\n    return e || (e = this._sessionId = fw()), e;\n  }\n  /**\n   * @returns an array of levels (variants) sorted by HDCP-LEVEL, RESOLUTION (height), FRAME-RATE, CODECS, VIDEO-RANGE, and BANDWIDTH\n   */\n  get levels() {\n    const e = this.levelController.levels;\n    return e || [];\n  }\n  /**\n   * @returns LevelDetails of last loaded level (variant) or `null` prior to loading a media playlist.\n   */\n  get latestLevelDetails() {\n    return this.streamController.getLevelDetails() || null;\n  }\n  /**\n   * @returns Level object of selected level (variant) or `null` prior to selecting a level or once the level is removed.\n   */\n  get loadLevelObj() {\n    return this.levelController.loadLevelObj;\n  }\n  /**\n   * Index of quality level (variant) currently played\n   */\n  get currentLevel() {\n    return this.streamController.currentLevel;\n  }\n  /**\n   * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.\n   */\n  set currentLevel(e) {\n    this.logger.log(`set currentLevel:${e}`), this.levelController.manualLevel = e, this.streamController.immediateLevelSwitch();\n  }\n  /**\n   * Index of next quality level loaded as scheduled by stream controller.\n   */\n  get nextLevel() {\n    return this.streamController.nextLevel;\n  }\n  /**\n   * Set quality level index for next loaded data.\n   * This will switch the video quality asap, without interrupting playback.\n   * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).\n   * @param newLevel - Pass -1 for automatic level selection\n   */\n  set nextLevel(e) {\n    this.logger.log(`set nextLevel:${e}`), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch();\n  }\n  /**\n   * Return the quality level of the currently or last (of none is loaded currently) segment\n   */\n  get loadLevel() {\n    return this.levelController.level;\n  }\n  /**\n   * Set quality level index for next loaded data in a conservative way.\n   * This will switch the quality without flushing, but interrupt current loading.\n   * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.\n   * @param newLevel - Pass -1 for automatic level selection\n   */\n  set loadLevel(e) {\n    this.logger.log(`set loadLevel:${e}`), this.levelController.manualLevel = e;\n  }\n  /**\n   * get next quality level loaded\n   */\n  get nextLoadLevel() {\n    return this.levelController.nextLoadLevel;\n  }\n  /**\n   * Set quality level of next loaded segment in a fully \"non-destructive\" way.\n   * Same as `loadLevel` but will wait for next switch (until current loading is done).\n   */\n  set nextLoadLevel(e) {\n    this.levelController.nextLoadLevel = e;\n  }\n  /**\n   * Return \"first level\": like a default level, if not set,\n   * falls back to index of first level referenced in manifest\n   */\n  get firstLevel() {\n    return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n  }\n  /**\n   * Sets \"first-level\", see getter.\n   */\n  set firstLevel(e) {\n    this.logger.log(`set firstLevel:${e}`), this.levelController.firstLevel = e;\n  }\n  /**\n   * Return the desired start level for the first fragment that will be loaded.\n   * The default value of -1 indicates automatic start level selection.\n   * Setting hls.nextAutoLevel without setting a startLevel will result in\n   * the nextAutoLevel value being used for one fragment load.\n   */\n  get startLevel() {\n    const e = this.levelController.startLevel;\n    return e === -1 &amp;&amp; this.abrController.forcedAutoLevel &gt; -1 ? this.abrController.forcedAutoLevel : e;\n  }\n  /**\n   * set  start level (level of first fragment that will be played back)\n   * if not overrided by user, first level appearing in manifest will be used as start level\n   * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n   * (determined from download of first segment)\n   */\n  set startLevel(e) {\n    this.logger.log(`set startLevel:${e}`), e !== -1 &amp;&amp; (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e;\n  }\n  /**\n   * Whether level capping is enabled.\n   * Default value is set via `config.capLevelToPlayerSize`.\n   */\n  get capLevelToPlayerSize() {\n    return this.config.capLevelToPlayerSize;\n  }\n  /**\n   * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.\n   */\n  set capLevelToPlayerSize(e) {\n    const t = !!e;\n    t !== this.config.capLevelToPlayerSize &amp;&amp; (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t);\n  }\n  /**\n   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n   */\n  get autoLevelCapping() {\n    return this._autoLevelCapping;\n  }\n  /**\n   * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.\n   */\n  get bandwidthEstimate() {\n    const {\n      bwEstimator: e\n    } = this.abrController;\n    return e ? e.getEstimate() : NaN;\n  }\n  set bandwidthEstimate(e) {\n    this.abrController.resetEstimator(e);\n  }\n  get abrEwmaDefaultEstimate() {\n    const {\n      bwEstimator: e\n    } = this.abrController;\n    return e ? e.defaultEstimate : NaN;\n  }\n  /**\n   * get time to first byte estimate\n   * @type {number}\n   */\n  get ttfbEstimate() {\n    const {\n      bwEstimator: e\n    } = this.abrController;\n    return e ? e.getEstimateTTFB() : NaN;\n  }\n  /**\n   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n   */\n  set autoLevelCapping(e) {\n    this._autoLevelCapping !== e &amp;&amp; (this.logger.log(`set autoLevelCapping:${e}`), this._autoLevelCapping = e, this.levelController.checkMaxAutoUpdated());\n  }\n  get maxHdcpLevel() {\n    return this._maxHdcpLevel;\n  }\n  set maxHdcpLevel(e) {\n    ab(e) &amp;&amp; this._maxHdcpLevel !== e &amp;&amp; (this._maxHdcpLevel = e, this.levelController.checkMaxAutoUpdated());\n  }\n  /**\n   * True when automatic level selection enabled\n   */\n  get autoLevelEnabled() {\n    return this.levelController.manualLevel === -1;\n  }\n  /**\n   * Level set manually (if any)\n   */\n  get manualLevel() {\n    return this.levelController.manualLevel;\n  }\n  /**\n   * min level selectable in auto mode according to config.minAutoBitrate\n   */\n  get minAutoLevel() {\n    const {\n      levels: e,\n      config: {\n        minAutoBitrate: t\n      }\n    } = this;\n    if (!e) return 0;\n    const r = e.length;\n    for (let n = 0; n &lt; r; n++)\n      if (e[n].maxBitrate &gt;= t)\n        return n;\n    return 0;\n  }\n  /**\n   * max level selectable in auto mode according to autoLevelCapping\n   */\n  get maxAutoLevel() {\n    const {\n      levels: e,\n      autoLevelCapping: t,\n      maxHdcpLevel: r\n    } = this;\n    let n;\n    if (t === -1 &amp;&amp; e != null &amp;&amp; e.length ? n = e.length - 1 : n = t, r)\n      for (let i = n; i--; ) {\n        const o = e[i].attrs[\"HDCP-LEVEL\"];\n        if (o &amp;&amp; o &lt;= r)\n          return i;\n      }\n    return n;\n  }\n  get firstAutoLevel() {\n    return this.abrController.firstAutoLevel;\n  }\n  /**\n   * next automatically selected quality level\n   */\n  get nextAutoLevel() {\n    return this.abrController.nextAutoLevel;\n  }\n  /**\n   * this setter is used to force next auto level.\n   * this is useful to force a switch down in auto mode:\n   * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)\n   * forced value is valid for one fragment. upon successful frag loading at forced level,\n   * this value will be resetted to -1 by ABR controller.\n   */\n  set nextAutoLevel(e) {\n    this.abrController.nextAutoLevel = e;\n  }\n  /**\n   * get the datetime value relative to media.currentTime for the active level Program Date Time if present\n   */\n  get playingDate() {\n    return this.streamController.currentProgramDateTime;\n  }\n  get mainForwardBufferInfo() {\n    return this.streamController.getMainFwdBufferInfo();\n  }\n  get maxBufferLength() {\n    return this.streamController.maxBufferLength;\n  }\n  /**\n   * Find and select the best matching audio track, making a level switch when a Group change is necessary.\n   * Updates `hls.config.audioPreference`. Returns the selected track, or null when no matching track is found.\n   */\n  setAudioOption(e) {\n    var t;\n    return ((t = this.audioTrackController) == null ? void 0 : t.setAudioOption(e)) || null;\n  }\n  /**\n   * Find and select the best matching subtitle track, making a level switch when a Group change is necessary.\n   * Updates `hls.config.subtitlePreference`. Returns the selected track, or null when no matching track is found.\n   */\n  setSubtitleOption(e) {\n    var t;\n    return ((t = this.subtitleTrackController) == null ? void 0 : t.setSubtitleOption(e)) || null;\n  }\n  /**\n   * Get the complete list of audio tracks across all media groups\n   */\n  get allAudioTracks() {\n    const e = this.audioTrackController;\n    return e ? e.allAudioTracks : [];\n  }\n  /**\n   * Get the list of selectable audio tracks\n   */\n  get audioTracks() {\n    const e = this.audioTrackController;\n    return e ? e.audioTracks : [];\n  }\n  /**\n   * index of the selected audio track (index in audio track lists)\n   */\n  get audioTrack() {\n    const e = this.audioTrackController;\n    return e ? e.audioTrack : -1;\n  }\n  /**\n   * selects an audio track, based on its index in audio track lists\n   */\n  set audioTrack(e) {\n    const t = this.audioTrackController;\n    t &amp;&amp; (t.audioTrack = e);\n  }\n  /**\n   * get the complete list of subtitle tracks across all media groups\n   */\n  get allSubtitleTracks() {\n    const e = this.subtitleTrackController;\n    return e ? e.allSubtitleTracks : [];\n  }\n  /**\n   * get alternate subtitle tracks list from playlist\n   */\n  get subtitleTracks() {\n    const e = this.subtitleTrackController;\n    return e ? e.subtitleTracks : [];\n  }\n  /**\n   * index of the selected subtitle track (index in subtitle track lists)\n   */\n  get subtitleTrack() {\n    const e = this.subtitleTrackController;\n    return e ? e.subtitleTrack : -1;\n  }\n  get media() {\n    return this._media;\n  }\n  /**\n   * select an subtitle track, based on its index in subtitle track lists\n   */\n  set subtitleTrack(e) {\n    const t = this.subtitleTrackController;\n    t &amp;&amp; (t.subtitleTrack = e);\n  }\n  /**\n   * Whether subtitle display is enabled or not\n   */\n  get subtitleDisplay() {\n    const e = this.subtitleTrackController;\n    return e ? e.subtitleDisplay : !1;\n  }\n  /**\n   * Enable/disable subtitle display rendering\n   */\n  set subtitleDisplay(e) {\n    const t = this.subtitleTrackController;\n    t &amp;&amp; (t.subtitleDisplay = e);\n  }\n  /**\n   * get mode for Low-Latency HLS loading\n   */\n  get lowLatencyMode() {\n    return this.config.lowLatencyMode;\n  }\n  /**\n   * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.\n   */\n  set lowLatencyMode(e) {\n    this.config.lowLatencyMode = e;\n  }\n  /**\n   * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)\n   * @returns null prior to loading live Playlist\n   */\n  get liveSyncPosition() {\n    return this.latencyController.liveSyncPosition;\n  }\n  /**\n   * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)\n   * @returns 0 before first playlist is loaded\n   */\n  get latency() {\n    return this.latencyController.latency;\n  }\n  /**\n   * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```\n   * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```\n   * @returns 0 before first playlist is loaded\n   */\n  get maxLatency() {\n    return this.latencyController.maxLatency;\n  }\n  /**\n   * target distance from the edge as calculated by the latency controller\n   */\n  get targetLatency() {\n    return this.latencyController.targetLatency;\n  }\n  set targetLatency(e) {\n    this.latencyController.targetLatency = e;\n  }\n  /**\n   * the rate at which the edge of the current live playlist is advancing or 1 if there is none\n   */\n  get drift() {\n    return this.latencyController.drift;\n  }\n  /**\n   * set to true when startLoad is called before MANIFEST_PARSED event\n   */\n  get forceStartLoad() {\n    return this.streamController.forceStartLoad;\n  }\n  /**\n   * ContentSteering pathways getter\n   */\n  get pathways() {\n    return this.levelController.pathways;\n  }\n  /**\n   * ContentSteering pathwayPriority getter/setter\n   */\n  get pathwayPriority() {\n    return this.levelController.pathwayPriority;\n  }\n  set pathwayPriority(e) {\n    this.levelController.pathwayPriority = e;\n  }\n  /**\n   * returns true when all SourceBuffers are buffered to the end\n   */\n  get bufferedToEnd() {\n    var e;\n    return !!((e = this.bufferController) != null &amp;&amp; e.bufferedToEnd);\n  }\n  /**\n   * returns Interstitials Program Manager\n   */\n  get interstitialsManager() {\n    var e;\n    return ((e = this.interstitialsController) == null ? void 0 : e.interstitialsManager) || null;\n  }\n  /**\n   * returns mediaCapabilities.decodingInfo for a variant/rendition\n   */\n  getMediaDecodingInfo(e, t = this.allAudioTracks) {\n    const r = $g(t);\n    return Ng(e, r, navigator.mediaCapabilities);\n  }\n}\nHr.defaultConfig = void 0;\nconst on = \"https://sdk-api.neynar.com\", wA = \"https://api.allorigins.win/get\", bi = \"https://i.imgur.com/gxH8azy.png\";\nvar AA = {\n  SDK_VERSION: '\"1.2.15\"'\n};\nconst IA = AA.SDK_VERSION, an = async (s, e = {}) =&gt; (e.headers = {\n  ...e.headers,\n  \"x-sdk\": \"react\",\n  \"x-sdk-version\": IA\n}, fetch(s, e));\nasync function _A({\n  type: s,\n  identifier: e,\n  viewerFid: t,\n  client_id: r\n}) {\n  try {\n    let n = `${on}/v2/farcaster/cast?type=${s}&amp;identifier=${e}${t ? `&amp;viewer_fid=${t}` : \"\"}&amp;client_id=${r}`;\n    const o = await (await an(n)).json();\n    return (o == null ? void 0 : o.cast) || null;\n  } catch (n) {\n    return console.error(\"Error fetching cast by identifier\", n), null;\n  }\n}\nconst RA = ({\n  type: s,\n  identifier: e,\n  viewerFid: t,\n  allowReactions: r = !1,\n  renderEmbeds: n = !0,\n  renderFrames: i = !1,\n  onLikeBtnPress: o,\n  onRecastBtnPress: a,\n  onCommentBtnPress: l,\n  onFrameBtnPress: c,\n  containerStyles: u,\n  textStyles: d\n}) =&gt; {\n  var F;\n  const {\n    client_id: h\n  } = ts(), [f, p] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null), [y, E] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(!0), [b, R] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null), A = (f == null ? void 0 : f.author.fid) === t;\n  return react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(() =&gt; {\n    s &amp;&amp; e &amp;&amp; (E(!0), R(null), _A({\n      type: s,\n      identifier: e,\n      viewerFid: t,\n      client_id: h\n    }).then((M) =&gt; {\n      p(M);\n    }).catch((M) =&gt; {\n      R(M);\n    }).finally(() =&gt; {\n      E(!1);\n    }));\n  }, [s, e, t, h]), y ? /* @__PURE__ */ q.jsx(\"div\", {\n    style: {\n      padding: \"20px\"\n    },\n    children: \"Loading...\"\n  }) : !f || b ? /* @__PURE__ */ q.jsx(\"div\", {\n    children: \"Error: could not fetch cast data\"\n  }) : i &amp;&amp; !c ? /* @__PURE__ */ q.jsx(\"div\", {\n    children: \"Error: onFrameBtnPress must be provided when renderEmbeds is true.\"\n  }) : /* @__PURE__ */ q.jsx(oa, {\n    username: f.author.username,\n    displayName: f.author.display_name,\n    avatarImgUrl: f.author.pfp_url,\n    text: f.text,\n    hash: f.hash,\n    reactions: f.reactions,\n    replies: f.replies.count,\n    embeds: f.embeds ?? [],\n    frames: f.frames ?? [],\n    renderEmbeds: n,\n    renderFrames: i,\n    channel: f.channel ? {\n      id: f.channel.id,\n      name: f.channel.name,\n      url: f.parent_url\n    } : void 0,\n    viewerFid: t,\n    allowReactions: r,\n    hasPowerBadge: f.author.power_badge,\n    appAvatarImgUrl: ((F = f.app) == null ? void 0 : F.pfp_url) || null,\n    isOwnProfile: A,\n    containerStyles: u,\n    textStyles: d,\n    onLikeBtnPress: o,\n    onRecastBtnPress: a,\n    onCommentBtnPress: l,\n    onFrameBtnPress: c,\n    timestamp: f.timestamp\n  });\n}, LA = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"a\")({\n  classes: [\"s1uo4lx4\"]\n}), Pl = /* @__PURE__ */ new Map(), io = /* @__PURE__ */ new Map(), ff = /* @__PURE__ */ new Map(), gf = (s) =&gt; new Promise((e) =&gt; setTimeout(e, s)), Qp = async (s, e = 0) =&gt; {\n  const t = new URL(s).hostname;\n  if (ff.get(t))\n    return {\n      ogImage: \"\",\n      ogTitle: \"\",\n      ogDescription: \"\"\n    };\n  if (Pl.has(s))\n    return Pl.get(s);\n  if (io.has(s))\n    return io.get(s);\n  const r = (async () =&gt; {\n    try {\n      await gf(100);\n      const n = await fetch(`${wA}?url=${encodeURIComponent(s)}`, {\n        method: \"GET\"\n      });\n      if (!n.ok) {\n        if (n.status === 429 &amp;&amp; e &lt; 5) {\n          const E = Math.pow(2, e) * 1e3;\n          return await gf(E), Qp(s, e + 1);\n        }\n        throw ff.set(t, !0), new Error(`Failed to fetch Open Graph data: ${n.statusText}`);\n      }\n      const i = await n.json(), a = new DOMParser().parseFromString(i.contents, \"text/html\"), l = a.querySelector('meta[property=\"og:image\"]'), c = a.querySelector('meta[property=\"og:title\"]'), u = a.querySelector('meta[property=\"og:description\"]'), d = a.querySelector(\"title\"), h = l &amp;&amp; l.getAttribute(\"content\") || \"\", f = c ? c.getAttribute(\"content\") || \"\" : d ? d.innerText : \"\", p = u &amp;&amp; u.getAttribute(\"content\") || \"\", y = {\n        ogImage: h,\n        ogTitle: f,\n        ogDescription: p\n      };\n      return Pl.set(s, y), y;\n    } catch (n) {\n      return console.error(\"Error fetching Open Graph data\", n), {\n        ogImage: \"\",\n        ogTitle: \"\",\n        ogDescription: \"\"\n      };\n    } finally {\n      io.delete(s);\n    }\n  })();\n  return io.set(s, r), r;\n}, Ac = [];\nlet Ml = 0;\nconst CA = 5, kA = (s) =&gt; {\n  Ac.push(s), em();\n}, em = async () =&gt; {\n  if (Ml &gt;= CA || Ac.length === 0)\n    return;\n  Ml++;\n  const s = Ac.shift();\n  s &amp;&amp; await s(), Ml--, em();\n}, DA = ({\n  src: s,\n  alt: e,\n  style: t\n}) =&gt; /* @__PURE__ */ q.jsx(\"img\", {\n  src: s,\n  alt: e,\n  style: {\n    display: \"block\",\n    height: \"auto\",\n    maxHeight: \"150px\",\n    width: \"auto\",\n    maxWidth: \"100%\",\n    objectFit: \"cover\",\n    border: \"1px solid grey\",\n    borderRadius: \"10px\",\n    margin: \"4px 0\",\n    ...t\n  }\n}), PA = ({\n  url: s\n}) =&gt; {\n  const e = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(() =&gt; {\n    if (e.current)\n      if (Hr.isSupported() &amp;&amp; s.endsWith(\".m3u8\")) {\n        const t = new Hr();\n        t.loadSource(s), t.attachMedia(e.current), t.on(Hr.Events.MANIFEST_PARSED, () =&gt; {\n          e.current.play();\n        });\n      } else\n        e.current.src = s, e.current.addEventListener(\"loadedmetadata\", () =&gt; {\n          e.current.play();\n        });\n  }, [s]), /* @__PURE__ */ q.jsx(\"video\", {\n    ref: e,\n    controls: !0,\n    muted: !0,\n    style: {\n      width: \"auto\",\n      maxWidth: \"100%\",\n      maxHeight: \"400px\",\n      borderRadius: \"10px\",\n      margin: \"10px 0\",\n      objectFit: \"contain\"\n    }\n  });\n}, MA = (s) =&gt; /\\.(jpeg|jpg|gif|png|webp|bmp|svg)$/.test(s) || s.startsWith(\"https://imagedelivery.net\"), OA = (s, e, t) =&gt; {\n  const [r, n] = react__WEBPACK_IMPORTED_MODULE_0___default().useState([]), i = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(async (o) =&gt; (await Promise.all(o.map(async (l) =&gt; {\n    if (l.url) {\n      const c = l.url;\n      return MA(c) ? /* @__PURE__ */ q.jsx(DA, {\n        src: c,\n        alt: \"Embedded image\"\n      }, c) : c.endsWith(\".m3u8\") || c.endsWith(\".mp4\") ? /* @__PURE__ */ q.jsx(PA, {\n        url: c\n      }, c) : new Promise((u) =&gt; {\n        kA(async () =&gt; {\n          const {\n            ogImage: d,\n            ogTitle: h\n          } = await Qp(c), f = new URL(c).hostname.replace(\"www.\", \"\");\n          u(/* @__PURE__ */ q.jsxs(LA, {\n            href: c,\n            target: \"_blank\",\n            rel: \"noreferrer\",\n            children: [d &amp;&amp; /* @__PURE__ */ q.jsx(\"img\", {\n              src: d,\n              alt: h,\n              style: {\n                width: \"50px\",\n                height: \"50px\",\n                objectFit: \"cover\",\n                borderRadius: \"5px\"\n              }\n            }), /* @__PURE__ */ q.jsxs(\"div\", {\n              style: {\n                display: \"flex\",\n                flexDirection: \"column\"\n              },\n              children: [/* @__PURE__ */ q.jsx(\"p\", {\n                style: {\n                  margin: 0\n                },\n                children: h || c\n              }), /* @__PURE__ */ q.jsx(\"p\", {\n                style: {\n                  margin: 0,\n                  color: \"grey\",\n                  fontSize: \"12px\"\n                },\n                children: f\n              })]\n            })]\n          }, c));\n        });\n      });\n    } else if (l.cast_id)\n      return /* @__PURE__ */ q.jsx(\"div\", {\n        style: {\n          maxWidth: \"85%\"\n        },\n        children: /* @__PURE__ */ q.jsx(RA, {\n          type: \"hash\",\n          identifier: l.cast_id.hash,\n          viewerFid: t,\n          allowReactions: e,\n          renderEmbeds: !1\n        }, l.cast_id.fid)\n      }, `cast-${l.cast_id.hash}`);\n    return null;\n  }))).filter((l) =&gt; l !== null), [e, t]);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(() =&gt; {\n    i(s).then(n);\n  }, [s, i]), r;\n}, tm = ({\n  onClick: s\n}) =&gt; /* @__PURE__ */ q.jsx(\"svg\", {\n  width: \"18\",\n  height: \"17\",\n  viewBox: \"0 0 18 17\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\",\n  onClick: (e) =&gt; s ? s(e) : void 0,\n  style: {\n    cursor: \"pointer\"\n  },\n  children: /* @__PURE__ */ q.jsx(\"path\", {\n    d: \"M6.22857 12.6828H7.01285C7.01285 12.2496 6.66172 11.8985 6.22857 11.8985V12.6828ZM6.22857 15.8199H5.4443C5.4443 16.1137 5.60848 16.3828 5.8697 16.5172C6.13092 16.6517 6.44537 16.6288 6.68443 16.4581L6.22857 15.8199ZM10.6205 12.6828V11.8985C10.4571 11.8985 10.2977 11.9496 10.1647 12.0446L10.6205 12.6828ZM1.78428 3.27146C1.78428 2.54955 2.3695 1.96433 3.09141 1.96433V0.395777C1.50321 0.395777 0.215723 1.68327 0.215723 3.27146H1.78428ZM1.78428 10.5914V3.27146H0.215723V10.5914H1.78428ZM3.0914 11.8985C2.3695 11.8985 1.78428 11.3133 1.78428 10.5914H0.215723C0.215723 12.1796 1.50321 13.4671 3.0914 13.4671V11.8985ZM6.22857 11.8985H3.0914V13.4671H6.22857V11.8985ZM7.01285 15.8199V12.6828H5.4443V15.8199H7.01285ZM10.1647 12.0446L5.77272 15.1817L6.68443 16.4581L11.0764 13.321L10.1647 12.0446ZM14.5941 11.8985H10.6205V13.4671H14.5941V11.8985ZM15.9013 10.5914C15.9013 11.3133 15.316 11.8985 14.5941 11.8985V13.4671C16.1823 13.4671 17.4698 12.1796 17.4698 10.5914H15.9013ZM15.9013 3.27146V10.5914H17.4698V3.27146H15.9013ZM14.5941 1.96433C15.316 1.96433 15.9013 2.54955 15.9013 3.27146H17.4698C17.4698 1.68326 16.1823 0.395777 14.5941 0.395777V1.96433ZM3.09141 1.96433H14.5941V0.395777H3.09141V1.96433Z\",\n    fill: \"#A0A3AD\"\n  })\n}), BA = ({\n  fill: s,\n  onClick: e\n}) =&gt; /* @__PURE__ */ q.jsxs(\"svg\", {\n  width: \"16\",\n  height: \"15\",\n  viewBox: \"0 0 16 15\",\n  fill: s || \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\",\n  onClick: (t) =&gt; e ? e(t) : void 0,\n  style: {\n    cursor: \"pointer\"\n  },\n  children: [/* @__PURE__ */ q.jsx(\"path\", {\n    d: \"M14.9245 14.2506C14.7258 14.2506 14.5352 14.1716 14.3946 14.0311C14.2541 13.8905 14.1751 13.6999 14.1751 13.5011V10.5034H11.1774C10.9787 10.5034 10.7881 10.4245 10.6475 10.2839C10.507 10.1434 10.428 9.95279 10.428 9.75403C10.428 9.55527 10.507 9.36465 10.6475 9.22411C10.7881 9.08357 10.9787 9.00461 11.1774 9.00461H14.9245C15.1233 9.00461 15.3139 9.08357 15.4545 9.22411C15.595 9.36465 15.674 9.55527 15.674 9.75403V13.5011C15.674 13.6999 15.595 13.8905 15.4545 14.0311C15.3139 14.1716 15.1233 14.2506 14.9245 14.2506ZM5.18207 6.00693H1.43497C1.23621 6.00693 1.04559 5.92797 0.905047 5.78743C0.764503 5.64688 0.685547 5.45627 0.685547 5.25751V1.51041C0.685547 1.31165 0.764503 1.12103 0.905047 0.980486C1.04559 0.839943 1.23621 0.760986 1.43497 0.760986C1.63373 0.760986 1.82434 0.839943 1.96489 0.980486C2.10543 1.12103 2.18439 1.31165 2.18439 1.51041V4.50809H5.18207C5.38083 4.50809 5.57145 4.58704 5.71199 4.72759C5.85253 4.86813 5.93149 5.05875 5.93149 5.25751C5.93149 5.45627 5.85253 5.64688 5.71199 5.78743C5.57145 5.92797 5.38083 6.00693 5.18207 6.00693Z\",\n    fill: s || \"#A0A3AD\"\n  }), /* @__PURE__ */ q.jsx(\"path\", {\n    d: \"M8.17934 15C6.33556 15.0003 4.55637 14.3209 3.18205 13.0918C1.80774 11.8627 0.934766 10.17 0.730106 8.33765C0.719281 8.23923 0.727945 8.13965 0.755606 8.04458C0.783266 7.94951 0.82938 7.86083 0.891315 7.78358C1.0164 7.62758 1.19833 7.52765 1.39709 7.50579C1.59585 7.48393 1.79515 7.54191 1.95116 7.667C2.10716 7.79208 2.20708 7.97401 2.22895 8.17277C2.37708 9.52376 2.97983 10.7843 3.93838 11.7478C4.89692 12.7113 6.15438 13.3205 7.50459 13.4755C8.85479 13.6306 10.2176 13.3223 11.3696 12.6012C12.5216 11.8801 13.3944 10.789 13.845 9.50674C13.8731 9.40817 13.9211 9.31642 13.986 9.23714C14.051 9.15787 14.1316 9.09277 14.2227 9.04586C14.3138 8.99895 14.4136 8.97123 14.5159 8.96442C14.6181 8.95761 14.7207 8.97185 14.8173 9.00625C14.9138 9.04066 15.0023 9.09451 15.0772 9.16446C15.1521 9.23442 15.2118 9.31899 15.2528 9.41296C15.2937 9.50693 15.3149 9.6083 15.3151 9.71079C15.3153 9.81329 15.2944 9.91473 15.2539 10.0089C14.7359 11.4705 13.7774 12.7355 12.5103 13.6294C11.2432 14.5233 9.73002 15.0022 8.17934 15ZM14.8792 7.50579C14.6939 7.50691 14.5148 7.43937 14.3764 7.3162C14.238 7.19302 14.1501 7.02295 14.1297 6.8388C13.975 5.49429 13.3699 4.24169 12.4128 3.28476C11.4558 2.32782 10.2031 1.72285 8.85858 1.56824C7.51405 1.41364 6.15676 1.7185 5.0075 2.43324C3.85823 3.14798 2.9846 4.23054 2.52872 5.50484C2.50062 5.6034 2.4526 5.69516 2.38763 5.77443C2.32266 5.85371 2.24212 5.91881 2.15099 5.96572C2.05987 6.01263 1.96008 6.04035 1.85781 6.04716C1.75555 6.05397 1.65297 6.03973 1.55642 6.00532C1.45988 5.97092 1.37141 5.91707 1.29651 5.84712C1.2216 5.77716 1.16183 5.69258 1.12091 5.59861C1.07999 5.50464 1.05878 5.40328 1.05859 5.30078C1.0584 5.19829 1.07923 5.09685 1.1198 5.00273C1.68406 3.40202 2.77497 2.04025 4.21397 1.14029C5.65297 0.240337 7.35485 -0.144505 9.04106 0.0487522C10.7273 0.242009 12.2979 1.00192 13.496 2.20411C14.6941 3.4063 15.4486 4.97958 15.6361 6.66644C15.6571 6.86306 15.5997 7.06004 15.4761 7.21445C15.3526 7.36887 15.173 7.4682 14.9766 7.4908L14.8792 7.50579Z\",\n    fill: s || \"#A0A3AD\"\n  })]\n}), rm = ({\n  fill: s,\n  onClick: e\n}) =&gt; /* @__PURE__ */ q.jsxs(\"svg\", {\n  width: \"17\",\n  height: \"15\",\n  viewBox: \"0 0 17 15\",\n  fill: s ? \"red\" : \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\",\n  onClick: (t) =&gt; e ? e(t) : void 0,\n  style: {\n    cursor: \"pointer\"\n  },\n  children: [/* @__PURE__ */ q.jsx(\"path\", {\n    d: \"M13.8719 2.25042L14.2947 1.58984L13.8719 2.25042C15.2467 3.13022 15.7676 5.22206 14.8856 7.61317C14.0436 9.89583 11.9555 12.2374 8.51573 13.3648C5.07606 12.2374 2.98799 9.89584 2.14596 7.61316C1.26392 5.22203 1.7848 3.13022 3.15951 2.25042L3.15951 2.25042C4.58542 1.33783 5.64997 1.52983 6.39945 1.92503C7.21272 2.35388 7.73108 3.07114 7.86143 3.26838L8.51573 4.25838L9.17002 3.26838C9.30038 3.07113 9.81873 2.35388 10.632 1.92503C11.3815 1.52983 12.446 1.33783 13.8719 2.25042Z\",\n    stroke: s || \"#A0A3AD\",\n    strokeWidth: \"1.56855\"\n  }), /* @__PURE__ */ q.jsx(\"mask\", {\n    id: \"path-2-inside-1_187_1051\",\n    fill: \"white\",\n    children: /* @__PURE__ */ q.jsx(\"path\", {\n      d: \"M8.58444 13.9397C7.76139 13.6864 7.05334 13.3937 6.29976 12.9825C5.95633 12.7951 5.62285 12.5895 5.3003 12.3681C5.14416 12.2609 4.99108 12.1493 4.84063 12.0343C4.78132 11.9889 4.88038 12.0652 4.82156 12.0195C4.80388 12.0058 4.7863 11.9919 4.76869 11.9781C4.73364 11.9505 4.69884 11.9225 4.66413 11.8945C4.58948 11.8342 4.51582 11.7727 4.4428 11.7105C3.90499 11.252 3.41381 10.7389 2.98016 10.1809C3.01856 10.2303 2.97651 10.176 2.97064 10.1683C2.9583 10.1522 2.94604 10.1359 2.9338 10.1197C2.90939 10.0874 2.88527 10.0548 2.86126 10.0221C2.80961 9.95189 2.75908 9.8808 2.70932 9.8092C2.61492 9.67345 2.52441 9.535 2.4371 9.39457C2.2673 9.12145 2.11213 8.83926 1.97147 8.55006C1.93849 8.48228 1.90657 8.41396 1.87531 8.34537C1.85978 8.3113 1.84459 8.27709 1.82948 8.24284C1.82195 8.22575 1.81456 8.20864 1.80714 8.19152C1.80167 8.17889 1.76856 8.10061 1.79664 8.16736C1.73728 8.0262 1.68205 7.88329 1.63029 7.73916C1.52982 7.45942 1.44498 7.17407 1.37575 6.88502C1.34218 6.74492 1.31301 6.60379 1.28746 6.46202C1.2754 6.39502 1.2645 6.32782 1.2543 6.26052C1.24925 6.22713 1.24453 6.19369 1.23994 6.16023C1.25136 6.24358 1.23495 6.11772 1.23231 6.09532C1.20042 5.82444 1.18535 5.55158 1.18721 5.27885C1.18811 5.14691 1.19374 5.01501 1.20334 4.88343C1.20788 4.82128 1.21368 4.75922 1.22023 4.69726C1.2235 4.66651 1.22713 4.6358 1.23089 4.60511C1.23278 4.58982 1.23477 4.57457 1.23678 4.5593C1.22562 4.64425 1.23563 4.56956 1.23823 4.55163C1.27428 4.30419 1.32861 4.05943 1.40097 3.82006C1.43614 3.70375 1.47635 3.58899 1.52072 3.47587C1.53125 3.449 1.54219 3.42229 1.55326 3.39564C1.51941 3.47716 1.55889 3.38334 1.56717 3.36464C1.59226 3.30803 1.61886 3.25209 1.64643 3.19664C1.75101 2.98624 1.87476 2.78549 2.01534 2.59724C2.02371 2.58603 2.03221 2.57492 2.04071 2.5638C1.99275 2.62656 2.02446 2.58496 2.03493 2.57169C2.05223 2.54974 2.06993 2.52808 2.08773 2.50653C2.12631 2.45984 2.16629 2.41434 2.20713 2.36962C2.28587 2.28341 2.36926 2.20151 2.456 2.12339C2.49787 2.08568 2.54084 2.0492 2.58443 2.01352C2.60631 1.99561 2.62852 1.97808 2.65084 1.9607C2.58164 2.01466 2.67191 1.94557 2.68962 1.93265C2.83338 1.8277 2.98587 1.7348 3.14013 1.6463C3.54393 1.41459 3.92437 1.25567 4.3831 1.15072C4.47716 1.12921 4.57219 1.11204 4.6676 1.09771C4.74483 1.08611 4.61527 1.10399 4.69217 1.09444C4.71513 1.0916 4.73817 1.08917 4.76119 1.08677C4.81403 1.08124 4.86704 1.07739 4.92007 1.07423C5.10084 1.06348 5.28237 1.06851 5.46252 1.0864C5.48336 1.08846 5.50417 1.09092 5.52495 1.09338C5.59508 1.10167 5.46943 1.08526 5.53899 1.09521C5.57965 1.10103 5.62016 1.10795 5.66059 1.11524C5.74647 1.13073 5.83159 1.1503 5.91604 1.17227C6.0728 1.21311 6.22621 1.26621 6.37595 1.32786C6.31111 1.30115 6.41877 1.34702 6.43584 1.35477C6.46987 1.3702 6.50356 1.38639 6.53714 1.4028C6.60865 1.43779 6.67886 1.47543 6.74817 1.51462C6.87662 1.58723 7.00062 1.66753 7.12092 1.7529C7.14882 1.77271 7.17637 1.79297 7.20383 1.81338C7.21739 1.82348 7.23087 1.8337 7.24432 1.84396C7.29158 1.87992 7.1988 1.80839 7.24529 1.84482C7.30109 1.88853 7.35568 1.93375 7.40949 1.97982C7.50652 2.06288 7.59994 2.15008 7.69053 2.24011C7.84008 2.38879 7.98044 2.54677 8.11149 2.71194C8.12572 2.72987 8.17533 2.79414 8.11485 2.7157C8.12636 2.73065 8.13776 2.74568 8.1491 2.76075C8.1694 2.78769 8.18934 2.81491 8.20905 2.8423C8.23825 2.88286 8.2667 2.92398 8.29429 2.96566C8.40374 3.131 8.6286 3.131 8.73805 2.96566C8.76707 2.92181 8.79712 2.87866 8.82785 2.83598C8.84783 2.80823 8.86819 2.78075 8.88875 2.75344C8.90242 2.73529 8.94928 2.67474 8.88935 2.75214C8.90409 2.73312 8.919 2.71424 8.93399 2.69542C9.0671 2.52834 9.21071 2.36968 9.36261 2.21954C9.45411 2.12907 9.5493 2.04234 9.64732 1.95897C9.69737 1.91641 9.74847 1.87507 9.80017 1.83456C9.7388 1.88263 9.82694 1.81457 9.84213 1.80327C9.87427 1.77937 9.90683 1.75606 9.9396 1.73301C10.0608 1.64773 10.1866 1.56915 10.3159 1.49682C10.3802 1.46084 10.4457 1.42703 10.5119 1.39467C10.5455 1.37823 10.5795 1.36251 10.6136 1.34704C10.6308 1.33926 10.6481 1.33171 10.6654 1.32417C10.6915 1.31296 10.6885 1.3142 10.6564 1.3279C10.6681 1.32303 10.6798 1.31822 10.6916 1.31349C10.8423 1.25235 10.9973 1.20246 11.1548 1.16239C11.2332 1.14248 11.3123 1.12599 11.3918 1.11166C11.4323 1.10435 11.473 1.09815 11.5138 1.09231C11.4471 1.10186 11.5171 1.09226 11.5281 1.09095C11.5559 1.08767 11.5838 1.08499 11.6117 1.0824C11.793 1.06553 11.9757 1.06513 12.1573 1.0771C12.203 1.08011 12.2485 1.08444 12.294 1.08921C12.3172 1.09163 12.3402 1.0945 12.3633 1.09734C12.3036 1.08994 12.3813 1.10022 12.3881 1.10123C12.4921 1.11685 12.5952 1.13785 12.6975 1.16193C13.1586 1.27048 13.5378 1.44037 13.9464 1.67761C14.0904 1.76129 14.2314 1.8507 14.3656 1.9495C14.377 1.95791 14.3884 1.96648 14.3997 1.97503C14.4419 2.00688 14.351 1.93696 14.3926 1.96945C14.4149 1.98683 14.4369 2.00462 14.4588 2.02252C14.5059 2.06115 14.5519 2.1013 14.5971 2.14228C14.6835 2.22073 14.7656 2.30388 14.8439 2.39035C14.8815 2.43176 14.9178 2.47427 14.9534 2.51736C14.9712 2.53891 14.9887 2.56077 15.006 2.58274C15.0384 2.62388 14.9682 2.53335 15 2.575C15.0114 2.58983 15.0225 2.60479 15.0336 2.61978C15.1736 2.80871 15.2946 3.01142 15.3985 3.22224C15.4238 3.27356 15.4477 3.32553 15.4709 3.37782C15.4767 3.39096 15.4824 3.40414 15.4881 3.41734C15.5093 3.46656 15.464 3.35945 15.4845 3.40902C15.4975 3.44013 15.5099 3.47148 15.5221 3.50289C15.5661 3.61632 15.6049 3.73175 15.6398 3.84833C15.7115 4.08832 15.763 4.33416 15.7984 4.58204C15.8064 4.63806 15.7901 4.51842 15.7975 4.57463C15.7995 4.58992 15.8014 4.60521 15.8033 4.6205C15.807 4.6512 15.8104 4.68197 15.8137 4.71273C15.8208 4.77994 15.8264 4.84732 15.8312 4.91474C15.8404 5.04658 15.8447 5.17876 15.8453 5.31093C15.8464 5.58418 15.8287 5.85737 15.7961 6.12862C15.7941 6.14529 15.7919 6.16192 15.7898 6.17856C15.7822 6.23827 15.7983 6.11722 15.7901 6.17697C15.7855 6.21044 15.7806 6.24389 15.7755 6.27731C15.7644 6.35031 15.752 6.4231 15.7388 6.49573C15.7129 6.63769 15.6823 6.7788 15.6484 6.91905C15.5784 7.20843 15.4909 7.49348 15.3897 7.77343C15.3648 7.84232 15.3388 7.9108 15.3121 7.97902C15.2987 8.01338 15.2849 8.0476 15.2711 8.08179C15.2641 8.09896 15.257 8.11604 15.25 8.13315C15.2452 8.14458 15.2405 8.15598 15.2357 8.16738C15.2496 8.13453 15.251 8.13117 15.2399 8.15734C15.1786 8.30137 15.1131 8.44355 15.0443 8.58416C14.9028 8.87351 14.7451 9.15483 14.5745 9.42799C14.4868 9.56844 14.395 9.70634 14.3002 9.84213C14.254 9.90821 14.2069 9.97355 14.1592 10.0385C14.1351 10.0711 14.1108 10.1036 14.0864 10.136C14.0741 10.1522 14.0617 10.1684 14.0494 10.1845C14.0319 10.2073 14.0329 10.2061 14.0522 10.181C14.0439 10.1918 14.0355 10.2025 14.0271 10.2132C13.8135 10.4869 13.5849 10.7488 13.3445 10.9992C13.0948 11.2594 12.8309 11.5058 12.556 11.7391C12.4884 11.7965 12.4199 11.8528 12.3509 11.9086C12.3162 11.9366 12.2812 11.9643 12.2461 11.992C12.2285 12.0058 12.2108 12.0196 12.1931 12.0333C12.2377 11.9987 12.1636 12.0558 12.156 12.0616C12.005 12.1765 11.8508 12.2871 11.6942 12.3941C11.3706 12.6153 11.0348 12.8185 10.6904 13.0055C10.5122 13.1023 10.3313 13.1939 10.1484 13.2815C10.059 13.3243 9.96904 13.3658 9.87868 13.4064C9.8331 13.4269 9.78733 13.4469 9.74151 13.4669C9.7185 13.4769 9.69541 13.4868 9.67233 13.4966C9.6442 13.5086 9.64146 13.5098 9.66417 13.5002C9.64864 13.5067 9.63313 13.5132 9.61758 13.5196C9.2349 13.6788 8.84398 13.8179 8.44786 13.9398C8.31409 13.9809 8.2304 14.1178 8.26839 14.2559C8.3047 14.3878 8.45064 14.4765 8.5845 14.4353C10.1534 13.9525 11.626 13.1871 12.8857 12.131C13.9425 11.245 14.8349 10.1456 15.4543 8.91165C15.9942 7.83608 16.3357 6.64744 16.3583 5.43967C16.3774 4.41628 16.149 3.35704 15.5742 2.49789C15.2929 2.07732 14.9371 1.71816 14.5205 1.43134C13.7956 0.932295 12.9294 0.592822 12.045 0.557214C10.7717 0.505949 9.60126 1.17157 8.7697 2.09685C8.59779 2.28813 8.43634 2.49172 8.29431 2.70629C8.44223 2.70629 8.59015 2.70629 8.73807 2.70629C8.22434 1.93023 7.48255 1.25338 6.6264 0.880424C5.9305 0.577258 5.18555 0.490164 4.43721 0.617179C3.98766 0.69348 3.55546 0.856508 3.14849 1.05915C2.81945 1.22296 2.50653 1.41842 2.22115 1.65017C1.44904 2.27713 0.973026 3.20995 0.783732 4.17519C0.56509 5.29004 0.68737 6.45381 1.02051 7.53339C1.41084 8.79827 2.09407 9.95916 2.95641 10.9589C3.94757 12.1081 5.19614 13.0306 6.5582 13.6933C7.16712 13.9896 7.8008 14.2362 8.44788 14.4353C8.58174 14.4765 8.72768 14.3878 8.76399 14.2559C8.80189 14.1177 8.71821 13.9809 8.58444 13.9397Z\"\n    })\n  }), /* @__PURE__ */ q.jsx(\"path\", {\n    d: \"M8.58444 13.9397C7.76139 13.6864 7.05334 13.3937 6.29976 12.9825C5.95633 12.7951 5.62285 12.5895 5.3003 12.3681C5.14416 12.2609 4.99108 12.1493 4.84063 12.0343C4.78132 11.9889 4.88038 12.0652 4.82156 12.0195C4.80388 12.0058 4.7863 11.9919 4.76869 11.9781C4.73364 11.9505 4.69884 11.9225 4.66413 11.8945C4.58948 11.8342 4.51582 11.7727 4.4428 11.7105C3.90499 11.252 3.41381 10.7389 2.98016 10.1809C3.01856 10.2303 2.97651 10.176 2.97064 10.1683C2.9583 10.1522 2.94604 10.1359 2.9338 10.1197C2.90939 10.0874 2.88527 10.0548 2.86126 10.0221C2.80961 9.95189 2.75908 9.8808 2.70932 9.8092C2.61492 9.67345 2.52441 9.535 2.4371 9.39457C2.2673 9.12145 2.11213 8.83926 1.97147 8.55006C1.93849 8.48228 1.90657 8.41396 1.87531 8.34537C1.85978 8.3113 1.84459 8.27709 1.82948 8.24284C1.82195 8.22575 1.81456 8.20864 1.80714 8.19152C1.80167 8.17889 1.76856 8.10061 1.79664 8.16736C1.73728 8.0262 1.68205 7.88329 1.63029 7.73916C1.52982 7.45942 1.44498 7.17407 1.37575 6.88502C1.34218 6.74492 1.31301 6.60379 1.28746 6.46202C1.2754 6.39502 1.2645 6.32782 1.2543 6.26052C1.24925 6.22713 1.24453 6.19369 1.23994 6.16023C1.25136 6.24358 1.23495 6.11772 1.23231 6.09532C1.20042 5.82444 1.18535 5.55158 1.18721 5.27885C1.18811 5.14691 1.19374 5.01501 1.20334 4.88343C1.20788 4.82128 1.21368 4.75922 1.22023 4.69726C1.2235 4.66651 1.22713 4.6358 1.23089 4.60511C1.23278 4.58982 1.23477 4.57457 1.23678 4.5593C1.22562 4.64425 1.23563 4.56956 1.23823 4.55163C1.27428 4.30419 1.32861 4.05943 1.40097 3.82006C1.43614 3.70375 1.47635 3.58899 1.52072 3.47587C1.53125 3.449 1.54219 3.42229 1.55326 3.39564C1.51941 3.47716 1.55889 3.38334 1.56717 3.36464C1.59226 3.30803 1.61886 3.25209 1.64643 3.19664C1.75101 2.98624 1.87476 2.78549 2.01534 2.59724C2.02371 2.58603 2.03221 2.57492 2.04071 2.5638C1.99275 2.62656 2.02446 2.58496 2.03493 2.57169C2.05223 2.54974 2.06993 2.52808 2.08773 2.50653C2.12631 2.45984 2.16629 2.41434 2.20713 2.36962C2.28587 2.28341 2.36926 2.20151 2.456 2.12339C2.49787 2.08568 2.54084 2.0492 2.58443 2.01352C2.60631 1.99561 2.62852 1.97808 2.65084 1.9607C2.58164 2.01466 2.67191 1.94557 2.68962 1.93265C2.83338 1.8277 2.98587 1.7348 3.14013 1.6463C3.54393 1.41459 3.92437 1.25567 4.3831 1.15072C4.47716 1.12921 4.57219 1.11204 4.6676 1.09771C4.74483 1.08611 4.61527 1.10399 4.69217 1.09444C4.71513 1.0916 4.73817 1.08917 4.76119 1.08677C4.81403 1.08124 4.86704 1.07739 4.92007 1.07423C5.10084 1.06348 5.28237 1.06851 5.46252 1.0864C5.48336 1.08846 5.50417 1.09092 5.52495 1.09338C5.59508 1.10167 5.46943 1.08526 5.53899 1.09521C5.57965 1.10103 5.62016 1.10795 5.66059 1.11524C5.74647 1.13073 5.83159 1.1503 5.91604 1.17227C6.0728 1.21311 6.22621 1.26621 6.37595 1.32786C6.31111 1.30115 6.41877 1.34702 6.43584 1.35477C6.46987 1.3702 6.50356 1.38639 6.53714 1.4028C6.60865 1.43779 6.67886 1.47543 6.74817 1.51462C6.87662 1.58723 7.00062 1.66753 7.12092 1.7529C7.14882 1.77271 7.17637 1.79297 7.20383 1.81338C7.21739 1.82348 7.23087 1.8337 7.24432 1.84396C7.29158 1.87992 7.1988 1.80839 7.24529 1.84482C7.30109 1.88853 7.35568 1.93375 7.40949 1.97982C7.50652 2.06288 7.59994 2.15008 7.69053 2.24011C7.84008 2.38879 7.98044 2.54677 8.11149 2.71194C8.12572 2.72987 8.17533 2.79414 8.11485 2.7157C8.12636 2.73065 8.13776 2.74568 8.1491 2.76075C8.1694 2.78769 8.18934 2.81491 8.20905 2.8423C8.23825 2.88286 8.2667 2.92398 8.29429 2.96566C8.40374 3.131 8.6286 3.131 8.73805 2.96566C8.76707 2.92181 8.79712 2.87866 8.82785 2.83598C8.84783 2.80823 8.86819 2.78075 8.88875 2.75344C8.90242 2.73529 8.94928 2.67474 8.88935 2.75214C8.90409 2.73312 8.919 2.71424 8.93399 2.69542C9.0671 2.52834 9.21071 2.36968 9.36261 2.21954C9.45411 2.12907 9.5493 2.04234 9.64732 1.95897C9.69737 1.91641 9.74847 1.87507 9.80017 1.83456C9.7388 1.88263 9.82694 1.81457 9.84213 1.80327C9.87427 1.77937 9.90683 1.75606 9.9396 1.73301C10.0608 1.64773 10.1866 1.56915 10.3159 1.49682C10.3802 1.46084 10.4457 1.42703 10.5119 1.39467C10.5455 1.37823 10.5795 1.36251 10.6136 1.34704C10.6308 1.33926 10.6481 1.33171 10.6654 1.32417C10.6915 1.31296 10.6885 1.3142 10.6564 1.3279C10.6681 1.32303 10.6798 1.31822 10.6916 1.31349C10.8423 1.25235 10.9973 1.20246 11.1548 1.16239C11.2332 1.14248 11.3123 1.12599 11.3918 1.11166C11.4323 1.10435 11.473 1.09815 11.5138 1.09231C11.4471 1.10186 11.5171 1.09226 11.5281 1.09095C11.5559 1.08767 11.5838 1.08499 11.6117 1.0824C11.793 1.06553 11.9757 1.06513 12.1573 1.0771C12.203 1.08011 12.2485 1.08444 12.294 1.08921C12.3172 1.09163 12.3402 1.0945 12.3633 1.09734C12.3036 1.08994 12.3813 1.10022 12.3881 1.10123C12.4921 1.11685 12.5952 1.13785 12.6975 1.16193C13.1586 1.27048 13.5378 1.44037 13.9464 1.67761C14.0904 1.76129 14.2314 1.8507 14.3656 1.9495C14.377 1.95791 14.3884 1.96648 14.3997 1.97503C14.4419 2.00688 14.351 1.93696 14.3926 1.96945C14.4149 1.98683 14.4369 2.00462 14.4588 2.02252C14.5059 2.06115 14.5519 2.1013 14.5971 2.14228C14.6835 2.22073 14.7656 2.30388 14.8439 2.39035C14.8815 2.43176 14.9178 2.47427 14.9534 2.51736C14.9712 2.53891 14.9887 2.56077 15.006 2.58274C15.0384 2.62388 14.9682 2.53335 15 2.575C15.0114 2.58983 15.0225 2.60479 15.0336 2.61978C15.1736 2.80871 15.2946 3.01142 15.3985 3.22224C15.4238 3.27356 15.4477 3.32553 15.4709 3.37782C15.4767 3.39096 15.4824 3.40414 15.4881 3.41734C15.5093 3.46656 15.464 3.35945 15.4845 3.40902C15.4975 3.44013 15.5099 3.47148 15.5221 3.50289C15.5661 3.61632 15.6049 3.73175 15.6398 3.84833C15.7115 4.08832 15.763 4.33416 15.7984 4.58204C15.8064 4.63806 15.7901 4.51842 15.7975 4.57463C15.7995 4.58992 15.8014 4.60521 15.8033 4.6205C15.807 4.6512 15.8104 4.68197 15.8137 4.71273C15.8208 4.77994 15.8264 4.84732 15.8312 4.91474C15.8404 5.04658 15.8447 5.17876 15.8453 5.31093C15.8464 5.58418 15.8287 5.85737 15.7961 6.12862C15.7941 6.14529 15.7919 6.16192 15.7898 6.17856C15.7822 6.23827 15.7983 6.11722 15.7901 6.17697C15.7855 6.21044 15.7806 6.24389 15.7755 6.27731C15.7644 6.35031 15.752 6.4231 15.7388 6.49573C15.7129 6.63769 15.6823 6.7788 15.6484 6.91905C15.5784 7.20843 15.4909 7.49348 15.3897 7.77343C15.3648 7.84232 15.3388 7.9108 15.3121 7.97902C15.2987 8.01338 15.2849 8.0476 15.2711 8.08179C15.2641 8.09896 15.257 8.11604 15.25 8.13315C15.2452 8.14458 15.2405 8.15598 15.2357 8.16738C15.2496 8.13453 15.251 8.13117 15.2399 8.15734C15.1786 8.30137 15.1131 8.44355 15.0443 8.58416C14.9028 8.87351 14.7451 9.15483 14.5745 9.42799C14.4868 9.56844 14.395 9.70634 14.3002 9.84213C14.254 9.90821 14.2069 9.97355 14.1592 10.0385C14.1351 10.0711 14.1108 10.1036 14.0864 10.136C14.0741 10.1522 14.0617 10.1684 14.0494 10.1845C14.0319 10.2073 14.0329 10.2061 14.0522 10.181C14.0439 10.1918 14.0355 10.2025 14.0271 10.2132C13.8135 10.4869 13.5849 10.7488 13.3445 10.9992C13.0948 11.2594 12.8309 11.5058 12.556 11.7391C12.4884 11.7965 12.4199 11.8528 12.3509 11.9086C12.3162 11.9366 12.2812 11.9643 12.2461 11.992C12.2285 12.0058 12.2108 12.0196 12.1931 12.0333C12.2377 11.9987 12.1636 12.0558 12.156 12.0616C12.005 12.1765 11.8508 12.2871 11.6942 12.3941C11.3706 12.6153 11.0348 12.8185 10.6904 13.0055C10.5122 13.1023 10.3313 13.1939 10.1484 13.2815C10.059 13.3243 9.96904 13.3658 9.87868 13.4064C9.8331 13.4269 9.78733 13.4469 9.74151 13.4669C9.7185 13.4769 9.69541 13.4868 9.67233 13.4966C9.6442 13.5086 9.64146 13.5098 9.66417 13.5002C9.64864 13.5067 9.63313 13.5132 9.61758 13.5196C9.2349 13.6788 8.84398 13.8179 8.44786 13.9398C8.31409 13.9809 8.2304 14.1178 8.26839 14.2559C8.3047 14.3878 8.45064 14.4765 8.5845 14.4353C10.1534 13.9525 11.626 13.1871 12.8857 12.131C13.9425 11.245 14.8349 10.1456 15.4543 8.91165C15.9942 7.83608 16.3357 6.64744 16.3583 5.43967C16.3774 4.41628 16.149 3.35704 15.5742 2.49789C15.2929 2.07732 14.9371 1.71816 14.5205 1.43134C13.7956 0.932295 12.9294 0.592822 12.045 0.557214C10.7717 0.505949 9.60126 1.17157 8.7697 2.09685C8.59779 2.28813 8.43634 2.49172 8.29431 2.70629C8.44223 2.70629 8.59015 2.70629 8.73807 2.70629C8.22434 1.93023 7.48255 1.25338 6.6264 0.880424C5.9305 0.577258 5.18555 0.490164 4.43721 0.617179C3.98766 0.69348 3.55546 0.856508 3.14849 1.05915C2.81945 1.22296 2.50653 1.41842 2.22115 1.65017C1.44904 2.27713 0.973026 3.20995 0.783732 4.17519C0.56509 5.29004 0.68737 6.45381 1.02051 7.53339C1.41084 8.79827 2.09407 9.95916 2.95641 10.9589C3.94757 12.1081 5.19614 13.0306 6.5582 13.6933C7.16712 13.9896 7.8008 14.2362 8.44788 14.4353C8.58174 14.4765 8.72768 14.3878 8.76399 14.2559C8.80189 14.1177 8.71821 13.9809 8.58444 13.9397Z\",\n    stroke: s || \"#A0A3AD\",\n    strokeWidth: \"3.13711\",\n    mask: \"url(#path-2-inside-1_187_1051)\"\n  })]\n});\nfunction sm({\n  onClick: s,\n  size: e = 24\n}) {\n  return /* @__PURE__ */ q.jsx(\"svg\", {\n    \"aria-hidden\": \"true\",\n    focusable: \"false\",\n    role: \"img\",\n    viewBox: \"0 0 16 16\",\n    width: e,\n    height: e,\n    fill: \"#4A4A4A\",\n    style: {\n      display: \"inline-block\",\n      userSelect: \"none\",\n      verticalAlign: \"text-bottom\",\n      overflow: \"visible\",\n      cursor: \"pointer\",\n      padding: \"4px\"\n    },\n    onClick: s,\n    children: /* @__PURE__ */ q.jsx(\"path\", {\n      d: \"M3.72 3.72a.75.75 0 0 1 1.06 0L8 6.94l3.22-3.22a.749.749 0 0 1 1.275.326.749.749 0 0 1-.215.734L9.06 8l3.22 3.22a.749.749 0 0 1-.326 1.275.749.749 0 0 1-.734-.215L8 9.06l-3.22 3.22a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042L6.94 8 3.72 4.78a.75.75 0 0 1 0-1.06Z\"\n    })\n  });\n}\nconst FA = () =&gt; Ir, NA = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(FA())({\n  classes: [\"rect7e5\"]\n}), UA = () =&gt; Ir, $A = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(UA())({\n  classes: [\"p13mqntt\"]\n}), GA = () =&gt; Ir, VA = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(GA())({\n  classes: [\"p1r47dz2\"]\n}), jA = () =&gt; Ir, KA = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(jA())({\n  classes: [\"cnojpqv\"]\n}), HA = ({\n  hash: s,\n  reactions: e,\n  onComment: t,\n  onRecast: r,\n  onLike: n,\n  isLiked: i\n}) =&gt; {\n  const {\n    client_id: o,\n    user: a,\n    isAuthenticated: l\n  } = ts(), [c, u] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(!1), [d, h] = react__WEBPACK_IMPORTED_MODULE_0___default().useState({\n    top: 0,\n    left: 0\n  }), [f, p] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null), [y, E] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(i), [b, R] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(!1), A = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null), F = react__WEBPACK_IMPORTED_MODULE_0___default().useRef({\n    comment: null,\n    recast: null,\n    like: null\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    E(e.likes.some((H) =&gt; H.fid === (a == null ? void 0 : a.fid))), R(e.recasts.some((H) =&gt; H.fid === (a == null ? void 0 : a.fid)));\n  }, [e, a]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    const H = localStorage.getItem(jn.NEYNAR_AUTHENTICATED_USER);\n    if (H)\n      try {\n        p(JSON.parse(H).signer_uuid);\n      } catch (K) {\n        console.error(\"Error parsing JSON from local storage:\", K), p(null);\n      }\n    else\n      console.warn(\"No NEYNAR_AUTHENTICATED_USER found in local storage.\");\n  }, [l]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    (f || l) &amp;&amp; c &amp;&amp; u(!1);\n  }, [f, l, c]);\n  const M = async (H, K) =&gt; {\n    if (f)\n      switch (K) {\n        case \"comment\":\n          if (t)\n            t();\n          else\n            throw new Error(\"No comment handler function provided\");\n          break;\n        case \"recast\":\n          if (r)\n            R(r());\n          else\n            throw new Error(\"No recast handler function provided\");\n          break;\n        case \"like\":\n          if (n)\n            E(n());\n          else\n            throw new Error(\"No like handler function provided\");\n          break;\n      }\n    const j = F.current[K];\n    if (j) {\n      const C = j.getBoundingClientRect(), k = A.current;\n      if (k) {\n        const $ = k.getBoundingClientRect();\n        h({\n          top: C.top - $.height - 10,\n          left: C.left + C.width / 2 - $.width / 2\n        });\n      }\n    }\n  };\n  return /* @__PURE__ */ q.jsxs(NA, {\n    children: [c &amp;&amp; /* @__PURE__ */ q.jsxs($A, {\n      ref: A,\n      style: {\n        top: d.top,\n        left: d.left\n      },\n      children: [/* @__PURE__ */ q.jsx(VA, {\n        children: /* @__PURE__ */ q.jsx(pS, {\n          variant: gs.NEYNAR\n        })\n      }), /* @__PURE__ */ q.jsx(KA, {\n        children: /* @__PURE__ */ q.jsx(sm, {\n          onClick: () =&gt; u(!1),\n          size: 16\n        })\n      })]\n    }), /* @__PURE__ */ q.jsx(Ir, {\n      style: {\n        display: \"flex\",\n        justifyContent: \"space-between\",\n        alignItems: \"center\"\n      },\n      children: /* @__PURE__ */ q.jsxs(Ir, {\n        spacingVertical: \"15px\",\n        style: {\n          display: \"flex\",\n          gap: \"42px\"\n        },\n        children: [/* @__PURE__ */ q.jsx(\"div\", {\n          ref: (H) =&gt; F.current.comment = H,\n          children: /* @__PURE__ */ q.jsx(tm, {\n            onClick: (H) =&gt; M(H, \"comment\")\n          })\n        }), /* @__PURE__ */ q.jsx(\"div\", {\n          ref: (H) =&gt; F.current.recast = H,\n          children: /* @__PURE__ */ q.jsx(BA, {\n            fill: b ? \"green\" : void 0,\n            onClick: (H) =&gt; M(H, \"recast\")\n          })\n        }), /* @__PURE__ */ q.jsx(\"div\", {\n          ref: (H) =&gt; F.current.like = H,\n          children: /* @__PURE__ */ q.jsx(rm, {\n            fill: y ? \"red\" : void 0,\n            onClick: (H) =&gt; M(H, \"like\")\n          })\n        })]\n      })\n    })]\n  });\n};\nfunction qA({\n  onClick: s\n}) {\n  return /* @__PURE__ */ q.jsx(\"svg\", {\n    style: {\n      cursor: \"pointer\"\n    },\n    width: \"16\",\n    height: \"15\",\n    viewBox: \"0 0 16 15\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    onClick: (e) =&gt; s ? s(e) : void 0,\n    children: /* @__PURE__ */ q.jsx(\"path\", {\n      d: \"M15.2003 7.49063C14.7504 7.49063 14.4504 7.79057 14.4504 8.24048V12.7396C14.4504 13.1895 14.1505 13.4894 13.7006 13.4894H3.20268C2.75277 13.4894 2.45283 13.1895 2.45283 12.7396V8.24048C2.45283 7.79057 2.15289 7.49063 1.70298 7.49063C1.25307 7.49063 0.953125 7.79057 0.953125 8.24048V12.7396C0.953125 14.0143 1.92793 14.9891 3.20268 14.9891H13.7006C14.9753 14.9891 15.9501 14.0143 15.9501 12.7396V8.24048C15.9501 7.79057 15.6502 7.49063 15.2003 7.49063ZM5.97713 4.26627L7.70178 2.54161V9.74018C7.70178 10.1901 8.00172 10.49 8.45163 10.49C8.90155 10.49 9.20149 10.1901 9.20149 9.74018V2.54161L10.9261 4.26627C11.2261 4.56621 11.676 4.56621 11.9759 4.26627C12.2759 3.96633 12.2759 3.51642 11.9759 3.21648L8.97653 0.217073C8.90155 0.142088 8.82656 0.0671031 8.75157 0.0671031C8.6016 -0.00788202 8.37665 -0.00788202 8.15169 0.0671031C8.07671 0.0671031 8.00172 0.142088 7.92674 0.217073L4.92734 3.21648C4.62739 3.51642 4.62739 3.96633 4.92734 4.26627C5.22728 4.56621 5.67719 4.56621 5.97713 4.26627Z\",\n      fill: \"#A0A3AD\"\n    })\n  });\n}\nconst Ic = ({\n  url: s\n}) =&gt; {\n  const [e, t] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(!1), r = async (n) =&gt; {\n    try {\n      await navigator.clipboard.writeText(s), t(!0), setTimeout(() =&gt; {\n        t(!1);\n      }, 2e3);\n    } catch (i) {\n      console.error(\"Failed to copy the text to clipboard:\", i);\n    }\n  };\n  return /* @__PURE__ */ q.jsx(\"div\", {\n    children: e ? /* @__PURE__ */ q.jsx(\"svg\", {\n      style: {\n        cursor: \"pointer\",\n        fill: \"green\"\n      },\n      width: \"16\",\n      height: \"15\",\n      viewBox: \"0 0 16 15\",\n      xmlns: \"http://www.w3.org/2000/svg\",\n      children: /* @__PURE__ */ q.jsx(\"path\", {\n        d: \"M5.99967 12.8136L1.71967 8.53364L0.559673 9.69364L5.99967 15.1336L16.4397 4.69364L15.2797 3.53364L5.99967 12.8136Z\"\n      })\n    }) : /* @__PURE__ */ q.jsx(qA, {\n      onClick: r\n    })\n  });\n}, WA = () =&gt; /* @__PURE__ */ q.jsxs(\"svg\", {\n  width: \"10\",\n  height: \"10\",\n  viewBox: \"0 0 10 10\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\",\n  children: [/* @__PURE__ */ q.jsx(\"path\", {\n    d: \"M5.85855 0.555664H8.31281M8.31281 0.555664V2.73754M8.31281 0.555664L4.31445 4.11122\",\n    stroke: \"#FFFFFF\",\n    \"stroke-linecap\": \"round\",\n    \"stroke-linejoin\": \"round\"\n  }), /* @__PURE__ */ q.jsx(\"path\", {\n    \"fill-rule\": \"evenodd\",\n    \"clip-rule\": \"evenodd\",\n    d: \"M3.31445 1H1.31445C0.762168 1 0.314453 1.44772 0.314453 2V8C0.314453 8.55228 0.762168 9 1.31445 9H7.31445C7.86674 9 8.31445 8.55228 8.31445 8V6H7.31445V8H1.31445V2H3.31445V1Z\",\n    fill: \"#FFFFFF\"\n  })]\n}), zA = () =&gt; /* @__PURE__ */ q.jsx(\"svg\", {\n  width: \"10\",\n  height: \"14\",\n  viewBox: \"0 0 10 14\",\n  fill: \"none\",\n  xmlns: \"http://www.w3.org/2000/svg\",\n  children: /* @__PURE__ */ q.jsx(\"path\", {\n    d: \"M5.01451 12.5187L4.96833 12.5174L4.93914 12.522C4.93113 12.516 4.92402 12.5087 4.91808 12.5005L4.51231 12.7926L4.91808 12.5005C4.9049 12.4822 4.89824 12.46 4.89913 12.4375L4.89953 12.4275V12.4176V8.81194V8.31194H4.39953H1.8876H1.88753C1.76188 8.31196 1.63853 8.27825 1.53036 8.21433C1.42218 8.1504 1.33315 8.05862 1.27256 7.94854C1.21196 7.83847 1.18203 7.71415 1.18588 7.58856C1.18973 7.46301 1.2272 7.34079 1.29438 7.23466C1.2944 7.23463 1.29442 7.23459 1.29444 7.23456L4.90001 1.54377L4.90567 1.53483L4.91095 1.52567C4.92227 1.50601 4.93988 1.49074 4.96094 1.48232C4.982 1.47389 5.00528 1.47281 5.02703 1.47924L5.02912 1.47985C5.05077 1.48614 5.06969 1.4995 5.08286 1.5178C5.09603 1.53609 5.1027 1.55827 5.1018 1.58079L5.10141 1.59073V1.60067V5.20631V5.70631H5.60141H8.11333H8.1134C8.23905 5.70629 8.3624 5.74 8.47058 5.80392C8.57875 5.86784 8.66778 5.95963 8.72838 6.06971C8.78897 6.17978 8.81891 6.3041 8.81506 6.42969C8.81121 6.55528 8.77371 6.67753 8.70649 6.78369L5.10232 12.4723C5.10219 12.4725 5.10205 12.4727 5.10191 12.4729C5.09255 12.4873 5.07969 12.499 5.06452 12.507C5.04914 12.5152 5.03191 12.5192 5.01451 12.5187Z\",\n    stroke: \"#FFFFFF\"\n  })\n}), YA = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"button\")({\n  classes: [\"f1hmcrrf\"]\n}), ZA = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"f1ki4il6\"]\n}), XA = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"bgnz0ud\"]\n}), JA = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"img\")({\n  classes: [\"f1gbget9\"]\n}), QA = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"f4rwe4i\"]\n}), eI = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"f1qellgw\"]\n}), tI = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"input\")({\n  classes: [\"i1hgxwhi\"]\n}), rI = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"s1ahcfax\"]\n}), sI = () =&gt; {\n  const s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    if (s.current) {\n      let e = 0;\n      const t = () =&gt; {\n        e += 6, s.current &amp;&amp; (s.current.style.transform = `rotate(${e}deg)`), requestAnimationFrame(t);\n      };\n      requestAnimationFrame(t);\n    }\n  }, []), /* @__PURE__ */ q.jsx(\"svg\", {\n    ref: s,\n    xmlns: \"http://www.w3.org/2000/svg\",\n    fill: \"none\",\n    viewBox: \"0 0 24 24\",\n    strokeWidth: \"1.5\",\n    stroke: \"currentColor\",\n    className: \"size-6 text-white\",\n    style: {\n      width: \"24px\",\n      height: \"24px\"\n    },\n    children: /* @__PURE__ */ q.jsx(\"path\", {\n      strokeLinecap: \"round\",\n      strokeLinejoin: \"round\",\n      d: \"M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99\"\n    })\n  });\n};\nfunction nI({\n  number: s,\n  text: e,\n  actionType: t,\n  target: r,\n  frameUrl: n,\n  handleOnClick: i\n}) {\n  return /* @__PURE__ */ q.jsxs(YA, {\n    onClick: () =&gt; i(s),\n    children: [e, (t === \"link\" || t === \"post_redirect\" || t === \"mint\") &amp;&amp; /* @__PURE__ */ q.jsx(WA, {}), t === \"tx\" &amp;&amp; /* @__PURE__ */ q.jsx(zA, {})]\n  });\n}\nfunction iI({\n  frame: s,\n  onFrameBtnPress: e\n}) {\n  var h;\n  const [t, r] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(s), [n, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\"), [o, a] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), l = () =&gt; {\n    const f = t.buttons.map((p) =&gt; /* @__PURE__ */ q.jsx(nI, {\n      number: p.index,\n      text: p.title,\n      actionType: p.action_type,\n      target: p.target,\n      frameUrl: s.frames_url,\n      handleOnClick: (y) =&gt; {\n        a(!0), e(y, t, r, n).finally(() =&gt; a(!1));\n      }\n    }, p.index));\n    return /* @__PURE__ */ q.jsx(XA, {\n      children: f\n    });\n  }, c = (f) =&gt; {\n    i(f);\n  }, u = (f) =&gt; {\n    try {\n      return new URL(f).hostname.replace(\"www.\", \"\");\n    } catch {\n      return \"\";\n    }\n  }, d = () =&gt; {\n    switch (t.image_aspect_ratio) {\n      case \"1:1\":\n        return {\n          aspectRatio: \"1 / 1\"\n        };\n      case \"1.91:1\":\n        return {\n          aspectRatio: \"1.91 / 1\"\n        };\n      default:\n        return {\n          aspectRatio: \"1.91 / 1\"\n        };\n    }\n  };\n  return /* @__PURE__ */ q.jsxs(q.Fragment, {\n    children: [/* @__PURE__ */ q.jsxs(ZA, {\n      children: [o &amp;&amp; /* @__PURE__ */ q.jsx(rI, {\n        children: /* @__PURE__ */ q.jsx(sI, {})\n      }), t.frames_url &amp;&amp; /* @__PURE__ */ q.jsxs(q.Fragment, {\n        children: [/* @__PURE__ */ q.jsx(\"a\", {\n          href: t.frames_url,\n          target: \"_blank\",\n          rel: \"noopener noreferrer\",\n          style: {\n            width: \"100%\"\n          },\n          children: /* @__PURE__ */ q.jsx(JA, {\n            src: t.image,\n            alt: `Frame image for ${t.frames_url}`,\n            style: d()\n          })\n        }), ((h = t.input) == null ? void 0 : h.text) &amp;&amp; /* @__PURE__ */ q.jsx(tI, {\n          type: \"text\",\n          placeholder: t.input.text,\n          value: n,\n          onChange: (f) =&gt; c(f.target.value)\n        }), l()]\n      })]\n    }), t.frames_url &amp;&amp; /* @__PURE__ */ q.jsx(QA, {\n      children: u(t.frames_url)\n    })]\n  });\n}\nconst oI = ({\n  frame: s,\n  onFrameBtnPress: e\n}) =&gt; /* @__PURE__ */ q.jsx(eI, {\n  children: s ? /* @__PURE__ */ q.jsx(iI, {\n    frame: s,\n    onFrameBtnPress: e\n  }) : /* @__PURE__ */ q.jsx(q.Fragment, {})\n}), aI = ({\n  url: s,\n  onFrameBtnPress: e,\n  initialFrame: t\n}) =&gt; {\n  const {\n    client_id: r,\n    showToast: n\n  } = ts(), [i] = du(jn.NEYNAR_AUTHENTICATED_USER, null), [o, a] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [l, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(t || null), [u, d] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    i ? a(i.signer_uuid) : console.warn(\"No NEYNAR_AUTHENTICATED_USER found in local storage.\");\n  }, [i]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    t || (async () =&gt; {\n      try {\n        const y = await lI(`${on}/v2/farcaster/frame/crawl?url=${s}&amp;client_id=${r}`, {\n          method: \"GET\"\n        });\n        if (y.ok) {\n          const b = (await y.json()).frame;\n          if (Object.keys(b).length === 0)\n            throw new Error(\"No frame data available\");\n          c(b), d(null);\n        } else\n          throw new Error(`HTTP error! status: ${y.status}`);\n      } catch (y) {\n        console.error(`An error occurred: ${y}`), d(`Failed to fetch: ${y.message}`);\n      }\n    })();\n  }, [s, n, t]);\n  const h = (p) =&gt; {\n    if (typeof p != \"object\" || p === null) return !1;\n    const y = [\"version\", \"image\", \"buttons\", \"frames_url\"];\n    for (const E of y)\n      if (!(E in p)) return !1;\n    return !(!Array.isArray(p.buttons) || p.buttons.some((E) =&gt; typeof E.index != \"number\"));\n  }, f = async (p, y, E, b) =&gt; {\n    try {\n      const R = await e(p, y, E, b);\n      if (!h(R))\n        throw new Error(\"Invalid frame data received\");\n      E(R);\n    } catch (R) {\n      n(xg.Error, `An error occurred while processing the button press: ${R}`);\n    }\n  };\n  return u ? /* @__PURE__ */ q.jsx(\"div\", {\n    style: {\n      color: \"red\",\n      padding: \"10px\",\n      border: \"1px solid red\",\n      borderRadius: \"5px\"\n    },\n    children: u\n  }) : /* @__PURE__ */ q.jsx(oI, {\n    frame: l,\n    onFrameBtnPress: f\n  });\n};\nfunction lI(s, e, t = 8e3) {\n  return Promise.race([an(s, e), new Promise((r, n) =&gt; setTimeout(() =&gt; n(new Error(\"Request timed out\")), t))]);\n}\nfunction pf(s) {\n  const e = Math.min(s, 1e9);\n  return e &gt;= 1e9 ? Math.floor(e / 1e8) / 10 + \"B\" : e &gt;= 1e6 ? Math.floor(e / 1e5) / 10 + \"M\" : e &gt;= 1e3 ? Math.floor(e / 100) / 10 + \"K\" : e.toString();\n}\nfunction cI(s) {\n  if (!s)\n    return console.error(\"Error: Timestamp is undefined or empty.\"), \"Invalid timestamp\";\n  const e = new Date(s);\n  if (isNaN(e.getTime()))\n    return console.error(\"Error: Invalid timestamp provided:\", s), \"Invalid timestamp\";\n  const t = /* @__PURE__ */ new Date(), n = new Intl.DateTimeFormat(void 0, {\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    hour12: !0\n  }).format(e).replace(\" \", \"\"), i = t.toDateString() === e.toDateString(), o = new Date(t.setDate(t.getDate() - 1)).toDateString() === e.toDateString();\n  if (i)\n    return `${n}, today`;\n  if (o)\n    return `${n}, yesterday`;\n  const a = [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"], l = e.getDate(), c = a[e.getMonth()], u = e.getFullYear(), h = `${c} ${((f) =&gt; {\n    if (f &gt; 3 &amp;&amp; f &lt; 21) return `${f}th`;\n    const p = [\"st\", \"nd\", \"rd\"], y = f % 10;\n    return `${f}${p[y - 1] || \"th\"}`;\n  })(l)} ${u}`;\n  return `${n}, ${h}`;\n}\nconst uI = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"sxqvxvq\"]\n}), dI = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"a\")({\n  classes: [\"s3kamov\"]\n}), hI = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"m1wrvvhk\"]\n}), fI = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"t1lcaq27\"]\n}), gI = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"ugtp1wh\"]\n}), pI = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"l1dqpn4e\"]\n}), mI = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"l1bjnv2t\"]\n}), mf = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"e15yf123\"]\n}), yI = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"rxra94g\"]\n}), yf = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"s1whgqrs\"]\n}), vI = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"p\")({\n  classes: [\"dz8marf\"]\n}), oa = react__WEBPACK_IMPORTED_MODULE_0___default().memo(({\n  username: s,\n  displayName: e,\n  avatarImgUrl: t,\n  text: r = \"\",\n  hash: n,\n  reactions: i,\n  replies: o,\n  embeds: a = [],\n  frames: l = [],\n  channel: c,\n  viewerFid: u,\n  hasPowerBadge: d,\n  isEmbed: h = !0,\n  allowReactions: f,\n  renderEmbeds: p,\n  renderFrames: y,\n  onLikeBtnPress: E,\n  onRecastBtnPress: b,\n  onCommentBtnPress: R,\n  onFrameBtnPress: A,\n  direct_replies: F,\n  containerStyles: M,\n  textStyles: H,\n  timestamp: K,\n  appAvatarImgUrl: j\n}) =&gt; {\n  const [C, k] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(i.likes_count), [$, W] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(i.likes.some((V) =&gt; V.fid === u)), _ = /* @__PURE__ */ q.jsx(mI, {\n    children: ES(r, a)\n  }), g = (a == null ? void 0 : a.length) === 1, x = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() =&gt; l.map((V) =&gt; V.frames_url), [l]), w = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() =&gt; a.filter((V) =&gt; !x.includes(V.url)), [a, x]), D = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((V) =&gt; {\n    V.currentTarget.src = bi;\n  }, []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    W(i.likes.some((V) =&gt; V.fid === u));\n  }, [i.likes, u]);\n  const O = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() =&gt; E &amp;&amp; E() ? (k((L) =&gt; L + 1), W(!$), !0) : !1, [E]), U = OA(w, f, u);\n  return /* @__PURE__ */ q.jsx(uI, {\n    style: {\n      ...M,\n      borderWidth: h ? \"1px\" : \"0\"\n    },\n    children: /* @__PURE__ */ q.jsxs(Pr, {\n      children: [/* @__PURE__ */ q.jsx(Ir, {\n        spacingRight: \"10px\",\n        children: /* @__PURE__ */ q.jsx(Yo, {\n          src: t &amp;&amp; t.length &gt; 0 ? t : bi,\n          width: \"20px\",\n          height: \"20px\",\n          onError: D,\n          loading: \"lazy\",\n          alt: `${e ?? \"Skeleton\"} Avatar`\n        })\n      }), /* @__PURE__ */ q.jsxs(hI, {\n        children: [/* @__PURE__ */ q.jsxs(Pr, {\n          flexGrow: 1,\n          alignItems: \"center\",\n          children: [/* @__PURE__ */ q.jsxs(Pr, {\n            children: [/* @__PURE__ */ q.jsx(vI, {\n              children: e\n            }), \" \", j &amp;&amp; /* @__PURE__ */ q.jsx(Ir, {\n              spacingLeft: \"5px\",\n              children: /* @__PURE__ */ q.jsx(\"img\", {\n                style: {\n                  padding: \"2px\",\n                  borderWidth: \"0.5px\"\n                },\n                className: \"border-white rounded-full\",\n                src: j,\n                width: \"18\",\n                height: \"18\",\n                onError: (V) =&gt; {\n                  V.currentTarget.style.display = \"none\";\n                }\n              })\n            })]\n          }), /* @__PURE__ */ q.jsxs(Pr, {\n            alignItems: \"center\",\n            children: [/* @__PURE__ */ q.jsxs(gI, {\n              children: [\"@\", s, \" \"]\n            }), \" \", /* @__PURE__ */ q.jsx(fI, {\n              style: {\n                color: \"#999999\",\n                fontSize: \"14px\",\n                fontFamily: \"Work Sans\"\n              },\n              children: cI(K)\n            })]\n          })]\n        }), /* @__PURE__ */ q.jsx(Ir, {\n          style: {\n            marginTop: \"10px\"\n          },\n          children: /* @__PURE__ */ q.jsx(pI, {\n            style: H,\n            children: _\n          })\n        }), p &amp;&amp; w &amp;&amp; w.length &gt; 0 ? /* @__PURE__ */ q.jsx(mf, {\n          style: {\n            margin: g ? \"4px 0\" : \"0\"\n          },\n          children: U.map((V, L) =&gt; /* @__PURE__ */ q.jsx(\"div\", {\n            style: {\n              width: \"100%\"\n            },\n            children: V\n          }, L))\n        }) : /* @__PURE__ */ q.jsx(q.Fragment, {}), y &amp;&amp; l &amp;&amp; l.length &gt; 0 ? /* @__PURE__ */ q.jsx(mf, {\n          children: l.map((V) =&gt; /* @__PURE__ */ q.jsx(aI, {\n            url: V.frames_url,\n            initialFrame: V,\n            onFrameBtnPress: A\n          }, V.frames_url))\n        }) : null, /* @__PURE__ */ q.jsxs(yI, {\n          style: {\n            justifyContent: f ? \"space-between\" : \"flex-end\"\n          },\n          children: [f &amp;&amp; /* @__PURE__ */ q.jsx(HA, {\n            hash: n,\n            reactions: i,\n            onComment: R,\n            onRecast: b,\n            onLike: O,\n            isLiked: $\n          }), f &amp;&amp; s &amp;&amp; n &amp;&amp; /* @__PURE__ */ q.jsx(Ic, {\n            url: `https://farcaster.xyz/${s}/${n.slice(0, 10)}`\n          })]\n        }), /* @__PURE__ */ q.jsxs(yf, {\n          style: {\n            justifyContent: f ? \"\" : \"space-between\",\n            marginTop: \"10px\"\n          },\n          children: [/* @__PURE__ */ q.jsxs(yf, {\n            style: {\n              justifyContent: f ? \"\" : \"space-between\",\n              gap: 6\n            },\n            children: [/* @__PURE__ */ q.jsxs(\"div\", {\n              style: {\n                display: \"flex\",\n                alignItems: \"center\",\n                gap: \"4px\",\n                color: \"#999999\"\n              },\n              children: [/* @__PURE__ */ q.jsx(tm, {}), o]\n            }), /* @__PURE__ */ q.jsx(\"div\", {\n              style: {\n                padding: \"0px 10px\"\n              }\n            }), /* @__PURE__ */ q.jsxs(\"div\", {\n              style: {\n                display: \"flex\",\n                alignItems: \"center\",\n                gap: \"4px\",\n                color: \"#999999\"\n              },\n              children: [/* @__PURE__ */ q.jsx(rm, {}), \" \", C]\n            }), c &amp;&amp; /* @__PURE__ */ q.jsxs(q.Fragment, {\n              children: [/* @__PURE__ */ q.jsx(\"div\", {}), /* @__PURE__ */ q.jsxs(dI, {\n                href: `https://farcaster.xyz/~/channel/${c.id}`,\n                target: \"_blank\",\n                children: [\"/\", c.id]\n              })]\n            })]\n          }), !f &amp;&amp; s &amp;&amp; n &amp;&amp; /* @__PURE__ */ q.jsx(Ic, {\n            url: `https://farcaster.xyz/${s}/${n.slice(0, 10)}`\n          })]\n        })]\n      })]\n    })\n  });\n}), EI = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"s1m6ob1a\"]\n}), vf = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"r1esevc7\"]\n}), Ef = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"vxb1f00\"]\n}), xI = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"htv0qz7\"]\n}), xf = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"rzksy2\"]\n});\nfunction SI(s) {\n  return /* @__PURE__ */ q.jsx(EI, {\n    children: s.casts.map((e, t) =&gt; /* @__PURE__ */ q.jsxs(vf, {\n      children: [t !== 0 &amp;&amp; /* @__PURE__ */ q.jsx(Ef, {\n        style: {\n          left: \"42px\"\n        }\n      }), /* @__PURE__ */ q.jsxs(xf, {\n        children: [/* @__PURE__ */ q.jsx(oa, {\n          isEmbed: !1,\n          ...e\n        }), t === 0 &amp;&amp; /* @__PURE__ */ q.jsx(xI, {}), e.direct_replies &amp;&amp; e.direct_replies.length &gt; 0 &amp;&amp; e.direct_replies.map((r, n) =&gt; /* @__PURE__ */ q.jsxs(vf, {\n          children: [/* @__PURE__ */ q.jsx(Ef, {\n            style: {\n              left: \"42px\"\n            }\n          }), /* @__PURE__ */ q.jsx(xf, {\n            children: /* @__PURE__ */ q.jsx(oa, {\n              isEmbed: !1,\n              ...r\n            })\n          })]\n        }, n))]\n      })]\n    }, t))\n  });\n}\nasync function bI({\n  type: s,\n  identifier: e,\n  replyDepth: t = 2,\n  includeChronologicalParentCasts: r = !1,\n  limit: n = 20,\n  viewerFid: i,\n  clientId: o\n}) {\n  try {\n    let a = `${on}/v2/farcaster/cast/conversation?identifier=${encodeURIComponent(e)}&amp;type=${s}&amp;reply_depth=${t}&amp;include_chronological_parent_casts=${r}&amp;limit=${n}&amp;client_id=${o}`;\n    return i &amp;&amp; (a += `&amp;viewer_fid=${i}`), await (await an(a, {\n      method: \"GET\",\n      headers: {\n        accept: \"application/json\"\n      }\n    })).json() || null;\n  } catch (a) {\n    return console.error(\"Error fetching conversation\", a), null;\n  }\n}\nfunction nm(s) {\n  return {\n    username: s.author.username,\n    displayName: s.author.display_name,\n    avatarImgUrl: s.author.pfp_url,\n    text: s.text,\n    hash: s.hash,\n    reactions: s.reactions,\n    replies: s.replies.count,\n    embeds: s.embeds,\n    frames: s.frames,\n    renderEmbeds: s.renderEmbeds,\n    channel: s.channel,\n    viewerFid: 2,\n    hasPowerBadge: s.author.power_badge,\n    appAvatarImgUrl: s.app.pfp_url,\n    isOwnProfile: !1,\n    allowReactions: !0,\n    renderFrames: !1,\n    direct_replies: s.direct_replies ? s.direct_replies.map(nm) : [],\n    timestamp: s.timestamp\n  };\n}\nfunction TI(s) {\n  const e = [];\n  return s.cast &amp;&amp; e.push(nm(s.cast)), e;\n}\nconst mR = ({\n  type: s,\n  identifier: e,\n  replyDepth: t = 2,\n  includeChronologicalParentCasts: r = !1,\n  limit: n = 20,\n  viewerFid: i\n}) =&gt; {\n  const {\n    client_id: o\n  } = ts(), [a, l] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null), [c, u] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(!0), [d, h] = react__WEBPACK_IMPORTED_MODULE_0___default().useState(null);\n  return react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(() =&gt; {\n    u(!0), h(null), bI({\n      type: s,\n      identifier: e,\n      replyDepth: t,\n      includeChronologicalParentCasts: r,\n      limit: n,\n      viewerFid: i,\n      clientId: o\n    }).then((f) =&gt; {\n      l(f);\n    }).catch((f) =&gt; {\n      h(f);\n    }).finally(() =&gt; {\n      u(!1);\n    });\n  }, [s, e, t, r, n, i, o]), c ? /* @__PURE__ */ q.jsx(q.Fragment, {\n    children: \" \"\n  }) : d ? /* @__PURE__ */ q.jsx(q.Fragment, {\n    children: \" \"\n  }) : /* @__PURE__ */ q.jsx(SI, {\n    casts: TI(a.conversation)\n  });\n};\nvar Ol = { exports: {} }, Bl = {};\n/**\n * @license React\n * use-sync-external-store-shim.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Sf;\nfunction wI() {\n  if (Sf) return Bl;\n  Sf = 1;\n  var s = (react__WEBPACK_IMPORTED_MODULE_0___default());\n  function e(d, h) {\n    return d === h &amp;&amp; (d !== 0 || 1 / d === 1 / h) || d !== d &amp;&amp; h !== h;\n  }\n  var t = typeof Object.is == \"function\" ? Object.is : e, r = s.useState, n = s.useEffect, i = s.useLayoutEffect, o = s.useDebugValue;\n  function a(d, h) {\n    var f = h(), p = r({ inst: { value: f, getSnapshot: h } }), y = p[0].inst, E = p[1];\n    return i(\n      function() {\n        y.value = f, y.getSnapshot = h, l(y) &amp;&amp; E({ inst: y });\n      },\n      [d, f, h]\n    ), n(\n      function() {\n        return l(y) &amp;&amp; E({ inst: y }), d(function() {\n          l(y) &amp;&amp; E({ inst: y });\n        });\n      },\n      [d]\n    ), o(f), f;\n  }\n  function l(d) {\n    var h = d.getSnapshot;\n    d = d.value;\n    try {\n      var f = h();\n      return !t(d, f);\n    } catch {\n      return !0;\n    }\n  }\n  function c(d, h) {\n    return h();\n  }\n  var u = typeof window &gt; \"u\" || typeof window.document &gt; \"u\" || typeof window.document.createElement &gt; \"u\" ? c : a;\n  return Bl.useSyncExternalStore = s.useSyncExternalStore !== void 0 ? s.useSyncExternalStore : u, Bl;\n}\nvar bf;\nfunction AI() {\n  return bf || (bf = 1, Ol.exports = wI()), Ol.exports;\n}\nvar im = AI();\nconst om = 0, am = 1, lm = 2, Tf = 3;\nvar wf = Object.prototype.hasOwnProperty;\nfunction _c(s, e) {\n  var t, r;\n  if (s === e) return !0;\n  if (s &amp;&amp; e &amp;&amp; (t = s.constructor) === e.constructor) {\n    if (t === Date) return s.getTime() === e.getTime();\n    if (t === RegExp) return s.toString() === e.toString();\n    if (t === Array) {\n      if ((r = s.length) === e.length)\n        for (; r-- &amp;&amp; _c(s[r], e[r]); ) ;\n      return r === -1;\n    }\n    if (!t || typeof s == \"object\") {\n      r = 0;\n      for (t in s)\n        if (wf.call(s, t) &amp;&amp; ++r &amp;&amp; !wf.call(e, t) || !(t in e) || !_c(s[t], e[t])) return !1;\n      return Object.keys(e).length === r;\n    }\n  }\n  return s !== s &amp;&amp; e !== e;\n}\nconst qr = /* @__PURE__ */ new WeakMap(), Cs = () =&gt; {\n}, qt = (\n  /*#__NOINLINE__*/\n  Cs()\n), Rc = Object, $e = (s) =&gt; s === qt, Mr = (s) =&gt; typeof s == \"function\", Bs = (s, e) =&gt; ({\n  ...s,\n  ...e\n}), cm = (s) =&gt; Mr(s.then), Fl = {}, oo = {}, Fu = \"undefined\", Pi = typeof window != Fu, Lc = typeof document != Fu, II = Pi &amp;&amp; \"Deno\" in window, _I = () =&gt; Pi &amp;&amp; typeof window.requestAnimationFrame != Fu, _s = (s, e) =&gt; {\n  const t = qr.get(s);\n  return [\n    // Getter\n    () =&gt; !$e(e) &amp;&amp; s.get(e) || Fl,\n    // Setter\n    (r) =&gt; {\n      if (!$e(e)) {\n        const n = s.get(e);\n        e in oo || (oo[e] = n), t[5](e, Bs(n, r), n || Fl);\n      }\n    },\n    // Subscriber\n    t[6],\n    // Get server cache snapshot\n    () =&gt; !$e(e) &amp;&amp; e in oo ? oo[e] : !$e(e) &amp;&amp; s.get(e) || Fl\n  ];\n};\nlet Cc = !0;\nconst RI = () =&gt; Cc, [kc, Dc] = Pi &amp;&amp; window.addEventListener ? [\n  window.addEventListener.bind(window),\n  window.removeEventListener.bind(window)\n] : [\n  Cs,\n  Cs\n], LI = () =&gt; {\n  const s = Lc &amp;&amp; document.visibilityState;\n  return $e(s) || s !== \"hidden\";\n}, CI = (s) =&gt; (Lc &amp;&amp; document.addEventListener(\"visibilitychange\", s), kc(\"focus\", s), () =&gt; {\n  Lc &amp;&amp; document.removeEventListener(\"visibilitychange\", s), Dc(\"focus\", s);\n}), kI = (s) =&gt; {\n  const e = () =&gt; {\n    Cc = !0, s();\n  }, t = () =&gt; {\n    Cc = !1;\n  };\n  return kc(\"online\", e), kc(\"offline\", t), () =&gt; {\n    Dc(\"online\", e), Dc(\"offline\", t);\n  };\n}, DI = {\n  isOnline: RI,\n  isVisible: LI\n}, PI = {\n  initFocus: CI,\n  initReconnect: kI\n}, Af = !(react__WEBPACK_IMPORTED_MODULE_0___default().useId), Ti = !Pi || II, MI = (s) =&gt; _I() ? window.requestAnimationFrame(s) : setTimeout(s, 1), So = Ti ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect, Nl = typeof navigator &lt; \"u\" &amp;&amp; navigator.connection, If = !Ti &amp;&amp; Nl &amp;&amp; ([\n  \"slow-2g\",\n  \"2g\"\n].includes(Nl.effectiveType) || Nl.saveData), ao = /* @__PURE__ */ new WeakMap(), OI = (s) =&gt; Rc.prototype.toString.call(s), Ul = (s, e) =&gt; s === `[object ${e}]`;\nlet BI = 0;\nconst Pc = (s) =&gt; {\n  const e = typeof s, t = OI(s), r = Ul(t, \"Date\"), n = Ul(t, \"RegExp\"), i = Ul(t, \"Object\");\n  let o, a;\n  if (Rc(s) === s &amp;&amp; !r &amp;&amp; !n) {\n    if (o = ao.get(s), o) return o;\n    if (o = ++BI + \"~\", ao.set(s, o), Array.isArray(s)) {\n      for (o = \"@\", a = 0; a &lt; s.length; a++)\n        o += Pc(s[a]) + \",\";\n      ao.set(s, o);\n    }\n    if (i) {\n      o = \"#\";\n      const l = Rc.keys(s).sort();\n      for (; !$e(a = l.pop()); )\n        $e(s[a]) || (o += a + \":\" + Pc(s[a]) + \",\");\n      ao.set(s, o);\n    }\n  } else\n    o = r ? s.toJSON() : e == \"symbol\" ? s.toString() : e == \"string\" ? JSON.stringify(s) : \"\" + s;\n  return o;\n}, wi = (s) =&gt; {\n  if (Mr(s))\n    try {\n      s = s();\n    } catch {\n      s = \"\";\n    }\n  const e = s;\n  return s = typeof s == \"string\" ? s : (Array.isArray(s) ? s.length : s) ? Pc(s) : \"\", [\n    s,\n    e\n  ];\n};\nlet FI = 0;\nconst Mc = () =&gt; ++FI;\nasync function um(...s) {\n  const [e, t, r, n] = s, i = Bs({\n    populateCache: !0,\n    throwOnError: !0\n  }, typeof n == \"boolean\" ? {\n    revalidate: n\n  } : n || {});\n  let o = i.populateCache;\n  const a = i.rollbackOnError;\n  let l = i.optimisticData;\n  const c = (h) =&gt; typeof a == \"function\" ? a(h) : a !== !1, u = i.throwOnError;\n  if (Mr(t)) {\n    const h = t, f = [], p = e.keys();\n    for (const y of p)\n      // Skip the special useSWRInfinite and useSWRSubscription keys.\n      !/^\\$(inf|sub)\\$/.test(y) &amp;&amp; h(e.get(y)._k) &amp;&amp; f.push(y);\n    return Promise.all(f.map(d));\n  }\n  return d(t);\n  async function d(h) {\n    const [f] = wi(h);\n    if (!f) return;\n    const [p, y] = _s(e, f), [E, b, R, A] = qr.get(e), F = () =&gt; {\n      const g = E[f];\n      return (Mr(i.revalidate) ? i.revalidate(p().data, h) : i.revalidate !== !1) &amp;&amp; (delete R[f], delete A[f], g &amp;&amp; g[0]) ? g[0](lm).then(() =&gt; p().data) : p().data;\n    };\n    if (s.length &lt; 3)\n      return F();\n    let M = r, H, K = !1;\n    const j = Mc();\n    b[f] = [\n      j,\n      0\n    ];\n    const C = !$e(l), k = p(), $ = k.data, W = k._c, _ = $e(W) ? $ : W;\n    if (C &amp;&amp; (l = Mr(l) ? l(_, $) : l, y({\n      data: l,\n      _c: _\n    })), Mr(M))\n      try {\n        M = M(_);\n      } catch (g) {\n        H = g, K = !0;\n      }\n    if (M &amp;&amp; cm(M))\n      if (M = await M.catch((g) =&gt; {\n        H = g, K = !0;\n      }), j !== b[f][0]) {\n        if (K) throw H;\n        return M;\n      } else K &amp;&amp; C &amp;&amp; c(H) &amp;&amp; (o = !0, y({\n        data: _,\n        _c: qt\n      }));\n    if (o &amp;&amp; !K)\n      if (Mr(o)) {\n        const g = o(M, _);\n        y({\n          data: g,\n          error: qt,\n          _c: qt\n        });\n      } else\n        y({\n          data: M,\n          error: qt,\n          _c: qt\n        });\n    if (b[f][1] = Mc(), Promise.resolve(F()).then(() =&gt; {\n      y({\n        _c: qt\n      });\n    }), K) {\n      if (u) throw H;\n      return;\n    }\n    return M;\n  }\n}\nconst _f = (s, e) =&gt; {\n  for (const t in s)\n    s[t][0] &amp;&amp; s[t][0](e);\n}, NI = (s, e) =&gt; {\n  if (!qr.has(s)) {\n    const t = Bs(PI, e), r = /* @__PURE__ */ Object.create(null), n = um.bind(qt, s);\n    let i = Cs;\n    const o = /* @__PURE__ */ Object.create(null), a = (u, d) =&gt; {\n      const h = o[u] || [];\n      return o[u] = h, h.push(d), () =&gt; h.splice(h.indexOf(d), 1);\n    }, l = (u, d, h) =&gt; {\n      s.set(u, d);\n      const f = o[u];\n      if (f)\n        for (const p of f)\n          p(d, h);\n    }, c = () =&gt; {\n      if (!qr.has(s) &amp;&amp; (qr.set(s, [\n        r,\n        /* @__PURE__ */ Object.create(null),\n        /* @__PURE__ */ Object.create(null),\n        /* @__PURE__ */ Object.create(null),\n        n,\n        l,\n        a\n      ]), !Ti)) {\n        const u = t.initFocus(setTimeout.bind(qt, _f.bind(qt, r, om))), d = t.initReconnect(setTimeout.bind(qt, _f.bind(qt, r, am)));\n        i = () =&gt; {\n          u &amp;&amp; u(), d &amp;&amp; d(), qr.delete(s);\n        };\n      }\n    };\n    return c(), [\n      s,\n      n,\n      c,\n      i\n    ];\n  }\n  return [\n    s,\n    qr.get(s)[4]\n  ];\n}, UI = (s, e, t, r, n) =&gt; {\n  const i = t.errorRetryCount, o = n.retryCount, a = ~~((Math.random() + 0.5) * (1 &lt;&lt; (o &lt; 8 ? o : 8))) * t.errorRetryInterval;\n  !$e(i) &amp;&amp; o &gt; i || setTimeout(r, a, n);\n}, $I = _c, [Nu, GI] = NI(/* @__PURE__ */ new Map()), VI = Bs(\n  {\n    // events\n    onLoadingSlow: Cs,\n    onSuccess: Cs,\n    onError: Cs,\n    onErrorRetry: UI,\n    onDiscarded: Cs,\n    // switches\n    revalidateOnFocus: !0,\n    revalidateOnReconnect: !0,\n    revalidateIfStale: !0,\n    shouldRetryOnError: !0,\n    // timeouts\n    errorRetryInterval: If ? 1e4 : 5e3,\n    focusThrottleInterval: 5 * 1e3,\n    dedupingInterval: 2 * 1e3,\n    loadingTimeout: If ? 5e3 : 3e3,\n    // providers\n    compare: $I,\n    isPaused: () =&gt; !1,\n    cache: Nu,\n    mutate: GI,\n    fallback: {}\n  },\n  // use web preset by default\n  DI\n), jI = (s, e) =&gt; {\n  const t = Bs(s, e);\n  if (e) {\n    const { use: r, fallback: n } = s, { use: i, fallback: o } = e;\n    r &amp;&amp; i &amp;&amp; (t.use = r.concat(i)), n &amp;&amp; o &amp;&amp; (t.fallback = Bs(n, o));\n  }\n  return t;\n}, KI = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({}), dm = \"$inf$\", hm = Pi &amp;&amp; window.__SWR_DEVTOOLS_USE__, HI = hm ? window.__SWR_DEVTOOLS_USE__ : [], qI = () =&gt; {\n  hm &amp;&amp; (window.__SWR_DEVTOOLS_REACT__ = (react__WEBPACK_IMPORTED_MODULE_0___default()));\n}, fm = (s) =&gt; Mr(s[1]) ? [\n  s[0],\n  s[1],\n  s[2] || {}\n] : [\n  s[0],\n  null,\n  (s[1] === null ? s[2] : s[1]) || {}\n], WI = () =&gt; {\n  const s = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(KI);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() =&gt; Bs(VI, s), [\n    s\n  ]);\n}, zI = (s) =&gt; (e, t, r) =&gt; s(e, t &amp;&amp; ((...i) =&gt; {\n  const [o] = wi(e), [, , , a] = qr.get(Nu);\n  if (o.startsWith(dm))\n    return t(...i);\n  const l = a[o];\n  return $e(l) ? t(...i) : (delete a[o], l);\n}), r), YI = HI.concat(zI), ZI = (s) =&gt; function(...t) {\n  const r = WI(), [n, i, o] = fm(t), a = jI(r, o);\n  let l = s;\n  const { use: c } = a, u = (c || []).concat(YI);\n  for (let d = u.length; d--; )\n    l = u[d](l);\n  return l(n, i || a.fetcher || null, a);\n}, XI = (s, e, t) =&gt; {\n  const r = e[s] || (e[s] = []);\n  return r.push(t), () =&gt; {\n    const n = r.indexOf(t);\n    n &gt;= 0 &amp;&amp; (r[n] = r[r.length - 1], r.pop());\n  };\n}, JI = (s, e) =&gt; (...t) =&gt; {\n  const [r, n, i] = fm(t), o = (i.use || []).concat(e);\n  return s(r, n, {\n    ...i,\n    use: o\n  });\n};\nqI();\nconst $l = (react__WEBPACK_IMPORTED_MODULE_0___default().use) || // This extra generic is to avoid TypeScript mixing up the generic and JSX sytax\n// and emitting an error.\n// We assume that this is only for the `use(thenable)` case, not `use(context)`.\n// https://github.com/facebook/react/blob/aed00dacfb79d17c53218404c52b1c7aa59c4a89/packages/react-server/src/ReactFizzThenable.js#L45\n((s) =&gt; {\n  switch (s.status) {\n    case \"pending\":\n      throw s;\n    case \"fulfilled\":\n      return s.value;\n    case \"rejected\":\n      throw s.reason;\n    default:\n      throw s.status = \"pending\", s.then((e) =&gt; {\n        s.status = \"fulfilled\", s.value = e;\n      }, (e) =&gt; {\n        s.status = \"rejected\", s.reason = e;\n      }), s;\n  }\n}), Gl = {\n  dedupe: !0\n}, Rf = Promise.resolve(qt), QI = (s, e, t) =&gt; {\n  const { cache: r, compare: n, suspense: i, fallbackData: o, revalidateOnMount: a, revalidateIfStale: l, refreshInterval: c, refreshWhenHidden: u, refreshWhenOffline: d, keepPreviousData: h } = t, [f, p, y, E] = qr.get(r), [b, R] = wi(s), A = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), F = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), M = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(b), H = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(e), K = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(t), j = () =&gt; K.current, C = () =&gt; j().isVisible() &amp;&amp; j().isOnline(), [k, $, W, _] = _s(r, b), g = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({}).current, x = $e(o) ? $e(t.fallback) ? qt : t.fallback[b] : o, w = (_e, xe) =&gt; {\n    for (const Be in g) {\n      const ye = Be;\n      if (ye === \"data\") {\n        if (!n(_e[ye], xe[ye]) &amp;&amp; (!$e(_e[ye]) || !n(N, xe[ye])))\n          return !1;\n      } else if (xe[ye] !== _e[ye])\n        return !1;\n    }\n    return !0;\n  }, D = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() =&gt; {\n    const _e = !b || !e ? !1 : $e(a) ? j().isPaused() || i ? !1 : l !== !1 : a, xe = (we) =&gt; {\n      const Ne = Bs(we);\n      return delete Ne._k, _e ? {\n        isValidating: !0,\n        isLoading: !0,\n        ...Ne\n      } : Ne;\n    }, Be = k(), ye = _(), be = xe(Be), Fe = Be === ye ? be : xe(ye);\n    let Xe = be;\n    return [\n      () =&gt; {\n        const we = xe(k());\n        return w(we, Xe) ? (Xe.data = we.data, Xe.isLoading = we.isLoading, Xe.isValidating = we.isValidating, Xe.error = we.error, Xe) : (Xe = we, we);\n      },\n      () =&gt; Fe\n    ];\n  }, [\n    r,\n    b\n  ]), O = im.useSyncExternalStore((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (_e) =&gt; W(b, (xe, Be) =&gt; {\n      w(Be, xe) || _e();\n    }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      r,\n      b\n    ]\n  ), D[0], D[1]), U = !A.current, V = f[b] &amp;&amp; f[b].length &gt; 0, L = O.data, m = $e(L) ? x &amp;&amp; cm(x) ? $l(x) : x : L, v = O.error, P = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(m), N = h ? $e(L) ? $e(P.current) ? m : P.current : L : m, Y = V &amp;&amp; !$e(v) ? !1 : U &amp;&amp; !$e(a) ? a : j().isPaused() ? !1 : i ? $e(m) ? !1 : l : $e(m) || l, ee = !!(b &amp;&amp; e &amp;&amp; U &amp;&amp; Y), ie = $e(O.isValidating) ? ee : O.isValidating, le = $e(O.isLoading) ? ee : O.isLoading, Te = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (_e) =&gt; {\n      const xe = H.current;\n      if (!b || !xe || F.current || j().isPaused())\n        return !1;\n      let Be, ye, be = !0;\n      const Fe = _e || {}, Xe = !y[b] || !Fe.dedupe, we = () =&gt; Af ? !F.current &amp;&amp; b === M.current &amp;&amp; A.current : b === M.current, Ne = {\n        isValidating: !1,\n        isLoading: !1\n      }, dt = () =&gt; {\n        $(Ne);\n      }, Je = () =&gt; {\n        const it = y[b];\n        it &amp;&amp; it[1] === ye &amp;&amp; delete y[b];\n      }, Qe = {\n        isValidating: !0\n      };\n      $e(k().data) &amp;&amp; (Qe.isLoading = !0);\n      try {\n        if (Xe &amp;&amp; ($(Qe), t.loadingTimeout &amp;&amp; $e(k().data) &amp;&amp; setTimeout(() =&gt; {\n          be &amp;&amp; we() &amp;&amp; j().onLoadingSlow(b, t);\n        }, t.loadingTimeout), y[b] = [\n          xe(R),\n          Mc()\n        ]), [Be, ye] = y[b], Be = await Be, Xe &amp;&amp; setTimeout(Je, t.dedupingInterval), !y[b] || y[b][1] !== ye)\n          return Xe &amp;&amp; we() &amp;&amp; j().onDiscarded(b), !1;\n        Ne.error = qt;\n        const it = p[b];\n        if (!$e(it) &amp;&amp; // case 1\n        (ye &lt;= it[0] || // case 2\n        ye &lt;= it[1] || // case 3\n        it[1] === 0))\n          return dt(), Xe &amp;&amp; we() &amp;&amp; j().onDiscarded(b), !1;\n        const je = k().data;\n        Ne.data = n(je, Be) ? je : Be, Xe &amp;&amp; we() &amp;&amp; j().onSuccess(Be, b, t);\n      } catch (it) {\n        Je();\n        const je = j(), { shouldRetryOnError: B } = je;\n        je.isPaused() || (Ne.error = it, Xe &amp;&amp; we() &amp;&amp; (je.onError(it, b, je), (B === !0 || Mr(B) &amp;&amp; B(it)) &amp;&amp; (!j().revalidateOnFocus || !j().revalidateOnReconnect || C()) &amp;&amp; je.onErrorRetry(it, b, je, (S) =&gt; {\n          const T = f[b];\n          T &amp;&amp; T[0] &amp;&amp; T[0](Tf, S);\n        }, {\n          retryCount: (Fe.retryCount || 0) + 1,\n          dedupe: !0\n        })));\n      }\n      return be = !1, dt(), !0;\n    },\n    // `setState` is immutable, and `eventsCallback`, `fnArg`, and\n    // `keyValidating` are depending on `key`, so we can exclude them from\n    // the deps array.\n    //\n    // FIXME:\n    // `fn` and `config` might be changed during the lifecycle,\n    // but they might be changed every render like this.\n    // `useSWR('key', () =&gt; fetch('/api/'), { suspense: true })`\n    // So we omit the values from the deps array\n    // even though it might cause unexpected behaviors.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      b,\n      r\n    ]\n  ), De = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    // Use callback to make sure `keyRef.current` returns latest result every time\n    (..._e) =&gt; um(r, M.current, ..._e),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    []\n  );\n  if (So(() =&gt; {\n    H.current = e, K.current = t, $e(L) || (P.current = L);\n  }), So(() =&gt; {\n    if (!b) return;\n    const _e = Te.bind(qt, Gl);\n    let xe = 0;\n    j().revalidateOnFocus &amp;&amp; (xe = Date.now() + j().focusThrottleInterval);\n    const ye = XI(b, f, (be, Fe = {}) =&gt; {\n      if (be == om) {\n        const Xe = Date.now();\n        j().revalidateOnFocus &amp;&amp; Xe &gt; xe &amp;&amp; C() &amp;&amp; (xe = Xe + j().focusThrottleInterval, _e());\n      } else if (be == am)\n        j().revalidateOnReconnect &amp;&amp; C() &amp;&amp; _e();\n      else {\n        if (be == lm)\n          return Te();\n        if (be == Tf)\n          return Te(Fe);\n      }\n    });\n    return F.current = !1, M.current = b, A.current = !0, $({\n      _k: R\n    }), Y &amp;&amp; (y[b] || ($e(m) || Ti ? _e() : MI(_e))), () =&gt; {\n      F.current = !0, ye();\n    };\n  }, [\n    b\n  ]), So(() =&gt; {\n    let _e;\n    function xe() {\n      const ye = Mr(c) ? c(k().data) : c;\n      ye &amp;&amp; _e !== -1 &amp;&amp; (_e = setTimeout(Be, ye));\n    }\n    function Be() {\n      !k().error &amp;&amp; (u || j().isVisible()) &amp;&amp; (d || j().isOnline()) ? Te(Gl).then(xe) : xe();\n    }\n    return xe(), () =&gt; {\n      _e &amp;&amp; (clearTimeout(_e), _e = -1);\n    };\n  }, [\n    c,\n    u,\n    d,\n    b\n  ]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(N), i) {\n    const _e = b &amp;&amp; $e(m);\n    if (!Af &amp;&amp; Ti &amp;&amp; _e)\n      throw new Error(\"Fallback data is required when using Suspense in SSR.\");\n    _e &amp;&amp; (H.current = e, K.current = t, F.current = !1);\n    const xe = E[b], Be = !$e(xe) &amp;&amp; _e ? De(xe) : Rf;\n    if ($l(Be), !$e(v) &amp;&amp; _e)\n      throw v;\n    const ye = _e ? Te(Gl) : Rf;\n    !$e(N) &amp;&amp; _e &amp;&amp; (ye.status = \"fulfilled\", ye.value = !0), $l(ye);\n  }\n  return {\n    mutate: De,\n    get data() {\n      return g.data = !0, N;\n    },\n    get error() {\n      return g.error = !0, v;\n    },\n    get isValidating() {\n      return g.isValidating = !0, ie;\n    },\n    get isLoading() {\n      return g.isLoading = !0, le;\n    }\n  };\n}, e_ = ZI(QI), t_ = () =&gt; {\n}, r_ = (\n  /*#__NOINLINE__*/\n  t_()\n), Oc = Object, Lf = (s) =&gt; s === r_, s_ = (s) =&gt; typeof s == \"function\", lo = /* @__PURE__ */ new WeakMap(), n_ = (s) =&gt; Oc.prototype.toString.call(s), Vl = (s, e) =&gt; s === `[object ${e}]`;\nlet i_ = 0;\nconst Bc = (s) =&gt; {\n  const e = typeof s, t = n_(s), r = Vl(t, \"Date\"), n = Vl(t, \"RegExp\"), i = Vl(t, \"Object\");\n  let o, a;\n  if (Oc(s) === s &amp;&amp; !r &amp;&amp; !n) {\n    if (o = lo.get(s), o) return o;\n    if (o = ++i_ + \"~\", lo.set(s, o), Array.isArray(s)) {\n      for (o = \"@\", a = 0; a &lt; s.length; a++)\n        o += Bc(s[a]) + \",\";\n      lo.set(s, o);\n    }\n    if (i) {\n      o = \"#\";\n      const l = Oc.keys(s).sort();\n      for (; !Lf(a = l.pop()); )\n        Lf(s[a]) || (o += a + \":\" + Bc(s[a]) + \",\");\n      lo.set(s, o);\n    }\n  } else\n    o = r ? s.toJSON() : e == \"symbol\" ? s.toString() : e == \"string\" ? JSON.stringify(s) : \"\" + s;\n  return o;\n}, o_ = (s) =&gt; {\n  if (s_(s))\n    try {\n      s = s();\n    } catch {\n      s = \"\";\n    }\n  const e = s;\n  return s = typeof s == \"string\" ? s : (Array.isArray(s) ? s.length : s) ? Bc(s) : \"\", [\n    s,\n    e\n  ];\n}, a_ = (s) =&gt; o_(s ? s(0, null) : null)[0], jl = Promise.resolve(), l_ = (s) =&gt; (e, t, r) =&gt; {\n  const n = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(!1), { cache: i, initialSize: o = 1, revalidateAll: a = !1, persistSize: l = !1, revalidateFirstPage: c = !0, revalidateOnMount: u = !1, parallel: d = !1 } = r, [, , , h] = qr.get(Nu);\n  let f;\n  try {\n    f = a_(e), f &amp;&amp; (f = dm + f);\n  } catch {\n  }\n  const [p, y, E] = _s(i, f), b = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() =&gt; $e(p()._l) ? o : p()._l, [\n    i,\n    f,\n    o\n  ]);\n  im.useSyncExternalStore((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (j) =&gt; f ? E(f, () =&gt; {\n      j();\n    }) : () =&gt; {\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      i,\n      f\n    ]\n  ), b, b);\n  const R = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() =&gt; {\n    const j = p()._l;\n    return $e(j) ? o : j;\n  }, [\n    f,\n    o\n  ]), A = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(R());\n  So(() =&gt; {\n    if (!n.current) {\n      n.current = !0;\n      return;\n    }\n    f &amp;&amp; y({\n      _l: l ? A.current : R()\n    });\n  }, [\n    f,\n    i\n  ]);\n  const F = u &amp;&amp; !n.current, M = s(f, async (j) =&gt; {\n    const C = p()._i, k = p()._r;\n    y({\n      _r: qt\n    });\n    const $ = [], W = R(), [_] = _s(i, j), g = _().data, x = [];\n    let w = null;\n    for (let D = 0; D &lt; W; ++D) {\n      const [O, U] = wi(e(D, d ? null : w));\n      if (!O)\n        break;\n      const [V, L] = _s(i, O);\n      let m = V().data;\n      const v = a || C || $e(m) || c &amp;&amp; !D &amp;&amp; !$e(g) || F || g &amp;&amp; !$e(g[D]) &amp;&amp; !r.compare(g[D], m);\n      if (t &amp;&amp; (typeof k == \"function\" ? k(m, U) : v)) {\n        const P = async () =&gt; {\n          if (!(O in h))\n            m = await t(U);\n          else {\n            const Y = h[O];\n            delete h[O], m = await Y;\n          }\n          L({\n            data: m,\n            _k: U\n          }), $[D] = m;\n        };\n        d ? x.push(P) : await P();\n      } else\n        $[D] = m;\n      d || (w = m);\n    }\n    return d &amp;&amp; await Promise.all(x.map((D) =&gt; D())), y({\n      _i: qt\n    }), $;\n  }, r), H = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    // eslint-disable-next-line func-names\n    function(j, C) {\n      const k = typeof C == \"boolean\" ? {\n        revalidate: C\n      } : C || {}, $ = k.revalidate !== !1;\n      return f ? ($ &amp;&amp; ($e(j) ? y({\n        _i: !0,\n        _r: k.revalidate\n      }) : y({\n        _i: !1,\n        _r: k.revalidate\n      })), arguments.length ? M.mutate(j, {\n        ...k,\n        revalidate: $\n      }) : M.mutate()) : jl;\n    },\n    // swr.mutate is always the same reference\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      f,\n      i\n    ]\n  ), K = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (j) =&gt; {\n      if (!f) return jl;\n      const [, C] = _s(i, f);\n      let k;\n      if (Mr(j) ? k = j(R()) : typeof j == \"number\" &amp;&amp; (k = j), typeof k != \"number\") return jl;\n      C({\n        _l: k\n      }), A.current = k;\n      const $ = [], [W] = _s(i, f);\n      let _ = null;\n      for (let g = 0; g &lt; k; ++g) {\n        const [x] = wi(e(g, _)), [w] = _s(i, x), D = x ? w().data : qt;\n        if ($e(D))\n          return H(W().data);\n        $.push(D), _ = D;\n      }\n      return H($);\n    },\n    // exclude getKey from the dependencies, which isn't allowed to change during the lifecycle\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      f,\n      i,\n      H,\n      R\n    ]\n  );\n  return {\n    size: R(),\n    setSize: K,\n    mutate: H,\n    get data() {\n      return M.data;\n    },\n    get error() {\n      return M.error;\n    },\n    get isValidating() {\n      return M.isValidating;\n    },\n    get isLoading() {\n      return M.isLoading;\n    }\n  };\n}, c_ = JI(e_, l_), u_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"sfmkqcr\"]\n}), d_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"hrldtio\"]\n}), h_ = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({\n  casts: s,\n  cursor: e\n}) =&gt; /* @__PURE__ */ q.jsx(u_, {\n  children: s.map((t, r) =&gt; /* @__PURE__ */ q.jsxs((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), {\n    children: [/* @__PURE__ */ q.jsx(oa, {\n      isEmbed: !1,\n      ...t\n    }), r &lt; s.length - 1 &amp;&amp; /* @__PURE__ */ q.jsx(d_, {})]\n  }, t.hash))\n}));\nfunction f_(s) {\n  return s ? s.map((e) =&gt; {\n    var r, n, i, o, a;\n    const t = e != null &amp;&amp; e.replies &amp;&amp; typeof e.replies == \"object\" ? Number(e.replies.count) || 0 : Number(e == null ? void 0 : e.replies) || 0;\n    return {\n      username: ((r = e == null ? void 0 : e.author) == null ? void 0 : r.username) ?? \"\",\n      displayName: ((n = e == null ? void 0 : e.author) == null ? void 0 : n.display_name) ?? \"\",\n      avatarImgUrl: ((i = e == null ? void 0 : e.author) == null ? void 0 : i.pfp_url) ?? \"\",\n      text: (e == null ? void 0 : e.text) ?? \"\",\n      hash: (e == null ? void 0 : e.hash) ?? \"\",\n      reactions: (e == null ? void 0 : e.reactions) ?? [],\n      replies: t,\n      embeds: (e == null ? void 0 : e.embeds) ?? [],\n      frames: (e == null ? void 0 : e.frames) ?? [],\n      renderEmbeds: (e == null ? void 0 : e.renderEmbeds) ?? !0,\n      channel: (e == null ? void 0 : e.channel) ?? \"\",\n      viewerFid: 2,\n      hasPowerBadge: ((o = e == null ? void 0 : e.author) == null ? void 0 : o.power_badge) ?? !1,\n      appAvatarImgUrl: ((a = e == null ? void 0 : e.app) == null ? void 0 : a.pfp_url) ?? \"\",\n      isOwnProfile: !1,\n      allowReactions: !0,\n      renderFrames: !1,\n      timestamp: e.timestamp ?? \"\"\n    };\n  }) : [];\n}\nconst g_ = (s) =&gt; an(s).then(async (e) =&gt; await e.json()), p_ = (s, e, t, r, n) =&gt; {\n  if (e &amp;&amp; (!e.casts || !e.casts.length)) return null;\n  let i = `${on}/v2/farcaster/feed${t ? \"\" : \"?\"}`;\n  const o = new URLSearchParams();\n  t &amp;&amp; (i += `${t}?`), n &amp;&amp; (i += `client_id=${n}`), e &amp;&amp; (i += `&amp;cursor=${e.next.cursor}`);\n  const a = (l, c) =&gt; {\n    c != null &amp;&amp; !i.includes(`${l}=`) &amp;&amp; o.append(l, String(c));\n  };\n  if (r) {\n    Object.entries(r).forEach(([c, u]) =&gt; {\n      const d = c.replace(/([a-z])([A-Z])/g, \"$1_$2\").toLowerCase();\n      a(d, u);\n    });\n    const l = o.toString();\n    l &amp;&amp; (i += i.includes(\"?\") ? `&amp;${l}` : `?${l}`);\n  }\n  if (Object.keys(r).length &gt; 1)\n    return i;\n}, yR = ({\n  path: s,\n  ...e\n}) =&gt; {\n  var f;\n  const {\n    client_id: t\n  } = ts(), r = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), [n, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), o = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null), {\n    data: a,\n    error: l,\n    size: c,\n    setSize: u,\n    isValidating: d\n  } = c_((p, y) =&gt; p_(p, y, s, e, t), g_), h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() =&gt; {\n    if (!a) return [];\n    const p = a.flatMap((E) =&gt; (E == null ? void 0 : E.casts) ?? []), y = Array.from(new Set(p.map((E) =&gt; E.hash))).map((E) =&gt; p.find((b) =&gt; b.hash === E));\n    return f_(y);\n  }, [a]);\n  return (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; (o.current &amp;&amp; o.current.disconnect(), o.current = new IntersectionObserver((p) =&gt; {\n    var E, b;\n    const [y] = p;\n    y.isIntersecting &amp;&amp; !n &amp;&amp; !d &amp;&amp; a &amp;&amp; ((b = (E = a[a.length - 1]) == null ? void 0 : E.next) != null &amp;&amp; b.cursor) &amp;&amp; (i(!0), u(c + 1).then(() =&gt; i(!1)));\n  }, {\n    rootMargin: \"100px\"\n  }), r.current &amp;&amp; o.current.observe(r.current), () =&gt; {\n    o.current &amp;&amp; o.current.disconnect();\n  }), [r.current, n, d, a, c]), l ? /* @__PURE__ */ q.jsx(\"div\", {\n    children: \"Error fetching feed data\"\n  }) : /* @__PURE__ */ q.jsxs(\"div\", {\n    children: [h.length !== 0 ? /* @__PURE__ */ q.jsx(h_, {\n      casts: h,\n      cursor: \"\"\n    }) : /* @__PURE__ */ q.jsx(\"div\", {\n      children: (f = a == null ? void 0 : a[0]) == null ? void 0 : f.message\n    }), d &amp;&amp; /* @__PURE__ */ q.jsxs(\"div\", {\n      style: {\n        display: \"flex\",\n        justifyContent: \"center\",\n        padding: \"10px\"\n      },\n      children: [/* @__PURE__ */ q.jsxs(\"span\", {\n        style: {\n          animation: \"blink 1.5s infinite\"\n        },\n        children: [\"Loading\", /* @__PURE__ */ q.jsx(\"span\", {\n          className: \"dots\",\n          children: \"...\"\n        })]\n      }), /* @__PURE__ */ q.jsx(\"style\", {\n        children: `\n                        @keyframes blink {\n                            0% { opacity: 1; }\n                            50% { opacity: 0; }\n                            100% { opacity: 1; }\n                        }\n                    `\n      })]\n    }), /* @__PURE__ */ q.jsx(\"div\", {\n      ref: r\n    })]\n  });\n}, m_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"button\")({\n  classes: [\"b1bqug8r\"]\n}), y_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"button\")({\n  classes: [\"b1mra45w\"]\n}), Cf = \"https://farcaster.xyz\", gm = /(^|\\s)\\/\\w+/g, pm = /@\\w+/g, mm = /((https?:\\/\\/)?([a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})(\\/[^\\s]*)?)/g, kf = new RegExp(`(${gm.source})|(${pm.source})|(${mm.source})`, \"g\"), v_ = (s) =&gt; gm.test(s) ? `${Cf}/~/channel${s.trim()}` : pm.test(s) ? `${Cf}/${s.substring(1)}` : mm.test(s) ? s.startsWith(\"http\") ? s : `http://${s}` : \"\", E_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"a\")({\n  classes: [\"sby9wa2\"]\n}), x_ = (s) =&gt; {\n  if (!s) return [];\n  const e = [];\n  let t = 0, r;\n  for (; (r = kf.exec(s)) !== null; ) {\n    const n = r.index;\n    t &lt; n &amp;&amp; e.push(s.slice(t, n));\n    const i = v_(r[0]), o = r[0].trim().startsWith(\"/\");\n    e.push(/* @__PURE__ */ q.jsx(\"span\", {\n      children: /* @__PURE__ */ q.jsx(E_, {\n        href: i,\n        target: \"_blank\",\n        style: o ? {\n          marginLeft: 3.5\n        } : {},\n        children: r[0]\n      }, n)\n    })), t = kf.lastIndex;\n  }\n  return t &lt; s.length &amp;&amp; e.push(s.slice(t)), e;\n}, S_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"sdahm58\"]\n}), b_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"mziqyxp\"]\n}), T_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"uz7tpmf\"]\n}), w_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"d1rxlwac\"]\n}), A_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"ugc6yqp\"]\n}), Df = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"porjf9a\"]\n}), I_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"ttt7x9x\"]\n}), Pf = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"b1wbe9o6\"]\n}), __ = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(({\n  fid: s,\n  username: e,\n  displayName: t,\n  avatarImgUrl: r,\n  bio: n,\n  followers: i,\n  following: o,\n  hasPowerBadge: a,\n  isFollowing: l,\n  isOwnProfile: c,\n  onCast: u,\n  containerStyles: d\n}) =&gt; {\n  const h = x_(n), f = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() =&gt; pf(o), [o]), p = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() =&gt; pf(i), [i]), y = () =&gt; {\n    window.open(\"https://farcaster.xyz/~/settings\", \"_blank\");\n  }, E = {\n    color: d == null ? void 0 : d.color\n  };\n  return /* @__PURE__ */ q.jsxs(S_, {\n    style: d,\n    children: [c &amp;&amp; u &amp;&amp; /* @__PURE__ */ q.jsxs(Pr, {\n      alignItems: \"center\",\n      justifyContent: \"space-between\",\n      spacingBottom: \"20px\",\n      children: [/* @__PURE__ */ q.jsxs(A_, {\n        children: [\"@\", e]\n      }), /* @__PURE__ */ q.jsx(m_, {\n        onClick: u,\n        children: \"Cast\"\n      })]\n    }), /* @__PURE__ */ q.jsx(Pr, {\n      children: /* @__PURE__ */ q.jsxs(b_, {\n        children: [/* @__PURE__ */ q.jsxs(Pr, {\n          alignItems: \"center\",\n          flexGrow: 1,\n          style: {\n            gap: \"10px\"\n          },\n          children: [/* @__PURE__ */ q.jsx(Ir, {\n            children: /* @__PURE__ */ q.jsx(Yo, {\n              width: \"20px\",\n              height: \"20px\",\n              src: r ?? bi,\n              loading: \"lazy\",\n              alt: `${t ?? \"Skeleton\"} Avatar`\n            })\n          }), /* @__PURE__ */ q.jsx(Pr, {\n            children: /* @__PURE__ */ q.jsx(w_, {\n              children: t || `!${s}`\n            })\n          }), /* @__PURE__ */ q.jsxs(Pr, {\n            alignItems: \"center\",\n            children: [/* @__PURE__ */ q.jsxs(T_, {\n              children: [\"@\", e]\n            }), l &amp;&amp; /* @__PURE__ */ q.jsx(I_, {\n              children: \"Follows you\"\n            })]\n          }), /* @__PURE__ */ q.jsx(Pr, {\n            children: c &amp;&amp; /* @__PURE__ */ q.jsx(y_, {\n              onClick: y,\n              children: \"Edit Profile\"\n            })\n          })]\n        }), (h == null ? void 0 : h.length) !== 0 ? /* @__PURE__ */ q.jsx(Pf, {\n          children: h\n        }) : /* @__PURE__ */ q.jsx(Pf, {\n          style: {\n            padding: \"26px 0px\"\n          }\n        }), /* @__PURE__ */ q.jsxs(Pr, {\n          style: {\n            justifyContent: \"space-between\",\n            display: \"flex\",\n            alignItems: \"center\"\n          },\n          children: [/* @__PURE__ */ q.jsxs(Df, {\n            children: [/* @__PURE__ */ q.jsx(\"strong\", {\n              style: E,\n              children: f\n            }), \" \", \"Following\"]\n          }), /* @__PURE__ */ q.jsxs(Df, {\n            children: [/* @__PURE__ */ q.jsx(\"strong\", {\n              style: E,\n              children: p\n            }), \" \", \"Followers\"]\n          }), e &amp;&amp; /* @__PURE__ */ q.jsx(Ir, {\n            style: {\n              marginLeft: \"auto\"\n            },\n            children: /* @__PURE__ */ q.jsx(Ic, {\n              url: `https://farcaster.xyz/${e}`\n            })\n          })]\n        })]\n      })\n    })]\n  });\n});\nasync function R_({\n  fid: s,\n  viewerFid: e,\n  clientId: t\n}) {\n  var r;\n  try {\n    let n = `${on}/v2/farcaster/user/bulk?client_id=${t}&amp;fids=${s}`;\n    e &amp;&amp; (n += `&amp;viewer_fid=${e}`);\n    const o = await (await an(n)).json();\n    return ((r = o == null ? void 0 : o.users) == null ? void 0 : r[0]) ?? null;\n  } catch (n) {\n    return console.error(\"Error fetching user by fid\", n), null;\n  }\n}\nconst vR = ({\n  fid: s,\n  viewerFid: e,\n  containerStyles: t\n}) =&gt; {\n  var h;\n  const {\n    client_id: r\n  } = ts(), [n, i] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), [o, a] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!0), [l, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), u = (n == null ? void 0 : n.fid) === e;\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    s &amp;&amp; (a(!0), c(null), R_({\n      fid: s,\n      viewerFid: e,\n      clientId: r\n    }).then((f) =&gt; {\n      i(f);\n    }).catch((f) =&gt; {\n      c(f);\n    }).finally(() =&gt; {\n      a(!1);\n    }));\n  }, [s, e]);\n  const d = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() =&gt; {\n  }, []);\n  return o ? /* @__PURE__ */ q.jsx(\"div\", {\n    style: {\n      padding: \"20px\"\n    },\n    children: \"Loading...\"\n  }) : !n || l ? /* @__PURE__ */ q.jsx(\"div\", {\n    children: \"Error fetching user data\"\n  }) : /* @__PURE__ */ q.jsx(__, {\n    fid: s,\n    username: n.username,\n    displayName: n.display_name,\n    avatarImgUrl: n.pfp_url,\n    bio: n.profile.bio.text,\n    followers: n.follower_count,\n    following: n.following_count,\n    hasPowerBadge: n.power_badge,\n    isOwnProfile: u,\n    isFollowing: (h = n.viewer_context) == null ? void 0 : h.followed_by,\n    onCast: d,\n    containerStyles: t\n  });\n}, L_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"ul\")({\n  classes: [\"d12rx4om\"]\n}), C_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"li\")({\n  classes: [\"lrpm6lp\"]\n}), k_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"img\")({\n  classes: [\"a1e9hg3b\"]\n}), D_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"u1aqay1i\"]\n}), P_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"d1m0njq\"]\n}), M_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"u1lvlbuo\"]\n}), O_ = ({\n  users: s,\n  onSelect: e,\n  customStyles: t = {}\n}) =&gt; /* @__PURE__ */ q.jsx(L_, {\n  style: {\n    ...t == null ? void 0 : t.dropdown\n  },\n  children: s.map((r) =&gt; /* @__PURE__ */ q.jsxs(C_, {\n    style: {\n      ...t == null ? void 0 : t.listItem\n    },\n    onClick: () =&gt; e(r),\n    children: [/* @__PURE__ */ q.jsx(k_, {\n      style: {\n        ...t == null ? void 0 : t.avatar\n      },\n      src: r.pfp_url,\n      alt: r.username\n    }), /* @__PURE__ */ q.jsxs(D_, {\n      style: {\n        ...t.userInfo\n      },\n      children: [/* @__PURE__ */ q.jsx(P_, {\n        children: r.display_name\n      }), /* @__PURE__ */ q.jsxs(M_, {\n        children: [\"@\", r.username]\n      })]\n    })]\n  }, r.fid))\n}), B_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"c9hm20t\"]\n}), F_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"input\")({\n  classes: [\"i80sd8h\"]\n});\nasync function N_({\n  q: s,\n  viewerFid: e,\n  client_id: t\n}) {\n  var r;\n  try {\n    let n = `${on}/v2/farcaster/user/search?q=${s}&amp;limit=5${e ? `&amp;viewer_fid=${e}` : \"\"}&amp;client_id=${t}`;\n    const o = await (await an(n)).json();\n    return ((r = o == null ? void 0 : o.result) == null ? void 0 : r.users) || [];\n  } catch {\n    return null;\n  }\n}\nconst ER = ({\n  value: s,\n  onChange: e,\n  style: t = {},\n  placeholder: r = \"Enter username\",\n  disabled: n = !1,\n  viewerFid: i,\n  customStyles: o = {},\n  limit: a = null\n}) =&gt; {\n  const {\n    client_id: l\n  } = ts(), [c, u] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\"), [d, h] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), [f, p] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), y = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    const M = (s == null ? void 0 : s.split(\",\")) || [];\n    if (!M[M.length - 1]) {\n      u(\"\");\n      return;\n    }\n    u(M[M.length - 1].trim());\n  }, [s]), (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    c !== \"\" &amp;&amp; !/^\\d+$/.test(c) ? E(c) : h(!1);\n  }, [c]);\n  const E = async (M) =&gt; {\n    const H = await N_({\n      q: M,\n      viewerFid: i,\n      client_id: l\n    });\n    H &amp;&amp; (p(H), h(!0));\n  }, b = (M) =&gt; {\n    const H = M.target.value;\n    e(H);\n  }, R = (M) =&gt; {\n    let H = s.split(\",\");\n    a !== null &amp;&amp; H.length &gt;= a ? H[H.length - 1] = M.fid.toString() : H.push(M.fid.toString());\n    const K = H.join(\",\");\n    e(K), u(\"\"), h(!1);\n  }, A = () =&gt; {\n    c &amp;&amp; isNaN(Number(c)) &amp;&amp; h(!0);\n  }, F = () =&gt; {\n    setTimeout(() =&gt; h(!1), 200);\n  };\n  return /* @__PURE__ */ q.jsxs(B_, {\n    style: t,\n    children: [/* @__PURE__ */ q.jsx(F_, {\n      ref: y,\n      type: \"text\",\n      value: s,\n      onChange: b,\n      onFocus: A,\n      onBlur: F,\n      placeholder: r,\n      disabled: n\n    }), d &amp;&amp; /* @__PURE__ */ q.jsx(O_, {\n      users: f,\n      onSelect: R,\n      customStyles: o\n    })]\n  });\n}, U_ = ({\n  color: s = \"#855DCD\"\n}) =&gt; /* @__PURE__ */ q.jsxs(\"svg\", {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  width: \"24\",\n  height: \"24\",\n  viewBox: \"0 0 24 24\",\n  fill: \"none\",\n  stroke: s,\n  \"stroke-width\": \"2\",\n  \"stroke-linecap\": \"round\",\n  \"stroke-linejoin\": \"round\",\n  className: \"lucide lucide-search\",\n  children: [/* @__PURE__ */ q.jsx(\"circle\", {\n    cx: \"11\",\n    cy: \"11\",\n    r: \"8\"\n  }), /* @__PURE__ */ q.jsx(\"path\", {\n    d: \"m21 21-4.3-4.3\"\n  })]\n}), $_ = ({\n  color: s = \"#855DCD\"\n}) =&gt; /* @__PURE__ */ q.jsx(\"svg\", {\n  xmlns: \"http://www.w3.org/2000/svg\",\n  width: \"24\",\n  height: \"24\",\n  viewBox: \"0 0 24 24\",\n  fill: \"none\",\n  stroke: s,\n  \"stroke-width\": \"2\",\n  \"stroke-linecap\": \"round\",\n  \"stroke-linejoin\": \"round\",\n  className: \"lucide lucide-loader-circle\",\n  children: /* @__PURE__ */ q.jsx(\"path\", {\n    d: \"M21 12a9 9 0 1 1-6.219-8.56\"\n  })\n}), G_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"ig7kcuc\"]\n}), V_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"input\")({\n  classes: [\"sh7z7k6\"]\n}), j_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"s14ai203\"]\n}), K_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"if18nd6\"]\n}), H_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"sd833lb\"]\n}), q_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"ugo586m\"]\n}), W_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"ukwty1d\"]\n}), z_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"u77olmy\"]\n}), Y_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"s1xvkxww\"]\n}), Z_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"s1f6b1ja\"]\n}), X_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"udiufd8\"]\n}), J_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"f1b8a2h0\"]\n}), Q_ = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"div\")({\n  classes: [\"l1yq26j0\"]\n}), eR = /* @__PURE__ */ (0,_pigment_css_react__WEBPACK_IMPORTED_MODULE_1__.styled)(\"li\")({\n  classes: [\"s18mk47k\"]\n}), xR = ({\n  width: s,\n  height: e,\n  selectedUsers: t,\n  onSelectUsers: r,\n  ...n\n}) =&gt; {\n  const {\n    client_id: i\n  } = ts(), {\n    user: o,\n    isAuthenticated: a\n  } = Eg(), [l, c] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\"), [u, d] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]), [h, f] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(!1), p = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() =&gt; {\n    function M(H) {\n      p.current &amp;&amp; !p.current.contains(H.target) &amp;&amp; (d([]), c(\"\"));\n    }\n    return document.addEventListener(\"mousedown\", M), () =&gt; {\n      document.removeEventListener(\"mousedown\", M);\n    };\n  }, []);\n  const b = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(((M, H) =&gt; {\n    let K;\n    return (...j) =&gt; {\n      clearTimeout(K), K = setTimeout(() =&gt; M(...j), H);\n    };\n  })(async (M, H) =&gt; {\n    var K;\n    if (!M) {\n      d([]);\n      return;\n    }\n    f(!0);\n    try {\n      const C = await (await an(H)).json();\n      d(((K = C == null ? void 0 : C.result) == null ? void 0 : K.users) || []);\n    } catch (j) {\n      console.error(\"Error fetching data:\", j);\n    } finally {\n      f(!1);\n    }\n  }, 500), []), R = (M) =&gt; {\n    const H = `${on}/v2/farcaster/user/search?q=${M.target.value}&amp;client_id=${i}${a ? `&amp;viewer_fid=${o == null ? void 0 : o.fid}` : \"\"})`;\n    c(M.target.value), b(M.target.value, H);\n  }, A = (M) =&gt; {\n    t.some((H) =&gt; H.username === M.username) || (r([...t, M]), c(\"\"), d([]));\n  }, F = (M) =&gt; {\n    r(t.filter((H) =&gt; H.username !== M));\n  };\n  return /* @__PURE__ */ q.jsxs(G_, {\n    ref: p,\n    style: {\n      width: s\n    },\n    children: [/* @__PURE__ */ q.jsxs(K_, {\n      children: [t.map((M) =&gt; /* @__PURE__ */ q.jsxs(H_, {\n        children: [/* @__PURE__ */ q.jsx(Yo, {\n          src: M.pfp_url ?? bi,\n          alt: `${M.username} Avatar`,\n          style: {\n            width: \"24px\",\n            height: \"24px\",\n            borderRadius: \"50%\"\n          }\n        }), /* @__PURE__ */ q.jsx(\"span\", {\n          style: {\n            marginLeft: \"8px\"\n          },\n          children: M.display_name\n        }), /* @__PURE__ */ q.jsx(sm, {\n          size: 20,\n          onClick: () =&gt; F(M.username)\n        })]\n      }, M.username)), /* @__PURE__ */ q.jsxs(Y_, {\n        children: [/* @__PURE__ */ q.jsx(Z_, {\n          children: /* @__PURE__ */ q.jsx(U_, {\n            color: \"#855DCD\"\n          })\n        }), /* @__PURE__ */ q.jsx(V_, {\n          ...n,\n          value: l,\n          onChange: R,\n          placeholder: \"Type to search users\",\n          style: {\n            width: s || \"100%\",\n            height: e || \"40px\"\n          }\n        })]\n      })]\n    }), h ? /* @__PURE__ */ q.jsx(Q_, {\n      children: /* @__PURE__ */ q.jsx($_, {\n        color: \"#855DCD\"\n      })\n    }) : u.length !== 0 &amp;&amp; /* @__PURE__ */ q.jsx(j_, {\n      children: u.map((M) =&gt; /* @__PURE__ */ q.jsxs(eR, {\n        onClick: () =&gt; A(M),\n        children: [/* @__PURE__ */ q.jsx(Yo, {\n          src: M.pfp_url ?? bi,\n          alt: `${M.username} Avatar`,\n          style: {\n            width: \"40px\",\n            height: \"40px\",\n            borderRadius: \"50%\"\n          }\n        }), /* @__PURE__ */ q.jsxs(q_, {\n          children: [/* @__PURE__ */ q.jsx(W_, {\n            children: M.display_name\n          }), /* @__PURE__ */ q.jsxs(X_, {\n            children: [/* @__PURE__ */ q.jsxs(z_, {\n              children: [\"@\", M.username]\n            }), M.viewer_context &amp;&amp; (M.viewer_context.following || M.viewer_context.followed_by) &amp;&amp; /* @__PURE__ */ q.jsx(J_, {\n              children: M.viewer_context.following &amp;&amp; M.viewer_context.followed_by ? \"Following each other\" : M.viewer_context.following ? \"Following\" : M.viewer_context.followed_by ? \"Follows you\" : null\n            })]\n          })]\n        })]\n      }, M.username))\n    })]\n  });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG5leW5hci9yZWFjdC9kaXN0L2J1bmRsZS5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQSwwQ0FBMEMsMERBQTBEO0FBQ3BHO0FBQ2tEO0FBQ3lKO0FBQzNNO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQ7QUFDQTtBQUNBLENBQUMsZ0JBQWdCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDLGdCQUFnQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFFBQVEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBLHdEQUF3RCxhQUFhLDhDQUE4QyxhQUFhO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEVBQUU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxXQUFXLGFBQWEsV0FBVztBQUN4RztBQUNBO0FBQ0EsNkNBQTZDLHFEQUFxRDtBQUNsRztBQUNBO0FBQ0EsNENBQTRDLDRCQUE0QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELHlCQUF5QjtBQUM1RTtBQUNBO0FBQ0EsMENBQTBDLHlCQUF5QixjQUFjLFdBQVc7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxzQkFBc0Isd0RBQXdELEdBQUcsb0RBQW9ELHNCQUFzQiw0RUFBNEUsd0JBQXdCLHVFQUF1RSxzQkFBc0IsOEVBQThFLGFBQWE7QUFDamlCO0FBQ0E7QUFDQSxxREFBcUQsOERBQThELEVBQUUsV0FBVywrREFBK0QseURBQXlELEVBQUUsV0FBVyw0REFBNEQsNEZBQTRGLEVBQUUsVUFBVSxnREFBZ0QsNEZBQTRGLEVBQUUsVUFBVSw0Q0FBNEMsNEZBQTRGLEVBQUUsNEJBQTRCO0FBQ3Z1QjtBQUNBO0FBQ0EscURBQXFELDZEQUE2RCxFQUFFLFdBQVcsK0RBQStELHlEQUF5RCxFQUFFLFdBQVcsNERBQTRELDJFQUEyRSxFQUFFLFVBQVUsZ0RBQWdELDJFQUEyRSxFQUFFLFVBQVUsNENBQTRDLGlGQUFpRixFQUFFLDRCQUE0QjtBQUN6ckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxhQUFhO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsK0NBQStDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQkFBa0IsMkJBQTJCLGtCQUFrQiwyQkFBMkI7QUFDM0Y7QUFDQTtBQUNBLCtDQUErQyxhQUFhLFNBQVM7QUFDckUsQ0FBQyxnQkFBZ0I7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3RUFBd0U7QUFDbEY7QUFDQTtBQUNBLGVBQWUsOEJBQThCLElBQUk7QUFDakQsWUFBWSxhQUFhO0FBQ3pCLCtDQUErQywrQkFBK0IsMEJBQTBCLG9DQUFvQyxnQ0FBZ0MsMEJBQTBCLElBQUk7QUFDMU0sR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssd0JBQXdCLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsOEJBQThCO0FBQ2xFO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhCQUE4QjtBQUM1RDtBQUNBLE1BQU07QUFDTjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxvQkFBb0Isa0NBQWtDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxhQUFhO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLEdBQUcsbURBQW1ELEdBQUcsd0JBQXdCLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxlQUFlLEVBQUUsZUFBZSxHQUFHLHVCQUF1QixHQUFHLGtjQUFrYyxHQUFHLGlCQUFpQixzQkFBc0IsS0FBSyxnQkFBZ0I7QUFDeHNCO0FBQ0Esd0VBQXdFLEVBQUUsMEhBQTBILEVBQUUsa0dBQWtHLElBQUksR0FBRyxJQUFJLFlBQVksSUFBSSxjQUFjLElBQUksR0FBRyxJQUFJLGVBQWUsSUFBSSxHQUFHLElBQUksYUFBYSxJQUFJLGNBQWMsSUFBSSxHQUFHLElBQUksY0FBYyxJQUFJLEVBQUUsSUFBSSxjQUFjLElBQUksR0FBRyxJQUFJLGNBQWMsSUFBSSxFQUFFLElBQUksY0FBYyxJQUFJLEdBQUcsSUFBSSxjQUFjLElBQUksRUFBRSxJQUFJLGNBQWMsSUFBSSxHQUFHLElBQUksY0FBYyxJQUFJLEVBQUUsSUFBSSxhQUFhLElBQUksZ0JBQWdCLElBQUksRUFBRSxJQUFJLGtCQUFrQixJQUFJLEVBQUUsSUFBSSx1QkFBdUIsSUFBSSxFQUFFLElBQUksYUFBYSxHQUFHLFlBQVksSUFBSSxFQUFFLElBQUksR0FBRyxJQUFJLG9CQUFvQixJQUFJLE9BQU8sSUFBSSxVQUFVLElBQUksbUJBQW1CLElBQUksT0FBTyxJQUFJLG9CQUFvQixJQUFJLEdBQUcsSUFBSSxxQkFBcUIsSUFBSSxPQUFPLElBQUksVUFBVSxJQUFJLG1CQUFtQixJQUFJLE9BQU8sSUFBSSxnQ0FBZ0MsSUFBSSxHQUFHLElBQUksWUFBWSxJQUFJLGNBQWMsSUFBSSxHQUFHLElBQUksZUFBZSxJQUFJLEdBQUcsSUFBSSxhQUFhLElBQUksY0FBYyxJQUFJLEdBQUcsSUFBSSxjQUFjLElBQUksRUFBRSxJQUFJLGNBQWMsSUFBSSxHQUFHLElBQUksY0FBYyxJQUFJLEVBQUUsSUFBSSxjQUFjLElBQUksR0FBRyxJQUFJLGNBQWMsSUFBSSxFQUFFLElBQUksY0FBYyxJQUFJLEdBQUcsSUFBSSxjQUFjLElBQUksRUFBRSxJQUFJLGFBQWEsSUFBSSxnQkFBZ0IsSUFBSSxFQUFFLElBQUksa0JBQWtCLElBQUksRUFBRSxJQUFJLHVCQUF1QixJQUFJLEVBQUUsSUFBSSxhQUFhLEdBQUcsWUFBWSxJQUFJLEVBQUUsSUFBSSxHQUFHLElBQUksb0JBQW9CLElBQUksT0FBTyxJQUFJLFVBQVUsSUFBSSxtQkFBbUIsSUFBSSxPQUFPLElBQUksb0JBQW9CLElBQUksR0FBRyxJQUFJLHFCQUFxQixJQUFJLE9BQU8sSUFBSSxVQUFVLElBQUksbUJBQW1CLElBQUksT0FBTyxJQUFJLG1FQUFtRSxFQUFFLGtCQUFrQixFQUFFLG1CQUFtQixFQUFFLDhCQUE4QixFQUFFLGtCQUFrQixFQUFFLHNCQUFzQixFQUFFLDJHQUEyRyxFQUFFLDRIQUE0SCxHQUFHO0FBQzErRDtBQUNBO0FBQ0EsdUJBQXVCLEVBQUUsT0FBTyxFQUFFLGFBQWEsbUNBQW1DLEVBQUU7QUFDcEY7QUFDQSx1Q0FBdUMsRUFBRSxHQUFHLEVBQUU7QUFDOUM7QUFDQTtBQUNBLHdCQUF3QixNQUFNO0FBQzlCO0FBQ0E7QUFDQSxhQUFhLEdBQUcsR0FBRyxNQUFNO0FBQ3pCO0FBQ0Esb0VBQW9FLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxHQUFHLFlBQVksbUJBQW1CLEVBQUU7QUFDaEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLHNCQUFzQix5Q0FBeUM7QUFDL0Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSxzQkFBc0IscUJBQXFCO0FBQzNDO0FBQ0EsT0FBTztBQUNQO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBLDRCQUE0QixnQ0FBZ0M7QUFDNUQ7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBLDRCQUE0QixpQ0FBaUM7QUFDN0Q7QUFDQTtBQUNBLDRCQUE0QixtQ0FBbUM7QUFDL0Q7QUFDQTtBQUNBLDRCQUE0QixpQ0FBaUM7QUFDN0Q7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBLDRCQUE0QixpQ0FBaUM7QUFDN0Q7QUFDQTtBQUNBLDRCQUE0QixtQ0FBbUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCLGdDQUFnQztBQUM1RDtBQUNBO0FBQ0EsNEJBQTRCLCtCQUErQjtBQUMzRDtBQUNBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsNEJBQTRCLHFDQUFxQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHFCQUFxQjtBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxZQUFZLG9CQUFvQixpQ0FBaUMsb0JBQW9CO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwyQkFBMkI7QUFDMUM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDLHFCQUFxQjtBQUNyQixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw2Q0FBNkMsbUJBQW1CO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQkFBb0I7QUFDaEM7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxRQUFRO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsT0FBTztBQUM3QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFD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QUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsd0JBQXdCO0FBQ3REO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUI7QUFDM0Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix3QkFBd0I7QUFDdEQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlCQUF5QjtBQUMzRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLE9BQU87QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGNBQWM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSwrQkFBK0IsY0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQ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c0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVSxhQUFhLG1DQUFtQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdDQUFnQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw4QkFBOEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw2Q0FBNkM7QUFDOUM7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlDQUFpQyxjQUFjO0FBQ3pFLDhCQUE4QixxQ0FBcUMsa0JBQWtCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFD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Q0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFnRCxJQUFJO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxnQkFBZ0IsMEZBQTBGLElBQUk7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGdCQUFnQixxRUFBcUUsSUFBSTtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsZ0JB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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFVBQVU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLE9BQU87QUFDNUUsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxxQkFBcUI7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsMEJBQTBCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxtQ0FBbUM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTLG1DQUFtQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTLG1DQUFtQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGtCQUFrQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsRUFBRTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCLHdDQUF3QyxFQUFFO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0IsMkJBQTJCLEVBQUU7QUFDN0I7QUFDQSxHQUFHO0FBQ0g7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQiwyQkFBMkIsRUFBRTtBQUM3QjtBQUNBLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQSxHQUFHO0FBQ0g7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsSUFBSSxtRkFBbUYsR0FBRztBQUN0TDtBQUNBO0FBQ0EsVUFBVSxnQ0FBZ0MsdURBQXVELElBQUksK0VBQStFLHVEQUF1RDtBQUMzTztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXFCLElBQUk7QUFDdEMsYUFBYSw4QkFBOEIsSUFBSTtBQUMvQyxhQUFhLHdCQUF3QixJQUFJO0FBQ3pDLGFBQWEseUJBQXlCLElBQUk7QUFDMUMsYUFBYSxlQUFlLElBQUk7QUFDaEMsYUFBYSxlQUFlLElBQUk7QUFDaEMsYUFBYSxZQUFZLElBQUk7QUFDN0IsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxLQUFLLFdBQVc7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx5QkFBeUI7QUFDekI7QUFDQSx3RkFBd0YsaUJBQWlCO0FBQ3pHO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLGNBQWMsV0FBVztBQUN6Qiw4Q0FBOEMsRUFBRTtBQUNoRDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOEJBQThCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHlFQUF5RSxrQkFBa0I7QUFDaEc7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsseUVBQXlFLGtCQUFrQjtBQUNoRztBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUyx3RUFBd0UsWUFBWTtBQUMzRyxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hELEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQkFBbUIscUJBQXFCLElBQUk7QUFDNUMsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLFdBQVcsb0RBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQSxDQUFDLFFBQVEsMERBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLEVBQUUsaURBQUUsZUFBZSwrQ0FBRSxlQUFlLCtDQUFFLGlCQUFpQiwrQ0FBRSxlQUFlLCtDQUFFLGlCQUFpQiwrQ0FBRSxlQUFlLCtDQUFFLEdBQUcsWUFBWSwrQ0FBRSxlQUFlLCtDQUFFLGVBQWUsK0NBQUUsVUFBVSw2Q0FBRSxpQ0FBaUMsNkNBQUUsaUNBQWlDLDZDQUFFLEdBQUcsT0FBTyw2Q0FBRTtBQUNuUTtBQUNBLFlBQVksa0RBQUUsV0FBVztBQUN6QjtBQUNBLEdBQUcsWUFBWSxrREFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUcsWUFBWSxrREFBRTtBQUNqQjtBQUNBO0FBQ0EsR0FBRyxXQUFXLGtEQUFFO0FBQ2hCO0FBQ0EsR0FBRyxXQUFXLGtEQUFFO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRyxrQkFBa0Isa0RBQUU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUcsWUFBWSxrREFBRTtBQUNqQjtBQUNBO0FBQ0EsR0FBRyx1REFBdUQsa0RBQUU7QUFDNUQ7QUFDQTtBQUNBLEdBQUcsNkRBQTZELGtEQUFFO0FBQ2xFO0FBQ0EsR0FBRyx3REFBd0Qsa0RBQUU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRyx1REFBdUQsNkNBQUU7QUFDNUQsaUJBQWlCLGdEQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1Asd0NBQXdDLEdBQUc7QUFDM0MsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsTUFBTSxnREFBRTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUssUUFBUSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxLQUFLLFdBQVc7QUFDckIsR0FBRztBQUNILGlCQUFpQiwrQ0FBRTtBQUNuQixTQUFTLGdEQUFFO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUcsT0FBTyxnREFBRTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxLQUFLLFdBQVc7QUFDdkI7QUFDQTtBQUNBLG9CQUFvQixFQUFFLEdBQUcsV0FBVyxHQUFHLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsWUFBWSw4Q0FBRTtBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVksaURBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixzSEFBc0g7QUFDeE07QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ04saUJBQWlCLCtDQUFFO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHlHQUF5RztBQUN6RyxXQUFXLG9EQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsSUFBSSxpQkFBaUIsK0NBQUUsZUFBZSwrQ0FBRTtBQUN4QyxFQUFFLGdEQUFFO0FBQ0o7QUFDQSxHQUFHLFFBQVEsZ0RBQUU7QUFDYjtBQUNBLEdBQUcsUUFBUSxnREFBRTtBQUNiO0FBQ0EsR0FBRyxPQUFPLGdEQUFFO0FBQ1o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUcsTUFBTSw4Q0FBRTtBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNELFlBQVksaURBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQSxDQUFDLHVCQUF1QiwwREFBRTtBQUMxQjtBQUNBLENBQUMsd0JBQXdCLDBEQUFFO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRCxnSUFBZ0k7QUFDaEksV0FBVyxvREFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjLCtDQUFFLGNBQWMsK0NBQUUsZUFBZSwrQ0FBRSxjQUFjLCtDQUFFLGVBQWUsK0NBQUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRSxnREFBRTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsR0FBRyxNQUFNLDhDQUFFO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSCxDQUFDO0FBQ0QsWUFBWSxpREFBRTtBQUNkO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQztBQUNEO0FBQ0EsMkJBQTJCLDBEQUFFO0FBQzdCO0FBQ0EsQ0FBQyx3QkFBd0IsMERBQUU7QUFDM0I7QUFDQSxDQUFDLHdCQUF3QiwwREFBRTtBQUMzQjtBQUNBLENBQUMsd0JBQXdCLDBEQUFFO0FBQzNCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLHlDQUF5QztBQUN6QztBQUNBLHlDQUF5QztBQUN6QztBQUNBLHlDQUF5QztBQUN6QztBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCLDBCQUEwQjtBQUMxQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksK0RBQStELCtDQUFFLFVBQVUsNkNBQUUsZUFBZSxzREFBc0QsYUFBYSxFQUFFLDhCQUE4Qiw2Q0FBRSxZQUFZLGtEQUFFO0FBQ25OO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUcsZUFBZSxrREFBRTtBQUNwQiw2RUFBNkUsbUNBQW1DLFFBQVEsRUFBRTtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUUsZ0RBQUU7QUFDSjtBQUNBLEdBQUc7QUFDSCxZQUFZLGtEQUFFO0FBQ2Q7QUFDQSxHQUFHO0FBQ0gsU0FBUyxnREFBRTtBQUNYO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUNBQWlDO0FBQ25ELFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQyx1QkFBdUIsMERBQUU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMkhBQTJILEdBQUcscUNBQXFDLFVBQVUsS0FBSyxVQUFVLEtBQUssVUFBVSxzQ0FBc0MsR0FBRyxZQUFZLFNBQVMsb0JBQW9CLEdBQUcsR0FBRyxlQUFlLHNEQUFzRCxFQUFFLDZCQUE2QiwwREFBRTtBQUMxWTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxTQUFTLDJCQUEyQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUIsMERBQUU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsdUNBQXVDLDBEQUFFO0FBQzFDO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDLElBQUk7QUFDTDtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0EsQ0FBQyxJQUFJO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsRUFBRTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx3QkFBd0IsR0FBRyxFQUFFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDLEVBQUU7QUFDekMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxpQkFBaUI7QUFDakg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFNBQVM7QUFDVDtBQUNBLGtFQUFrRSw0Q0FBNEM7QUFDOUc7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsWUFBWSxFQUFFLElBQUksU0FBUyxHQUFHLFFBQVEsR0FBRyx1QkFBdUIsRUFBRSwyQkFBMkIsR0FBRywyQkFBMkI7QUFDM0g7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhLEVBQUUsRUFBRSxJQUFJLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsa0JBQWtCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFFBQVE7QUFDUiw2QkFBNkIsS0FBSztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdOQUFnTixtQkFBbUI7QUFDbk87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVILGVBQWU7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixLQUFLO0FBQy9CO0FBQ0E7QUFDQSxvREFBb0QsR0FBRyxHQUFHLGFBQWEsdUJBQXVCLHNEQUFzRCxLQUFLLHdDQUF3QyxZQUFZLGtCQUFrQix1RUFBdUUsR0FBRyxrQkFBa0IsUUFBUTtBQUNuVTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsR0FBRyxRQUFRLFVBQVU7QUFDL0Y7QUFDQSw2QkFBNkIsS0FBSztBQUNsQyxnQkFBZ0IsbUJBQW1CLDZDQUE2QyxHQUFHLE1BQU0sV0FBVyxJQUFJLEVBQUU7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixLQUFLO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJCQUEyQixLQUFLO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTyxHQUFHLFFBQVEsR0FBRyxLQUFLO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFD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VztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDJDQUEyQyxRQUFRLEVBQUUsT0FBTztBQUM1RDtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsVUFBVTtBQUN4RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2QkFBNkI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSkFBMEosRUFBRTtBQUM1SixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEVBQUUsZ0RBQWdELEVBQUU7QUFDaEYsTUFBTTtBQUNOLGdHQUFnRyxVQUFVO0FBQzFHO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZ0lBQWdJLEVBQUU7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyxJQUFJO0FBQ0osd0lBQXdJLEVBQUU7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEVBQUUsY0FBYyxHQUFHO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsRUFBRSxzQ0FBc0MsS0FBSztBQUM1RjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwwSEFBMEgsUUFBUSxLQUFLLEVBQUU7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwc0NBQTBzQztBQUMxc0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLEtBQUs7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEVBQUU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxFQUFFO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLFNBQVMsRUFBRTtBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0JBQStCLFNBQVMsRUFBRTtBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFVBQVU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsRUFBRTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEVBQUUsaUJBQWlCLEVBQUUsYUFBYSxFQUFFLFNBQVMsR0FBRyxvQkFBb0IsR0FBRyxpQkFBaUIsRUFBRTtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxVQUFVO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxLQUFLO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLE9BQU87QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHdCQUF3QjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0NBQXdDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0NBQWtDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDBCQUEwQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBLHFIQUFxSCxPQUFPO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxtQ0FBbUMsUUFBUSxpQkFBaUIsRUFBRSxHQUFHLFFBQVE7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixHQUFHLFNBQVMsR0FBRztBQUM5QztBQUNBO0FBQ0EsVUFBVSx3REFBd0QsR0FBRztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxVQUFVO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTixnREFBZ0QsU0FBUyxNQUFNLEtBQUssRUFBRSx1Q0FBdUMsS0FBSyx5Q0FBeUMsRUFBRSxRQUFRO0FBQ3JLO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDZCQUE2QixZQUFZLEdBQUcsV0FBVyxHQUFHLFNBQVM7QUFDbkUsMkVBQTJFLFFBQVE7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxjQUFjLE9BQU8sRUFBRSxrRkFBa0YsRUFBRTtBQUNqSztBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Ysc0NBQXNDLEVBQUU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsUUFBUSxNQUFNLEtBQUssRUFBRSx1Q0FBdUMsRUFBRSx3Q0FBd0MsSUFBSSxTQUFTLE1BQU07QUFDaE4seUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QixzQkFBc0I7QUFDdEIsOEJBQThCO0FBQzlCLHNCQUFzQjtBQUN0Qiw2QkFBNkIsRUFBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sOEJBQThCLEdBQUcsbUJBQW1CLE9BQU8sR0FBRyxFQUFFLEdBQUcsRUFBRSxhQUFhLEVBQUU7QUFDM0Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFNBQVMsS0FBSyxLQUFLO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUhBQXlILGFBQWE7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMERBQTBELEdBQUcsR0FBRyxPQUFPLFFBQVEsRUFBRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxHQUFHLEdBQUcsT0FBTyxRQUFRLEVBQUUsWUFBWSxVQUFVLEdBQUcsUUFBUSxHQUFHLHdCQUF3QixhQUFhLEdBQUcsZ0JBQWdCLFFBQVEsWUFBWSxnQkFBZ0I7QUFDdE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSx5RkFBeUYsTUFBTSxXQUFXLFNBQVM7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkNBQTJDLEtBQUsscURBQXFELE1BQU0sTUFBTSxXQUFXLEdBQUcsUUFBUSxVQUFVLEVBQUU7QUFDbko7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixLQUFLLEVBQUUsMkJBQTJCLFdBQVcsU0FBUyw4Q0FBOEMsV0FBVyxpQkFBaUIseURBQXlEO0FBQ3JOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4R0FBOEc7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFlBQVksMEJBQTBCLEVBQUUsR0FBRyxRQUFRO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxNQUFNLCtDQUErQyxNQUFNLFdBQVcsYUFBYTtBQUNuSjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwySEFBMkg7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix5RUFBeUUsRUFBRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLCtFQUErRSxFQUFFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUhBQW1ILEdBQUcsRUFBRSxvR0FBb0c7QUFDNU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7QUFDQSwwREFBMEQsY0FBYyxNQUFNLEdBQUcscUJBQXFCLE1BQU07QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVksa0JBQWtCLGFBQWEsVUFBVSxHQUFHLFVBQVUsR0FBRyxVQUFVLEVBQUU7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw2QkFBNkIsS0FBSyxlQUFlO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxNQUFNLEdBQUcsZUFBZSxTQUFTLEVBQUU7QUFDbEY7QUFDQTtBQUNBLDhIQUE4SCxNQUFNLEdBQUcsZUFBZSxTQUFTLEVBQUUsT0FBTyxFQUFFO0FBQzFLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsdUNBQXVDLEdBQUcsWUFBWSxHQUFHLDRCQUE0QiwrQkFBK0I7QUFDcEg7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELEdBQUcsR0FBRyxPQUFPLFNBQVMsUUFBUSxRQUFRLEdBQUcsVUFBVSxVQUFVLEdBQUcsUUFBUTtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsVUFBVSw4QkFBOEIsaUNBQWlDO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Ysb0RBQW9ELGVBQWUsU0FBUztBQUNsSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxFQUFFO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GLEdBQUcsR0FBRyxPQUFPLFNBQVMsUUFBUSxRQUFRLFdBQVcsV0FBVyxXQUFXLDRGQUE0RjtBQUN2UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsR0FBRyxHQUFHLE9BQU8sU0FBUyxRQUFRLFFBQVEsRUFBRSxFQUFFLHFGQUFxRixFQUFFLDRFQUE0RSxFQUFFLEVBQUU7QUFDclA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEVBQUU7QUFDRixFQUFFO0FBQ0YsRUFBRSx5QkFBeUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLEVBQUUsS0FBSyxtQkFBbUIsSUFBSSxnQkFBZ0I7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsOEJBQThCLEVBQUUsd0JBQXdCLEVBQUUsMEJBQTBCO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssa0JBQWtCO0FBQ3ZCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLHNGQUFzRixHQUFHLElBQUksRUFBRTtBQUMvRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsZ0NBQWdDLEVBQUUsc0NBQXNDLEVBQUUsb0JBQW9CO0FBQ3pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csR0FBRztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOEZBQThGLGdCQUFnQiw4Q0FBOEM7QUFDNUs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsNEJBQTRCO0FBQzdGLG1CQUFtQjtBQUNuQixtQkFBbUIsbURBQW1EO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBLDZGQUE2RixHQUFHLEtBQUssRUFBRTtBQUN2RztBQUNBO0FBQ0Esd0ZBQXdGLGVBQWUsTUFBTSxlQUFlLGlCQUFpQixHQUFHLGVBQWUsRUFBRSwrQ0FBK0M7QUFDaE47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxtQ0FBbUMsaUNBQWlDO0FBQ3BFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQSxZQUFZO0FBQ1osMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG1DQUFtQyxFQUFFO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsRUFBRSxzQkFBc0IsdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQSxtREFBbUQsZUFBZSxTQUFTLEVBQUU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHFIQUFxSCxHQUFHLEtBQUssRUFBRTtBQUMvSCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQSxpQkFBaUIsR0FBRyxTQUFTLEVBQUU7QUFDL0IsNEJBQTRCLEVBQUU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsR0FBRyx1QkFBdUIsRUFBRTtBQUN6RjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0Esc0NBQXNDLEdBQUc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZUFBZTtBQUN4QjtBQUNBLFNBQVMsVUFBVTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxZQUFZLEdBQUcsR0FBRyxFQUFFO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFGQUFxRjtBQUNyRjtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrVkFBK1Y7QUFDL1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxrVUFBa1Us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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsRUFBRTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEVBQUUsY0FBYyxPQUFPLFNBQVMsUUFBUSxRQUFRLFVBQVU7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSTtBQUNMO0FBQ0EsWUFBWSxhQUFhLEdBQUcsTUFBTSxHQUFHLE1BQU07QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsRUFBRTtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEdBQUcsR0FBRyxFQUFFO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsR0FBRyxFQUFFLE1BQU07QUFDdkQsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxFQUFFO0FBQzNDLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsTUFBTTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUtBQW1LLEVBQUU7QUFDcks7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBbUQsS0FBSyxtQkFBbUIsT0FBTyxHQUFHLHNCQUFzQixjQUFjO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxFQUFFLElBQUksR0FBRyxHQUFHLFdBQVcsU0FBUyxpQkFBaUI7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE1BQU0sR0FBRyxvQkFBb0IsRUFBRSxNQUFNO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzSEFBc0gsR0FBRyxFQUFFLE1BQU07QUFDakk7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRyxPQUFPLEVBQUUseUNBQXlDO0FBQ3ZKO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCwrREFBK0QsRUFBRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsRUFBRTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixNQUFNLEdBQUcsR0FBRyxtQkFBbUIsRUFBRTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUtBQWlLLE1BQU07QUFDdks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE1BQU07QUFDMUQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwrQ0FBK0M7QUFDckU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx3QkFBd0I7QUFDMUQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msd0JBQXdCO0FBQzFEO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsdUZBQXVGLE9BQU8sT0FBTyxNQUFNO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELE1BQU0sY0FBYyxjQUFjO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU0sR0FBRyxXQUFXLEVBQUUsRUFBRSxFQUFFLG9CQUFvQixHQUFHLGdCQUFnQixFQUFFLE9BQU87QUFDeEg7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxFQUFFO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFFBQVE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLEtBQUssMkVBQTJFLEdBQUcsWUFBWSxFQUFFO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxFQUFFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLEVBQUUsb0JBQW9CLEdBQUcsSUFBSSxFQUFFO0FBQzVHO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsRUFBRTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyR0FBMkcsU0FBUyxFQUFFLEVBQUU7QUFDeEgsS0FBSztBQUNMO0FBQ0E7QUFDQSxpRUFBaUUsRUFBRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLGlEQUFpRCxNQUFNO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEVBQUU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixHQUFHLGFBQWEsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkxBQTJMLE1BQU0sR0FBRyxHQUFHLEVBQUUsTUFBTTtBQUMvTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsRUFBRTtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTyx3QkFBd0Isc0JBQXNCLHNEQUFzRCxlQUFlO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxHQUFHLEtBQUssT0FBTyxLQUFLLEdBQUcsRUFBRSxHQUFHLHNCQUFzQixFQUFFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsWUFBWSxFQUFFLFFBQVE7QUFDcEU7QUFDQSxrS0FBa0s7QUFDbEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isd0JBQXdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxhQUFhLFdBQVcsR0FBRyxPQUFPLGtCQUFrQixXQUFXLE9BQU8sU0FBUyxRQUFRO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxnRUFBZ0UsR0FBRyxRQUFRLEVBQUUsSUFBSSxFQUFFO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsa0JBQWtCLEVBQUUsRUFBRTtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxrQkFBa0IsZUFBZSxpQkFBaUI7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esa0VBQWtFLEVBQUU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixHQUFHLFVBQVUsVUFBVSxHQUFHLFFBQVEsR0FBRyx3QkFBd0IsYUFBYSxHQUFHLGdCQUFnQixRQUFRLFlBQVksZ0JBQWdCO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQLHFCQUFxQixPQUFPLElBQUksVUFBVTtBQUMxQyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsRUFBRSx5Q0FBeUMsRUFBRSx1Q0FBdUMsRUFBRTtBQUMzSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVyxHQUFHLEVBQUUsSUFBSSxFQUFFO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixJQUFJO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsRUFBRTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwQkFBMEI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0NBQXdDLEdBQUcsTUFBTSxFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsb0VBQW9FLEVBQUUsa0JBQWtCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxFQUFFO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc05BQXNOLG1DQUFtQztBQUN6UDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEtBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNCQUFzQix5QkFBeUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLHNLQUFzSyxtQ0FBbUM7QUFDek07QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDZGQUE2RixhQUFhO0FBQzFHO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUs7QUFDakM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCw2Q0FBNkMsRUFBRTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSw0RkFBNEYsRUFBRTtBQUM5RjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsR0FBRyxnQkFBZ0IsTUFBTTtBQUM3QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLDRDQUE0QztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDREQUE0RCw4Q0FBOEMsZ0JBQWdCLDJCQUEyQixhQUFhLFFBQVEsR0FBRyxlQUFlLEtBQUssZ0JBQWdCO0FBQ2pOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsRUFBRTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxXQUFXO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07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O0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBLHNHQUFzRyxRQUFRLGNBQWMsT0FBTztBQUNuSTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxFQUFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDBGQUEwRixFQUFFO0FBQzVGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3Q0FBd0M7QUFDekUsb0JBQW9CLGtJQUFrSTtBQUN0SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw0SEFBNEg7QUFDaEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxFQUFFO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsRUFBRTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEVBQUU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsRUFBRTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsRUFBRTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsRUFBRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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SDtBQUNBLElBQUksU0FBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQixPQUFPLHNCQUFzQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxDQUFDLE9BQU8sb0RB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Q1g7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBa0JFIiwic291cmNlcyI6WyIvaG9tZS93c2x4dC9jczQ3Mi9mYXJjYXN0ZXIvbm9kZV9tb2R1bGVzL0BuZXluYXIvcmVhY3QvZGlzdC9idW5kbGUuZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIHltID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIHZtID0gKHMsIGUsIHQpID0+IGUgaW4gcyA/IHltKHMsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiBzW2VdID0gdDtcbnZhciBDciA9IChzLCBlLCB0KSA9PiB2bShzLCB0eXBlb2YgZSAhPSBcInN5bWJvbFwiID8gZSArIFwiXCIgOiBlLCB0KTtcbmltcG9ydCB7IHN0eWxlZCBhcyBkZSB9IGZyb20gXCJAcGlnbWVudC1jc3MvcmVhY3RcIjtcbmltcG9ydCBzdCwgeyBjcmVhdGVDb250ZXh0IGFzIGFhLCB1c2VNZW1vIGFzIFpyLCB1c2VDb250ZXh0IGFzIEFpLCB1c2VTdGF0ZSBhcyBxZSwgdXNlUmVmIGFzIGJ0LCB1c2VDYWxsYmFjayBhcyB1dCwgdXNlRWZmZWN0IGFzIGZ0LCB1c2VMYXlvdXRFZmZlY3QgYXMgRW0sIHVzZURlYnVnVmFsdWUgYXMgeG0sIG1lbW8gYXMgTWYgfSBmcm9tIFwicmVhY3RcIjtcbmNvbnN0IEdyID0ge1xuICB2YXJzOiB7XG4gICAgY29sb3JzOiB7XG4gICAgICBwcmltYXJ5OiBcInZhcigtLWNvbG9ycy1wcmltYXJ5KVwiXG4gICAgfSxcbiAgICB0eXBvZ3JhcGh5OiB7XG4gICAgICBmb250czoge1xuICAgICAgICBiYXNlOiBcInZhcigtLXR5cG9ncmFwaHktZm9udHMtYmFzZSlcIlxuICAgICAgfSxcbiAgICAgIGZvbnRXZWlnaHRzOiB7XG4gICAgICAgIHJlZ3VsYXI6IFwidmFyKC0tdHlwb2dyYXBoeS1mb250V2VpZ2h0cy1yZWd1bGFyKVwiLFxuICAgICAgICBib2xkOiBcInZhcigtLXR5cG9ncmFwaHktZm9udFdlaWdodHMtYm9sZClcIlxuICAgICAgfSxcbiAgICAgIGZvbnRTaXplczoge1xuICAgICAgICBsYXJnZTogXCJ2YXIoLS10eXBvZ3JhcGh5LWZvbnRTaXplcy1sYXJnZSlcIixcbiAgICAgICAgbWVkaXVtOiBcInZhcigtLXR5cG9ncmFwaHktZm9udFNpemVzLW1lZGl1bSlcIixcbiAgICAgICAgc21hbGw6IFwidmFyKC0tdHlwb2dyYXBoeS1mb250U2l6ZXMtc21hbGwpXCJcbiAgICAgIH1cbiAgICB9LFxuICAgIHBhbGV0dGU6IHtcbiAgICAgIGJhY2tncm91bmQ6IFwidmFyKC0tcGFsZXR0ZS1iYWNrZ3JvdW5kKVwiLFxuICAgICAgYm9yZGVyOiBcInZhcigtLXBhbGV0dGUtYm9yZGVyKVwiLFxuICAgICAgdGV4dDogXCJ2YXIoLS1wYWxldHRlLXRleHQpXCIsXG4gICAgICB0ZXh0TXV0ZWQ6IFwidmFyKC0tcGFsZXR0ZS10ZXh0TXV0ZWQpXCJcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBGYyhzKSB7XG4gIHJldHVybiBzICYmIHMuX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgXCJkZWZhdWx0XCIpID8gcy5kZWZhdWx0IDogcztcbn1cbmZ1bmN0aW9uIE5jKHMpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBcIl9fZXNNb2R1bGVcIikpIHJldHVybiBzO1xuICB2YXIgZSA9IHMuZGVmYXVsdDtcbiAgaWYgKHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciB0ID0gZnVuY3Rpb24gcigpIHtcbiAgICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgciA/IFJlZmxlY3QuY29uc3RydWN0KGUsIGFyZ3VtZW50cywgdGhpcy5jb25zdHJ1Y3RvcikgOiBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgICB0LnByb3RvdHlwZSA9IGUucHJvdG90eXBlO1xuICB9IGVsc2UgdCA9IHt9O1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6ICEwXG4gIH0pLCBPYmplY3Qua2V5cyhzKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iocywgcik7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIHIsIG4uZ2V0ID8gbiA6IHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHNbcl07XG4gICAgICB9XG4gICAgfSk7XG4gIH0pLCB0O1xufVxudmFyIFVhID0geyBleHBvcnRzOiB7fSB9LCBLbiA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBXdTtcbmZ1bmN0aW9uIFNtKCkge1xuICBpZiAoV3UpIHJldHVybiBLbjtcbiAgV3UgPSAxO1xuICB2YXIgcyA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSwgZSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKTtcbiAgZnVuY3Rpb24gdChyLCBuLCBpKSB7XG4gICAgdmFyIG8gPSBudWxsO1xuICAgIGlmIChpICE9PSB2b2lkIDAgJiYgKG8gPSBcIlwiICsgaSksIG4ua2V5ICE9PSB2b2lkIDAgJiYgKG8gPSBcIlwiICsgbi5rZXkpLCBcImtleVwiIGluIG4pIHtcbiAgICAgIGkgPSB7fTtcbiAgICAgIGZvciAodmFyIGEgaW4gbilcbiAgICAgICAgYSAhPT0gXCJrZXlcIiAmJiAoaVthXSA9IG5bYV0pO1xuICAgIH0gZWxzZSBpID0gbjtcbiAgICByZXR1cm4gbiA9IGkucmVmLCB7XG4gICAgICAkJHR5cGVvZjogcyxcbiAgICAgIHR5cGU6IHIsXG4gICAgICBrZXk6IG8sXG4gICAgICByZWY6IG4gIT09IHZvaWQgMCA/IG4gOiBudWxsLFxuICAgICAgcHJvcHM6IGlcbiAgICB9O1xuICB9XG4gIHJldHVybiBLbi5GcmFnbWVudCA9IGUsIEtuLmpzeCA9IHQsIEtuLmpzeHMgPSB0LCBLbjtcbn1cbnZhciB6dTtcbmZ1bmN0aW9uIGJtKCkge1xuICByZXR1cm4genUgfHwgKHp1ID0gMSwgVWEuZXhwb3J0cyA9IFNtKCkpLCBVYS5leHBvcnRzO1xufVxudmFyIHEgPSBibSgpO1xubGV0IFVuID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHQsIHIgPSB7fSkge1xuICAgIHN1cGVyKHQsIHIuY2F1c2UgPyB7IGNhdXNlOiByLmNhdXNlIH0gOiB2b2lkIDApO1xuICAgIENyKHRoaXMsIFwibmFtZVwiLCBcIkJhc2VFcnJvclwiKTtcbiAgICBDcih0aGlzLCBcImNhdXNlXCIpO1xuICAgIHRoaXMuY2F1c2UgPSByLmNhdXNlO1xuICB9XG59O1xuY2xhc3MgVG0gZXh0ZW5kcyBVbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiSW52YWxpZCBkb21haW4gbWFuaWZlc3RcIik7XG4gICAgQ3IodGhpcywgXCJuYW1lXCIsIFwiQWRkTWluaUFwcC5JbnZhbGlkRG9tYWluTWFuaWZlc3RcIik7XG4gIH1cbn1cbmxldCB3bSA9IGNsYXNzIGV4dGVuZHMgVW4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcIkFkZCBtaW5pYXBwIHJlamVjdGVkIGJ5IHVzZXJcIik7XG4gICAgQ3IodGhpcywgXCJuYW1lXCIsIFwiQWRkTWluaUFwcC5SZWplY3RlZEJ5VXNlclwiKTtcbiAgfVxufSwgT2YgPSBjbGFzcyBleHRlbmRzIFVuIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoXCJTaWduIGluIHJlamVjdGVkIGJ5IHVzZXJcIik7XG4gICAgQ3IodGhpcywgXCJuYW1lXCIsIFwiU2lnbkluLlJlamVjdGVkQnlVc2VyXCIpO1xuICB9XG59O1xuY2xhc3MgQW0gZXh0ZW5kcyBVbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiU2lnbiBtYW5pZmVzdCByZWplY3RlZCBieSB1c2VyXCIpO1xuICAgIENyKHRoaXMsIFwibmFtZVwiLCBcIlNpZ25NYW5pZmVzdC5SZWplY3RlZEJ5VXNlclwiKTtcbiAgfVxufVxuY2xhc3MgSW0gZXh0ZW5kcyBVbiB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFwiSW52YWxpZCBkb21haW4gcHJvdmlkZWRcIik7XG4gICAgQ3IodGhpcywgXCJuYW1lXCIsIFwiU2lnbk1hbmlmZXN0LkludmFsaWREb21haW5cIik7XG4gIH1cbn1cbmNsYXNzIF9tIGV4dGVuZHMgVW4ge1xuICBjb25zdHJ1Y3Rvcih0ID0gXCJNYW5pZmVzdCBzaWduaW5nIGZhaWxlZFwiKSB7XG4gICAgc3VwZXIodCk7XG4gICAgQ3IodGhpcywgXCJuYW1lXCIsIFwiU2lnbk1hbmlmZXN0LkdlbmVyaWNFcnJvclwiKTtcbiAgfVxufVxudmFyIFplO1xuKGZ1bmN0aW9uKHMpIHtcbiAgcy5hc3NlcnRFcXVhbCA9IChuKSA9PiB7XG4gIH07XG4gIGZ1bmN0aW9uIGUobikge1xuICB9XG4gIHMuYXNzZXJ0SXMgPSBlO1xuICBmdW5jdGlvbiB0KG4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgfVxuICBzLmFzc2VydE5ldmVyID0gdCwgcy5hcnJheVRvRW51bSA9IChuKSA9PiB7XG4gICAgY29uc3QgaSA9IHt9O1xuICAgIGZvciAoY29uc3QgbyBvZiBuKVxuICAgICAgaVtvXSA9IG87XG4gICAgcmV0dXJuIGk7XG4gIH0sIHMuZ2V0VmFsaWRFbnVtVmFsdWVzID0gKG4pID0+IHtcbiAgICBjb25zdCBpID0gcy5vYmplY3RLZXlzKG4pLmZpbHRlcigoYSkgPT4gdHlwZW9mIG5bblthXV0gIT0gXCJudW1iZXJcIiksIG8gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGEgb2YgaSlcbiAgICAgIG9bYV0gPSBuW2FdO1xuICAgIHJldHVybiBzLm9iamVjdFZhbHVlcyhvKTtcbiAgfSwgcy5vYmplY3RWYWx1ZXMgPSAobikgPT4gcy5vYmplY3RLZXlzKG4pLm1hcChmdW5jdGlvbihpKSB7XG4gICAgcmV0dXJuIG5baV07XG4gIH0pLCBzLm9iamVjdEtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT0gXCJmdW5jdGlvblwiID8gKG4pID0+IE9iamVjdC5rZXlzKG4pIDogKG4pID0+IHtcbiAgICBjb25zdCBpID0gW107XG4gICAgZm9yIChjb25zdCBvIGluIG4pXG4gICAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobiwgbykgJiYgaS5wdXNoKG8pO1xuICAgIHJldHVybiBpO1xuICB9LCBzLmZpbmQgPSAobiwgaSkgPT4ge1xuICAgIGZvciAoY29uc3QgbyBvZiBuKVxuICAgICAgaWYgKGkobykpXG4gICAgICAgIHJldHVybiBvO1xuICB9LCBzLmlzSW50ZWdlciA9IHR5cGVvZiBOdW1iZXIuaXNJbnRlZ2VyID09IFwiZnVuY3Rpb25cIiA/IChuKSA9PiBOdW1iZXIuaXNJbnRlZ2VyKG4pIDogKG4pID0+IHR5cGVvZiBuID09IFwibnVtYmVyXCIgJiYgTnVtYmVyLmlzRmluaXRlKG4pICYmIE1hdGguZmxvb3IobikgPT09IG47XG4gIGZ1bmN0aW9uIHIobiwgaSA9IFwiIHwgXCIpIHtcbiAgICByZXR1cm4gbi5tYXAoKG8pID0+IHR5cGVvZiBvID09IFwic3RyaW5nXCIgPyBgJyR7b30nYCA6IG8pLmpvaW4oaSk7XG4gIH1cbiAgcy5qb2luVmFsdWVzID0gciwgcy5qc29uU3RyaW5naWZ5UmVwbGFjZXIgPSAobiwgaSkgPT4gdHlwZW9mIGkgPT0gXCJiaWdpbnRcIiA/IGkudG9TdHJpbmcoKSA6IGk7XG59KShaZSB8fCAoWmUgPSB7fSkpO1xudmFyIFl1O1xuKGZ1bmN0aW9uKHMpIHtcbiAgcy5tZXJnZVNoYXBlcyA9IChlLCB0KSA9PiAoe1xuICAgIC4uLmUsXG4gICAgLi4udFxuICAgIC8vIHNlY29uZCBvdmVyd3JpdGVzIGZpcnN0XG4gIH0pO1xufSkoWXUgfHwgKFl1ID0ge30pKTtcbmNvbnN0IG1lID0gWmUuYXJyYXlUb0VudW0oW1xuICBcInN0cmluZ1wiLFxuICBcIm5hblwiLFxuICBcIm51bWJlclwiLFxuICBcImludGVnZXJcIixcbiAgXCJmbG9hdFwiLFxuICBcImJvb2xlYW5cIixcbiAgXCJkYXRlXCIsXG4gIFwiYmlnaW50XCIsXG4gIFwic3ltYm9sXCIsXG4gIFwiZnVuY3Rpb25cIixcbiAgXCJ1bmRlZmluZWRcIixcbiAgXCJudWxsXCIsXG4gIFwiYXJyYXlcIixcbiAgXCJvYmplY3RcIixcbiAgXCJ1bmtub3duXCIsXG4gIFwicHJvbWlzZVwiLFxuICBcInZvaWRcIixcbiAgXCJuZXZlclwiLFxuICBcIm1hcFwiLFxuICBcInNldFwiXG5dKSwgd3MgPSAocykgPT4ge1xuICBzd2l0Y2ggKHR5cGVvZiBzKSB7XG4gICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgcmV0dXJuIG1lLnVuZGVmaW5lZDtcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICByZXR1cm4gbWUuc3RyaW5nO1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIHJldHVybiBOdW1iZXIuaXNOYU4ocykgPyBtZS5uYW4gOiBtZS5udW1iZXI7XG4gICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgIHJldHVybiBtZS5ib29sZWFuO1xuICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgcmV0dXJuIG1lLmZ1bmN0aW9uO1xuICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgIHJldHVybiBtZS5iaWdpbnQ7XG4gICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgcmV0dXJuIG1lLnN5bWJvbDtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShzKSA/IG1lLmFycmF5IDogcyA9PT0gbnVsbCA/IG1lLm51bGwgOiBzLnRoZW4gJiYgdHlwZW9mIHMudGhlbiA9PSBcImZ1bmN0aW9uXCIgJiYgcy5jYXRjaCAmJiB0eXBlb2Ygcy5jYXRjaCA9PSBcImZ1bmN0aW9uXCIgPyBtZS5wcm9taXNlIDogdHlwZW9mIE1hcCA8IFwidVwiICYmIHMgaW5zdGFuY2VvZiBNYXAgPyBtZS5tYXAgOiB0eXBlb2YgU2V0IDwgXCJ1XCIgJiYgcyBpbnN0YW5jZW9mIFNldCA/IG1lLnNldCA6IHR5cGVvZiBEYXRlIDwgXCJ1XCIgJiYgcyBpbnN0YW5jZW9mIERhdGUgPyBtZS5kYXRlIDogbWUub2JqZWN0O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbWUudW5rbm93bjtcbiAgfVxufSwgYWUgPSBaZS5hcnJheVRvRW51bShbXG4gIFwiaW52YWxpZF90eXBlXCIsXG4gIFwiaW52YWxpZF9saXRlcmFsXCIsXG4gIFwiY3VzdG9tXCIsXG4gIFwiaW52YWxpZF91bmlvblwiLFxuICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxuICBcImludmFsaWRfZW51bV92YWx1ZVwiLFxuICBcInVucmVjb2duaXplZF9rZXlzXCIsXG4gIFwiaW52YWxpZF9hcmd1bWVudHNcIixcbiAgXCJpbnZhbGlkX3JldHVybl90eXBlXCIsXG4gIFwiaW52YWxpZF9kYXRlXCIsXG4gIFwiaW52YWxpZF9zdHJpbmdcIixcbiAgXCJ0b29fc21hbGxcIixcbiAgXCJ0b29fYmlnXCIsXG4gIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcbiAgXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgXCJub3RfZmluaXRlXCJcbl0pO1xuY2xhc3MgcHMgZXh0ZW5kcyBFcnJvciB7XG4gIGdldCBlcnJvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNzdWVzO1xuICB9XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcigpLCB0aGlzLmlzc3VlcyA9IFtdLCB0aGlzLmFkZElzc3VlID0gKHIpID0+IHtcbiAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCByXTtcbiAgICB9LCB0aGlzLmFkZElzc3VlcyA9IChyID0gW10pID0+IHtcbiAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCAuLi5yXTtcbiAgICB9O1xuICAgIGNvbnN0IHQgPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgdCkgOiB0aGlzLl9fcHJvdG9fXyA9IHQsIHRoaXMubmFtZSA9IFwiWm9kRXJyb3JcIiwgdGhpcy5pc3N1ZXMgPSBlO1xuICB9XG4gIGZvcm1hdChlKSB7XG4gICAgY29uc3QgdCA9IGUgfHwgZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIGkubWVzc2FnZTtcbiAgICB9LCByID0geyBfZXJyb3JzOiBbXSB9LCBuID0gKGkpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbyBvZiBpLmlzc3VlcylcbiAgICAgICAgaWYgKG8uY29kZSA9PT0gXCJpbnZhbGlkX3VuaW9uXCIpXG4gICAgICAgICAgby51bmlvbkVycm9ycy5tYXAobik7XG4gICAgICAgIGVsc2UgaWYgKG8uY29kZSA9PT0gXCJpbnZhbGlkX3JldHVybl90eXBlXCIpXG4gICAgICAgICAgbihvLnJldHVyblR5cGVFcnJvcik7XG4gICAgICAgIGVsc2UgaWYgKG8uY29kZSA9PT0gXCJpbnZhbGlkX2FyZ3VtZW50c1wiKVxuICAgICAgICAgIG4oby5hcmd1bWVudHNFcnJvcik7XG4gICAgICAgIGVsc2UgaWYgKG8ucGF0aC5sZW5ndGggPT09IDApXG4gICAgICAgICAgci5fZXJyb3JzLnB1c2godChvKSk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGxldCBhID0gciwgbCA9IDA7XG4gICAgICAgICAgZm9yICg7IGwgPCBvLnBhdGgubGVuZ3RoOyApIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBvLnBhdGhbbF07XG4gICAgICAgICAgICBsID09PSBvLnBhdGgubGVuZ3RoIC0gMSA/IChhW2NdID0gYVtjXSB8fCB7IF9lcnJvcnM6IFtdIH0sIGFbY10uX2Vycm9ycy5wdXNoKHQobykpKSA6IGFbY10gPSBhW2NdIHx8IHsgX2Vycm9yczogW10gfSwgYSA9IGFbY10sIGwrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBuKHRoaXMpLCByO1xuICB9XG4gIHN0YXRpYyBhc3NlcnQoZSkge1xuICAgIGlmICghKGUgaW5zdGFuY2VvZiBwcykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhIFpvZEVycm9yOiAke2V9YCk7XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgfVxuICBnZXQgbWVzc2FnZSgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5pc3N1ZXMsIFplLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gIH1cbiAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgfVxuICBmbGF0dGVuKGUgPSAodCkgPT4gdC5tZXNzYWdlKSB7XG4gICAgY29uc3QgdCA9IHt9LCByID0gW107XG4gICAgZm9yIChjb25zdCBuIG9mIHRoaXMuaXNzdWVzKVxuICAgICAgaWYgKG4ucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGkgPSBuLnBhdGhbMF07XG4gICAgICAgIHRbaV0gPSB0W2ldIHx8IFtdLCB0W2ldLnB1c2goZShuKSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgci5wdXNoKGUobikpO1xuICAgIHJldHVybiB7IGZvcm1FcnJvcnM6IHIsIGZpZWxkRXJyb3JzOiB0IH07XG4gIH1cbiAgZ2V0IGZvcm1FcnJvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpO1xuICB9XG59XG5wcy5jcmVhdGUgPSAocykgPT4gbmV3IHBzKHMpO1xuY29uc3QgS2wgPSAocywgZSkgPT4ge1xuICBsZXQgdDtcbiAgc3dpdGNoIChzLmNvZGUpIHtcbiAgICBjYXNlIGFlLmludmFsaWRfdHlwZTpcbiAgICAgIHMucmVjZWl2ZWQgPT09IG1lLnVuZGVmaW5lZCA/IHQgPSBcIlJlcXVpcmVkXCIgOiB0ID0gYEV4cGVjdGVkICR7cy5leHBlY3RlZH0sIHJlY2VpdmVkICR7cy5yZWNlaXZlZH1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhZS5pbnZhbGlkX2xpdGVyYWw6XG4gICAgICB0ID0gYEludmFsaWQgbGl0ZXJhbCB2YWx1ZSwgZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShzLmV4cGVjdGVkLCBaZS5qc29uU3RyaW5naWZ5UmVwbGFjZXIpfWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFlLnVucmVjb2duaXplZF9rZXlzOlxuICAgICAgdCA9IGBVbnJlY29nbml6ZWQga2V5KHMpIGluIG9iamVjdDogJHtaZS5qb2luVmFsdWVzKHMua2V5cywgXCIsIFwiKX1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhZS5pbnZhbGlkX3VuaW9uOlxuICAgICAgdCA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3I6XG4gICAgICB0ID0gYEludmFsaWQgZGlzY3JpbWluYXRvciB2YWx1ZS4gRXhwZWN0ZWQgJHtaZS5qb2luVmFsdWVzKHMub3B0aW9ucyl9YDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYWUuaW52YWxpZF9lbnVtX3ZhbHVlOlxuICAgICAgdCA9IGBJbnZhbGlkIGVudW0gdmFsdWUuIEV4cGVjdGVkICR7WmUuam9pblZhbHVlcyhzLm9wdGlvbnMpfSwgcmVjZWl2ZWQgJyR7cy5yZWNlaXZlZH0nYDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYWUuaW52YWxpZF9hcmd1bWVudHM6XG4gICAgICB0ID0gXCJJbnZhbGlkIGZ1bmN0aW9uIGFyZ3VtZW50c1wiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhZS5pbnZhbGlkX3JldHVybl90eXBlOlxuICAgICAgdCA9IFwiSW52YWxpZCBmdW5jdGlvbiByZXR1cm4gdHlwZVwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhZS5pbnZhbGlkX2RhdGU6XG4gICAgICB0ID0gXCJJbnZhbGlkIGRhdGVcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYWUuaW52YWxpZF9zdHJpbmc6XG4gICAgICB0eXBlb2Ygcy52YWxpZGF0aW9uID09IFwib2JqZWN0XCIgPyBcImluY2x1ZGVzXCIgaW4gcy52YWxpZGF0aW9uID8gKHQgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBpbmNsdWRlIFwiJHtzLnZhbGlkYXRpb24uaW5jbHVkZXN9XCJgLCB0eXBlb2Ygcy52YWxpZGF0aW9uLnBvc2l0aW9uID09IFwibnVtYmVyXCIgJiYgKHQgPSBgJHt0fSBhdCBvbmUgb3IgbW9yZSBwb3NpdGlvbnMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7cy52YWxpZGF0aW9uLnBvc2l0aW9ufWApKSA6IFwic3RhcnRzV2l0aFwiIGluIHMudmFsaWRhdGlvbiA/IHQgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBzdGFydCB3aXRoIFwiJHtzLnZhbGlkYXRpb24uc3RhcnRzV2l0aH1cImAgOiBcImVuZHNXaXRoXCIgaW4gcy52YWxpZGF0aW9uID8gdCA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGVuZCB3aXRoIFwiJHtzLnZhbGlkYXRpb24uZW5kc1dpdGh9XCJgIDogWmUuYXNzZXJ0TmV2ZXIocy52YWxpZGF0aW9uKSA6IHMudmFsaWRhdGlvbiAhPT0gXCJyZWdleFwiID8gdCA9IGBJbnZhbGlkICR7cy52YWxpZGF0aW9ufWAgOiB0ID0gXCJJbnZhbGlkXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFlLnRvb19zbWFsbDpcbiAgICAgIHMudHlwZSA9PT0gXCJhcnJheVwiID8gdCA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtzLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBzLmluY2x1c2l2ZSA/IFwiYXQgbGVhc3RcIiA6IFwibW9yZSB0aGFuXCJ9ICR7cy5taW5pbXVtfSBlbGVtZW50KHMpYCA6IHMudHlwZSA9PT0gXCJzdHJpbmdcIiA/IHQgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke3MuZXhhY3QgPyBcImV4YWN0bHlcIiA6IHMuaW5jbHVzaXZlID8gXCJhdCBsZWFzdFwiIDogXCJvdmVyXCJ9ICR7cy5taW5pbXVtfSBjaGFyYWN0ZXIocylgIDogcy50eXBlID09PSBcIm51bWJlclwiID8gdCA9IGBOdW1iZXIgbXVzdCBiZSAke3MuZXhhY3QgPyBcImV4YWN0bHkgZXF1YWwgdG8gXCIgOiBzLmluY2x1c2l2ZSA/IFwiZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIFwiIDogXCJncmVhdGVyIHRoYW4gXCJ9JHtzLm1pbmltdW19YCA6IHMudHlwZSA9PT0gXCJiaWdpbnRcIiA/IHQgPSBgTnVtYmVyIG11c3QgYmUgJHtzLmV4YWN0ID8gXCJleGFjdGx5IGVxdWFsIHRvIFwiIDogcy5pbmNsdXNpdmUgPyBcImdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBcIiA6IFwiZ3JlYXRlciB0aGFuIFwifSR7cy5taW5pbXVtfWAgOiBzLnR5cGUgPT09IFwiZGF0ZVwiID8gdCA9IGBEYXRlIG11c3QgYmUgJHtzLmV4YWN0ID8gXCJleGFjdGx5IGVxdWFsIHRvIFwiIDogcy5pbmNsdXNpdmUgPyBcImdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBcIiA6IFwiZ3JlYXRlciB0aGFuIFwifSR7bmV3IERhdGUoTnVtYmVyKHMubWluaW11bSkpfWAgOiB0ID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFlLnRvb19iaWc6XG4gICAgICBzLnR5cGUgPT09IFwiYXJyYXlcIiA/IHQgPSBgQXJyYXkgbXVzdCBjb250YWluICR7cy5leGFjdCA/IFwiZXhhY3RseVwiIDogcy5pbmNsdXNpdmUgPyBcImF0IG1vc3RcIiA6IFwibGVzcyB0aGFuXCJ9ICR7cy5tYXhpbXVtfSBlbGVtZW50KHMpYCA6IHMudHlwZSA9PT0gXCJzdHJpbmdcIiA/IHQgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke3MuZXhhY3QgPyBcImV4YWN0bHlcIiA6IHMuaW5jbHVzaXZlID8gXCJhdCBtb3N0XCIgOiBcInVuZGVyXCJ9ICR7cy5tYXhpbXVtfSBjaGFyYWN0ZXIocylgIDogcy50eXBlID09PSBcIm51bWJlclwiID8gdCA9IGBOdW1iZXIgbXVzdCBiZSAke3MuZXhhY3QgPyBcImV4YWN0bHlcIiA6IHMuaW5jbHVzaXZlID8gXCJsZXNzIHRoYW4gb3IgZXF1YWwgdG9cIiA6IFwibGVzcyB0aGFuXCJ9ICR7cy5tYXhpbXVtfWAgOiBzLnR5cGUgPT09IFwiYmlnaW50XCIgPyB0ID0gYEJpZ0ludCBtdXN0IGJlICR7cy5leGFjdCA/IFwiZXhhY3RseVwiIDogcy5pbmNsdXNpdmUgPyBcImxlc3MgdGhhbiBvciBlcXVhbCB0b1wiIDogXCJsZXNzIHRoYW5cIn0gJHtzLm1heGltdW19YCA6IHMudHlwZSA9PT0gXCJkYXRlXCIgPyB0ID0gYERhdGUgbXVzdCBiZSAke3MuZXhhY3QgPyBcImV4YWN0bHlcIiA6IHMuaW5jbHVzaXZlID8gXCJzbWFsbGVyIHRoYW4gb3IgZXF1YWwgdG9cIiA6IFwic21hbGxlciB0aGFuXCJ9ICR7bmV3IERhdGUoTnVtYmVyKHMubWF4aW11bSkpfWAgOiB0ID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFlLmN1c3RvbTpcbiAgICAgIHQgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgYWUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXM6XG4gICAgICB0ID0gXCJJbnRlcnNlY3Rpb24gcmVzdWx0cyBjb3VsZCBub3QgYmUgbWVyZ2VkXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGFlLm5vdF9tdWx0aXBsZV9vZjpcbiAgICAgIHQgPSBgTnVtYmVyIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAke3MubXVsdGlwbGVPZn1gO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBhZS5ub3RfZmluaXRlOlxuICAgICAgdCA9IFwiTnVtYmVyIG11c3QgYmUgZmluaXRlXCI7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdCA9IGUuZGVmYXVsdEVycm9yLCBaZS5hc3NlcnROZXZlcihzKTtcbiAgfVxuICByZXR1cm4geyBtZXNzYWdlOiB0IH07XG59O1xubGV0IFJtID0gS2w7XG5mdW5jdGlvbiBMbSgpIHtcbiAgcmV0dXJuIFJtO1xufVxuY29uc3QgQ20gPSAocykgPT4ge1xuICBjb25zdCB7IGRhdGE6IGUsIHBhdGg6IHQsIGVycm9yTWFwczogciwgaXNzdWVEYXRhOiBuIH0gPSBzLCBpID0gWy4uLnQsIC4uLm4ucGF0aCB8fCBbXV0sIG8gPSB7XG4gICAgLi4ubixcbiAgICBwYXRoOiBpXG4gIH07XG4gIGlmIChuLm1lc3NhZ2UgIT09IHZvaWQgMClcbiAgICByZXR1cm4ge1xuICAgICAgLi4ubixcbiAgICAgIHBhdGg6IGksXG4gICAgICBtZXNzYWdlOiBuLm1lc3NhZ2VcbiAgICB9O1xuICBsZXQgYSA9IFwiXCI7XG4gIGNvbnN0IGwgPSByLmZpbHRlcigoYykgPT4gISFjKS5zbGljZSgpLnJldmVyc2UoKTtcbiAgZm9yIChjb25zdCBjIG9mIGwpXG4gICAgYSA9IGMobywgeyBkYXRhOiBlLCBkZWZhdWx0RXJyb3I6IGEgfSkubWVzc2FnZTtcbiAgcmV0dXJuIHtcbiAgICAuLi5uLFxuICAgIHBhdGg6IGksXG4gICAgbWVzc2FnZTogYVxuICB9O1xufTtcbmZ1bmN0aW9uIGhlKHMsIGUpIHtcbiAgY29uc3QgdCA9IExtKCksIHIgPSBDbSh7XG4gICAgaXNzdWVEYXRhOiBlLFxuICAgIGRhdGE6IHMuZGF0YSxcbiAgICBwYXRoOiBzLnBhdGgsXG4gICAgZXJyb3JNYXBzOiBbXG4gICAgICBzLmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAvLyBjb250ZXh0dWFsIGVycm9yIG1hcCBpcyBmaXJzdCBwcmlvcml0eVxuICAgICAgcy5zY2hlbWFFcnJvck1hcCxcbiAgICAgIC8vIHRoZW4gc2NoZW1hLWJvdW5kIG1hcCBpZiBhdmFpbGFibGVcbiAgICAgIHQsXG4gICAgICAvLyB0aGVuIGdsb2JhbCBvdmVycmlkZSBtYXBcbiAgICAgIHQgPT09IEtsID8gdm9pZCAwIDogS2xcbiAgICAgIC8vIHRoZW4gZ2xvYmFsIGRlZmF1bHQgbWFwXG4gICAgXS5maWx0ZXIoKG4pID0+ICEhbilcbiAgfSk7XG4gIHMuY29tbW9uLmlzc3Vlcy5wdXNoKHIpO1xufVxuY2xhc3Mgd3Ige1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnZhbHVlID0gXCJ2YWxpZFwiO1xuICB9XG4gIGRpcnR5KCkge1xuICAgIHRoaXMudmFsdWUgPT09IFwidmFsaWRcIiAmJiAodGhpcy52YWx1ZSA9IFwiZGlydHlcIik7XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgdGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIgJiYgKHRoaXMudmFsdWUgPSBcImFib3J0ZWRcIik7XG4gIH1cbiAgc3RhdGljIG1lcmdlQXJyYXkoZSwgdCkge1xuICAgIGNvbnN0IHIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG4gb2YgdCkge1xuICAgICAgaWYgKG4uc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgcmV0dXJuIFJlO1xuICAgICAgbi5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiBlLmRpcnR5KCksIHIucHVzaChuLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBlLnZhbHVlLCB2YWx1ZTogciB9O1xuICB9XG4gIHN0YXRpYyBhc3luYyBtZXJnZU9iamVjdEFzeW5jKGUsIHQpIHtcbiAgICBjb25zdCByID0gW107XG4gICAgZm9yIChjb25zdCBuIG9mIHQpIHtcbiAgICAgIGNvbnN0IGkgPSBhd2FpdCBuLmtleSwgbyA9IGF3YWl0IG4udmFsdWU7XG4gICAgICByLnB1c2goe1xuICAgICAgICBrZXk6IGksXG4gICAgICAgIHZhbHVlOiBvXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHdyLm1lcmdlT2JqZWN0U3luYyhlLCByKTtcbiAgfVxuICBzdGF0aWMgbWVyZ2VPYmplY3RTeW5jKGUsIHQpIHtcbiAgICBjb25zdCByID0ge307XG4gICAgZm9yIChjb25zdCBuIG9mIHQpIHtcbiAgICAgIGNvbnN0IHsga2V5OiBpLCB2YWx1ZTogbyB9ID0gbjtcbiAgICAgIGlmIChpLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgby5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICByZXR1cm4gUmU7XG4gICAgICBpLnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmIGUuZGlydHkoKSwgby5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiBlLmRpcnR5KCksIGkudmFsdWUgIT09IFwiX19wcm90b19fXCIgJiYgKHR5cGVvZiBvLnZhbHVlIDwgXCJ1XCIgfHwgbi5hbHdheXNTZXQpICYmIChyW2kudmFsdWVdID0gby52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXR1czogZS52YWx1ZSwgdmFsdWU6IHIgfTtcbiAgfVxufVxuY29uc3QgUmUgPSBPYmplY3QuZnJlZXplKHtcbiAgc3RhdHVzOiBcImFib3J0ZWRcIlxufSksIFduID0gKHMpID0+ICh7IHN0YXR1czogXCJkaXJ0eVwiLCB2YWx1ZTogcyB9KSwgUnIgPSAocykgPT4gKHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBzIH0pLCBadSA9IChzKSA9PiBzLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIsIFh1ID0gKHMpID0+IHMuc3RhdHVzID09PSBcImRpcnR5XCIsIExuID0gKHMpID0+IHMuc3RhdHVzID09PSBcInZhbGlkXCIsIGJvID0gKHMpID0+IHR5cGVvZiBQcm9taXNlIDwgXCJ1XCIgJiYgcyBpbnN0YW5jZW9mIFByb21pc2U7XG52YXIgRWU7XG4oZnVuY3Rpb24ocykge1xuICBzLmVyclRvT2JqID0gKGUpID0+IHR5cGVvZiBlID09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IGUgfSA6IGUgfHwge30sIHMudG9TdHJpbmcgPSAoZSkgPT4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IGUgOiBlID09IG51bGwgPyB2b2lkIDAgOiBlLm1lc3NhZ2U7XG59KShFZSB8fCAoRWUgPSB7fSkpO1xuY2xhc3MgRHMge1xuICBjb25zdHJ1Y3RvcihlLCB0LCByLCBuKSB7XG4gICAgdGhpcy5fY2FjaGVkUGF0aCA9IFtdLCB0aGlzLnBhcmVudCA9IGUsIHRoaXMuZGF0YSA9IHQsIHRoaXMuX3BhdGggPSByLCB0aGlzLl9rZXkgPSBuO1xuICB9XG4gIGdldCBwYXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9jYWNoZWRQYXRoLmxlbmd0aCB8fCAoQXJyYXkuaXNBcnJheSh0aGlzLl9rZXkpID8gdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIC4uLnRoaXMuX2tleSkgOiB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgdGhpcy5fa2V5KSksIHRoaXMuX2NhY2hlZFBhdGg7XG4gIH1cbn1cbmNvbnN0IEp1ID0gKHMsIGUpID0+IHtcbiAgaWYgKExuKGUpKVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6ICEwLCBkYXRhOiBlLnZhbHVlIH07XG4gIGlmICghcy5jb21tb24uaXNzdWVzLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZGF0aW9uIGZhaWxlZCBidXQgbm8gaXNzdWVzIGRldGVjdGVkLlwiKTtcbiAgcmV0dXJuIHtcbiAgICBzdWNjZXNzOiAhMSxcbiAgICBnZXQgZXJyb3IoKSB7XG4gICAgICBpZiAodGhpcy5fZXJyb3IpXG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgIGNvbnN0IHQgPSBuZXcgcHMocy5jb21tb24uaXNzdWVzKTtcbiAgICAgIHJldHVybiB0aGlzLl9lcnJvciA9IHQsIHRoaXMuX2Vycm9yO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBWZShzKSB7XG4gIGlmICghcylcbiAgICByZXR1cm4ge307XG4gIGNvbnN0IHsgZXJyb3JNYXA6IGUsIGludmFsaWRfdHlwZV9lcnJvcjogdCwgcmVxdWlyZWRfZXJyb3I6IHIsIGRlc2NyaXB0aW9uOiBuIH0gPSBzO1xuICBpZiAoZSAmJiAodCB8fCByKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHVzZSBcImludmFsaWRfdHlwZV9lcnJvclwiIG9yIFwicmVxdWlyZWRfZXJyb3JcIiBpbiBjb25qdW5jdGlvbiB3aXRoIGN1c3RvbSBlcnJvciBtYXAuYCk7XG4gIHJldHVybiBlID8geyBlcnJvck1hcDogZSwgZGVzY3JpcHRpb246IG4gfSA6IHsgZXJyb3JNYXA6IChvLCBhKSA9PiB7XG4gICAgY29uc3QgeyBtZXNzYWdlOiBsIH0gPSBzO1xuICAgIHJldHVybiBvLmNvZGUgPT09IFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIgPyB7IG1lc3NhZ2U6IGwgPz8gYS5kZWZhdWx0RXJyb3IgfSA6IHR5cGVvZiBhLmRhdGEgPiBcInVcIiA/IHsgbWVzc2FnZTogbCA/PyByID8/IGEuZGVmYXVsdEVycm9yIH0gOiBvLmNvZGUgIT09IFwiaW52YWxpZF90eXBlXCIgPyB7IG1lc3NhZ2U6IGEuZGVmYXVsdEVycm9yIH0gOiB7IG1lc3NhZ2U6IGwgPz8gdCA/PyBhLmRlZmF1bHRFcnJvciB9O1xuICB9LCBkZXNjcmlwdGlvbjogbiB9O1xufVxuY2xhc3MgWWUge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5kZXNjcmlwdGlvbjtcbiAgfVxuICBfZ2V0VHlwZShlKSB7XG4gICAgcmV0dXJuIHdzKGUuZGF0YSk7XG4gIH1cbiAgX2dldE9yUmV0dXJuQ3R4KGUsIHQpIHtcbiAgICByZXR1cm4gdCB8fCB7XG4gICAgICBjb21tb246IGUucGFyZW50LmNvbW1vbixcbiAgICAgIGRhdGE6IGUuZGF0YSxcbiAgICAgIHBhcnNlZFR5cGU6IHdzKGUuZGF0YSksXG4gICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgcGF0aDogZS5wYXRoLFxuICAgICAgcGFyZW50OiBlLnBhcmVudFxuICAgIH07XG4gIH1cbiAgX3Byb2Nlc3NJbnB1dFBhcmFtcyhlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogbmV3IHdyKCksXG4gICAgICBjdHg6IHtcbiAgICAgICAgY29tbW9uOiBlLnBhcmVudC5jb21tb24sXG4gICAgICAgIGRhdGE6IGUuZGF0YSxcbiAgICAgICAgcGFyc2VkVHlwZTogd3MoZS5kYXRhKSxcbiAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgcGF0aDogZS5wYXRoLFxuICAgICAgICBwYXJlbnQ6IGUucGFyZW50XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBfcGFyc2VTeW5jKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fcGFyc2UoZSk7XG4gICAgaWYgKGJvKHQpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3luY2hyb25vdXMgcGFyc2UgZW5jb3VudGVyZWQgcHJvbWlzZS5cIik7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgX3BhcnNlQXN5bmMoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9wYXJzZShlKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHQpO1xuICB9XG4gIHBhcnNlKGUsIHQpIHtcbiAgICBjb25zdCByID0gdGhpcy5zYWZlUGFyc2UoZSwgdCk7XG4gICAgaWYgKHIuc3VjY2VzcylcbiAgICAgIHJldHVybiByLmRhdGE7XG4gICAgdGhyb3cgci5lcnJvcjtcbiAgfVxuICBzYWZlUGFyc2UoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB7XG4gICAgICBjb21tb246IHtcbiAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgYXN5bmM6ICh0ID09IG51bGwgPyB2b2lkIDAgOiB0LmFzeW5jKSA/PyAhMSxcbiAgICAgICAgY29udGV4dHVhbEVycm9yTWFwOiB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmVycm9yTWFwXG4gICAgICB9LFxuICAgICAgcGF0aDogKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQucGF0aCkgfHwgW10sXG4gICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgZGF0YTogZSxcbiAgICAgIHBhcnNlZFR5cGU6IHdzKGUpXG4gICAgfSwgbiA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGE6IGUsIHBhdGg6IHIucGF0aCwgcGFyZW50OiByIH0pO1xuICAgIHJldHVybiBKdShyLCBuKTtcbiAgfVxuICBcIn52YWxpZGF0ZVwiKGUpIHtcbiAgICB2YXIgciwgbjtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgY29tbW9uOiB7XG4gICAgICAgIGlzc3VlczogW10sXG4gICAgICAgIGFzeW5jOiAhIXRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmNcbiAgICAgIH0sXG4gICAgICBwYXRoOiBbXSxcbiAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICBkYXRhOiBlLFxuICAgICAgcGFyc2VkVHlwZTogd3MoZSlcbiAgICB9O1xuICAgIGlmICghdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYylcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLl9wYXJzZVN5bmMoeyBkYXRhOiBlLCBwYXRoOiBbXSwgcGFyZW50OiB0IH0pO1xuICAgICAgICByZXR1cm4gTG4oaSkgPyB7XG4gICAgICAgICAgdmFsdWU6IGkudmFsdWVcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICBpc3N1ZXM6IHQuY29tbW9uLmlzc3Vlc1xuICAgICAgICB9O1xuICAgICAgfSBjYXRjaCAoaSkge1xuICAgICAgICAobiA9IChyID0gaSA9PSBudWxsID8gdm9pZCAwIDogaS5tZXNzYWdlKSA9PSBudWxsID8gdm9pZCAwIDogci50b0xvd2VyQ2FzZSgpKSAhPSBudWxsICYmIG4uaW5jbHVkZXMoXCJlbmNvdW50ZXJlZFwiKSAmJiAodGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYyA9ICEwKSwgdC5jb21tb24gPSB7XG4gICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICBhc3luYzogITBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcGFyc2VBc3luYyh7IGRhdGE6IGUsIHBhdGg6IFtdLCBwYXJlbnQ6IHQgfSkudGhlbigoaSkgPT4gTG4oaSkgPyB7XG4gICAgICB2YWx1ZTogaS52YWx1ZVxuICAgIH0gOiB7XG4gICAgICBpc3N1ZXM6IHQuY29tbW9uLmlzc3Vlc1xuICAgIH0pO1xuICB9XG4gIGFzeW5jIHBhcnNlQXN5bmMoZSwgdCkge1xuICAgIGNvbnN0IHIgPSBhd2FpdCB0aGlzLnNhZmVQYXJzZUFzeW5jKGUsIHQpO1xuICAgIGlmIChyLnN1Y2Nlc3MpXG4gICAgICByZXR1cm4gci5kYXRhO1xuICAgIHRocm93IHIuZXJyb3I7XG4gIH1cbiAgYXN5bmMgc2FmZVBhcnNlQXN5bmMoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB7XG4gICAgICBjb21tb246IHtcbiAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgY29udGV4dHVhbEVycm9yTWFwOiB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmVycm9yTWFwLFxuICAgICAgICBhc3luYzogITBcbiAgICAgIH0sXG4gICAgICBwYXRoOiAodCA9PSBudWxsID8gdm9pZCAwIDogdC5wYXRoKSB8fCBbXSxcbiAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICBkYXRhOiBlLFxuICAgICAgcGFyc2VkVHlwZTogd3MoZSlcbiAgICB9LCBuID0gdGhpcy5fcGFyc2UoeyBkYXRhOiBlLCBwYXRoOiByLnBhdGgsIHBhcmVudDogciB9KSwgaSA9IGF3YWl0IChibyhuKSA/IG4gOiBQcm9taXNlLnJlc29sdmUobikpO1xuICAgIHJldHVybiBKdShyLCBpKTtcbiAgfVxuICByZWZpbmUoZSwgdCkge1xuICAgIGNvbnN0IHIgPSAobikgPT4gdHlwZW9mIHQgPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdCA+IFwidVwiID8geyBtZXNzYWdlOiB0IH0gOiB0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyB0KG4pIDogdDtcbiAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgobiwgaSkgPT4ge1xuICAgICAgY29uc3QgbyA9IGUobiksIGEgPSAoKSA9PiBpLmFkZElzc3VlKHtcbiAgICAgICAgY29kZTogYWUuY3VzdG9tLFxuICAgICAgICAuLi5yKG4pXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0eXBlb2YgUHJvbWlzZSA8IFwidVwiICYmIG8gaW5zdGFuY2VvZiBQcm9taXNlID8gby50aGVuKChsKSA9PiBsID8gITAgOiAoYSgpLCAhMSkpIDogbyA/ICEwIDogKGEoKSwgITEpO1xuICAgIH0pO1xuICB9XG4gIHJlZmluZW1lbnQoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KChyLCBuKSA9PiBlKHIpID8gITAgOiAobi5hZGRJc3N1ZSh0eXBlb2YgdCA9PSBcImZ1bmN0aW9uXCIgPyB0KHIsIG4pIDogdCksICExKSk7XG4gIH1cbiAgX3JlZmluZW1lbnQoZSkge1xuICAgIHJldHVybiBuZXcgWXMoe1xuICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgdHlwZU5hbWU6IGtlLlpvZEVmZmVjdHMsXG4gICAgICBlZmZlY3Q6IHsgdHlwZTogXCJyZWZpbmVtZW50XCIsIHJlZmluZW1lbnQ6IGUgfVxuICAgIH0pO1xuICB9XG4gIHN1cGVyUmVmaW5lKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudChlKTtcbiAgfVxuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5zcGEgPSB0aGlzLnNhZmVQYXJzZUFzeW5jLCB0aGlzLl9kZWYgPSBlLCB0aGlzLnBhcnNlID0gdGhpcy5wYXJzZS5iaW5kKHRoaXMpLCB0aGlzLnNhZmVQYXJzZSA9IHRoaXMuc2FmZVBhcnNlLmJpbmQodGhpcyksIHRoaXMucGFyc2VBc3luYyA9IHRoaXMucGFyc2VBc3luYy5iaW5kKHRoaXMpLCB0aGlzLnNhZmVQYXJzZUFzeW5jID0gdGhpcy5zYWZlUGFyc2VBc3luYy5iaW5kKHRoaXMpLCB0aGlzLnNwYSA9IHRoaXMuc3BhLmJpbmQodGhpcyksIHRoaXMucmVmaW5lID0gdGhpcy5yZWZpbmUuYmluZCh0aGlzKSwgdGhpcy5yZWZpbmVtZW50ID0gdGhpcy5yZWZpbmVtZW50LmJpbmQodGhpcyksIHRoaXMuc3VwZXJSZWZpbmUgPSB0aGlzLnN1cGVyUmVmaW5lLmJpbmQodGhpcyksIHRoaXMub3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsLmJpbmQodGhpcyksIHRoaXMubnVsbGFibGUgPSB0aGlzLm51bGxhYmxlLmJpbmQodGhpcyksIHRoaXMubnVsbGlzaCA9IHRoaXMubnVsbGlzaC5iaW5kKHRoaXMpLCB0aGlzLmFycmF5ID0gdGhpcy5hcnJheS5iaW5kKHRoaXMpLCB0aGlzLnByb21pc2UgPSB0aGlzLnByb21pc2UuYmluZCh0aGlzKSwgdGhpcy5vciA9IHRoaXMub3IuYmluZCh0aGlzKSwgdGhpcy5hbmQgPSB0aGlzLmFuZC5iaW5kKHRoaXMpLCB0aGlzLnRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLmJpbmQodGhpcyksIHRoaXMuYnJhbmQgPSB0aGlzLmJyYW5kLmJpbmQodGhpcyksIHRoaXMuZGVmYXVsdCA9IHRoaXMuZGVmYXVsdC5iaW5kKHRoaXMpLCB0aGlzLmNhdGNoID0gdGhpcy5jYXRjaC5iaW5kKHRoaXMpLCB0aGlzLmRlc2NyaWJlID0gdGhpcy5kZXNjcmliZS5iaW5kKHRoaXMpLCB0aGlzLnBpcGUgPSB0aGlzLnBpcGUuYmluZCh0aGlzKSwgdGhpcy5yZWFkb25seSA9IHRoaXMucmVhZG9ubHkuYmluZCh0aGlzKSwgdGhpcy5pc051bGxhYmxlID0gdGhpcy5pc051bGxhYmxlLmJpbmQodGhpcyksIHRoaXMuaXNPcHRpb25hbCA9IHRoaXMuaXNPcHRpb25hbC5iaW5kKHRoaXMpLCB0aGlzW1wifnN0YW5kYXJkXCJdID0ge1xuICAgICAgdmVyc2lvbjogMSxcbiAgICAgIHZlbmRvcjogXCJ6b2RcIixcbiAgICAgIHZhbGlkYXRlOiAodCkgPT4gdGhpc1tcIn52YWxpZGF0ZVwiXSh0KVxuICAgIH07XG4gIH1cbiAgb3B0aW9uYWwoKSB7XG4gICAgcmV0dXJuIGZzLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICB9XG4gIG51bGxhYmxlKCkge1xuICAgIHJldHVybiBacy5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgfVxuICBudWxsaXNoKCkge1xuICAgIHJldHVybiB0aGlzLm51bGxhYmxlKCkub3B0aW9uYWwoKTtcbiAgfVxuICBhcnJheSgpIHtcbiAgICByZXR1cm4gWXIuY3JlYXRlKHRoaXMpO1xuICB9XG4gIHByb21pc2UoKSB7XG4gICAgcmV0dXJuIF9vLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICB9XG4gIG9yKGUpIHtcbiAgICByZXR1cm4gd28uY3JlYXRlKFt0aGlzLCBlXSwgdGhpcy5fZGVmKTtcbiAgfVxuICBhbmQoZSkge1xuICAgIHJldHVybiBBby5jcmVhdGUodGhpcywgZSwgdGhpcy5fZGVmKTtcbiAgfVxuICB0cmFuc2Zvcm0oZSkge1xuICAgIHJldHVybiBuZXcgWXMoe1xuICAgICAgLi4uVmUodGhpcy5fZGVmKSxcbiAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgIHR5cGVOYW1lOiBrZS5ab2RFZmZlY3RzLFxuICAgICAgZWZmZWN0OiB7IHR5cGU6IFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybTogZSB9XG4gICAgfSk7XG4gIH1cbiAgZGVmYXVsdChlKSB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBlID09IFwiZnVuY3Rpb25cIiA/IGUgOiAoKSA9PiBlO1xuICAgIHJldHVybiBuZXcgUm8oe1xuICAgICAgLi4uVmUodGhpcy5fZGVmKSxcbiAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgIGRlZmF1bHRWYWx1ZTogdCxcbiAgICAgIHR5cGVOYW1lOiBrZS5ab2REZWZhdWx0XG4gICAgfSk7XG4gIH1cbiAgYnJhbmQoKSB7XG4gICAgcmV0dXJuIG5ldyBVZih7XG4gICAgICB0eXBlTmFtZToga2UuWm9kQnJhbmRlZCxcbiAgICAgIHR5cGU6IHRoaXMsXG4gICAgICAuLi5WZSh0aGlzLl9kZWYpXG4gICAgfSk7XG4gIH1cbiAgY2F0Y2goZSkge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZSA9PSBcImZ1bmN0aW9uXCIgPyBlIDogKCkgPT4gZTtcbiAgICByZXR1cm4gbmV3IExvKHtcbiAgICAgIC4uLlZlKHRoaXMuX2RlZiksXG4gICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICBjYXRjaFZhbHVlOiB0LFxuICAgICAgdHlwZU5hbWU6IGtlLlpvZENhdGNoXG4gICAgfSk7XG4gIH1cbiAgZGVzY3JpYmUoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBuZXcgdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBkZXNjcmlwdGlvbjogZVxuICAgIH0pO1xuICB9XG4gIHBpcGUoZSkge1xuICAgIHJldHVybiAkYy5jcmVhdGUodGhpcywgZSk7XG4gIH1cbiAgcmVhZG9ubHkoKSB7XG4gICAgcmV0dXJuIENvLmNyZWF0ZSh0aGlzKTtcbiAgfVxuICBpc09wdGlvbmFsKCkge1xuICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZSh2b2lkIDApLnN1Y2Nlc3M7XG4gIH1cbiAgaXNOdWxsYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zYWZlUGFyc2UobnVsbCkuc3VjY2VzcztcbiAgfVxufVxuY29uc3Qga20gPSAvXmNbXlxccy1dezgsfSQvaSwgRG0gPSAvXlswLTlhLXpdKyQvLCBQbSA9IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvaSwgTW0gPSAvXlswLTlhLWZBLUZdezh9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezEyfSQvaSwgT20gPSAvXlthLXowLTlfLV17MjF9JC9pLCBCbSA9IC9eW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10qJC8sIEZtID0gL15bLStdP1AoPyEkKSg/Oig/OlstK10/XFxkK1kpfCg/OlstK10/XFxkK1suLF1cXGQrWSQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86KD86Wy0rXT9cXGQrVyl8KD86Wy0rXT9cXGQrWy4sXVxcZCtXJCkpPyg/Oig/OlstK10/XFxkK0QpfCg/OlstK10/XFxkK1suLF1cXGQrRCQpKT8oPzpUKD89W1xcZCstXSkoPzooPzpbLStdP1xcZCtIKXwoPzpbLStdP1xcZCtbLixdXFxkK0gkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/OlstK10/XFxkKyg/OlsuLF1cXGQrKT9TKT8pPz8kLywgTm0gPSAvXig/IVxcLikoPyEuKlxcLlxcLikoW0EtWjAtOV8nK1xcLVxcLl0qKVtBLVowLTlfKy1dQChbQS1aMC05XVtBLVowLTlcXC1dKlxcLikrW0EtWl17Mix9JC9pLCBVbSA9IFwiXihcXFxccHtFeHRlbmRlZF9QaWN0b2dyYXBoaWN9fFxcXFxwe0Vtb2ppX0NvbXBvbmVudH0pKyRcIjtcbmxldCAkYTtcbmNvbnN0ICRtID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSkkLywgR20gPSAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLygzWzAtMl18WzEyXT9bMC05XSkkLywgVm0gPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSkkLywgam0gPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSlcXC8oMTJbMC04XXwxWzAxXVswLTldfFsxLTldP1swLTldKSQvLCBLbSA9IC9eKFswLTlhLXpBLVorL117NH0pKigoWzAtOWEtekEtWisvXXsyfT09KXwoWzAtOWEtekEtWisvXXszfT0pKT8kLywgSG0gPSAvXihbMC05YS16QS1aLV9dezR9KSooKFswLTlhLXpBLVotX117Mn0oPT0pPyl8KFswLTlhLXpBLVotX117M30oPSk/KSk/JC8sIEJmID0gXCIoKFxcXFxkXFxcXGRbMjQ2OF1bMDQ4XXxcXFxcZFxcXFxkWzEzNTc5XVsyNl18XFxcXGRcXFxcZDBbNDhdfFswMjQ2OF1bMDQ4XTAwfFsxMzU3OV1bMjZdMDApLTAyLTI5fFxcXFxkezR9LSgoMFsxMzU3OF18MVswMl0pLSgwWzEtOV18WzEyXVxcXFxkfDNbMDFdKXwoMFs0NjldfDExKS0oMFsxLTldfFsxMl1cXFxcZHwzMCl8KDAyKS0oMFsxLTldfDFcXFxcZHwyWzAtOF0pKSlcIiwgcW0gPSBuZXcgUmVnRXhwKGBeJHtCZn0kYCk7XG5mdW5jdGlvbiBGZihzKSB7XG4gIGxldCBlID0gXCJbMC01XVxcXFxkXCI7XG4gIHMucHJlY2lzaW9uID8gZSA9IGAke2V9XFxcXC5cXFxcZHske3MucHJlY2lzaW9ufX1gIDogcy5wcmVjaXNpb24gPT0gbnVsbCAmJiAoZSA9IGAke2V9KFxcXFwuXFxcXGQrKT9gKTtcbiAgY29uc3QgdCA9IHMucHJlY2lzaW9uID8gXCIrXCIgOiBcIj9cIjtcbiAgcmV0dXJuIGAoWzAxXVxcXFxkfDJbMC0zXSk6WzAtNV1cXFxcZCg6JHtlfSkke3R9YDtcbn1cbmZ1bmN0aW9uIFdtKHMpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke0ZmKHMpfSRgKTtcbn1cbmZ1bmN0aW9uIHptKHMpIHtcbiAgbGV0IGUgPSBgJHtCZn1UJHtGZihzKX1gO1xuICBjb25zdCB0ID0gW107XG4gIHJldHVybiB0LnB1c2gocy5sb2NhbCA/IFwiWj9cIiA6IFwiWlwiKSwgcy5vZmZzZXQgJiYgdC5wdXNoKFwiKFsrLV1cXFxcZHsyfTo/XFxcXGR7Mn0pXCIpLCBlID0gYCR7ZX0oJHt0LmpvaW4oXCJ8XCIpfSlgLCBuZXcgUmVnRXhwKGBeJHtlfSRgKTtcbn1cbmZ1bmN0aW9uIFltKHMsIGUpIHtcbiAgcmV0dXJuICEhKChlID09PSBcInY0XCIgfHwgIWUpICYmICRtLnRlc3QocykgfHwgKGUgPT09IFwidjZcIiB8fCAhZSkgJiYgVm0udGVzdChzKSk7XG59XG5mdW5jdGlvbiBabShzLCBlKSB7XG4gIGlmICghQm0udGVzdChzKSlcbiAgICByZXR1cm4gITE7XG4gIHRyeSB7XG4gICAgY29uc3QgW3RdID0gcy5zcGxpdChcIi5cIik7XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHIgPSB0LnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpLnBhZEVuZCh0Lmxlbmd0aCArICg0IC0gdC5sZW5ndGggJSA0KSAlIDQsIFwiPVwiKSwgbiA9IEpTT04ucGFyc2UoYXRvYihyKSk7XG4gICAgcmV0dXJuICEodHlwZW9mIG4gIT0gXCJvYmplY3RcIiB8fCBuID09PSBudWxsIHx8IFwidHlwXCIgaW4gbiAmJiAobiA9PSBudWxsID8gdm9pZCAwIDogbi50eXApICE9PSBcIkpXVFwiIHx8ICFuLmFsZyB8fCBlICYmIG4uYWxnICE9PSBlKTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBYbShzLCBlKSB7XG4gIHJldHVybiAhISgoZSA9PT0gXCJ2NFwiIHx8ICFlKSAmJiBHbS50ZXN0KHMpIHx8IChlID09PSBcInY2XCIgfHwgIWUpICYmIGptLnRlc3QocykpO1xufVxuY2xhc3MgUnMgZXh0ZW5kcyBZZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UgJiYgKGUuZGF0YSA9IFN0cmluZyhlLmRhdGEpKSwgdGhpcy5fZ2V0VHlwZShlKSAhPT0gbWUuc3RyaW5nKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgICByZXR1cm4gaGUoaSwge1xuICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBtZS5zdHJpbmcsXG4gICAgICAgIHJlY2VpdmVkOiBpLnBhcnNlZFR5cGVcbiAgICAgIH0pLCBSZTtcbiAgICB9XG4gICAgY29uc3QgciA9IG5ldyB3cigpO1xuICAgIGxldCBuO1xuICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLl9kZWYuY2hlY2tzKVxuICAgICAgaWYgKGkua2luZCA9PT0gXCJtaW5cIilcbiAgICAgICAgZS5kYXRhLmxlbmd0aCA8IGkudmFsdWUgJiYgKG4gPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBuKSwgaGUobiwge1xuICAgICAgICAgIGNvZGU6IGFlLnRvb19zbWFsbCxcbiAgICAgICAgICBtaW5pbXVtOiBpLnZhbHVlLFxuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgICAgICBleGFjdDogITEsXG4gICAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICAgIH0pLCByLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoaS5raW5kID09PSBcIm1heFwiKVxuICAgICAgICBlLmRhdGEubGVuZ3RoID4gaS52YWx1ZSAmJiAobiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG4pLCBoZShuLCB7XG4gICAgICAgICAgY29kZTogYWUudG9vX2JpZyxcbiAgICAgICAgICBtYXhpbXVtOiBpLnZhbHVlLFxuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgICAgICBleGFjdDogITEsXG4gICAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICAgIH0pLCByLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoaS5raW5kID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgIGNvbnN0IG8gPSBlLmRhdGEubGVuZ3RoID4gaS52YWx1ZSwgYSA9IGUuZGF0YS5sZW5ndGggPCBpLnZhbHVlO1xuICAgICAgICAobyB8fCBhKSAmJiAobiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG4pLCBvID8gaGUobiwge1xuICAgICAgICAgIGNvZGU6IGFlLnRvb19iaWcsXG4gICAgICAgICAgbWF4aW11bTogaS52YWx1ZSxcbiAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICAgICAgZXhhY3Q6ICEwLFxuICAgICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgICB9KSA6IGEgJiYgaGUobiwge1xuICAgICAgICAgIGNvZGU6IGFlLnRvb19zbWFsbCxcbiAgICAgICAgICBtaW5pbXVtOiBpLnZhbHVlLFxuICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgICAgICBleGFjdDogITAsXG4gICAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICAgIH0pLCByLmRpcnR5KCkpO1xuICAgICAgfSBlbHNlIGlmIChpLmtpbmQgPT09IFwiZW1haWxcIilcbiAgICAgICAgTm0udGVzdChlLmRhdGEpIHx8IChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIGhlKG4sIHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtYWlsXCIsXG4gICAgICAgICAgY29kZTogYWUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICAgIH0pLCByLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoaS5raW5kID09PSBcImVtb2ppXCIpXG4gICAgICAgICRhIHx8ICgkYSA9IG5ldyBSZWdFeHAoVW0sIFwidVwiKSksICRhLnRlc3QoZS5kYXRhKSB8fCAobiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG4pLCBoZShuLCB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJlbW9qaVwiLFxuICAgICAgICAgIGNvZGU6IGFlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgICB9KSwgci5kaXJ0eSgpKTtcbiAgICAgIGVsc2UgaWYgKGkua2luZCA9PT0gXCJ1dWlkXCIpXG4gICAgICAgIE1tLnRlc3QoZS5kYXRhKSB8fCAobiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG4pLCBoZShuLCB7XG4gICAgICAgICAgdmFsaWRhdGlvbjogXCJ1dWlkXCIsXG4gICAgICAgICAgY29kZTogYWUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICAgIH0pLCByLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoaS5raW5kID09PSBcIm5hbm9pZFwiKVxuICAgICAgICBPbS50ZXN0KGUuZGF0YSkgfHwgKG4gPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBuKSwgaGUobiwge1xuICAgICAgICAgIHZhbGlkYXRpb246IFwibmFub2lkXCIsXG4gICAgICAgICAgY29kZTogYWUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICAgIH0pLCByLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoaS5raW5kID09PSBcImN1aWRcIilcbiAgICAgICAga20udGVzdChlLmRhdGEpIHx8IChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIGhlKG4sIHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWRcIixcbiAgICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICBtZXNzYWdlOiBpLm1lc3NhZ2VcbiAgICAgICAgfSksIHIuZGlydHkoKSk7XG4gICAgICBlbHNlIGlmIChpLmtpbmQgPT09IFwiY3VpZDJcIilcbiAgICAgICAgRG0udGVzdChlLmRhdGEpIHx8IChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIGhlKG4sIHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWQyXCIsXG4gICAgICAgICAgY29kZTogYWUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICAgIH0pLCByLmRpcnR5KCkpO1xuICAgICAgZWxzZSBpZiAoaS5raW5kID09PSBcInVsaWRcIilcbiAgICAgICAgUG0udGVzdChlLmRhdGEpIHx8IChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIGhlKG4sIHtcbiAgICAgICAgICB2YWxpZGF0aW9uOiBcInVsaWRcIixcbiAgICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICBtZXNzYWdlOiBpLm1lc3NhZ2VcbiAgICAgICAgfSksIHIuZGlydHkoKSk7XG4gICAgICBlbHNlIGlmIChpLmtpbmQgPT09IFwidXJsXCIpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbmV3IFVSTChlLmRhdGEpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICBuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIGhlKG4sIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXJsXCIsXG4gICAgICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgICAgIH0pLCByLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgIGVsc2UgaS5raW5kID09PSBcInJlZ2V4XCIgPyAoaS5yZWdleC5sYXN0SW5kZXggPSAwLCBpLnJlZ2V4LnRlc3QoZS5kYXRhKSB8fCAobiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG4pLCBoZShuLCB7XG4gICAgICAgIHZhbGlkYXRpb246IFwicmVnZXhcIixcbiAgICAgICAgY29kZTogYWUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIHIuZGlydHkoKSkpIDogaS5raW5kID09PSBcInRyaW1cIiA/IGUuZGF0YSA9IGUuZGF0YS50cmltKCkgOiBpLmtpbmQgPT09IFwiaW5jbHVkZXNcIiA/IGUuZGF0YS5pbmNsdWRlcyhpLnZhbHVlLCBpLnBvc2l0aW9uKSB8fCAobiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG4pLCBoZShuLCB7XG4gICAgICAgIGNvZGU6IGFlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICB2YWxpZGF0aW9uOiB7IGluY2x1ZGVzOiBpLnZhbHVlLCBwb3NpdGlvbjogaS5wb3NpdGlvbiB9LFxuICAgICAgICBtZXNzYWdlOiBpLm1lc3NhZ2VcbiAgICAgIH0pLCByLmRpcnR5KCkpIDogaS5raW5kID09PSBcInRvTG93ZXJDYXNlXCIgPyBlLmRhdGEgPSBlLmRhdGEudG9Mb3dlckNhc2UoKSA6IGkua2luZCA9PT0gXCJ0b1VwcGVyQ2FzZVwiID8gZS5kYXRhID0gZS5kYXRhLnRvVXBwZXJDYXNlKCkgOiBpLmtpbmQgPT09IFwic3RhcnRzV2l0aFwiID8gZS5kYXRhLnN0YXJ0c1dpdGgoaS52YWx1ZSkgfHwgKG4gPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBuKSwgaGUobiwge1xuICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgdmFsaWRhdGlvbjogeyBzdGFydHNXaXRoOiBpLnZhbHVlIH0sXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIHIuZGlydHkoKSkgOiBpLmtpbmQgPT09IFwiZW5kc1dpdGhcIiA/IGUuZGF0YS5lbmRzV2l0aChpLnZhbHVlKSB8fCAobiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG4pLCBoZShuLCB7XG4gICAgICAgIGNvZGU6IGFlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBpLnZhbHVlIH0sXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIHIuZGlydHkoKSkgOiBpLmtpbmQgPT09IFwiZGF0ZXRpbWVcIiA/IHptKGkpLnRlc3QoZS5kYXRhKSB8fCAobiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG4pLCBoZShuLCB7XG4gICAgICAgIGNvZGU6IGFlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGV0aW1lXCIsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIHIuZGlydHkoKSkgOiBpLmtpbmQgPT09IFwiZGF0ZVwiID8gcW0udGVzdChlLmRhdGEpIHx8IChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIGhlKG4sIHtcbiAgICAgICAgY29kZTogYWUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZVwiLFxuICAgICAgICBtZXNzYWdlOiBpLm1lc3NhZ2VcbiAgICAgIH0pLCByLmRpcnR5KCkpIDogaS5raW5kID09PSBcInRpbWVcIiA/IFdtKGkpLnRlc3QoZS5kYXRhKSB8fCAobiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG4pLCBoZShuLCB7XG4gICAgICAgIGNvZGU6IGFlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICB2YWxpZGF0aW9uOiBcInRpbWVcIixcbiAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICB9KSwgci5kaXJ0eSgpKSA6IGkua2luZCA9PT0gXCJkdXJhdGlvblwiID8gRm0udGVzdChlLmRhdGEpIHx8IChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIGhlKG4sIHtcbiAgICAgICAgdmFsaWRhdGlvbjogXCJkdXJhdGlvblwiLFxuICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICB9KSwgci5kaXJ0eSgpKSA6IGkua2luZCA9PT0gXCJpcFwiID8gWW0oZS5kYXRhLCBpLnZlcnNpb24pIHx8IChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIGhlKG4sIHtcbiAgICAgICAgdmFsaWRhdGlvbjogXCJpcFwiLFxuICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICB9KSwgci5kaXJ0eSgpKSA6IGkua2luZCA9PT0gXCJqd3RcIiA/IFptKGUuZGF0YSwgaS5hbGcpIHx8IChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIGhlKG4sIHtcbiAgICAgICAgdmFsaWRhdGlvbjogXCJqd3RcIixcbiAgICAgICAgY29kZTogYWUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIHIuZGlydHkoKSkgOiBpLmtpbmQgPT09IFwiY2lkclwiID8gWG0oZS5kYXRhLCBpLnZlcnNpb24pIHx8IChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIGhlKG4sIHtcbiAgICAgICAgdmFsaWRhdGlvbjogXCJjaWRyXCIsXG4gICAgICAgIGNvZGU6IGFlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICBtZXNzYWdlOiBpLm1lc3NhZ2VcbiAgICAgIH0pLCByLmRpcnR5KCkpIDogaS5raW5kID09PSBcImJhc2U2NFwiID8gS20udGVzdChlLmRhdGEpIHx8IChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIGhlKG4sIHtcbiAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjRcIixcbiAgICAgICAgY29kZTogYWUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIHIuZGlydHkoKSkgOiBpLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIgPyBIbS50ZXN0KGUuZGF0YSkgfHwgKG4gPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCBuKSwgaGUobiwge1xuICAgICAgICB2YWxpZGF0aW9uOiBcImJhc2U2NHVybFwiLFxuICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlXG4gICAgICB9KSwgci5kaXJ0eSgpKSA6IFplLmFzc2VydE5ldmVyKGkpO1xuICAgIHJldHVybiB7IHN0YXR1czogci52YWx1ZSwgdmFsdWU6IGUuZGF0YSB9O1xuICB9XG4gIF9yZWdleChlLCB0LCByKSB7XG4gICAgcmV0dXJuIHRoaXMucmVmaW5lbWVudCgobikgPT4gZS50ZXN0KG4pLCB7XG4gICAgICB2YWxpZGF0aW9uOiB0LFxuICAgICAgY29kZTogYWUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAuLi5FZS5lcnJUb09iaihyKVxuICAgIH0pO1xuICB9XG4gIF9hZGRDaGVjayhlKSB7XG4gICAgcmV0dXJuIG5ldyBScyh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBlXVxuICAgIH0pO1xuICB9XG4gIGVtYWlsKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtYWlsXCIsIC4uLkVlLmVyclRvT2JqKGUpIH0pO1xuICB9XG4gIHVybChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1cmxcIiwgLi4uRWUuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgZW1vamkoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1vamlcIiwgLi4uRWUuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgdXVpZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1dWlkXCIsIC4uLkVlLmVyclRvT2JqKGUpIH0pO1xuICB9XG4gIG5hbm9pZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJuYW5vaWRcIiwgLi4uRWUuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgY3VpZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkXCIsIC4uLkVlLmVyclRvT2JqKGUpIH0pO1xuICB9XG4gIGN1aWQyKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWQyXCIsIC4uLkVlLmVyclRvT2JqKGUpIH0pO1xuICB9XG4gIHVsaWQoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidWxpZFwiLCAuLi5FZS5lcnJUb09iaihlKSB9KTtcbiAgfVxuICBiYXNlNjQoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiYmFzZTY0XCIsIC4uLkVlLmVyclRvT2JqKGUpIH0pO1xuICB9XG4gIGJhc2U2NHVybChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiYmFzZTY0dXJsXCIsXG4gICAgICAuLi5FZS5lcnJUb09iaihlKVxuICAgIH0pO1xuICB9XG4gIGp3dChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJqd3RcIiwgLi4uRWUuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgaXAoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiaXBcIiwgLi4uRWUuZXJyVG9PYmooZSkgfSk7XG4gIH1cbiAgY2lkcihlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjaWRyXCIsIC4uLkVlLmVyclRvT2JqKGUpIH0pO1xuICB9XG4gIGRhdGV0aW1lKGUpIHtcbiAgICByZXR1cm4gdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiA/IHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgIG9mZnNldDogITEsXG4gICAgICBsb2NhbDogITEsXG4gICAgICBtZXNzYWdlOiBlXG4gICAgfSkgOiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICBwcmVjaXNpb246IHR5cGVvZiAoZSA9PSBudWxsID8gdm9pZCAwIDogZS5wcmVjaXNpb24pID4gXCJ1XCIgPyBudWxsIDogZSA9PSBudWxsID8gdm9pZCAwIDogZS5wcmVjaXNpb24sXG4gICAgICBvZmZzZXQ6IChlID09IG51bGwgPyB2b2lkIDAgOiBlLm9mZnNldCkgPz8gITEsXG4gICAgICBsb2NhbDogKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUubG9jYWwpID8/ICExLFxuICAgICAgLi4uRWUuZXJyVG9PYmooZSA9PSBudWxsID8gdm9pZCAwIDogZS5tZXNzYWdlKVxuICAgIH0pO1xuICB9XG4gIGRhdGUoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZGF0ZVwiLCBtZXNzYWdlOiBlIH0pO1xuICB9XG4gIHRpbWUoZSkge1xuICAgIHJldHVybiB0eXBlb2YgZSA9PSBcInN0cmluZ1wiID8gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJ0aW1lXCIsXG4gICAgICBwcmVjaXNpb246IG51bGwsXG4gICAgICBtZXNzYWdlOiBlXG4gICAgfSkgOiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcInRpbWVcIixcbiAgICAgIHByZWNpc2lvbjogdHlwZW9mIChlID09IG51bGwgPyB2b2lkIDAgOiBlLnByZWNpc2lvbikgPiBcInVcIiA/IG51bGwgOiBlID09IG51bGwgPyB2b2lkIDAgOiBlLnByZWNpc2lvbixcbiAgICAgIC4uLkVlLmVyclRvT2JqKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUubWVzc2FnZSlcbiAgICB9KTtcbiAgfVxuICBkdXJhdGlvbihlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkdXJhdGlvblwiLCAuLi5FZS5lcnJUb09iaihlKSB9KTtcbiAgfVxuICByZWdleChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwicmVnZXhcIixcbiAgICAgIHJlZ2V4OiBlLFxuICAgICAgLi4uRWUuZXJyVG9PYmoodClcbiAgICB9KTtcbiAgfVxuICBpbmNsdWRlcyhlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiaW5jbHVkZXNcIixcbiAgICAgIHZhbHVlOiBlLFxuICAgICAgcG9zaXRpb246IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQucG9zaXRpb24sXG4gICAgICAuLi5FZS5lcnJUb09iaih0ID09IG51bGwgPyB2b2lkIDAgOiB0Lm1lc3NhZ2UpXG4gICAgfSk7XG4gIH1cbiAgc3RhcnRzV2l0aChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwic3RhcnRzV2l0aFwiLFxuICAgICAgdmFsdWU6IGUsXG4gICAgICAuLi5FZS5lcnJUb09iaih0KVxuICAgIH0pO1xuICB9XG4gIGVuZHNXaXRoKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJlbmRzV2l0aFwiLFxuICAgICAgdmFsdWU6IGUsXG4gICAgICAuLi5FZS5lcnJUb09iaih0KVxuICAgIH0pO1xuICB9XG4gIG1pbihlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogZSxcbiAgICAgIC4uLkVlLmVyclRvT2JqKHQpXG4gICAgfSk7XG4gIH1cbiAgbWF4KGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtYXhcIixcbiAgICAgIHZhbHVlOiBlLFxuICAgICAgLi4uRWUuZXJyVG9PYmoodClcbiAgICB9KTtcbiAgfVxuICBsZW5ndGgoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcImxlbmd0aFwiLFxuICAgICAgdmFsdWU6IGUsXG4gICAgICAuLi5FZS5lcnJUb09iaih0KVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFcXVpdmFsZW50IHRvIGAubWluKDEpYFxuICAgKi9cbiAgbm9uZW1wdHkoZSkge1xuICAgIHJldHVybiB0aGlzLm1pbigxLCBFZS5lcnJUb09iaihlKSk7XG4gIH1cbiAgdHJpbSgpIHtcbiAgICByZXR1cm4gbmV3IFJzKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0cmltXCIgfV1cbiAgICB9KTtcbiAgfVxuICB0b0xvd2VyQ2FzZSgpIHtcbiAgICByZXR1cm4gbmV3IFJzKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0b0xvd2VyQ2FzZVwiIH1dXG4gICAgfSk7XG4gIH1cbiAgdG9VcHBlckNhc2UoKSB7XG4gICAgcmV0dXJuIG5ldyBScyh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9VcHBlckNhc2VcIiB9XVxuICAgIH0pO1xuICB9XG4gIGdldCBpc0RhdGV0aW1lKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImRhdGV0aW1lXCIpO1xuICB9XG4gIGdldCBpc0RhdGUoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChlKSA9PiBlLmtpbmQgPT09IFwiZGF0ZVwiKTtcbiAgfVxuICBnZXQgaXNUaW1lKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcInRpbWVcIik7XG4gIH1cbiAgZ2V0IGlzRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChlKSA9PiBlLmtpbmQgPT09IFwiZHVyYXRpb25cIik7XG4gIH1cbiAgZ2V0IGlzRW1haWwoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChlKSA9PiBlLmtpbmQgPT09IFwiZW1haWxcIik7XG4gIH1cbiAgZ2V0IGlzVVJMKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcInVybFwiKTtcbiAgfVxuICBnZXQgaXNFbW9qaSgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJlbW9qaVwiKTtcbiAgfVxuICBnZXQgaXNVVUlEKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcInV1aWRcIik7XG4gIH1cbiAgZ2V0IGlzTkFOT0lEKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcIm5hbm9pZFwiKTtcbiAgfVxuICBnZXQgaXNDVUlEKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImN1aWRcIik7XG4gIH1cbiAgZ2V0IGlzQ1VJRDIoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChlKSA9PiBlLmtpbmQgPT09IFwiY3VpZDJcIik7XG4gIH1cbiAgZ2V0IGlzVUxJRCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJ1bGlkXCIpO1xuICB9XG4gIGdldCBpc0lQKCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImlwXCIpO1xuICB9XG4gIGdldCBpc0NJRFIoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChlKSA9PiBlLmtpbmQgPT09IFwiY2lkclwiKTtcbiAgfVxuICBnZXQgaXNCYXNlNjQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChlKSA9PiBlLmtpbmQgPT09IFwiYmFzZTY0XCIpO1xuICB9XG4gIGdldCBpc0Jhc2U2NHVybCgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGUpID0+IGUua2luZCA9PT0gXCJiYXNlNjR1cmxcIik7XG4gIH1cbiAgZ2V0IG1pbkxlbmd0aCgpIHtcbiAgICBsZXQgZSA9IG51bGw7XG4gICAgZm9yIChjb25zdCB0IG9mIHRoaXMuX2RlZi5jaGVja3MpXG4gICAgICB0LmtpbmQgPT09IFwibWluXCIgJiYgKGUgPT09IG51bGwgfHwgdC52YWx1ZSA+IGUpICYmIChlID0gdC52YWx1ZSk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZ2V0IG1heExlbmd0aCgpIHtcbiAgICBsZXQgZSA9IG51bGw7XG4gICAgZm9yIChjb25zdCB0IG9mIHRoaXMuX2RlZi5jaGVja3MpXG4gICAgICB0LmtpbmQgPT09IFwibWF4XCIgJiYgKGUgPT09IG51bGwgfHwgdC52YWx1ZSA8IGUpICYmIChlID0gdC52YWx1ZSk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn1cblJzLmNyZWF0ZSA9IChzKSA9PiBuZXcgUnMoe1xuICBjaGVja3M6IFtdLFxuICB0eXBlTmFtZToga2UuWm9kU3RyaW5nLFxuICBjb2VyY2U6IChzID09IG51bGwgPyB2b2lkIDAgOiBzLmNvZXJjZSkgPz8gITEsXG4gIC4uLlZlKHMpXG59KTtcbmZ1bmN0aW9uIEptKHMsIGUpIHtcbiAgY29uc3QgdCA9IChzLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aCwgciA9IChlLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aCwgbiA9IHQgPiByID8gdCA6IHIsIGkgPSBOdW1iZXIucGFyc2VJbnQocy50b0ZpeGVkKG4pLnJlcGxhY2UoXCIuXCIsIFwiXCIpKSwgbyA9IE51bWJlci5wYXJzZUludChlLnRvRml4ZWQobikucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICByZXR1cm4gaSAlIG8gLyAxMCAqKiBuO1xufVxuY2xhc3MgQ24gZXh0ZW5kcyBZZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMubWluID0gdGhpcy5ndGUsIHRoaXMubWF4ID0gdGhpcy5sdGUsIHRoaXMuc3RlcCA9IHRoaXMubXVsdGlwbGVPZjtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlICYmIChlLmRhdGEgPSBOdW1iZXIoZS5kYXRhKSksIHRoaXMuX2dldFR5cGUoZSkgIT09IG1lLm51bWJlcikge1xuICAgICAgY29uc3QgaSA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgICAgcmV0dXJuIGhlKGksIHtcbiAgICAgICAgY29kZTogYWUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogbWUubnVtYmVyLFxuICAgICAgICByZWNlaXZlZDogaS5wYXJzZWRUeXBlXG4gICAgICB9KSwgUmU7XG4gICAgfVxuICAgIGxldCByO1xuICAgIGNvbnN0IG4gPSBuZXcgd3IoKTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy5fZGVmLmNoZWNrcylcbiAgICAgIGkua2luZCA9PT0gXCJpbnRcIiA/IFplLmlzSW50ZWdlcihlLmRhdGEpIHx8IChyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgciksIGhlKHIsIHtcbiAgICAgICAgY29kZTogYWUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogXCJpbnRlZ2VyXCIsXG4gICAgICAgIHJlY2VpdmVkOiBcImZsb2F0XCIsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIG4uZGlydHkoKSkgOiBpLmtpbmQgPT09IFwibWluXCIgPyAoaS5pbmNsdXNpdmUgPyBlLmRhdGEgPCBpLnZhbHVlIDogZS5kYXRhIDw9IGkudmFsdWUpICYmIChyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgciksIGhlKHIsIHtcbiAgICAgICAgY29kZTogYWUudG9vX3NtYWxsLFxuICAgICAgICBtaW5pbXVtOiBpLnZhbHVlLFxuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBpbmNsdXNpdmU6IGkuaW5jbHVzaXZlLFxuICAgICAgICBleGFjdDogITEsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIG4uZGlydHkoKSkgOiBpLmtpbmQgPT09IFwibWF4XCIgPyAoaS5pbmNsdXNpdmUgPyBlLmRhdGEgPiBpLnZhbHVlIDogZS5kYXRhID49IGkudmFsdWUpICYmIChyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgciksIGhlKHIsIHtcbiAgICAgICAgY29kZTogYWUudG9vX2JpZyxcbiAgICAgICAgbWF4aW11bTogaS52YWx1ZSxcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgaW5jbHVzaXZlOiBpLmluY2x1c2l2ZSxcbiAgICAgICAgZXhhY3Q6ICExLFxuICAgICAgICBtZXNzYWdlOiBpLm1lc3NhZ2VcbiAgICAgIH0pLCBuLmRpcnR5KCkpIDogaS5raW5kID09PSBcIm11bHRpcGxlT2ZcIiA/IEptKGUuZGF0YSwgaS52YWx1ZSkgIT09IDAgJiYgKHIgPSB0aGlzLl9nZXRPclJldHVybkN0eChlLCByKSwgaGUociwge1xuICAgICAgICBjb2RlOiBhZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgIG11bHRpcGxlT2Y6IGkudmFsdWUsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIG4uZGlydHkoKSkgOiBpLmtpbmQgPT09IFwiZmluaXRlXCIgPyBOdW1iZXIuaXNGaW5pdGUoZS5kYXRhKSB8fCAociA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHIpLCBoZShyLCB7XG4gICAgICAgIGNvZGU6IGFlLm5vdF9maW5pdGUsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIG4uZGlydHkoKSkgOiBaZS5hc3NlcnROZXZlcihpKTtcbiAgICByZXR1cm4geyBzdGF0dXM6IG4udmFsdWUsIHZhbHVlOiBlLmRhdGEgfTtcbiAgfVxuICBndGUoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIGUsICEwLCBFZS50b1N0cmluZyh0KSk7XG4gIH1cbiAgZ3QoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIGUsICExLCBFZS50b1N0cmluZyh0KSk7XG4gIH1cbiAgbHRlKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCBlLCAhMCwgRWUudG9TdHJpbmcodCkpO1xuICB9XG4gIGx0KGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCBlLCAhMSwgRWUudG9TdHJpbmcodCkpO1xuICB9XG4gIHNldExpbWl0KGUsIHQsIHIsIG4pIHtcbiAgICByZXR1cm4gbmV3IENuKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogW1xuICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICB7XG4gICAgICAgICAga2luZDogZSxcbiAgICAgICAgICB2YWx1ZTogdCxcbiAgICAgICAgICBpbmNsdXNpdmU6IHIsXG4gICAgICAgICAgbWVzc2FnZTogRWUudG9TdHJpbmcobilcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICB9XG4gIF9hZGRDaGVjayhlKSB7XG4gICAgcmV0dXJuIG5ldyBDbih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBlXVxuICAgIH0pO1xuICB9XG4gIGludChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiaW50XCIsXG4gICAgICBtZXNzYWdlOiBFZS50b1N0cmluZyhlKVxuICAgIH0pO1xuICB9XG4gIHBvc2l0aXZlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtaW5cIixcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgaW5jbHVzaXZlOiAhMSxcbiAgICAgIG1lc3NhZ2U6IEVlLnRvU3RyaW5nKGUpXG4gICAgfSk7XG4gIH1cbiAgbmVnYXRpdmUoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBpbmNsdXNpdmU6ICExLFxuICAgICAgbWVzc2FnZTogRWUudG9TdHJpbmcoZSlcbiAgICB9KTtcbiAgfVxuICBub25wb3NpdGl2ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICBtZXNzYWdlOiBFZS50b1N0cmluZyhlKVxuICAgIH0pO1xuICB9XG4gIG5vbm5lZ2F0aXZlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtaW5cIixcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgIG1lc3NhZ2U6IEVlLnRvU3RyaW5nKGUpXG4gICAgfSk7XG4gIH1cbiAgbXVsdGlwbGVPZihlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgdmFsdWU6IGUsXG4gICAgICBtZXNzYWdlOiBFZS50b1N0cmluZyh0KVxuICAgIH0pO1xuICB9XG4gIGZpbml0ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwiZmluaXRlXCIsXG4gICAgICBtZXNzYWdlOiBFZS50b1N0cmluZyhlKVxuICAgIH0pO1xuICB9XG4gIHNhZmUoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgIHZhbHVlOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUixcbiAgICAgIG1lc3NhZ2U6IEVlLnRvU3RyaW5nKGUpXG4gICAgfSkuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgdmFsdWU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgbWVzc2FnZTogRWUudG9TdHJpbmcoZSlcbiAgICB9KTtcbiAgfVxuICBnZXQgbWluVmFsdWUoKSB7XG4gICAgbGV0IGUgPSBudWxsO1xuICAgIGZvciAoY29uc3QgdCBvZiB0aGlzLl9kZWYuY2hlY2tzKVxuICAgICAgdC5raW5kID09PSBcIm1pblwiICYmIChlID09PSBudWxsIHx8IHQudmFsdWUgPiBlKSAmJiAoZSA9IHQudmFsdWUpO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGdldCBtYXhWYWx1ZSgpIHtcbiAgICBsZXQgZSA9IG51bGw7XG4gICAgZm9yIChjb25zdCB0IG9mIHRoaXMuX2RlZi5jaGVja3MpXG4gICAgICB0LmtpbmQgPT09IFwibWF4XCIgJiYgKGUgPT09IG51bGwgfHwgdC52YWx1ZSA8IGUpICYmIChlID0gdC52YWx1ZSk7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZ2V0IGlzSW50KCkge1xuICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoZSkgPT4gZS5raW5kID09PSBcImludFwiIHx8IGUua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIgJiYgWmUuaXNJbnRlZ2VyKGUudmFsdWUpKTtcbiAgfVxuICBnZXQgaXNGaW5pdGUoKSB7XG4gICAgbGV0IGUgPSBudWxsLCB0ID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgaWYgKHIua2luZCA9PT0gXCJmaW5pdGVcIiB8fCByLmtpbmQgPT09IFwiaW50XCIgfHwgci5raW5kID09PSBcIm11bHRpcGxlT2ZcIilcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgci5raW5kID09PSBcIm1pblwiID8gKHQgPT09IG51bGwgfHwgci52YWx1ZSA+IHQpICYmICh0ID0gci52YWx1ZSkgOiByLmtpbmQgPT09IFwibWF4XCIgJiYgKGUgPT09IG51bGwgfHwgci52YWx1ZSA8IGUpICYmIChlID0gci52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUodCkgJiYgTnVtYmVyLmlzRmluaXRlKGUpO1xuICB9XG59XG5Dbi5jcmVhdGUgPSAocykgPT4gbmV3IENuKHtcbiAgY2hlY2tzOiBbXSxcbiAgdHlwZU5hbWU6IGtlLlpvZE51bWJlcixcbiAgY29lcmNlOiAocyA9PSBudWxsID8gdm9pZCAwIDogcy5jb2VyY2UpIHx8ICExLFxuICAuLi5WZShzKVxufSk7XG5jbGFzcyBKbiBleHRlbmRzIFllIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5taW4gPSB0aGlzLmd0ZSwgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKVxuICAgICAgdHJ5IHtcbiAgICAgICAgZS5kYXRhID0gQmlnSW50KGUuZGF0YSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChlKTtcbiAgICAgIH1cbiAgICBpZiAodGhpcy5fZ2V0VHlwZShlKSAhPT0gbWUuYmlnaW50KVxuICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChlKTtcbiAgICBsZXQgcjtcbiAgICBjb25zdCBuID0gbmV3IHdyKCk7XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuX2RlZi5jaGVja3MpXG4gICAgICBpLmtpbmQgPT09IFwibWluXCIgPyAoaS5pbmNsdXNpdmUgPyBlLmRhdGEgPCBpLnZhbHVlIDogZS5kYXRhIDw9IGkudmFsdWUpICYmIChyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgciksIGhlKHIsIHtcbiAgICAgICAgY29kZTogYWUudG9vX3NtYWxsLFxuICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICBtaW5pbXVtOiBpLnZhbHVlLFxuICAgICAgICBpbmNsdXNpdmU6IGkuaW5jbHVzaXZlLFxuICAgICAgICBtZXNzYWdlOiBpLm1lc3NhZ2VcbiAgICAgIH0pLCBuLmRpcnR5KCkpIDogaS5raW5kID09PSBcIm1heFwiID8gKGkuaW5jbHVzaXZlID8gZS5kYXRhID4gaS52YWx1ZSA6IGUuZGF0YSA+PSBpLnZhbHVlKSAmJiAociA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIHIpLCBoZShyLCB7XG4gICAgICAgIGNvZGU6IGFlLnRvb19iaWcsXG4gICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgIG1heGltdW06IGkudmFsdWUsXG4gICAgICAgIGluY2x1c2l2ZTogaS5pbmNsdXNpdmUsXG4gICAgICAgIG1lc3NhZ2U6IGkubWVzc2FnZVxuICAgICAgfSksIG4uZGlydHkoKSkgOiBpLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiID8gZS5kYXRhICUgaS52YWx1ZSAhPT0gQmlnSW50KDApICYmIChyID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgciksIGhlKHIsIHtcbiAgICAgICAgY29kZTogYWUubm90X211bHRpcGxlX29mLFxuICAgICAgICBtdWx0aXBsZU9mOiBpLnZhbHVlLFxuICAgICAgICBtZXNzYWdlOiBpLm1lc3NhZ2VcbiAgICAgIH0pLCBuLmRpcnR5KCkpIDogWmUuYXNzZXJ0TmV2ZXIoaSk7XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBuLnZhbHVlLCB2YWx1ZTogZS5kYXRhIH07XG4gIH1cbiAgX2dldEludmFsaWRJbnB1dChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgIHJldHVybiBoZSh0LCB7XG4gICAgICBjb2RlOiBhZS5pbnZhbGlkX3R5cGUsXG4gICAgICBleHBlY3RlZDogbWUuYmlnaW50LFxuICAgICAgcmVjZWl2ZWQ6IHQucGFyc2VkVHlwZVxuICAgIH0pLCBSZTtcbiAgfVxuICBndGUoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIGUsICEwLCBFZS50b1N0cmluZyh0KSk7XG4gIH1cbiAgZ3QoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIGUsICExLCBFZS50b1N0cmluZyh0KSk7XG4gIH1cbiAgbHRlKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCBlLCAhMCwgRWUudG9TdHJpbmcodCkpO1xuICB9XG4gIGx0KGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCBlLCAhMSwgRWUudG9TdHJpbmcodCkpO1xuICB9XG4gIHNldExpbWl0KGUsIHQsIHIsIG4pIHtcbiAgICByZXR1cm4gbmV3IEpuKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIGNoZWNrczogW1xuICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICB7XG4gICAgICAgICAga2luZDogZSxcbiAgICAgICAgICB2YWx1ZTogdCxcbiAgICAgICAgICBpbmNsdXNpdmU6IHIsXG4gICAgICAgICAgbWVzc2FnZTogRWUudG9TdHJpbmcobilcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0pO1xuICB9XG4gIF9hZGRDaGVjayhlKSB7XG4gICAgcmV0dXJuIG5ldyBKbih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBlXVxuICAgIH0pO1xuICB9XG4gIHBvc2l0aXZlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtaW5cIixcbiAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICBpbmNsdXNpdmU6ICExLFxuICAgICAgbWVzc2FnZTogRWUudG9TdHJpbmcoZSlcbiAgICB9KTtcbiAgfVxuICBuZWdhdGl2ZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgaW5jbHVzaXZlOiAhMSxcbiAgICAgIG1lc3NhZ2U6IEVlLnRvU3RyaW5nKGUpXG4gICAgfSk7XG4gIH1cbiAgbm9ucG9zaXRpdmUoZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICBtZXNzYWdlOiBFZS50b1N0cmluZyhlKVxuICAgIH0pO1xuICB9XG4gIG5vbm5lZ2F0aXZlKGUpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtaW5cIixcbiAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgbWVzc2FnZTogRWUudG9TdHJpbmcoZSlcbiAgICB9KTtcbiAgfVxuICBtdWx0aXBsZU9mKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICB2YWx1ZTogZSxcbiAgICAgIG1lc3NhZ2U6IEVlLnRvU3RyaW5nKHQpXG4gICAgfSk7XG4gIH1cbiAgZ2V0IG1pblZhbHVlKCkge1xuICAgIGxldCBlID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHQgb2YgdGhpcy5fZGVmLmNoZWNrcylcbiAgICAgIHQua2luZCA9PT0gXCJtaW5cIiAmJiAoZSA9PT0gbnVsbCB8fCB0LnZhbHVlID4gZSkgJiYgKGUgPSB0LnZhbHVlKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgbGV0IGUgPSBudWxsO1xuICAgIGZvciAoY29uc3QgdCBvZiB0aGlzLl9kZWYuY2hlY2tzKVxuICAgICAgdC5raW5kID09PSBcIm1heFwiICYmIChlID09PSBudWxsIHx8IHQudmFsdWUgPCBlKSAmJiAoZSA9IHQudmFsdWUpO1xuICAgIHJldHVybiBlO1xuICB9XG59XG5Kbi5jcmVhdGUgPSAocykgPT4gbmV3IEpuKHtcbiAgY2hlY2tzOiBbXSxcbiAgdHlwZU5hbWU6IGtlLlpvZEJpZ0ludCxcbiAgY29lcmNlOiAocyA9PSBudWxsID8gdm9pZCAwIDogcy5jb2VyY2UpID8/ICExLFxuICAuLi5WZShzKVxufSk7XG5jbGFzcyBIbCBleHRlbmRzIFllIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSAmJiAoZS5kYXRhID0gISFlLmRhdGEpLCB0aGlzLl9nZXRUeXBlKGUpICE9PSBtZS5ib29sZWFuKSB7XG4gICAgICBjb25zdCByID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgICByZXR1cm4gaGUociwge1xuICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBtZS5ib29sZWFuLFxuICAgICAgICByZWNlaXZlZDogci5wYXJzZWRUeXBlXG4gICAgICB9KSwgUmU7XG4gICAgfVxuICAgIHJldHVybiBScihlLmRhdGEpO1xuICB9XG59XG5IbC5jcmVhdGUgPSAocykgPT4gbmV3IEhsKHtcbiAgdHlwZU5hbWU6IGtlLlpvZEJvb2xlYW4sXG4gIGNvZXJjZTogKHMgPT0gbnVsbCA/IHZvaWQgMCA6IHMuY29lcmNlKSB8fCAhMSxcbiAgLi4uVmUocylcbn0pO1xuY2xhc3MgVG8gZXh0ZW5kcyBZZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UgJiYgKGUuZGF0YSA9IG5ldyBEYXRlKGUuZGF0YSkpLCB0aGlzLl9nZXRUeXBlKGUpICE9PSBtZS5kYXRlKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgICByZXR1cm4gaGUoaSwge1xuICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBtZS5kYXRlLFxuICAgICAgICByZWNlaXZlZDogaS5wYXJzZWRUeXBlXG4gICAgICB9KSwgUmU7XG4gICAgfVxuICAgIGlmIChOdW1iZXIuaXNOYU4oZS5kYXRhLmdldFRpbWUoKSkpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRPclJldHVybkN0eChlKTtcbiAgICAgIHJldHVybiBoZShpLCB7XG4gICAgICAgIGNvZGU6IGFlLmludmFsaWRfZGF0ZVxuICAgICAgfSksIFJlO1xuICAgIH1cbiAgICBjb25zdCByID0gbmV3IHdyKCk7XG4gICAgbGV0IG47XG4gICAgZm9yIChjb25zdCBpIG9mIHRoaXMuX2RlZi5jaGVja3MpXG4gICAgICBpLmtpbmQgPT09IFwibWluXCIgPyBlLmRhdGEuZ2V0VGltZSgpIDwgaS52YWx1ZSAmJiAobiA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUsIG4pLCBoZShuLCB7XG4gICAgICAgIGNvZGU6IGFlLnRvb19zbWFsbCxcbiAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlLFxuICAgICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgICBleGFjdDogITEsXG4gICAgICAgIG1pbmltdW06IGkudmFsdWUsXG4gICAgICAgIHR5cGU6IFwiZGF0ZVwiXG4gICAgICB9KSwgci5kaXJ0eSgpKSA6IGkua2luZCA9PT0gXCJtYXhcIiA/IGUuZGF0YS5nZXRUaW1lKCkgPiBpLnZhbHVlICYmIChuID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSwgbiksIGhlKG4sIHtcbiAgICAgICAgY29kZTogYWUudG9vX2JpZyxcbiAgICAgICAgbWVzc2FnZTogaS5tZXNzYWdlLFxuICAgICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgICBleGFjdDogITEsXG4gICAgICAgIG1heGltdW06IGkudmFsdWUsXG4gICAgICAgIHR5cGU6IFwiZGF0ZVwiXG4gICAgICB9KSwgci5kaXJ0eSgpKSA6IFplLmFzc2VydE5ldmVyKGkpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IHIudmFsdWUsXG4gICAgICB2YWx1ZTogbmV3IERhdGUoZS5kYXRhLmdldFRpbWUoKSlcbiAgICB9O1xuICB9XG4gIF9hZGRDaGVjayhlKSB7XG4gICAgcmV0dXJuIG5ldyBUbyh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBlXVxuICAgIH0pO1xuICB9XG4gIG1pbihlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICB2YWx1ZTogZS5nZXRUaW1lKCksXG4gICAgICBtZXNzYWdlOiBFZS50b1N0cmluZyh0KVxuICAgIH0pO1xuICB9XG4gIG1heChlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICB2YWx1ZTogZS5nZXRUaW1lKCksXG4gICAgICBtZXNzYWdlOiBFZS50b1N0cmluZyh0KVxuICAgIH0pO1xuICB9XG4gIGdldCBtaW5EYXRlKCkge1xuICAgIGxldCBlID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHQgb2YgdGhpcy5fZGVmLmNoZWNrcylcbiAgICAgIHQua2luZCA9PT0gXCJtaW5cIiAmJiAoZSA9PT0gbnVsbCB8fCB0LnZhbHVlID4gZSkgJiYgKGUgPSB0LnZhbHVlKTtcbiAgICByZXR1cm4gZSAhPSBudWxsID8gbmV3IERhdGUoZSkgOiBudWxsO1xuICB9XG4gIGdldCBtYXhEYXRlKCkge1xuICAgIGxldCBlID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IHQgb2YgdGhpcy5fZGVmLmNoZWNrcylcbiAgICAgIHQua2luZCA9PT0gXCJtYXhcIiAmJiAoZSA9PT0gbnVsbCB8fCB0LnZhbHVlIDwgZSkgJiYgKGUgPSB0LnZhbHVlKTtcbiAgICByZXR1cm4gZSAhPSBudWxsID8gbmV3IERhdGUoZSkgOiBudWxsO1xuICB9XG59XG5Uby5jcmVhdGUgPSAocykgPT4gbmV3IFRvKHtcbiAgY2hlY2tzOiBbXSxcbiAgY29lcmNlOiAocyA9PSBudWxsID8gdm9pZCAwIDogcy5jb2VyY2UpIHx8ICExLFxuICB0eXBlTmFtZToga2UuWm9kRGF0ZSxcbiAgLi4uVmUocylcbn0pO1xuY2xhc3MgUXUgZXh0ZW5kcyBZZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgaWYgKHRoaXMuX2dldFR5cGUoZSkgIT09IG1lLnN5bWJvbCkge1xuICAgICAgY29uc3QgciA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgICAgcmV0dXJuIGhlKHIsIHtcbiAgICAgICAgY29kZTogYWUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogbWUuc3ltYm9sLFxuICAgICAgICByZWNlaXZlZDogci5wYXJzZWRUeXBlXG4gICAgICB9KSwgUmU7XG4gICAgfVxuICAgIHJldHVybiBScihlLmRhdGEpO1xuICB9XG59XG5RdS5jcmVhdGUgPSAocykgPT4gbmV3IFF1KHtcbiAgdHlwZU5hbWU6IGtlLlpvZFN5bWJvbCxcbiAgLi4uVmUocylcbn0pO1xuY2xhc3MgcWwgZXh0ZW5kcyBZZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgaWYgKHRoaXMuX2dldFR5cGUoZSkgIT09IG1lLnVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgciA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgICAgcmV0dXJuIGhlKHIsIHtcbiAgICAgICAgY29kZTogYWUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogbWUudW5kZWZpbmVkLFxuICAgICAgICByZWNlaXZlZDogci5wYXJzZWRUeXBlXG4gICAgICB9KSwgUmU7XG4gICAgfVxuICAgIHJldHVybiBScihlLmRhdGEpO1xuICB9XG59XG5xbC5jcmVhdGUgPSAocykgPT4gbmV3IHFsKHtcbiAgdHlwZU5hbWU6IGtlLlpvZFVuZGVmaW5lZCxcbiAgLi4uVmUocylcbn0pO1xuY2xhc3MgV2wgZXh0ZW5kcyBZZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgaWYgKHRoaXMuX2dldFR5cGUoZSkgIT09IG1lLm51bGwpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLl9nZXRPclJldHVybkN0eChlKTtcbiAgICAgIHJldHVybiBoZShyLCB7XG4gICAgICAgIGNvZGU6IGFlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IG1lLm51bGwsXG4gICAgICAgIHJlY2VpdmVkOiByLnBhcnNlZFR5cGVcbiAgICAgIH0pLCBSZTtcbiAgICB9XG4gICAgcmV0dXJuIFJyKGUuZGF0YSk7XG4gIH1cbn1cbldsLmNyZWF0ZSA9IChzKSA9PiBuZXcgV2woe1xuICB0eXBlTmFtZToga2UuWm9kTnVsbCxcbiAgLi4uVmUocylcbn0pO1xuY2xhc3MgZWQgZXh0ZW5kcyBZZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuX2FueSA9ICEwO1xuICB9XG4gIF9wYXJzZShlKSB7XG4gICAgcmV0dXJuIFJyKGUuZGF0YSk7XG4gIH1cbn1cbmVkLmNyZWF0ZSA9IChzKSA9PiBuZXcgZWQoe1xuICB0eXBlTmFtZToga2UuWm9kQW55LFxuICAuLi5WZShzKVxufSk7XG5jbGFzcyB0ZCBleHRlbmRzIFllIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5fdW5rbm93biA9ICEwO1xuICB9XG4gIF9wYXJzZShlKSB7XG4gICAgcmV0dXJuIFJyKGUuZGF0YSk7XG4gIH1cbn1cbnRkLmNyZWF0ZSA9IChzKSA9PiBuZXcgdGQoe1xuICB0eXBlTmFtZToga2UuWm9kVW5rbm93bixcbiAgLi4uVmUocylcbn0pO1xuY2xhc3MgUHMgZXh0ZW5kcyBZZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgIHJldHVybiBoZSh0LCB7XG4gICAgICBjb2RlOiBhZS5pbnZhbGlkX3R5cGUsXG4gICAgICBleHBlY3RlZDogbWUubmV2ZXIsXG4gICAgICByZWNlaXZlZDogdC5wYXJzZWRUeXBlXG4gICAgfSksIFJlO1xuICB9XG59XG5Qcy5jcmVhdGUgPSAocykgPT4gbmV3IFBzKHtcbiAgdHlwZU5hbWU6IGtlLlpvZE5ldmVyLFxuICAuLi5WZShzKVxufSk7XG5jbGFzcyByZCBleHRlbmRzIFllIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBpZiAodGhpcy5fZ2V0VHlwZShlKSAhPT0gbWUudW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCByID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgICByZXR1cm4gaGUociwge1xuICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBtZS52b2lkLFxuICAgICAgICByZWNlaXZlZDogci5wYXJzZWRUeXBlXG4gICAgICB9KSwgUmU7XG4gICAgfVxuICAgIHJldHVybiBScihlLmRhdGEpO1xuICB9XG59XG5yZC5jcmVhdGUgPSAocykgPT4gbmV3IHJkKHtcbiAgdHlwZU5hbWU6IGtlLlpvZFZvaWQsXG4gIC4uLlZlKHMpXG59KTtcbmNsYXNzIFlyIGV4dGVuZHMgWWUge1xuICBfcGFyc2UoZSkge1xuICAgIGNvbnN0IHsgY3R4OiB0LCBzdGF0dXM6IHIgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhlKSwgbiA9IHRoaXMuX2RlZjtcbiAgICBpZiAodC5wYXJzZWRUeXBlICE9PSBtZS5hcnJheSlcbiAgICAgIHJldHVybiBoZSh0LCB7XG4gICAgICAgIGNvZGU6IGFlLmludmFsaWRfdHlwZSxcbiAgICAgICAgZXhwZWN0ZWQ6IG1lLmFycmF5LFxuICAgICAgICByZWNlaXZlZDogdC5wYXJzZWRUeXBlXG4gICAgICB9KSwgUmU7XG4gICAgaWYgKG4uZXhhY3RMZW5ndGggIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG8gPSB0LmRhdGEubGVuZ3RoID4gbi5leGFjdExlbmd0aC52YWx1ZSwgYSA9IHQuZGF0YS5sZW5ndGggPCBuLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgKG8gfHwgYSkgJiYgKGhlKHQsIHtcbiAgICAgICAgY29kZTogbyA/IGFlLnRvb19iaWcgOiBhZS50b29fc21hbGwsXG4gICAgICAgIG1pbmltdW06IGEgPyBuLmV4YWN0TGVuZ3RoLnZhbHVlIDogdm9pZCAwLFxuICAgICAgICBtYXhpbXVtOiBvID8gbi5leGFjdExlbmd0aC52YWx1ZSA6IHZvaWQgMCxcbiAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgICBleGFjdDogITAsXG4gICAgICAgIG1lc3NhZ2U6IG4uZXhhY3RMZW5ndGgubWVzc2FnZVxuICAgICAgfSksIHIuZGlydHkoKSk7XG4gICAgfVxuICAgIGlmIChuLm1pbkxlbmd0aCAhPT0gbnVsbCAmJiB0LmRhdGEubGVuZ3RoIDwgbi5taW5MZW5ndGgudmFsdWUgJiYgKGhlKHQsIHtcbiAgICAgIGNvZGU6IGFlLnRvb19zbWFsbCxcbiAgICAgIG1pbmltdW06IG4ubWluTGVuZ3RoLnZhbHVlLFxuICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgIGV4YWN0OiAhMSxcbiAgICAgIG1lc3NhZ2U6IG4ubWluTGVuZ3RoLm1lc3NhZ2VcbiAgICB9KSwgci5kaXJ0eSgpKSwgbi5tYXhMZW5ndGggIT09IG51bGwgJiYgdC5kYXRhLmxlbmd0aCA+IG4ubWF4TGVuZ3RoLnZhbHVlICYmIChoZSh0LCB7XG4gICAgICBjb2RlOiBhZS50b29fYmlnLFxuICAgICAgbWF4aW11bTogbi5tYXhMZW5ndGgudmFsdWUsXG4gICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICBpbmNsdXNpdmU6ICEwLFxuICAgICAgZXhhY3Q6ICExLFxuICAgICAgbWVzc2FnZTogbi5tYXhMZW5ndGgubWVzc2FnZVxuICAgIH0pLCByLmRpcnR5KCkpLCB0LmNvbW1vbi5hc3luYylcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChbLi4udC5kYXRhXS5tYXAoKG8sIGEpID0+IG4udHlwZS5fcGFyc2VBc3luYyhuZXcgRHModCwgbywgdC5wYXRoLCBhKSkpKS50aGVuKChvKSA9PiB3ci5tZXJnZUFycmF5KHIsIG8pKTtcbiAgICBjb25zdCBpID0gWy4uLnQuZGF0YV0ubWFwKChvLCBhKSA9PiBuLnR5cGUuX3BhcnNlU3luYyhuZXcgRHModCwgbywgdC5wYXRoLCBhKSkpO1xuICAgIHJldHVybiB3ci5tZXJnZUFycmF5KHIsIGkpO1xuICB9XG4gIGdldCBlbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgfVxuICBtaW4oZSwgdCkge1xuICAgIHJldHVybiBuZXcgWXIoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgbWluTGVuZ3RoOiB7IHZhbHVlOiBlLCBtZXNzYWdlOiBFZS50b1N0cmluZyh0KSB9XG4gICAgfSk7XG4gIH1cbiAgbWF4KGUsIHQpIHtcbiAgICByZXR1cm4gbmV3IFlyKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIG1heExlbmd0aDogeyB2YWx1ZTogZSwgbWVzc2FnZTogRWUudG9TdHJpbmcodCkgfVxuICAgIH0pO1xuICB9XG4gIGxlbmd0aChlLCB0KSB7XG4gICAgcmV0dXJuIG5ldyBZcih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBleGFjdExlbmd0aDogeyB2YWx1ZTogZSwgbWVzc2FnZTogRWUudG9TdHJpbmcodCkgfVxuICAgIH0pO1xuICB9XG4gIG5vbmVtcHR5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5taW4oMSwgZSk7XG4gIH1cbn1cbllyLmNyZWF0ZSA9IChzLCBlKSA9PiBuZXcgWXIoe1xuICB0eXBlOiBzLFxuICBtaW5MZW5ndGg6IG51bGwsXG4gIG1heExlbmd0aDogbnVsbCxcbiAgZXhhY3RMZW5ndGg6IG51bGwsXG4gIHR5cGVOYW1lOiBrZS5ab2RBcnJheSxcbiAgLi4uVmUoZSlcbn0pO1xuZnVuY3Rpb24gbW4ocykge1xuICBpZiAocyBpbnN0YW5jZW9mICR0KSB7XG4gICAgY29uc3QgZSA9IHt9O1xuICAgIGZvciAoY29uc3QgdCBpbiBzLnNoYXBlKSB7XG4gICAgICBjb25zdCByID0gcy5zaGFwZVt0XTtcbiAgICAgIGVbdF0gPSBmcy5jcmVhdGUobW4ocikpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3ICR0KHtcbiAgICAgIC4uLnMuX2RlZixcbiAgICAgIHNoYXBlOiAoKSA9PiBlXG4gICAgfSk7XG4gIH0gZWxzZSByZXR1cm4gcyBpbnN0YW5jZW9mIFlyID8gbmV3IFlyKHtcbiAgICAuLi5zLl9kZWYsXG4gICAgdHlwZTogbW4ocy5lbGVtZW50KVxuICB9KSA6IHMgaW5zdGFuY2VvZiBmcyA/IGZzLmNyZWF0ZShtbihzLnVud3JhcCgpKSkgOiBzIGluc3RhbmNlb2YgWnMgPyBacy5jcmVhdGUobW4ocy51bndyYXAoKSkpIDogcyBpbnN0YW5jZW9mIFdzID8gV3MuY3JlYXRlKHMuaXRlbXMubWFwKChlKSA9PiBtbihlKSkpIDogcztcbn1cbmNsYXNzICR0IGV4dGVuZHMgWWUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpLCB0aGlzLl9jYWNoZWQgPSBudWxsLCB0aGlzLm5vbnN0cmljdCA9IHRoaXMucGFzc3Rocm91Z2gsIHRoaXMuYXVnbWVudCA9IHRoaXMuZXh0ZW5kO1xuICB9XG4gIF9nZXRDYWNoZWQoKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZCAhPT0gbnVsbClcbiAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XG4gICAgY29uc3QgZSA9IHRoaXMuX2RlZi5zaGFwZSgpLCB0ID0gWmUub2JqZWN0S2V5cyhlKTtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkID0geyBzaGFwZTogZSwga2V5czogdCB9LCB0aGlzLl9jYWNoZWQ7XG4gIH1cbiAgX3BhcnNlKGUpIHtcbiAgICBpZiAodGhpcy5fZ2V0VHlwZShlKSAhPT0gbWUub2JqZWN0KSB7XG4gICAgICBjb25zdCBjID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgICByZXR1cm4gaGUoYywge1xuICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBtZS5vYmplY3QsXG4gICAgICAgIHJlY2VpdmVkOiBjLnBhcnNlZFR5cGVcbiAgICAgIH0pLCBSZTtcbiAgICB9XG4gICAgY29uc3QgeyBzdGF0dXM6IHIsIGN0eDogbiB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpLCB7IHNoYXBlOiBpLCBrZXlzOiBvIH0gPSB0aGlzLl9nZXRDYWNoZWQoKSwgYSA9IFtdO1xuICAgIGlmICghKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFBzICYmIHRoaXMuX2RlZi51bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSlcbiAgICAgIGZvciAoY29uc3QgYyBpbiBuLmRhdGEpXG4gICAgICAgIG8uaW5jbHVkZXMoYykgfHwgYS5wdXNoKGMpO1xuICAgIGNvbnN0IGwgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGMgb2Ygbykge1xuICAgICAgY29uc3QgdSA9IGlbY10sIGQgPSBuLmRhdGFbY107XG4gICAgICBsLnB1c2goe1xuICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBjIH0sXG4gICAgICAgIHZhbHVlOiB1Ll9wYXJzZShuZXcgRHMobiwgZCwgbi5wYXRoLCBjKSksXG4gICAgICAgIGFsd2F5c1NldDogYyBpbiBuLmRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2YgUHMpIHtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XG4gICAgICBpZiAoYyA9PT0gXCJwYXNzdGhyb3VnaFwiKVxuICAgICAgICBmb3IgKGNvbnN0IHUgb2YgYSlcbiAgICAgICAgICBsLnB1c2goe1xuICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogdSB9LFxuICAgICAgICAgICAgdmFsdWU6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBuLmRhdGFbdV0gfVxuICAgICAgICAgIH0pO1xuICAgICAgZWxzZSBpZiAoYyA9PT0gXCJzdHJpY3RcIilcbiAgICAgICAgYS5sZW5ndGggPiAwICYmIChoZShuLCB7XG4gICAgICAgICAgY29kZTogYWUudW5yZWNvZ25pemVkX2tleXMsXG4gICAgICAgICAga2V5czogYVxuICAgICAgICB9KSwgci5kaXJ0eSgpKTtcbiAgICAgIGVsc2UgaWYgKGMgIT09IFwic3RyaXBcIikgdGhyb3cgbmV3IEVycm9yKFwiSW50ZXJuYWwgWm9kT2JqZWN0IGVycm9yOiBpbnZhbGlkIHVua25vd25LZXlzIHZhbHVlLlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgYyA9IHRoaXMuX2RlZi5jYXRjaGFsbDtcbiAgICAgIGZvciAoY29uc3QgdSBvZiBhKSB7XG4gICAgICAgIGNvbnN0IGQgPSBuLmRhdGFbdV07XG4gICAgICAgIGwucHVzaCh7XG4gICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogdSB9LFxuICAgICAgICAgIHZhbHVlOiBjLl9wYXJzZShcbiAgICAgICAgICAgIG5ldyBEcyhuLCBkLCBuLnBhdGgsIHUpXG4gICAgICAgICAgICAvLywgY3R4LmNoaWxkKGtleSksIHZhbHVlLCBnZXRQYXJzZWRUeXBlKHZhbHVlKVxuICAgICAgICAgICksXG4gICAgICAgICAgYWx3YXlzU2V0OiB1IGluIG4uZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG4uY29tbW9uLmFzeW5jID8gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBjID0gW107XG4gICAgICBmb3IgKGNvbnN0IHUgb2YgbCkge1xuICAgICAgICBjb25zdCBkID0gYXdhaXQgdS5rZXksIGggPSBhd2FpdCB1LnZhbHVlO1xuICAgICAgICBjLnB1c2goe1xuICAgICAgICAgIGtleTogZCxcbiAgICAgICAgICB2YWx1ZTogaCxcbiAgICAgICAgICBhbHdheXNTZXQ6IHUuYWx3YXlzU2V0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGM7XG4gICAgfSkudGhlbigoYykgPT4gd3IubWVyZ2VPYmplY3RTeW5jKHIsIGMpKSA6IHdyLm1lcmdlT2JqZWN0U3luYyhyLCBsKTtcbiAgfVxuICBnZXQgc2hhcGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5zaGFwZSgpO1xuICB9XG4gIHN0cmljdChlKSB7XG4gICAgcmV0dXJuIEVlLmVyclRvT2JqLCBuZXcgJHQoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAuLi5lICE9PSB2b2lkIDAgPyB7XG4gICAgICAgIGVycm9yTWFwOiAodCwgcikgPT4ge1xuICAgICAgICAgIHZhciBpLCBvO1xuICAgICAgICAgIGNvbnN0IG4gPSAoKG8gPSAoaSA9IHRoaXMuX2RlZikuZXJyb3JNYXApID09IG51bGwgPyB2b2lkIDAgOiBvLmNhbGwoaSwgdCwgcikubWVzc2FnZSkgPz8gci5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgcmV0dXJuIHQuY29kZSA9PT0gXCJ1bnJlY29nbml6ZWRfa2V5c1wiID8ge1xuICAgICAgICAgICAgbWVzc2FnZTogRWUuZXJyVG9PYmooZSkubWVzc2FnZSA/PyBuXG4gICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IG5cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IDoge31cbiAgICB9KTtcbiAgfVxuICBzdHJpcCgpIHtcbiAgICByZXR1cm4gbmV3ICR0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCJcbiAgICB9KTtcbiAgfVxuICBwYXNzdGhyb3VnaCgpIHtcbiAgICByZXR1cm4gbmV3ICR0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHVua25vd25LZXlzOiBcInBhc3N0aHJvdWdoXCJcbiAgICB9KTtcbiAgfVxuICAvLyBjb25zdCBBdWdtZW50RmFjdG9yeSA9XG4gIC8vICAgPERlZiBleHRlbmRzIFpvZE9iamVjdERlZj4oZGVmOiBEZWYpID0+XG4gIC8vICAgPEF1Z21lbnRhdGlvbiBleHRlbmRzIFpvZFJhd1NoYXBlPihcbiAgLy8gICAgIGF1Z21lbnRhdGlvbjogQXVnbWVudGF0aW9uXG4gIC8vICAgKTogWm9kT2JqZWN0PFxuICAvLyAgICAgZXh0ZW5kU2hhcGU8UmV0dXJuVHlwZTxEZWZbXCJzaGFwZVwiXT4sIEF1Z21lbnRhdGlvbj4sXG4gIC8vICAgICBEZWZbXCJ1bmtub3duS2V5c1wiXSxcbiAgLy8gICAgIERlZltcImNhdGNoYWxsXCJdXG4gIC8vICAgPiA9PiB7XG4gIC8vICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gIC8vICAgICAgIC4uLmRlZixcbiAgLy8gICAgICAgc2hhcGU6ICgpID0+ICh7XG4gIC8vICAgICAgICAgLi4uZGVmLnNoYXBlKCksXG4gIC8vICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAvLyAgICAgICB9KSxcbiAgLy8gICAgIH0pIGFzIGFueTtcbiAgLy8gICB9O1xuICBleHRlbmQoZSkge1xuICAgIHJldHVybiBuZXcgJHQoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAuLi5lXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQcmlvciB0byB6b2RAMS4wLjEyIHRoZXJlIHdhcyBhIGJ1ZyBpbiB0aGVcbiAgICogaW5mZXJyZWQgdHlwZSBvZiBtZXJnZWQgb2JqZWN0cy4gUGxlYXNlXG4gICAqIHVwZ3JhZGUgaWYgeW91IGFyZSBleHBlcmllbmNpbmcgaXNzdWVzLlxuICAgKi9cbiAgbWVyZ2UoZSkge1xuICAgIHJldHVybiBuZXcgJHQoe1xuICAgICAgdW5rbm93bktleXM6IGUuX2RlZi51bmtub3duS2V5cyxcbiAgICAgIGNhdGNoYWxsOiBlLl9kZWYuY2F0Y2hhbGwsXG4gICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgIC4uLmUuX2RlZi5zaGFwZSgpXG4gICAgICB9KSxcbiAgICAgIHR5cGVOYW1lOiBrZS5ab2RPYmplY3RcbiAgICB9KTtcbiAgfVxuICAvLyBtZXJnZTxcbiAgLy8gICBJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdCxcbiAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBJbmNvbWluZ1tcInNoYXBlXCJdLFxuICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHtcbiAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfb3V0cHV0XCJdXG4gIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAvLyAgICAgICA6IG5ldmVyO1xuICAvLyAgIH0sXG4gIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB7XG4gIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBJbnB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cbiAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgSW5wdXRcbiAgLy8gICAgICAgPyBJbnB1dFtrXVxuICAvLyAgICAgICA6IG5ldmVyO1xuICAvLyAgIH1cbiAgLy8gPihcbiAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAvLyApOiBab2RPYmplY3Q8XG4gIC8vICAgZXh0ZW5kU2hhcGU8VCwgUmV0dXJuVHlwZTxJbmNvbWluZ1tcIl9kZWZcIl1bXCJzaGFwZVwiXT4+LFxuICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdLFxuICAvLyAgIE5ld091dHB1dCxcbiAgLy8gICBOZXdJbnB1dFxuICAvLyA+IHtcbiAgLy8gICBjb25zdCBtZXJnZWQ6IGFueSA9IG5ldyBab2RPYmplY3Qoe1xuICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gIC8vICAgICBzaGFwZTogKCkgPT5cbiAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gIC8vICAgfSkgYXMgYW55O1xuICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gIC8vIH1cbiAgc2V0S2V5KGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5hdWdtZW50KHsgW2VdOiB0IH0pO1xuICB9XG4gIC8vIG1lcmdlPEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0PihcbiAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAvLyApOiAvL1pvZE9iamVjdDxUICYgSW5jb21pbmdbXCJfc2hhcGVcIl0sIFVua25vd25LZXlzLCBDYXRjaGFsbD4gPSAobWVyZ2luZykgPT4ge1xuICAvLyBab2RPYmplY3Q8XG4gIC8vICAgZXh0ZW5kU2hhcGU8VCwgUmV0dXJuVHlwZTxJbmNvbWluZ1tcIl9kZWZcIl1bXCJzaGFwZVwiXT4+LFxuICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdXG4gIC8vID4ge1xuICAvLyAgIC8vIGNvbnN0IG1lcmdlZFNoYXBlID0gb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyhcbiAgLy8gICAvLyAgIHRoaXMuX2RlZi5zaGFwZSgpLFxuICAvLyAgIC8vICAgbWVyZ2luZy5fZGVmLnNoYXBlKClcbiAgLy8gICAvLyApO1xuICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gIC8vICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAvLyAgICAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKHRoaXMuX2RlZi5zaGFwZSgpLCBtZXJnaW5nLl9kZWYuc2hhcGUoKSksXG4gIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgLy8gICB9KSBhcyBhbnk7XG4gIC8vICAgcmV0dXJuIG1lcmdlZDtcbiAgLy8gfVxuICBjYXRjaGFsbChlKSB7XG4gICAgcmV0dXJuIG5ldyAkdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBjYXRjaGFsbDogZVxuICAgIH0pO1xuICB9XG4gIHBpY2soZSkge1xuICAgIGNvbnN0IHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHIgb2YgWmUub2JqZWN0S2V5cyhlKSlcbiAgICAgIGVbcl0gJiYgdGhpcy5zaGFwZVtyXSAmJiAodFtyXSA9IHRoaXMuc2hhcGVbcl0pO1xuICAgIHJldHVybiBuZXcgJHQoe1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgc2hhcGU6ICgpID0+IHRcbiAgICB9KTtcbiAgfVxuICBvbWl0KGUpIHtcbiAgICBjb25zdCB0ID0ge307XG4gICAgZm9yIChjb25zdCByIG9mIFplLm9iamVjdEtleXModGhpcy5zaGFwZSkpXG4gICAgICBlW3JdIHx8ICh0W3JdID0gdGhpcy5zaGFwZVtyXSk7XG4gICAgcmV0dXJuIG5ldyAkdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBzaGFwZTogKCkgPT4gdFxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZGVlcFBhcnRpYWwoKSB7XG4gICAgcmV0dXJuIG1uKHRoaXMpO1xuICB9XG4gIHBhcnRpYWwoZSkge1xuICAgIGNvbnN0IHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHIgb2YgWmUub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSkge1xuICAgICAgY29uc3QgbiA9IHRoaXMuc2hhcGVbcl07XG4gICAgICBlICYmICFlW3JdID8gdFtyXSA9IG4gOiB0W3JdID0gbi5vcHRpb25hbCgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3ICR0KHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIHNoYXBlOiAoKSA9PiB0XG4gICAgfSk7XG4gIH1cbiAgcmVxdWlyZWQoZSkge1xuICAgIGNvbnN0IHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHIgb2YgWmUub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSlcbiAgICAgIGlmIChlICYmICFlW3JdKVxuICAgICAgICB0W3JdID0gdGhpcy5zaGFwZVtyXTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgaSA9IHRoaXMuc2hhcGVbcl07XG4gICAgICAgIGZvciAoOyBpIGluc3RhbmNlb2YgZnM7IClcbiAgICAgICAgICBpID0gaS5fZGVmLmlubmVyVHlwZTtcbiAgICAgICAgdFtyXSA9IGk7XG4gICAgICB9XG4gICAgcmV0dXJuIG5ldyAkdCh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBzaGFwZTogKCkgPT4gdFxuICAgIH0pO1xuICB9XG4gIGtleW9mKCkge1xuICAgIHJldHVybiBOZihaZS5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKTtcbiAgfVxufVxuJHQuY3JlYXRlID0gKHMsIGUpID0+IG5ldyAkdCh7XG4gIHNoYXBlOiAoKSA9PiBzLFxuICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICBjYXRjaGFsbDogUHMuY3JlYXRlKCksXG4gIHR5cGVOYW1lOiBrZS5ab2RPYmplY3QsXG4gIC4uLlZlKGUpXG59KTtcbiR0LnN0cmljdENyZWF0ZSA9IChzLCBlKSA9PiBuZXcgJHQoe1xuICBzaGFwZTogKCkgPT4gcyxcbiAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gIGNhdGNoYWxsOiBQcy5jcmVhdGUoKSxcbiAgdHlwZU5hbWU6IGtlLlpvZE9iamVjdCxcbiAgLi4uVmUoZSlcbn0pO1xuJHQubGF6eWNyZWF0ZSA9IChzLCBlKSA9PiBuZXcgJHQoe1xuICBzaGFwZTogcyxcbiAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgY2F0Y2hhbGw6IFBzLmNyZWF0ZSgpLFxuICB0eXBlTmFtZToga2UuWm9kT2JqZWN0LFxuICAuLi5WZShlKVxufSk7XG5jbGFzcyB3byBleHRlbmRzIFllIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IGN0eDogdCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpLCByID0gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgZnVuY3Rpb24gbihpKSB7XG4gICAgICBmb3IgKGNvbnN0IGEgb2YgaSlcbiAgICAgICAgaWYgKGEucmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKVxuICAgICAgICAgIHJldHVybiBhLnJlc3VsdDtcbiAgICAgIGZvciAoY29uc3QgYSBvZiBpKVxuICAgICAgICBpZiAoYS5yZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgcmV0dXJuIHQuY29tbW9uLmlzc3Vlcy5wdXNoKC4uLmEuY3R4LmNvbW1vbi5pc3N1ZXMpLCBhLnJlc3VsdDtcbiAgICAgIGNvbnN0IG8gPSBpLm1hcCgoYSkgPT4gbmV3IHBzKGEuY3R4LmNvbW1vbi5pc3N1ZXMpKTtcbiAgICAgIHJldHVybiBoZSh0LCB7XG4gICAgICAgIGNvZGU6IGFlLmludmFsaWRfdW5pb24sXG4gICAgICAgIHVuaW9uRXJyb3JzOiBvXG4gICAgICB9KSwgUmU7XG4gICAgfVxuICAgIGlmICh0LmNvbW1vbi5hc3luYylcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbChyLm1hcChhc3luYyAoaSkgPT4ge1xuICAgICAgICBjb25zdCBvID0ge1xuICAgICAgICAgIC4uLnQsXG4gICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAuLi50LmNvbW1vbixcbiAgICAgICAgICAgIGlzc3VlczogW11cbiAgICAgICAgICB9LFxuICAgICAgICAgIHBhcmVudDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDogYXdhaXQgaS5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICBkYXRhOiB0LmRhdGEsXG4gICAgICAgICAgICBwYXRoOiB0LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IG9cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBjdHg6IG9cbiAgICAgICAgfTtcbiAgICAgIH0pKS50aGVuKG4pO1xuICAgIHtcbiAgICAgIGxldCBpO1xuICAgICAgY29uc3QgbyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBsIG9mIHIpIHtcbiAgICAgICAgY29uc3QgYyA9IHtcbiAgICAgICAgICAuLi50LFxuICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgLi4udC5jb21tb24sXG4gICAgICAgICAgICBpc3N1ZXM6IFtdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXJlbnQ6IG51bGxcbiAgICAgICAgfSwgdSA9IGwuX3BhcnNlU3luYyh7XG4gICAgICAgICAgZGF0YTogdC5kYXRhLFxuICAgICAgICAgIHBhdGg6IHQucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IGNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh1LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKVxuICAgICAgICAgIHJldHVybiB1O1xuICAgICAgICB1LnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmICFpICYmIChpID0geyByZXN1bHQ6IHUsIGN0eDogYyB9KSwgYy5jb21tb24uaXNzdWVzLmxlbmd0aCAmJiBvLnB1c2goYy5jb21tb24uaXNzdWVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpKVxuICAgICAgICByZXR1cm4gdC5jb21tb24uaXNzdWVzLnB1c2goLi4uaS5jdHguY29tbW9uLmlzc3VlcyksIGkucmVzdWx0O1xuICAgICAgY29uc3QgYSA9IG8ubWFwKChsKSA9PiBuZXcgcHMobCkpO1xuICAgICAgcmV0dXJuIGhlKHQsIHtcbiAgICAgICAgY29kZTogYWUuaW52YWxpZF91bmlvbixcbiAgICAgICAgdW5pb25FcnJvcnM6IGFcbiAgICAgIH0pLCBSZTtcbiAgICB9XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xuICB9XG59XG53by5jcmVhdGUgPSAocywgZSkgPT4gbmV3IHdvKHtcbiAgb3B0aW9uczogcyxcbiAgdHlwZU5hbWU6IGtlLlpvZFVuaW9uLFxuICAuLi5WZShlKVxufSk7XG5jb25zdCBvcyA9IChzKSA9PiBzIGluc3RhbmNlb2YgWWwgPyBvcyhzLnNjaGVtYSkgOiBzIGluc3RhbmNlb2YgWXMgPyBvcyhzLmlubmVyVHlwZSgpKSA6IHMgaW5zdGFuY2VvZiBJbyA/IFtzLnZhbHVlXSA6IHMgaW5zdGFuY2VvZiB6cyA/IHMub3B0aW9ucyA6IHMgaW5zdGFuY2VvZiBabCA/IFplLm9iamVjdFZhbHVlcyhzLmVudW0pIDogcyBpbnN0YW5jZW9mIFJvID8gb3Mocy5fZGVmLmlubmVyVHlwZSkgOiBzIGluc3RhbmNlb2YgcWwgPyBbdm9pZCAwXSA6IHMgaW5zdGFuY2VvZiBXbCA/IFtudWxsXSA6IHMgaW5zdGFuY2VvZiBmcyA/IFt2b2lkIDAsIC4uLm9zKHMudW53cmFwKCkpXSA6IHMgaW5zdGFuY2VvZiBacyA/IFtudWxsLCAuLi5vcyhzLnVud3JhcCgpKV0gOiBzIGluc3RhbmNlb2YgVWYgfHwgcyBpbnN0YW5jZW9mIENvID8gb3Mocy51bndyYXAoKSkgOiBzIGluc3RhbmNlb2YgTG8gPyBvcyhzLl9kZWYuaW5uZXJUeXBlKSA6IFtdO1xuY2xhc3MgVWMgZXh0ZW5kcyBZZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgeyBjdHg6IHQgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhlKTtcbiAgICBpZiAodC5wYXJzZWRUeXBlICE9PSBtZS5vYmplY3QpXG4gICAgICByZXR1cm4gaGUodCwge1xuICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBtZS5vYmplY3QsXG4gICAgICAgIHJlY2VpdmVkOiB0LnBhcnNlZFR5cGVcbiAgICAgIH0pLCBSZTtcbiAgICBjb25zdCByID0gdGhpcy5kaXNjcmltaW5hdG9yLCBuID0gdC5kYXRhW3JdLCBpID0gdGhpcy5vcHRpb25zTWFwLmdldChuKTtcbiAgICByZXR1cm4gaSA/IHQuY29tbW9uLmFzeW5jID8gaS5fcGFyc2VBc3luYyh7XG4gICAgICBkYXRhOiB0LmRhdGEsXG4gICAgICBwYXRoOiB0LnBhdGgsXG4gICAgICBwYXJlbnQ6IHRcbiAgICB9KSA6IGkuX3BhcnNlU3luYyh7XG4gICAgICBkYXRhOiB0LmRhdGEsXG4gICAgICBwYXRoOiB0LnBhdGgsXG4gICAgICBwYXJlbnQ6IHRcbiAgICB9KSA6IChoZSh0LCB7XG4gICAgICBjb2RlOiBhZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IsXG4gICAgICBvcHRpb25zOiBBcnJheS5mcm9tKHRoaXMub3B0aW9uc01hcC5rZXlzKCkpLFxuICAgICAgcGF0aDogW3JdXG4gICAgfSksIFJlKTtcbiAgfVxuICBnZXQgZGlzY3JpbWluYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmRpc2NyaW1pbmF0b3I7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xuICB9XG4gIGdldCBvcHRpb25zTWFwKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9uc01hcDtcbiAgfVxuICAvKipcbiAgICogVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkaXNjcmltaW5hdGVkIHVuaW9uIHNjaGVtYS4gSXRzIGJlaGF2aW91ciBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhhdCBvZiB0aGUgbm9ybWFsIHoudW5pb24oKSBjb25zdHJ1Y3Rvci5cbiAgICogSG93ZXZlciwgaXQgb25seSBhbGxvd3MgYSB1bmlvbiBvZiBvYmplY3RzLCBhbGwgb2Ygd2hpY2ggbmVlZCB0byBzaGFyZSBhIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkuIFRoaXMgcHJvcGVydHkgbXVzdFxuICAgKiBoYXZlIGEgZGlmZmVyZW50IHZhbHVlIGZvciBlYWNoIG9iamVjdCBpbiB0aGUgdW5pb24uXG4gICAqIEBwYXJhbSBkaXNjcmltaW5hdG9yIHRoZSBuYW1lIG9mIHRoZSBkaXNjcmltaW5hdG9yIHByb3BlcnR5XG4gICAqIEBwYXJhbSB0eXBlcyBhbiBhcnJheSBvZiBvYmplY3Qgc2NoZW1hc1xuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKGUsIHQsIHIpIHtcbiAgICBjb25zdCBuID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGkgb2YgdCkge1xuICAgICAgY29uc3QgbyA9IG9zKGkuc2hhcGVbZV0pO1xuICAgICAgaWYgKCFvLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGRpc2NyaW1pbmF0b3IgdmFsdWUgZm9yIGtleSBcXGAke2V9XFxgIGNvdWxkIG5vdCBiZSBleHRyYWN0ZWQgZnJvbSBhbGwgc2NoZW1hIG9wdGlvbnNgKTtcbiAgICAgIGZvciAoY29uc3QgYSBvZiBvKSB7XG4gICAgICAgIGlmIChuLmhhcyhhKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZSl9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcoYSl9YCk7XG4gICAgICAgIG4uc2V0KGEsIGkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFVjKHtcbiAgICAgIHR5cGVOYW1lOiBrZS5ab2REaXNjcmltaW5hdGVkVW5pb24sXG4gICAgICBkaXNjcmltaW5hdG9yOiBlLFxuICAgICAgb3B0aW9uczogdCxcbiAgICAgIG9wdGlvbnNNYXA6IG4sXG4gICAgICAuLi5WZShyKVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiB6bChzLCBlKSB7XG4gIGNvbnN0IHQgPSB3cyhzKSwgciA9IHdzKGUpO1xuICBpZiAocyA9PT0gZSlcbiAgICByZXR1cm4geyB2YWxpZDogITAsIGRhdGE6IHMgfTtcbiAgaWYgKHQgPT09IG1lLm9iamVjdCAmJiByID09PSBtZS5vYmplY3QpIHtcbiAgICBjb25zdCBuID0gWmUub2JqZWN0S2V5cyhlKSwgaSA9IFplLm9iamVjdEtleXMocykuZmlsdGVyKChhKSA9PiBuLmluZGV4T2YoYSkgIT09IC0xKSwgbyA9IHsgLi4ucywgLi4uZSB9O1xuICAgIGZvciAoY29uc3QgYSBvZiBpKSB7XG4gICAgICBjb25zdCBsID0gemwoc1thXSwgZVthXSk7XG4gICAgICBpZiAoIWwudmFsaWQpXG4gICAgICAgIHJldHVybiB7IHZhbGlkOiAhMSB9O1xuICAgICAgb1thXSA9IGwuZGF0YTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsaWQ6ICEwLCBkYXRhOiBvIH07XG4gIH0gZWxzZSBpZiAodCA9PT0gbWUuYXJyYXkgJiYgciA9PT0gbWUuYXJyYXkpIHtcbiAgICBpZiAocy5sZW5ndGggIT09IGUubGVuZ3RoKVxuICAgICAgcmV0dXJuIHsgdmFsaWQ6ICExIH07XG4gICAgY29uc3QgbiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbyA9IHNbaV0sIGEgPSBlW2ldLCBsID0gemwobywgYSk7XG4gICAgICBpZiAoIWwudmFsaWQpXG4gICAgICAgIHJldHVybiB7IHZhbGlkOiAhMSB9O1xuICAgICAgbi5wdXNoKGwuZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB7IHZhbGlkOiAhMCwgZGF0YTogbiB9O1xuICB9IGVsc2UgcmV0dXJuIHQgPT09IG1lLmRhdGUgJiYgciA9PT0gbWUuZGF0ZSAmJiArcyA9PSArZSA/IHsgdmFsaWQ6ICEwLCBkYXRhOiBzIH0gOiB7IHZhbGlkOiAhMSB9O1xufVxuY2xhc3MgQW8gZXh0ZW5kcyBZZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgeyBzdGF0dXM6IHQsIGN0eDogciB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpLCBuID0gKGksIG8pID0+IHtcbiAgICAgIGlmIChadShpKSB8fCBadShvKSlcbiAgICAgICAgcmV0dXJuIFJlO1xuICAgICAgY29uc3QgYSA9IHpsKGkudmFsdWUsIG8udmFsdWUpO1xuICAgICAgcmV0dXJuIGEudmFsaWQgPyAoKFh1KGkpIHx8IFh1KG8pKSAmJiB0LmRpcnR5KCksIHsgc3RhdHVzOiB0LnZhbHVlLCB2YWx1ZTogYS5kYXRhIH0pIDogKGhlKHIsIHtcbiAgICAgICAgY29kZTogYWUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcbiAgICAgIH0pLCBSZSk7XG4gICAgfTtcbiAgICByZXR1cm4gci5jb21tb24uYXN5bmMgPyBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLl9kZWYubGVmdC5fcGFyc2VBc3luYyh7XG4gICAgICAgIGRhdGE6IHIuZGF0YSxcbiAgICAgICAgcGF0aDogci5wYXRoLFxuICAgICAgICBwYXJlbnQ6IHJcbiAgICAgIH0pLFxuICAgICAgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgZGF0YTogci5kYXRhLFxuICAgICAgICBwYXRoOiByLnBhdGgsXG4gICAgICAgIHBhcmVudDogclxuICAgICAgfSlcbiAgICBdKS50aGVuKChbaSwgb10pID0+IG4oaSwgbykpIDogbih0aGlzLl9kZWYubGVmdC5fcGFyc2VTeW5jKHtcbiAgICAgIGRhdGE6IHIuZGF0YSxcbiAgICAgIHBhdGg6IHIucGF0aCxcbiAgICAgIHBhcmVudDogclxuICAgIH0pLCB0aGlzLl9kZWYucmlnaHQuX3BhcnNlU3luYyh7XG4gICAgICBkYXRhOiByLmRhdGEsXG4gICAgICBwYXRoOiByLnBhdGgsXG4gICAgICBwYXJlbnQ6IHJcbiAgICB9KSk7XG4gIH1cbn1cbkFvLmNyZWF0ZSA9IChzLCBlLCB0KSA9PiBuZXcgQW8oe1xuICBsZWZ0OiBzLFxuICByaWdodDogZSxcbiAgdHlwZU5hbWU6IGtlLlpvZEludGVyc2VjdGlvbixcbiAgLi4uVmUodClcbn0pO1xuY2xhc3MgV3MgZXh0ZW5kcyBZZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgeyBzdGF0dXM6IHQsIGN0eDogciB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGlmIChyLnBhcnNlZFR5cGUgIT09IG1lLmFycmF5KVxuICAgICAgcmV0dXJuIGhlKHIsIHtcbiAgICAgICAgY29kZTogYWUuaW52YWxpZF90eXBlLFxuICAgICAgICBleHBlY3RlZDogbWUuYXJyYXksXG4gICAgICAgIHJlY2VpdmVkOiByLnBhcnNlZFR5cGVcbiAgICAgIH0pLCBSZTtcbiAgICBpZiAoci5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpXG4gICAgICByZXR1cm4gaGUociwge1xuICAgICAgICBjb2RlOiBhZS50b29fc21hbGwsXG4gICAgICAgIG1pbmltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICAgIGV4YWN0OiAhMSxcbiAgICAgICAgdHlwZTogXCJhcnJheVwiXG4gICAgICB9KSwgUmU7XG4gICAgIXRoaXMuX2RlZi5yZXN0ICYmIHIuZGF0YS5sZW5ndGggPiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoICYmIChoZShyLCB7XG4gICAgICBjb2RlOiBhZS50b29fYmlnLFxuICAgICAgbWF4aW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICBleGFjdDogITEsXG4gICAgICB0eXBlOiBcImFycmF5XCJcbiAgICB9KSwgdC5kaXJ0eSgpKTtcbiAgICBjb25zdCBpID0gWy4uLnIuZGF0YV0ubWFwKChvLCBhKSA9PiB7XG4gICAgICBjb25zdCBsID0gdGhpcy5fZGVmLml0ZW1zW2FdIHx8IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgcmV0dXJuIGwgPyBsLl9wYXJzZShuZXcgRHMociwgbywgci5wYXRoLCBhKSkgOiBudWxsO1xuICAgIH0pLmZpbHRlcigobykgPT4gISFvKTtcbiAgICByZXR1cm4gci5jb21tb24uYXN5bmMgPyBQcm9taXNlLmFsbChpKS50aGVuKChvKSA9PiB3ci5tZXJnZUFycmF5KHQsIG8pKSA6IHdyLm1lcmdlQXJyYXkodCwgaSk7XG4gIH1cbiAgZ2V0IGl0ZW1zKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaXRlbXM7XG4gIH1cbiAgcmVzdChlKSB7XG4gICAgcmV0dXJuIG5ldyBXcyh7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICByZXN0OiBlXG4gICAgfSk7XG4gIH1cbn1cbldzLmNyZWF0ZSA9IChzLCBlKSA9PiB7XG4gIGlmICghQXJyYXkuaXNBcnJheShzKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGFuIGFycmF5IG9mIHNjaGVtYXMgdG8gei50dXBsZShbIC4uLiBdKVwiKTtcbiAgcmV0dXJuIG5ldyBXcyh7XG4gICAgaXRlbXM6IHMsXG4gICAgdHlwZU5hbWU6IGtlLlpvZFR1cGxlLFxuICAgIHJlc3Q6IG51bGwsXG4gICAgLi4uVmUoZSlcbiAgfSk7XG59O1xuY2xhc3Mgc2QgZXh0ZW5kcyBZZSB7XG4gIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5rZXlUeXBlO1xuICB9XG4gIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIGNvbnN0IHsgc3RhdHVzOiB0LCBjdHg6IHIgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhlKTtcbiAgICBpZiAoci5wYXJzZWRUeXBlICE9PSBtZS5tYXApXG4gICAgICByZXR1cm4gaGUociwge1xuICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBtZS5tYXAsXG4gICAgICAgIHJlY2VpdmVkOiByLnBhcnNlZFR5cGVcbiAgICAgIH0pLCBSZTtcbiAgICBjb25zdCBuID0gdGhpcy5fZGVmLmtleVR5cGUsIGkgPSB0aGlzLl9kZWYudmFsdWVUeXBlLCBvID0gWy4uLnIuZGF0YS5lbnRyaWVzKCldLm1hcCgoW2EsIGxdLCBjKSA9PiAoe1xuICAgICAga2V5OiBuLl9wYXJzZShuZXcgRHMociwgYSwgci5wYXRoLCBbYywgXCJrZXlcIl0pKSxcbiAgICAgIHZhbHVlOiBpLl9wYXJzZShuZXcgRHMociwgbCwgci5wYXRoLCBbYywgXCJ2YWx1ZVwiXSkpXG4gICAgfSkpO1xuICAgIGlmIChyLmNvbW1vbi5hc3luYykge1xuICAgICAgY29uc3QgYSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgbCBvZiBvKSB7XG4gICAgICAgICAgY29uc3QgYyA9IGF3YWl0IGwua2V5LCB1ID0gYXdhaXQgbC52YWx1ZTtcbiAgICAgICAgICBpZiAoYy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHUuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgIHJldHVybiBSZTtcbiAgICAgICAgICAoYy5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB1LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSAmJiB0LmRpcnR5KCksIGEuc2V0KGMudmFsdWUsIHUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogdC52YWx1ZSwgdmFsdWU6IGEgfTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgIGZvciAoY29uc3QgbCBvZiBvKSB7XG4gICAgICAgIGNvbnN0IGMgPSBsLmtleSwgdSA9IGwudmFsdWU7XG4gICAgICAgIGlmIChjLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgIHJldHVybiBSZTtcbiAgICAgICAgKGMuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdS5zdGF0dXMgPT09IFwiZGlydHlcIikgJiYgdC5kaXJ0eSgpLCBhLnNldChjLnZhbHVlLCB1LnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN0YXR1czogdC52YWx1ZSwgdmFsdWU6IGEgfTtcbiAgICB9XG4gIH1cbn1cbnNkLmNyZWF0ZSA9IChzLCBlLCB0KSA9PiBuZXcgc2Qoe1xuICB2YWx1ZVR5cGU6IGUsXG4gIGtleVR5cGU6IHMsXG4gIHR5cGVOYW1lOiBrZS5ab2RNYXAsXG4gIC4uLlZlKHQpXG59KTtcbmNsYXNzIFFuIGV4dGVuZHMgWWUge1xuICBfcGFyc2UoZSkge1xuICAgIGNvbnN0IHsgc3RhdHVzOiB0LCBjdHg6IHIgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhlKTtcbiAgICBpZiAoci5wYXJzZWRUeXBlICE9PSBtZS5zZXQpXG4gICAgICByZXR1cm4gaGUociwge1xuICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBtZS5zZXQsXG4gICAgICAgIHJlY2VpdmVkOiByLnBhcnNlZFR5cGVcbiAgICAgIH0pLCBSZTtcbiAgICBjb25zdCBuID0gdGhpcy5fZGVmO1xuICAgIG4ubWluU2l6ZSAhPT0gbnVsbCAmJiByLmRhdGEuc2l6ZSA8IG4ubWluU2l6ZS52YWx1ZSAmJiAoaGUociwge1xuICAgICAgY29kZTogYWUudG9vX3NtYWxsLFxuICAgICAgbWluaW11bTogbi5taW5TaXplLnZhbHVlLFxuICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgIGluY2x1c2l2ZTogITAsXG4gICAgICBleGFjdDogITEsXG4gICAgICBtZXNzYWdlOiBuLm1pblNpemUubWVzc2FnZVxuICAgIH0pLCB0LmRpcnR5KCkpLCBuLm1heFNpemUgIT09IG51bGwgJiYgci5kYXRhLnNpemUgPiBuLm1heFNpemUudmFsdWUgJiYgKGhlKHIsIHtcbiAgICAgIGNvZGU6IGFlLnRvb19iaWcsXG4gICAgICBtYXhpbXVtOiBuLm1heFNpemUudmFsdWUsXG4gICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgaW5jbHVzaXZlOiAhMCxcbiAgICAgIGV4YWN0OiAhMSxcbiAgICAgIG1lc3NhZ2U6IG4ubWF4U2l6ZS5tZXNzYWdlXG4gICAgfSksIHQuZGlydHkoKSk7XG4gICAgY29uc3QgaSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgZnVuY3Rpb24gbyhsKSB7XG4gICAgICBjb25zdCBjID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgIGZvciAoY29uc3QgdSBvZiBsKSB7XG4gICAgICAgIGlmICh1LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgcmV0dXJuIFJlO1xuICAgICAgICB1LnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmIHQuZGlydHkoKSwgYy5hZGQodS52YWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdGF0dXM6IHQudmFsdWUsIHZhbHVlOiBjIH07XG4gICAgfVxuICAgIGNvbnN0IGEgPSBbLi4uci5kYXRhLnZhbHVlcygpXS5tYXAoKGwsIGMpID0+IGkuX3BhcnNlKG5ldyBEcyhyLCBsLCByLnBhdGgsIGMpKSk7XG4gICAgcmV0dXJuIHIuY29tbW9uLmFzeW5jID8gUHJvbWlzZS5hbGwoYSkudGhlbigobCkgPT4gbyhsKSkgOiBvKGEpO1xuICB9XG4gIG1pbihlLCB0KSB7XG4gICAgcmV0dXJuIG5ldyBRbih7XG4gICAgICAuLi50aGlzLl9kZWYsXG4gICAgICBtaW5TaXplOiB7IHZhbHVlOiBlLCBtZXNzYWdlOiBFZS50b1N0cmluZyh0KSB9XG4gICAgfSk7XG4gIH1cbiAgbWF4KGUsIHQpIHtcbiAgICByZXR1cm4gbmV3IFFuKHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIG1heFNpemU6IHsgdmFsdWU6IGUsIG1lc3NhZ2U6IEVlLnRvU3RyaW5nKHQpIH1cbiAgICB9KTtcbiAgfVxuICBzaXplKGUsIHQpIHtcbiAgICByZXR1cm4gdGhpcy5taW4oZSwgdCkubWF4KGUsIHQpO1xuICB9XG4gIG5vbmVtcHR5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5taW4oMSwgZSk7XG4gIH1cbn1cblFuLmNyZWF0ZSA9IChzLCBlKSA9PiBuZXcgUW4oe1xuICB2YWx1ZVR5cGU6IHMsXG4gIG1pblNpemU6IG51bGwsXG4gIG1heFNpemU6IG51bGwsXG4gIHR5cGVOYW1lOiBrZS5ab2RTZXQsXG4gIC4uLlZlKGUpXG59KTtcbmNsYXNzIFlsIGV4dGVuZHMgWWUge1xuICBnZXQgc2NoZW1hKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuZ2V0dGVyKCk7XG4gIH1cbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IGN0eDogdCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIHJldHVybiB0aGlzLl9kZWYuZ2V0dGVyKCkuX3BhcnNlKHsgZGF0YTogdC5kYXRhLCBwYXRoOiB0LnBhdGgsIHBhcmVudDogdCB9KTtcbiAgfVxufVxuWWwuY3JlYXRlID0gKHMsIGUpID0+IG5ldyBZbCh7XG4gIGdldHRlcjogcyxcbiAgdHlwZU5hbWU6IGtlLlpvZExhenksXG4gIC4uLlZlKGUpXG59KTtcbmNsYXNzIElvIGV4dGVuZHMgWWUge1xuICBfcGFyc2UoZSkge1xuICAgIGlmIChlLmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xuICAgICAgY29uc3QgdCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpO1xuICAgICAgcmV0dXJuIGhlKHQsIHtcbiAgICAgICAgcmVjZWl2ZWQ6IHQuZGF0YSxcbiAgICAgICAgY29kZTogYWUuaW52YWxpZF9saXRlcmFsLFxuICAgICAgICBleHBlY3RlZDogdGhpcy5fZGVmLnZhbHVlXG4gICAgICB9KSwgUmU7XG4gICAgfVxuICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogZS5kYXRhIH07XG4gIH1cbiAgZ2V0IHZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWU7XG4gIH1cbn1cbklvLmNyZWF0ZSA9IChzLCBlKSA9PiBuZXcgSW8oe1xuICB2YWx1ZTogcyxcbiAgdHlwZU5hbWU6IGtlLlpvZExpdGVyYWwsXG4gIC4uLlZlKGUpXG59KTtcbmZ1bmN0aW9uIE5mKHMsIGUpIHtcbiAgcmV0dXJuIG5ldyB6cyh7XG4gICAgdmFsdWVzOiBzLFxuICAgIHR5cGVOYW1lOiBrZS5ab2RFbnVtLFxuICAgIC4uLlZlKGUpXG4gIH0pO1xufVxuY2xhc3MgenMgZXh0ZW5kcyBZZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgaWYgKHR5cGVvZiBlLmRhdGEgIT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgdCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGUpLCByID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgIHJldHVybiBoZSh0LCB7XG4gICAgICAgIGV4cGVjdGVkOiBaZS5qb2luVmFsdWVzKHIpLFxuICAgICAgICByZWNlaXZlZDogdC5wYXJzZWRUeXBlLFxuICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX3R5cGVcbiAgICAgIH0pLCBSZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NhY2hlIHx8ICh0aGlzLl9jYWNoZSA9IG5ldyBTZXQodGhpcy5fZGVmLnZhbHVlcykpLCAhdGhpcy5fY2FjaGUuaGFzKGUuZGF0YSkpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLl9nZXRPclJldHVybkN0eChlKSwgciA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICByZXR1cm4gaGUodCwge1xuICAgICAgICByZWNlaXZlZDogdC5kYXRhLFxuICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgIG9wdGlvbnM6IHJcbiAgICAgIH0pLCBSZTtcbiAgICB9XG4gICAgcmV0dXJuIFJyKGUuZGF0YSk7XG4gIH1cbiAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZXM7XG4gIH1cbiAgZ2V0IGVudW0oKSB7XG4gICAgY29uc3QgZSA9IHt9O1xuICAgIGZvciAoY29uc3QgdCBvZiB0aGlzLl9kZWYudmFsdWVzKVxuICAgICAgZVt0XSA9IHQ7XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZ2V0IFZhbHVlcygpIHtcbiAgICBjb25zdCBlID0ge307XG4gICAgZm9yIChjb25zdCB0IG9mIHRoaXMuX2RlZi52YWx1ZXMpXG4gICAgICBlW3RdID0gdDtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBnZXQgRW51bSgpIHtcbiAgICBjb25zdCBlID0ge307XG4gICAgZm9yIChjb25zdCB0IG9mIHRoaXMuX2RlZi52YWx1ZXMpXG4gICAgICBlW3RdID0gdDtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBleHRyYWN0KGUsIHQgPSB0aGlzLl9kZWYpIHtcbiAgICByZXR1cm4genMuY3JlYXRlKGUsIHtcbiAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgIC4uLnRcbiAgICB9KTtcbiAgfVxuICBleGNsdWRlKGUsIHQgPSB0aGlzLl9kZWYpIHtcbiAgICByZXR1cm4genMuY3JlYXRlKHRoaXMub3B0aW9ucy5maWx0ZXIoKHIpID0+ICFlLmluY2x1ZGVzKHIpKSwge1xuICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgLi4udFxuICAgIH0pO1xuICB9XG59XG56cy5jcmVhdGUgPSBOZjtcbmNsYXNzIFpsIGV4dGVuZHMgWWUge1xuICBfcGFyc2UoZSkge1xuICAgIGNvbnN0IHQgPSBaZS5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyksIHIgPSB0aGlzLl9nZXRPclJldHVybkN0eChlKTtcbiAgICBpZiAoci5wYXJzZWRUeXBlICE9PSBtZS5zdHJpbmcgJiYgci5wYXJzZWRUeXBlICE9PSBtZS5udW1iZXIpIHtcbiAgICAgIGNvbnN0IG4gPSBaZS5vYmplY3RWYWx1ZXModCk7XG4gICAgICByZXR1cm4gaGUociwge1xuICAgICAgICBleHBlY3RlZDogWmUuam9pblZhbHVlcyhuKSxcbiAgICAgICAgcmVjZWl2ZWQ6IHIucGFyc2VkVHlwZSxcbiAgICAgICAgY29kZTogYWUuaW52YWxpZF90eXBlXG4gICAgICB9KSwgUmU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9jYWNoZSB8fCAodGhpcy5fY2FjaGUgPSBuZXcgU2V0KFplLmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKSkpLCAhdGhpcy5fY2FjaGUuaGFzKGUuZGF0YSkpIHtcbiAgICAgIGNvbnN0IG4gPSBaZS5vYmplY3RWYWx1ZXModCk7XG4gICAgICByZXR1cm4gaGUociwge1xuICAgICAgICByZWNlaXZlZDogci5kYXRhLFxuICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgIG9wdGlvbnM6IG5cbiAgICAgIH0pLCBSZTtcbiAgICB9XG4gICAgcmV0dXJuIFJyKGUuZGF0YSk7XG4gIH1cbiAgZ2V0IGVudW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZXM7XG4gIH1cbn1cblpsLmNyZWF0ZSA9IChzLCBlKSA9PiBuZXcgWmwoe1xuICB2YWx1ZXM6IHMsXG4gIHR5cGVOYW1lOiBrZS5ab2ROYXRpdmVFbnVtLFxuICAuLi5WZShlKVxufSk7XG5jbGFzcyBfbyBleHRlbmRzIFllIHtcbiAgdW53cmFwKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgfVxuICBfcGFyc2UoZSkge1xuICAgIGNvbnN0IHsgY3R4OiB0IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSk7XG4gICAgaWYgKHQucGFyc2VkVHlwZSAhPT0gbWUucHJvbWlzZSAmJiB0LmNvbW1vbi5hc3luYyA9PT0gITEpXG4gICAgICByZXR1cm4gaGUodCwge1xuICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBtZS5wcm9taXNlLFxuICAgICAgICByZWNlaXZlZDogdC5wYXJzZWRUeXBlXG4gICAgICB9KSwgUmU7XG4gICAgY29uc3QgciA9IHQucGFyc2VkVHlwZSA9PT0gbWUucHJvbWlzZSA/IHQuZGF0YSA6IFByb21pc2UucmVzb2x2ZSh0LmRhdGEpO1xuICAgIHJldHVybiBScihyLnRoZW4oKG4pID0+IHRoaXMuX2RlZi50eXBlLnBhcnNlQXN5bmMobiwge1xuICAgICAgcGF0aDogdC5wYXRoLFxuICAgICAgZXJyb3JNYXA6IHQuY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcFxuICAgIH0pKSk7XG4gIH1cbn1cbl9vLmNyZWF0ZSA9IChzLCBlKSA9PiBuZXcgX28oe1xuICB0eXBlOiBzLFxuICB0eXBlTmFtZToga2UuWm9kUHJvbWlzZSxcbiAgLi4uVmUoZSlcbn0pO1xuY2xhc3MgWXMgZXh0ZW5kcyBZZSB7XG4gIGlubmVyVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYTtcbiAgfVxuICBzb3VyY2VUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9kZWYudHlwZU5hbWUgPT09IGtlLlpvZEVmZmVjdHMgPyB0aGlzLl9kZWYuc2NoZW1hLnNvdXJjZVR5cGUoKSA6IHRoaXMuX2RlZi5zY2hlbWE7XG4gIH1cbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IHN0YXR1czogdCwgY3R4OiByIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSksIG4gPSB0aGlzLl9kZWYuZWZmZWN0IHx8IG51bGwsIGkgPSB7XG4gICAgICBhZGRJc3N1ZTogKG8pID0+IHtcbiAgICAgICAgaGUociwgbyksIG8uZmF0YWwgPyB0LmFib3J0KCkgOiB0LmRpcnR5KCk7XG4gICAgICB9LFxuICAgICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiByLnBhdGg7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaS5hZGRJc3N1ZSA9IGkuYWRkSXNzdWUuYmluZChpKSwgbi50eXBlID09PSBcInByZXByb2Nlc3NcIikge1xuICAgICAgY29uc3QgbyA9IG4udHJhbnNmb3JtKHIuZGF0YSwgaSk7XG4gICAgICBpZiAoci5jb21tb24uYXN5bmMpXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobykudGhlbihhc3luYyAoYSkgPT4ge1xuICAgICAgICAgIGlmICh0LnZhbHVlID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgIHJldHVybiBSZTtcbiAgICAgICAgICBjb25zdCBsID0gYXdhaXQgdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICBkYXRhOiBhLFxuICAgICAgICAgICAgcGF0aDogci5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiByXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGwuc3RhdHVzID09PSBcImFib3J0ZWRcIiA/IFJlIDogbC5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB0LnZhbHVlID09PSBcImRpcnR5XCIgPyBXbihsLnZhbHVlKSA6IGw7XG4gICAgICAgIH0pO1xuICAgICAge1xuICAgICAgICBpZiAodC52YWx1ZSA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgcmV0dXJuIFJlO1xuICAgICAgICBjb25zdCBhID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICBkYXRhOiBvLFxuICAgICAgICAgIHBhdGg6IHIucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IHJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgPyBSZSA6IGEuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdC52YWx1ZSA9PT0gXCJkaXJ0eVwiID8gV24oYS52YWx1ZSkgOiBhO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobi50eXBlID09PSBcInJlZmluZW1lbnRcIikge1xuICAgICAgY29uc3QgbyA9IChhKSA9PiB7XG4gICAgICAgIGNvbnN0IGwgPSBuLnJlZmluZW1lbnQoYSwgaSk7XG4gICAgICAgIGlmIChyLmNvbW1vbi5hc3luYylcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGwpO1xuICAgICAgICBpZiAobCBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXN5bmMgcmVmaW5lbWVudCBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5cIik7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfTtcbiAgICAgIGlmIChyLmNvbW1vbi5hc3luYyA9PT0gITEpIHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgZGF0YTogci5kYXRhLFxuICAgICAgICAgIHBhdGg6IHIucGF0aCxcbiAgICAgICAgICBwYXJlbnQ6IHJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBhLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgPyBSZSA6IChhLnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmIHQuZGlydHkoKSwgbyhhLnZhbHVlKSwgeyBzdGF0dXM6IHQudmFsdWUsIHZhbHVlOiBhLnZhbHVlIH0pO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHsgZGF0YTogci5kYXRhLCBwYXRoOiByLnBhdGgsIHBhcmVudDogciB9KS50aGVuKChhKSA9PiBhLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgPyBSZSA6IChhLnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmIHQuZGlydHkoKSwgbyhhLnZhbHVlKS50aGVuKCgpID0+ICh7IHN0YXR1czogdC52YWx1ZSwgdmFsdWU6IGEudmFsdWUgfSkpKSk7XG4gICAgfVxuICAgIGlmIChuLnR5cGUgPT09IFwidHJhbnNmb3JtXCIpXG4gICAgICBpZiAoci5jb21tb24uYXN5bmMgPT09ICExKSB7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgIGRhdGE6IHIuZGF0YSxcbiAgICAgICAgICBwYXRoOiByLnBhdGgsXG4gICAgICAgICAgcGFyZW50OiByXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIUxuKG8pKVxuICAgICAgICAgIHJldHVybiBSZTtcbiAgICAgICAgY29uc3QgYSA9IG4udHJhbnNmb3JtKG8udmFsdWUsIGkpO1xuICAgICAgICBpZiAoYSBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXN5bmNocm9ub3VzIHRyYW5zZm9ybSBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5cIik7XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogdC52YWx1ZSwgdmFsdWU6IGEgfTtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7IGRhdGE6IHIuZGF0YSwgcGF0aDogci5wYXRoLCBwYXJlbnQ6IHIgfSkudGhlbigobykgPT4gTG4obykgPyBQcm9taXNlLnJlc29sdmUobi50cmFuc2Zvcm0oby52YWx1ZSwgaSkpLnRoZW4oKGEpID0+ICh7XG4gICAgICAgICAgc3RhdHVzOiB0LnZhbHVlLFxuICAgICAgICAgIHZhbHVlOiBhXG4gICAgICAgIH0pKSA6IFJlKTtcbiAgICBaZS5hc3NlcnROZXZlcihuKTtcbiAgfVxufVxuWXMuY3JlYXRlID0gKHMsIGUsIHQpID0+IG5ldyBZcyh7XG4gIHNjaGVtYTogcyxcbiAgdHlwZU5hbWU6IGtlLlpvZEVmZmVjdHMsXG4gIGVmZmVjdDogZSxcbiAgLi4uVmUodClcbn0pO1xuWXMuY3JlYXRlV2l0aFByZXByb2Nlc3MgPSAocywgZSwgdCkgPT4gbmV3IFlzKHtcbiAgc2NoZW1hOiBlLFxuICBlZmZlY3Q6IHsgdHlwZTogXCJwcmVwcm9jZXNzXCIsIHRyYW5zZm9ybTogcyB9LFxuICB0eXBlTmFtZToga2UuWm9kRWZmZWN0cyxcbiAgLi4uVmUodClcbn0pO1xuY2xhc3MgZnMgZXh0ZW5kcyBZZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFR5cGUoZSkgPT09IG1lLnVuZGVmaW5lZCA/IFJyKHZvaWQgMCkgOiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShlKTtcbiAgfVxuICB1bndyYXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gIH1cbn1cbmZzLmNyZWF0ZSA9IChzLCBlKSA9PiBuZXcgZnMoe1xuICBpbm5lclR5cGU6IHMsXG4gIHR5cGVOYW1lOiBrZS5ab2RPcHRpb25hbCxcbiAgLi4uVmUoZSlcbn0pO1xuY2xhc3MgWnMgZXh0ZW5kcyBZZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFR5cGUoZSkgPT09IG1lLm51bGwgPyBScihudWxsKSA6IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGUpO1xuICB9XG4gIHVud3JhcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgfVxufVxuWnMuY3JlYXRlID0gKHMsIGUpID0+IG5ldyBacyh7XG4gIGlubmVyVHlwZTogcyxcbiAgdHlwZU5hbWU6IGtlLlpvZE51bGxhYmxlLFxuICAuLi5WZShlKVxufSk7XG5jbGFzcyBSbyBleHRlbmRzIFllIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBjb25zdCB7IGN0eDogdCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGxldCByID0gdC5kYXRhO1xuICAgIHJldHVybiB0LnBhcnNlZFR5cGUgPT09IG1lLnVuZGVmaW5lZCAmJiAociA9IHRoaXMuX2RlZi5kZWZhdWx0VmFsdWUoKSksIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgIGRhdGE6IHIsXG4gICAgICBwYXRoOiB0LnBhdGgsXG4gICAgICBwYXJlbnQ6IHRcbiAgICB9KTtcbiAgfVxuICByZW1vdmVEZWZhdWx0KCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59XG5Sby5jcmVhdGUgPSAocywgZSkgPT4gbmV3IFJvKHtcbiAgaW5uZXJUeXBlOiBzLFxuICB0eXBlTmFtZToga2UuWm9kRGVmYXVsdCxcbiAgZGVmYXVsdFZhbHVlOiB0eXBlb2YgZS5kZWZhdWx0ID09IFwiZnVuY3Rpb25cIiA/IGUuZGVmYXVsdCA6ICgpID0+IGUuZGVmYXVsdCxcbiAgLi4uVmUoZSlcbn0pO1xuY2xhc3MgTG8gZXh0ZW5kcyBZZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgeyBjdHg6IHQgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhlKSwgciA9IHtcbiAgICAgIC4uLnQsXG4gICAgICBjb21tb246IHtcbiAgICAgICAgLi4udC5jb21tb24sXG4gICAgICAgIGlzc3VlczogW11cbiAgICAgIH1cbiAgICB9LCBuID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xuICAgICAgZGF0YTogci5kYXRhLFxuICAgICAgcGF0aDogci5wYXRoLFxuICAgICAgcGFyZW50OiB7XG4gICAgICAgIC4uLnJcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYm8obikgPyBuLnRoZW4oKGkpID0+ICh7XG4gICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgIHZhbHVlOiBpLnN0YXR1cyA9PT0gXCJ2YWxpZFwiID8gaS52YWx1ZSA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgcHMoci5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5wdXQ6IHIuZGF0YVxuICAgICAgfSlcbiAgICB9KSkgOiB7XG4gICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgIHZhbHVlOiBuLnN0YXR1cyA9PT0gXCJ2YWxpZFwiID8gbi52YWx1ZSA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgcHMoci5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgfSxcbiAgICAgICAgaW5wdXQ6IHIuZGF0YVxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHJlbW92ZUNhdGNoKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59XG5Mby5jcmVhdGUgPSAocywgZSkgPT4gbmV3IExvKHtcbiAgaW5uZXJUeXBlOiBzLFxuICB0eXBlTmFtZToga2UuWm9kQ2F0Y2gsXG4gIGNhdGNoVmFsdWU6IHR5cGVvZiBlLmNhdGNoID09IFwiZnVuY3Rpb25cIiA/IGUuY2F0Y2ggOiAoKSA9PiBlLmNhdGNoLFxuICAuLi5WZShlKVxufSk7XG5jbGFzcyBuZCBleHRlbmRzIFllIHtcbiAgX3BhcnNlKGUpIHtcbiAgICBpZiAodGhpcy5fZ2V0VHlwZShlKSAhPT0gbWUubmFuKSB7XG4gICAgICBjb25zdCByID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoZSk7XG4gICAgICByZXR1cm4gaGUociwge1xuICAgICAgICBjb2RlOiBhZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgIGV4cGVjdGVkOiBtZS5uYW4sXG4gICAgICAgIHJlY2VpdmVkOiByLnBhcnNlZFR5cGVcbiAgICAgIH0pLCBSZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBlLmRhdGEgfTtcbiAgfVxufVxubmQuY3JlYXRlID0gKHMpID0+IG5ldyBuZCh7XG4gIHR5cGVOYW1lOiBrZS5ab2ROYU4sXG4gIC4uLlZlKHMpXG59KTtcbmNsYXNzIFVmIGV4dGVuZHMgWWUge1xuICBfcGFyc2UoZSkge1xuICAgIGNvbnN0IHsgY3R4OiB0IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoZSksIHIgPSB0LmRhdGE7XG4gICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLl9wYXJzZSh7XG4gICAgICBkYXRhOiByLFxuICAgICAgcGF0aDogdC5wYXRoLFxuICAgICAgcGFyZW50OiB0XG4gICAgfSk7XG4gIH1cbiAgdW53cmFwKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgfVxufVxuY2xhc3MgJGMgZXh0ZW5kcyBZZSB7XG4gIF9wYXJzZShlKSB7XG4gICAgY29uc3QgeyBzdGF0dXM6IHQsIGN0eDogciB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGUpO1xuICAgIGlmIChyLmNvbW1vbi5hc3luYylcbiAgICAgIHJldHVybiAoYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBpID0gYXdhaXQgdGhpcy5fZGVmLmluLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICBkYXRhOiByLmRhdGEsXG4gICAgICAgICAgcGF0aDogci5wYXRoLFxuICAgICAgICAgIHBhcmVudDogclxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGkuc3RhdHVzID09PSBcImFib3J0ZWRcIiA/IFJlIDogaS5zdGF0dXMgPT09IFwiZGlydHlcIiA/ICh0LmRpcnR5KCksIFduKGkudmFsdWUpKSA6IHRoaXMuX2RlZi5vdXQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgIGRhdGE6IGkudmFsdWUsXG4gICAgICAgICAgcGF0aDogci5wYXRoLFxuICAgICAgICAgIHBhcmVudDogclxuICAgICAgICB9KTtcbiAgICAgIH0pKCk7XG4gICAge1xuICAgICAgY29uc3QgbiA9IHRoaXMuX2RlZi5pbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgZGF0YTogci5kYXRhLFxuICAgICAgICBwYXRoOiByLnBhdGgsXG4gICAgICAgIHBhcmVudDogclxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbi5zdGF0dXMgPT09IFwiYWJvcnRlZFwiID8gUmUgOiBuLnN0YXR1cyA9PT0gXCJkaXJ0eVwiID8gKHQuZGlydHkoKSwge1xuICAgICAgICBzdGF0dXM6IFwiZGlydHlcIixcbiAgICAgICAgdmFsdWU6IG4udmFsdWVcbiAgICAgIH0pIDogdGhpcy5fZGVmLm91dC5fcGFyc2VTeW5jKHtcbiAgICAgICAgZGF0YTogbi52YWx1ZSxcbiAgICAgICAgcGF0aDogci5wYXRoLFxuICAgICAgICBwYXJlbnQ6IHJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgY3JlYXRlKGUsIHQpIHtcbiAgICByZXR1cm4gbmV3ICRjKHtcbiAgICAgIGluOiBlLFxuICAgICAgb3V0OiB0LFxuICAgICAgdHlwZU5hbWU6IGtlLlpvZFBpcGVsaW5lXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIENvIGV4dGVuZHMgWWUge1xuICBfcGFyc2UoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShlKSwgciA9IChuKSA9PiAoTG4obikgJiYgKG4udmFsdWUgPSBPYmplY3QuZnJlZXplKG4udmFsdWUpKSwgbik7XG4gICAgcmV0dXJuIGJvKHQpID8gdC50aGVuKChuKSA9PiByKG4pKSA6IHIodCk7XG4gIH1cbiAgdW53cmFwKCkge1xuICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICB9XG59XG5Dby5jcmVhdGUgPSAocywgZSkgPT4gbmV3IENvKHtcbiAgaW5uZXJUeXBlOiBzLFxuICB0eXBlTmFtZToga2UuWm9kUmVhZG9ubHksXG4gIC4uLlZlKGUpXG59KTtcbnZhciBrZTtcbihmdW5jdGlvbihzKSB7XG4gIHMuWm9kU3RyaW5nID0gXCJab2RTdHJpbmdcIiwgcy5ab2ROdW1iZXIgPSBcIlpvZE51bWJlclwiLCBzLlpvZE5hTiA9IFwiWm9kTmFOXCIsIHMuWm9kQmlnSW50ID0gXCJab2RCaWdJbnRcIiwgcy5ab2RCb29sZWFuID0gXCJab2RCb29sZWFuXCIsIHMuWm9kRGF0ZSA9IFwiWm9kRGF0ZVwiLCBzLlpvZFN5bWJvbCA9IFwiWm9kU3ltYm9sXCIsIHMuWm9kVW5kZWZpbmVkID0gXCJab2RVbmRlZmluZWRcIiwgcy5ab2ROdWxsID0gXCJab2ROdWxsXCIsIHMuWm9kQW55ID0gXCJab2RBbnlcIiwgcy5ab2RVbmtub3duID0gXCJab2RVbmtub3duXCIsIHMuWm9kTmV2ZXIgPSBcIlpvZE5ldmVyXCIsIHMuWm9kVm9pZCA9IFwiWm9kVm9pZFwiLCBzLlpvZEFycmF5ID0gXCJab2RBcnJheVwiLCBzLlpvZE9iamVjdCA9IFwiWm9kT2JqZWN0XCIsIHMuWm9kVW5pb24gPSBcIlpvZFVuaW9uXCIsIHMuWm9kRGlzY3JpbWluYXRlZFVuaW9uID0gXCJab2REaXNjcmltaW5hdGVkVW5pb25cIiwgcy5ab2RJbnRlcnNlY3Rpb24gPSBcIlpvZEludGVyc2VjdGlvblwiLCBzLlpvZFR1cGxlID0gXCJab2RUdXBsZVwiLCBzLlpvZFJlY29yZCA9IFwiWm9kUmVjb3JkXCIsIHMuWm9kTWFwID0gXCJab2RNYXBcIiwgcy5ab2RTZXQgPSBcIlpvZFNldFwiLCBzLlpvZEZ1bmN0aW9uID0gXCJab2RGdW5jdGlvblwiLCBzLlpvZExhenkgPSBcIlpvZExhenlcIiwgcy5ab2RMaXRlcmFsID0gXCJab2RMaXRlcmFsXCIsIHMuWm9kRW51bSA9IFwiWm9kRW51bVwiLCBzLlpvZEVmZmVjdHMgPSBcIlpvZEVmZmVjdHNcIiwgcy5ab2ROYXRpdmVFbnVtID0gXCJab2ROYXRpdmVFbnVtXCIsIHMuWm9kT3B0aW9uYWwgPSBcIlpvZE9wdGlvbmFsXCIsIHMuWm9kTnVsbGFibGUgPSBcIlpvZE51bGxhYmxlXCIsIHMuWm9kRGVmYXVsdCA9IFwiWm9kRGVmYXVsdFwiLCBzLlpvZENhdGNoID0gXCJab2RDYXRjaFwiLCBzLlpvZFByb21pc2UgPSBcIlpvZFByb21pc2VcIiwgcy5ab2RCcmFuZGVkID0gXCJab2RCcmFuZGVkXCIsIHMuWm9kUGlwZWxpbmUgPSBcIlpvZFBpcGVsaW5lXCIsIHMuWm9kUmVhZG9ubHkgPSBcIlpvZFJlYWRvbmx5XCI7XG59KShrZSB8fCAoa2UgPSB7fSkpO1xuY29uc3QgeHQgPSBScy5jcmVhdGUsICRmID0gQ24uY3JlYXRlLCBRbSA9IEhsLmNyZWF0ZTtcblBzLmNyZWF0ZTtcbmNvbnN0IEtzID0gWXIuY3JlYXRlLCBKdCA9ICR0LmNyZWF0ZSwga28gPSB3by5jcmVhdGUsIEdmID0gVWMuY3JlYXRlO1xuQW8uY3JlYXRlO1xuV3MuY3JlYXRlO1xuY29uc3QgaXIgPSBJby5jcmVhdGUsIEdjID0genMuY3JlYXRlO1xuX28uY3JlYXRlO1xuZnMuY3JlYXRlO1xuWnMuY3JlYXRlO1xuY29uc3QgZTEgPSAvW0AjJCVeJiorPS9cXFxcfH7Cq8K7XS8sIHQxID0gLyghezIsfXxcXD97Mix9fC17Mix9KS8sIHIxID0gL1tcXHV7MUYzMDB9LVxcdXsxRjlGRn1dfFtcXHV7MjcwMn0tXFx1ezI3QjB9XXxbXFx1ezI2MDB9LVxcdXsyNkZGfV18W1xcdXsyQjAwfS1cXHV7MkJGRn1dL3UsICRuID0gKHsgbWF4OiBzLCBub1NwYWNlczogZSB9ID0ge30pID0+IChlID8geHQoKS5tYXgocyA/PyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpLnJlZ2V4KC9eXFxTKiQvLCBcIlNwYWNlcyBhcmUgbm90IGFsbG93ZWRcIikgOiB4dCgpLm1heChzID8/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkpLnJlZmluZSgocikgPT4gIXIxLnRlc3QociksIHtcbiAgbWVzc2FnZTogXCJFbW9qaXMgYW5kIHN5bWJvbHMgYXJlIG5vdCBhbGxvd2VkXCJcbn0pLnJlZmluZSgocikgPT4gIWUxLnRlc3QociksIHtcbiAgbWVzc2FnZTogXCJTcGVjaWFsIGNoYXJhY3RlcnMgKEAsICMsICQsICUsIF4sICYsICosICssID0sIC8sIFxcXFwsIHwsIH4sIMKrLCDCuykgYXJlIG5vdCBhbGxvd2VkXCJcbn0pLnJlZmluZSgocikgPT4gIXQxLnRlc3QociksIHtcbiAgbWVzc2FnZTogXCJSZXBlYXRlZCBwdW5jdHVhdGlvbnMgKCEhLCA/PywgLS0pIGFyZSBub3QgYWxsb3dlZFwiXG59KSwgb3IgPSB4dCgpLnVybCgpLnN0YXJ0c1dpdGgoXCJodHRwczovL1wiLCB7IG1lc3NhZ2U6IFwiTXVzdCBiZSBhbiBodHRwcyB1cmxcIiB9KS5tYXgoMTAyNCkucmVmaW5lKChzKSA9PiAhcy5pbmNsdWRlcyhcIiBcIiksIHtcbiAgbWVzc2FnZTogXCJVUkwgbXVzdCBub3QgY29udGFpbiBzcGFjZXNcIlxufSkucmVmaW5lKChzKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgZSA9IG5ldyBVUkwocykuaG9zdG5hbWU7XG4gICAgcmV0dXJuICEoZSA9PT0gXCJsb2NhbGhvc3RcIiB8fCBlLmVuZHNXaXRoKFwiLmxvY2FsaG9zdFwiKSB8fCAvXihcXGR7MSwzfVxcLil7M31cXGR7MSwzfSQvLnRlc3QoZSkgfHwgZS5zdGFydHNXaXRoKFwiW1wiKSAmJiBlLmVuZHNXaXRoKFwiXVwiKSk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufSwge1xuICBtZXNzYWdlOiBcIlVSTCBtdXN0IG5vdCB1c2UgSVAgYWRkcmVzc2VzIG9yIGxvY2FsaG9zdFwiXG59KSwgVmMgPSB4dCgpLm1heCgzMiksIFZmID0geHQoKS5tYXgoMzIpLCBzMSA9IC9eWy1hLXowLTldezMsOH06Wy1fYS16QS1aMC05XXsxLDMyfVxcLyg/OlstYS16MC05XXszLDh9OlstLiVhLXpBLVowLTldezEsMTI4fSg/OlxcL1stLiVhLXpBLVowLTldezEsNzh9KT98bmF0aXZlKSQvLCBuMSA9IHh0KCkucmVnZXgoczEsIHsgbWVzc2FnZTogXCJJbnZhbGlkIENBSVAtMTkgYXNzZXQgSURcIiB9KSwgamMgPSB4dCgpLnJlZ2V4KC9eIyhbMC05QS1GXXszfXxbMC05QS1GXXs2fSkkL2ksIHtcbiAgbWVzc2FnZTogXCJJbnZhbGlkIGhleCBjb2xvciBjb2RlLiBJdCBzaG91bGQgYmUgaW4gdGhlIGZvcm1hdCAjUlJHR0JCIG9yICNSR0IuXCJcbn0pLCBpMSA9IC9eKD8hLipcXC5cXC4pKFthLXpBLVowLTldKFthLXpBLVowLTktXSpbYS16QS1aMC05XSk/XFwuKStbYS16QS1aXXsyLH0kLywgbzEgPSB4dCgpLm1heCgxMDI0KS5yZWdleChpMSwge1xuICBtZXNzYWdlOiBcIk11c3QgYmUgYSB2YWxpZCBkb21haW4gbmFtZSAoZS5nLiwgZXhhbXBsZS5jb20sIHN1Yi5leGFtcGxlLmNvbSlcIlxufSkucmVmaW5lKChzKSA9PiAhcy5pbmNsdWRlcyhcIjovL1wiKSwge1xuICBtZXNzYWdlOiBcIkRvbWFpbiBtdXN0IG5vdCBpbmNsdWRlIHByb3RvY29sIChodHRwOi8vLCBodHRwczovLywgZXRjLilcIlxufSkucmVmaW5lKChzKSA9PiAhcy5pbmNsdWRlcyhcIi9cIiksIHtcbiAgbWVzc2FnZTogXCJEb21haW4gbXVzdCBub3QgaW5jbHVkZSBwYXRoIHNlcGFyYXRvcnNcIlxufSkucmVmaW5lKChzKSA9PiAhcy5pbmNsdWRlcyhcIkBcIiksIHtcbiAgbWVzc2FnZTogXCJEb21haW4gbXVzdCBub3QgaW5jbHVkZSBAIHN5bWJvbFwiXG59KS5yZWZpbmUoKHMpID0+ICFzLmluY2x1ZGVzKFwiOlwiKSwge1xuICBtZXNzYWdlOiBcIkRvbWFpbiBtdXN0IG5vdCBpbmNsdWRlIHBvcnQgbnVtYmVyc1wiXG59KSwgYTEgPSBrbyhbaXIoXCIxOjFcIiksIGlyKFwiMzoyXCIpXSksIGwxID0gSnQoe1xuICBoZWFkZXI6IHh0KCksXG4gIHBheWxvYWQ6IHh0KCksXG4gIHNpZ25hdHVyZTogeHQoKVxufSk7XG5KdCh7XG4gIGZpZDogJGYoKSxcbiAgdHlwZTogaXIoXCJhcHBfa2V5XCIpLFxuICBrZXk6IHh0KCkuc3RhcnRzV2l0aChcIjB4XCIpXG59KTtcbmNvbnN0IGMxID0gSnQoe1xuICB0eXBlOiBpcihcImxhdW5jaF9mcmFtZVwiKSxcbiAgbmFtZTogVmMsXG4gIHVybDogb3Iub3B0aW9uYWwoKSxcbiAgc3BsYXNoSW1hZ2VVcmw6IG9yLm9wdGlvbmFsKCksXG4gIHNwbGFzaEJhY2tncm91bmRDb2xvcjogamMub3B0aW9uYWwoKVxufSksIHUxID0gSnQoe1xuICB0eXBlOiBpcihcImxhdW5jaF9taW5pYXBwXCIpLFxuICBuYW1lOiBWYyxcbiAgdXJsOiBvci5vcHRpb25hbCgpLFxuICBzcGxhc2hJbWFnZVVybDogb3Iub3B0aW9uYWwoKSxcbiAgc3BsYXNoQmFja2dyb3VuZENvbG9yOiBqYy5vcHRpb25hbCgpXG59KSwgZDEgPSBKdCh7XG4gIHR5cGU6IGlyKFwidmlld190b2tlblwiKSxcbiAgdG9rZW46IG4xXG59KSwgaDEgPSBHZihcInR5cGVcIiwgW1xuICB1MSxcbiAgZDEsXG4gIC8vIFJlbW92ZSBhZnRlciBjb21wYXRpYmlsaXR5IHBlcmlvZFxuICBjMVxuXSksIGYxID0gSnQoe1xuICB0aXRsZTogVmYsXG4gIGFjdGlvbjogaDFcbn0pO1xuSnQoe1xuICB2ZXJzaW9uOiBrbyhbeHQoKSwgJGYoKV0pLnRyYW5zZm9ybSgocykgPT4gU3RyaW5nKHMpKS5waXBlKGtvKFtpcihcIm5leHRcIiksIGlyKFwiMVwiKV0pKSxcbiAgaW1hZ2VVcmw6IG9yLFxuICBhc3BlY3RSYXRpbzogYTEub3B0aW9uYWwoKSxcbiAgYnV0dG9uOiBmMVxufSk7XG5jb25zdCBqZiA9IEp0KHtcbiAgdXJsOiB4dCgpLFxuICB0b2tlbjogeHQoKVxufSk7XG5KdCh7XG4gIG5vdGlmaWNhdGlvbklkOiB4dCgpLm1heCgxMjgpLFxuICB0aXRsZTogeHQoKS5tYXgoMzIpLFxuICBib2R5OiB4dCgpLm1heCgxMjgpLFxuICB0YXJnZXRVcmw6IG9yLFxuICB0b2tlbnM6IHh0KCkuYXJyYXkoKS5tYXgoMTAwKVxufSk7XG5KdCh7XG4gIHJlc3VsdDogSnQoe1xuICAgIHN1Y2Nlc3NmdWxUb2tlbnM6IEtzKHh0KCkpLFxuICAgIGludmFsaWRUb2tlbnM6IEtzKHh0KCkpLFxuICAgIHJhdGVMaW1pdGVkVG9rZW5zOiBLcyh4dCgpKVxuICB9KVxufSk7XG5jb25zdCBnMSA9IEp0KHtcbiAgZXZlbnQ6IGlyKFwibWluaWFwcF9hZGRlZFwiKSxcbiAgbm90aWZpY2F0aW9uRGV0YWlsczogamYub3B0aW9uYWwoKVxufSksIHAxID0gSnQoe1xuICBldmVudDogaXIoXCJtaW5pYXBwX3JlbW92ZWRcIilcbn0pLCBtMSA9IEp0KHtcbiAgZXZlbnQ6IGlyKFwibm90aWZpY2F0aW9uc19lbmFibGVkXCIpLFxuICBub3RpZmljYXRpb25EZXRhaWxzOiBqZi5yZXF1aXJlZCgpXG59KSwgeTEgPSBKdCh7XG4gIGV2ZW50OiBpcihcIm5vdGlmaWNhdGlvbnNfZGlzYWJsZWRcIilcbn0pO1xuR2YoXCJldmVudFwiLCBbXG4gIGcxLFxuICBwMSxcbiAgbTEsXG4gIHkxXG5dKTtcbmNvbnN0IHYxID0gW1xuICBcIndhbGxldC5nZXRFdGhlcmV1bVByb3ZpZGVyXCIsXG4gIFwid2FsbGV0LmdldFNvbGFuYVByb3ZpZGVyXCIsXG4gIFwiYWN0aW9ucy5yZWFkeVwiLFxuICBcImFjdGlvbnMub3BlblVybFwiLFxuICBcImFjdGlvbnMuY2xvc2VcIixcbiAgXCJhY3Rpb25zLnNldFByaW1hcnlCdXR0b25cIixcbiAgXCJhY3Rpb25zLmFkZE1pbmlBcHBcIixcbiAgXCJhY3Rpb25zLnNpZ25JblwiLFxuICBcImFjdGlvbnMudmlld0Nhc3RcIixcbiAgXCJhY3Rpb25zLnZpZXdQcm9maWxlXCIsXG4gIFwiYWN0aW9ucy5jb21wb3NlQ2FzdFwiLFxuICBcImFjdGlvbnMudmlld1Rva2VuXCIsXG4gIFwiYWN0aW9ucy5zZW5kVG9rZW5cIixcbiAgXCJhY3Rpb25zLnN3YXBUb2tlblwiLFxuICBcImFjdGlvbnMub3Blbk1pbmlBcHBcIixcbiAgXCJhY3Rpb25zLnJlcXVlc3RDYW1lcmFBbmRNaWNyb3Bob25lQWNjZXNzXCIsXG4gIFwiZXhwZXJpbWVudGFsLnNpZ25NYW5pZmVzdFwiLFxuICBcImhhcHRpY3MuaW1wYWN0T2NjdXJyZWRcIixcbiAgXCJoYXB0aWNzLm5vdGlmaWNhdGlvbk9jY3VycmVkXCIsXG4gIFwiaGFwdGljcy5zZWxlY3Rpb25DaGFuZ2VkXCIsXG4gIFwiYmFja1wiXG5dLCBFMSA9IFtcbiAgXCJnYW1lc1wiLFxuICBcInNvY2lhbFwiLFxuICBcImZpbmFuY2VcIixcbiAgXCJ1dGlsaXR5XCIsXG4gIFwicHJvZHVjdGl2aXR5XCIsXG4gIFwiaGVhbHRoLWZpdG5lc3NcIixcbiAgXCJuZXdzLW1lZGlhXCIsXG4gIFwibXVzaWNcIixcbiAgXCJzaG9wcGluZ1wiLFxuICBcImVkdWNhdGlvblwiLFxuICBcImRldmVsb3Blci10b29sc1wiLFxuICBcImVudGVydGFpbm1lbnRcIixcbiAgXCJhcnQtY3JlYXRpdml0eVwiXG5dLCB4MSA9IEdjKEUxKSwgUzEgPSBrbyhbXG4gIGlyKFwiMC4wLjBcIiksXG4gIGlyKFwiMC4wLjFcIiksXG4gIGlyKFwiMVwiKSxcbiAgaXIoXCJuZXh0XCIpXG5dKSwgYjEgPSAkbih7IG1heDogMzAgfSksIFQxID0gJG4oeyBtYXg6IDE3MCB9KSwgdzEgPSBLcyhvcikubWF4KDMpLCBBMSA9IEtzKCRuKHsgbWF4OiAyMCwgbm9TcGFjZXM6ICEwIH0pKS5tYXgoNSksIEkxID0gJG4oeyBtYXg6IDMwIH0pLCBfMSA9ICRuKHsgbWF4OiAzMCB9KSwgUjEgPSAkbih7IG1heDogMTAwIH0pLCBMMSA9IFFtKCksIEMxID0gW1xuICBcImVpcDE1NToxXCIsXG4gIC8vIEV0aGVyZXVtIG1haW5uZXRcbiAgXCJlaXAxNTU6ODQ1M1wiLFxuICAvLyBCYXNlIG1haW5uZXRcbiAgXCJlaXAxNTU6NDIxNjFcIixcbiAgLy8gQXJiaXRydW0gT25lXG4gIFwiZWlwMTU1OjQyMTYxNFwiLFxuICAvLyBBcmJpdHJ1bSBTZXBvbGlhXG4gIFwiZWlwMTU1Ojg0NTMyXCIsXG4gIC8vIEJhc2UgU2Vwb2xpYVxuICBcImVpcDE1NTo2NjY2NjY2NjZcIixcbiAgLy8gRGVnZW5cbiAgXCJlaXAxNTU6MTAwXCIsXG4gIC8vIEdub3Npc1xuICBcImVpcDE1NToxMFwiLFxuICAvLyBPcHRpbWlzbVxuICBcImVpcDE1NToxMTE1NTQyMFwiLFxuICAvLyBPcHRpbWlzbSBTZXBvbGlhXG4gIFwiZWlwMTU1OjEzN1wiLFxuICAvLyBQb2x5Z29uXG4gIFwiZWlwMTU1OjExMTU1MTExXCIsXG4gIC8vIEV0aGVyZXVtIFNlcG9saWFcbiAgXCJlaXAxNTU6Nzc3Nzc3N1wiLFxuICAvLyBab3JhXG4gIFwiZWlwMTU1OjEzMFwiLFxuICAvLyBVbmljaGFpblxuICBcImVpcDE1NToxMDE0M1wiLFxuICAvLyBNb25hZCB0ZXN0bmV0XG4gIFwiZWlwMTU1OjQyMjIwXCIsXG4gIC8vIENlbG9cbiAgXCJzb2xhbmE6NWV5a3Q0VXNGdjhQOE5KZFRSRXBZMXZ6cUtxWkt2ZHBcIlxuICAvLyBTb2xhbmFcbl07XG5mdW5jdGlvbiBLZihzKSB7XG4gIGNvbnN0IGUgPSBuZXcgU2V0KHMpO1xuICByZXR1cm4gQXJyYXkuZnJvbShlKTtcbn1cbmNvbnN0IGsxID0gS3MoR2MoQzEpKS50cmFuc2Zvcm0oS2YpLCBEMSA9IEtzKEdjKHYxKSkudHJhbnNmb3JtKEtmKSwgaWQgPSBKdCh7XG4gIC8vIDAuMC4wIGFuZCAwLjAuMSBhcmUgbm90IHRlY2huaWNhbGx5IHBhcnQgb2YgdGhlIHNwZWMgYnV0IGtlcHQgZm9yXG4gIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LiBuZXh0IHNob3VsZCBhbHdheXMgcmVzb2x2ZSB0byB0aGUgbW9zdCByZWNlbnRcbiAgLy8gc2NoZW1hIHZlcnNpb24uXG4gIHZlcnNpb246IFMxLFxuICBuYW1lOiBWYyxcbiAgaWNvblVybDogb3IsXG4gIGhvbWVVcmw6IG9yLFxuICAvKiogZGVwcmVjYXRlZCwgc2V0IG9nSW1hZ2VVcmwgaW5zdGVhZCAqL1xuICBpbWFnZVVybDogb3Iub3B0aW9uYWwoKSxcbiAgLyoqIGRlcHJlY2F0ZWQsIHdpbGwgcmVseSBvbiBmYzpmcmFtZS9mYzptaW5pYXBwIG1ldGEgdGFnICovXG4gIGJ1dHRvblRpdGxlOiBWZi5vcHRpb25hbCgpLFxuICBzcGxhc2hJbWFnZVVybDogb3Iub3B0aW9uYWwoKSxcbiAgc3BsYXNoQmFja2dyb3VuZENvbG9yOiBqYy5vcHRpb25hbCgpLFxuICB3ZWJob29rVXJsOiBvci5vcHRpb25hbCgpLFxuICAvKiogc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmFyY2FzdGVyeHl6L21pbmlhcHBzL2Rpc2N1c3Npb25zLzE5MSAqL1xuICBzdWJ0aXRsZTogYjEub3B0aW9uYWwoKSxcbiAgZGVzY3JpcHRpb246IFQxLm9wdGlvbmFsKCksXG4gIHNjcmVlbnNob3RVcmxzOiB3MS5vcHRpb25hbCgpLFxuICBwcmltYXJ5Q2F0ZWdvcnk6IHgxLm9wdGlvbmFsKCksXG4gIHRhZ3M6IEExLm9wdGlvbmFsKCksXG4gIGhlcm9JbWFnZVVybDogb3Iub3B0aW9uYWwoKSxcbiAgdGFnbGluZTogSTEub3B0aW9uYWwoKSxcbiAgb2dUaXRsZTogXzEub3B0aW9uYWwoKSxcbiAgb2dEZXNjcmlwdGlvbjogUjEub3B0aW9uYWwoKSxcbiAgb2dJbWFnZVVybDogb3Iub3B0aW9uYWwoKSxcbiAgLyoqIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhcmNhc3Rlcnh5ei9taW5pYXBwcy9kaXNjdXNzaW9ucy8yMDQgKi9cbiAgbm9pbmRleDogTDEub3B0aW9uYWwoKSxcbiAgLyoqIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFyY2FzdGVyeHl6L21pbmlhcHBzL2Rpc2N1c3Npb25zLzI1NiAqL1xuICByZXF1aXJlZENoYWluczogazEub3B0aW9uYWwoKSxcbiAgcmVxdWlyZWRDYXBhYmlsaXRpZXM6IEQxLm9wdGlvbmFsKCksXG4gIC8qKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhcmNhc3Rlcnh5ei9taW5pYXBwcy9kaXNjdXNzaW9ucy8xNTggKi9cbiAgLyoqIERvY3VtZW50YXRpb24gd2lsbCBiZSBhZGRlZCBvbmNlIHRoaXMgZmVhdHVyZSBpcyBmaW5hbGl6ZWQuICovXG4gIGNhc3RTaGFyZVVybDogb3Iub3B0aW9uYWwoKSxcbiAgLyoqIENhbm9uaWNhbCBkb21haW4gZm9yIHRoZSBtaW5pYXBwIGFwcGxpY2F0aW9uICovXG4gIGNhbm9uaWNhbERvbWFpbjogbzEub3B0aW9uYWwoKVxufSkucmVmaW5lKChzKSA9PiB7XG4gIGlmIChzLmNhc3RTaGFyZVVybCA9PT0gdm9pZCAwKVxuICAgIHJldHVybiAhMDtcbiAgdHJ5IHtcbiAgICBjb25zdCBlID0gbmV3IFVSTChzLmhvbWVVcmwpLmhvc3RuYW1lLCB0ID0gbmV3IFVSTChzLmNhc3RTaGFyZVVybCkuaG9zdG5hbWU7XG4gICAgcmV0dXJuIGUgPT09IHQ7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiAhMTtcbiAgfVxufSwge1xuICBtZXNzYWdlOiBcImNhc3RTaGFyZVVybCBtdXN0IGhhdmUgdGhlIHNhbWUgZG9tYWluIGFzIGhvbWVVcmxcIixcbiAgcGF0aDogW1wiY2FzdFNoYXJlVXJsXCJdXG59KTtcbkp0KHtcbiAgYWNjb3VudEFzc29jaWF0aW9uOiBsMSxcbiAgbWluaWFwcDogaWQub3B0aW9uYWwoKSxcbiAgLy8gU3VwcG9ydCBib3RoICdmcmFtZScgYW5kICdtaW5pYXBwJyBkdXJpbmcgdHJhbnNpdGlvbiBwZXJpb2RcbiAgZnJhbWU6IGlkLm9wdGlvbmFsKClcbn0pLnJlZmluZSgocykgPT4gcy5mcmFtZSAmJiBzLm1pbmlhcHAgPyBKU09OLnN0cmluZ2lmeShzLmZyYW1lKSA9PT0gSlNPTi5zdHJpbmdpZnkocy5taW5pYXBwKSA6ICEwLCB7XG4gIG1lc3NhZ2U6ICdJZiBib3RoIFwiZnJhbWVcIiBhbmQgXCJtaW5pYXBwXCIgYXJlIHByb3ZpZGVkLCB0aGV5IG11c3QgYmUgaWRlbnRpY2FsJyxcbiAgcGF0aDogW1wiZnJhbWVcIiwgXCJtaW5pYXBwXCJdXG59KS50cmFuc2Zvcm0oKHMpID0+ICh7XG4gIC4uLnMsXG4gIGZyYW1lOiBzLmZyYW1lID8/IHMubWluaWFwcFxufSkpO1xudmFyIEdhID0ge30sIEhuID0ge30sIG9kO1xuZnVuY3Rpb24gUDEoKSB7XG4gIGlmIChvZCkgcmV0dXJuIEhuO1xuICBvZCA9IDEsIEhuLmJ5dGVMZW5ndGggPSBhLCBIbi50b0J5dGVBcnJheSA9IGMsIEhuLmZyb21CeXRlQXJyYXkgPSBoO1xuICBmb3IgKHZhciBzID0gW10sIGUgPSBbXSwgdCA9IHR5cGVvZiBVaW50OEFycmF5IDwgXCJ1XCIgPyBVaW50OEFycmF5IDogQXJyYXksIHIgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIiwgbiA9IDAsIGkgPSByLmxlbmd0aDsgbiA8IGk7ICsrbilcbiAgICBzW25dID0gcltuXSwgZVtyLmNoYXJDb2RlQXQobildID0gbjtcbiAgZVs0NV0gPSA2MiwgZVs5NV0gPSA2MztcbiAgZnVuY3Rpb24gbyhmKSB7XG4gICAgdmFyIHAgPSBmLmxlbmd0aDtcbiAgICBpZiAocCAlIDQgPiAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNFwiKTtcbiAgICB2YXIgeSA9IGYuaW5kZXhPZihcIj1cIik7XG4gICAgeSA9PT0gLTEgJiYgKHkgPSBwKTtcbiAgICB2YXIgRSA9IHkgPT09IHAgPyAwIDogNCAtIHkgJSA0O1xuICAgIHJldHVybiBbeSwgRV07XG4gIH1cbiAgZnVuY3Rpb24gYShmKSB7XG4gICAgdmFyIHAgPSBvKGYpLCB5ID0gcFswXSwgRSA9IHBbMV07XG4gICAgcmV0dXJuICh5ICsgRSkgKiAzIC8gNCAtIEU7XG4gIH1cbiAgZnVuY3Rpb24gbChmLCBwLCB5KSB7XG4gICAgcmV0dXJuIChwICsgeSkgKiAzIC8gNCAtIHk7XG4gIH1cbiAgZnVuY3Rpb24gYyhmKSB7XG4gICAgdmFyIHAsIHkgPSBvKGYpLCBFID0geVswXSwgYiA9IHlbMV0sIFIgPSBuZXcgdChsKGYsIEUsIGIpKSwgQSA9IDAsIEYgPSBiID4gMCA/IEUgLSA0IDogRSwgTTtcbiAgICBmb3IgKE0gPSAwOyBNIDwgRjsgTSArPSA0KVxuICAgICAgcCA9IGVbZi5jaGFyQ29kZUF0KE0pXSA8PCAxOCB8IGVbZi5jaGFyQ29kZUF0KE0gKyAxKV0gPDwgMTIgfCBlW2YuY2hhckNvZGVBdChNICsgMildIDw8IDYgfCBlW2YuY2hhckNvZGVBdChNICsgMyldLCBSW0ErK10gPSBwID4+IDE2ICYgMjU1LCBSW0ErK10gPSBwID4+IDggJiAyNTUsIFJbQSsrXSA9IHAgJiAyNTU7XG4gICAgcmV0dXJuIGIgPT09IDIgJiYgKHAgPSBlW2YuY2hhckNvZGVBdChNKV0gPDwgMiB8IGVbZi5jaGFyQ29kZUF0KE0gKyAxKV0gPj4gNCwgUltBKytdID0gcCAmIDI1NSksIGIgPT09IDEgJiYgKHAgPSBlW2YuY2hhckNvZGVBdChNKV0gPDwgMTAgfCBlW2YuY2hhckNvZGVBdChNICsgMSldIDw8IDQgfCBlW2YuY2hhckNvZGVBdChNICsgMildID4+IDIsIFJbQSsrXSA9IHAgPj4gOCAmIDI1NSwgUltBKytdID0gcCAmIDI1NSksIFI7XG4gIH1cbiAgZnVuY3Rpb24gdShmKSB7XG4gICAgcmV0dXJuIHNbZiA+PiAxOCAmIDYzXSArIHNbZiA+PiAxMiAmIDYzXSArIHNbZiA+PiA2ICYgNjNdICsgc1tmICYgNjNdO1xuICB9XG4gIGZ1bmN0aW9uIGQoZiwgcCwgeSkge1xuICAgIGZvciAodmFyIEUsIGIgPSBbXSwgUiA9IHA7IFIgPCB5OyBSICs9IDMpXG4gICAgICBFID0gKGZbUl0gPDwgMTYgJiAxNjcxMTY4MCkgKyAoZltSICsgMV0gPDwgOCAmIDY1MjgwKSArIChmW1IgKyAyXSAmIDI1NSksIGIucHVzaCh1KEUpKTtcbiAgICByZXR1cm4gYi5qb2luKFwiXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGgoZikge1xuICAgIGZvciAodmFyIHAsIHkgPSBmLmxlbmd0aCwgRSA9IHkgJSAzLCBiID0gW10sIFIgPSAxNjM4MywgQSA9IDAsIEYgPSB5IC0gRTsgQSA8IEY7IEEgKz0gUilcbiAgICAgIGIucHVzaChkKGYsIEEsIEEgKyBSID4gRiA/IEYgOiBBICsgUikpO1xuICAgIHJldHVybiBFID09PSAxID8gKHAgPSBmW3kgLSAxXSwgYi5wdXNoKFxuICAgICAgc1twID4+IDJdICsgc1twIDw8IDQgJiA2M10gKyBcIj09XCJcbiAgICApKSA6IEUgPT09IDIgJiYgKHAgPSAoZlt5IC0gMl0gPDwgOCkgKyBmW3kgLSAxXSwgYi5wdXNoKFxuICAgICAgc1twID4+IDEwXSArIHNbcCA+PiA0ICYgNjNdICsgc1twIDw8IDIgJiA2M10gKyBcIj1cIlxuICAgICkpLCBiLmpvaW4oXCJcIik7XG4gIH1cbiAgcmV0dXJuIEhuO1xufVxudmFyIE1pID0ge307XG4vKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xudmFyIGFkO1xuZnVuY3Rpb24gTTEoKSB7XG4gIHJldHVybiBhZCB8fCAoYWQgPSAxLCBNaS5yZWFkID0gZnVuY3Rpb24ocywgZSwgdCwgciwgbikge1xuICAgIHZhciBpLCBvLCBhID0gbiAqIDggLSByIC0gMSwgbCA9ICgxIDw8IGEpIC0gMSwgYyA9IGwgPj4gMSwgdSA9IC03LCBkID0gdCA/IG4gLSAxIDogMCwgaCA9IHQgPyAtMSA6IDEsIGYgPSBzW2UgKyBkXTtcbiAgICBmb3IgKGQgKz0gaCwgaSA9IGYgJiAoMSA8PCAtdSkgLSAxLCBmID4+PSAtdSwgdSArPSBhOyB1ID4gMDsgaSA9IGkgKiAyNTYgKyBzW2UgKyBkXSwgZCArPSBoLCB1IC09IDgpXG4gICAgICA7XG4gICAgZm9yIChvID0gaSAmICgxIDw8IC11KSAtIDEsIGkgPj49IC11LCB1ICs9IHI7IHUgPiAwOyBvID0gbyAqIDI1NiArIHNbZSArIGRdLCBkICs9IGgsIHUgLT0gOClcbiAgICAgIDtcbiAgICBpZiAoaSA9PT0gMClcbiAgICAgIGkgPSAxIC0gYztcbiAgICBlbHNlIHtcbiAgICAgIGlmIChpID09PSBsKVxuICAgICAgICByZXR1cm4gbyA/IE5hTiA6IChmID8gLTEgOiAxKSAqICgxIC8gMCk7XG4gICAgICBvID0gbyArIE1hdGgucG93KDIsIHIpLCBpID0gaSAtIGM7XG4gICAgfVxuICAgIHJldHVybiAoZiA/IC0xIDogMSkgKiBvICogTWF0aC5wb3coMiwgaSAtIHIpO1xuICB9LCBNaS53cml0ZSA9IGZ1bmN0aW9uKHMsIGUsIHQsIHIsIG4sIGkpIHtcbiAgICB2YXIgbywgYSwgbCwgYyA9IGkgKiA4IC0gbiAtIDEsIHUgPSAoMSA8PCBjKSAtIDEsIGQgPSB1ID4+IDEsIGggPSBuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCwgZiA9IHIgPyAwIDogaSAtIDEsIHAgPSByID8gMSA6IC0xLCB5ID0gZSA8IDAgfHwgZSA9PT0gMCAmJiAxIC8gZSA8IDAgPyAxIDogMDtcbiAgICBmb3IgKGUgPSBNYXRoLmFicyhlKSwgaXNOYU4oZSkgfHwgZSA9PT0gMSAvIDAgPyAoYSA9IGlzTmFOKGUpID8gMSA6IDAsIG8gPSB1KSA6IChvID0gTWF0aC5mbG9vcihNYXRoLmxvZyhlKSAvIE1hdGguTE4yKSwgZSAqIChsID0gTWF0aC5wb3coMiwgLW8pKSA8IDEgJiYgKG8tLSwgbCAqPSAyKSwgbyArIGQgPj0gMSA/IGUgKz0gaCAvIGwgOiBlICs9IGggKiBNYXRoLnBvdygyLCAxIC0gZCksIGUgKiBsID49IDIgJiYgKG8rKywgbCAvPSAyKSwgbyArIGQgPj0gdSA/IChhID0gMCwgbyA9IHUpIDogbyArIGQgPj0gMSA/IChhID0gKGUgKiBsIC0gMSkgKiBNYXRoLnBvdygyLCBuKSwgbyA9IG8gKyBkKSA6IChhID0gZSAqIE1hdGgucG93KDIsIGQgLSAxKSAqIE1hdGgucG93KDIsIG4pLCBvID0gMCkpOyBuID49IDg7IHNbdCArIGZdID0gYSAmIDI1NSwgZiArPSBwLCBhIC89IDI1NiwgbiAtPSA4KVxuICAgICAgO1xuICAgIGZvciAobyA9IG8gPDwgbiB8IGEsIGMgKz0gbjsgYyA+IDA7IHNbdCArIGZdID0gbyAmIDI1NSwgZiArPSBwLCBvIC89IDI1NiwgYyAtPSA4KVxuICAgICAgO1xuICAgIHNbdCArIGYgLSBwXSB8PSB5ICogMTI4O1xuICB9KSwgTWk7XG59XG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbnZhciBsZDtcbmZ1bmN0aW9uIEtjKCkge1xuICByZXR1cm4gbGQgfHwgKGxkID0gMSwgKGZ1bmN0aW9uKHMpIHtcbiAgICBjb25zdCBlID0gUDEoKSwgdCA9IE0xKCksIHIgPSB0eXBlb2YgU3ltYm9sID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wuZm9yKFwibm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b21cIikgOiBudWxsO1xuICAgIHMuQnVmZmVyID0gYSwgcy5TbG93QnVmZmVyID0gUiwgcy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwO1xuICAgIGNvbnN0IG4gPSAyMTQ3NDgzNjQ3O1xuICAgIHMua01heExlbmd0aCA9IG4sIGEuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGkoKSwgIWEuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSA8IFwidVwiICYmIHR5cGVvZiBjb25zb2xlLmVycm9yID09IFwiZnVuY3Rpb25cIiAmJiBjb25zb2xlLmVycm9yKFxuICAgICAgXCJUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC5cIlxuICAgICk7XG4gICAgZnVuY3Rpb24gaSgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IEIgPSBuZXcgVWludDhBcnJheSgxKSwgUyA9IHsgZm9vOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gNDI7XG4gICAgICAgIH0gfTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihTLCBVaW50OEFycmF5LnByb3RvdHlwZSksIE9iamVjdC5zZXRQcm90b3R5cGVPZihCLCBTKSwgQi5mb28oKSA9PT0gNDI7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgfVxuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYS5wcm90b3R5cGUsIFwicGFyZW50XCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGEuaXNCdWZmZXIodGhpcykpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICAgICAgfVxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoYS5wcm90b3R5cGUsIFwib2Zmc2V0XCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGEuaXNCdWZmZXIodGhpcykpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmdW5jdGlvbiBvKEIpIHtcbiAgICAgIGlmIChCID4gbilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBCICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpO1xuICAgICAgY29uc3QgUyA9IG5ldyBVaW50OEFycmF5KEIpO1xuICAgICAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihTLCBhLnByb3RvdHlwZSksIFM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGEoQiwgUywgVCkge1xuICAgICAgaWYgKHR5cGVvZiBCID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBTID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgICAgICApO1xuICAgICAgICByZXR1cm4gZChCKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsKEIsIFMsIFQpO1xuICAgIH1cbiAgICBhLnBvb2xTaXplID0gODE5MjtcbiAgICBmdW5jdGlvbiBsKEIsIFMsIFQpIHtcbiAgICAgIGlmICh0eXBlb2YgQiA9PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gaChCLCBTKTtcbiAgICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoQikpXG4gICAgICAgIHJldHVybiBwKEIpO1xuICAgICAgaWYgKEIgPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiICsgdHlwZW9mIEJcbiAgICAgICAgKTtcbiAgICAgIGlmIChkdChCLCBBcnJheUJ1ZmZlcikgfHwgQiAmJiBkdChCLmJ1ZmZlciwgQXJyYXlCdWZmZXIpIHx8IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA8IFwidVwiICYmIChkdChCLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHwgQiAmJiBkdChCLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSlcbiAgICAgICAgcmV0dXJuIHkoQiwgUywgVCk7XG4gICAgICBpZiAodHlwZW9mIEIgPT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICAgICk7XG4gICAgICBjb25zdCBHID0gQi52YWx1ZU9mICYmIEIudmFsdWVPZigpO1xuICAgICAgaWYgKEcgIT0gbnVsbCAmJiBHICE9PSBCKVxuICAgICAgICByZXR1cm4gYS5mcm9tKEcsIFMsIFQpO1xuICAgICAgY29uc3QgWiA9IEUoQik7XG4gICAgICBpZiAoWikgcmV0dXJuIFo7XG4gICAgICBpZiAodHlwZW9mIFN5bWJvbCA8IFwidVwiICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmIHR5cGVvZiBCW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gYS5mcm9tKEJbU3ltYm9sLnRvUHJpbWl0aXZlXShcInN0cmluZ1wiKSwgUywgVCk7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiICsgdHlwZW9mIEJcbiAgICAgICk7XG4gICAgfVxuICAgIGEuZnJvbSA9IGZ1bmN0aW9uKEIsIFMsIFQpIHtcbiAgICAgIHJldHVybiBsKEIsIFMsIFQpO1xuICAgIH0sIE9iamVjdC5zZXRQcm90b3R5cGVPZihhLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpLCBPYmplY3Quc2V0UHJvdG90eXBlT2YoYSwgVWludDhBcnJheSk7XG4gICAgZnVuY3Rpb24gYyhCKSB7XG4gICAgICBpZiAodHlwZW9mIEIgIT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpO1xuICAgICAgaWYgKEIgPCAwKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIEIgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHUoQiwgUywgVCkge1xuICAgICAgcmV0dXJuIGMoQiksIEIgPD0gMCA/IG8oQikgOiBTICE9PSB2b2lkIDAgPyB0eXBlb2YgVCA9PSBcInN0cmluZ1wiID8gbyhCKS5maWxsKFMsIFQpIDogbyhCKS5maWxsKFMpIDogbyhCKTtcbiAgICB9XG4gICAgYS5hbGxvYyA9IGZ1bmN0aW9uKEIsIFMsIFQpIHtcbiAgICAgIHJldHVybiB1KEIsIFMsIFQpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gZChCKSB7XG4gICAgICByZXR1cm4gYyhCKSwgbyhCIDwgMCA/IDAgOiBiKEIpIHwgMCk7XG4gICAgfVxuICAgIGEuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbihCKSB7XG4gICAgICByZXR1cm4gZChCKTtcbiAgICB9LCBhLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uKEIpIHtcbiAgICAgIHJldHVybiBkKEIpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gaChCLCBTKSB7XG4gICAgICBpZiAoKHR5cGVvZiBTICE9IFwic3RyaW5nXCIgfHwgUyA9PT0gXCJcIikgJiYgKFMgPSBcInV0ZjhcIiksICFhLmlzRW5jb2RpbmcoUykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIiArIFMpO1xuICAgICAgY29uc3QgVCA9IEEoQiwgUykgfCAwO1xuICAgICAgbGV0IEcgPSBvKFQpO1xuICAgICAgY29uc3QgWiA9IEcud3JpdGUoQiwgUyk7XG4gICAgICByZXR1cm4gWiAhPT0gVCAmJiAoRyA9IEcuc2xpY2UoMCwgWikpLCBHO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmKEIpIHtcbiAgICAgIGNvbnN0IFMgPSBCLmxlbmd0aCA8IDAgPyAwIDogYihCLmxlbmd0aCkgfCAwLCBUID0gbyhTKTtcbiAgICAgIGZvciAobGV0IEcgPSAwOyBHIDwgUzsgRyArPSAxKVxuICAgICAgICBUW0ddID0gQltHXSAmIDI1NTtcbiAgICAgIHJldHVybiBUO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwKEIpIHtcbiAgICAgIGlmIChkdChCLCBVaW50OEFycmF5KSkge1xuICAgICAgICBjb25zdCBTID0gbmV3IFVpbnQ4QXJyYXkoQik7XG4gICAgICAgIHJldHVybiB5KFMuYnVmZmVyLCBTLmJ5dGVPZmZzZXQsIFMuYnl0ZUxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZihCKTtcbiAgICB9XG4gICAgZnVuY3Rpb24geShCLCBTLCBUKSB7XG4gICAgICBpZiAoUyA8IDAgfHwgQi5ieXRlTGVuZ3RoIDwgUylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyk7XG4gICAgICBpZiAoQi5ieXRlTGVuZ3RoIDwgUyArIChUIHx8IDApKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKTtcbiAgICAgIGxldCBHO1xuICAgICAgcmV0dXJuIFMgPT09IHZvaWQgMCAmJiBUID09PSB2b2lkIDAgPyBHID0gbmV3IFVpbnQ4QXJyYXkoQikgOiBUID09PSB2b2lkIDAgPyBHID0gbmV3IFVpbnQ4QXJyYXkoQiwgUykgOiBHID0gbmV3IFVpbnQ4QXJyYXkoQiwgUywgVCksIE9iamVjdC5zZXRQcm90b3R5cGVPZihHLCBhLnByb3RvdHlwZSksIEc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEUoQikge1xuICAgICAgaWYgKGEuaXNCdWZmZXIoQikpIHtcbiAgICAgICAgY29uc3QgUyA9IGIoQi5sZW5ndGgpIHwgMCwgVCA9IG8oUyk7XG4gICAgICAgIHJldHVybiBULmxlbmd0aCA9PT0gMCB8fCBCLmNvcHkoVCwgMCwgMCwgUyksIFQ7XG4gICAgICB9XG4gICAgICBpZiAoQi5sZW5ndGggIT09IHZvaWQgMClcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBCLmxlbmd0aCAhPSBcIm51bWJlclwiIHx8IEplKEIubGVuZ3RoKSA/IG8oMCkgOiBmKEIpO1xuICAgICAgaWYgKEIudHlwZSA9PT0gXCJCdWZmZXJcIiAmJiBBcnJheS5pc0FycmF5KEIuZGF0YSkpXG4gICAgICAgIHJldHVybiBmKEIuZGF0YSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGIoQikge1xuICAgICAgaWYgKEIgPj0gbilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtIHNpemU6IDB4XCIgKyBuLnRvU3RyaW5nKDE2KSArIFwiIGJ5dGVzXCIpO1xuICAgICAgcmV0dXJuIEIgfCAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSKEIpIHtcbiAgICAgIHJldHVybiArQiAhPSBCICYmIChCID0gMCksIGEuYWxsb2MoK0IpO1xuICAgIH1cbiAgICBhLmlzQnVmZmVyID0gZnVuY3Rpb24oUykge1xuICAgICAgcmV0dXJuIFMgIT0gbnVsbCAmJiBTLl9pc0J1ZmZlciA9PT0gITAgJiYgUyAhPT0gYS5wcm90b3R5cGU7XG4gICAgfSwgYS5jb21wYXJlID0gZnVuY3Rpb24oUywgVCkge1xuICAgICAgaWYgKGR0KFMsIFVpbnQ4QXJyYXkpICYmIChTID0gYS5mcm9tKFMsIFMub2Zmc2V0LCBTLmJ5dGVMZW5ndGgpKSwgZHQoVCwgVWludDhBcnJheSkgJiYgKFQgPSBhLmZyb20oVCwgVC5vZmZzZXQsIFQuYnl0ZUxlbmd0aCkpLCAhYS5pc0J1ZmZlcihTKSB8fCAhYS5pc0J1ZmZlcihUKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICAgICAgKTtcbiAgICAgIGlmIChTID09PSBUKSByZXR1cm4gMDtcbiAgICAgIGxldCBHID0gUy5sZW5ndGgsIFogPSBULmxlbmd0aDtcbiAgICAgIGZvciAobGV0IFEgPSAwLCBzZSA9IE1hdGgubWluKEcsIFopOyBRIDwgc2U7ICsrUSlcbiAgICAgICAgaWYgKFNbUV0gIT09IFRbUV0pIHtcbiAgICAgICAgICBHID0gU1tRXSwgWiA9IFRbUV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiBHIDwgWiA/IC0xIDogWiA8IEcgPyAxIDogMDtcbiAgICB9LCBhLmlzRW5jb2RpbmcgPSBmdW5jdGlvbihTKSB7XG4gICAgICBzd2l0Y2ggKFN0cmluZyhTKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgY2FzZSBcInV0ZjhcIjpcbiAgICAgICAgY2FzZSBcInV0Zi04XCI6XG4gICAgICAgIGNhc2UgXCJhc2NpaVwiOlxuICAgICAgICBjYXNlIFwibGF0aW4xXCI6XG4gICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcbiAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICBjYXNlIFwidWNzMlwiOlxuICAgICAgICBjYXNlIFwidWNzLTJcIjpcbiAgICAgICAgY2FzZSBcInV0ZjE2bGVcIjpcbiAgICAgICAgY2FzZSBcInV0Zi0xNmxlXCI6XG4gICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICB9LCBhLmNvbmNhdCA9IGZ1bmN0aW9uKFMsIFQpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShTKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7XG4gICAgICBpZiAoUy5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBhLmFsbG9jKDApO1xuICAgICAgbGV0IEc7XG4gICAgICBpZiAoVCA9PT0gdm9pZCAwKVxuICAgICAgICBmb3IgKFQgPSAwLCBHID0gMDsgRyA8IFMubGVuZ3RoOyArK0cpXG4gICAgICAgICAgVCArPSBTW0ddLmxlbmd0aDtcbiAgICAgIGNvbnN0IFogPSBhLmFsbG9jVW5zYWZlKFQpO1xuICAgICAgbGV0IFEgPSAwO1xuICAgICAgZm9yIChHID0gMDsgRyA8IFMubGVuZ3RoOyArK0cpIHtcbiAgICAgICAgbGV0IHNlID0gU1tHXTtcbiAgICAgICAgaWYgKGR0KHNlLCBVaW50OEFycmF5KSlcbiAgICAgICAgICBRICsgc2UubGVuZ3RoID4gWi5sZW5ndGggPyAoYS5pc0J1ZmZlcihzZSkgfHwgKHNlID0gYS5mcm9tKHNlKSksIHNlLmNvcHkoWiwgUSkpIDogVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgICBaLFxuICAgICAgICAgICAgc2UsXG4gICAgICAgICAgICBRXG4gICAgICAgICAgKTtcbiAgICAgICAgZWxzZSBpZiAoYS5pc0J1ZmZlcihzZSkpXG4gICAgICAgICAgc2UuY29weShaLCBRKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpO1xuICAgICAgICBRICs9IHNlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBaO1xuICAgIH07XG4gICAgZnVuY3Rpb24gQShCLCBTKSB7XG4gICAgICBpZiAoYS5pc0J1ZmZlcihCKSlcbiAgICAgICAgcmV0dXJuIEIubGVuZ3RoO1xuICAgICAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhCKSB8fCBkdChCLCBBcnJheUJ1ZmZlcikpXG4gICAgICAgIHJldHVybiBCLmJ5dGVMZW5ndGg7XG4gICAgICBpZiAodHlwZW9mIEIgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBCXG4gICAgICAgICk7XG4gICAgICBjb25zdCBUID0gQi5sZW5ndGgsIEcgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09ICEwO1xuICAgICAgaWYgKCFHICYmIFQgPT09IDApIHJldHVybiAwO1xuICAgICAgbGV0IFogPSAhMTtcbiAgICAgIGZvciAoOyA7IClcbiAgICAgICAgc3dpdGNoIChTKSB7XG4gICAgICAgICAgY2FzZSBcImFzY2lpXCI6XG4gICAgICAgICAgY2FzZSBcImxhdGluMVwiOlxuICAgICAgICAgIGNhc2UgXCJiaW5hcnlcIjpcbiAgICAgICAgICAgIHJldHVybiBUO1xuICAgICAgICAgIGNhc2UgXCJ1dGY4XCI6XG4gICAgICAgICAgY2FzZSBcInV0Zi04XCI6XG4gICAgICAgICAgICByZXR1cm4gYmUoQikubGVuZ3RoO1xuICAgICAgICAgIGNhc2UgXCJ1Y3MyXCI6XG4gICAgICAgICAgY2FzZSBcInVjcy0yXCI6XG4gICAgICAgICAgY2FzZSBcInV0ZjE2bGVcIjpcbiAgICAgICAgICBjYXNlIFwidXRmLTE2bGVcIjpcbiAgICAgICAgICAgIHJldHVybiBUICogMjtcbiAgICAgICAgICBjYXNlIFwiaGV4XCI6XG4gICAgICAgICAgICByZXR1cm4gVCA+Pj4gMTtcbiAgICAgICAgICBjYXNlIFwiYmFzZTY0XCI6XG4gICAgICAgICAgICByZXR1cm4gd2UoQikubGVuZ3RoO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoWilcbiAgICAgICAgICAgICAgcmV0dXJuIEcgPyAtMSA6IGJlKEIpLmxlbmd0aDtcbiAgICAgICAgICAgIFMgPSAoXCJcIiArIFMpLnRvTG93ZXJDYXNlKCksIFogPSAhMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhLmJ5dGVMZW5ndGggPSBBO1xuICAgIGZ1bmN0aW9uIEYoQiwgUywgVCkge1xuICAgICAgbGV0IEcgPSAhMTtcbiAgICAgIGlmICgoUyA9PT0gdm9pZCAwIHx8IFMgPCAwKSAmJiAoUyA9IDApLCBTID4gdGhpcy5sZW5ndGggfHwgKChUID09PSB2b2lkIDAgfHwgVCA+IHRoaXMubGVuZ3RoKSAmJiAoVCA9IHRoaXMubGVuZ3RoKSwgVCA8PSAwKSB8fCAoVCA+Pj49IDAsIFMgPj4+PSAwLCBUIDw9IFMpKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIGZvciAoQiB8fCAoQiA9IFwidXRmOFwiKTsgOyApXG4gICAgICAgIHN3aXRjaCAoQikge1xuICAgICAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgICAgIHJldHVybiBVKHRoaXMsIFMsIFQpO1xuICAgICAgICAgIGNhc2UgXCJ1dGY4XCI6XG4gICAgICAgICAgY2FzZSBcInV0Zi04XCI6XG4gICAgICAgICAgICByZXR1cm4gZyh0aGlzLCBTLCBUKTtcbiAgICAgICAgICBjYXNlIFwiYXNjaWlcIjpcbiAgICAgICAgICAgIHJldHVybiBEKHRoaXMsIFMsIFQpO1xuICAgICAgICAgIGNhc2UgXCJsYXRpbjFcIjpcbiAgICAgICAgICBjYXNlIFwiYmluYXJ5XCI6XG4gICAgICAgICAgICByZXR1cm4gTyh0aGlzLCBTLCBUKTtcbiAgICAgICAgICBjYXNlIFwiYmFzZTY0XCI6XG4gICAgICAgICAgICByZXR1cm4gXyh0aGlzLCBTLCBUKTtcbiAgICAgICAgICBjYXNlIFwidWNzMlwiOlxuICAgICAgICAgIGNhc2UgXCJ1Y3MtMlwiOlxuICAgICAgICAgIGNhc2UgXCJ1dGYxNmxlXCI6XG4gICAgICAgICAgY2FzZSBcInV0Zi0xNmxlXCI6XG4gICAgICAgICAgICByZXR1cm4gVih0aGlzLCBTLCBUKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgaWYgKEcpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIiArIEIpO1xuICAgICAgICAgICAgQiA9IChCICsgXCJcIikudG9Mb3dlckNhc2UoKSwgRyA9ICEwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGEucHJvdG90eXBlLl9pc0J1ZmZlciA9ICEwO1xuICAgIGZ1bmN0aW9uIE0oQiwgUywgVCkge1xuICAgICAgY29uc3QgRyA9IEJbU107XG4gICAgICBCW1NdID0gQltUXSwgQltUXSA9IEc7XG4gICAgfVxuICAgIGEucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgUyA9IHRoaXMubGVuZ3RoO1xuICAgICAgaWYgKFMgJSAyICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzXCIpO1xuICAgICAgZm9yIChsZXQgVCA9IDA7IFQgPCBTOyBUICs9IDIpXG4gICAgICAgIE0odGhpcywgVCwgVCArIDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgYS5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zdCBTID0gdGhpcy5sZW5ndGg7XG4gICAgICBpZiAoUyAlIDQgIT09IDApXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHNcIik7XG4gICAgICBmb3IgKGxldCBUID0gMDsgVCA8IFM7IFQgKz0gNClcbiAgICAgICAgTSh0aGlzLCBULCBUICsgMyksIE0odGhpcywgVCArIDEsIFQgKyAyKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIGEucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgUyA9IHRoaXMubGVuZ3RoO1xuICAgICAgaWYgKFMgJSA4ICE9PSAwKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzXCIpO1xuICAgICAgZm9yIChsZXQgVCA9IDA7IFQgPCBTOyBUICs9IDgpXG4gICAgICAgIE0odGhpcywgVCwgVCArIDcpLCBNKHRoaXMsIFQgKyAxLCBUICsgNiksIE0odGhpcywgVCArIDIsIFQgKyA1KSwgTSh0aGlzLCBUICsgMywgVCArIDQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSwgYS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IFMgPSB0aGlzLmxlbmd0aDtcbiAgICAgIHJldHVybiBTID09PSAwID8gXCJcIiA6IGFyZ3VtZW50cy5sZW5ndGggPT09IDAgPyBnKHRoaXMsIDAsIFMpIDogRi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sIGEucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gYS5wcm90b3R5cGUudG9TdHJpbmcsIGEucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uKFMpIHtcbiAgICAgIGlmICghYS5pc0J1ZmZlcihTKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXJcIik7XG4gICAgICByZXR1cm4gdGhpcyA9PT0gUyA/ICEwIDogYS5jb21wYXJlKHRoaXMsIFMpID09PSAwO1xuICAgIH0sIGEucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgIGxldCBTID0gXCJcIjtcbiAgICAgIGNvbnN0IFQgPSBzLklOU1BFQ1RfTUFYX0JZVEVTO1xuICAgICAgcmV0dXJuIFMgPSB0aGlzLnRvU3RyaW5nKFwiaGV4XCIsIDAsIFQpLnJlcGxhY2UoLyguezJ9KS9nLCBcIiQxIFwiKS50cmltKCksIHRoaXMubGVuZ3RoID4gVCAmJiAoUyArPSBcIiAuLi4gXCIpLCBcIjxCdWZmZXIgXCIgKyBTICsgXCI+XCI7XG4gICAgfSwgciAmJiAoYS5wcm90b3R5cGVbcl0gPSBhLnByb3RvdHlwZS5pbnNwZWN0KSwgYS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uKFMsIFQsIEcsIFosIFEpIHtcbiAgICAgIGlmIChkdChTLCBVaW50OEFycmF5KSAmJiAoUyA9IGEuZnJvbShTLCBTLm9mZnNldCwgUy5ieXRlTGVuZ3RoKSksICFhLmlzQnVmZmVyKFMpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgU1xuICAgICAgICApO1xuICAgICAgaWYgKFQgPT09IHZvaWQgMCAmJiAoVCA9IDApLCBHID09PSB2b2lkIDAgJiYgKEcgPSBTID8gUy5sZW5ndGggOiAwKSwgWiA9PT0gdm9pZCAwICYmIChaID0gMCksIFEgPT09IHZvaWQgMCAmJiAoUSA9IHRoaXMubGVuZ3RoKSwgVCA8IDAgfHwgRyA+IFMubGVuZ3RoIHx8IFogPCAwIHx8IFEgPiB0aGlzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvdXQgb2YgcmFuZ2UgaW5kZXhcIik7XG4gICAgICBpZiAoWiA+PSBRICYmIFQgPj0gRylcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICBpZiAoWiA+PSBRKVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgICBpZiAoVCA+PSBHKVxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIGlmIChUID4+Pj0gMCwgRyA+Pj49IDAsIFogPj4+PSAwLCBRID4+Pj0gMCwgdGhpcyA9PT0gUykgcmV0dXJuIDA7XG4gICAgICBsZXQgc2UgPSBRIC0gWiwgVWUgPSBHIC0gVDtcbiAgICAgIGNvbnN0IFBlID0gTWF0aC5taW4oc2UsIFVlKSwgTGUgPSB0aGlzLnNsaWNlKFosIFEpLCBjdCA9IFMuc2xpY2UoVCwgRyk7XG4gICAgICBmb3IgKGxldCBBZSA9IDA7IEFlIDwgUGU7ICsrQWUpXG4gICAgICAgIGlmIChMZVtBZV0gIT09IGN0W0FlXSkge1xuICAgICAgICAgIHNlID0gTGVbQWVdLCBVZSA9IGN0W0FlXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgcmV0dXJuIHNlIDwgVWUgPyAtMSA6IFVlIDwgc2UgPyAxIDogMDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIEgoQiwgUywgVCwgRywgWikge1xuICAgICAgaWYgKEIubGVuZ3RoID09PSAwKSByZXR1cm4gLTE7XG4gICAgICBpZiAodHlwZW9mIFQgPT0gXCJzdHJpbmdcIiA/IChHID0gVCwgVCA9IDApIDogVCA+IDIxNDc0ODM2NDcgPyBUID0gMjE0NzQ4MzY0NyA6IFQgPCAtMjE0NzQ4MzY0OCAmJiAoVCA9IC0yMTQ3NDgzNjQ4KSwgVCA9ICtULCBKZShUKSAmJiAoVCA9IFogPyAwIDogQi5sZW5ndGggLSAxKSwgVCA8IDAgJiYgKFQgPSBCLmxlbmd0aCArIFQpLCBUID49IEIubGVuZ3RoKSB7XG4gICAgICAgIGlmIChaKSByZXR1cm4gLTE7XG4gICAgICAgIFQgPSBCLmxlbmd0aCAtIDE7XG4gICAgICB9IGVsc2UgaWYgKFQgPCAwKVxuICAgICAgICBpZiAoWikgVCA9IDA7XG4gICAgICAgIGVsc2UgcmV0dXJuIC0xO1xuICAgICAgaWYgKHR5cGVvZiBTID09IFwic3RyaW5nXCIgJiYgKFMgPSBhLmZyb20oUywgRykpLCBhLmlzQnVmZmVyKFMpKVxuICAgICAgICByZXR1cm4gUy5sZW5ndGggPT09IDAgPyAtMSA6IEsoQiwgUywgVCwgRywgWik7XG4gICAgICBpZiAodHlwZW9mIFMgPT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIFMgPSBTICYgMjU1LCB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PSBcImZ1bmN0aW9uXCIgPyBaID8gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKEIsIFMsIFQpIDogVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChCLCBTLCBUKSA6IEsoQiwgW1NdLCBULCBHLCBaKTtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXJcIik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEsoQiwgUywgVCwgRywgWikge1xuICAgICAgbGV0IFEgPSAxLCBzZSA9IEIubGVuZ3RoLCBVZSA9IFMubGVuZ3RoO1xuICAgICAgaWYgKEcgIT09IHZvaWQgMCAmJiAoRyA9IFN0cmluZyhHKS50b0xvd2VyQ2FzZSgpLCBHID09PSBcInVjczJcIiB8fCBHID09PSBcInVjcy0yXCIgfHwgRyA9PT0gXCJ1dGYxNmxlXCIgfHwgRyA9PT0gXCJ1dGYtMTZsZVwiKSkge1xuICAgICAgICBpZiAoQi5sZW5ndGggPCAyIHx8IFMubGVuZ3RoIDwgMilcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIFEgPSAyLCBzZSAvPSAyLCBVZSAvPSAyLCBUIC89IDI7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBQZShjdCwgQWUpIHtcbiAgICAgICAgcmV0dXJuIFEgPT09IDEgPyBjdFtBZV0gOiBjdC5yZWFkVUludDE2QkUoQWUgKiBRKTtcbiAgICAgIH1cbiAgICAgIGxldCBMZTtcbiAgICAgIGlmIChaKSB7XG4gICAgICAgIGxldCBjdCA9IC0xO1xuICAgICAgICBmb3IgKExlID0gVDsgTGUgPCBzZTsgTGUrKylcbiAgICAgICAgICBpZiAoUGUoQiwgTGUpID09PSBQZShTLCBjdCA9PT0gLTEgPyAwIDogTGUgLSBjdCkpIHtcbiAgICAgICAgICAgIGlmIChjdCA9PT0gLTEgJiYgKGN0ID0gTGUpLCBMZSAtIGN0ICsgMSA9PT0gVWUpIHJldHVybiBjdCAqIFE7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBjdCAhPT0gLTEgJiYgKExlIC09IExlIC0gY3QpLCBjdCA9IC0xO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGZvciAoVCArIFVlID4gc2UgJiYgKFQgPSBzZSAtIFVlKSwgTGUgPSBUOyBMZSA+PSAwOyBMZS0tKSB7XG4gICAgICAgICAgbGV0IGN0ID0gITA7XG4gICAgICAgICAgZm9yIChsZXQgQWUgPSAwOyBBZSA8IFVlOyBBZSsrKVxuICAgICAgICAgICAgaWYgKFBlKEIsIExlICsgQWUpICE9PSBQZShTLCBBZSkpIHtcbiAgICAgICAgICAgICAgY3QgPSAhMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGN0KSByZXR1cm4gTGU7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgYS5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbihTLCBULCBHKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleE9mKFMsIFQsIEcpICE9PSAtMTtcbiAgICB9LCBhLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24oUywgVCwgRykge1xuICAgICAgcmV0dXJuIEgodGhpcywgUywgVCwgRywgITApO1xuICAgIH0sIGEucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24oUywgVCwgRykge1xuICAgICAgcmV0dXJuIEgodGhpcywgUywgVCwgRywgITEpO1xuICAgIH07XG4gICAgZnVuY3Rpb24gaihCLCBTLCBULCBHKSB7XG4gICAgICBUID0gTnVtYmVyKFQpIHx8IDA7XG4gICAgICBjb25zdCBaID0gQi5sZW5ndGggLSBUO1xuICAgICAgRyA/IChHID0gTnVtYmVyKEcpLCBHID4gWiAmJiAoRyA9IFopKSA6IEcgPSBaO1xuICAgICAgY29uc3QgUSA9IFMubGVuZ3RoO1xuICAgICAgRyA+IFEgLyAyICYmIChHID0gUSAvIDIpO1xuICAgICAgbGV0IHNlO1xuICAgICAgZm9yIChzZSA9IDA7IHNlIDwgRzsgKytzZSkge1xuICAgICAgICBjb25zdCBVZSA9IHBhcnNlSW50KFMuc3Vic3RyKHNlICogMiwgMiksIDE2KTtcbiAgICAgICAgaWYgKEplKFVlKSkgcmV0dXJuIHNlO1xuICAgICAgICBCW1QgKyBzZV0gPSBVZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQyhCLCBTLCBULCBHKSB7XG4gICAgICByZXR1cm4gTmUoYmUoUywgQi5sZW5ndGggLSBUKSwgQiwgVCwgRyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGsoQiwgUywgVCwgRykge1xuICAgICAgcmV0dXJuIE5lKEZlKFMpLCBCLCBULCBHKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gJChCLCBTLCBULCBHKSB7XG4gICAgICByZXR1cm4gTmUod2UoUyksIEIsIFQsIEcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBXKEIsIFMsIFQsIEcpIHtcbiAgICAgIHJldHVybiBOZShYZShTLCBCLmxlbmd0aCAtIFQpLCBCLCBULCBHKTtcbiAgICB9XG4gICAgYS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihTLCBULCBHLCBaKSB7XG4gICAgICBpZiAoVCA9PT0gdm9pZCAwKVxuICAgICAgICBaID0gXCJ1dGY4XCIsIEcgPSB0aGlzLmxlbmd0aCwgVCA9IDA7XG4gICAgICBlbHNlIGlmIChHID09PSB2b2lkIDAgJiYgdHlwZW9mIFQgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgWiA9IFQsIEcgPSB0aGlzLmxlbmd0aCwgVCA9IDA7XG4gICAgICBlbHNlIGlmIChpc0Zpbml0ZShUKSlcbiAgICAgICAgVCA9IFQgPj4+IDAsIGlzRmluaXRlKEcpID8gKEcgPSBHID4+PiAwLCBaID09PSB2b2lkIDAgJiYgKFogPSBcInV0ZjhcIikpIDogKFogPSBHLCBHID0gdm9pZCAwKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIlxuICAgICAgICApO1xuICAgICAgY29uc3QgUSA9IHRoaXMubGVuZ3RoIC0gVDtcbiAgICAgIGlmICgoRyA9PT0gdm9pZCAwIHx8IEcgPiBRKSAmJiAoRyA9IFEpLCBTLmxlbmd0aCA+IDAgJiYgKEcgPCAwIHx8IFQgPCAwKSB8fCBUID4gdGhpcy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHNcIik7XG4gICAgICBaIHx8IChaID0gXCJ1dGY4XCIpO1xuICAgICAgbGV0IHNlID0gITE7XG4gICAgICBmb3IgKDsgOyApXG4gICAgICAgIHN3aXRjaCAoWikge1xuICAgICAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgICAgIHJldHVybiBqKHRoaXMsIFMsIFQsIEcpO1xuICAgICAgICAgIGNhc2UgXCJ1dGY4XCI6XG4gICAgICAgICAgY2FzZSBcInV0Zi04XCI6XG4gICAgICAgICAgICByZXR1cm4gQyh0aGlzLCBTLCBULCBHKTtcbiAgICAgICAgICBjYXNlIFwiYXNjaWlcIjpcbiAgICAgICAgICBjYXNlIFwibGF0aW4xXCI6XG4gICAgICAgICAgY2FzZSBcImJpbmFyeVwiOlxuICAgICAgICAgICAgcmV0dXJuIGsodGhpcywgUywgVCwgRyk7XG4gICAgICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICAgICAgcmV0dXJuICQodGhpcywgUywgVCwgRyk7XG4gICAgICAgICAgY2FzZSBcInVjczJcIjpcbiAgICAgICAgICBjYXNlIFwidWNzLTJcIjpcbiAgICAgICAgICBjYXNlIFwidXRmMTZsZVwiOlxuICAgICAgICAgIGNhc2UgXCJ1dGYtMTZsZVwiOlxuICAgICAgICAgICAgcmV0dXJuIFcodGhpcywgUywgVCwgRyk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGlmIChzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiICsgWik7XG4gICAgICAgICAgICBaID0gKFwiXCIgKyBaKS50b0xvd2VyQ2FzZSgpLCBzZSA9ICEwO1xuICAgICAgICB9XG4gICAgfSwgYS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIkJ1ZmZlclwiLFxuICAgICAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgICAgIH07XG4gICAgfTtcbiAgICBmdW5jdGlvbiBfKEIsIFMsIFQpIHtcbiAgICAgIHJldHVybiBTID09PSAwICYmIFQgPT09IEIubGVuZ3RoID8gZS5mcm9tQnl0ZUFycmF5KEIpIDogZS5mcm9tQnl0ZUFycmF5KEIuc2xpY2UoUywgVCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnKEIsIFMsIFQpIHtcbiAgICAgIFQgPSBNYXRoLm1pbihCLmxlbmd0aCwgVCk7XG4gICAgICBjb25zdCBHID0gW107XG4gICAgICBsZXQgWiA9IFM7XG4gICAgICBmb3IgKDsgWiA8IFQ7ICkge1xuICAgICAgICBjb25zdCBRID0gQltaXTtcbiAgICAgICAgbGV0IHNlID0gbnVsbCwgVWUgPSBRID4gMjM5ID8gNCA6IFEgPiAyMjMgPyAzIDogUSA+IDE5MSA/IDIgOiAxO1xuICAgICAgICBpZiAoWiArIFVlIDw9IFQpIHtcbiAgICAgICAgICBsZXQgUGUsIExlLCBjdCwgQWU7XG4gICAgICAgICAgc3dpdGNoIChVZSkge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBRIDwgMTI4ICYmIChzZSA9IFEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgUGUgPSBCW1ogKyAxXSwgKFBlICYgMTkyKSA9PT0gMTI4ICYmIChBZSA9IChRICYgMzEpIDw8IDYgfCBQZSAmIDYzLCBBZSA+IDEyNyAmJiAoc2UgPSBBZSkpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgUGUgPSBCW1ogKyAxXSwgTGUgPSBCW1ogKyAyXSwgKFBlICYgMTkyKSA9PT0gMTI4ICYmIChMZSAmIDE5MikgPT09IDEyOCAmJiAoQWUgPSAoUSAmIDE1KSA8PCAxMiB8IChQZSAmIDYzKSA8PCA2IHwgTGUgJiA2MywgQWUgPiAyMDQ3ICYmIChBZSA8IDU1Mjk2IHx8IEFlID4gNTczNDMpICYmIChzZSA9IEFlKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBQZSA9IEJbWiArIDFdLCBMZSA9IEJbWiArIDJdLCBjdCA9IEJbWiArIDNdLCAoUGUgJiAxOTIpID09PSAxMjggJiYgKExlICYgMTkyKSA9PT0gMTI4ICYmIChjdCAmIDE5MikgPT09IDEyOCAmJiAoQWUgPSAoUSAmIDE1KSA8PCAxOCB8IChQZSAmIDYzKSA8PCAxMiB8IChMZSAmIDYzKSA8PCA2IHwgY3QgJiA2MywgQWUgPiA2NTUzNSAmJiBBZSA8IDExMTQxMTIgJiYgKHNlID0gQWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2UgPT09IG51bGwgPyAoc2UgPSA2NTUzMywgVWUgPSAxKSA6IHNlID4gNjU1MzUgJiYgKHNlIC09IDY1NTM2LCBHLnB1c2goc2UgPj4+IDEwICYgMTAyMyB8IDU1Mjk2KSwgc2UgPSA1NjMyMCB8IHNlICYgMTAyMyksIEcucHVzaChzZSksIFogKz0gVWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdyhHKTtcbiAgICB9XG4gICAgY29uc3QgeCA9IDQwOTY7XG4gICAgZnVuY3Rpb24gdyhCKSB7XG4gICAgICBjb25zdCBTID0gQi5sZW5ndGg7XG4gICAgICBpZiAoUyA8PSB4KVxuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIEIpO1xuICAgICAgbGV0IFQgPSBcIlwiLCBHID0gMDtcbiAgICAgIGZvciAoOyBHIDwgUzsgKVxuICAgICAgICBUICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICAgICAgU3RyaW5nLFxuICAgICAgICAgIEIuc2xpY2UoRywgRyArPSB4KVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEQoQiwgUywgVCkge1xuICAgICAgbGV0IEcgPSBcIlwiO1xuICAgICAgVCA9IE1hdGgubWluKEIubGVuZ3RoLCBUKTtcbiAgICAgIGZvciAobGV0IFogPSBTOyBaIDwgVDsgKytaKVxuICAgICAgICBHICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoQltaXSAmIDEyNyk7XG4gICAgICByZXR1cm4gRztcbiAgICB9XG4gICAgZnVuY3Rpb24gTyhCLCBTLCBUKSB7XG4gICAgICBsZXQgRyA9IFwiXCI7XG4gICAgICBUID0gTWF0aC5taW4oQi5sZW5ndGgsIFQpO1xuICAgICAgZm9yIChsZXQgWiA9IFM7IFogPCBUOyArK1opXG4gICAgICAgIEcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShCW1pdKTtcbiAgICAgIHJldHVybiBHO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVKEIsIFMsIFQpIHtcbiAgICAgIGNvbnN0IEcgPSBCLmxlbmd0aDtcbiAgICAgICghUyB8fCBTIDwgMCkgJiYgKFMgPSAwKSwgKCFUIHx8IFQgPCAwIHx8IFQgPiBHKSAmJiAoVCA9IEcpO1xuICAgICAgbGV0IFogPSBcIlwiO1xuICAgICAgZm9yIChsZXQgUSA9IFM7IFEgPCBUOyArK1EpXG4gICAgICAgIFogKz0gUWVbQltRXV07XG4gICAgICByZXR1cm4gWjtcbiAgICB9XG4gICAgZnVuY3Rpb24gVihCLCBTLCBUKSB7XG4gICAgICBjb25zdCBHID0gQi5zbGljZShTLCBUKTtcbiAgICAgIGxldCBaID0gXCJcIjtcbiAgICAgIGZvciAobGV0IFEgPSAwOyBRIDwgRy5sZW5ndGggLSAxOyBRICs9IDIpXG4gICAgICAgIFogKz0gU3RyaW5nLmZyb21DaGFyQ29kZShHW1FdICsgR1tRICsgMV0gKiAyNTYpO1xuICAgICAgcmV0dXJuIFo7XG4gICAgfVxuICAgIGEucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24oUywgVCkge1xuICAgICAgY29uc3QgRyA9IHRoaXMubGVuZ3RoO1xuICAgICAgUyA9IH5+UywgVCA9IFQgPT09IHZvaWQgMCA/IEcgOiB+flQsIFMgPCAwID8gKFMgKz0gRywgUyA8IDAgJiYgKFMgPSAwKSkgOiBTID4gRyAmJiAoUyA9IEcpLCBUIDwgMCA/IChUICs9IEcsIFQgPCAwICYmIChUID0gMCkpIDogVCA+IEcgJiYgKFQgPSBHKSwgVCA8IFMgJiYgKFQgPSBTKTtcbiAgICAgIGNvbnN0IFogPSB0aGlzLnN1YmFycmF5KFMsIFQpO1xuICAgICAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZihaLCBhLnByb3RvdHlwZSksIFo7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBMKEIsIFMsIFQpIHtcbiAgICAgIGlmIChCICUgMSAhPT0gMCB8fCBCIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvZmZzZXQgaXMgbm90IHVpbnRcIik7XG4gICAgICBpZiAoQiArIFMgPiBUKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGhcIik7XG4gICAgfVxuICAgIGEucHJvdG90eXBlLnJlYWRVaW50TEUgPSBhLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24oUywgVCwgRykge1xuICAgICAgUyA9IFMgPj4+IDAsIFQgPSBUID4+PiAwLCBHIHx8IEwoUywgVCwgdGhpcy5sZW5ndGgpO1xuICAgICAgbGV0IFogPSB0aGlzW1NdLCBRID0gMSwgc2UgPSAwO1xuICAgICAgZm9yICg7ICsrc2UgPCBUICYmIChRICo9IDI1Nik7IClcbiAgICAgICAgWiArPSB0aGlzW1MgKyBzZV0gKiBRO1xuICAgICAgcmV0dXJuIFo7XG4gICAgfSwgYS5wcm90b3R5cGUucmVhZFVpbnRCRSA9IGEucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbihTLCBULCBHKSB7XG4gICAgICBTID0gUyA+Pj4gMCwgVCA9IFQgPj4+IDAsIEcgfHwgTChTLCBULCB0aGlzLmxlbmd0aCk7XG4gICAgICBsZXQgWiA9IHRoaXNbUyArIC0tVF0sIFEgPSAxO1xuICAgICAgZm9yICg7IFQgPiAwICYmIChRICo9IDI1Nik7IClcbiAgICAgICAgWiArPSB0aGlzW1MgKyAtLVRdICogUTtcbiAgICAgIHJldHVybiBaO1xuICAgIH0sIGEucHJvdG90eXBlLnJlYWRVaW50OCA9IGEucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uKFMsIFQpIHtcbiAgICAgIHJldHVybiBTID0gUyA+Pj4gMCwgVCB8fCBMKFMsIDEsIHRoaXMubGVuZ3RoKSwgdGhpc1tTXTtcbiAgICB9LCBhLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPSBhLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbihTLCBUKSB7XG4gICAgICByZXR1cm4gUyA9IFMgPj4+IDAsIFQgfHwgTChTLCAyLCB0aGlzLmxlbmd0aCksIHRoaXNbU10gfCB0aGlzW1MgKyAxXSA8PCA4O1xuICAgIH0sIGEucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9IGEucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uKFMsIFQpIHtcbiAgICAgIHJldHVybiBTID0gUyA+Pj4gMCwgVCB8fCBMKFMsIDIsIHRoaXMubGVuZ3RoKSwgdGhpc1tTXSA8PCA4IHwgdGhpc1tTICsgMV07XG4gICAgfSwgYS5wcm90b3R5cGUucmVhZFVpbnQzMkxFID0gYS5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24oUywgVCkge1xuICAgICAgcmV0dXJuIFMgPSBTID4+PiAwLCBUIHx8IEwoUywgNCwgdGhpcy5sZW5ndGgpLCAodGhpc1tTXSB8IHRoaXNbUyArIDFdIDw8IDggfCB0aGlzW1MgKyAyXSA8PCAxNikgKyB0aGlzW1MgKyAzXSAqIDE2Nzc3MjE2O1xuICAgIH0sIGEucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9IGEucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uKFMsIFQpIHtcbiAgICAgIHJldHVybiBTID0gUyA+Pj4gMCwgVCB8fCBMKFMsIDQsIHRoaXMubGVuZ3RoKSwgdGhpc1tTXSAqIDE2Nzc3MjE2ICsgKHRoaXNbUyArIDFdIDw8IDE2IHwgdGhpc1tTICsgMl0gPDwgOCB8IHRoaXNbUyArIDNdKTtcbiAgICB9LCBhLnByb3RvdHlwZS5yZWFkQmlnVUludDY0TEUgPSBpdChmdW5jdGlvbihTKSB7XG4gICAgICBTID0gUyA+Pj4gMCwgX2UoUywgXCJvZmZzZXRcIik7XG4gICAgICBjb25zdCBUID0gdGhpc1tTXSwgRyA9IHRoaXNbUyArIDddO1xuICAgICAgKFQgPT09IHZvaWQgMCB8fCBHID09PSB2b2lkIDApICYmIHhlKFMsIHRoaXMubGVuZ3RoIC0gOCk7XG4gICAgICBjb25zdCBaID0gVCArIHRoaXNbKytTXSAqIDIgKiogOCArIHRoaXNbKytTXSAqIDIgKiogMTYgKyB0aGlzWysrU10gKiAyICoqIDI0LCBRID0gdGhpc1srK1NdICsgdGhpc1srK1NdICogMiAqKiA4ICsgdGhpc1srK1NdICogMiAqKiAxNiArIEcgKiAyICoqIDI0O1xuICAgICAgcmV0dXJuIEJpZ0ludChaKSArIChCaWdJbnQoUSkgPDwgQmlnSW50KDMyKSk7XG4gICAgfSksIGEucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSA9IGl0KGZ1bmN0aW9uKFMpIHtcbiAgICAgIFMgPSBTID4+PiAwLCBfZShTLCBcIm9mZnNldFwiKTtcbiAgICAgIGNvbnN0IFQgPSB0aGlzW1NdLCBHID0gdGhpc1tTICsgN107XG4gICAgICAoVCA9PT0gdm9pZCAwIHx8IEcgPT09IHZvaWQgMCkgJiYgeGUoUywgdGhpcy5sZW5ndGggLSA4KTtcbiAgICAgIGNvbnN0IFogPSBUICogMiAqKiAyNCArIHRoaXNbKytTXSAqIDIgKiogMTYgKyB0aGlzWysrU10gKiAyICoqIDggKyB0aGlzWysrU10sIFEgPSB0aGlzWysrU10gKiAyICoqIDI0ICsgdGhpc1srK1NdICogMiAqKiAxNiArIHRoaXNbKytTXSAqIDIgKiogOCArIEc7XG4gICAgICByZXR1cm4gKEJpZ0ludChaKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChRKTtcbiAgICB9KSwgYS5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24oUywgVCwgRykge1xuICAgICAgUyA9IFMgPj4+IDAsIFQgPSBUID4+PiAwLCBHIHx8IEwoUywgVCwgdGhpcy5sZW5ndGgpO1xuICAgICAgbGV0IFogPSB0aGlzW1NdLCBRID0gMSwgc2UgPSAwO1xuICAgICAgZm9yICg7ICsrc2UgPCBUICYmIChRICo9IDI1Nik7IClcbiAgICAgICAgWiArPSB0aGlzW1MgKyBzZV0gKiBRO1xuICAgICAgcmV0dXJuIFEgKj0gMTI4LCBaID49IFEgJiYgKFogLT0gTWF0aC5wb3coMiwgOCAqIFQpKSwgWjtcbiAgICB9LCBhLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbihTLCBULCBHKSB7XG4gICAgICBTID0gUyA+Pj4gMCwgVCA9IFQgPj4+IDAsIEcgfHwgTChTLCBULCB0aGlzLmxlbmd0aCk7XG4gICAgICBsZXQgWiA9IFQsIFEgPSAxLCBzZSA9IHRoaXNbUyArIC0tWl07XG4gICAgICBmb3IgKDsgWiA+IDAgJiYgKFEgKj0gMjU2KTsgKVxuICAgICAgICBzZSArPSB0aGlzW1MgKyAtLVpdICogUTtcbiAgICAgIHJldHVybiBRICo9IDEyOCwgc2UgPj0gUSAmJiAoc2UgLT0gTWF0aC5wb3coMiwgOCAqIFQpKSwgc2U7XG4gICAgfSwgYS5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbihTLCBUKSB7XG4gICAgICByZXR1cm4gUyA9IFMgPj4+IDAsIFQgfHwgTChTLCAxLCB0aGlzLmxlbmd0aCksIHRoaXNbU10gJiAxMjggPyAoMjU1IC0gdGhpc1tTXSArIDEpICogLTEgOiB0aGlzW1NdO1xuICAgIH0sIGEucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24oUywgVCkge1xuICAgICAgUyA9IFMgPj4+IDAsIFQgfHwgTChTLCAyLCB0aGlzLmxlbmd0aCk7XG4gICAgICBjb25zdCBHID0gdGhpc1tTXSB8IHRoaXNbUyArIDFdIDw8IDg7XG4gICAgICByZXR1cm4gRyAmIDMyNzY4ID8gRyB8IDQyOTQ5MDE3NjAgOiBHO1xuICAgIH0sIGEucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24oUywgVCkge1xuICAgICAgUyA9IFMgPj4+IDAsIFQgfHwgTChTLCAyLCB0aGlzLmxlbmd0aCk7XG4gICAgICBjb25zdCBHID0gdGhpc1tTICsgMV0gfCB0aGlzW1NdIDw8IDg7XG4gICAgICByZXR1cm4gRyAmIDMyNzY4ID8gRyB8IDQyOTQ5MDE3NjAgOiBHO1xuICAgIH0sIGEucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24oUywgVCkge1xuICAgICAgcmV0dXJuIFMgPSBTID4+PiAwLCBUIHx8IEwoUywgNCwgdGhpcy5sZW5ndGgpLCB0aGlzW1NdIHwgdGhpc1tTICsgMV0gPDwgOCB8IHRoaXNbUyArIDJdIDw8IDE2IHwgdGhpc1tTICsgM10gPDwgMjQ7XG4gICAgfSwgYS5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbihTLCBUKSB7XG4gICAgICByZXR1cm4gUyA9IFMgPj4+IDAsIFQgfHwgTChTLCA0LCB0aGlzLmxlbmd0aCksIHRoaXNbU10gPDwgMjQgfCB0aGlzW1MgKyAxXSA8PCAxNiB8IHRoaXNbUyArIDJdIDw8IDggfCB0aGlzW1MgKyAzXTtcbiAgICB9LCBhLnByb3RvdHlwZS5yZWFkQmlnSW50NjRMRSA9IGl0KGZ1bmN0aW9uKFMpIHtcbiAgICAgIFMgPSBTID4+PiAwLCBfZShTLCBcIm9mZnNldFwiKTtcbiAgICAgIGNvbnN0IFQgPSB0aGlzW1NdLCBHID0gdGhpc1tTICsgN107XG4gICAgICAoVCA9PT0gdm9pZCAwIHx8IEcgPT09IHZvaWQgMCkgJiYgeGUoUywgdGhpcy5sZW5ndGggLSA4KTtcbiAgICAgIGNvbnN0IFogPSB0aGlzW1MgKyA0XSArIHRoaXNbUyArIDVdICogMiAqKiA4ICsgdGhpc1tTICsgNl0gKiAyICoqIDE2ICsgKEcgPDwgMjQpO1xuICAgICAgcmV0dXJuIChCaWdJbnQoWikgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQoVCArIHRoaXNbKytTXSAqIDIgKiogOCArIHRoaXNbKytTXSAqIDIgKiogMTYgKyB0aGlzWysrU10gKiAyICoqIDI0KTtcbiAgICB9KSwgYS5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUgPSBpdChmdW5jdGlvbihTKSB7XG4gICAgICBTID0gUyA+Pj4gMCwgX2UoUywgXCJvZmZzZXRcIik7XG4gICAgICBjb25zdCBUID0gdGhpc1tTXSwgRyA9IHRoaXNbUyArIDddO1xuICAgICAgKFQgPT09IHZvaWQgMCB8fCBHID09PSB2b2lkIDApICYmIHhlKFMsIHRoaXMubGVuZ3RoIC0gOCk7XG4gICAgICBjb25zdCBaID0gKFQgPDwgMjQpICsgLy8gT3ZlcmZsb3dcbiAgICAgIHRoaXNbKytTXSAqIDIgKiogMTYgKyB0aGlzWysrU10gKiAyICoqIDggKyB0aGlzWysrU107XG4gICAgICByZXR1cm4gKEJpZ0ludChaKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludCh0aGlzWysrU10gKiAyICoqIDI0ICsgdGhpc1srK1NdICogMiAqKiAxNiArIHRoaXNbKytTXSAqIDIgKiogOCArIEcpO1xuICAgIH0pLCBhLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uKFMsIFQpIHtcbiAgICAgIHJldHVybiBTID0gUyA+Pj4gMCwgVCB8fCBMKFMsIDQsIHRoaXMubGVuZ3RoKSwgdC5yZWFkKHRoaXMsIFMsICEwLCAyMywgNCk7XG4gICAgfSwgYS5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbihTLCBUKSB7XG4gICAgICByZXR1cm4gUyA9IFMgPj4+IDAsIFQgfHwgTChTLCA0LCB0aGlzLmxlbmd0aCksIHQucmVhZCh0aGlzLCBTLCAhMSwgMjMsIDQpO1xuICAgIH0sIGEucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uKFMsIFQpIHtcbiAgICAgIHJldHVybiBTID0gUyA+Pj4gMCwgVCB8fCBMKFMsIDgsIHRoaXMubGVuZ3RoKSwgdC5yZWFkKHRoaXMsIFMsICEwLCA1MiwgOCk7XG4gICAgfSwgYS5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24oUywgVCkge1xuICAgICAgcmV0dXJuIFMgPSBTID4+PiAwLCBUIHx8IEwoUywgOCwgdGhpcy5sZW5ndGgpLCB0LnJlYWQodGhpcywgUywgITEsIDUyLCA4KTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIG0oQiwgUywgVCwgRywgWiwgUSkge1xuICAgICAgaWYgKCFhLmlzQnVmZmVyKEIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKTtcbiAgICAgIGlmIChTID4gWiB8fCBTIDwgUSkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJyk7XG4gICAgICBpZiAoVCArIEcgPiBCLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgfVxuICAgIGEucHJvdG90eXBlLndyaXRlVWludExFID0gYS5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbihTLCBULCBHLCBaKSB7XG4gICAgICBpZiAoUyA9ICtTLCBUID0gVCA+Pj4gMCwgRyA9IEcgPj4+IDAsICFaKSB7XG4gICAgICAgIGNvbnN0IFVlID0gTWF0aC5wb3coMiwgOCAqIEcpIC0gMTtcbiAgICAgICAgbSh0aGlzLCBTLCBULCBHLCBVZSwgMCk7XG4gICAgICB9XG4gICAgICBsZXQgUSA9IDEsIHNlID0gMDtcbiAgICAgIGZvciAodGhpc1tUXSA9IFMgJiAyNTU7ICsrc2UgPCBHICYmIChRICo9IDI1Nik7IClcbiAgICAgICAgdGhpc1tUICsgc2VdID0gUyAvIFEgJiAyNTU7XG4gICAgICByZXR1cm4gVCArIEc7XG4gICAgfSwgYS5wcm90b3R5cGUud3JpdGVVaW50QkUgPSBhLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uKFMsIFQsIEcsIFopIHtcbiAgICAgIGlmIChTID0gK1MsIFQgPSBUID4+PiAwLCBHID0gRyA+Pj4gMCwgIVopIHtcbiAgICAgICAgY29uc3QgVWUgPSBNYXRoLnBvdygyLCA4ICogRykgLSAxO1xuICAgICAgICBtKHRoaXMsIFMsIFQsIEcsIFVlLCAwKTtcbiAgICAgIH1cbiAgICAgIGxldCBRID0gRyAtIDEsIHNlID0gMTtcbiAgICAgIGZvciAodGhpc1tUICsgUV0gPSBTICYgMjU1OyAtLVEgPj0gMCAmJiAoc2UgKj0gMjU2KTsgKVxuICAgICAgICB0aGlzW1QgKyBRXSA9IFMgLyBzZSAmIDI1NTtcbiAgICAgIHJldHVybiBUICsgRztcbiAgICB9LCBhLnByb3RvdHlwZS53cml0ZVVpbnQ4ID0gYS5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uKFMsIFQsIEcpIHtcbiAgICAgIHJldHVybiBTID0gK1MsIFQgPSBUID4+PiAwLCBHIHx8IG0odGhpcywgUywgVCwgMSwgMjU1LCAwKSwgdGhpc1tUXSA9IFMgJiAyNTUsIFQgKyAxO1xuICAgIH0sIGEucHJvdG90eXBlLndyaXRlVWludDE2TEUgPSBhLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24oUywgVCwgRykge1xuICAgICAgcmV0dXJuIFMgPSArUywgVCA9IFQgPj4+IDAsIEcgfHwgbSh0aGlzLCBTLCBULCAyLCA2NTUzNSwgMCksIHRoaXNbVF0gPSBTICYgMjU1LCB0aGlzW1QgKyAxXSA9IFMgPj4+IDgsIFQgKyAyO1xuICAgIH0sIGEucHJvdG90eXBlLndyaXRlVWludDE2QkUgPSBhLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24oUywgVCwgRykge1xuICAgICAgcmV0dXJuIFMgPSArUywgVCA9IFQgPj4+IDAsIEcgfHwgbSh0aGlzLCBTLCBULCAyLCA2NTUzNSwgMCksIHRoaXNbVF0gPSBTID4+PiA4LCB0aGlzW1QgKyAxXSA9IFMgJiAyNTUsIFQgKyAyO1xuICAgIH0sIGEucHJvdG90eXBlLndyaXRlVWludDMyTEUgPSBhLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24oUywgVCwgRykge1xuICAgICAgcmV0dXJuIFMgPSArUywgVCA9IFQgPj4+IDAsIEcgfHwgbSh0aGlzLCBTLCBULCA0LCA0Mjk0OTY3Mjk1LCAwKSwgdGhpc1tUICsgM10gPSBTID4+PiAyNCwgdGhpc1tUICsgMl0gPSBTID4+PiAxNiwgdGhpc1tUICsgMV0gPSBTID4+PiA4LCB0aGlzW1RdID0gUyAmIDI1NSwgVCArIDQ7XG4gICAgfSwgYS5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9IGEucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbihTLCBULCBHKSB7XG4gICAgICByZXR1cm4gUyA9ICtTLCBUID0gVCA+Pj4gMCwgRyB8fCBtKHRoaXMsIFMsIFQsIDQsIDQyOTQ5NjcyOTUsIDApLCB0aGlzW1RdID0gUyA+Pj4gMjQsIHRoaXNbVCArIDFdID0gUyA+Pj4gMTYsIHRoaXNbVCArIDJdID0gUyA+Pj4gOCwgdGhpc1tUICsgM10gPSBTICYgMjU1LCBUICsgNDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHYoQiwgUywgVCwgRywgWikge1xuICAgICAgemUoUywgRywgWiwgQiwgVCwgNyk7XG4gICAgICBsZXQgUSA9IE51bWJlcihTICYgQmlnSW50KDQyOTQ5NjcyOTUpKTtcbiAgICAgIEJbVCsrXSA9IFEsIFEgPSBRID4+IDgsIEJbVCsrXSA9IFEsIFEgPSBRID4+IDgsIEJbVCsrXSA9IFEsIFEgPSBRID4+IDgsIEJbVCsrXSA9IFE7XG4gICAgICBsZXQgc2UgPSBOdW1iZXIoUyA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDQyOTQ5NjcyOTUpKTtcbiAgICAgIHJldHVybiBCW1QrK10gPSBzZSwgc2UgPSBzZSA+PiA4LCBCW1QrK10gPSBzZSwgc2UgPSBzZSA+PiA4LCBCW1QrK10gPSBzZSwgc2UgPSBzZSA+PiA4LCBCW1QrK10gPSBzZSwgVDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUChCLCBTLCBULCBHLCBaKSB7XG4gICAgICB6ZShTLCBHLCBaLCBCLCBULCA3KTtcbiAgICAgIGxldCBRID0gTnVtYmVyKFMgJiBCaWdJbnQoNDI5NDk2NzI5NSkpO1xuICAgICAgQltUICsgN10gPSBRLCBRID0gUSA+PiA4LCBCW1QgKyA2XSA9IFEsIFEgPSBRID4+IDgsIEJbVCArIDVdID0gUSwgUSA9IFEgPj4gOCwgQltUICsgNF0gPSBRO1xuICAgICAgbGV0IHNlID0gTnVtYmVyKFMgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCg0Mjk0OTY3Mjk1KSk7XG4gICAgICByZXR1cm4gQltUICsgM10gPSBzZSwgc2UgPSBzZSA+PiA4LCBCW1QgKyAyXSA9IHNlLCBzZSA9IHNlID4+IDgsIEJbVCArIDFdID0gc2UsIHNlID0gc2UgPj4gOCwgQltUXSA9IHNlLCBUICsgODtcbiAgICB9XG4gICAgYS5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGl0KGZ1bmN0aW9uKFMsIFQgPSAwKSB7XG4gICAgICByZXR1cm4gdih0aGlzLCBTLCBULCBCaWdJbnQoMCksIEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZlwiKSk7XG4gICAgfSksIGEucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUgPSBpdChmdW5jdGlvbihTLCBUID0gMCkge1xuICAgICAgcmV0dXJuIFAodGhpcywgUywgVCwgQmlnSW50KDApLCBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZcIikpO1xuICAgIH0pLCBhLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24oUywgVCwgRywgWikge1xuICAgICAgaWYgKFMgPSArUywgVCA9IFQgPj4+IDAsICFaKSB7XG4gICAgICAgIGNvbnN0IFBlID0gTWF0aC5wb3coMiwgOCAqIEcgLSAxKTtcbiAgICAgICAgbSh0aGlzLCBTLCBULCBHLCBQZSAtIDEsIC1QZSk7XG4gICAgICB9XG4gICAgICBsZXQgUSA9IDAsIHNlID0gMSwgVWUgPSAwO1xuICAgICAgZm9yICh0aGlzW1RdID0gUyAmIDI1NTsgKytRIDwgRyAmJiAoc2UgKj0gMjU2KTsgKVxuICAgICAgICBTIDwgMCAmJiBVZSA9PT0gMCAmJiB0aGlzW1QgKyBRIC0gMV0gIT09IDAgJiYgKFVlID0gMSksIHRoaXNbVCArIFFdID0gKFMgLyBzZSA+PiAwKSAtIFVlICYgMjU1O1xuICAgICAgcmV0dXJuIFQgKyBHO1xuICAgIH0sIGEucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbihTLCBULCBHLCBaKSB7XG4gICAgICBpZiAoUyA9ICtTLCBUID0gVCA+Pj4gMCwgIVopIHtcbiAgICAgICAgY29uc3QgUGUgPSBNYXRoLnBvdygyLCA4ICogRyAtIDEpO1xuICAgICAgICBtKHRoaXMsIFMsIFQsIEcsIFBlIC0gMSwgLVBlKTtcbiAgICAgIH1cbiAgICAgIGxldCBRID0gRyAtIDEsIHNlID0gMSwgVWUgPSAwO1xuICAgICAgZm9yICh0aGlzW1QgKyBRXSA9IFMgJiAyNTU7IC0tUSA+PSAwICYmIChzZSAqPSAyNTYpOyApXG4gICAgICAgIFMgPCAwICYmIFVlID09PSAwICYmIHRoaXNbVCArIFEgKyAxXSAhPT0gMCAmJiAoVWUgPSAxKSwgdGhpc1tUICsgUV0gPSAoUyAvIHNlID4+IDApIC0gVWUgJiAyNTU7XG4gICAgICByZXR1cm4gVCArIEc7XG4gICAgfSwgYS5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24oUywgVCwgRykge1xuICAgICAgcmV0dXJuIFMgPSArUywgVCA9IFQgPj4+IDAsIEcgfHwgbSh0aGlzLCBTLCBULCAxLCAxMjcsIC0xMjgpLCBTIDwgMCAmJiAoUyA9IDI1NSArIFMgKyAxKSwgdGhpc1tUXSA9IFMgJiAyNTUsIFQgKyAxO1xuICAgIH0sIGEucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uKFMsIFQsIEcpIHtcbiAgICAgIHJldHVybiBTID0gK1MsIFQgPSBUID4+PiAwLCBHIHx8IG0odGhpcywgUywgVCwgMiwgMzI3NjcsIC0zMjc2OCksIHRoaXNbVF0gPSBTICYgMjU1LCB0aGlzW1QgKyAxXSA9IFMgPj4+IDgsIFQgKyAyO1xuICAgIH0sIGEucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uKFMsIFQsIEcpIHtcbiAgICAgIHJldHVybiBTID0gK1MsIFQgPSBUID4+PiAwLCBHIHx8IG0odGhpcywgUywgVCwgMiwgMzI3NjcsIC0zMjc2OCksIHRoaXNbVF0gPSBTID4+PiA4LCB0aGlzW1QgKyAxXSA9IFMgJiAyNTUsIFQgKyAyO1xuICAgIH0sIGEucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uKFMsIFQsIEcpIHtcbiAgICAgIHJldHVybiBTID0gK1MsIFQgPSBUID4+PiAwLCBHIHx8IG0odGhpcywgUywgVCwgNCwgMjE0NzQ4MzY0NywgLTIxNDc0ODM2NDgpLCB0aGlzW1RdID0gUyAmIDI1NSwgdGhpc1tUICsgMV0gPSBTID4+PiA4LCB0aGlzW1QgKyAyXSA9IFMgPj4+IDE2LCB0aGlzW1QgKyAzXSA9IFMgPj4+IDI0LCBUICsgNDtcbiAgICB9LCBhLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbihTLCBULCBHKSB7XG4gICAgICByZXR1cm4gUyA9ICtTLCBUID0gVCA+Pj4gMCwgRyB8fCBtKHRoaXMsIFMsIFQsIDQsIDIxNDc0ODM2NDcsIC0yMTQ3NDgzNjQ4KSwgUyA8IDAgJiYgKFMgPSA0Mjk0OTY3Mjk1ICsgUyArIDEpLCB0aGlzW1RdID0gUyA+Pj4gMjQsIHRoaXNbVCArIDFdID0gUyA+Pj4gMTYsIHRoaXNbVCArIDJdID0gUyA+Pj4gOCwgdGhpc1tUICsgM10gPSBTICYgMjU1LCBUICsgNDtcbiAgICB9LCBhLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUgPSBpdChmdW5jdGlvbihTLCBUID0gMCkge1xuICAgICAgcmV0dXJuIHYodGhpcywgUywgVCwgLUJpZ0ludChcIjB4ODAwMDAwMDAwMDAwMDAwMFwiKSwgQmlnSW50KFwiMHg3ZmZmZmZmZmZmZmZmZmZmXCIpKTtcbiAgICB9KSwgYS5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFID0gaXQoZnVuY3Rpb24oUywgVCA9IDApIHtcbiAgICAgIHJldHVybiBQKHRoaXMsIFMsIFQsIC1CaWdJbnQoXCIweDgwMDAwMDAwMDAwMDAwMDBcIiksIEJpZ0ludChcIjB4N2ZmZmZmZmZmZmZmZmZmZlwiKSk7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gTihCLCBTLCBULCBHLCBaLCBRKSB7XG4gICAgICBpZiAoVCArIEcgPiBCLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICBpZiAoVCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBZKEIsIFMsIFQsIEcsIFopIHtcbiAgICAgIHJldHVybiBTID0gK1MsIFQgPSBUID4+PiAwLCBaIHx8IE4oQiwgUywgVCwgNCksIHQud3JpdGUoQiwgUywgVCwgRywgMjMsIDQpLCBUICsgNDtcbiAgICB9XG4gICAgYS5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24oUywgVCwgRykge1xuICAgICAgcmV0dXJuIFkodGhpcywgUywgVCwgITAsIEcpO1xuICAgIH0sIGEucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uKFMsIFQsIEcpIHtcbiAgICAgIHJldHVybiBZKHRoaXMsIFMsIFQsICExLCBHKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGVlKEIsIFMsIFQsIEcsIFopIHtcbiAgICAgIHJldHVybiBTID0gK1MsIFQgPSBUID4+PiAwLCBaIHx8IE4oQiwgUywgVCwgOCksIHQud3JpdGUoQiwgUywgVCwgRywgNTIsIDgpLCBUICsgODtcbiAgICB9XG4gICAgYS5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uKFMsIFQsIEcpIHtcbiAgICAgIHJldHVybiBlZSh0aGlzLCBTLCBULCAhMCwgRyk7XG4gICAgfSwgYS5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uKFMsIFQsIEcpIHtcbiAgICAgIHJldHVybiBlZSh0aGlzLCBTLCBULCAhMSwgRyk7XG4gICAgfSwgYS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKFMsIFQsIEcsIFopIHtcbiAgICAgIGlmICghYS5pc0J1ZmZlcihTKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcImFyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlclwiKTtcbiAgICAgIGlmIChHIHx8IChHID0gMCksICFaICYmIFogIT09IDAgJiYgKFogPSB0aGlzLmxlbmd0aCksIFQgPj0gUy5sZW5ndGggJiYgKFQgPSBTLmxlbmd0aCksIFQgfHwgKFQgPSAwKSwgWiA+IDAgJiYgWiA8IEcgJiYgKFogPSBHKSwgWiA9PT0gRyB8fCBTLmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDA7XG4gICAgICBpZiAoVCA8IDApXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwidGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgIGlmIChHIDwgMCB8fCBHID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGlmIChaIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kc1wiKTtcbiAgICAgIFogPiB0aGlzLmxlbmd0aCAmJiAoWiA9IHRoaXMubGVuZ3RoKSwgUy5sZW5ndGggLSBUIDwgWiAtIEcgJiYgKFogPSBTLmxlbmd0aCAtIFQgKyBHKTtcbiAgICAgIGNvbnN0IFEgPSBaIC0gRztcbiAgICAgIHJldHVybiB0aGlzID09PSBTICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09IFwiZnVuY3Rpb25cIiA/IHRoaXMuY29weVdpdGhpbihULCBHLCBaKSA6IFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgICBTLFxuICAgICAgICB0aGlzLnN1YmFycmF5KEcsIFopLFxuICAgICAgICBUXG4gICAgICApLCBRO1xuICAgIH0sIGEucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbihTLCBULCBHLCBaKSB7XG4gICAgICBpZiAodHlwZW9mIFMgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAodHlwZW9mIFQgPT0gXCJzdHJpbmdcIiA/IChaID0gVCwgVCA9IDAsIEcgPSB0aGlzLmxlbmd0aCkgOiB0eXBlb2YgRyA9PSBcInN0cmluZ1wiICYmIChaID0gRywgRyA9IHRoaXMubGVuZ3RoKSwgWiAhPT0gdm9pZCAwICYmIHR5cGVvZiBaICE9IFwic3RyaW5nXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImVuY29kaW5nIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIGlmICh0eXBlb2YgWiA9PSBcInN0cmluZ1wiICYmICFhLmlzRW5jb2RpbmcoWikpXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiICsgWik7XG4gICAgICAgIGlmIChTLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGNvbnN0IHNlID0gUy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgIChaID09PSBcInV0ZjhcIiAmJiBzZSA8IDEyOCB8fCBaID09PSBcImxhdGluMVwiKSAmJiAoUyA9IHNlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHR5cGVvZiBTID09IFwibnVtYmVyXCIgPyBTID0gUyAmIDI1NSA6IHR5cGVvZiBTID09IFwiYm9vbGVhblwiICYmIChTID0gTnVtYmVyKFMpKTtcbiAgICAgIGlmIChUIDwgMCB8fCB0aGlzLmxlbmd0aCA8IFQgfHwgdGhpcy5sZW5ndGggPCBHKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk91dCBvZiByYW5nZSBpbmRleFwiKTtcbiAgICAgIGlmIChHIDw9IFQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgVCA9IFQgPj4+IDAsIEcgPSBHID09PSB2b2lkIDAgPyB0aGlzLmxlbmd0aCA6IEcgPj4+IDAsIFMgfHwgKFMgPSAwKTtcbiAgICAgIGxldCBRO1xuICAgICAgaWYgKHR5cGVvZiBTID09IFwibnVtYmVyXCIpXG4gICAgICAgIGZvciAoUSA9IFQ7IFEgPCBHOyArK1EpXG4gICAgICAgICAgdGhpc1tRXSA9IFM7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qgc2UgPSBhLmlzQnVmZmVyKFMpID8gUyA6IGEuZnJvbShTLCBaKSwgVWUgPSBzZS5sZW5ndGg7XG4gICAgICAgIGlmIChVZSA9PT0gMClcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgUyArICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKTtcbiAgICAgICAgZm9yIChRID0gMDsgUSA8IEcgLSBUOyArK1EpXG4gICAgICAgICAgdGhpc1tRICsgVF0gPSBzZVtRICUgVWVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBjb25zdCBpZSA9IHt9O1xuICAgIGZ1bmN0aW9uIGxlKEIsIFMsIFQpIHtcbiAgICAgIGllW0JdID0gY2xhc3MgZXh0ZW5kcyBUIHtcbiAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgc3VwZXIoKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibWVzc2FnZVwiLCB7XG4gICAgICAgICAgICB2YWx1ZTogUy5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgICAgIH0pLCB0aGlzLm5hbWUgPSBgJHt0aGlzLm5hbWV9IFske0J9XWAsIHRoaXMuc3RhY2ssIGRlbGV0ZSB0aGlzLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGNvZGUoKSB7XG4gICAgICAgICAgcmV0dXJuIEI7XG4gICAgICAgIH1cbiAgICAgICAgc2V0IGNvZGUoWikge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgICAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgICAgICAgdmFsdWU6IFosXG4gICAgICAgICAgICB3cml0YWJsZTogITBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtCfV06ICR7dGhpcy5tZXNzYWdlfWA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGxlKFxuICAgICAgXCJFUlJfQlVGRkVSX09VVF9PRl9CT1VORFNcIixcbiAgICAgIGZ1bmN0aW9uKEIpIHtcbiAgICAgICAgcmV0dXJuIEIgPyBgJHtCfSBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNgIDogXCJBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzXCI7XG4gICAgICB9LFxuICAgICAgUmFuZ2VFcnJvclxuICAgICksIGxlKFxuICAgICAgXCJFUlJfSU5WQUxJRF9BUkdfVFlQRVwiLFxuICAgICAgZnVuY3Rpb24oQiwgUykge1xuICAgICAgICByZXR1cm4gYFRoZSBcIiR7Qn1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIFN9YDtcbiAgICAgIH0sXG4gICAgICBUeXBlRXJyb3JcbiAgICApLCBsZShcbiAgICAgIFwiRVJSX09VVF9PRl9SQU5HRVwiLFxuICAgICAgZnVuY3Rpb24oQiwgUywgVCkge1xuICAgICAgICBsZXQgRyA9IGBUaGUgdmFsdWUgb2YgXCIke0J9XCIgaXMgb3V0IG9mIHJhbmdlLmAsIFogPSBUO1xuICAgICAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihUKSAmJiBNYXRoLmFicyhUKSA+IDIgKiogMzIgPyBaID0gVGUoU3RyaW5nKFQpKSA6IHR5cGVvZiBUID09IFwiYmlnaW50XCIgJiYgKFogPSBTdHJpbmcoVCksIChUID4gQmlnSW50KDIpICoqIEJpZ0ludCgzMikgfHwgVCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSAmJiAoWiA9IFRlKFopKSwgWiArPSBcIm5cIiksIEcgKz0gYCBJdCBtdXN0IGJlICR7U30uIFJlY2VpdmVkICR7Wn1gLCBHO1xuICAgICAgfSxcbiAgICAgIFJhbmdlRXJyb3JcbiAgICApO1xuICAgIGZ1bmN0aW9uIFRlKEIpIHtcbiAgICAgIGxldCBTID0gXCJcIiwgVCA9IEIubGVuZ3RoO1xuICAgICAgY29uc3QgRyA9IEJbMF0gPT09IFwiLVwiID8gMSA6IDA7XG4gICAgICBmb3IgKDsgVCA+PSBHICsgNDsgVCAtPSAzKVxuICAgICAgICBTID0gYF8ke0Iuc2xpY2UoVCAtIDMsIFQpfSR7U31gO1xuICAgICAgcmV0dXJuIGAke0Iuc2xpY2UoMCwgVCl9JHtTfWA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIERlKEIsIFMsIFQpIHtcbiAgICAgIF9lKFMsIFwib2Zmc2V0XCIpLCAoQltTXSA9PT0gdm9pZCAwIHx8IEJbUyArIFRdID09PSB2b2lkIDApICYmIHhlKFMsIEIubGVuZ3RoIC0gKFQgKyAxKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHplKEIsIFMsIFQsIEcsIFosIFEpIHtcbiAgICAgIGlmIChCID4gVCB8fCBCIDwgUykge1xuICAgICAgICBjb25zdCBzZSA9IHR5cGVvZiBTID09IFwiYmlnaW50XCIgPyBcIm5cIiA6IFwiXCI7XG4gICAgICAgIGxldCBVZTtcbiAgICAgICAgdGhyb3cgUyA9PT0gMCB8fCBTID09PSBCaWdJbnQoMCkgPyBVZSA9IGA+PSAwJHtzZX0gYW5kIDwgMiR7c2V9ICoqICR7KFEgKyAxKSAqIDh9JHtzZX1gIDogVWUgPSBgPj0gLSgyJHtzZX0gKiogJHsoUSArIDEpICogOCAtIDF9JHtzZX0pIGFuZCA8IDIgKiogJHsoUSArIDEpICogOCAtIDF9JHtzZX1gLCBuZXcgaWUuRVJSX09VVF9PRl9SQU5HRShcInZhbHVlXCIsIFVlLCBCKTtcbiAgICAgIH1cbiAgICAgIERlKEcsIFosIFEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBfZShCLCBTKSB7XG4gICAgICBpZiAodHlwZW9mIEIgIT0gXCJudW1iZXJcIilcbiAgICAgICAgdGhyb3cgbmV3IGllLkVSUl9JTlZBTElEX0FSR19UWVBFKFMsIFwibnVtYmVyXCIsIEIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB4ZShCLCBTLCBUKSB7XG4gICAgICB0aHJvdyBNYXRoLmZsb29yKEIpICE9PSBCID8gKF9lKEIsIFQpLCBuZXcgaWUuRVJSX09VVF9PRl9SQU5HRShcIm9mZnNldFwiLCBcImFuIGludGVnZXJcIiwgQikpIDogUyA8IDAgPyBuZXcgaWUuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKCkgOiBuZXcgaWUuRVJSX09VVF9PRl9SQU5HRShcbiAgICAgICAgXCJvZmZzZXRcIixcbiAgICAgICAgYD49IDAgYW5kIDw9ICR7U31gLFxuICAgICAgICBCXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBCZSA9IC9bXisvMC05QS1aYS16LV9dL2c7XG4gICAgZnVuY3Rpb24geWUoQikge1xuICAgICAgaWYgKEIgPSBCLnNwbGl0KFwiPVwiKVswXSwgQiA9IEIudHJpbSgpLnJlcGxhY2UoQmUsIFwiXCIpLCBCLmxlbmd0aCA8IDIpIHJldHVybiBcIlwiO1xuICAgICAgZm9yICg7IEIubGVuZ3RoICUgNCAhPT0gMDsgKVxuICAgICAgICBCID0gQiArIFwiPVwiO1xuICAgICAgcmV0dXJuIEI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGJlKEIsIFMpIHtcbiAgICAgIFMgPSBTIHx8IDEgLyAwO1xuICAgICAgbGV0IFQ7XG4gICAgICBjb25zdCBHID0gQi5sZW5ndGg7XG4gICAgICBsZXQgWiA9IG51bGw7XG4gICAgICBjb25zdCBRID0gW107XG4gICAgICBmb3IgKGxldCBzZSA9IDA7IHNlIDwgRzsgKytzZSkge1xuICAgICAgICBpZiAoVCA9IEIuY2hhckNvZGVBdChzZSksIFQgPiA1NTI5NSAmJiBUIDwgNTczNDQpIHtcbiAgICAgICAgICBpZiAoIVopIHtcbiAgICAgICAgICAgIGlmIChUID4gNTYzMTkpIHtcbiAgICAgICAgICAgICAgKFMgLT0gMykgPiAtMSAmJiBRLnB1c2goMjM5LCAxOTEsIDE4OSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzZSArIDEgPT09IEcpIHtcbiAgICAgICAgICAgICAgKFMgLT0gMykgPiAtMSAmJiBRLnB1c2goMjM5LCAxOTEsIDE4OSk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgWiA9IFQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFQgPCA1NjMyMCkge1xuICAgICAgICAgICAgKFMgLT0gMykgPiAtMSAmJiBRLnB1c2goMjM5LCAxOTEsIDE4OSksIFogPSBUO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIFQgPSAoWiAtIDU1Mjk2IDw8IDEwIHwgVCAtIDU2MzIwKSArIDY1NTM2O1xuICAgICAgICB9IGVsc2UgWiAmJiAoUyAtPSAzKSA+IC0xICYmIFEucHVzaCgyMzksIDE5MSwgMTg5KTtcbiAgICAgICAgaWYgKFogPSBudWxsLCBUIDwgMTI4KSB7XG4gICAgICAgICAgaWYgKChTIC09IDEpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgUS5wdXNoKFQpO1xuICAgICAgICB9IGVsc2UgaWYgKFQgPCAyMDQ4KSB7XG4gICAgICAgICAgaWYgKChTIC09IDIpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgUS5wdXNoKFxuICAgICAgICAgICAgVCA+PiA2IHwgMTkyLFxuICAgICAgICAgICAgVCAmIDYzIHwgMTI4XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChUIDwgNjU1MzYpIHtcbiAgICAgICAgICBpZiAoKFMgLT0gMykgPCAwKSBicmVhaztcbiAgICAgICAgICBRLnB1c2goXG4gICAgICAgICAgICBUID4+IDEyIHwgMjI0LFxuICAgICAgICAgICAgVCA+PiA2ICYgNjMgfCAxMjgsXG4gICAgICAgICAgICBUICYgNjMgfCAxMjhcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKFQgPCAxMTE0MTEyKSB7XG4gICAgICAgICAgaWYgKChTIC09IDQpIDwgMCkgYnJlYWs7XG4gICAgICAgICAgUS5wdXNoKFxuICAgICAgICAgICAgVCA+PiAxOCB8IDI0MCxcbiAgICAgICAgICAgIFQgPj4gMTIgJiA2MyB8IDEyOCxcbiAgICAgICAgICAgIFQgPj4gNiAmIDYzIHwgMTI4LFxuICAgICAgICAgICAgVCAmIDYzIHwgMTI4XG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50XCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIEZlKEIpIHtcbiAgICAgIGNvbnN0IFMgPSBbXTtcbiAgICAgIGZvciAobGV0IFQgPSAwOyBUIDwgQi5sZW5ndGg7ICsrVClcbiAgICAgICAgUy5wdXNoKEIuY2hhckNvZGVBdChUKSAmIDI1NSk7XG4gICAgICByZXR1cm4gUztcbiAgICB9XG4gICAgZnVuY3Rpb24gWGUoQiwgUykge1xuICAgICAgbGV0IFQsIEcsIFo7XG4gICAgICBjb25zdCBRID0gW107XG4gICAgICBmb3IgKGxldCBzZSA9IDA7IHNlIDwgQi5sZW5ndGggJiYgISgoUyAtPSAyKSA8IDApOyArK3NlKVxuICAgICAgICBUID0gQi5jaGFyQ29kZUF0KHNlKSwgRyA9IFQgPj4gOCwgWiA9IFQgJSAyNTYsIFEucHVzaChaKSwgUS5wdXNoKEcpO1xuICAgICAgcmV0dXJuIFE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHdlKEIpIHtcbiAgICAgIHJldHVybiBlLnRvQnl0ZUFycmF5KHllKEIpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gTmUoQiwgUywgVCwgRykge1xuICAgICAgbGV0IFo7XG4gICAgICBmb3IgKFogPSAwOyBaIDwgRyAmJiAhKFogKyBUID49IFMubGVuZ3RoIHx8IFogPj0gQi5sZW5ndGgpOyArK1opXG4gICAgICAgIFNbWiArIFRdID0gQltaXTtcbiAgICAgIHJldHVybiBaO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkdChCLCBTKSB7XG4gICAgICByZXR1cm4gQiBpbnN0YW5jZW9mIFMgfHwgQiAhPSBudWxsICYmIEIuY29uc3RydWN0b3IgIT0gbnVsbCAmJiBCLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJiBCLmNvbnN0cnVjdG9yLm5hbWUgPT09IFMubmFtZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gSmUoQikge1xuICAgICAgcmV0dXJuIEIgIT09IEI7XG4gICAgfVxuICAgIGNvbnN0IFFlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgQiA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiLCBTID0gbmV3IEFycmF5KDI1Nik7XG4gICAgICBmb3IgKGxldCBUID0gMDsgVCA8IDE2OyArK1QpIHtcbiAgICAgICAgY29uc3QgRyA9IFQgKiAxNjtcbiAgICAgICAgZm9yIChsZXQgWiA9IDA7IFogPCAxNjsgKytaKVxuICAgICAgICAgIFNbRyArIFpdID0gQltUXSArIEJbWl07XG4gICAgICB9XG4gICAgICByZXR1cm4gUztcbiAgICB9KSgpO1xuICAgIGZ1bmN0aW9uIGl0KEIpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgQmlnSW50ID4gXCJ1XCIgPyBqZSA6IEI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGplKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmlnSW50IG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICB9KShHYSkpLCBHYTtcbn1cbnZhciBIZSA9IEtjKCk7XG5jb25zdCBsbiA9IHR5cGVvZiBnbG9iYWxUaGlzID09IFwib2JqZWN0XCIgJiYgXCJjcnlwdG9cIiBpbiBnbG9iYWxUaGlzID8gZ2xvYmFsVGhpcy5jcnlwdG8gOiB2b2lkIDA7XG4vKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5mdW5jdGlvbiBJaShzKSB7XG4gIHJldHVybiBzIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcocykgJiYgcy5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIlVpbnQ4QXJyYXlcIjtcbn1cbmZ1bmN0aW9uIFhsKHMpIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihzKSB8fCBzIDwgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb3NpdGl2ZSBpbnRlZ2VyIGV4cGVjdGVkLCBnb3QgXCIgKyBzKTtcbn1cbmZ1bmN0aW9uIFFzKHMsIC4uLmUpIHtcbiAgaWYgKCFJaShzKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGV4cGVjdGVkXCIpO1xuICBpZiAoZS5sZW5ndGggPiAwICYmICFlLmluY2x1ZGVzKHMubGVuZ3RoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVaW50OEFycmF5IGV4cGVjdGVkIG9mIGxlbmd0aCBcIiArIGUgKyBcIiwgZ290IGxlbmd0aD1cIiArIHMubGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIEhmKHMpIHtcbiAgaWYgKHR5cGVvZiBzICE9IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2Ygcy5jcmVhdGUgIT0gXCJmdW5jdGlvblwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkhhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMuY3JlYXRlSGFzaGVyXCIpO1xuICBYbChzLm91dHB1dExlbiksIFhsKHMuYmxvY2tMZW4pO1xufVxuZnVuY3Rpb24gRG8ocywgZSA9ICEwKSB7XG4gIGlmIChzLmRlc3Ryb3llZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZFwiKTtcbiAgaWYgKGUgJiYgcy5maW5pc2hlZClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkXCIpO1xufVxuZnVuY3Rpb24gTzEocywgZSkge1xuICBRcyhzKTtcbiAgY29uc3QgdCA9IGUub3V0cHV0TGVuO1xuICBpZiAocy5sZW5ndGggPCB0KVxuICAgIHRocm93IG5ldyBFcnJvcihcImRpZ2VzdEludG8oKSBleHBlY3RzIG91dHB1dCBidWZmZXIgb2YgbGVuZ3RoIGF0IGxlYXN0IFwiICsgdCk7XG59XG5mdW5jdGlvbiBrbiguLi5zKSB7XG4gIGZvciAobGV0IGUgPSAwOyBlIDwgcy5sZW5ndGg7IGUrKylcbiAgICBzW2VdLmZpbGwoMCk7XG59XG5mdW5jdGlvbiBWYShzKSB7XG4gIHJldHVybiBuZXcgRGF0YVZpZXcocy5idWZmZXIsIHMuYnl0ZU9mZnNldCwgcy5ieXRlTGVuZ3RoKTtcbn1cbmZ1bmN0aW9uIE5yKHMsIGUpIHtcbiAgcmV0dXJuIHMgPDwgMzIgLSBlIHwgcyA+Pj4gZTtcbn1cbmNvbnN0IHFmID0gLyogQHRzLWlnbm9yZSAqLyB0eXBlb2YgVWludDhBcnJheS5mcm9tKFtdKS50b0hleCA9PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFVpbnQ4QXJyYXkuZnJvbUhleCA9PSBcImZ1bmN0aW9uXCIsIEIxID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAocywgZSkgPT4gZS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKTtcbmZ1bmN0aW9uIEhzKHMpIHtcbiAgaWYgKFFzKHMpLCBxZilcbiAgICByZXR1cm4gcy50b0hleCgpO1xuICBsZXQgZSA9IFwiXCI7XG4gIGZvciAobGV0IHQgPSAwOyB0IDwgcy5sZW5ndGg7IHQrKylcbiAgICBlICs9IEIxW3NbdF1dO1xuICByZXR1cm4gZTtcbn1cbmNvbnN0IHJzID0geyBfMDogNDgsIF85OiA1NywgQTogNjUsIEY6IDcwLCBhOiA5NywgZjogMTAyIH07XG5mdW5jdGlvbiBjZChzKSB7XG4gIGlmIChzID49IHJzLl8wICYmIHMgPD0gcnMuXzkpXG4gICAgcmV0dXJuIHMgLSBycy5fMDtcbiAgaWYgKHMgPj0gcnMuQSAmJiBzIDw9IHJzLkYpXG4gICAgcmV0dXJuIHMgLSAocnMuQSAtIDEwKTtcbiAgaWYgKHMgPj0gcnMuYSAmJiBzIDw9IHJzLmYpXG4gICAgcmV0dXJuIHMgLSAocnMuYSAtIDEwKTtcbn1cbmZ1bmN0aW9uIFBvKHMpIHtcbiAgaWYgKHR5cGVvZiBzICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IFwiICsgdHlwZW9mIHMpO1xuICBpZiAocWYpXG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbUhleChzKTtcbiAgY29uc3QgZSA9IHMubGVuZ3RoLCB0ID0gZSAvIDI7XG4gIGlmIChlICUgMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCBcIiArIGUpO1xuICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkodCk7XG4gIGZvciAobGV0IG4gPSAwLCBpID0gMDsgbiA8IHQ7IG4rKywgaSArPSAyKSB7XG4gICAgY29uc3QgbyA9IGNkKHMuY2hhckNvZGVBdChpKSksIGEgPSBjZChzLmNoYXJDb2RlQXQoaSArIDEpKTtcbiAgICBpZiAobyA9PT0gdm9pZCAwIHx8IGEgPT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgbCA9IHNbaV0gKyBzW2kgKyAxXTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGwgKyAnXCIgYXQgaW5kZXggJyArIGkpO1xuICAgIH1cbiAgICByW25dID0gbyAqIDE2ICsgYTtcbiAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIEYxKHMpIHtcbiAgaWYgKHR5cGVvZiBzICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwic3RyaW5nIGV4cGVjdGVkXCIpO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHMpKTtcbn1cbmZ1bmN0aW9uIEhjKHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBzID09IFwic3RyaW5nXCIgJiYgKHMgPSBGMShzKSksIFFzKHMpLCBzO1xufVxuZnVuY3Rpb24gS3IoLi4ucykge1xuICBsZXQgZSA9IDA7XG4gIGZvciAobGV0IHIgPSAwOyByIDwgcy5sZW5ndGg7IHIrKykge1xuICAgIGNvbnN0IG4gPSBzW3JdO1xuICAgIFFzKG4pLCBlICs9IG4ubGVuZ3RoO1xuICB9XG4gIGNvbnN0IHQgPSBuZXcgVWludDhBcnJheShlKTtcbiAgZm9yIChsZXQgciA9IDAsIG4gPSAwOyByIDwgcy5sZW5ndGg7IHIrKykge1xuICAgIGNvbnN0IGkgPSBzW3JdO1xuICAgIHQuc2V0KGksIG4pLCBuICs9IGkubGVuZ3RoO1xuICB9XG4gIHJldHVybiB0O1xufVxuY2xhc3MgV2Yge1xufVxuZnVuY3Rpb24gemYocykge1xuICBjb25zdCBlID0gKHIpID0+IHMoKS51cGRhdGUoSGMocikpLmRpZ2VzdCgpLCB0ID0gcygpO1xuICByZXR1cm4gZS5vdXRwdXRMZW4gPSB0Lm91dHB1dExlbiwgZS5ibG9ja0xlbiA9IHQuYmxvY2tMZW4sIGUuY3JlYXRlID0gKCkgPT4gcygpLCBlO1xufVxuZnVuY3Rpb24gcWMocyA9IDMyKSB7XG4gIGlmIChsbiAmJiB0eXBlb2YgbG4uZ2V0UmFuZG9tVmFsdWVzID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gbG4uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KHMpKTtcbiAgaWYgKGxuICYmIHR5cGVvZiBsbi5yYW5kb21CeXRlcyA9PSBcImZ1bmN0aW9uXCIpXG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShsbi5yYW5kb21CeXRlcyhzKSk7XG4gIHRocm93IG5ldyBFcnJvcihcImNyeXB0by5nZXRSYW5kb21WYWx1ZXMgbXVzdCBiZSBkZWZpbmVkXCIpO1xufVxuZnVuY3Rpb24gTjEocywgZSwgdCwgcikge1xuICBpZiAodHlwZW9mIHMuc2V0QmlnVWludDY0ID09IFwiZnVuY3Rpb25cIilcbiAgICByZXR1cm4gcy5zZXRCaWdVaW50NjQoZSwgdCwgcik7XG4gIGNvbnN0IG4gPSBCaWdJbnQoMzIpLCBpID0gQmlnSW50KDQyOTQ5NjcyOTUpLCBvID0gTnVtYmVyKHQgPj4gbiAmIGkpLCBhID0gTnVtYmVyKHQgJiBpKSwgbCA9IHIgPyA0IDogMCwgYyA9IHIgPyAwIDogNDtcbiAgcy5zZXRVaW50MzIoZSArIGwsIG8sIHIpLCBzLnNldFVpbnQzMihlICsgYywgYSwgcik7XG59XG5mdW5jdGlvbiBVMShzLCBlLCB0KSB7XG4gIHJldHVybiBzICYgZSBeIH5zICYgdDtcbn1cbmZ1bmN0aW9uICQxKHMsIGUsIHQpIHtcbiAgcmV0dXJuIHMgJiBlIF4gcyAmIHQgXiBlICYgdDtcbn1cbmNsYXNzIFlmIGV4dGVuZHMgV2Yge1xuICBjb25zdHJ1Y3RvcihlLCB0LCByLCBuKSB7XG4gICAgc3VwZXIoKSwgdGhpcy5maW5pc2hlZCA9ICExLCB0aGlzLmxlbmd0aCA9IDAsIHRoaXMucG9zID0gMCwgdGhpcy5kZXN0cm95ZWQgPSAhMSwgdGhpcy5ibG9ja0xlbiA9IGUsIHRoaXMub3V0cHV0TGVuID0gdCwgdGhpcy5wYWRPZmZzZXQgPSByLCB0aGlzLmlzTEUgPSBuLCB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGUpLCB0aGlzLnZpZXcgPSBWYSh0aGlzLmJ1ZmZlcik7XG4gIH1cbiAgdXBkYXRlKGUpIHtcbiAgICBEbyh0aGlzKSwgZSA9IEhjKGUpLCBRcyhlKTtcbiAgICBjb25zdCB7IHZpZXc6IHQsIGJ1ZmZlcjogciwgYmxvY2tMZW46IG4gfSA9IHRoaXMsIGkgPSBlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IGk7ICkge1xuICAgICAgY29uc3QgYSA9IE1hdGgubWluKG4gLSB0aGlzLnBvcywgaSAtIG8pO1xuICAgICAgaWYgKGEgPT09IG4pIHtcbiAgICAgICAgY29uc3QgbCA9IFZhKGUpO1xuICAgICAgICBmb3IgKDsgbiA8PSBpIC0gbzsgbyArPSBuKVxuICAgICAgICAgIHRoaXMucHJvY2VzcyhsLCBvKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICByLnNldChlLnN1YmFycmF5KG8sIG8gKyBhKSwgdGhpcy5wb3MpLCB0aGlzLnBvcyArPSBhLCBvICs9IGEsIHRoaXMucG9zID09PSBuICYmICh0aGlzLnByb2Nlc3ModCwgMCksIHRoaXMucG9zID0gMCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmxlbmd0aCArPSBlLmxlbmd0aCwgdGhpcy5yb3VuZENsZWFuKCksIHRoaXM7XG4gIH1cbiAgZGlnZXN0SW50byhlKSB7XG4gICAgRG8odGhpcyksIE8xKGUsIHRoaXMpLCB0aGlzLmZpbmlzaGVkID0gITA7XG4gICAgY29uc3QgeyBidWZmZXI6IHQsIHZpZXc6IHIsIGJsb2NrTGVuOiBuLCBpc0xFOiBpIH0gPSB0aGlzO1xuICAgIGxldCB7IHBvczogbyB9ID0gdGhpcztcbiAgICB0W28rK10gPSAxMjgsIGtuKHRoaXMuYnVmZmVyLnN1YmFycmF5KG8pKSwgdGhpcy5wYWRPZmZzZXQgPiBuIC0gbyAmJiAodGhpcy5wcm9jZXNzKHIsIDApLCBvID0gMCk7XG4gICAgZm9yIChsZXQgZCA9IG87IGQgPCBuOyBkKyspXG4gICAgICB0W2RdID0gMDtcbiAgICBOMShyLCBuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGkpLCB0aGlzLnByb2Nlc3MociwgMCk7XG4gICAgY29uc3QgYSA9IFZhKGUpLCBsID0gdGhpcy5vdXRwdXRMZW47XG4gICAgaWYgKGwgJSA0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdFwiKTtcbiAgICBjb25zdCBjID0gbCAvIDQsIHUgPSB0aGlzLmdldCgpO1xuICAgIGlmIChjID4gdS5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlXCIpO1xuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgYzsgZCsrKVxuICAgICAgYS5zZXRVaW50MzIoNCAqIGQsIHVbZF0sIGkpO1xuICB9XG4gIGRpZ2VzdCgpIHtcbiAgICBjb25zdCB7IGJ1ZmZlcjogZSwgb3V0cHV0TGVuOiB0IH0gPSB0aGlzO1xuICAgIHRoaXMuZGlnZXN0SW50byhlKTtcbiAgICBjb25zdCByID0gZS5zbGljZSgwLCB0KTtcbiAgICByZXR1cm4gdGhpcy5kZXN0cm95KCksIHI7XG4gIH1cbiAgX2Nsb25lSW50byhlKSB7XG4gICAgZSB8fCAoZSA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpLCBlLnNldCguLi50aGlzLmdldCgpKTtcbiAgICBjb25zdCB7IGJsb2NrTGVuOiB0LCBidWZmZXI6IHIsIGxlbmd0aDogbiwgZmluaXNoZWQ6IGksIGRlc3Ryb3llZDogbywgcG9zOiBhIH0gPSB0aGlzO1xuICAgIHJldHVybiBlLmRlc3Ryb3llZCA9IG8sIGUuZmluaXNoZWQgPSBpLCBlLmxlbmd0aCA9IG4sIGUucG9zID0gYSwgbiAlIHQgJiYgZS5idWZmZXIuc2V0KHIpLCBlO1xuICB9XG4gIGNsb25lKCkge1xuICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgfVxufVxuY29uc3QgbXMgPSAvKiBAX19QVVJFX18gKi8gVWludDMyQXJyYXkuZnJvbShbXG4gIDE3NzkwMzM3MDMsXG4gIDMxNDQxMzQyNzcsXG4gIDEwMTM5MDQyNDIsXG4gIDI3NzM0ODA3NjIsXG4gIDEzNTk4OTMxMTksXG4gIDI2MDA4MjI5MjQsXG4gIDUyODczNDYzNSxcbiAgMTU0MTQ1OTIyNVxuXSksIFF0ID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAxNzc5MDMzNzAzLFxuICA0MDg5MjM1NzIwLFxuICAzMTQ0MTM0Mjc3LFxuICAyMjI3ODczNTk1LFxuICAxMDEzOTA0MjQyLFxuICA0MjcxMTc1NzIzLFxuICAyNzczNDgwNzYyLFxuICAxNTk1NzUwMTI5LFxuICAxMzU5ODkzMTE5LFxuICAyOTE3NTY1MTM3LFxuICAyNjAwODIyOTI0LFxuICA3MjU1MTExOTksXG4gIDUyODczNDYzNSxcbiAgNDIxNTM4OTU0NyxcbiAgMTU0MTQ1OTIyNSxcbiAgMzI3MDMzMjA5XG5dKSwgT2kgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIgKiogMzIgLSAxKSwgdWQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMyKTtcbmZ1bmN0aW9uIEcxKHMsIGUgPSAhMSkge1xuICByZXR1cm4gZSA/IHsgaDogTnVtYmVyKHMgJiBPaSksIGw6IE51bWJlcihzID4+IHVkICYgT2kpIH0gOiB7IGg6IE51bWJlcihzID4+IHVkICYgT2kpIHwgMCwgbDogTnVtYmVyKHMgJiBPaSkgfCAwIH07XG59XG5mdW5jdGlvbiBWMShzLCBlID0gITEpIHtcbiAgY29uc3QgdCA9IHMubGVuZ3RoO1xuICBsZXQgciA9IG5ldyBVaW50MzJBcnJheSh0KSwgbiA9IG5ldyBVaW50MzJBcnJheSh0KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0OyBpKyspIHtcbiAgICBjb25zdCB7IGg6IG8sIGw6IGEgfSA9IEcxKHNbaV0sIGUpO1xuICAgIFtyW2ldLCBuW2ldXSA9IFtvLCBhXTtcbiAgfVxuICByZXR1cm4gW3IsIG5dO1xufVxuY29uc3QgZGQgPSAocywgZSwgdCkgPT4gcyA+Pj4gdCwgaGQgPSAocywgZSwgdCkgPT4gcyA8PCAzMiAtIHQgfCBlID4+PiB0LCBjbiA9IChzLCBlLCB0KSA9PiBzID4+PiB0IHwgZSA8PCAzMiAtIHQsIHVuID0gKHMsIGUsIHQpID0+IHMgPDwgMzIgLSB0IHwgZSA+Pj4gdCwgQmkgPSAocywgZSwgdCkgPT4gcyA8PCA2NCAtIHQgfCBlID4+PiB0IC0gMzIsIEZpID0gKHMsIGUsIHQpID0+IHMgPj4+IHQgLSAzMiB8IGUgPDwgNjQgLSB0O1xuZnVuY3Rpb24gc3MocywgZSwgdCwgcikge1xuICBjb25zdCBuID0gKGUgPj4+IDApICsgKHIgPj4+IDApO1xuICByZXR1cm4geyBoOiBzICsgdCArIChuIC8gMiAqKiAzMiB8IDApIHwgMCwgbDogbiB8IDAgfTtcbn1cbmNvbnN0IGoxID0gKHMsIGUsIHQpID0+IChzID4+PiAwKSArIChlID4+PiAwKSArICh0ID4+PiAwKSwgSzEgPSAocywgZSwgdCwgcikgPT4gZSArIHQgKyByICsgKHMgLyAyICoqIDMyIHwgMCkgfCAwLCBIMSA9IChzLCBlLCB0LCByKSA9PiAocyA+Pj4gMCkgKyAoZSA+Pj4gMCkgKyAodCA+Pj4gMCkgKyAociA+Pj4gMCksIHExID0gKHMsIGUsIHQsIHIsIG4pID0+IGUgKyB0ICsgciArIG4gKyAocyAvIDIgKiogMzIgfCAwKSB8IDAsIFcxID0gKHMsIGUsIHQsIHIsIG4pID0+IChzID4+PiAwKSArIChlID4+PiAwKSArICh0ID4+PiAwKSArIChyID4+PiAwKSArIChuID4+PiAwKSwgejEgPSAocywgZSwgdCwgciwgbiwgaSkgPT4gZSArIHQgKyByICsgbiArIGkgKyAocyAvIDIgKiogMzIgfCAwKSB8IDAsIFkxID0gLyogQF9fUFVSRV9fICovIFVpbnQzMkFycmF5LmZyb20oW1xuICAxMTE2MzUyNDA4LFxuICAxODk5NDQ3NDQxLFxuICAzMDQ5MzIzNDcxLFxuICAzOTIxMDA5NTczLFxuICA5NjE5ODcxNjMsXG4gIDE1MDg5NzA5OTMsXG4gIDI0NTM2MzU3NDgsXG4gIDI4NzA3NjMyMjEsXG4gIDM2MjQzODEwODAsXG4gIDMxMDU5ODQwMSxcbiAgNjA3MjI1Mjc4LFxuICAxNDI2ODgxOTg3LFxuICAxOTI1MDc4Mzg4LFxuICAyMTYyMDc4MjA2LFxuICAyNjE0ODg4MTAzLFxuICAzMjQ4MjIyNTgwLFxuICAzODM1MzkwNDAxLFxuICA0MDIyMjI0Nzc0LFxuICAyNjQzNDcwNzgsXG4gIDYwNDgwNzYyOCxcbiAgNzcwMjU1OTgzLFxuICAxMjQ5MTUwMTIyLFxuICAxNTU1MDgxNjkyLFxuICAxOTk2MDY0OTg2LFxuICAyNTU0MjIwODgyLFxuICAyODIxODM0MzQ5LFxuICAyOTUyOTk2ODA4LFxuICAzMjEwMzEzNjcxLFxuICAzMzM2NTcxODkxLFxuICAzNTg0NTI4NzExLFxuICAxMTM5MjY5OTMsXG4gIDMzODI0MTg5NSxcbiAgNjY2MzA3MjA1LFxuICA3NzM1Mjk5MTIsXG4gIDEyOTQ3NTczNzIsXG4gIDEzOTYxODIyOTEsXG4gIDE2OTUxODM3MDAsXG4gIDE5ODY2NjEwNTEsXG4gIDIxNzcwMjYzNTAsXG4gIDI0NTY5NTYwMzcsXG4gIDI3MzA0ODU5MjEsXG4gIDI4MjAzMDI0MTEsXG4gIDMyNTk3MzA4MDAsXG4gIDMzNDU3NjQ3NzEsXG4gIDM1MTYwNjU4MTcsXG4gIDM2MDAzNTI4MDQsXG4gIDQwOTQ1NzE5MDksXG4gIDI3NTQyMzM0NCxcbiAgNDMwMjI3NzM0LFxuICA1MDY5NDg2MTYsXG4gIDY1OTA2MDU1NixcbiAgODgzOTk3ODc3LFxuICA5NTgxMzk1NzEsXG4gIDEzMjI4MjIyMTgsXG4gIDE1MzcwMDIwNjMsXG4gIDE3NDc4NzM3NzksXG4gIDE5NTU1NjIyMjIsXG4gIDIwMjQxMDQ4MTUsXG4gIDIyMjc3MzA0NTIsXG4gIDIzNjE4NTI0MjQsXG4gIDI0Mjg0MzY0NzQsXG4gIDI3NTY3MzQxODcsXG4gIDMyMDQwMzE0NzksXG4gIDMzMjkzMjUyOThcbl0pLCB5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoNjQpO1xuY2xhc3MgWjEgZXh0ZW5kcyBZZiB7XG4gIGNvbnN0cnVjdG9yKGUgPSAzMikge1xuICAgIHN1cGVyKDY0LCBlLCA4LCAhMSksIHRoaXMuQSA9IG1zWzBdIHwgMCwgdGhpcy5CID0gbXNbMV0gfCAwLCB0aGlzLkMgPSBtc1syXSB8IDAsIHRoaXMuRCA9IG1zWzNdIHwgMCwgdGhpcy5FID0gbXNbNF0gfCAwLCB0aGlzLkYgPSBtc1s1XSB8IDAsIHRoaXMuRyA9IG1zWzZdIHwgMCwgdGhpcy5IID0gbXNbN10gfCAwO1xuICB9XG4gIGdldCgpIHtcbiAgICBjb25zdCB7IEE6IGUsIEI6IHQsIEM6IHIsIEQ6IG4sIEU6IGksIEY6IG8sIEc6IGEsIEg6IGwgfSA9IHRoaXM7XG4gICAgcmV0dXJuIFtlLCB0LCByLCBuLCBpLCBvLCBhLCBsXTtcbiAgfVxuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgc2V0KGUsIHQsIHIsIG4sIGksIG8sIGEsIGwpIHtcbiAgICB0aGlzLkEgPSBlIHwgMCwgdGhpcy5CID0gdCB8IDAsIHRoaXMuQyA9IHIgfCAwLCB0aGlzLkQgPSBuIHwgMCwgdGhpcy5FID0gaSB8IDAsIHRoaXMuRiA9IG8gfCAwLCB0aGlzLkcgPSBhIHwgMCwgdGhpcy5IID0gbCB8IDA7XG4gIH1cbiAgcHJvY2VzcyhlLCB0KSB7XG4gICAgZm9yIChsZXQgZCA9IDA7IGQgPCAxNjsgZCsrLCB0ICs9IDQpXG4gICAgICB5c1tkXSA9IGUuZ2V0VWludDMyKHQsICExKTtcbiAgICBmb3IgKGxldCBkID0gMTY7IGQgPCA2NDsgZCsrKSB7XG4gICAgICBjb25zdCBoID0geXNbZCAtIDE1XSwgZiA9IHlzW2QgLSAyXSwgcCA9IE5yKGgsIDcpIF4gTnIoaCwgMTgpIF4gaCA+Pj4gMywgeSA9IE5yKGYsIDE3KSBeIE5yKGYsIDE5KSBeIGYgPj4+IDEwO1xuICAgICAgeXNbZF0gPSB5ICsgeXNbZCAtIDddICsgcCArIHlzW2QgLSAxNl0gfCAwO1xuICAgIH1cbiAgICBsZXQgeyBBOiByLCBCOiBuLCBDOiBpLCBEOiBvLCBFOiBhLCBGOiBsLCBHOiBjLCBIOiB1IH0gPSB0aGlzO1xuICAgIGZvciAobGV0IGQgPSAwOyBkIDwgNjQ7IGQrKykge1xuICAgICAgY29uc3QgaCA9IE5yKGEsIDYpIF4gTnIoYSwgMTEpIF4gTnIoYSwgMjUpLCBmID0gdSArIGggKyBVMShhLCBsLCBjKSArIFkxW2RdICsgeXNbZF0gfCAwLCB5ID0gKE5yKHIsIDIpIF4gTnIociwgMTMpIF4gTnIociwgMjIpKSArICQxKHIsIG4sIGkpIHwgMDtcbiAgICAgIHUgPSBjLCBjID0gbCwgbCA9IGEsIGEgPSBvICsgZiB8IDAsIG8gPSBpLCBpID0gbiwgbiA9IHIsIHIgPSBmICsgeSB8IDA7XG4gICAgfVxuICAgIHIgPSByICsgdGhpcy5BIHwgMCwgbiA9IG4gKyB0aGlzLkIgfCAwLCBpID0gaSArIHRoaXMuQyB8IDAsIG8gPSBvICsgdGhpcy5EIHwgMCwgYSA9IGEgKyB0aGlzLkUgfCAwLCBsID0gbCArIHRoaXMuRiB8IDAsIGMgPSBjICsgdGhpcy5HIHwgMCwgdSA9IHUgKyB0aGlzLkggfCAwLCB0aGlzLnNldChyLCBuLCBpLCBvLCBhLCBsLCBjLCB1KTtcbiAgfVxuICByb3VuZENsZWFuKCkge1xuICAgIGtuKHlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuc2V0KDAsIDAsIDAsIDAsIDAsIDAsIDAsIDApLCBrbih0aGlzLmJ1ZmZlcik7XG4gIH1cbn1cbmNvbnN0IFpmID0gVjEoW1xuICBcIjB4NDI4YTJmOThkNzI4YWUyMlwiLFxuICBcIjB4NzEzNzQ0OTEyM2VmNjVjZFwiLFxuICBcIjB4YjVjMGZiY2ZlYzRkM2IyZlwiLFxuICBcIjB4ZTliNWRiYTU4MTg5ZGJiY1wiLFxuICBcIjB4Mzk1NmMyNWJmMzQ4YjUzOFwiLFxuICBcIjB4NTlmMTExZjFiNjA1ZDAxOVwiLFxuICBcIjB4OTIzZjgyYTRhZjE5NGY5YlwiLFxuICBcIjB4YWIxYzVlZDVkYTZkODExOFwiLFxuICBcIjB4ZDgwN2FhOThhMzAzMDI0MlwiLFxuICBcIjB4MTI4MzViMDE0NTcwNmZiZVwiLFxuICBcIjB4MjQzMTg1YmU0ZWU0YjI4Y1wiLFxuICBcIjB4NTUwYzdkYzNkNWZmYjRlMlwiLFxuICBcIjB4NzJiZTVkNzRmMjdiODk2ZlwiLFxuICBcIjB4ODBkZWIxZmUzYjE2OTZiMVwiLFxuICBcIjB4OWJkYzA2YTcyNWM3MTIzNVwiLFxuICBcIjB4YzE5YmYxNzRjZjY5MjY5NFwiLFxuICBcIjB4ZTQ5YjY5YzE5ZWYxNGFkMlwiLFxuICBcIjB4ZWZiZTQ3ODYzODRmMjVlM1wiLFxuICBcIjB4MGZjMTlkYzY4YjhjZDViNVwiLFxuICBcIjB4MjQwY2ExY2M3N2FjOWM2NVwiLFxuICBcIjB4MmRlOTJjNmY1OTJiMDI3NVwiLFxuICBcIjB4NGE3NDg0YWE2ZWE2ZTQ4M1wiLFxuICBcIjB4NWNiMGE5ZGNiZDQxZmJkNFwiLFxuICBcIjB4NzZmOTg4ZGE4MzExNTNiNVwiLFxuICBcIjB4OTgzZTUxNTJlZTY2ZGZhYlwiLFxuICBcIjB4YTgzMWM2NmQyZGI0MzIxMFwiLFxuICBcIjB4YjAwMzI3Yzg5OGZiMjEzZlwiLFxuICBcIjB4YmY1OTdmYzdiZWVmMGVlNFwiLFxuICBcIjB4YzZlMDBiZjMzZGE4OGZjMlwiLFxuICBcIjB4ZDVhNzkxNDc5MzBhYTcyNVwiLFxuICBcIjB4MDZjYTYzNTFlMDAzODI2ZlwiLFxuICBcIjB4MTQyOTI5NjcwYTBlNmU3MFwiLFxuICBcIjB4MjdiNzBhODU0NmQyMmZmY1wiLFxuICBcIjB4MmUxYjIxMzg1YzI2YzkyNlwiLFxuICBcIjB4NGQyYzZkZmM1YWM0MmFlZFwiLFxuICBcIjB4NTMzODBkMTM5ZDk1YjNkZlwiLFxuICBcIjB4NjUwYTczNTQ4YmFmNjNkZVwiLFxuICBcIjB4NzY2YTBhYmIzYzc3YjJhOFwiLFxuICBcIjB4ODFjMmM5MmU0N2VkYWVlNlwiLFxuICBcIjB4OTI3MjJjODUxNDgyMzUzYlwiLFxuICBcIjB4YTJiZmU4YTE0Y2YxMDM2NFwiLFxuICBcIjB4YTgxYTY2NGJiYzQyMzAwMVwiLFxuICBcIjB4YzI0YjhiNzBkMGY4OTc5MVwiLFxuICBcIjB4Yzc2YzUxYTMwNjU0YmUzMFwiLFxuICBcIjB4ZDE5MmU4MTlkNmVmNTIxOFwiLFxuICBcIjB4ZDY5OTA2MjQ1NTY1YTkxMFwiLFxuICBcIjB4ZjQwZTM1ODU1NzcxMjAyYVwiLFxuICBcIjB4MTA2YWEwNzAzMmJiZDFiOFwiLFxuICBcIjB4MTlhNGMxMTZiOGQyZDBjOFwiLFxuICBcIjB4MWUzNzZjMDg1MTQxYWI1M1wiLFxuICBcIjB4Mjc0ODc3NGNkZjhlZWI5OVwiLFxuICBcIjB4MzRiMGJjYjVlMTliNDhhOFwiLFxuICBcIjB4MzkxYzBjYjNjNWM5NWE2M1wiLFxuICBcIjB4NGVkOGFhNGFlMzQxOGFjYlwiLFxuICBcIjB4NWI5Y2NhNGY3NzYzZTM3M1wiLFxuICBcIjB4NjgyZTZmZjNkNmIyYjhhM1wiLFxuICBcIjB4NzQ4ZjgyZWU1ZGVmYjJmY1wiLFxuICBcIjB4NzhhNTYzNmY0MzE3MmY2MFwiLFxuICBcIjB4ODRjODc4MTRhMWYwYWI3MlwiLFxuICBcIjB4OGNjNzAyMDgxYTY0MzllY1wiLFxuICBcIjB4OTBiZWZmZmEyMzYzMWUyOFwiLFxuICBcIjB4YTQ1MDZjZWJkZTgyYmRlOVwiLFxuICBcIjB4YmVmOWEzZjdiMmM2NzkxNVwiLFxuICBcIjB4YzY3MTc4ZjJlMzcyNTMyYlwiLFxuICBcIjB4Y2EyNzNlY2VlYTI2NjE5Y1wiLFxuICBcIjB4ZDE4NmI4YzcyMWMwYzIwN1wiLFxuICBcIjB4ZWFkYTdkZDZjZGUwZWIxZVwiLFxuICBcIjB4ZjU3ZDRmN2ZlZTZlZDE3OFwiLFxuICBcIjB4MDZmMDY3YWE3MjE3NmZiYVwiLFxuICBcIjB4MGE2MzdkYzVhMmM4OThhNlwiLFxuICBcIjB4MTEzZjk4MDRiZWY5MGRhZVwiLFxuICBcIjB4MWI3MTBiMzUxMzFjNDcxYlwiLFxuICBcIjB4MjhkYjc3ZjUyMzA0N2Q4NFwiLFxuICBcIjB4MzJjYWFiN2I0MGM3MjQ5M1wiLFxuICBcIjB4M2M5ZWJlMGExNWM5YmViY1wiLFxuICBcIjB4NDMxZDY3YzQ5YzEwMGQ0Y1wiLFxuICBcIjB4NGNjNWQ0YmVjYjNlNDJiNlwiLFxuICBcIjB4NTk3ZjI5OWNmYzY1N2UyYVwiLFxuICBcIjB4NWZjYjZmYWIzYWQ2ZmFlY1wiLFxuICBcIjB4NmM0NDE5OGM0YTQ3NTgxN1wiXG5dLm1hcCgocykgPT4gQmlnSW50KHMpKSksIFgxID0gWmZbMF0sIEoxID0gWmZbMV0sIHZzID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCksIEVzID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg4MCk7XG5jbGFzcyBRMSBleHRlbmRzIFlmIHtcbiAgY29uc3RydWN0b3IoZSA9IDY0KSB7XG4gICAgc3VwZXIoMTI4LCBlLCAxNiwgITEpLCB0aGlzLkFoID0gUXRbMF0gfCAwLCB0aGlzLkFsID0gUXRbMV0gfCAwLCB0aGlzLkJoID0gUXRbMl0gfCAwLCB0aGlzLkJsID0gUXRbM10gfCAwLCB0aGlzLkNoID0gUXRbNF0gfCAwLCB0aGlzLkNsID0gUXRbNV0gfCAwLCB0aGlzLkRoID0gUXRbNl0gfCAwLCB0aGlzLkRsID0gUXRbN10gfCAwLCB0aGlzLkVoID0gUXRbOF0gfCAwLCB0aGlzLkVsID0gUXRbOV0gfCAwLCB0aGlzLkZoID0gUXRbMTBdIHwgMCwgdGhpcy5GbCA9IFF0WzExXSB8IDAsIHRoaXMuR2ggPSBRdFsxMl0gfCAwLCB0aGlzLkdsID0gUXRbMTNdIHwgMCwgdGhpcy5IaCA9IFF0WzE0XSB8IDAsIHRoaXMuSGwgPSBRdFsxNV0gfCAwO1xuICB9XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBnZXQoKSB7XG4gICAgY29uc3QgeyBBaDogZSwgQWw6IHQsIEJoOiByLCBCbDogbiwgQ2g6IGksIENsOiBvLCBEaDogYSwgRGw6IGwsIEVoOiBjLCBFbDogdSwgRmg6IGQsIEZsOiBoLCBHaDogZiwgR2w6IHAsIEhoOiB5LCBIbDogRSB9ID0gdGhpcztcbiAgICByZXR1cm4gW2UsIHQsIHIsIG4sIGksIG8sIGEsIGwsIGMsIHUsIGQsIGgsIGYsIHAsIHksIEVdO1xuICB9XG4gIC8vIHByZXR0aWVyLWlnbm9yZVxuICBzZXQoZSwgdCwgciwgbiwgaSwgbywgYSwgbCwgYywgdSwgZCwgaCwgZiwgcCwgeSwgRSkge1xuICAgIHRoaXMuQWggPSBlIHwgMCwgdGhpcy5BbCA9IHQgfCAwLCB0aGlzLkJoID0gciB8IDAsIHRoaXMuQmwgPSBuIHwgMCwgdGhpcy5DaCA9IGkgfCAwLCB0aGlzLkNsID0gbyB8IDAsIHRoaXMuRGggPSBhIHwgMCwgdGhpcy5EbCA9IGwgfCAwLCB0aGlzLkVoID0gYyB8IDAsIHRoaXMuRWwgPSB1IHwgMCwgdGhpcy5GaCA9IGQgfCAwLCB0aGlzLkZsID0gaCB8IDAsIHRoaXMuR2ggPSBmIHwgMCwgdGhpcy5HbCA9IHAgfCAwLCB0aGlzLkhoID0geSB8IDAsIHRoaXMuSGwgPSBFIHwgMDtcbiAgfVxuICBwcm9jZXNzKGUsIHQpIHtcbiAgICBmb3IgKGxldCBBID0gMDsgQSA8IDE2OyBBKyssIHQgKz0gNClcbiAgICAgIHZzW0FdID0gZS5nZXRVaW50MzIodCksIEVzW0FdID0gZS5nZXRVaW50MzIodCArPSA0KTtcbiAgICBmb3IgKGxldCBBID0gMTY7IEEgPCA4MDsgQSsrKSB7XG4gICAgICBjb25zdCBGID0gdnNbQSAtIDE1XSB8IDAsIE0gPSBFc1tBIC0gMTVdIHwgMCwgSCA9IGNuKEYsIE0sIDEpIF4gY24oRiwgTSwgOCkgXiBkZChGLCBNLCA3KSwgSyA9IHVuKEYsIE0sIDEpIF4gdW4oRiwgTSwgOCkgXiBoZChGLCBNLCA3KSwgaiA9IHZzW0EgLSAyXSB8IDAsIEMgPSBFc1tBIC0gMl0gfCAwLCBrID0gY24oaiwgQywgMTkpIF4gQmkoaiwgQywgNjEpIF4gZGQoaiwgQywgNiksICQgPSB1bihqLCBDLCAxOSkgXiBGaShqLCBDLCA2MSkgXiBoZChqLCBDLCA2KSwgVyA9IEgxKEssICQsIEVzW0EgLSA3XSwgRXNbQSAtIDE2XSksIF8gPSBxMShXLCBILCBrLCB2c1tBIC0gN10sIHZzW0EgLSAxNl0pO1xuICAgICAgdnNbQV0gPSBfIHwgMCwgRXNbQV0gPSBXIHwgMDtcbiAgICB9XG4gICAgbGV0IHsgQWg6IHIsIEFsOiBuLCBCaDogaSwgQmw6IG8sIENoOiBhLCBDbDogbCwgRGg6IGMsIERsOiB1LCBFaDogZCwgRWw6IGgsIEZoOiBmLCBGbDogcCwgR2g6IHksIEdsOiBFLCBIaDogYiwgSGw6IFIgfSA9IHRoaXM7XG4gICAgZm9yIChsZXQgQSA9IDA7IEEgPCA4MDsgQSsrKSB7XG4gICAgICBjb25zdCBGID0gY24oZCwgaCwgMTQpIF4gY24oZCwgaCwgMTgpIF4gQmkoZCwgaCwgNDEpLCBNID0gdW4oZCwgaCwgMTQpIF4gdW4oZCwgaCwgMTgpIF4gRmkoZCwgaCwgNDEpLCBIID0gZCAmIGYgXiB+ZCAmIHksIEsgPSBoICYgcCBeIH5oICYgRSwgaiA9IFcxKFIsIE0sIEssIEoxW0FdLCBFc1tBXSksIEMgPSB6MShqLCBiLCBGLCBILCBYMVtBXSwgdnNbQV0pLCBrID0gaiB8IDAsICQgPSBjbihyLCBuLCAyOCkgXiBCaShyLCBuLCAzNCkgXiBCaShyLCBuLCAzOSksIFcgPSB1bihyLCBuLCAyOCkgXiBGaShyLCBuLCAzNCkgXiBGaShyLCBuLCAzOSksIF8gPSByICYgaSBeIHIgJiBhIF4gaSAmIGEsIGcgPSBuICYgbyBeIG4gJiBsIF4gbyAmIGw7XG4gICAgICBiID0geSB8IDAsIFIgPSBFIHwgMCwgeSA9IGYgfCAwLCBFID0gcCB8IDAsIGYgPSBkIHwgMCwgcCA9IGggfCAwLCB7IGg6IGQsIGw6IGggfSA9IHNzKGMgfCAwLCB1IHwgMCwgQyB8IDAsIGsgfCAwKSwgYyA9IGEgfCAwLCB1ID0gbCB8IDAsIGEgPSBpIHwgMCwgbCA9IG8gfCAwLCBpID0gciB8IDAsIG8gPSBuIHwgMDtcbiAgICAgIGNvbnN0IHggPSBqMShrLCBXLCBnKTtcbiAgICAgIHIgPSBLMSh4LCBDLCAkLCBfKSwgbiA9IHggfCAwO1xuICAgIH1cbiAgICAoeyBoOiByLCBsOiBuIH0gPSBzcyh0aGlzLkFoIHwgMCwgdGhpcy5BbCB8IDAsIHIgfCAwLCBuIHwgMCkpLCB7IGg6IGksIGw6IG8gfSA9IHNzKHRoaXMuQmggfCAwLCB0aGlzLkJsIHwgMCwgaSB8IDAsIG8gfCAwKSwgeyBoOiBhLCBsIH0gPSBzcyh0aGlzLkNoIHwgMCwgdGhpcy5DbCB8IDAsIGEgfCAwLCBsIHwgMCksIHsgaDogYywgbDogdSB9ID0gc3ModGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCBjIHwgMCwgdSB8IDApLCB7IGg6IGQsIGw6IGggfSA9IHNzKHRoaXMuRWggfCAwLCB0aGlzLkVsIHwgMCwgZCB8IDAsIGggfCAwKSwgeyBoOiBmLCBsOiBwIH0gPSBzcyh0aGlzLkZoIHwgMCwgdGhpcy5GbCB8IDAsIGYgfCAwLCBwIHwgMCksIHsgaDogeSwgbDogRSB9ID0gc3ModGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCB5IHwgMCwgRSB8IDApLCB7IGg6IGIsIGw6IFIgfSA9IHNzKHRoaXMuSGggfCAwLCB0aGlzLkhsIHwgMCwgYiB8IDAsIFIgfCAwKSwgdGhpcy5zZXQociwgbiwgaSwgbywgYSwgbCwgYywgdSwgZCwgaCwgZiwgcCwgeSwgRSwgYiwgUik7XG4gIH1cbiAgcm91bmRDbGVhbigpIHtcbiAgICBrbih2cywgRXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAga24odGhpcy5idWZmZXIpLCB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgfVxufVxuY29uc3QgWGYgPSAvKiBAX19QVVJFX18gKi8gemYoKCkgPT4gbmV3IFoxKCkpLCBleSA9IC8qIEBfX1BVUkVfXyAqLyB6ZigoKSA9PiBuZXcgUTEoKSk7XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCBXYyA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCksIEpsID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxKTtcbmZ1bmN0aW9uIFhzKHMsIGUgPSBcIlwiKSB7XG4gIGlmICh0eXBlb2YgcyAhPSBcImJvb2xlYW5cIikge1xuICAgIGNvbnN0IHQgPSBlICYmIGBcIiR7ZX1cImA7XG4gICAgdGhyb3cgbmV3IEVycm9yKHQgKyBcImV4cGVjdGVkIGJvb2xlYW4sIGdvdCB0eXBlPVwiICsgdHlwZW9mIHMpO1xuICB9XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gT3IocywgZSwgdCA9IFwiXCIpIHtcbiAgY29uc3QgciA9IElpKHMpLCBuID0gcyA9PSBudWxsID8gdm9pZCAwIDogcy5sZW5ndGgsIGkgPSBlICE9PSB2b2lkIDA7XG4gIGlmICghciB8fCBpICYmIG4gIT09IGUpIHtcbiAgICBjb25zdCBvID0gdCAmJiBgXCIke3R9XCIgYCwgYSA9IGkgPyBgIG9mIGxlbmd0aCAke2V9YCA6IFwiXCIsIGwgPSByID8gYGxlbmd0aD0ke259YCA6IGB0eXBlPSR7dHlwZW9mIHN9YDtcbiAgICB0aHJvdyBuZXcgRXJyb3IobyArIFwiZXhwZWN0ZWQgVWludDhBcnJheVwiICsgYSArIFwiLCBnb3QgXCIgKyBsKTtcbiAgfVxuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIE5pKHMpIHtcbiAgY29uc3QgZSA9IHMudG9TdHJpbmcoMTYpO1xuICByZXR1cm4gZS5sZW5ndGggJiAxID8gXCIwXCIgKyBlIDogZTtcbn1cbmZ1bmN0aW9uIEpmKHMpIHtcbiAgaWYgKHR5cGVvZiBzICE9IFwic3RyaW5nXCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IFwiICsgdHlwZW9mIHMpO1xuICByZXR1cm4gcyA9PT0gXCJcIiA/IFdjIDogQmlnSW50KFwiMHhcIiArIHMpO1xufVxuZnVuY3Rpb24gbGEocykge1xuICByZXR1cm4gSmYoSHMocykpO1xufVxuZnVuY3Rpb24gZWkocykge1xuICByZXR1cm4gUXMocyksIEpmKEhzKFVpbnQ4QXJyYXkuZnJvbShzKS5yZXZlcnNlKCkpKTtcbn1cbmZ1bmN0aW9uIHpjKHMsIGUpIHtcbiAgcmV0dXJuIFBvKHMudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KGUgKiAyLCBcIjBcIikpO1xufVxuZnVuY3Rpb24gUWYocywgZSkge1xuICByZXR1cm4gemMocywgZSkucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gRXQocywgZSwgdCkge1xuICBsZXQgcjtcbiAgaWYgKHR5cGVvZiBlID09IFwic3RyaW5nXCIpXG4gICAgdHJ5IHtcbiAgICAgIHIgPSBQbyhlKTtcbiAgICB9IGNhdGNoIChpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocyArIFwiIG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjYXVzZTogXCIgKyBpKTtcbiAgICB9XG4gIGVsc2UgaWYgKElpKGUpKVxuICAgIHIgPSBVaW50OEFycmF5LmZyb20oZSk7XG4gIGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IocyArIFwiIG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5XCIpO1xuICBjb25zdCBuID0gci5sZW5ndGg7XG4gIGlmICh0eXBlb2YgdCA9PSBcIm51bWJlclwiICYmIG4gIT09IHQpXG4gICAgdGhyb3cgbmV3IEVycm9yKHMgKyBcIiBvZiBsZW5ndGggXCIgKyB0ICsgXCIgZXhwZWN0ZWQsIGdvdCBcIiArIG4pO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIGZkKHMpIHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShzKTtcbn1cbmNvbnN0IGphID0gKHMpID0+IHR5cGVvZiBzID09IFwiYmlnaW50XCIgJiYgV2MgPD0gcztcbmZ1bmN0aW9uIHR5KHMsIGUsIHQpIHtcbiAgcmV0dXJuIGphKHMpICYmIGphKGUpICYmIGphKHQpICYmIGUgPD0gcyAmJiBzIDwgdDtcbn1cbmZ1bmN0aW9uIFFsKHMsIGUsIHQsIHIpIHtcbiAgaWYgKCF0eShlLCB0LCByKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCB2YWxpZCBcIiArIHMgKyBcIjogXCIgKyB0ICsgXCIgPD0gbiA8IFwiICsgciArIFwiLCBnb3QgXCIgKyBlKTtcbn1cbmZ1bmN0aW9uIGUwKHMpIHtcbiAgbGV0IGU7XG4gIGZvciAoZSA9IDA7IHMgPiBXYzsgcyA+Pj0gSmwsIGUgKz0gMSlcbiAgICA7XG4gIHJldHVybiBlO1xufVxuY29uc3QgX2kgPSAocykgPT4gKEpsIDw8IEJpZ0ludChzKSkgLSBKbDtcbmZ1bmN0aW9uIHJ5KHMsIGUsIHQpIHtcbiAgaWYgKHR5cGVvZiBzICE9IFwibnVtYmVyXCIgfHwgcyA8IDIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyXCIpO1xuICBpZiAodHlwZW9mIGUgIT0gXCJudW1iZXJcIiB8fCBlIDwgMilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJxQnl0ZUxlbiBtdXN0IGJlIGEgbnVtYmVyXCIpO1xuICBpZiAodHlwZW9mIHQgIT0gXCJmdW5jdGlvblwiKVxuICAgIHRocm93IG5ldyBFcnJvcihcImhtYWNGbiBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gIGNvbnN0IHIgPSAoZikgPT4gbmV3IFVpbnQ4QXJyYXkoZiksIG4gPSAoZikgPT4gVWludDhBcnJheS5vZihmKTtcbiAgbGV0IGkgPSByKHMpLCBvID0gcihzKSwgYSA9IDA7XG4gIGNvbnN0IGwgPSAoKSA9PiB7XG4gICAgaS5maWxsKDEpLCBvLmZpbGwoMCksIGEgPSAwO1xuICB9LCBjID0gKC4uLmYpID0+IHQobywgaSwgLi4uZiksIHUgPSAoZiA9IHIoMCkpID0+IHtcbiAgICBvID0gYyhuKDApLCBmKSwgaSA9IGMoKSwgZi5sZW5ndGggIT09IDAgJiYgKG8gPSBjKG4oMSksIGYpLCBpID0gYygpKTtcbiAgfSwgZCA9ICgpID0+IHtcbiAgICBpZiAoYSsrID49IDFlMylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImRyYmc6IHRyaWVkIDEwMDAgdmFsdWVzXCIpO1xuICAgIGxldCBmID0gMDtcbiAgICBjb25zdCBwID0gW107XG4gICAgZm9yICg7IGYgPCBlOyApIHtcbiAgICAgIGkgPSBjKCk7XG4gICAgICBjb25zdCB5ID0gaS5zbGljZSgpO1xuICAgICAgcC5wdXNoKHkpLCBmICs9IGkubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gS3IoLi4ucCk7XG4gIH07XG4gIHJldHVybiAoZiwgcCkgPT4ge1xuICAgIGwoKSwgdShmKTtcbiAgICBsZXQgeTtcbiAgICBmb3IgKDsgISh5ID0gcChkKCkpKTsgKVxuICAgICAgdSgpO1xuICAgIHJldHVybiBsKCksIHk7XG4gIH07XG59XG5mdW5jdGlvbiBSaShzLCBlLCB0ID0ge30pIHtcbiAgaWYgKCFzIHx8IHR5cGVvZiBzICE9IFwib2JqZWN0XCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZXhwZWN0ZWQgdmFsaWQgb3B0aW9ucyBvYmplY3RcIik7XG4gIGZ1bmN0aW9uIHIobiwgaSwgbykge1xuICAgIGNvbnN0IGEgPSBzW25dO1xuICAgIGlmIChvICYmIGEgPT09IHZvaWQgMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsID0gdHlwZW9mIGE7XG4gICAgaWYgKGwgIT09IGkgfHwgYSA9PT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyYW0gXCIke259XCIgaXMgaW52YWxpZDogZXhwZWN0ZWQgJHtpfSwgZ290ICR7bH1gKTtcbiAgfVxuICBPYmplY3QuZW50cmllcyhlKS5mb3JFYWNoKChbbiwgaV0pID0+IHIobiwgaSwgITEpKSwgT2JqZWN0LmVudHJpZXModCkuZm9yRWFjaCgoW24sIGldKSA9PiByKG4sIGksICEwKSk7XG59XG5mdW5jdGlvbiBNbyhzKSB7XG4gIGNvbnN0IGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbiAgcmV0dXJuICh0LCAuLi5yKSA9PiB7XG4gICAgY29uc3QgbiA9IGUuZ2V0KHQpO1xuICAgIGlmIChuICE9PSB2b2lkIDApXG4gICAgICByZXR1cm4gbjtcbiAgICBjb25zdCBpID0gcyh0LCAuLi5yKTtcbiAgICByZXR1cm4gZS5zZXQodCwgaSksIGk7XG4gIH07XG59XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCBnciA9IEJpZ0ludCgwKSwgWHQgPSBCaWdJbnQoMSksIEdzID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKSwgdDAgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDMpLCByMCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoNCksIHMwID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg1KSwgc3kgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDcpLCBuMCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoOCksIG55ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg5KSwgaTAgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDE2KTtcbmZ1bmN0aW9uIEd0KHMsIGUpIHtcbiAgY29uc3QgdCA9IHMgJSBlO1xuICByZXR1cm4gdCA+PSBnciA/IHQgOiBlICsgdDtcbn1cbmZ1bmN0aW9uIHZ0KHMsIGUsIHQpIHtcbiAgbGV0IHIgPSBzO1xuICBmb3IgKDsgZS0tID4gZ3I7IClcbiAgICByICo9IHIsIHIgJT0gdDtcbiAgcmV0dXJuIHI7XG59XG5mdW5jdGlvbiBnZChzLCBlKSB7XG4gIGlmIChzID09PSBncilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZlcnQ6IGV4cGVjdGVkIG5vbi16ZXJvIG51bWJlclwiKTtcbiAgaWYgKGUgPD0gZ3IpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBtb2R1bHVzLCBnb3QgXCIgKyBlKTtcbiAgbGV0IHQgPSBHdChzLCBlKSwgciA9IGUsIG4gPSBnciwgaSA9IFh0O1xuICBmb3IgKDsgdCAhPT0gZ3I7ICkge1xuICAgIGNvbnN0IGEgPSByIC8gdCwgbCA9IHIgJSB0LCBjID0gbiAtIGkgKiBhO1xuICAgIHIgPSB0LCB0ID0gbCwgbiA9IGksIGkgPSBjO1xuICB9XG4gIGlmIChyICE9PSBYdClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZlcnQ6IGRvZXMgbm90IGV4aXN0XCIpO1xuICByZXR1cm4gR3QobiwgZSk7XG59XG5mdW5jdGlvbiBZYyhzLCBlLCB0KSB7XG4gIGlmICghcy5lcWwocy5zcXIoZSksIHQpKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHNxdWFyZSByb290XCIpO1xufVxuZnVuY3Rpb24gbzAocywgZSkge1xuICBjb25zdCB0ID0gKHMuT1JERVIgKyBYdCkgLyByMCwgciA9IHMucG93KGUsIHQpO1xuICByZXR1cm4gWWMocywgciwgZSksIHI7XG59XG5mdW5jdGlvbiBpeShzLCBlKSB7XG4gIGNvbnN0IHQgPSAocy5PUkRFUiAtIHMwKSAvIG4wLCByID0gcy5tdWwoZSwgR3MpLCBuID0gcy5wb3cociwgdCksIGkgPSBzLm11bChlLCBuKSwgbyA9IHMubXVsKHMubXVsKGksIEdzKSwgbiksIGEgPSBzLm11bChpLCBzLnN1YihvLCBzLk9ORSkpO1xuICByZXR1cm4gWWMocywgYSwgZSksIGE7XG59XG5mdW5jdGlvbiBveShzKSB7XG4gIGNvbnN0IGUgPSBlbihzKSwgdCA9IGEwKHMpLCByID0gdChlLCBlLm5lZyhlLk9ORSkpLCBuID0gdChlLCByKSwgaSA9IHQoZSwgZS5uZWcocikpLCBvID0gKHMgKyBzeSkgLyBpMDtcbiAgcmV0dXJuIChhLCBsKSA9PiB7XG4gICAgbGV0IGMgPSBhLnBvdyhsLCBvKSwgdSA9IGEubXVsKGMsIHIpO1xuICAgIGNvbnN0IGQgPSBhLm11bChjLCBuKSwgaCA9IGEubXVsKGMsIGkpLCBmID0gYS5lcWwoYS5zcXIodSksIGwpLCBwID0gYS5lcWwoYS5zcXIoZCksIGwpO1xuICAgIGMgPSBhLmNtb3YoYywgdSwgZiksIHUgPSBhLmNtb3YoaCwgZCwgcCk7XG4gICAgY29uc3QgeSA9IGEuZXFsKGEuc3FyKHUpLCBsKSwgRSA9IGEuY21vdihjLCB1LCB5KTtcbiAgICByZXR1cm4gWWMoYSwgRSwgbCksIEU7XG4gIH07XG59XG5mdW5jdGlvbiBhMChzKSB7XG4gIGlmIChzIDwgdDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFwic3FydCBpcyBub3QgZGVmaW5lZCBmb3Igc21hbGwgZmllbGRcIik7XG4gIGxldCBlID0gcyAtIFh0LCB0ID0gMDtcbiAgZm9yICg7IGUgJSBHcyA9PT0gZ3I7IClcbiAgICBlIC89IEdzLCB0Kys7XG4gIGxldCByID0gR3M7XG4gIGNvbnN0IG4gPSBlbihzKTtcbiAgZm9yICg7IHBkKG4sIHIpID09PSAxOyApXG4gICAgaWYgKHIrKyA+IDFlMylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHNxdWFyZSByb290OiBwcm9iYWJseSBub24tcHJpbWUgUFwiKTtcbiAgaWYgKHQgPT09IDEpXG4gICAgcmV0dXJuIG8wO1xuICBsZXQgaSA9IG4ucG93KHIsIGUpO1xuICBjb25zdCBvID0gKGUgKyBYdCkgLyBHcztcbiAgcmV0dXJuIGZ1bmN0aW9uKGwsIGMpIHtcbiAgICBpZiAobC5pczAoYykpXG4gICAgICByZXR1cm4gYztcbiAgICBpZiAocGQobCwgYykgIT09IDEpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBzcXVhcmUgcm9vdFwiKTtcbiAgICBsZXQgdSA9IHQsIGQgPSBsLm11bChsLk9ORSwgaSksIGggPSBsLnBvdyhjLCBlKSwgZiA9IGwucG93KGMsIG8pO1xuICAgIGZvciAoOyAhbC5lcWwoaCwgbC5PTkUpOyApIHtcbiAgICAgIGlmIChsLmlzMChoKSlcbiAgICAgICAgcmV0dXJuIGwuWkVSTztcbiAgICAgIGxldCBwID0gMSwgeSA9IGwuc3FyKGgpO1xuICAgICAgZm9yICg7ICFsLmVxbCh5LCBsLk9ORSk7IClcbiAgICAgICAgaWYgKHArKywgeSA9IGwuc3FyKHkpLCBwID09PSB1KVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHNxdWFyZSByb290XCIpO1xuICAgICAgY29uc3QgRSA9IFh0IDw8IEJpZ0ludCh1IC0gcCAtIDEpLCBiID0gbC5wb3coZCwgRSk7XG4gICAgICB1ID0gcCwgZCA9IGwuc3FyKGIpLCBoID0gbC5tdWwoaCwgZCksIGYgPSBsLm11bChmLCBiKTtcbiAgICB9XG4gICAgcmV0dXJuIGY7XG4gIH07XG59XG5mdW5jdGlvbiBheShzKSB7XG4gIHJldHVybiBzICUgcjAgPT09IHQwID8gbzAgOiBzICUgbjAgPT09IHMwID8gaXkgOiBzICUgaTAgPT09IG55ID8gb3kocykgOiBhMChzKTtcbn1cbmNvbnN0IGx5ID0gKHMsIGUpID0+IChHdChzLCBlKSAmIFh0KSA9PT0gWHQsIGN5ID0gW1xuICBcImNyZWF0ZVwiLFxuICBcImlzVmFsaWRcIixcbiAgXCJpczBcIixcbiAgXCJuZWdcIixcbiAgXCJpbnZcIixcbiAgXCJzcXJ0XCIsXG4gIFwic3FyXCIsXG4gIFwiZXFsXCIsXG4gIFwiYWRkXCIsXG4gIFwic3ViXCIsXG4gIFwibXVsXCIsXG4gIFwicG93XCIsXG4gIFwiZGl2XCIsXG4gIFwiYWRkTlwiLFxuICBcInN1Yk5cIixcbiAgXCJtdWxOXCIsXG4gIFwic3FyTlwiXG5dO1xuZnVuY3Rpb24gdXkocykge1xuICBjb25zdCBlID0ge1xuICAgIE9SREVSOiBcImJpZ2ludFwiLFxuICAgIE1BU0s6IFwiYmlnaW50XCIsXG4gICAgQllURVM6IFwibnVtYmVyXCIsXG4gICAgQklUUzogXCJudW1iZXJcIlxuICB9LCB0ID0gY3kucmVkdWNlKChyLCBuKSA9PiAocltuXSA9IFwiZnVuY3Rpb25cIiwgciksIGUpO1xuICByZXR1cm4gUmkocywgdCksIHM7XG59XG5mdW5jdGlvbiBkeShzLCBlLCB0KSB7XG4gIGlmICh0IDwgZ3IpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBleHBvbmVudCwgbmVnYXRpdmVzIHVuc3VwcG9ydGVkXCIpO1xuICBpZiAodCA9PT0gZ3IpXG4gICAgcmV0dXJuIHMuT05FO1xuICBpZiAodCA9PT0gWHQpXG4gICAgcmV0dXJuIGU7XG4gIGxldCByID0gcy5PTkUsIG4gPSBlO1xuICBmb3IgKDsgdCA+IGdyOyApXG4gICAgdCAmIFh0ICYmIChyID0gcy5tdWwociwgbikpLCBuID0gcy5zcXIobiksIHQgPj49IFh0O1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIGwwKHMsIGUsIHQgPSAhMSkge1xuICBjb25zdCByID0gbmV3IEFycmF5KGUubGVuZ3RoKS5maWxsKHQgPyBzLlpFUk8gOiB2b2lkIDApLCBuID0gZS5yZWR1Y2UoKG8sIGEsIGwpID0+IHMuaXMwKGEpID8gbyA6IChyW2xdID0gbywgcy5tdWwobywgYSkpLCBzLk9ORSksIGkgPSBzLmludihuKTtcbiAgcmV0dXJuIGUucmVkdWNlUmlnaHQoKG8sIGEsIGwpID0+IHMuaXMwKGEpID8gbyA6IChyW2xdID0gcy5tdWwobywgcltsXSksIHMubXVsKG8sIGEpKSwgaSksIHI7XG59XG5mdW5jdGlvbiBwZChzLCBlKSB7XG4gIGNvbnN0IHQgPSAocy5PUkRFUiAtIFh0KSAvIEdzLCByID0gcy5wb3coZSwgdCksIG4gPSBzLmVxbChyLCBzLk9ORSksIGkgPSBzLmVxbChyLCBzLlpFUk8pLCBvID0gcy5lcWwociwgcy5uZWcocy5PTkUpKTtcbiAgaWYgKCFuICYmICFpICYmICFvKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgTGVnZW5kcmUgc3ltYm9sIHJlc3VsdFwiKTtcbiAgcmV0dXJuIG4gPyAxIDogaSA/IDAgOiAtMTtcbn1cbmZ1bmN0aW9uIGMwKHMsIGUpIHtcbiAgZSAhPT0gdm9pZCAwICYmIFhsKGUpO1xuICBjb25zdCB0ID0gZSAhPT0gdm9pZCAwID8gZSA6IHMudG9TdHJpbmcoMikubGVuZ3RoLCByID0gTWF0aC5jZWlsKHQgLyA4KTtcbiAgcmV0dXJuIHsgbkJpdExlbmd0aDogdCwgbkJ5dGVMZW5ndGg6IHIgfTtcbn1cbmZ1bmN0aW9uIGVuKHMsIGUsIHQgPSAhMSwgciA9IHt9KSB7XG4gIGlmIChzIDw9IGdyKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSID4gMCwgZ290IFwiICsgcyk7XG4gIGxldCBuLCBpLCBvID0gITEsIGE7XG4gIGlmICh0eXBlb2YgZSA9PSBcIm9iamVjdFwiICYmIGUgIT0gbnVsbCkge1xuICAgIGlmIChyLnNxcnQgfHwgdClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBzcGVjaWZ5IG9wdHMgaW4gdHdvIGFyZ3VtZW50c1wiKTtcbiAgICBjb25zdCBoID0gZTtcbiAgICBoLkJJVFMgJiYgKG4gPSBoLkJJVFMpLCBoLnNxcnQgJiYgKGkgPSBoLnNxcnQpLCB0eXBlb2YgaC5pc0xFID09IFwiYm9vbGVhblwiICYmICh0ID0gaC5pc0xFKSwgdHlwZW9mIGgubW9kRnJvbUJ5dGVzID09IFwiYm9vbGVhblwiICYmIChvID0gaC5tb2RGcm9tQnl0ZXMpLCBhID0gaC5hbGxvd2VkTGVuZ3RocztcbiAgfSBlbHNlXG4gICAgdHlwZW9mIGUgPT0gXCJudW1iZXJcIiAmJiAobiA9IGUpLCByLnNxcnQgJiYgKGkgPSByLnNxcnQpO1xuICBjb25zdCB7IG5CaXRMZW5ndGg6IGwsIG5CeXRlTGVuZ3RoOiBjIH0gPSBjMChzLCBuKTtcbiAgaWYgKGMgPiAyMDQ4KVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSIG9mIDw9IDIwNDggYnl0ZXNcIik7XG4gIGxldCB1O1xuICBjb25zdCBkID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgT1JERVI6IHMsXG4gICAgaXNMRTogdCxcbiAgICBCSVRTOiBsLFxuICAgIEJZVEVTOiBjLFxuICAgIE1BU0s6IF9pKGwpLFxuICAgIFpFUk86IGdyLFxuICAgIE9ORTogWHQsXG4gICAgYWxsb3dlZExlbmd0aHM6IGEsXG4gICAgY3JlYXRlOiAoaCkgPT4gR3QoaCwgcyksXG4gICAgaXNWYWxpZDogKGgpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgaCAhPSBcImJpZ2ludFwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290IFwiICsgdHlwZW9mIGgpO1xuICAgICAgcmV0dXJuIGdyIDw9IGggJiYgaCA8IHM7XG4gICAgfSxcbiAgICBpczA6IChoKSA9PiBoID09PSBncixcbiAgICAvLyBpcyB2YWxpZCBhbmQgaW52ZXJ0aWJsZVxuICAgIGlzVmFsaWROb3QwOiAoaCkgPT4gIWQuaXMwKGgpICYmIGQuaXNWYWxpZChoKSxcbiAgICBpc09kZDogKGgpID0+IChoICYgWHQpID09PSBYdCxcbiAgICBuZWc6IChoKSA9PiBHdCgtaCwgcyksXG4gICAgZXFsOiAoaCwgZikgPT4gaCA9PT0gZixcbiAgICBzcXI6IChoKSA9PiBHdChoICogaCwgcyksXG4gICAgYWRkOiAoaCwgZikgPT4gR3QoaCArIGYsIHMpLFxuICAgIHN1YjogKGgsIGYpID0+IEd0KGggLSBmLCBzKSxcbiAgICBtdWw6IChoLCBmKSA9PiBHdChoICogZiwgcyksXG4gICAgcG93OiAoaCwgZikgPT4gZHkoZCwgaCwgZiksXG4gICAgZGl2OiAoaCwgZikgPT4gR3QoaCAqIGdkKGYsIHMpLCBzKSxcbiAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICBzcXJOOiAoaCkgPT4gaCAqIGgsXG4gICAgYWRkTjogKGgsIGYpID0+IGggKyBmLFxuICAgIHN1Yk46IChoLCBmKSA9PiBoIC0gZixcbiAgICBtdWxOOiAoaCwgZikgPT4gaCAqIGYsXG4gICAgaW52OiAoaCkgPT4gZ2QoaCwgcyksXG4gICAgc3FydDogaSB8fCAoKGgpID0+ICh1IHx8ICh1ID0gYXkocykpLCB1KGQsIGgpKSksXG4gICAgdG9CeXRlczogKGgpID0+IHQgPyBRZihoLCBjKSA6IHpjKGgsIGMpLFxuICAgIGZyb21CeXRlczogKGgsIGYgPSAhMCkgPT4ge1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgaWYgKCFhLmluY2x1ZGVzKGgubGVuZ3RoKSB8fCBoLmxlbmd0aCA+IGMpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQuZnJvbUJ5dGVzOiBleHBlY3RlZCBcIiArIGEgKyBcIiBieXRlcywgZ290IFwiICsgaC5sZW5ndGgpO1xuICAgICAgICBjb25zdCB5ID0gbmV3IFVpbnQ4QXJyYXkoYyk7XG4gICAgICAgIHkuc2V0KGgsIHQgPyAwIDogeS5sZW5ndGggLSBoLmxlbmd0aCksIGggPSB5O1xuICAgICAgfVxuICAgICAgaWYgKGgubGVuZ3RoICE9PSBjKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZC5mcm9tQnl0ZXM6IGV4cGVjdGVkIFwiICsgYyArIFwiIGJ5dGVzLCBnb3QgXCIgKyBoLmxlbmd0aCk7XG4gICAgICBsZXQgcCA9IHQgPyBlaShoKSA6IGxhKGgpO1xuICAgICAgaWYgKG8gJiYgKHAgPSBHdChwLCBzKSksICFmICYmICFkLmlzVmFsaWQocCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmllbGQgZWxlbWVudDogb3V0c2lkZSBvZiByYW5nZSAwLi5PUkRFUlwiKTtcbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgLy8gVE9ETzogd2UgZG9uJ3QgbmVlZCBpdCBoZXJlLCBtb3ZlIG91dCB0byBzZXBhcmF0ZSBmblxuICAgIGludmVydEJhdGNoOiAoaCkgPT4gbDAoZCwgaCksXG4gICAgLy8gV2UgY2FuJ3QgbW92ZSB0aGlzIG91dCBiZWNhdXNlIEZwNiwgRnAxMiBpbXBsZW1lbnQgaXRcbiAgICAvLyBhbmQgaXQncyB1bmNsZWFyIHdoYXQgdG8gcmV0dXJuIGluIHRoZXJlLlxuICAgIGNtb3Y6IChoLCBmLCBwKSA9PiBwID8gZiA6IGhcbiAgfSk7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKGQpO1xufVxuZnVuY3Rpb24gdTAocykge1xuICBpZiAodHlwZW9mIHMgIT0gXCJiaWdpbnRcIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludFwiKTtcbiAgY29uc3QgZSA9IHMudG9TdHJpbmcoMikubGVuZ3RoO1xuICByZXR1cm4gTWF0aC5jZWlsKGUgLyA4KTtcbn1cbmZ1bmN0aW9uIGQwKHMpIHtcbiAgY29uc3QgZSA9IHUwKHMpO1xuICByZXR1cm4gZSArIE1hdGguY2VpbChlIC8gMik7XG59XG5mdW5jdGlvbiBoeShzLCBlLCB0ID0gITEpIHtcbiAgY29uc3QgciA9IHMubGVuZ3RoLCBuID0gdTAoZSksIGkgPSBkMChlKTtcbiAgaWYgKHIgPCAxNiB8fCByIDwgaSB8fCByID4gMTAyNClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJleHBlY3RlZCBcIiArIGkgKyBcIi0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgXCIgKyByKTtcbiAgY29uc3QgbyA9IHQgPyBlaShzKSA6IGxhKHMpLCBhID0gR3QobywgZSAtIFh0KSArIFh0O1xuICByZXR1cm4gdCA/IFFmKGEsIG4pIDogemMoYSwgbik7XG59XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCBEbiA9IEJpZ0ludCgwKSwgVnMgPSBCaWdJbnQoMSk7XG5mdW5jdGlvbiBPbyhzLCBlKSB7XG4gIGNvbnN0IHQgPSBlLm5lZ2F0ZSgpO1xuICByZXR1cm4gcyA/IHQgOiBlO1xufVxuZnVuY3Rpb24ganMocywgZSkge1xuICBjb25zdCB0ID0gbDAocy5GcCwgZS5tYXAoKHIpID0+IHIuWikpO1xuICByZXR1cm4gZS5tYXAoKHIsIG4pID0+IHMuZnJvbUFmZmluZShyLnRvQWZmaW5lKHRbbl0pKSk7XG59XG5mdW5jdGlvbiBoMChzLCBlKSB7XG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIocykgfHwgcyA8PSAwIHx8IHMgPiBlKVxuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgd2luZG93IHNpemUsIGV4cGVjdGVkIFsxLi5cIiArIGUgKyBcIl0sIGdvdCBXPVwiICsgcyk7XG59XG5mdW5jdGlvbiBLYShzLCBlKSB7XG4gIGgwKHMsIGUpO1xuICBjb25zdCB0ID0gTWF0aC5jZWlsKGUgLyBzKSArIDEsIHIgPSAyICoqIChzIC0gMSksIG4gPSAyICoqIHMsIGkgPSBfaShzKSwgbyA9IEJpZ0ludChzKTtcbiAgcmV0dXJuIHsgd2luZG93czogdCwgd2luZG93U2l6ZTogciwgbWFzazogaSwgbWF4TnVtYmVyOiBuLCBzaGlmdEJ5OiBvIH07XG59XG5mdW5jdGlvbiBtZChzLCBlLCB0KSB7XG4gIGNvbnN0IHsgd2luZG93U2l6ZTogciwgbWFzazogbiwgbWF4TnVtYmVyOiBpLCBzaGlmdEJ5OiBvIH0gPSB0O1xuICBsZXQgYSA9IE51bWJlcihzICYgbiksIGwgPSBzID4+IG87XG4gIGEgPiByICYmIChhIC09IGksIGwgKz0gVnMpO1xuICBjb25zdCBjID0gZSAqIHIsIHUgPSBjICsgTWF0aC5hYnMoYSkgLSAxLCBkID0gYSA9PT0gMCwgaCA9IGEgPCAwLCBmID0gZSAlIDIgIT09IDA7XG4gIHJldHVybiB7IG5leHROOiBsLCBvZmZzZXQ6IHUsIGlzWmVybzogZCwgaXNOZWc6IGgsIGlzTmVnRjogZiwgb2Zmc2V0RjogYyB9O1xufVxuZnVuY3Rpb24gZnkocywgZSkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkocykpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYXJyYXkgZXhwZWN0ZWRcIik7XG4gIHMuZm9yRWFjaCgodCwgcikgPT4ge1xuICAgIGlmICghKHQgaW5zdGFuY2VvZiBlKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcG9pbnQgYXQgaW5kZXggXCIgKyByKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBneShzLCBlKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShzKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBvZiBzY2FsYXJzIGV4cGVjdGVkXCIpO1xuICBzLmZvckVhY2goKHQsIHIpID0+IHtcbiAgICBpZiAoIWUuaXNWYWxpZCh0KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2NhbGFyIGF0IGluZGV4IFwiICsgcik7XG4gIH0pO1xufVxuY29uc3QgSGEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgZjAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIHFhKHMpIHtcbiAgcmV0dXJuIGYwLmdldChzKSB8fCAxO1xufVxuZnVuY3Rpb24geWQocykge1xuICBpZiAocyAhPT0gRG4pXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB3TkFGXCIpO1xufVxuY2xhc3MgZzAge1xuICAvLyBQYXJhbWV0cml6ZWQgd2l0aCBhIGdpdmVuIFBvaW50IGNsYXNzIChub3QgaW5kaXZpZHVhbCBwb2ludClcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMuQkFTRSA9IGUuQkFTRSwgdGhpcy5aRVJPID0gZS5aRVJPLCB0aGlzLkZuID0gZS5GbiwgdGhpcy5iaXRzID0gdDtcbiAgfVxuICAvLyBub24tY29uc3QgdGltZSBtdWx0aXBsaWNhdGlvbiBsYWRkZXJcbiAgX3Vuc2FmZUxhZGRlcihlLCB0LCByID0gdGhpcy5aRVJPKSB7XG4gICAgbGV0IG4gPSBlO1xuICAgIGZvciAoOyB0ID4gRG47IClcbiAgICAgIHQgJiBWcyAmJiAociA9IHIuYWRkKG4pKSwgbiA9IG4uZG91YmxlKCksIHQgPj49IFZzO1xuICAgIHJldHVybiByO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgd05BRiBwcmVjb21wdXRhdGlvbiB3aW5kb3cuIFVzZWQgZm9yIGNhY2hpbmcuXG4gICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgKiBOdW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGRlcGVuZHMgb24gdGhlIGN1cnZlIHNpemU6XG4gICAqIDJeKPCdkYriiJIxKSAqIChNYXRoLmNlaWwo8J2RmyAvIPCdkYopICsgMSksIHdoZXJlOlxuICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAqIC0g8J2RmyBpcyB0aGUgYml0bGVuZ3RoIG9mIHRoZSBjdXJ2ZSBvcmRlci5cbiAgICogRm9yIGEgMjU2LWJpdCBjdXJ2ZSBhbmQgd2luZG93IHNpemUgOCwgdGhlIG51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgaXMgMTI4ICogMzMgPSA0MjI0LlxuICAgKiBAcGFyYW0gcG9pbnQgUG9pbnQgaW5zdGFuY2VcbiAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgKi9cbiAgcHJlY29tcHV0ZVdpbmRvdyhlLCB0KSB7XG4gICAgY29uc3QgeyB3aW5kb3dzOiByLCB3aW5kb3dTaXplOiBuIH0gPSBLYSh0LCB0aGlzLmJpdHMpLCBpID0gW107XG4gICAgbGV0IG8gPSBlLCBhID0gbztcbiAgICBmb3IgKGxldCBsID0gMDsgbCA8IHI7IGwrKykge1xuICAgICAgYSA9IG8sIGkucHVzaChhKTtcbiAgICAgIGZvciAobGV0IGMgPSAxOyBjIDwgbjsgYysrKVxuICAgICAgICBhID0gYS5hZGQobyksIGkucHVzaChhKTtcbiAgICAgIG8gPSBhLmRvdWJsZSgpO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfVxuICAvKipcbiAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgKiBNb3JlIGNvbXBhY3QgaW1wbGVtZW50YXRpb246XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wYXVsbWlsbHIvbm9ibGUtc2VjcDI1NmsxL2Jsb2IvNDdjYjE2NjliNmU1MDZhZDY2YjM1ZmU3ZDc2MTMyYWU5NzQ2NWRhMi9pbmRleC50cyNMNTAyLUw1NDFcbiAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgKi9cbiAgd05BRihlLCB0LCByKSB7XG4gICAgaWYgKCF0aGlzLkZuLmlzVmFsaWQocikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNjYWxhclwiKTtcbiAgICBsZXQgbiA9IHRoaXMuWkVSTywgaSA9IHRoaXMuQkFTRTtcbiAgICBjb25zdCBvID0gS2EoZSwgdGhpcy5iaXRzKTtcbiAgICBmb3IgKGxldCBhID0gMDsgYSA8IG8ud2luZG93czsgYSsrKSB7XG4gICAgICBjb25zdCB7IG5leHROOiBsLCBvZmZzZXQ6IGMsIGlzWmVybzogdSwgaXNOZWc6IGQsIGlzTmVnRjogaCwgb2Zmc2V0RjogZiB9ID0gbWQociwgYSwgbyk7XG4gICAgICByID0gbCwgdSA/IGkgPSBpLmFkZChPbyhoLCB0W2ZdKSkgOiBuID0gbi5hZGQoT28oZCwgdFtjXSkpO1xuICAgIH1cbiAgICByZXR1cm4geWQociksIHsgcDogbiwgZjogaSB9O1xuICB9XG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIGVjIHVuc2FmZSAobm9uIGNvbnN0LXRpbWUpIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAqIEBwYXJhbSBhY2MgYWNjdW11bGF0b3IgcG9pbnQgdG8gYWRkIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvblxuICAgKiBAcmV0dXJucyBwb2ludFxuICAgKi9cbiAgd05BRlVuc2FmZShlLCB0LCByLCBuID0gdGhpcy5aRVJPKSB7XG4gICAgY29uc3QgaSA9IEthKGUsIHRoaXMuYml0cyk7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBpLndpbmRvd3MgJiYgciAhPT0gRG47IG8rKykge1xuICAgICAgY29uc3QgeyBuZXh0TjogYSwgb2Zmc2V0OiBsLCBpc1plcm86IGMsIGlzTmVnOiB1IH0gPSBtZChyLCBvLCBpKTtcbiAgICAgIGlmIChyID0gYSwgIWMpIHtcbiAgICAgICAgY29uc3QgZCA9IHRbbF07XG4gICAgICAgIG4gPSBuLmFkZCh1ID8gZC5uZWdhdGUoKSA6IGQpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geWQociksIG47XG4gIH1cbiAgZ2V0UHJlY29tcHV0ZXMoZSwgdCwgcikge1xuICAgIGxldCBuID0gSGEuZ2V0KHQpO1xuICAgIHJldHVybiBuIHx8IChuID0gdGhpcy5wcmVjb21wdXRlV2luZG93KHQsIGUpLCBlICE9PSAxICYmICh0eXBlb2YgciA9PSBcImZ1bmN0aW9uXCIgJiYgKG4gPSByKG4pKSwgSGEuc2V0KHQsIG4pKSksIG47XG4gIH1cbiAgY2FjaGVkKGUsIHQsIHIpIHtcbiAgICBjb25zdCBuID0gcWEoZSk7XG4gICAgcmV0dXJuIHRoaXMud05BRihuLCB0aGlzLmdldFByZWNvbXB1dGVzKG4sIGUsIHIpLCB0KTtcbiAgfVxuICB1bnNhZmUoZSwgdCwgciwgbikge1xuICAgIGNvbnN0IGkgPSBxYShlKTtcbiAgICByZXR1cm4gaSA9PT0gMSA/IHRoaXMuX3Vuc2FmZUxhZGRlcihlLCB0LCBuKSA6IHRoaXMud05BRlVuc2FmZShpLCB0aGlzLmdldFByZWNvbXB1dGVzKGksIGUsIHIpLCB0LCBuKTtcbiAgfVxuICAvLyBXZSBjYWxjdWxhdGUgcHJlY29tcHV0ZXMgZm9yIGVsbGlwdGljIGN1cnZlIHBvaW50IG11bHRpcGxpY2F0aW9uXG4gIC8vIHVzaW5nIHdpbmRvd2VkIG1ldGhvZC4gVGhpcyBzcGVjaWZpZXMgd2luZG93IHNpemUgYW5kXG4gIC8vIHN0b3JlcyBwcmVjb21wdXRlZCB2YWx1ZXMuIFVzdWFsbHkgb25seSBiYXNlIHBvaW50IHdvdWxkIGJlIHByZWNvbXB1dGVkLlxuICBjcmVhdGVDYWNoZShlLCB0KSB7XG4gICAgaDAodCwgdGhpcy5iaXRzKSwgZjAuc2V0KGUsIHQpLCBIYS5kZWxldGUoZSk7XG4gIH1cbiAgaGFzQ2FjaGUoZSkge1xuICAgIHJldHVybiBxYShlKSAhPT0gMTtcbiAgfVxufVxuZnVuY3Rpb24gcHkocywgZSwgdCwgcikge1xuICBsZXQgbiA9IGUsIGkgPSBzLlpFUk8sIG8gPSBzLlpFUk87XG4gIGZvciAoOyB0ID4gRG4gfHwgciA+IERuOyApXG4gICAgdCAmIFZzICYmIChpID0gaS5hZGQobikpLCByICYgVnMgJiYgKG8gPSBvLmFkZChuKSksIG4gPSBuLmRvdWJsZSgpLCB0ID4+PSBWcywgciA+Pj0gVnM7XG4gIHJldHVybiB7IHAxOiBpLCBwMjogbyB9O1xufVxuZnVuY3Rpb24gcDAocywgZSwgdCwgcikge1xuICBmeSh0LCBzKSwgZ3kociwgZSk7XG4gIGNvbnN0IG4gPSB0Lmxlbmd0aCwgaSA9IHIubGVuZ3RoO1xuICBpZiAobiAhPT0gaSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheXMgb2YgcG9pbnRzIGFuZCBzY2FsYXJzIG11c3QgaGF2ZSBlcXVhbCBsZW5ndGhcIik7XG4gIGNvbnN0IG8gPSBzLlpFUk8sIGEgPSBlMChCaWdJbnQobikpO1xuICBsZXQgbCA9IDE7XG4gIGEgPiAxMiA/IGwgPSBhIC0gMyA6IGEgPiA0ID8gbCA9IGEgLSAyIDogYSA+IDAgJiYgKGwgPSAyKTtcbiAgY29uc3QgYyA9IF9pKGwpLCB1ID0gbmV3IEFycmF5KE51bWJlcihjKSArIDEpLmZpbGwobyksIGQgPSBNYXRoLmZsb29yKChlLkJJVFMgLSAxKSAvIGwpICogbDtcbiAgbGV0IGggPSBvO1xuICBmb3IgKGxldCBmID0gZDsgZiA+PSAwOyBmIC09IGwpIHtcbiAgICB1LmZpbGwobyk7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBpOyB5KyspIHtcbiAgICAgIGNvbnN0IEUgPSByW3ldLCBiID0gTnVtYmVyKEUgPj4gQmlnSW50KGYpICYgYyk7XG4gICAgICB1W2JdID0gdVtiXS5hZGQodFt5XSk7XG4gICAgfVxuICAgIGxldCBwID0gbztcbiAgICBmb3IgKGxldCB5ID0gdS5sZW5ndGggLSAxLCBFID0gbzsgeSA+IDA7IHktLSlcbiAgICAgIEUgPSBFLmFkZCh1W3ldKSwgcCA9IHAuYWRkKEUpO1xuICAgIGlmIChoID0gaC5hZGQocCksIGYgIT09IDApXG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGw7IHkrKylcbiAgICAgICAgaCA9IGguZG91YmxlKCk7XG4gIH1cbiAgcmV0dXJuIGg7XG59XG5mdW5jdGlvbiB2ZChzLCBlLCB0KSB7XG4gIGlmIChlKSB7XG4gICAgaWYgKGUuT1JERVIgIT09IHMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZC5PUkRFUiBtdXN0IG1hdGNoIG9yZGVyOiBGcCA9PSBwLCBGbiA9PSBuXCIpO1xuICAgIHJldHVybiB1eShlKSwgZTtcbiAgfSBlbHNlXG4gICAgcmV0dXJuIGVuKHMsIHsgaXNMRTogdCB9KTtcbn1cbmZ1bmN0aW9uIG0wKHMsIGUsIHQgPSB7fSwgcikge1xuICBpZiAociA9PT0gdm9pZCAwICYmIChyID0gcyA9PT0gXCJlZHdhcmRzXCIpLCAhZSB8fCB0eXBlb2YgZSAhPSBcIm9iamVjdFwiKVxuICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgdmFsaWQgJHtzfSBDVVJWRSBvYmplY3RgKTtcbiAgZm9yIChjb25zdCBsIG9mIFtcInBcIiwgXCJuXCIsIFwiaFwiXSkge1xuICAgIGNvbnN0IGMgPSBlW2xdO1xuICAgIGlmICghKHR5cGVvZiBjID09IFwiYmlnaW50XCIgJiYgYyA+IERuKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ1VSVkUuJHtsfSBtdXN0IGJlIHBvc2l0aXZlIGJpZ2ludGApO1xuICB9XG4gIGNvbnN0IG4gPSB2ZChlLnAsIHQuRnAsIHIpLCBpID0gdmQoZS5uLCB0LkZuLCByKSwgYSA9IFtcIkd4XCIsIFwiR3lcIiwgXCJhXCIsIHMgPT09IFwid2VpZXJzdHJhc3NcIiA/IFwiYlwiIDogXCJkXCJdO1xuICBmb3IgKGNvbnN0IGwgb2YgYSlcbiAgICBpZiAoIW4uaXNWYWxpZChlW2xdKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ1VSVkUuJHtsfSBtdXN0IGJlIHZhbGlkIGZpZWxkIGVsZW1lbnQgb2YgQ1VSVkUuRnBgKTtcbiAgcmV0dXJuIGUgPSBPYmplY3QuZnJlZXplKE9iamVjdC5hc3NpZ24oe30sIGUpKSwgeyBDVVJWRTogZSwgRnA6IG4sIEZuOiBpIH07XG59XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5jb25zdCB4cyA9IEJpZ0ludCgwKSwgenQgPSBCaWdJbnQoMSksIFdhID0gQmlnSW50KDIpLCBteSA9IEJpZ0ludCg4KTtcbmZ1bmN0aW9uIHl5KHMsIGUsIHQsIHIpIHtcbiAgY29uc3QgbiA9IHMuc3FyKHQpLCBpID0gcy5zcXIociksIG8gPSBzLmFkZChzLm11bChlLmEsIG4pLCBpKSwgYSA9IHMuYWRkKHMuT05FLCBzLm11bChlLmQsIHMubXVsKG4sIGkpKSk7XG4gIHJldHVybiBzLmVxbChvLCBhKTtcbn1cbmZ1bmN0aW9uIHZ5KHMsIGUgPSB7fSkge1xuICBjb25zdCB0ID0gbTAoXCJlZHdhcmRzXCIsIHMsIGUsIGUuRnBGbkxFKSwgeyBGcDogciwgRm46IG4gfSA9IHQ7XG4gIGxldCBpID0gdC5DVVJWRTtcbiAgY29uc3QgeyBoOiBvIH0gPSBpO1xuICBSaShlLCB7fSwgeyB1dlJhdGlvOiBcImZ1bmN0aW9uXCIgfSk7XG4gIGNvbnN0IGEgPSBXYSA8PCBCaWdJbnQobi5CWVRFUyAqIDgpIC0genQsIGwgPSAoRSkgPT4gci5jcmVhdGUoRSksIGMgPSBlLnV2UmF0aW8gfHwgKChFLCBiKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IGlzVmFsaWQ6ICEwLCB2YWx1ZTogci5zcXJ0KHIuZGl2KEUsIGIpKSB9O1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIHsgaXNWYWxpZDogITEsIHZhbHVlOiB4cyB9O1xuICAgIH1cbiAgfSk7XG4gIGlmICgheXkociwgaSwgaS5HeCwgaS5HeSkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIGN1cnZlIHBhcmFtczogZ2VuZXJhdG9yIHBvaW50XCIpO1xuICBmdW5jdGlvbiB1KEUsIGIsIFIgPSAhMSkge1xuICAgIGNvbnN0IEEgPSBSID8genQgOiB4cztcbiAgICByZXR1cm4gUWwoXCJjb29yZGluYXRlIFwiICsgRSwgYiwgQSwgYSksIGI7XG4gIH1cbiAgZnVuY3Rpb24gZChFKSB7XG4gICAgaWYgKCEoRSBpbnN0YW5jZW9mIHApKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXh0ZW5kZWRQb2ludCBleHBlY3RlZFwiKTtcbiAgfVxuICBjb25zdCBoID0gTW8oKEUsIGIpID0+IHtcbiAgICBjb25zdCB7IFg6IFIsIFk6IEEsIFo6IEYgfSA9IEUsIE0gPSBFLmlzMCgpO1xuICAgIGIgPT0gbnVsbCAmJiAoYiA9IE0gPyBteSA6IHIuaW52KEYpKTtcbiAgICBjb25zdCBIID0gbChSICogYiksIEsgPSBsKEEgKiBiKSwgaiA9IHIubXVsKEYsIGIpO1xuICAgIGlmIChNKVxuICAgICAgcmV0dXJuIHsgeDogeHMsIHk6IHp0IH07XG4gICAgaWYgKGogIT09IHp0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52WiB3YXMgaW52YWxpZFwiKTtcbiAgICByZXR1cm4geyB4OiBILCB5OiBLIH07XG4gIH0pLCBmID0gTW8oKEUpID0+IHtcbiAgICBjb25zdCB7IGE6IGIsIGQ6IFIgfSA9IGk7XG4gICAgaWYgKEUuaXMwKCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcG9pbnQ6IFpFUk9cIik7XG4gICAgY29uc3QgeyBYOiBBLCBZOiBGLCBaOiBNLCBUOiBIIH0gPSBFLCBLID0gbChBICogQSksIGogPSBsKEYgKiBGKSwgQyA9IGwoTSAqIE0pLCBrID0gbChDICogQyksICQgPSBsKEsgKiBiKSwgVyA9IGwoQyAqIGwoJCArIGopKSwgXyA9IGwoayArIGwoUiAqIGwoSyAqIGopKSk7XG4gICAgaWYgKFcgIT09IF8pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQgKDEpXCIpO1xuICAgIGNvbnN0IGcgPSBsKEEgKiBGKSwgeCA9IGwoTSAqIEgpO1xuICAgIGlmIChnICE9PSB4KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0ICgyKVwiKTtcbiAgICByZXR1cm4gITA7XG4gIH0pO1xuICBjbGFzcyBwIHtcbiAgICBjb25zdHJ1Y3RvcihiLCBSLCBBLCBGKSB7XG4gICAgICB0aGlzLlggPSB1KFwieFwiLCBiKSwgdGhpcy5ZID0gdShcInlcIiwgUiksIHRoaXMuWiA9IHUoXCJ6XCIsIEEsICEwKSwgdGhpcy5UID0gdShcInRcIiwgRiksIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIHN0YXRpYyBDVVJWRSgpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFmZmluZShiKSB7XG4gICAgICBpZiAoYiBpbnN0YW5jZW9mIHApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImV4dGVuZGVkIHBvaW50IG5vdCBhbGxvd2VkXCIpO1xuICAgICAgY29uc3QgeyB4OiBSLCB5OiBBIH0gPSBiIHx8IHt9O1xuICAgICAgcmV0dXJuIHUoXCJ4XCIsIFIpLCB1KFwieVwiLCBBKSwgbmV3IHAoUiwgQSwgenQsIGwoUiAqIEEpKTtcbiAgICB9XG4gICAgLy8gVXNlcyBhbGdvIGZyb20gUkZDODAzMiA1LjEuMy5cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKGIsIFIgPSAhMSkge1xuICAgICAgY29uc3QgQSA9IHIuQllURVMsIHsgYTogRiwgZDogTSB9ID0gaTtcbiAgICAgIGIgPSBmZChPcihiLCBBLCBcInBvaW50XCIpKSwgWHMoUiwgXCJ6aXAyMTVcIik7XG4gICAgICBjb25zdCBIID0gZmQoYiksIEsgPSBiW0EgLSAxXTtcbiAgICAgIEhbQSAtIDFdID0gSyAmIC0xMjk7XG4gICAgICBjb25zdCBqID0gZWkoSCksIEMgPSBSID8gYSA6IHIuT1JERVI7XG4gICAgICBRbChcInBvaW50LnlcIiwgaiwgeHMsIEMpO1xuICAgICAgY29uc3QgayA9IGwoaiAqIGopLCAkID0gbChrIC0genQpLCBXID0gbChNICogayAtIEYpO1xuICAgICAgbGV0IHsgaXNWYWxpZDogXywgdmFsdWU6IGcgfSA9IGMoJCwgVyk7XG4gICAgICBpZiAoIV8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBwb2ludDogaW52YWxpZCB5IGNvb3JkaW5hdGVcIik7XG4gICAgICBjb25zdCB4ID0gKGcgJiB6dCkgPT09IHp0LCB3ID0gKEsgJiAxMjgpICE9PSAwO1xuICAgICAgaWYgKCFSICYmIGcgPT09IHhzICYmIHcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBwb2ludDogeD0wIGFuZCB4XzA9MVwiKTtcbiAgICAgIHJldHVybiB3ICE9PSB4ICYmIChnID0gbCgtZykpLCBwLmZyb21BZmZpbmUoeyB4OiBnLCB5OiBqIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhleChiLCBSID0gITEpIHtcbiAgICAgIHJldHVybiBwLmZyb21CeXRlcyhFdChcInBvaW50XCIsIGIpLCBSKTtcbiAgICB9XG4gICAgZ2V0IHgoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgfVxuICAgIGdldCB5KCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgIH1cbiAgICBwcmVjb21wdXRlKGIgPSA4LCBSID0gITApIHtcbiAgICAgIHJldHVybiB5LmNyZWF0ZUNhY2hlKHRoaXMsIGIpLCBSIHx8IHRoaXMubXVsdGlwbHkoV2EpLCB0aGlzO1xuICAgIH1cbiAgICAvLyBVc2VmdWwgaW4gZnJvbUFmZmluZSgpIC0gbm90IGZvciBmcm9tQnl0ZXMoKSwgd2hpY2ggYWx3YXlzIGNyZWF0ZWQgdmFsaWQgcG9pbnRzLlxuICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgZih0aGlzKTtcbiAgICB9XG4gICAgLy8gQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci5cbiAgICBlcXVhbHMoYikge1xuICAgICAgZChiKTtcbiAgICAgIGNvbnN0IHsgWDogUiwgWTogQSwgWjogRiB9ID0gdGhpcywgeyBYOiBNLCBZOiBILCBaOiBLIH0gPSBiLCBqID0gbChSICogSyksIEMgPSBsKE0gKiBGKSwgayA9IGwoQSAqIEspLCAkID0gbChIICogRik7XG4gICAgICByZXR1cm4gaiA9PT0gQyAmJiBrID09PSAkO1xuICAgIH1cbiAgICBpczAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lcXVhbHMocC5aRVJPKTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgcmV0dXJuIG5ldyBwKGwoLXRoaXMuWCksIHRoaXMuWSwgdGhpcy5aLCBsKC10aGlzLlQpKTtcbiAgICB9XG4gICAgLy8gRmFzdCBhbGdvIGZvciBkb3VibGluZyBFeHRlbmRlZCBQb2ludC5cbiAgICAvLyBodHRwczovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLmh0bWwjZG91YmxpbmctZGJsLTIwMDgtaHdjZFxuICAgIC8vIENvc3Q6IDRNICsgNFMgKyAxKmEgKyA2YWRkICsgMSoyLlxuICAgIGRvdWJsZSgpIHtcbiAgICAgIGNvbnN0IHsgYTogYiB9ID0gaSwgeyBYOiBSLCBZOiBBLCBaOiBGIH0gPSB0aGlzLCBNID0gbChSICogUiksIEggPSBsKEEgKiBBKSwgSyA9IGwoV2EgKiBsKEYgKiBGKSksIGogPSBsKGIgKiBNKSwgQyA9IFIgKyBBLCBrID0gbChsKEMgKiBDKSAtIE0gLSBIKSwgJCA9IGogKyBILCBXID0gJCAtIEssIF8gPSBqIC0gSCwgZyA9IGwoayAqIFcpLCB4ID0gbCgkICogXyksIHcgPSBsKGsgKiBfKSwgRCA9IGwoVyAqICQpO1xuICAgICAgcmV0dXJuIG5ldyBwKGcsIHgsIEQsIHcpO1xuICAgIH1cbiAgICAvLyBGYXN0IGFsZ28gZm9yIGFkZGluZyAyIEV4dGVuZGVkIFBvaW50cy5cbiAgICAvLyBodHRwczovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLmh0bWwjYWRkaXRpb24tYWRkLTIwMDgtaHdjZFxuICAgIC8vIENvc3Q6IDlNICsgMSphICsgMSpkICsgN2FkZC5cbiAgICBhZGQoYikge1xuICAgICAgZChiKTtcbiAgICAgIGNvbnN0IHsgYTogUiwgZDogQSB9ID0gaSwgeyBYOiBGLCBZOiBNLCBaOiBILCBUOiBLIH0gPSB0aGlzLCB7IFg6IGosIFk6IEMsIFo6IGssIFQ6ICQgfSA9IGIsIFcgPSBsKEYgKiBqKSwgXyA9IGwoTSAqIEMpLCBnID0gbChLICogQSAqICQpLCB4ID0gbChIICogayksIHcgPSBsKChGICsgTSkgKiAoaiArIEMpIC0gVyAtIF8pLCBEID0geCAtIGcsIE8gPSB4ICsgZywgVSA9IGwoXyAtIFIgKiBXKSwgViA9IGwodyAqIEQpLCBMID0gbChPICogVSksIG0gPSBsKHcgKiBVKSwgdiA9IGwoRCAqIE8pO1xuICAgICAgcmV0dXJuIG5ldyBwKFYsIEwsIHYsIG0pO1xuICAgIH1cbiAgICBzdWJ0cmFjdChiKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGQoYi5uZWdhdGUoKSk7XG4gICAgfVxuICAgIC8vIENvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgbXVsdGlwbHkoYikge1xuICAgICAgaWYgKCFuLmlzVmFsaWROb3QwKGIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNjYWxhcjogZXhwZWN0ZWQgMSA8PSBzYyA8IGN1cnZlLm5cIik7XG4gICAgICBjb25zdCB7IHA6IFIsIGY6IEEgfSA9IHkuY2FjaGVkKHRoaXMsIGIsIChGKSA9PiBqcyhwLCBGKSk7XG4gICAgICByZXR1cm4ganMocCwgW1IsIEFdKVswXTtcbiAgICB9XG4gICAgLy8gTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgIC8vIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgLy8gYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24uXG4gICAgLy8gRG9lcyBOT1QgYWxsb3cgc2NhbGFycyBoaWdoZXIgdGhhbiBDVVJWRS5uLlxuICAgIC8vIEFjY2VwdHMgb3B0aW9uYWwgYWNjdW11bGF0b3IgdG8gbWVyZ2Ugd2l0aCBtdWx0aXBseSAoaW1wb3J0YW50IGZvciBzcGFyc2Ugc2NhbGFycylcbiAgICBtdWx0aXBseVVuc2FmZShiLCBSID0gcC5aRVJPKSB7XG4gICAgICBpZiAoIW4uaXNWYWxpZChiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzY2FsYXI6IGV4cGVjdGVkIDAgPD0gc2MgPCBjdXJ2ZS5uXCIpO1xuICAgICAgcmV0dXJuIGIgPT09IHhzID8gcC5aRVJPIDogdGhpcy5pczAoKSB8fCBiID09PSB6dCA/IHRoaXMgOiB5LnVuc2FmZSh0aGlzLCBiLCAoQSkgPT4ganMocCwgQSksIFIpO1xuICAgIH1cbiAgICAvLyBDaGVja3MgaWYgcG9pbnQgaXMgb2Ygc21hbGwgb3JkZXIuXG4gICAgLy8gSWYgeW91IGFkZCBzb21ldGhpbmcgdG8gc21hbGwgb3JkZXIgcG9pbnQsIHlvdSB3aWxsIGhhdmUgXCJkaXJ0eVwiXG4gICAgLy8gcG9pbnQgd2l0aCB0b3JzaW9uIGNvbXBvbmVudC5cbiAgICAvLyBNdWx0aXBsaWVzIHBvaW50IGJ5IGNvZmFjdG9yIGFuZCBjaGVja3MgaWYgdGhlIHJlc3VsdCBpcyAwLlxuICAgIGlzU21hbGxPcmRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKG8pLmlzMCgpO1xuICAgIH1cbiAgICAvLyBNdWx0aXBsaWVzIHBvaW50IGJ5IGN1cnZlIG9yZGVyIGFuZCBjaGVja3MgaWYgdGhlIHJlc3VsdCBpcyAwLlxuICAgIC8vIFJldHVybnMgYGZhbHNlYCBpcyB0aGUgcG9pbnQgaXMgZGlydHkuXG4gICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgIHJldHVybiB5LnVuc2FmZSh0aGlzLCBpLm4pLmlzMCgpO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0cyBFeHRlbmRlZCBwb2ludCB0byBkZWZhdWx0ICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICB0b0FmZmluZShiKSB7XG4gICAgICByZXR1cm4gaCh0aGlzLCBiKTtcbiAgICB9XG4gICAgY2xlYXJDb2ZhY3RvcigpIHtcbiAgICAgIHJldHVybiBvID09PSB6dCA/IHRoaXMgOiB0aGlzLm11bHRpcGx5VW5zYWZlKG8pO1xuICAgIH1cbiAgICB0b0J5dGVzKCkge1xuICAgICAgY29uc3QgeyB4OiBiLCB5OiBSIH0gPSB0aGlzLnRvQWZmaW5lKCksIEEgPSByLnRvQnl0ZXMoUik7XG4gICAgICByZXR1cm4gQVtBLmxlbmd0aCAtIDFdIHw9IGIgJiB6dCA/IDEyOCA6IDAsIEE7XG4gICAgfVxuICAgIHRvSGV4KCkge1xuICAgICAgcmV0dXJuIEhzKHRoaXMudG9CeXRlcygpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYDxQb2ludCAke3RoaXMuaXMwKCkgPyBcIlpFUk9cIiA6IHRoaXMudG9IZXgoKX0+YDtcbiAgICB9XG4gICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgZ2V0IGV4KCkge1xuICAgICAgcmV0dXJuIHRoaXMuWDtcbiAgICB9XG4gICAgZ2V0IGV5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuWTtcbiAgICB9XG4gICAgZ2V0IGV6KCkge1xuICAgICAgcmV0dXJuIHRoaXMuWjtcbiAgICB9XG4gICAgZ2V0IGV0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuVDtcbiAgICB9XG4gICAgc3RhdGljIG5vcm1hbGl6ZVooYikge1xuICAgICAgcmV0dXJuIGpzKHAsIGIpO1xuICAgIH1cbiAgICBzdGF0aWMgbXNtKGIsIFIpIHtcbiAgICAgIHJldHVybiBwMChwLCBuLCBiLCBSKTtcbiAgICB9XG4gICAgX3NldFdpbmRvd1NpemUoYikge1xuICAgICAgdGhpcy5wcmVjb21wdXRlKGIpO1xuICAgIH1cbiAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9CeXRlcygpO1xuICAgIH1cbiAgfVxuICBwLkJBU0UgPSBuZXcgcChpLkd4LCBpLkd5LCB6dCwgbChpLkd4ICogaS5HeSkpLCBwLlpFUk8gPSBuZXcgcCh4cywgenQsIHp0LCB4cyksIHAuRnAgPSByLCBwLkZuID0gbjtcbiAgY29uc3QgeSA9IG5ldyBnMChwLCBuLkJJVFMpO1xuICByZXR1cm4gcC5CQVNFLnByZWNvbXB1dGUoOCksIHA7XG59XG5mdW5jdGlvbiBFeShzLCBlLCB0ID0ge30pIHtcbiAgaWYgKHR5cGVvZiBlICE9IFwiZnVuY3Rpb25cIilcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiaGFzaFwiIGZ1bmN0aW9uIHBhcmFtIGlzIHJlcXVpcmVkJyk7XG4gIFJpKHQsIHt9LCB7XG4gICAgYWRqdXN0U2NhbGFyQnl0ZXM6IFwiZnVuY3Rpb25cIixcbiAgICByYW5kb21CeXRlczogXCJmdW5jdGlvblwiLFxuICAgIGRvbWFpbjogXCJmdW5jdGlvblwiLFxuICAgIHByZWhhc2g6IFwiZnVuY3Rpb25cIixcbiAgICBtYXBUb0N1cnZlOiBcImZ1bmN0aW9uXCJcbiAgfSk7XG4gIGNvbnN0IHsgcHJlaGFzaDogciB9ID0gdCwgeyBCQVNFOiBuLCBGcDogaSwgRm46IG8gfSA9IHMsIGEgPSB0LnJhbmRvbUJ5dGVzIHx8IHFjLCBsID0gdC5hZGp1c3RTY2FsYXJCeXRlcyB8fCAoKEMpID0+IEMpLCBjID0gdC5kb21haW4gfHwgKChDLCBrLCAkKSA9PiB7XG4gICAgaWYgKFhzKCQsIFwicGhmbGFnXCIpLCBrLmxlbmd0aCB8fCAkKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGV4dHMvcHJlLWhhc2ggYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgcmV0dXJuIEM7XG4gIH0pO1xuICBmdW5jdGlvbiB1KEMpIHtcbiAgICByZXR1cm4gby5jcmVhdGUoZWkoQykpO1xuICB9XG4gIGZ1bmN0aW9uIGQoQykge1xuICAgIGNvbnN0IGsgPSBBLnNlY3JldEtleTtcbiAgICBDID0gRXQoXCJwcml2YXRlIGtleVwiLCBDLCBrKTtcbiAgICBjb25zdCAkID0gRXQoXCJoYXNoZWQgcHJpdmF0ZSBrZXlcIiwgZShDKSwgMiAqIGspLCBXID0gbCgkLnNsaWNlKDAsIGspKSwgXyA9ICQuc2xpY2UoaywgMiAqIGspLCBnID0gdShXKTtcbiAgICByZXR1cm4geyBoZWFkOiBXLCBwcmVmaXg6IF8sIHNjYWxhcjogZyB9O1xuICB9XG4gIGZ1bmN0aW9uIGgoQykge1xuICAgIGNvbnN0IHsgaGVhZDogaywgcHJlZml4OiAkLCBzY2FsYXI6IFcgfSA9IGQoQyksIF8gPSBuLm11bHRpcGx5KFcpLCBnID0gXy50b0J5dGVzKCk7XG4gICAgcmV0dXJuIHsgaGVhZDogaywgcHJlZml4OiAkLCBzY2FsYXI6IFcsIHBvaW50OiBfLCBwb2ludEJ5dGVzOiBnIH07XG4gIH1cbiAgZnVuY3Rpb24gZihDKSB7XG4gICAgcmV0dXJuIGgoQykucG9pbnRCeXRlcztcbiAgfVxuICBmdW5jdGlvbiBwKEMgPSBVaW50OEFycmF5Lm9mKCksIC4uLmspIHtcbiAgICBjb25zdCAkID0gS3IoLi4uayk7XG4gICAgcmV0dXJuIHUoZShjKCQsIEV0KFwiY29udGV4dFwiLCBDKSwgISFyKSkpO1xuICB9XG4gIGZ1bmN0aW9uIHkoQywgaywgJCA9IHt9KSB7XG4gICAgQyA9IEV0KFwibWVzc2FnZVwiLCBDKSwgciAmJiAoQyA9IHIoQykpO1xuICAgIGNvbnN0IHsgcHJlZml4OiBXLCBzY2FsYXI6IF8sIHBvaW50Qnl0ZXM6IGcgfSA9IGgoayksIHggPSBwKCQuY29udGV4dCwgVywgQyksIHcgPSBuLm11bHRpcGx5KHgpLnRvQnl0ZXMoKSwgRCA9IHAoJC5jb250ZXh0LCB3LCBnLCBDKSwgTyA9IG8uY3JlYXRlKHggKyBEICogXyk7XG4gICAgaWYgKCFvLmlzVmFsaWQoTykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaWduIGZhaWxlZDogaW52YWxpZCBzXCIpO1xuICAgIGNvbnN0IFUgPSBLcih3LCBvLnRvQnl0ZXMoTykpO1xuICAgIHJldHVybiBPcihVLCBBLnNpZ25hdHVyZSwgXCJyZXN1bHRcIik7XG4gIH1cbiAgY29uc3QgRSA9IHsgemlwMjE1OiAhMCB9O1xuICBmdW5jdGlvbiBiKEMsIGssICQsIFcgPSBFKSB7XG4gICAgY29uc3QgeyBjb250ZXh0OiBfLCB6aXAyMTU6IGcgfSA9IFcsIHggPSBBLnNpZ25hdHVyZTtcbiAgICBDID0gRXQoXCJzaWduYXR1cmVcIiwgQywgeCksIGsgPSBFdChcIm1lc3NhZ2VcIiwgayksICQgPSBFdChcInB1YmxpY0tleVwiLCAkLCBBLnB1YmxpY0tleSksIGcgIT09IHZvaWQgMCAmJiBYcyhnLCBcInppcDIxNVwiKSwgciAmJiAoayA9IHIoaykpO1xuICAgIGNvbnN0IHcgPSB4IC8gMiwgRCA9IEMuc3ViYXJyYXkoMCwgdyksIE8gPSBlaShDLnN1YmFycmF5KHcsIHgpKTtcbiAgICBsZXQgVSwgViwgTDtcbiAgICB0cnkge1xuICAgICAgVSA9IHMuZnJvbUJ5dGVzKCQsIGcpLCBWID0gcy5mcm9tQnl0ZXMoRCwgZyksIEwgPSBuLm11bHRpcGx5VW5zYWZlKE8pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuICExO1xuICAgIH1cbiAgICBpZiAoIWcgJiYgVS5pc1NtYWxsT3JkZXIoKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBtID0gcChfLCBWLnRvQnl0ZXMoKSwgVS50b0J5dGVzKCksIGspO1xuICAgIHJldHVybiBWLmFkZChVLm11bHRpcGx5VW5zYWZlKG0pKS5zdWJ0cmFjdChMKS5jbGVhckNvZmFjdG9yKCkuaXMwKCk7XG4gIH1cbiAgY29uc3QgUiA9IGkuQllURVMsIEEgPSB7XG4gICAgc2VjcmV0S2V5OiBSLFxuICAgIHB1YmxpY0tleTogUixcbiAgICBzaWduYXR1cmU6IDIgKiBSLFxuICAgIHNlZWQ6IFJcbiAgfTtcbiAgZnVuY3Rpb24gRihDID0gYShBLnNlZWQpKSB7XG4gICAgcmV0dXJuIE9yKEMsIEEuc2VlZCwgXCJzZWVkXCIpO1xuICB9XG4gIGZ1bmN0aW9uIE0oQykge1xuICAgIGNvbnN0IGsgPSBqLnJhbmRvbVNlY3JldEtleShDKTtcbiAgICByZXR1cm4geyBzZWNyZXRLZXk6IGssIHB1YmxpY0tleTogZihrKSB9O1xuICB9XG4gIGZ1bmN0aW9uIEgoQykge1xuICAgIHJldHVybiBJaShDKSAmJiBDLmxlbmd0aCA9PT0gby5CWVRFUztcbiAgfVxuICBmdW5jdGlvbiBLKEMsIGspIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuICEhcy5mcm9tQnl0ZXMoQywgayk7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICB9XG4gIGNvbnN0IGogPSB7XG4gICAgZ2V0RXh0ZW5kZWRQdWJsaWNLZXk6IGgsXG4gICAgcmFuZG9tU2VjcmV0S2V5OiBGLFxuICAgIGlzVmFsaWRTZWNyZXRLZXk6IEgsXG4gICAgaXNWYWxpZFB1YmxpY0tleTogSyxcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBlZCBwdWJsaWMga2V5IHRvIHggcHVibGljIGtleS4gVXNlcyBmb3JtdWxhOlxuICAgICAqIC0gZWQyNTUxOTpcbiAgICAgKiAgIC0gYCh1LCB2KSA9ICgoMSt5KS8oMS15KSwgc3FydCgtNDg2NjY0KSp1L3gpYFxuICAgICAqICAgLSBgKHgsIHkpID0gKHNxcnQoLTQ4NjY2NCkqdS92LCAodS0xKS8odSsxKSlgXG4gICAgICogLSBlZDQ0ODpcbiAgICAgKiAgIC0gYCh1LCB2KSA9ICgoeS0xKS8oeSsxKSwgc3FydCgxNTYzMjQpKnUveClgXG4gICAgICogICAtIGAoeCwgeSkgPSAoc3FydCgxNTYzMjQpKnUvdiwgKDErdSkvKDEtdSkpYFxuICAgICAqL1xuICAgIHRvTW9udGdvbWVyeShDKSB7XG4gICAgICBjb25zdCB7IHk6IGsgfSA9IHMuZnJvbUJ5dGVzKEMpLCAkID0gQS5wdWJsaWNLZXksIFcgPSAkID09PSAzMjtcbiAgICAgIGlmICghVyAmJiAkICE9PSA1NylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25seSBkZWZpbmVkIGZvciAyNTUxOSBhbmQgNDQ4XCIpO1xuICAgICAgY29uc3QgXyA9IFcgPyBpLmRpdih6dCArIGssIHp0IC0gaykgOiBpLmRpdihrIC0genQsIGsgKyB6dCk7XG4gICAgICByZXR1cm4gaS50b0J5dGVzKF8pO1xuICAgIH0sXG4gICAgdG9Nb250Z29tZXJ5U2VjcmV0KEMpIHtcbiAgICAgIGNvbnN0IGsgPSBBLnNlY3JldEtleTtcbiAgICAgIE9yKEMsIGspO1xuICAgICAgY29uc3QgJCA9IGUoQy5zdWJhcnJheSgwLCBrKSk7XG4gICAgICByZXR1cm4gbCgkKS5zdWJhcnJheSgwLCBrKTtcbiAgICB9LFxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIHJhbmRvbVByaXZhdGVLZXk6IEYsXG4gICAgLyoqIEBkZXByZWNhdGVkICovXG4gICAgcHJlY29tcHV0ZShDID0gOCwgayA9IHMuQkFTRSkge1xuICAgICAgcmV0dXJuIGsucHJlY29tcHV0ZShDLCAhMSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAga2V5Z2VuOiBNLFxuICAgIGdldFB1YmxpY0tleTogZixcbiAgICBzaWduOiB5LFxuICAgIHZlcmlmeTogYixcbiAgICB1dGlsczogaixcbiAgICBQb2ludDogcyxcbiAgICBsZW5ndGhzOiBBXG4gIH0pO1xufVxuZnVuY3Rpb24geHkocykge1xuICBjb25zdCBlID0ge1xuICAgIGE6IHMuYSxcbiAgICBkOiBzLmQsXG4gICAgcDogcy5GcC5PUkRFUixcbiAgICBuOiBzLm4sXG4gICAgaDogcy5oLFxuICAgIEd4OiBzLkd4LFxuICAgIEd5OiBzLkd5XG4gIH0sIHQgPSBzLkZwLCByID0gZW4oZS5uLCBzLm5CaXRMZW5ndGgsICEwKSwgbiA9IHsgRnA6IHQsIEZuOiByLCB1dlJhdGlvOiBzLnV2UmF0aW8gfSwgaSA9IHtcbiAgICByYW5kb21CeXRlczogcy5yYW5kb21CeXRlcyxcbiAgICBhZGp1c3RTY2FsYXJCeXRlczogcy5hZGp1c3RTY2FsYXJCeXRlcyxcbiAgICBkb21haW46IHMuZG9tYWluLFxuICAgIHByZWhhc2g6IHMucHJlaGFzaCxcbiAgICBtYXBUb0N1cnZlOiBzLm1hcFRvQ3VydmVcbiAgfTtcbiAgcmV0dXJuIHsgQ1VSVkU6IGUsIGN1cnZlT3B0czogbiwgaGFzaDogcy5oYXNoLCBlZGRzYU9wdHM6IGkgfTtcbn1cbmZ1bmN0aW9uIFN5KHMsIGUpIHtcbiAgY29uc3QgdCA9IGUuUG9pbnQ7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBlLCB7XG4gICAgRXh0ZW5kZWRQb2ludDogdCxcbiAgICBDVVJWRTogcyxcbiAgICBuQml0TGVuZ3RoOiB0LkZuLkJJVFMsXG4gICAgbkJ5dGVMZW5ndGg6IHQuRm4uQllURVNcbiAgfSk7XG59XG5mdW5jdGlvbiBieShzKSB7XG4gIGNvbnN0IHsgQ1VSVkU6IGUsIGN1cnZlT3B0czogdCwgaGFzaDogciwgZWRkc2FPcHRzOiBuIH0gPSB4eShzKSwgaSA9IHZ5KGUsIHQpLCBvID0gRXkoaSwgciwgbik7XG4gIHJldHVybiBTeShzLCBvKTtcbn1cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IFR5ID0gQmlnSW50KDEpLCBFZCA9IEJpZ0ludCgyKTtcbkJpZ0ludCgzKTtcbmNvbnN0IHd5ID0gQmlnSW50KDUpLCBBeSA9IEJpZ0ludCg4KSwgWmMgPSBCaWdJbnQoXCIweDdmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWRcIiksIHkwID0ge1xuICBwOiBaYyxcbiAgbjogQmlnSW50KFwiMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE0ZGVmOWRlYTJmNzljZDY1ODEyNjMxYTVjZjVkM2VkXCIpLFxuICBoOiBBeSxcbiAgYTogQmlnSW50KFwiMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVjXCIpLFxuICBkOiBCaWdJbnQoXCIweDUyMDM2Y2VlMmI2ZmZlNzM4Y2M3NDA3OTc3NzllODk4MDA3MDBhNGQ0MTQxZDhhYjc1ZWI0ZGNhMTM1OTc4YTNcIiksXG4gIEd4OiBCaWdJbnQoXCIweDIxNjkzNmQzY2Q2ZTUzZmVjMGE0ZTIzMWZkZDZkYzVjNjkyY2M3NjA5NTI1YTdiMmM5NTYyZDYwOGYyNWQ1MWFcIiksXG4gIEd5OiBCaWdJbnQoXCIweDY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NThcIilcbn07XG5mdW5jdGlvbiBJeShzKSB7XG4gIGNvbnN0IGUgPSBCaWdJbnQoMTApLCB0ID0gQmlnSW50KDIwKSwgciA9IEJpZ0ludCg0MCksIG4gPSBCaWdJbnQoODApLCBpID0gWmMsIGEgPSBzICogcyAlIGkgKiBzICUgaSwgbCA9IHZ0KGEsIEVkLCBpKSAqIGEgJSBpLCBjID0gdnQobCwgVHksIGkpICogcyAlIGksIHUgPSB2dChjLCB3eSwgaSkgKiBjICUgaSwgZCA9IHZ0KHUsIGUsIGkpICogdSAlIGksIGggPSB2dChkLCB0LCBpKSAqIGQgJSBpLCBmID0gdnQoaCwgciwgaSkgKiBoICUgaSwgcCA9IHZ0KGYsIG4sIGkpICogZiAlIGksIHkgPSB2dChwLCBuLCBpKSAqIGYgJSBpLCBFID0gdnQoeSwgZSwgaSkgKiB1ICUgaTtcbiAgcmV0dXJuIHsgcG93X3BfNV84OiB2dChFLCBFZCwgaSkgKiBzICUgaSwgYjI6IGEgfTtcbn1cbmZ1bmN0aW9uIF95KHMpIHtcbiAgcmV0dXJuIHNbMF0gJj0gMjQ4LCBzWzMxXSAmPSAxMjcsIHNbMzFdIHw9IDY0LCBzO1xufVxuY29uc3QgeGQgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KFwiMTk2ODExNjEzNzY3MDc1MDU5NTY4MDcwNzkzMDQ5ODg1NDIwMTU0NDYwNjY1MTU5MjM4OTAxNjI3NDQwMjEwNzMxMjM4Mjk3ODQ3NTJcIik7XG5mdW5jdGlvbiBSeShzLCBlKSB7XG4gIGNvbnN0IHQgPSBaYywgciA9IEd0KGUgKiBlICogZSwgdCksIG4gPSBHdChyICogciAqIGUsIHQpLCBpID0gSXkocyAqIG4pLnBvd19wXzVfODtcbiAgbGV0IG8gPSBHdChzICogciAqIGksIHQpO1xuICBjb25zdCBhID0gR3QoZSAqIG8gKiBvLCB0KSwgbCA9IG8sIGMgPSBHdChvICogeGQsIHQpLCB1ID0gYSA9PT0gcywgZCA9IGEgPT09IEd0KC1zLCB0KSwgaCA9IGEgPT09IEd0KC1zICogeGQsIHQpO1xuICByZXR1cm4gdSAmJiAobyA9IGwpLCAoZCB8fCBoKSAmJiAobyA9IGMpLCBseShvLCB0KSAmJiAobyA9IEd0KC1vLCB0KSksIHsgaXNWYWxpZDogdSB8fCBkLCB2YWx1ZTogbyB9O1xufVxuY29uc3QgTHkgPSBlbih5MC5wLCB7IGlzTEU6ICEwIH0pLCBDeSA9IHtcbiAgLi4ueTAsXG4gIEZwOiBMeSxcbiAgaGFzaDogZXksXG4gIGFkanVzdFNjYWxhckJ5dGVzOiBfeSxcbiAgLy8gZG9tMlxuICAvLyBSYXRpbyBvZiB1IHRvIHYuIEFsbG93cyB1cyB0byBjb21iaW5lIGludmVyc2lvbiBhbmQgc3F1YXJlIHJvb3QuIFVzZXMgYWxnbyBmcm9tIFJGQzgwMzIgNS4xLjMuXG4gIC8vIENvbnN0YW50LXRpbWUsIHUv4oiadlxuICB1dlJhdGlvOiBSeVxufSwgTGkgPSBieShDeSk7XG52YXIgY28gPSB7IGV4cG9ydHM6IHt9IH07XG5jb25zdCBreSA9IHt9LCBEeSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGRlZmF1bHQ6IGt5XG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBQeSA9IC8qIEBfX1BVUkVfXyAqLyBOYyhEeSk7XG52YXIgTXkgPSBjby5leHBvcnRzLCBTZDtcbmZ1bmN0aW9uIHYwKCkge1xuICByZXR1cm4gU2QgfHwgKFNkID0gMSwgKGZ1bmN0aW9uKHMpIHtcbiAgICAoZnVuY3Rpb24oZSwgdCkge1xuICAgICAgZnVuY3Rpb24gcihfLCBnKSB7XG4gICAgICAgIGlmICghXykgdGhyb3cgbmV3IEVycm9yKGcgfHwgXCJBc3NlcnRpb24gZmFpbGVkXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbihfLCBnKSB7XG4gICAgICAgIF8uc3VwZXJfID0gZztcbiAgICAgICAgdmFyIHggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgfTtcbiAgICAgICAgeC5wcm90b3R5cGUgPSBnLnByb3RvdHlwZSwgXy5wcm90b3R5cGUgPSBuZXcgeCgpLCBfLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IF87XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpKF8sIGcsIHgpIHtcbiAgICAgICAgaWYgKGkuaXNCTihfKSlcbiAgICAgICAgICByZXR1cm4gXztcbiAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDAsIHRoaXMud29yZHMgPSBudWxsLCB0aGlzLmxlbmd0aCA9IDAsIHRoaXMucmVkID0gbnVsbCwgXyAhPT0gbnVsbCAmJiAoKGcgPT09IFwibGVcIiB8fCBnID09PSBcImJlXCIpICYmICh4ID0gZywgZyA9IDEwKSwgdGhpcy5faW5pdChfIHx8IDAsIGcgfHwgMTAsIHggfHwgXCJiZVwiKSk7XG4gICAgICB9XG4gICAgICB0eXBlb2YgZSA9PSBcIm9iamVjdFwiID8gZS5leHBvcnRzID0gaSA6IHQuQk4gPSBpLCBpLkJOID0gaSwgaS53b3JkU2l6ZSA9IDI2O1xuICAgICAgdmFyIG87XG4gICAgICB0cnkge1xuICAgICAgICB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgdHlwZW9mIHdpbmRvdy5CdWZmZXIgPCBcInVcIiA/IG8gPSB3aW5kb3cuQnVmZmVyIDogbyA9IFB5LkJ1ZmZlcjtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgaS5pc0JOID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gZyBpbnN0YW5jZW9mIGkgPyAhMCA6IGcgIT09IG51bGwgJiYgdHlwZW9mIGcgPT0gXCJvYmplY3RcIiAmJiBnLmNvbnN0cnVjdG9yLndvcmRTaXplID09PSBpLndvcmRTaXplICYmIEFycmF5LmlzQXJyYXkoZy53b3Jkcyk7XG4gICAgICB9LCBpLm1heCA9IGZ1bmN0aW9uKGcsIHgpIHtcbiAgICAgICAgcmV0dXJuIGcuY21wKHgpID4gMCA/IGcgOiB4O1xuICAgICAgfSwgaS5taW4gPSBmdW5jdGlvbihnLCB4KSB7XG4gICAgICAgIHJldHVybiBnLmNtcCh4KSA8IDAgPyBnIDogeDtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24oZywgeCwgdykge1xuICAgICAgICBpZiAodHlwZW9mIGcgPT0gXCJudW1iZXJcIilcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW5pdE51bWJlcihnLCB4LCB3KTtcbiAgICAgICAgaWYgKHR5cGVvZiBnID09IFwib2JqZWN0XCIpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShnLCB4LCB3KTtcbiAgICAgICAgeCA9PT0gXCJoZXhcIiAmJiAoeCA9IDE2KSwgcih4ID09PSAoeCB8IDApICYmIHggPj0gMiAmJiB4IDw9IDM2KSwgZyA9IGcudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csIFwiXCIpO1xuICAgICAgICB2YXIgRCA9IDA7XG4gICAgICAgIGdbMF0gPT09IFwiLVwiICYmIChEKyssIHRoaXMubmVnYXRpdmUgPSAxKSwgRCA8IGcubGVuZ3RoICYmICh4ID09PSAxNiA/IHRoaXMuX3BhcnNlSGV4KGcsIEQsIHcpIDogKHRoaXMuX3BhcnNlQmFzZShnLCB4LCBEKSwgdyA9PT0gXCJsZVwiICYmIHRoaXMuX2luaXRBcnJheSh0aGlzLnRvQXJyYXkoKSwgeCwgdykpKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9pbml0TnVtYmVyID0gZnVuY3Rpb24oZywgeCwgdykge1xuICAgICAgICBnIDwgMCAmJiAodGhpcy5uZWdhdGl2ZSA9IDEsIGcgPSAtZyksIGcgPCA2NzEwODg2NCA/ICh0aGlzLndvcmRzID0gW2cgJiA2NzEwODg2M10sIHRoaXMubGVuZ3RoID0gMSkgOiBnIDwgNDUwMzU5OTYyNzM3MDQ5NiA/ICh0aGlzLndvcmRzID0gW1xuICAgICAgICAgIGcgJiA2NzEwODg2MyxcbiAgICAgICAgICBnIC8gNjcxMDg4NjQgJiA2NzEwODg2M1xuICAgICAgICBdLCB0aGlzLmxlbmd0aCA9IDIpIDogKHIoZyA8IDkwMDcxOTkyNTQ3NDA5OTIpLCB0aGlzLndvcmRzID0gW1xuICAgICAgICAgIGcgJiA2NzEwODg2MyxcbiAgICAgICAgICBnIC8gNjcxMDg4NjQgJiA2NzEwODg2MyxcbiAgICAgICAgICAxXG4gICAgICAgIF0sIHRoaXMubGVuZ3RoID0gMyksIHcgPT09IFwibGVcIiAmJiB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIHgsIHcpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2luaXRBcnJheSA9IGZ1bmN0aW9uKGcsIHgsIHcpIHtcbiAgICAgICAgaWYgKHIodHlwZW9mIGcubGVuZ3RoID09IFwibnVtYmVyXCIpLCBnLmxlbmd0aCA8PSAwKVxuICAgICAgICAgIHJldHVybiB0aGlzLndvcmRzID0gWzBdLCB0aGlzLmxlbmd0aCA9IDEsIHRoaXM7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKGcubGVuZ3RoIC8gMyksIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBEID0gMDsgRCA8IHRoaXMubGVuZ3RoOyBEKyspXG4gICAgICAgICAgdGhpcy53b3Jkc1tEXSA9IDA7XG4gICAgICAgIHZhciBPLCBVLCBWID0gMDtcbiAgICAgICAgaWYgKHcgPT09IFwiYmVcIilcbiAgICAgICAgICBmb3IgKEQgPSBnLmxlbmd0aCAtIDEsIE8gPSAwOyBEID49IDA7IEQgLT0gMylcbiAgICAgICAgICAgIFUgPSBnW0RdIHwgZ1tEIC0gMV0gPDwgOCB8IGdbRCAtIDJdIDw8IDE2LCB0aGlzLndvcmRzW09dIHw9IFUgPDwgViAmIDY3MTA4ODYzLCB0aGlzLndvcmRzW08gKyAxXSA9IFUgPj4+IDI2IC0gViAmIDY3MTA4ODYzLCBWICs9IDI0LCBWID49IDI2ICYmIChWIC09IDI2LCBPKyspO1xuICAgICAgICBlbHNlIGlmICh3ID09PSBcImxlXCIpXG4gICAgICAgICAgZm9yIChEID0gMCwgTyA9IDA7IEQgPCBnLmxlbmd0aDsgRCArPSAzKVxuICAgICAgICAgICAgVSA9IGdbRF0gfCBnW0QgKyAxXSA8PCA4IHwgZ1tEICsgMl0gPDwgMTYsIHRoaXMud29yZHNbT10gfD0gVSA8PCBWICYgNjcxMDg4NjMsIHRoaXMud29yZHNbTyArIDFdID0gVSA+Pj4gMjYgLSBWICYgNjcxMDg4NjMsIFYgKz0gMjQsIFYgPj0gMjYgJiYgKFYgLT0gMjYsIE8rKyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIGEoXywgZykge1xuICAgICAgICB2YXIgeCA9IF8uY2hhckNvZGVBdChnKTtcbiAgICAgICAgaWYgKHggPj0gNDggJiYgeCA8PSA1NylcbiAgICAgICAgICByZXR1cm4geCAtIDQ4O1xuICAgICAgICBpZiAoeCA+PSA2NSAmJiB4IDw9IDcwKVxuICAgICAgICAgIHJldHVybiB4IC0gNTU7XG4gICAgICAgIGlmICh4ID49IDk3ICYmIHggPD0gMTAyKVxuICAgICAgICAgIHJldHVybiB4IC0gODc7XG4gICAgICAgIHIoITEsIFwiSW52YWxpZCBjaGFyYWN0ZXIgaW4gXCIgKyBfKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGwoXywgZywgeCkge1xuICAgICAgICB2YXIgdyA9IGEoXywgeCk7XG4gICAgICAgIHJldHVybiB4IC0gMSA+PSBnICYmICh3IHw9IGEoXywgeCAtIDEpIDw8IDQpLCB3O1xuICAgICAgfVxuICAgICAgaS5wcm90b3R5cGUuX3BhcnNlSGV4ID0gZnVuY3Rpb24oZywgeCwgdykge1xuICAgICAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgoZy5sZW5ndGggLSB4KSAvIDYpLCB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgRCA9IDA7IEQgPCB0aGlzLmxlbmd0aDsgRCsrKVxuICAgICAgICAgIHRoaXMud29yZHNbRF0gPSAwO1xuICAgICAgICB2YXIgTyA9IDAsIFUgPSAwLCBWO1xuICAgICAgICBpZiAodyA9PT0gXCJiZVwiKVxuICAgICAgICAgIGZvciAoRCA9IGcubGVuZ3RoIC0gMTsgRCA+PSB4OyBEIC09IDIpXG4gICAgICAgICAgICBWID0gbChnLCB4LCBEKSA8PCBPLCB0aGlzLndvcmRzW1VdIHw9IFYgJiA2NzEwODg2MywgTyA+PSAxOCA/IChPIC09IDE4LCBVICs9IDEsIHRoaXMud29yZHNbVV0gfD0gViA+Pj4gMjYpIDogTyArPSA4O1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgTCA9IGcubGVuZ3RoIC0geDtcbiAgICAgICAgICBmb3IgKEQgPSBMICUgMiA9PT0gMCA/IHggKyAxIDogeDsgRCA8IGcubGVuZ3RoOyBEICs9IDIpXG4gICAgICAgICAgICBWID0gbChnLCB4LCBEKSA8PCBPLCB0aGlzLndvcmRzW1VdIHw9IFYgJiA2NzEwODg2MywgTyA+PSAxOCA/IChPIC09IDE4LCBVICs9IDEsIHRoaXMud29yZHNbVV0gfD0gViA+Pj4gMjYpIDogTyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gYyhfLCBnLCB4LCB3KSB7XG4gICAgICAgIGZvciAodmFyIEQgPSAwLCBPID0gMCwgVSA9IE1hdGgubWluKF8ubGVuZ3RoLCB4KSwgViA9IGc7IFYgPCBVOyBWKyspIHtcbiAgICAgICAgICB2YXIgTCA9IF8uY2hhckNvZGVBdChWKSAtIDQ4O1xuICAgICAgICAgIEQgKj0gdywgTCA+PSA0OSA/IE8gPSBMIC0gNDkgKyAxMCA6IEwgPj0gMTcgPyBPID0gTCAtIDE3ICsgMTAgOiBPID0gTCwgcihMID49IDAgJiYgTyA8IHcsIFwiSW52YWxpZCBjaGFyYWN0ZXJcIiksIEQgKz0gTztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRDtcbiAgICAgIH1cbiAgICAgIGkucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbihnLCB4LCB3KSB7XG4gICAgICAgIHRoaXMud29yZHMgPSBbMF0sIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgICAgZm9yICh2YXIgRCA9IDAsIE8gPSAxOyBPIDw9IDY3MTA4ODYzOyBPICo9IHgpXG4gICAgICAgICAgRCsrO1xuICAgICAgICBELS0sIE8gPSBPIC8geCB8IDA7XG4gICAgICAgIGZvciAodmFyIFUgPSBnLmxlbmd0aCAtIHcsIFYgPSBVICUgRCwgTCA9IE1hdGgubWluKFUsIFUgLSBWKSArIHcsIG0gPSAwLCB2ID0gdzsgdiA8IEw7IHYgKz0gRClcbiAgICAgICAgICBtID0gYyhnLCB2LCB2ICsgRCwgeCksIHRoaXMuaW11bG4oTyksIHRoaXMud29yZHNbMF0gKyBtIDwgNjcxMDg4NjQgPyB0aGlzLndvcmRzWzBdICs9IG0gOiB0aGlzLl9pYWRkbihtKTtcbiAgICAgICAgaWYgKFYgIT09IDApIHtcbiAgICAgICAgICB2YXIgUCA9IDE7XG4gICAgICAgICAgZm9yIChtID0gYyhnLCB2LCBnLmxlbmd0aCwgeCksIHYgPSAwOyB2IDwgVjsgdisrKVxuICAgICAgICAgICAgUCAqPSB4O1xuICAgICAgICAgIHRoaXMuaW11bG4oUCksIHRoaXMud29yZHNbMF0gKyBtIDwgNjcxMDg4NjQgPyB0aGlzLndvcmRzWzBdICs9IG0gOiB0aGlzLl9pYWRkbihtKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdHJpcCgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgZy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy5sZW5ndGg7IHgrKylcbiAgICAgICAgICBnLndvcmRzW3hdID0gdGhpcy53b3Jkc1t4XTtcbiAgICAgICAgZy5sZW5ndGggPSB0aGlzLmxlbmd0aCwgZy5uZWdhdGl2ZSA9IHRoaXMubmVnYXRpdmUsIGcucmVkID0gdGhpcy5yZWQ7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gdShfLCBnKSB7XG4gICAgICAgIF8ud29yZHMgPSBnLndvcmRzLCBfLmxlbmd0aCA9IGcubGVuZ3RoLCBfLm5lZ2F0aXZlID0gZy5uZWdhdGl2ZSwgXy5yZWQgPSBnLnJlZDtcbiAgICAgIH1cbiAgICAgIGlmIChpLnByb3RvdHlwZS5fbW92ZSA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgdShnLCB0aGlzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBnID0gbmV3IGkobnVsbCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkoZyksIGc7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fZXhwYW5kID0gZnVuY3Rpb24oZykge1xuICAgICAgICBmb3IgKDsgdGhpcy5sZW5ndGggPCBnOyApXG4gICAgICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX3N0cmlwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAoOyB0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwOyApXG4gICAgICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fbm9ybVNpZ24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDAgJiYgKHRoaXMubmVnYXRpdmUgPSAwKSwgdGhpcztcbiAgICAgIH0sIHR5cGVvZiBTeW1ib2wgPCBcInVcIiAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaS5wcm90b3R5cGVbU3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpXSA9IGQ7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIGkucHJvdG90eXBlLmluc3BlY3QgPSBkO1xuICAgICAgICB9XG4gICAgICBlbHNlXG4gICAgICAgIGkucHJvdG90eXBlLmluc3BlY3QgPSBkO1xuICAgICAgZnVuY3Rpb24gZCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnJlZCA/IFwiPEJOLVI6IFwiIDogXCI8Qk46IFwiKSArIHRoaXMudG9TdHJpbmcoMTYpICsgXCI+XCI7XG4gICAgICB9XG4gICAgICB2YXIgaCA9IFtcbiAgICAgICAgXCJcIixcbiAgICAgICAgXCIwXCIsXG4gICAgICAgIFwiMDBcIixcbiAgICAgICAgXCIwMDBcIixcbiAgICAgICAgXCIwMDAwXCIsXG4gICAgICAgIFwiMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwXCIsXG4gICAgICAgIFwiMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwXCIsXG4gICAgICAgIFwiMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgIFwiMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgIFwiMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgIFwiMDAwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIsXG4gICAgICAgIFwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIixcbiAgICAgICAgXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCJcbiAgICAgIF0sIGYgPSBbXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDI1LFxuICAgICAgICAxNixcbiAgICAgICAgMTIsXG4gICAgICAgIDExLFxuICAgICAgICAxMCxcbiAgICAgICAgOSxcbiAgICAgICAgOCxcbiAgICAgICAgOCxcbiAgICAgICAgNyxcbiAgICAgICAgNyxcbiAgICAgICAgNyxcbiAgICAgICAgNyxcbiAgICAgICAgNixcbiAgICAgICAgNixcbiAgICAgICAgNixcbiAgICAgICAgNixcbiAgICAgICAgNixcbiAgICAgICAgNixcbiAgICAgICAgNixcbiAgICAgICAgNSxcbiAgICAgICAgNSxcbiAgICAgICAgNSxcbiAgICAgICAgNSxcbiAgICAgICAgNSxcbiAgICAgICAgNSxcbiAgICAgICAgNSxcbiAgICAgICAgNSxcbiAgICAgICAgNSxcbiAgICAgICAgNSxcbiAgICAgICAgNSxcbiAgICAgICAgNSxcbiAgICAgICAgNSxcbiAgICAgICAgNSxcbiAgICAgICAgNSxcbiAgICAgICAgNVxuICAgICAgXSwgcCA9IFtcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMzM1NTQ0MzIsXG4gICAgICAgIDQzMDQ2NzIxLFxuICAgICAgICAxNjc3NzIxNixcbiAgICAgICAgNDg4MjgxMjUsXG4gICAgICAgIDYwNDY2MTc2LFxuICAgICAgICA0MDM1MzYwNyxcbiAgICAgICAgMTY3NzcyMTYsXG4gICAgICAgIDQzMDQ2NzIxLFxuICAgICAgICAxZTcsXG4gICAgICAgIDE5NDg3MTcxLFxuICAgICAgICAzNTgzMTgwOCxcbiAgICAgICAgNjI3NDg1MTcsXG4gICAgICAgIDc1Mjk1MzYsXG4gICAgICAgIDExMzkwNjI1LFxuICAgICAgICAxNjc3NzIxNixcbiAgICAgICAgMjQxMzc1NjksXG4gICAgICAgIDM0MDEyMjI0LFxuICAgICAgICA0NzA0NTg4MSxcbiAgICAgICAgNjRlNixcbiAgICAgICAgNDA4NDEwMSxcbiAgICAgICAgNTE1MzYzMixcbiAgICAgICAgNjQzNjM0MyxcbiAgICAgICAgNzk2MjYyNCxcbiAgICAgICAgOTc2NTYyNSxcbiAgICAgICAgMTE4ODEzNzYsXG4gICAgICAgIDE0MzQ4OTA3LFxuICAgICAgICAxNzIxMDM2OCxcbiAgICAgICAgMjA1MTExNDksXG4gICAgICAgIDI0M2U1LFxuICAgICAgICAyODYyOTE1MSxcbiAgICAgICAgMzM1NTQ0MzIsXG4gICAgICAgIDM5MTM1MzkzLFxuICAgICAgICA0NTQzNTQyNCxcbiAgICAgICAgNTI1MjE4NzUsXG4gICAgICAgIDYwNDY2MTc2XG4gICAgICBdO1xuICAgICAgaS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbihnLCB4KSB7XG4gICAgICAgIGcgPSBnIHx8IDEwLCB4ID0geCB8IDAgfHwgMTtcbiAgICAgICAgdmFyIHc7XG4gICAgICAgIGlmIChnID09PSAxNiB8fCBnID09PSBcImhleFwiKSB7XG4gICAgICAgICAgdyA9IFwiXCI7XG4gICAgICAgICAgZm9yICh2YXIgRCA9IDAsIE8gPSAwLCBVID0gMDsgVSA8IHRoaXMubGVuZ3RoOyBVKyspIHtcbiAgICAgICAgICAgIHZhciBWID0gdGhpcy53b3Jkc1tVXSwgTCA9ICgoViA8PCBEIHwgTykgJiAxNjc3NzIxNSkudG9TdHJpbmcoMTYpO1xuICAgICAgICAgICAgTyA9IFYgPj4+IDI0IC0gRCAmIDE2Nzc3MjE1LCBEICs9IDIsIEQgPj0gMjYgJiYgKEQgLT0gMjYsIFUtLSksIE8gIT09IDAgfHwgVSAhPT0gdGhpcy5sZW5ndGggLSAxID8gdyA9IGhbNiAtIEwubGVuZ3RoXSArIEwgKyB3IDogdyA9IEwgKyB3O1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKE8gIT09IDAgJiYgKHcgPSBPLnRvU3RyaW5nKDE2KSArIHcpOyB3Lmxlbmd0aCAlIHggIT09IDA7IClcbiAgICAgICAgICAgIHcgPSBcIjBcIiArIHc7XG4gICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDAgJiYgKHcgPSBcIi1cIiArIHcpLCB3O1xuICAgICAgICB9XG4gICAgICAgIGlmIChnID09PSAoZyB8IDApICYmIGcgPj0gMiAmJiBnIDw9IDM2KSB7XG4gICAgICAgICAgdmFyIG0gPSBmW2ddLCB2ID0gcFtnXTtcbiAgICAgICAgICB3ID0gXCJcIjtcbiAgICAgICAgICB2YXIgUCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgICBmb3IgKFAubmVnYXRpdmUgPSAwOyAhUC5pc1plcm8oKTsgKSB7XG4gICAgICAgICAgICB2YXIgTiA9IFAubW9kcm4odikudG9TdHJpbmcoZyk7XG4gICAgICAgICAgICBQID0gUC5pZGl2bih2KSwgUC5pc1plcm8oKSA/IHcgPSBOICsgdyA6IHcgPSBoW20gLSBOLmxlbmd0aF0gKyBOICsgdztcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yICh0aGlzLmlzWmVybygpICYmICh3ID0gXCIwXCIgKyB3KTsgdy5sZW5ndGggJSB4ICE9PSAwOyApXG4gICAgICAgICAgICB3ID0gXCIwXCIgKyB3O1xuICAgICAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwICYmICh3ID0gXCItXCIgKyB3KSwgdztcbiAgICAgICAgfVxuICAgICAgICByKCExLCBcIkJhc2Ugc2hvdWxkIGJlIGJldHdlZW4gMiBhbmQgMzZcIik7XG4gICAgICB9LCBpLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZyA9IHRoaXMud29yZHNbMF07XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMiA/IGcgKz0gdGhpcy53b3Jkc1sxXSAqIDY3MTA4ODY0IDogdGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMSA/IGcgKz0gNDUwMzU5OTYyNzM3MDQ5NiArIHRoaXMud29yZHNbMV0gKiA2NzEwODg2NCA6IHRoaXMubGVuZ3RoID4gMiAmJiByKCExLCBcIk51bWJlciBjYW4gb25seSBzYWZlbHkgc3RvcmUgdXAgdG8gNTMgYml0c1wiKSwgdGhpcy5uZWdhdGl2ZSAhPT0gMCA/IC1nIDogZztcbiAgICAgIH0sIGkucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNiwgMik7XG4gICAgICB9LCBvICYmIChpLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uKGcsIHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UobywgZywgeCk7XG4gICAgICB9KSwgaS5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKGcsIHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQXJyYXksIGcsIHgpO1xuICAgICAgfTtcbiAgICAgIHZhciB5ID0gZnVuY3Rpb24oZywgeCkge1xuICAgICAgICByZXR1cm4gZy5hbGxvY1Vuc2FmZSA/IGcuYWxsb2NVbnNhZmUoeCkgOiBuZXcgZyh4KTtcbiAgICAgIH07XG4gICAgICBpLnByb3RvdHlwZS50b0FycmF5TGlrZSA9IGZ1bmN0aW9uKGcsIHgsIHcpIHtcbiAgICAgICAgdGhpcy5fc3RyaXAoKTtcbiAgICAgICAgdmFyIEQgPSB0aGlzLmJ5dGVMZW5ndGgoKSwgTyA9IHcgfHwgTWF0aC5tYXgoMSwgRCk7XG4gICAgICAgIHIoRCA8PSBPLCBcImJ5dGUgYXJyYXkgbG9uZ2VyIHRoYW4gZGVzaXJlZCBsZW5ndGhcIiksIHIoTyA+IDAsIFwiUmVxdWVzdGVkIGFycmF5IGxlbmd0aCA8PSAwXCIpO1xuICAgICAgICB2YXIgVSA9IHkoZywgTyksIFYgPSB4ID09PSBcImxlXCIgPyBcIkxFXCIgOiBcIkJFXCI7XG4gICAgICAgIHJldHVybiB0aGlzW1wiX3RvQXJyYXlMaWtlXCIgKyBWXShVLCBEKSwgVTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl90b0FycmF5TGlrZUxFID0gZnVuY3Rpb24oZywgeCkge1xuICAgICAgICBmb3IgKHZhciB3ID0gMCwgRCA9IDAsIE8gPSAwLCBVID0gMDsgTyA8IHRoaXMubGVuZ3RoOyBPKyspIHtcbiAgICAgICAgICB2YXIgViA9IHRoaXMud29yZHNbT10gPDwgVSB8IEQ7XG4gICAgICAgICAgZ1t3KytdID0gViAmIDI1NSwgdyA8IGcubGVuZ3RoICYmIChnW3crK10gPSBWID4+IDggJiAyNTUpLCB3IDwgZy5sZW5ndGggJiYgKGdbdysrXSA9IFYgPj4gMTYgJiAyNTUpLCBVID09PSA2ID8gKHcgPCBnLmxlbmd0aCAmJiAoZ1t3KytdID0gViA+PiAyNCAmIDI1NSksIEQgPSAwLCBVID0gMCkgOiAoRCA9IFYgPj4+IDI0LCBVICs9IDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3IDwgZy5sZW5ndGgpXG4gICAgICAgICAgZm9yIChnW3crK10gPSBEOyB3IDwgZy5sZW5ndGg7IClcbiAgICAgICAgICAgIGdbdysrXSA9IDA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fdG9BcnJheUxpa2VCRSA9IGZ1bmN0aW9uKGcsIHgpIHtcbiAgICAgICAgZm9yICh2YXIgdyA9IGcubGVuZ3RoIC0gMSwgRCA9IDAsIE8gPSAwLCBVID0gMDsgTyA8IHRoaXMubGVuZ3RoOyBPKyspIHtcbiAgICAgICAgICB2YXIgViA9IHRoaXMud29yZHNbT10gPDwgVSB8IEQ7XG4gICAgICAgICAgZ1t3LS1dID0gViAmIDI1NSwgdyA+PSAwICYmIChnW3ctLV0gPSBWID4+IDggJiAyNTUpLCB3ID49IDAgJiYgKGdbdy0tXSA9IFYgPj4gMTYgJiAyNTUpLCBVID09PSA2ID8gKHcgPj0gMCAmJiAoZ1t3LS1dID0gViA+PiAyNCAmIDI1NSksIEQgPSAwLCBVID0gMCkgOiAoRCA9IFYgPj4+IDI0LCBVICs9IDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3ID49IDApXG4gICAgICAgICAgZm9yIChnW3ctLV0gPSBEOyB3ID49IDA7IClcbiAgICAgICAgICAgIGdbdy0tXSA9IDA7XG4gICAgICB9LCBNYXRoLmNsejMyID8gaS5wcm90b3R5cGUuX2NvdW50Qml0cyA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIDMyIC0gTWF0aC5jbHozMihnKTtcbiAgICAgIH0gOiBpLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24oZykge1xuICAgICAgICB2YXIgeCA9IGcsIHcgPSAwO1xuICAgICAgICByZXR1cm4geCA+PSA0MDk2ICYmICh3ICs9IDEzLCB4ID4+Pj0gMTMpLCB4ID49IDY0ICYmICh3ICs9IDcsIHggPj4+PSA3KSwgeCA+PSA4ICYmICh3ICs9IDQsIHggPj4+PSA0KSwgeCA+PSAyICYmICh3ICs9IDIsIHggPj4+PSAyKSwgdyArIHg7XG4gICAgICB9LCBpLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIGlmIChnID09PSAwKSByZXR1cm4gMjY7XG4gICAgICAgIHZhciB4ID0gZywgdyA9IDA7XG4gICAgICAgIHJldHVybiAoeCAmIDgxOTEpID09PSAwICYmICh3ICs9IDEzLCB4ID4+Pj0gMTMpLCAoeCAmIDEyNykgPT09IDAgJiYgKHcgKz0gNywgeCA+Pj49IDcpLCAoeCAmIDE1KSA9PT0gMCAmJiAodyArPSA0LCB4ID4+Pj0gNCksICh4ICYgMykgPT09IDAgJiYgKHcgKz0gMiwgeCA+Pj49IDIpLCAoeCAmIDEpID09PSAwICYmIHcrKywgdztcbiAgICAgIH0sIGkucHJvdG90eXBlLmJpdExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZyA9IHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSwgeCA9IHRoaXMuX2NvdW50Qml0cyhnKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLmxlbmd0aCAtIDEpICogMjYgKyB4O1xuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIEUoXykge1xuICAgICAgICBmb3IgKHZhciBnID0gbmV3IEFycmF5KF8uYml0TGVuZ3RoKCkpLCB4ID0gMDsgeCA8IGcubGVuZ3RoOyB4KyspIHtcbiAgICAgICAgICB2YXIgdyA9IHggLyAyNiB8IDAsIEQgPSB4ICUgMjY7XG4gICAgICAgICAgZ1t4XSA9IF8ud29yZHNbd10gPj4+IEQgJiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnO1xuICAgICAgfVxuICAgICAgaS5wcm90b3R5cGUuemVyb0JpdHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiAwO1xuICAgICAgICBmb3IgKHZhciBnID0gMCwgeCA9IDA7IHggPCB0aGlzLmxlbmd0aDsgeCsrKSB7XG4gICAgICAgICAgdmFyIHcgPSB0aGlzLl96ZXJvQml0cyh0aGlzLndvcmRzW3hdKTtcbiAgICAgICAgICBpZiAoZyArPSB3LCB3ICE9PSAyNikgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGc7XG4gICAgICB9LCBpLnByb3RvdHlwZS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUudG9Ud29zID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMCA/IHRoaXMuYWJzKCkuaW5vdG4oZykuaWFkZG4oMSkgOiB0aGlzLmNsb25lKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5mcm9tVHdvcyA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGVzdG4oZyAtIDEpID8gdGhpcy5ub3RuKGcpLmlhZGRuKDEpLmluZWcoKSA6IHRoaXMuY2xvbmUoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xuICAgICAgfSwgaS5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5lZygpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaW5lZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1plcm8oKSB8fCAodGhpcy5uZWdhdGl2ZSBePSAxKSwgdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLml1b3IgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIGZvciAoOyB0aGlzLmxlbmd0aCA8IGcubGVuZ3RoOyApXG4gICAgICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgZy5sZW5ndGg7IHgrKylcbiAgICAgICAgICB0aGlzLndvcmRzW3hdID0gdGhpcy53b3Jkc1t4XSB8IGcud29yZHNbeF07XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaW9yID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gcigodGhpcy5uZWdhdGl2ZSB8IGcubmVnYXRpdmUpID09PSAwKSwgdGhpcy5pdW9yKGcpO1xuICAgICAgfSwgaS5wcm90b3R5cGUub3IgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IGcubGVuZ3RoID8gdGhpcy5jbG9uZSgpLmlvcihnKSA6IGcuY2xvbmUoKS5pb3IodGhpcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IGcubGVuZ3RoID8gdGhpcy5jbG9uZSgpLml1b3IoZykgOiBnLmNsb25lKCkuaXVvcih0aGlzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLml1YW5kID0gZnVuY3Rpb24oZykge1xuICAgICAgICB2YXIgeDtcbiAgICAgICAgdGhpcy5sZW5ndGggPiBnLmxlbmd0aCA/IHggPSBnIDogeCA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIHcgPSAwOyB3IDwgeC5sZW5ndGg7IHcrKylcbiAgICAgICAgICB0aGlzLndvcmRzW3ddID0gdGhpcy53b3Jkc1t3XSAmIGcud29yZHNbd107XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9IHgubGVuZ3RoLCB0aGlzLl9zdHJpcCgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaWFuZCA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIHIoKHRoaXMubmVnYXRpdmUgfCBnLm5lZ2F0aXZlKSA9PT0gMCksIHRoaXMuaXVhbmQoZyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IGcubGVuZ3RoID8gdGhpcy5jbG9uZSgpLmlhbmQoZykgOiBnLmNsb25lKCkuaWFuZCh0aGlzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnVhbmQgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IGcubGVuZ3RoID8gdGhpcy5jbG9uZSgpLml1YW5kKGcpIDogZy5jbG9uZSgpLml1YW5kKHRoaXMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaXV4b3IgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHZhciB4LCB3O1xuICAgICAgICB0aGlzLmxlbmd0aCA+IGcubGVuZ3RoID8gKHggPSB0aGlzLCB3ID0gZykgOiAoeCA9IGcsIHcgPSB0aGlzKTtcbiAgICAgICAgZm9yICh2YXIgRCA9IDA7IEQgPCB3Lmxlbmd0aDsgRCsrKVxuICAgICAgICAgIHRoaXMud29yZHNbRF0gPSB4LndvcmRzW0RdIF4gdy53b3Jkc1tEXTtcbiAgICAgICAgaWYgKHRoaXMgIT09IHgpXG4gICAgICAgICAgZm9yICg7IEQgPCB4Lmxlbmd0aDsgRCsrKVxuICAgICAgICAgICAgdGhpcy53b3Jkc1tEXSA9IHgud29yZHNbRF07XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9IHgubGVuZ3RoLCB0aGlzLl9zdHJpcCgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIHIoKHRoaXMubmVnYXRpdmUgfCBnLm5lZ2F0aXZlKSA9PT0gMCksIHRoaXMuaXV4b3IoZyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IGcubGVuZ3RoID8gdGhpcy5jbG9uZSgpLml4b3IoZykgOiBnLmNsb25lKCkuaXhvcih0aGlzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnV4b3IgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA+IGcubGVuZ3RoID8gdGhpcy5jbG9uZSgpLml1eG9yKGcpIDogZy5jbG9uZSgpLml1eG9yKHRoaXMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaW5vdG4gPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHIodHlwZW9mIGcgPT0gXCJudW1iZXJcIiAmJiBnID49IDApO1xuICAgICAgICB2YXIgeCA9IE1hdGguY2VpbChnIC8gMjYpIHwgMCwgdyA9IGcgJSAyNjtcbiAgICAgICAgdGhpcy5fZXhwYW5kKHgpLCB3ID4gMCAmJiB4LS07XG4gICAgICAgIGZvciAodmFyIEQgPSAwOyBEIDwgeDsgRCsrKVxuICAgICAgICAgIHRoaXMud29yZHNbRF0gPSB+dGhpcy53b3Jkc1tEXSAmIDY3MTA4ODYzO1xuICAgICAgICByZXR1cm4gdyA+IDAgJiYgKHRoaXMud29yZHNbRF0gPSB+dGhpcy53b3Jkc1tEXSAmIDY3MTA4ODYzID4+IDI2IC0gdyksIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlub3RuKGcpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2V0biA9IGZ1bmN0aW9uKGcsIHgpIHtcbiAgICAgICAgcih0eXBlb2YgZyA9PSBcIm51bWJlclwiICYmIGcgPj0gMCk7XG4gICAgICAgIHZhciB3ID0gZyAvIDI2IHwgMCwgRCA9IGcgJSAyNjtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuZCh3ICsgMSksIHggPyB0aGlzLndvcmRzW3ddID0gdGhpcy53b3Jkc1t3XSB8IDEgPDwgRCA6IHRoaXMud29yZHNbd10gPSB0aGlzLndvcmRzW3ddICYgfigxIDw8IEQpLCB0aGlzLl9zdHJpcCgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgdmFyIHg7XG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIGcubmVnYXRpdmUgPT09IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgPSAwLCB4ID0gdGhpcy5pc3ViKGcpLCB0aGlzLm5lZ2F0aXZlIF49IDEsIHRoaXMuX25vcm1TaWduKCk7XG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIGcubmVnYXRpdmUgIT09IDApXG4gICAgICAgICAgcmV0dXJuIGcubmVnYXRpdmUgPSAwLCB4ID0gdGhpcy5pc3ViKGcpLCBnLm5lZ2F0aXZlID0gMSwgeC5fbm9ybVNpZ24oKTtcbiAgICAgICAgdmFyIHcsIEQ7XG4gICAgICAgIHRoaXMubGVuZ3RoID4gZy5sZW5ndGggPyAodyA9IHRoaXMsIEQgPSBnKSA6ICh3ID0gZywgRCA9IHRoaXMpO1xuICAgICAgICBmb3IgKHZhciBPID0gMCwgVSA9IDA7IFUgPCBELmxlbmd0aDsgVSsrKVxuICAgICAgICAgIHggPSAody53b3Jkc1tVXSB8IDApICsgKEQud29yZHNbVV0gfCAwKSArIE8sIHRoaXMud29yZHNbVV0gPSB4ICYgNjcxMDg4NjMsIE8gPSB4ID4+PiAyNjtcbiAgICAgICAgZm9yICg7IE8gIT09IDAgJiYgVSA8IHcubGVuZ3RoOyBVKyspXG4gICAgICAgICAgeCA9ICh3LndvcmRzW1VdIHwgMCkgKyBPLCB0aGlzLndvcmRzW1VdID0geCAmIDY3MTA4ODYzLCBPID0geCA+Pj4gMjY7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9IHcubGVuZ3RoLCBPICE9PSAwKVxuICAgICAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGhdID0gTywgdGhpcy5sZW5ndGgrKztcbiAgICAgICAgZWxzZSBpZiAodyAhPT0gdGhpcylcbiAgICAgICAgICBmb3IgKDsgVSA8IHcubGVuZ3RoOyBVKyspXG4gICAgICAgICAgICB0aGlzLndvcmRzW1VdID0gdy53b3Jkc1tVXTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHZhciB4O1xuICAgICAgICByZXR1cm4gZy5uZWdhdGl2ZSAhPT0gMCAmJiB0aGlzLm5lZ2F0aXZlID09PSAwID8gKGcubmVnYXRpdmUgPSAwLCB4ID0gdGhpcy5zdWIoZyksIGcubmVnYXRpdmUgXj0gMSwgeCkgOiBnLm5lZ2F0aXZlID09PSAwICYmIHRoaXMubmVnYXRpdmUgIT09IDAgPyAodGhpcy5uZWdhdGl2ZSA9IDAsIHggPSBnLnN1Yih0aGlzKSwgdGhpcy5uZWdhdGl2ZSA9IDEsIHgpIDogdGhpcy5sZW5ndGggPiBnLmxlbmd0aCA/IHRoaXMuY2xvbmUoKS5pYWRkKGcpIDogZy5jbG9uZSgpLmlhZGQodGhpcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24oZykge1xuICAgICAgICBpZiAoZy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIGcubmVnYXRpdmUgPSAwO1xuICAgICAgICAgIHZhciB4ID0gdGhpcy5pYWRkKGcpO1xuICAgICAgICAgIHJldHVybiBnLm5lZ2F0aXZlID0gMSwgeC5fbm9ybVNpZ24oKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKVxuICAgICAgICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlID0gMCwgdGhpcy5pYWRkKGcpLCB0aGlzLm5lZ2F0aXZlID0gMSwgdGhpcy5fbm9ybVNpZ24oKTtcbiAgICAgICAgdmFyIHcgPSB0aGlzLmNtcChnKTtcbiAgICAgICAgaWYgKHcgPT09IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgPSAwLCB0aGlzLmxlbmd0aCA9IDEsIHRoaXMud29yZHNbMF0gPSAwLCB0aGlzO1xuICAgICAgICB2YXIgRCwgTztcbiAgICAgICAgdyA+IDAgPyAoRCA9IHRoaXMsIE8gPSBnKSA6IChEID0gZywgTyA9IHRoaXMpO1xuICAgICAgICBmb3IgKHZhciBVID0gMCwgViA9IDA7IFYgPCBPLmxlbmd0aDsgVisrKVxuICAgICAgICAgIHggPSAoRC53b3Jkc1tWXSB8IDApIC0gKE8ud29yZHNbVl0gfCAwKSArIFUsIFUgPSB4ID4+IDI2LCB0aGlzLndvcmRzW1ZdID0geCAmIDY3MTA4ODYzO1xuICAgICAgICBmb3IgKDsgVSAhPT0gMCAmJiBWIDwgRC5sZW5ndGg7IFYrKylcbiAgICAgICAgICB4ID0gKEQud29yZHNbVl0gfCAwKSArIFUsIFUgPSB4ID4+IDI2LCB0aGlzLndvcmRzW1ZdID0geCAmIDY3MTA4ODYzO1xuICAgICAgICBpZiAoVSA9PT0gMCAmJiBWIDwgRC5sZW5ndGggJiYgRCAhPT0gdGhpcylcbiAgICAgICAgICBmb3IgKDsgViA8IEQubGVuZ3RoOyBWKyspXG4gICAgICAgICAgICB0aGlzLndvcmRzW1ZdID0gRC53b3Jkc1tWXTtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIFYpLCBEICE9PSB0aGlzICYmICh0aGlzLm5lZ2F0aXZlID0gMSksIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1YihnKTtcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbiBiKF8sIGcsIHgpIHtcbiAgICAgICAgeC5uZWdhdGl2ZSA9IGcubmVnYXRpdmUgXiBfLm5lZ2F0aXZlO1xuICAgICAgICB2YXIgdyA9IF8ubGVuZ3RoICsgZy5sZW5ndGggfCAwO1xuICAgICAgICB4Lmxlbmd0aCA9IHcsIHcgPSB3IC0gMSB8IDA7XG4gICAgICAgIHZhciBEID0gXy53b3Jkc1swXSB8IDAsIE8gPSBnLndvcmRzWzBdIHwgMCwgVSA9IEQgKiBPLCBWID0gVSAmIDY3MTA4ODYzLCBMID0gVSAvIDY3MTA4ODY0IHwgMDtcbiAgICAgICAgeC53b3Jkc1swXSA9IFY7XG4gICAgICAgIGZvciAodmFyIG0gPSAxOyBtIDwgdzsgbSsrKSB7XG4gICAgICAgICAgZm9yICh2YXIgdiA9IEwgPj4+IDI2LCBQID0gTCAmIDY3MTA4ODYzLCBOID0gTWF0aC5taW4obSwgZy5sZW5ndGggLSAxKSwgWSA9IE1hdGgubWF4KDAsIG0gLSBfLmxlbmd0aCArIDEpOyBZIDw9IE47IFkrKykge1xuICAgICAgICAgICAgdmFyIGVlID0gbSAtIFkgfCAwO1xuICAgICAgICAgICAgRCA9IF8ud29yZHNbZWVdIHwgMCwgTyA9IGcud29yZHNbWV0gfCAwLCBVID0gRCAqIE8gKyBQLCB2ICs9IFUgLyA2NzEwODg2NCB8IDAsIFAgPSBVICYgNjcxMDg4NjM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHgud29yZHNbbV0gPSBQIHwgMCwgTCA9IHYgfCAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBMICE9PSAwID8geC53b3Jkc1ttXSA9IEwgfCAwIDogeC5sZW5ndGgtLSwgeC5fc3RyaXAoKTtcbiAgICAgIH1cbiAgICAgIHZhciBSID0gZnVuY3Rpb24oZywgeCwgdykge1xuICAgICAgICB2YXIgRCA9IGcud29yZHMsIE8gPSB4LndvcmRzLCBVID0gdy53b3JkcywgViA9IDAsIEwsIG0sIHYsIFAgPSBEWzBdIHwgMCwgTiA9IFAgJiA4MTkxLCBZID0gUCA+Pj4gMTMsIGVlID0gRFsxXSB8IDAsIGllID0gZWUgJiA4MTkxLCBsZSA9IGVlID4+PiAxMywgVGUgPSBEWzJdIHwgMCwgRGUgPSBUZSAmIDgxOTEsIHplID0gVGUgPj4+IDEzLCBfZSA9IERbM10gfCAwLCB4ZSA9IF9lICYgODE5MSwgQmUgPSBfZSA+Pj4gMTMsIHllID0gRFs0XSB8IDAsIGJlID0geWUgJiA4MTkxLCBGZSA9IHllID4+PiAxMywgWGUgPSBEWzVdIHwgMCwgd2UgPSBYZSAmIDgxOTEsIE5lID0gWGUgPj4+IDEzLCBkdCA9IERbNl0gfCAwLCBKZSA9IGR0ICYgODE5MSwgUWUgPSBkdCA+Pj4gMTMsIGl0ID0gRFs3XSB8IDAsIGplID0gaXQgJiA4MTkxLCBCID0gaXQgPj4+IDEzLCBTID0gRFs4XSB8IDAsIFQgPSBTICYgODE5MSwgRyA9IFMgPj4+IDEzLCBaID0gRFs5XSB8IDAsIFEgPSBaICYgODE5MSwgc2UgPSBaID4+PiAxMywgVWUgPSBPWzBdIHwgMCwgUGUgPSBVZSAmIDgxOTEsIExlID0gVWUgPj4+IDEzLCBjdCA9IE9bMV0gfCAwLCBBZSA9IGN0ICYgODE5MSwgVHQgPSBjdCA+Pj4gMTMsIFV1ID0gT1syXSB8IDAsIHd0ID0gVXUgJiA4MTkxLCBBdCA9IFV1ID4+PiAxMywgJHUgPSBPWzNdIHwgMCwgSXQgPSAkdSAmIDgxOTEsIF90ID0gJHUgPj4+IDEzLCBHdSA9IE9bNF0gfCAwLCBSdCA9IEd1ICYgODE5MSwgTHQgPSBHdSA+Pj4gMTMsIFZ1ID0gT1s1XSB8IDAsIEN0ID0gVnUgJiA4MTkxLCBrdCA9IFZ1ID4+PiAxMywganUgPSBPWzZdIHwgMCwgRHQgPSBqdSAmIDgxOTEsIFB0ID0ganUgPj4+IDEzLCBLdSA9IE9bN10gfCAwLCBNdCA9IEt1ICYgODE5MSwgT3QgPSBLdSA+Pj4gMTMsIEh1ID0gT1s4XSB8IDAsIEJ0ID0gSHUgJiA4MTkxLCBGdCA9IEh1ID4+PiAxMywgcXUgPSBPWzldIHwgMCwgTnQgPSBxdSAmIDgxOTEsIFV0ID0gcXUgPj4+IDEzO1xuICAgICAgICB3Lm5lZ2F0aXZlID0gZy5uZWdhdGl2ZSBeIHgubmVnYXRpdmUsIHcubGVuZ3RoID0gMTksIEwgPSBNYXRoLmltdWwoTiwgUGUpLCBtID0gTWF0aC5pbXVsKE4sIExlKSwgbSA9IG0gKyBNYXRoLmltdWwoWSwgUGUpIHwgMCwgdiA9IE1hdGguaW11bChZLCBMZSk7XG4gICAgICAgIHZhciB4YSA9IChWICsgTCB8IDApICsgKChtICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgViA9ICh2ICsgKG0gPj4+IDEzKSB8IDApICsgKHhhID4+PiAyNikgfCAwLCB4YSAmPSA2NzEwODg2MywgTCA9IE1hdGguaW11bChpZSwgUGUpLCBtID0gTWF0aC5pbXVsKGllLCBMZSksIG0gPSBtICsgTWF0aC5pbXVsKGxlLCBQZSkgfCAwLCB2ID0gTWF0aC5pbXVsKGxlLCBMZSksIEwgPSBMICsgTWF0aC5pbXVsKE4sIEFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKE4sIFR0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFksIEFlKSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKFksIFR0KSB8IDA7XG4gICAgICAgIHZhciBTYSA9IChWICsgTCB8IDApICsgKChtICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgViA9ICh2ICsgKG0gPj4+IDEzKSB8IDApICsgKFNhID4+PiAyNikgfCAwLCBTYSAmPSA2NzEwODg2MywgTCA9IE1hdGguaW11bChEZSwgUGUpLCBtID0gTWF0aC5pbXVsKERlLCBMZSksIG0gPSBtICsgTWF0aC5pbXVsKHplLCBQZSkgfCAwLCB2ID0gTWF0aC5pbXVsKHplLCBMZSksIEwgPSBMICsgTWF0aC5pbXVsKGllLCBBZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChpZSwgVHQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwobGUsIEFlKSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKGxlLCBUdCkgfCAwLCBMID0gTCArIE1hdGguaW11bChOLCB3dCkgfCAwLCBtID0gbSArIE1hdGguaW11bChOLCBBdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChZLCB3dCkgfCAwLCB2ID0gdiArIE1hdGguaW11bChZLCBBdCkgfCAwO1xuICAgICAgICB2YXIgYmEgPSAoViArIEwgfCAwKSArICgobSAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICAgIFYgPSAodiArIChtID4+PiAxMykgfCAwKSArIChiYSA+Pj4gMjYpIHwgMCwgYmEgJj0gNjcxMDg4NjMsIEwgPSBNYXRoLmltdWwoeGUsIFBlKSwgbSA9IE1hdGguaW11bCh4ZSwgTGUpLCBtID0gbSArIE1hdGguaW11bChCZSwgUGUpIHwgMCwgdiA9IE1hdGguaW11bChCZSwgTGUpLCBMID0gTCArIE1hdGguaW11bChEZSwgQWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoRGUsIFR0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHplLCBBZSkgfCAwLCB2ID0gdiArIE1hdGguaW11bCh6ZSwgVHQpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoaWUsIHd0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKGllLCBBdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChsZSwgd3QpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwobGUsIEF0KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKE4sIEl0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKE4sIF90KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFksIEl0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKFksIF90KSB8IDA7XG4gICAgICAgIHZhciBUYSA9IChWICsgTCB8IDApICsgKChtICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgViA9ICh2ICsgKG0gPj4+IDEzKSB8IDApICsgKFRhID4+PiAyNikgfCAwLCBUYSAmPSA2NzEwODg2MywgTCA9IE1hdGguaW11bChiZSwgUGUpLCBtID0gTWF0aC5pbXVsKGJlLCBMZSksIG0gPSBtICsgTWF0aC5pbXVsKEZlLCBQZSkgfCAwLCB2ID0gTWF0aC5pbXVsKEZlLCBMZSksIEwgPSBMICsgTWF0aC5pbXVsKHhlLCBBZSkgfCAwLCBtID0gbSArIE1hdGguaW11bCh4ZSwgVHQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoQmUsIEFlKSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKEJlLCBUdCkgfCAwLCBMID0gTCArIE1hdGguaW11bChEZSwgd3QpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoRGUsIEF0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHplLCB3dCkgfCAwLCB2ID0gdiArIE1hdGguaW11bCh6ZSwgQXQpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoaWUsIEl0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKGllLCBfdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChsZSwgSXQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwobGUsIF90KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKE4sIFJ0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKE4sIEx0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFksIFJ0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKFksIEx0KSB8IDA7XG4gICAgICAgIHZhciB3YSA9IChWICsgTCB8IDApICsgKChtICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgViA9ICh2ICsgKG0gPj4+IDEzKSB8IDApICsgKHdhID4+PiAyNikgfCAwLCB3YSAmPSA2NzEwODg2MywgTCA9IE1hdGguaW11bCh3ZSwgUGUpLCBtID0gTWF0aC5pbXVsKHdlLCBMZSksIG0gPSBtICsgTWF0aC5pbXVsKE5lLCBQZSkgfCAwLCB2ID0gTWF0aC5pbXVsKE5lLCBMZSksIEwgPSBMICsgTWF0aC5pbXVsKGJlLCBBZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChiZSwgVHQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoRmUsIEFlKSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKEZlLCBUdCkgfCAwLCBMID0gTCArIE1hdGguaW11bCh4ZSwgd3QpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoeGUsIEF0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEJlLCB3dCkgfCAwLCB2ID0gdiArIE1hdGguaW11bChCZSwgQXQpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoRGUsIEl0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKERlLCBfdCkgfCAwLCBtID0gbSArIE1hdGguaW11bCh6ZSwgSXQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoemUsIF90KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKGllLCBSdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChpZSwgTHQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwobGUsIFJ0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKGxlLCBMdCkgfCAwLCBMID0gTCArIE1hdGguaW11bChOLCBDdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChOLCBrdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChZLCBDdCkgfCAwLCB2ID0gdiArIE1hdGguaW11bChZLCBrdCkgfCAwO1xuICAgICAgICB2YXIgQWEgPSAoViArIEwgfCAwKSArICgobSAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICAgIFYgPSAodiArIChtID4+PiAxMykgfCAwKSArIChBYSA+Pj4gMjYpIHwgMCwgQWEgJj0gNjcxMDg4NjMsIEwgPSBNYXRoLmltdWwoSmUsIFBlKSwgbSA9IE1hdGguaW11bChKZSwgTGUpLCBtID0gbSArIE1hdGguaW11bChRZSwgUGUpIHwgMCwgdiA9IE1hdGguaW11bChRZSwgTGUpLCBMID0gTCArIE1hdGguaW11bCh3ZSwgQWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwod2UsIFR0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKE5lLCBBZSkgfCAwLCB2ID0gdiArIE1hdGguaW11bChOZSwgVHQpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoYmUsIHd0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKGJlLCBBdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChGZSwgd3QpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoRmUsIEF0KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKHhlLCBJdCkgfCAwLCBtID0gbSArIE1hdGguaW11bCh4ZSwgX3QpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoQmUsIEl0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKEJlLCBfdCkgfCAwLCBMID0gTCArIE1hdGguaW11bChEZSwgUnQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoRGUsIEx0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHplLCBSdCkgfCAwLCB2ID0gdiArIE1hdGguaW11bCh6ZSwgTHQpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoaWUsIEN0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKGllLCBrdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChsZSwgQ3QpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwobGUsIGt0KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKE4sIER0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKE4sIFB0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFksIER0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKFksIFB0KSB8IDA7XG4gICAgICAgIHZhciBJYSA9IChWICsgTCB8IDApICsgKChtICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgViA9ICh2ICsgKG0gPj4+IDEzKSB8IDApICsgKElhID4+PiAyNikgfCAwLCBJYSAmPSA2NzEwODg2MywgTCA9IE1hdGguaW11bChqZSwgUGUpLCBtID0gTWF0aC5pbXVsKGplLCBMZSksIG0gPSBtICsgTWF0aC5pbXVsKEIsIFBlKSB8IDAsIHYgPSBNYXRoLmltdWwoQiwgTGUpLCBMID0gTCArIE1hdGguaW11bChKZSwgQWUpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoSmUsIFR0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFFlLCBBZSkgfCAwLCB2ID0gdiArIE1hdGguaW11bChRZSwgVHQpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwod2UsIHd0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHdlLCBBdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChOZSwgd3QpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoTmUsIEF0KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKGJlLCBJdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChiZSwgX3QpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoRmUsIEl0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKEZlLCBfdCkgfCAwLCBMID0gTCArIE1hdGguaW11bCh4ZSwgUnQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoeGUsIEx0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEJlLCBSdCkgfCAwLCB2ID0gdiArIE1hdGguaW11bChCZSwgTHQpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoRGUsIEN0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKERlLCBrdCkgfCAwLCBtID0gbSArIE1hdGguaW11bCh6ZSwgQ3QpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoemUsIGt0KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKGllLCBEdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChpZSwgUHQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwobGUsIER0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKGxlLCBQdCkgfCAwLCBMID0gTCArIE1hdGguaW11bChOLCBNdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChOLCBPdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChZLCBNdCkgfCAwLCB2ID0gdiArIE1hdGguaW11bChZLCBPdCkgfCAwO1xuICAgICAgICB2YXIgX2EgPSAoViArIEwgfCAwKSArICgobSAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICAgIFYgPSAodiArIChtID4+PiAxMykgfCAwKSArIChfYSA+Pj4gMjYpIHwgMCwgX2EgJj0gNjcxMDg4NjMsIEwgPSBNYXRoLmltdWwoVCwgUGUpLCBtID0gTWF0aC5pbXVsKFQsIExlKSwgbSA9IG0gKyBNYXRoLmltdWwoRywgUGUpIHwgMCwgdiA9IE1hdGguaW11bChHLCBMZSksIEwgPSBMICsgTWF0aC5pbXVsKGplLCBBZSkgfCAwLCBtID0gbSArIE1hdGguaW11bChqZSwgVHQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoQiwgQWUpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoQiwgVHQpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoSmUsIHd0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEplLCBBdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChRZSwgd3QpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoUWUsIEF0KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKHdlLCBJdCkgfCAwLCBtID0gbSArIE1hdGguaW11bCh3ZSwgX3QpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoTmUsIEl0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKE5lLCBfdCkgfCAwLCBMID0gTCArIE1hdGguaW11bChiZSwgUnQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoYmUsIEx0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEZlLCBSdCkgfCAwLCB2ID0gdiArIE1hdGguaW11bChGZSwgTHQpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoeGUsIEN0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHhlLCBrdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChCZSwgQ3QpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoQmUsIGt0KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKERlLCBEdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChEZSwgUHQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoemUsIER0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKHplLCBQdCkgfCAwLCBMID0gTCArIE1hdGguaW11bChpZSwgTXQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoaWUsIE90KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKGxlLCBNdCkgfCAwLCB2ID0gdiArIE1hdGguaW11bChsZSwgT3QpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoTiwgQnQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoTiwgRnQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoWSwgQnQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoWSwgRnQpIHwgMDtcbiAgICAgICAgdmFyIFJhID0gKFYgKyBMIHwgMCkgKyAoKG0gJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBWID0gKHYgKyAobSA+Pj4gMTMpIHwgMCkgKyAoUmEgPj4+IDI2KSB8IDAsIFJhICY9IDY3MTA4ODYzLCBMID0gTWF0aC5pbXVsKFEsIFBlKSwgbSA9IE1hdGguaW11bChRLCBMZSksIG0gPSBtICsgTWF0aC5pbXVsKHNlLCBQZSkgfCAwLCB2ID0gTWF0aC5pbXVsKHNlLCBMZSksIEwgPSBMICsgTWF0aC5pbXVsKFQsIEFlKSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFQsIFR0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEcsIEFlKSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKEcsIFR0KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKGplLCB3dCkgfCAwLCBtID0gbSArIE1hdGguaW11bChqZSwgQXQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoQiwgd3QpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoQiwgQXQpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoSmUsIEl0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEplLCBfdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChRZSwgSXQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoUWUsIF90KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKHdlLCBSdCkgfCAwLCBtID0gbSArIE1hdGguaW11bCh3ZSwgTHQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoTmUsIFJ0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKE5lLCBMdCkgfCAwLCBMID0gTCArIE1hdGguaW11bChiZSwgQ3QpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoYmUsIGt0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEZlLCBDdCkgfCAwLCB2ID0gdiArIE1hdGguaW11bChGZSwga3QpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoeGUsIER0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHhlLCBQdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChCZSwgRHQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoQmUsIFB0KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKERlLCBNdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChEZSwgT3QpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoemUsIE10KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKHplLCBPdCkgfCAwLCBMID0gTCArIE1hdGguaW11bChpZSwgQnQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoaWUsIEZ0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKGxlLCBCdCkgfCAwLCB2ID0gdiArIE1hdGguaW11bChsZSwgRnQpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoTiwgTnQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoTiwgVXQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoWSwgTnQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoWSwgVXQpIHwgMDtcbiAgICAgICAgdmFyIExhID0gKFYgKyBMIHwgMCkgKyAoKG0gJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBWID0gKHYgKyAobSA+Pj4gMTMpIHwgMCkgKyAoTGEgPj4+IDI2KSB8IDAsIExhICY9IDY3MTA4ODYzLCBMID0gTWF0aC5pbXVsKFEsIEFlKSwgbSA9IE1hdGguaW11bChRLCBUdCksIG0gPSBtICsgTWF0aC5pbXVsKHNlLCBBZSkgfCAwLCB2ID0gTWF0aC5pbXVsKHNlLCBUdCksIEwgPSBMICsgTWF0aC5pbXVsKFQsIHd0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFQsIEF0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEcsIHd0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKEcsIEF0KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKGplLCBJdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChqZSwgX3QpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoQiwgSXQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoQiwgX3QpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoSmUsIFJ0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEplLCBMdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChRZSwgUnQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoUWUsIEx0KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKHdlLCBDdCkgfCAwLCBtID0gbSArIE1hdGguaW11bCh3ZSwga3QpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoTmUsIEN0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKE5lLCBrdCkgfCAwLCBMID0gTCArIE1hdGguaW11bChiZSwgRHQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoYmUsIFB0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEZlLCBEdCkgfCAwLCB2ID0gdiArIE1hdGguaW11bChGZSwgUHQpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoeGUsIE10KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHhlLCBPdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChCZSwgTXQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoQmUsIE90KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKERlLCBCdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChEZSwgRnQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoemUsIEJ0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKHplLCBGdCkgfCAwLCBMID0gTCArIE1hdGguaW11bChpZSwgTnQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoaWUsIFV0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKGxlLCBOdCkgfCAwLCB2ID0gdiArIE1hdGguaW11bChsZSwgVXQpIHwgMDtcbiAgICAgICAgdmFyIENhID0gKFYgKyBMIHwgMCkgKyAoKG0gJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBWID0gKHYgKyAobSA+Pj4gMTMpIHwgMCkgKyAoQ2EgPj4+IDI2KSB8IDAsIENhICY9IDY3MTA4ODYzLCBMID0gTWF0aC5pbXVsKFEsIHd0KSwgbSA9IE1hdGguaW11bChRLCBBdCksIG0gPSBtICsgTWF0aC5pbXVsKHNlLCB3dCkgfCAwLCB2ID0gTWF0aC5pbXVsKHNlLCBBdCksIEwgPSBMICsgTWF0aC5pbXVsKFQsIEl0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFQsIF90KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEcsIEl0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKEcsIF90KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKGplLCBSdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChqZSwgTHQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoQiwgUnQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoQiwgTHQpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoSmUsIEN0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEplLCBrdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChRZSwgQ3QpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoUWUsIGt0KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKHdlLCBEdCkgfCAwLCBtID0gbSArIE1hdGguaW11bCh3ZSwgUHQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoTmUsIER0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKE5lLCBQdCkgfCAwLCBMID0gTCArIE1hdGguaW11bChiZSwgTXQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoYmUsIE90KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEZlLCBNdCkgfCAwLCB2ID0gdiArIE1hdGguaW11bChGZSwgT3QpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoeGUsIEJ0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHhlLCBGdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChCZSwgQnQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoQmUsIEZ0KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKERlLCBOdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChEZSwgVXQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoemUsIE50KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKHplLCBVdCkgfCAwO1xuICAgICAgICB2YXIga2EgPSAoViArIEwgfCAwKSArICgobSAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICAgIFYgPSAodiArIChtID4+PiAxMykgfCAwKSArIChrYSA+Pj4gMjYpIHwgMCwga2EgJj0gNjcxMDg4NjMsIEwgPSBNYXRoLmltdWwoUSwgSXQpLCBtID0gTWF0aC5pbXVsKFEsIF90KSwgbSA9IG0gKyBNYXRoLmltdWwoc2UsIEl0KSB8IDAsIHYgPSBNYXRoLmltdWwoc2UsIF90KSwgTCA9IEwgKyBNYXRoLmltdWwoVCwgUnQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoVCwgTHQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoRywgUnQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoRywgTHQpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoamUsIEN0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKGplLCBrdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChCLCBDdCkgfCAwLCB2ID0gdiArIE1hdGguaW11bChCLCBrdCkgfCAwLCBMID0gTCArIE1hdGguaW11bChKZSwgRHQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoSmUsIFB0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFFlLCBEdCkgfCAwLCB2ID0gdiArIE1hdGguaW11bChRZSwgUHQpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwod2UsIE10KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKHdlLCBPdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChOZSwgTXQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoTmUsIE90KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKGJlLCBCdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChiZSwgRnQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoRmUsIEJ0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKEZlLCBGdCkgfCAwLCBMID0gTCArIE1hdGguaW11bCh4ZSwgTnQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoeGUsIFV0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEJlLCBOdCkgfCAwLCB2ID0gdiArIE1hdGguaW11bChCZSwgVXQpIHwgMDtcbiAgICAgICAgdmFyIERhID0gKFYgKyBMIHwgMCkgKyAoKG0gJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBWID0gKHYgKyAobSA+Pj4gMTMpIHwgMCkgKyAoRGEgPj4+IDI2KSB8IDAsIERhICY9IDY3MTA4ODYzLCBMID0gTWF0aC5pbXVsKFEsIFJ0KSwgbSA9IE1hdGguaW11bChRLCBMdCksIG0gPSBtICsgTWF0aC5pbXVsKHNlLCBSdCkgfCAwLCB2ID0gTWF0aC5pbXVsKHNlLCBMdCksIEwgPSBMICsgTWF0aC5pbXVsKFQsIEN0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFQsIGt0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEcsIEN0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKEcsIGt0KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKGplLCBEdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChqZSwgUHQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoQiwgRHQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoQiwgUHQpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoSmUsIE10KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEplLCBPdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChRZSwgTXQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoUWUsIE90KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKHdlLCBCdCkgfCAwLCBtID0gbSArIE1hdGguaW11bCh3ZSwgRnQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoTmUsIEJ0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKE5lLCBGdCkgfCAwLCBMID0gTCArIE1hdGguaW11bChiZSwgTnQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoYmUsIFV0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEZlLCBOdCkgfCAwLCB2ID0gdiArIE1hdGguaW11bChGZSwgVXQpIHwgMDtcbiAgICAgICAgdmFyIFBhID0gKFYgKyBMIHwgMCkgKyAoKG0gJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBWID0gKHYgKyAobSA+Pj4gMTMpIHwgMCkgKyAoUGEgPj4+IDI2KSB8IDAsIFBhICY9IDY3MTA4ODYzLCBMID0gTWF0aC5pbXVsKFEsIEN0KSwgbSA9IE1hdGguaW11bChRLCBrdCksIG0gPSBtICsgTWF0aC5pbXVsKHNlLCBDdCkgfCAwLCB2ID0gTWF0aC5pbXVsKHNlLCBrdCksIEwgPSBMICsgTWF0aC5pbXVsKFQsIER0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFQsIFB0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEcsIER0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKEcsIFB0KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKGplLCBNdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChqZSwgT3QpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoQiwgTXQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoQiwgT3QpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoSmUsIEJ0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEplLCBGdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChRZSwgQnQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoUWUsIEZ0KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKHdlLCBOdCkgfCAwLCBtID0gbSArIE1hdGguaW11bCh3ZSwgVXQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoTmUsIE50KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKE5lLCBVdCkgfCAwO1xuICAgICAgICB2YXIgTWEgPSAoViArIEwgfCAwKSArICgobSAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICAgIFYgPSAodiArIChtID4+PiAxMykgfCAwKSArIChNYSA+Pj4gMjYpIHwgMCwgTWEgJj0gNjcxMDg4NjMsIEwgPSBNYXRoLmltdWwoUSwgRHQpLCBtID0gTWF0aC5pbXVsKFEsIFB0KSwgbSA9IG0gKyBNYXRoLmltdWwoc2UsIER0KSB8IDAsIHYgPSBNYXRoLmltdWwoc2UsIFB0KSwgTCA9IEwgKyBNYXRoLmltdWwoVCwgTXQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoVCwgT3QpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoRywgTXQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoRywgT3QpIHwgMCwgTCA9IEwgKyBNYXRoLmltdWwoamUsIEJ0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKGplLCBGdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChCLCBCdCkgfCAwLCB2ID0gdiArIE1hdGguaW11bChCLCBGdCkgfCAwLCBMID0gTCArIE1hdGguaW11bChKZSwgTnQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoSmUsIFV0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFFlLCBOdCkgfCAwLCB2ID0gdiArIE1hdGguaW11bChRZSwgVXQpIHwgMDtcbiAgICAgICAgdmFyIE9hID0gKFYgKyBMIHwgMCkgKyAoKG0gJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBWID0gKHYgKyAobSA+Pj4gMTMpIHwgMCkgKyAoT2EgPj4+IDI2KSB8IDAsIE9hICY9IDY3MTA4ODYzLCBMID0gTWF0aC5pbXVsKFEsIE10KSwgbSA9IE1hdGguaW11bChRLCBPdCksIG0gPSBtICsgTWF0aC5pbXVsKHNlLCBNdCkgfCAwLCB2ID0gTWF0aC5pbXVsKHNlLCBPdCksIEwgPSBMICsgTWF0aC5pbXVsKFQsIEJ0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFQsIEZ0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEcsIEJ0KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKEcsIEZ0KSB8IDAsIEwgPSBMICsgTWF0aC5pbXVsKGplLCBOdCkgfCAwLCBtID0gbSArIE1hdGguaW11bChqZSwgVXQpIHwgMCwgbSA9IG0gKyBNYXRoLmltdWwoQiwgTnQpIHwgMCwgdiA9IHYgKyBNYXRoLmltdWwoQiwgVXQpIHwgMDtcbiAgICAgICAgdmFyIEJhID0gKFYgKyBMIHwgMCkgKyAoKG0gJiA4MTkxKSA8PCAxMykgfCAwO1xuICAgICAgICBWID0gKHYgKyAobSA+Pj4gMTMpIHwgMCkgKyAoQmEgPj4+IDI2KSB8IDAsIEJhICY9IDY3MTA4ODYzLCBMID0gTWF0aC5pbXVsKFEsIEJ0KSwgbSA9IE1hdGguaW11bChRLCBGdCksIG0gPSBtICsgTWF0aC5pbXVsKHNlLCBCdCkgfCAwLCB2ID0gTWF0aC5pbXVsKHNlLCBGdCksIEwgPSBMICsgTWF0aC5pbXVsKFQsIE50KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKFQsIFV0KSB8IDAsIG0gPSBtICsgTWF0aC5pbXVsKEcsIE50KSB8IDAsIHYgPSB2ICsgTWF0aC5pbXVsKEcsIFV0KSB8IDA7XG4gICAgICAgIHZhciBGYSA9IChWICsgTCB8IDApICsgKChtICYgODE5MSkgPDwgMTMpIHwgMDtcbiAgICAgICAgViA9ICh2ICsgKG0gPj4+IDEzKSB8IDApICsgKEZhID4+PiAyNikgfCAwLCBGYSAmPSA2NzEwODg2MywgTCA9IE1hdGguaW11bChRLCBOdCksIG0gPSBNYXRoLmltdWwoUSwgVXQpLCBtID0gbSArIE1hdGguaW11bChzZSwgTnQpIHwgMCwgdiA9IE1hdGguaW11bChzZSwgVXQpO1xuICAgICAgICB2YXIgTmEgPSAoViArIEwgfCAwKSArICgobSAmIDgxOTEpIDw8IDEzKSB8IDA7XG4gICAgICAgIHJldHVybiBWID0gKHYgKyAobSA+Pj4gMTMpIHwgMCkgKyAoTmEgPj4+IDI2KSB8IDAsIE5hICY9IDY3MTA4ODYzLCBVWzBdID0geGEsIFVbMV0gPSBTYSwgVVsyXSA9IGJhLCBVWzNdID0gVGEsIFVbNF0gPSB3YSwgVVs1XSA9IEFhLCBVWzZdID0gSWEsIFVbN10gPSBfYSwgVVs4XSA9IFJhLCBVWzldID0gTGEsIFVbMTBdID0gQ2EsIFVbMTFdID0ga2EsIFVbMTJdID0gRGEsIFVbMTNdID0gUGEsIFVbMTRdID0gTWEsIFVbMTVdID0gT2EsIFVbMTZdID0gQmEsIFVbMTddID0gRmEsIFVbMThdID0gTmEsIFYgIT09IDAgJiYgKFVbMTldID0gViwgdy5sZW5ndGgrKyksIHc7XG4gICAgICB9O1xuICAgICAgTWF0aC5pbXVsIHx8IChSID0gYik7XG4gICAgICBmdW5jdGlvbiBBKF8sIGcsIHgpIHtcbiAgICAgICAgeC5uZWdhdGl2ZSA9IGcubmVnYXRpdmUgXiBfLm5lZ2F0aXZlLCB4Lmxlbmd0aCA9IF8ubGVuZ3RoICsgZy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIHcgPSAwLCBEID0gMCwgTyA9IDA7IE8gPCB4Lmxlbmd0aCAtIDE7IE8rKykge1xuICAgICAgICAgIHZhciBVID0gRDtcbiAgICAgICAgICBEID0gMDtcbiAgICAgICAgICBmb3IgKHZhciBWID0gdyAmIDY3MTA4ODYzLCBMID0gTWF0aC5taW4oTywgZy5sZW5ndGggLSAxKSwgbSA9IE1hdGgubWF4KDAsIE8gLSBfLmxlbmd0aCArIDEpOyBtIDw9IEw7IG0rKykge1xuICAgICAgICAgICAgdmFyIHYgPSBPIC0gbSwgUCA9IF8ud29yZHNbdl0gfCAwLCBOID0gZy53b3Jkc1ttXSB8IDAsIFkgPSBQICogTiwgZWUgPSBZICYgNjcxMDg4NjM7XG4gICAgICAgICAgICBVID0gVSArIChZIC8gNjcxMDg4NjQgfCAwKSB8IDAsIGVlID0gZWUgKyBWIHwgMCwgViA9IGVlICYgNjcxMDg4NjMsIFUgPSBVICsgKGVlID4+PiAyNikgfCAwLCBEICs9IFUgPj4+IDI2LCBVICY9IDY3MTA4ODYzO1xuICAgICAgICAgIH1cbiAgICAgICAgICB4LndvcmRzW09dID0gViwgdyA9IFUsIFUgPSBEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ICE9PSAwID8geC53b3Jkc1tPXSA9IHcgOiB4Lmxlbmd0aC0tLCB4Ll9zdHJpcCgpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gRihfLCBnLCB4KSB7XG4gICAgICAgIHJldHVybiBBKF8sIGcsIHgpO1xuICAgICAgfVxuICAgICAgaS5wcm90b3R5cGUubXVsVG8gPSBmdW5jdGlvbihnLCB4KSB7XG4gICAgICAgIHZhciB3LCBEID0gdGhpcy5sZW5ndGggKyBnLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxMCAmJiBnLmxlbmd0aCA9PT0gMTAgPyB3ID0gUih0aGlzLCBnLCB4KSA6IEQgPCA2MyA/IHcgPSBiKHRoaXMsIGcsIHgpIDogRCA8IDEwMjQgPyB3ID0gQSh0aGlzLCBnLCB4KSA6IHcgPSBGKHRoaXMsIGcsIHgpLCB3O1xuICAgICAgfSwgaS5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24oZykge1xuICAgICAgICB2YXIgeCA9IG5ldyBpKG51bGwpO1xuICAgICAgICByZXR1cm4geC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIGcubGVuZ3RoKSwgdGhpcy5tdWxUbyhnLCB4KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLm11bGYgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHZhciB4ID0gbmV3IGkobnVsbCk7XG4gICAgICAgIHJldHVybiB4LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgZy5sZW5ndGgpLCBGKHRoaXMsIGcsIHgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5tdWxUbyhnLCB0aGlzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmltdWxuID0gZnVuY3Rpb24oZykge1xuICAgICAgICB2YXIgeCA9IGcgPCAwO1xuICAgICAgICB4ICYmIChnID0gLWcpLCByKHR5cGVvZiBnID09IFwibnVtYmVyXCIpLCByKGcgPCA2NzEwODg2NCk7XG4gICAgICAgIGZvciAodmFyIHcgPSAwLCBEID0gMDsgRCA8IHRoaXMubGVuZ3RoOyBEKyspIHtcbiAgICAgICAgICB2YXIgTyA9ICh0aGlzLndvcmRzW0RdIHwgMCkgKiBnLCBVID0gKE8gJiA2NzEwODg2MykgKyAodyAmIDY3MTA4ODYzKTtcbiAgICAgICAgICB3ID4+PSAyNiwgdyArPSBPIC8gNjcxMDg4NjQgfCAwLCB3ICs9IFUgPj4+IDI2LCB0aGlzLndvcmRzW0RdID0gVSAmIDY3MTA4ODYzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB3ICE9PSAwICYmICh0aGlzLndvcmRzW0RdID0gdywgdGhpcy5sZW5ndGgrKyksIHRoaXMubGVuZ3RoID0gZyA9PT0gMCA/IDEgOiB0aGlzLmxlbmd0aCwgeCA/IHRoaXMuaW5lZygpIDogdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLm11bG4gPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4oZyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKHRoaXMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbXVsKHRoaXMuY2xvbmUoKSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHZhciB4ID0gRShnKTtcbiAgICAgICAgaWYgKHgubGVuZ3RoID09PSAwKSByZXR1cm4gbmV3IGkoMSk7XG4gICAgICAgIGZvciAodmFyIHcgPSB0aGlzLCBEID0gMDsgRCA8IHgubGVuZ3RoICYmIHhbRF0gPT09IDA7IEQrKywgdyA9IHcuc3FyKCkpXG4gICAgICAgICAgO1xuICAgICAgICBpZiAoKytEIDwgeC5sZW5ndGgpXG4gICAgICAgICAgZm9yICh2YXIgTyA9IHcuc3FyKCk7IEQgPCB4Lmxlbmd0aDsgRCsrLCBPID0gTy5zcXIoKSlcbiAgICAgICAgICAgIHhbRF0gIT09IDAgJiYgKHcgPSB3Lm11bChPKSk7XG4gICAgICAgIHJldHVybiB3O1xuICAgICAgfSwgaS5wcm90b3R5cGUuaXVzaGxuID0gZnVuY3Rpb24oZykge1xuICAgICAgICByKHR5cGVvZiBnID09IFwibnVtYmVyXCIgJiYgZyA+PSAwKTtcbiAgICAgICAgdmFyIHggPSBnICUgMjYsIHcgPSAoZyAtIHgpIC8gMjYsIEQgPSA2NzEwODg2MyA+Pj4gMjYgLSB4IDw8IDI2IC0geCwgTztcbiAgICAgICAgaWYgKHggIT09IDApIHtcbiAgICAgICAgICB2YXIgVSA9IDA7XG4gICAgICAgICAgZm9yIChPID0gMDsgTyA8IHRoaXMubGVuZ3RoOyBPKyspIHtcbiAgICAgICAgICAgIHZhciBWID0gdGhpcy53b3Jkc1tPXSAmIEQsIEwgPSAodGhpcy53b3Jkc1tPXSB8IDApIC0gViA8PCB4O1xuICAgICAgICAgICAgdGhpcy53b3Jkc1tPXSA9IEwgfCBVLCBVID0gViA+Pj4gMjYgLSB4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBVICYmICh0aGlzLndvcmRzW09dID0gVSwgdGhpcy5sZW5ndGgrKyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHcgIT09IDApIHtcbiAgICAgICAgICBmb3IgKE8gPSB0aGlzLmxlbmd0aCAtIDE7IE8gPj0gMDsgTy0tKVxuICAgICAgICAgICAgdGhpcy53b3Jkc1tPICsgd10gPSB0aGlzLndvcmRzW09dO1xuICAgICAgICAgIGZvciAoTyA9IDA7IE8gPCB3OyBPKyspXG4gICAgICAgICAgICB0aGlzLndvcmRzW09dID0gMDtcbiAgICAgICAgICB0aGlzLmxlbmd0aCArPSB3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiByKHRoaXMubmVnYXRpdmUgPT09IDApLCB0aGlzLml1c2hsbihnKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLml1c2hybiA9IGZ1bmN0aW9uKGcsIHgsIHcpIHtcbiAgICAgICAgcih0eXBlb2YgZyA9PSBcIm51bWJlclwiICYmIGcgPj0gMCk7XG4gICAgICAgIHZhciBEO1xuICAgICAgICB4ID8gRCA9ICh4IC0geCAlIDI2KSAvIDI2IDogRCA9IDA7XG4gICAgICAgIHZhciBPID0gZyAlIDI2LCBVID0gTWF0aC5taW4oKGcgLSBPKSAvIDI2LCB0aGlzLmxlbmd0aCksIFYgPSA2NzEwODg2MyBeIDY3MTA4ODYzID4+PiBPIDw8IE8sIEwgPSB3O1xuICAgICAgICBpZiAoRCAtPSBVLCBEID0gTWF0aC5tYXgoMCwgRCksIEwpIHtcbiAgICAgICAgICBmb3IgKHZhciBtID0gMDsgbSA8IFU7IG0rKylcbiAgICAgICAgICAgIEwud29yZHNbbV0gPSB0aGlzLndvcmRzW21dO1xuICAgICAgICAgIEwubGVuZ3RoID0gVTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVSAhPT0gMCkgaWYgKHRoaXMubGVuZ3RoID4gVSlcbiAgICAgICAgICBmb3IgKHRoaXMubGVuZ3RoIC09IFUsIG0gPSAwOyBtIDwgdGhpcy5sZW5ndGg7IG0rKylcbiAgICAgICAgICAgIHRoaXMud29yZHNbbV0gPSB0aGlzLndvcmRzW20gKyBVXTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRoaXMud29yZHNbMF0gPSAwLCB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICAgIHZhciB2ID0gMDtcbiAgICAgICAgZm9yIChtID0gdGhpcy5sZW5ndGggLSAxOyBtID49IDAgJiYgKHYgIT09IDAgfHwgbSA+PSBEKTsgbS0tKSB7XG4gICAgICAgICAgdmFyIFAgPSB0aGlzLndvcmRzW21dIHwgMDtcbiAgICAgICAgICB0aGlzLndvcmRzW21dID0gdiA8PCAyNiAtIE8gfCBQID4+PiBPLCB2ID0gUCAmIFY7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEwgJiYgdiAhPT0gMCAmJiAoTC53b3Jkc1tMLmxlbmd0aCsrXSA9IHYpLCB0aGlzLmxlbmd0aCA9PT0gMCAmJiAodGhpcy53b3Jkc1swXSA9IDAsIHRoaXMubGVuZ3RoID0gMSksIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pc2hybiA9IGZ1bmN0aW9uKGcsIHgsIHcpIHtcbiAgICAgICAgcmV0dXJuIHIodGhpcy5uZWdhdGl2ZSA9PT0gMCksIHRoaXMuaXVzaHJuKGcsIHgsIHcpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc2hsbiA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hsbihnKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnVzaGxuID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihnKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnNocm4gPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNocm4oZyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oZyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS50ZXN0biA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcih0eXBlb2YgZyA9PSBcIm51bWJlclwiICYmIGcgPj0gMCk7XG4gICAgICAgIHZhciB4ID0gZyAlIDI2LCB3ID0gKGcgLSB4KSAvIDI2LCBEID0gMSA8PCB4O1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPD0gdykgcmV0dXJuICExO1xuICAgICAgICB2YXIgTyA9IHRoaXMud29yZHNbd107XG4gICAgICAgIHJldHVybiAhIShPICYgRCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHIodHlwZW9mIGcgPT0gXCJudW1iZXJcIiAmJiBnID49IDApO1xuICAgICAgICB2YXIgeCA9IGcgJSAyNiwgdyA9IChnIC0geCkgLyAyNjtcbiAgICAgICAgaWYgKHIodGhpcy5uZWdhdGl2ZSA9PT0gMCwgXCJpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnNcIiksIHRoaXMubGVuZ3RoIDw9IHcpXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICh4ICE9PSAwICYmIHcrKywgdGhpcy5sZW5ndGggPSBNYXRoLm1pbih3LCB0aGlzLmxlbmd0aCksIHggIT09IDApIHtcbiAgICAgICAgICB2YXIgRCA9IDY3MTA4ODYzIF4gNjcxMDg4NjMgPj4+IHggPDwgeDtcbiAgICAgICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gJj0gRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLm1hc2tuID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltYXNrbihnKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmlhZGRuID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gcih0eXBlb2YgZyA9PSBcIm51bWJlclwiKSwgcihnIDwgNjcxMDg4NjQpLCBnIDwgMCA/IHRoaXMuaXN1Ym4oLWcpIDogdGhpcy5uZWdhdGl2ZSAhPT0gMCA/IHRoaXMubGVuZ3RoID09PSAxICYmICh0aGlzLndvcmRzWzBdIHwgMCkgPD0gZyA/ICh0aGlzLndvcmRzWzBdID0gZyAtICh0aGlzLndvcmRzWzBdIHwgMCksIHRoaXMubmVnYXRpdmUgPSAwLCB0aGlzKSA6ICh0aGlzLm5lZ2F0aXZlID0gMCwgdGhpcy5pc3VibihnKSwgdGhpcy5uZWdhdGl2ZSA9IDEsIHRoaXMpIDogdGhpcy5faWFkZG4oZyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5faWFkZG4gPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gZztcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW3hdID49IDY3MTA4ODY0OyB4KyspXG4gICAgICAgICAgdGhpcy53b3Jkc1t4XSAtPSA2NzEwODg2NCwgeCA9PT0gdGhpcy5sZW5ndGggLSAxID8gdGhpcy53b3Jkc1t4ICsgMV0gPSAxIDogdGhpcy53b3Jkc1t4ICsgMV0rKztcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIHggKyAxKSwgdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLmlzdWJuID0gZnVuY3Rpb24oZykge1xuICAgICAgICBpZiAocih0eXBlb2YgZyA9PSBcIm51bWJlclwiKSwgcihnIDwgNjcxMDg4NjQpLCBnIDwgMCkgcmV0dXJuIHRoaXMuaWFkZG4oLWcpO1xuICAgICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMClcbiAgICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSA9IDAsIHRoaXMuaWFkZG4oZyksIHRoaXMubmVnYXRpdmUgPSAxLCB0aGlzO1xuICAgICAgICBpZiAodGhpcy53b3Jkc1swXSAtPSBnLCB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdIDwgMClcbiAgICAgICAgICB0aGlzLndvcmRzWzBdID0gLXRoaXMud29yZHNbMF0sIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW3hdIDwgMDsgeCsrKVxuICAgICAgICAgICAgdGhpcy53b3Jkc1t4XSArPSA2NzEwODg2NCwgdGhpcy53b3Jkc1t4ICsgMV0gLT0gMTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGRuKGcpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihnKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmlhYnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgPSAwLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFicygpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24oZywgeCwgdykge1xuICAgICAgICB2YXIgRCA9IGcubGVuZ3RoICsgdywgTztcbiAgICAgICAgdGhpcy5fZXhwYW5kKEQpO1xuICAgICAgICB2YXIgVSwgViA9IDA7XG4gICAgICAgIGZvciAoTyA9IDA7IE8gPCBnLmxlbmd0aDsgTysrKSB7XG4gICAgICAgICAgVSA9ICh0aGlzLndvcmRzW08gKyB3XSB8IDApICsgVjtcbiAgICAgICAgICB2YXIgTCA9IChnLndvcmRzW09dIHwgMCkgKiB4O1xuICAgICAgICAgIFUgLT0gTCAmIDY3MTA4ODYzLCBWID0gKFUgPj4gMjYpIC0gKEwgLyA2NzEwODg2NCB8IDApLCB0aGlzLndvcmRzW08gKyB3XSA9IFUgJiA2NzEwODg2MztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgTyA8IHRoaXMubGVuZ3RoIC0gdzsgTysrKVxuICAgICAgICAgIFUgPSAodGhpcy53b3Jkc1tPICsgd10gfCAwKSArIFYsIFYgPSBVID4+IDI2LCB0aGlzLndvcmRzW08gKyB3XSA9IFUgJiA2NzEwODg2MztcbiAgICAgICAgaWYgKFYgPT09IDApIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICAgICAgICBmb3IgKHIoViA9PT0gLTEpLCBWID0gMCwgTyA9IDA7IE8gPCB0aGlzLmxlbmd0aDsgTysrKVxuICAgICAgICAgIFUgPSAtKHRoaXMud29yZHNbT10gfCAwKSArIFYsIFYgPSBVID4+IDI2LCB0aGlzLndvcmRzW09dID0gVSAmIDY3MTA4ODYzO1xuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSA9IDEsIHRoaXMuX3N0cmlwKCk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uKGcsIHgpIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLmxlbmd0aCAtIGcubGVuZ3RoLCBEID0gdGhpcy5jbG9uZSgpLCBPID0gZywgVSA9IE8ud29yZHNbTy5sZW5ndGggLSAxXSB8IDAsIFYgPSB0aGlzLl9jb3VudEJpdHMoVSk7XG4gICAgICAgIHcgPSAyNiAtIFYsIHcgIT09IDAgJiYgKE8gPSBPLnVzaGxuKHcpLCBELml1c2hsbih3KSwgVSA9IE8ud29yZHNbTy5sZW5ndGggLSAxXSB8IDApO1xuICAgICAgICB2YXIgTCA9IEQubGVuZ3RoIC0gTy5sZW5ndGgsIG07XG4gICAgICAgIGlmICh4ICE9PSBcIm1vZFwiKSB7XG4gICAgICAgICAgbSA9IG5ldyBpKG51bGwpLCBtLmxlbmd0aCA9IEwgKyAxLCBtLndvcmRzID0gbmV3IEFycmF5KG0ubGVuZ3RoKTtcbiAgICAgICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IG0ubGVuZ3RoOyB2KyspXG4gICAgICAgICAgICBtLndvcmRzW3ZdID0gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgUCA9IEQuY2xvbmUoKS5faXNobG5zdWJtdWwoTywgMSwgTCk7XG4gICAgICAgIFAubmVnYXRpdmUgPT09IDAgJiYgKEQgPSBQLCBtICYmIChtLndvcmRzW0xdID0gMSkpO1xuICAgICAgICBmb3IgKHZhciBOID0gTCAtIDE7IE4gPj0gMDsgTi0tKSB7XG4gICAgICAgICAgdmFyIFkgPSAoRC53b3Jkc1tPLmxlbmd0aCArIE5dIHwgMCkgKiA2NzEwODg2NCArIChELndvcmRzW08ubGVuZ3RoICsgTiAtIDFdIHwgMCk7XG4gICAgICAgICAgZm9yIChZID0gTWF0aC5taW4oWSAvIFUgfCAwLCA2NzEwODg2MyksIEQuX2lzaGxuc3VibXVsKE8sIFksIE4pOyBELm5lZ2F0aXZlICE9PSAwOyApXG4gICAgICAgICAgICBZLS0sIEQubmVnYXRpdmUgPSAwLCBELl9pc2hsbnN1Ym11bChPLCAxLCBOKSwgRC5pc1plcm8oKSB8fCAoRC5uZWdhdGl2ZSBePSAxKTtcbiAgICAgICAgICBtICYmIChtLndvcmRzW05dID0gWSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0gJiYgbS5fc3RyaXAoKSwgRC5fc3RyaXAoKSwgeCAhPT0gXCJkaXZcIiAmJiB3ICE9PSAwICYmIEQuaXVzaHJuKHcpLCB7XG4gICAgICAgICAgZGl2OiBtIHx8IG51bGwsXG4gICAgICAgICAgbW9kOiBEXG4gICAgICAgIH07XG4gICAgICB9LCBpLnByb3RvdHlwZS5kaXZtb2QgPSBmdW5jdGlvbihnLCB4LCB3KSB7XG4gICAgICAgIGlmIChyKCFnLmlzWmVybygpKSwgdGhpcy5pc1plcm8oKSlcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGl2OiBuZXcgaSgwKSxcbiAgICAgICAgICAgIG1vZDogbmV3IGkoMClcbiAgICAgICAgICB9O1xuICAgICAgICB2YXIgRCwgTywgVTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDAgJiYgZy5uZWdhdGl2ZSA9PT0gMCA/IChVID0gdGhpcy5uZWcoKS5kaXZtb2QoZywgeCksIHggIT09IFwibW9kXCIgJiYgKEQgPSBVLmRpdi5uZWcoKSksIHggIT09IFwiZGl2XCIgJiYgKE8gPSBVLm1vZC5uZWcoKSwgdyAmJiBPLm5lZ2F0aXZlICE9PSAwICYmIE8uaWFkZChnKSksIHtcbiAgICAgICAgICBkaXY6IEQsXG4gICAgICAgICAgbW9kOiBPXG4gICAgICAgIH0pIDogdGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBnLm5lZ2F0aXZlICE9PSAwID8gKFUgPSB0aGlzLmRpdm1vZChnLm5lZygpLCB4KSwgeCAhPT0gXCJtb2RcIiAmJiAoRCA9IFUuZGl2Lm5lZygpKSwge1xuICAgICAgICAgIGRpdjogRCxcbiAgICAgICAgICBtb2Q6IFUubW9kXG4gICAgICAgIH0pIDogKHRoaXMubmVnYXRpdmUgJiBnLm5lZ2F0aXZlKSAhPT0gMCA/IChVID0gdGhpcy5uZWcoKS5kaXZtb2QoZy5uZWcoKSwgeCksIHggIT09IFwiZGl2XCIgJiYgKE8gPSBVLm1vZC5uZWcoKSwgdyAmJiBPLm5lZ2F0aXZlICE9PSAwICYmIE8uaXN1YihnKSksIHtcbiAgICAgICAgICBkaXY6IFUuZGl2LFxuICAgICAgICAgIG1vZDogT1xuICAgICAgICB9KSA6IGcubGVuZ3RoID4gdGhpcy5sZW5ndGggfHwgdGhpcy5jbXAoZykgPCAwID8ge1xuICAgICAgICAgIGRpdjogbmV3IGkoMCksXG4gICAgICAgICAgbW9kOiB0aGlzXG4gICAgICAgIH0gOiBnLmxlbmd0aCA9PT0gMSA/IHggPT09IFwiZGl2XCIgPyB7XG4gICAgICAgICAgZGl2OiB0aGlzLmRpdm4oZy53b3Jkc1swXSksXG4gICAgICAgICAgbW9kOiBudWxsXG4gICAgICAgIH0gOiB4ID09PSBcIm1vZFwiID8ge1xuICAgICAgICAgIGRpdjogbnVsbCxcbiAgICAgICAgICBtb2Q6IG5ldyBpKHRoaXMubW9kcm4oZy53b3Jkc1swXSkpXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgZGl2OiB0aGlzLmRpdm4oZy53b3Jkc1swXSksXG4gICAgICAgICAgbW9kOiBuZXcgaSh0aGlzLm1vZHJuKGcud29yZHNbMF0pKVxuICAgICAgICB9IDogdGhpcy5fd29yZERpdihnLCB4KTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2bW9kKGcsIFwiZGl2XCIsICExKS5kaXY7XG4gICAgICB9LCBpLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpdm1vZChnLCBcIm1vZFwiLCAhMSkubW9kO1xuICAgICAgfSwgaS5wcm90b3R5cGUudW1vZCA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGl2bW9kKGcsIFwibW9kXCIsICEwKS5tb2Q7XG4gICAgICB9LCBpLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLmRpdm1vZChnKTtcbiAgICAgICAgaWYgKHgubW9kLmlzWmVybygpKSByZXR1cm4geC5kaXY7XG4gICAgICAgIHZhciB3ID0geC5kaXYubmVnYXRpdmUgIT09IDAgPyB4Lm1vZC5pc3ViKGcpIDogeC5tb2QsIEQgPSBnLnVzaHJuKDEpLCBPID0gZy5hbmRsbigxKSwgVSA9IHcuY21wKEQpO1xuICAgICAgICByZXR1cm4gVSA8IDAgfHwgTyA9PT0gMSAmJiBVID09PSAwID8geC5kaXYgOiB4LmRpdi5uZWdhdGl2ZSAhPT0gMCA/IHguZGl2LmlzdWJuKDEpIDogeC5kaXYuaWFkZG4oMSk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5tb2RybiA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgdmFyIHggPSBnIDwgMDtcbiAgICAgICAgeCAmJiAoZyA9IC1nKSwgcihnIDw9IDY3MTA4ODYzKTtcbiAgICAgICAgZm9yICh2YXIgdyA9ICgxIDw8IDI2KSAlIGcsIEQgPSAwLCBPID0gdGhpcy5sZW5ndGggLSAxOyBPID49IDA7IE8tLSlcbiAgICAgICAgICBEID0gKHcgKiBEICsgKHRoaXMud29yZHNbT10gfCAwKSkgJSBnO1xuICAgICAgICByZXR1cm4geCA/IC1EIDogRDtcbiAgICAgIH0sIGkucHJvdG90eXBlLm1vZG4gPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZHJuKGcpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaWRpdm4gPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHZhciB4ID0gZyA8IDA7XG4gICAgICAgIHggJiYgKGcgPSAtZyksIHIoZyA8PSA2NzEwODg2Myk7XG4gICAgICAgIGZvciAodmFyIHcgPSAwLCBEID0gdGhpcy5sZW5ndGggLSAxOyBEID49IDA7IEQtLSkge1xuICAgICAgICAgIHZhciBPID0gKHRoaXMud29yZHNbRF0gfCAwKSArIHcgKiA2NzEwODg2NDtcbiAgICAgICAgICB0aGlzLndvcmRzW0RdID0gTyAvIGcgfCAwLCB3ID0gTyAlIGc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0cmlwKCksIHggPyB0aGlzLmluZWcoKSA6IHRoaXM7XG4gICAgICB9LCBpLnByb3RvdHlwZS5kaXZuID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKGcpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcihnLm5lZ2F0aXZlID09PSAwKSwgcighZy5pc1plcm8oKSk7XG4gICAgICAgIHZhciB4ID0gdGhpcywgdyA9IGcuY2xvbmUoKTtcbiAgICAgICAgeC5uZWdhdGl2ZSAhPT0gMCA/IHggPSB4LnVtb2QoZykgOiB4ID0geC5jbG9uZSgpO1xuICAgICAgICBmb3IgKHZhciBEID0gbmV3IGkoMSksIE8gPSBuZXcgaSgwKSwgVSA9IG5ldyBpKDApLCBWID0gbmV3IGkoMSksIEwgPSAwOyB4LmlzRXZlbigpICYmIHcuaXNFdmVuKCk7IClcbiAgICAgICAgICB4Lml1c2hybigxKSwgdy5pdXNocm4oMSksICsrTDtcbiAgICAgICAgZm9yICh2YXIgbSA9IHcuY2xvbmUoKSwgdiA9IHguY2xvbmUoKTsgIXguaXNaZXJvKCk7ICkge1xuICAgICAgICAgIGZvciAodmFyIFAgPSAwLCBOID0gMTsgKHgud29yZHNbMF0gJiBOKSA9PT0gMCAmJiBQIDwgMjY7ICsrUCwgTiA8PD0gMSkgO1xuICAgICAgICAgIGlmIChQID4gMClcbiAgICAgICAgICAgIGZvciAoeC5pdXNocm4oUCk7IFAtLSA+IDA7IClcbiAgICAgICAgICAgICAgKEQuaXNPZGQoKSB8fCBPLmlzT2RkKCkpICYmIChELmlhZGQobSksIE8uaXN1Yih2KSksIEQuaXVzaHJuKDEpLCBPLml1c2hybigxKTtcbiAgICAgICAgICBmb3IgKHZhciBZID0gMCwgZWUgPSAxOyAody53b3Jkc1swXSAmIGVlKSA9PT0gMCAmJiBZIDwgMjY7ICsrWSwgZWUgPDw9IDEpIDtcbiAgICAgICAgICBpZiAoWSA+IDApXG4gICAgICAgICAgICBmb3IgKHcuaXVzaHJuKFkpOyBZLS0gPiAwOyApXG4gICAgICAgICAgICAgIChVLmlzT2RkKCkgfHwgVi5pc09kZCgpKSAmJiAoVS5pYWRkKG0pLCBWLmlzdWIodikpLCBVLml1c2hybigxKSwgVi5pdXNocm4oMSk7XG4gICAgICAgICAgeC5jbXAodykgPj0gMCA/ICh4LmlzdWIodyksIEQuaXN1YihVKSwgTy5pc3ViKFYpKSA6ICh3LmlzdWIoeCksIFUuaXN1YihEKSwgVi5pc3ViKE8pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGE6IFUsXG4gICAgICAgICAgYjogVixcbiAgICAgICAgICBnY2Q6IHcuaXVzaGxuKEwpXG4gICAgICAgIH07XG4gICAgICB9LCBpLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHIoZy5uZWdhdGl2ZSA9PT0gMCksIHIoIWcuaXNaZXJvKCkpO1xuICAgICAgICB2YXIgeCA9IHRoaXMsIHcgPSBnLmNsb25lKCk7XG4gICAgICAgIHgubmVnYXRpdmUgIT09IDAgPyB4ID0geC51bW9kKGcpIDogeCA9IHguY2xvbmUoKTtcbiAgICAgICAgZm9yICh2YXIgRCA9IG5ldyBpKDEpLCBPID0gbmV3IGkoMCksIFUgPSB3LmNsb25lKCk7IHguY21wbigxKSA+IDAgJiYgdy5jbXBuKDEpID4gMDsgKSB7XG4gICAgICAgICAgZm9yICh2YXIgViA9IDAsIEwgPSAxOyAoeC53b3Jkc1swXSAmIEwpID09PSAwICYmIFYgPCAyNjsgKytWLCBMIDw8PSAxKSA7XG4gICAgICAgICAgaWYgKFYgPiAwKVxuICAgICAgICAgICAgZm9yICh4Lml1c2hybihWKTsgVi0tID4gMDsgKVxuICAgICAgICAgICAgICBELmlzT2RkKCkgJiYgRC5pYWRkKFUpLCBELml1c2hybigxKTtcbiAgICAgICAgICBmb3IgKHZhciBtID0gMCwgdiA9IDE7ICh3LndvcmRzWzBdICYgdikgPT09IDAgJiYgbSA8IDI2OyArK20sIHYgPDw9IDEpIDtcbiAgICAgICAgICBpZiAobSA+IDApXG4gICAgICAgICAgICBmb3IgKHcuaXVzaHJuKG0pOyBtLS0gPiAwOyApXG4gICAgICAgICAgICAgIE8uaXNPZGQoKSAmJiBPLmlhZGQoVSksIE8uaXVzaHJuKDEpO1xuICAgICAgICAgIHguY21wKHcpID49IDAgPyAoeC5pc3ViKHcpLCBELmlzdWIoTykpIDogKHcuaXN1Yih4KSwgTy5pc3ViKEQpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgUDtcbiAgICAgICAgcmV0dXJuIHguY21wbigxKSA9PT0gMCA/IFAgPSBEIDogUCA9IE8sIFAuY21wbigwKSA8IDAgJiYgUC5pYWRkKGcpLCBQO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ2NkID0gZnVuY3Rpb24oZykge1xuICAgICAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIGcuYWJzKCk7XG4gICAgICAgIGlmIChnLmlzWmVybygpKSByZXR1cm4gdGhpcy5hYnMoKTtcbiAgICAgICAgdmFyIHggPSB0aGlzLmNsb25lKCksIHcgPSBnLmNsb25lKCk7XG4gICAgICAgIHgubmVnYXRpdmUgPSAwLCB3Lm5lZ2F0aXZlID0gMDtcbiAgICAgICAgZm9yICh2YXIgRCA9IDA7IHguaXNFdmVuKCkgJiYgdy5pc0V2ZW4oKTsgRCsrKVxuICAgICAgICAgIHguaXVzaHJuKDEpLCB3Lml1c2hybigxKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGZvciAoOyB4LmlzRXZlbigpOyApXG4gICAgICAgICAgICB4Lml1c2hybigxKTtcbiAgICAgICAgICBmb3IgKDsgdy5pc0V2ZW4oKTsgKVxuICAgICAgICAgICAgdy5pdXNocm4oMSk7XG4gICAgICAgICAgdmFyIE8gPSB4LmNtcCh3KTtcbiAgICAgICAgICBpZiAoTyA8IDApIHtcbiAgICAgICAgICAgIHZhciBVID0geDtcbiAgICAgICAgICAgIHggPSB3LCB3ID0gVTtcbiAgICAgICAgICB9IGVsc2UgaWYgKE8gPT09IDAgfHwgdy5jbXBuKDEpID09PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgeC5pc3ViKHcpO1xuICAgICAgICB9IHdoaWxlICghMCk7XG4gICAgICAgIHJldHVybiB3Lml1c2hsbihEKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVnY2QoZykuYS51bW9kKGcpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAwO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG4gICAgICB9LCBpLnByb3RvdHlwZS5hbmRsbiA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBnO1xuICAgICAgfSwgaS5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHIodHlwZW9mIGcgPT0gXCJudW1iZXJcIik7XG4gICAgICAgIHZhciB4ID0gZyAlIDI2LCB3ID0gKGcgLSB4KSAvIDI2LCBEID0gMSA8PCB4O1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPD0gdylcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZXhwYW5kKHcgKyAxKSwgdGhpcy53b3Jkc1t3XSB8PSBELCB0aGlzO1xuICAgICAgICBmb3IgKHZhciBPID0gRCwgVSA9IHc7IE8gIT09IDAgJiYgVSA8IHRoaXMubGVuZ3RoOyBVKyspIHtcbiAgICAgICAgICB2YXIgViA9IHRoaXMud29yZHNbVV0gfCAwO1xuICAgICAgICAgIFYgKz0gTywgTyA9IFYgPj4+IDI2LCBWICY9IDY3MTA4ODYzLCB0aGlzLndvcmRzW1VdID0gVjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTyAhPT0gMCAmJiAodGhpcy53b3Jkc1tVXSA9IE8sIHRoaXMubGVuZ3RoKyspLCB0aGlzO1xuICAgICAgfSwgaS5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwO1xuICAgICAgfSwgaS5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgdmFyIHggPSBnIDwgMDtcbiAgICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgIXgpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgeCkgcmV0dXJuIDE7XG4gICAgICAgIHRoaXMuX3N0cmlwKCk7XG4gICAgICAgIHZhciB3O1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiAxKVxuICAgICAgICAgIHcgPSAxO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB4ICYmIChnID0gLWcpLCByKGcgPD0gNjcxMDg4NjMsIFwiTnVtYmVyIGlzIHRvbyBiaWdcIik7XG4gICAgICAgICAgdmFyIEQgPSB0aGlzLndvcmRzWzBdIHwgMDtcbiAgICAgICAgICB3ID0gRCA9PT0gZyA/IDAgOiBEIDwgZyA/IC0xIDogMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMCA/IC13IHwgMCA6IHc7XG4gICAgICB9LCBpLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIGcubmVnYXRpdmUgPT09IDApIHJldHVybiAtMTtcbiAgICAgICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgZy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIDE7XG4gICAgICAgIHZhciB4ID0gdGhpcy51Y21wKGcpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMCA/IC14IHwgMCA6IHg7XG4gICAgICB9LCBpLnByb3RvdHlwZS51Y21wID0gZnVuY3Rpb24oZykge1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggPiBnLmxlbmd0aCkgcmV0dXJuIDE7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA8IGcubGVuZ3RoKSByZXR1cm4gLTE7XG4gICAgICAgIGZvciAodmFyIHggPSAwLCB3ID0gdGhpcy5sZW5ndGggLSAxOyB3ID49IDA7IHctLSkge1xuICAgICAgICAgIHZhciBEID0gdGhpcy53b3Jkc1t3XSB8IDAsIE8gPSBnLndvcmRzW3ddIHwgMDtcbiAgICAgICAgICBpZiAoRCAhPT0gTykge1xuICAgICAgICAgICAgRCA8IE8gPyB4ID0gLTEgOiBEID4gTyAmJiAoeCA9IDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ3RuID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbXBuKGcpID09PSAxO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNtcChnKSA9PT0gMTtcbiAgICAgIH0sIGkucHJvdG90eXBlLmd0ZW4gPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNtcG4oZykgPj0gMDtcbiAgICAgIH0sIGkucHJvdG90eXBlLmd0ZSA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY21wKGcpID49IDA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5sdG4gPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNtcG4oZykgPT09IC0xO1xuICAgICAgfSwgaS5wcm90b3R5cGUubHQgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNtcChnKSA9PT0gLTE7XG4gICAgICB9LCBpLnByb3RvdHlwZS5sdGVuID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbXBuKGcpIDw9IDA7XG4gICAgICB9LCBpLnByb3RvdHlwZS5sdGUgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNtcChnKSA8PSAwO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZXFuID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gdGhpcy5jbXBuKGcpID09PSAwO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNtcChnKSA9PT0gMDtcbiAgICAgIH0sIGkucmVkID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gbmV3ICQoZyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS50b1JlZCA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIHIoIXRoaXMucmVkLCBcIkFscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHRcIiksIHIodGhpcy5uZWdhdGl2ZSA9PT0gMCwgXCJyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlc1wiKSwgZy5jb252ZXJ0VG8odGhpcykuX2ZvcmNlUmVkKGcpO1xuICAgICAgfSwgaS5wcm90b3R5cGUuZnJvbVJlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcih0aGlzLnJlZCwgXCJmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0XCIpLCB0aGlzLnJlZC5jb252ZXJ0RnJvbSh0aGlzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLl9mb3JjZVJlZCA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkID0gZywgdGhpcztcbiAgICAgIH0sIGkucHJvdG90eXBlLmZvcmNlUmVkID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gcighdGhpcy5yZWQsIFwiQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dFwiKSwgdGhpcy5fZm9yY2VSZWQoZyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiByKHRoaXMucmVkLCBcInJlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksIHRoaXMucmVkLmFkZCh0aGlzLCBnKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiByKHRoaXMucmVkLCBcInJlZElBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5pYWRkKHRoaXMsIGcpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVkU3ViID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gcih0aGlzLnJlZCwgXCJyZWRTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5zdWIodGhpcywgZyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZWRJU3ViID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gcih0aGlzLnJlZCwgXCJyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuaXN1Yih0aGlzLCBnKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlZFNobCA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIHIodGhpcy5yZWQsIFwicmVkU2hsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuc2hsKHRoaXMsIGcpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVkTXVsID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gcih0aGlzLnJlZCwgXCJyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBnKSwgdGhpcy5yZWQubXVsKHRoaXMsIGcpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVkSU11bCA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIHIodGhpcy5yZWQsIFwicmVkTXVsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgZyksIHRoaXMucmVkLmltdWwodGhpcywgZyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZWRTcXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHIodGhpcy5yZWQsIFwicmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyksIHRoaXMucmVkLnNxcih0aGlzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHIodGhpcy5yZWQsIFwicmVkSVNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIiksIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpLCB0aGlzLnJlZC5pc3FyKHRoaXMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVkU3FydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcih0aGlzLnJlZCwgXCJyZWRTcXJ0IHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVyc1wiKSwgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyksIHRoaXMucmVkLnNxcnQodGhpcyk7XG4gICAgICB9LCBpLnByb3RvdHlwZS5yZWRJbnZtID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByKHRoaXMucmVkLCBcInJlZEludm0gd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKSwgdGhpcy5yZWQuaW52bSh0aGlzKTtcbiAgICAgIH0sIGkucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcih0aGlzLnJlZCwgXCJyZWROZWcgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzXCIpLCB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKSwgdGhpcy5yZWQubmVnKHRoaXMpO1xuICAgICAgfSwgaS5wcm90b3R5cGUucmVkUG93ID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gcih0aGlzLnJlZCAmJiAhZy5yZWQsIFwicmVkUG93KG5vcm1hbE51bSlcIiksIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpLCB0aGlzLnJlZC5wb3codGhpcywgZyk7XG4gICAgICB9O1xuICAgICAgdmFyIE0gPSB7XG4gICAgICAgIGsyNTY6IG51bGwsXG4gICAgICAgIHAyMjQ6IG51bGwsXG4gICAgICAgIHAxOTI6IG51bGwsXG4gICAgICAgIHAyNTUxOTogbnVsbFxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIEgoXywgZykge1xuICAgICAgICB0aGlzLm5hbWUgPSBfLCB0aGlzLnAgPSBuZXcgaShnLCAxNiksIHRoaXMubiA9IHRoaXMucC5iaXRMZW5ndGgoKSwgdGhpcy5rID0gbmV3IGkoMSkuaXVzaGxuKHRoaXMubikuaXN1Yih0aGlzLnApLCB0aGlzLnRtcCA9IHRoaXMuX3RtcCgpO1xuICAgICAgfVxuICAgICAgSC5wcm90b3R5cGUuX3RtcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZyA9IG5ldyBpKG51bGwpO1xuICAgICAgICByZXR1cm4gZy53b3JkcyA9IG5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uIC8gMTMpKSwgZztcbiAgICAgIH0sIEgucHJvdG90eXBlLmlyZWR1Y2UgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHZhciB4ID0gZywgdztcbiAgICAgICAgZG9cbiAgICAgICAgICB0aGlzLnNwbGl0KHgsIHRoaXMudG1wKSwgeCA9IHRoaXMuaW11bEsoeCksIHggPSB4LmlhZGQodGhpcy50bXApLCB3ID0geC5iaXRMZW5ndGgoKTtcbiAgICAgICAgd2hpbGUgKHcgPiB0aGlzLm4pO1xuICAgICAgICB2YXIgRCA9IHcgPCB0aGlzLm4gPyAtMSA6IHgudWNtcCh0aGlzLnApO1xuICAgICAgICByZXR1cm4gRCA9PT0gMCA/ICh4LndvcmRzWzBdID0gMCwgeC5sZW5ndGggPSAxKSA6IEQgPiAwID8geC5pc3ViKHRoaXMucCkgOiB4LnN0cmlwICE9PSB2b2lkIDAgPyB4LnN0cmlwKCkgOiB4Ll9zdHJpcCgpLCB4O1xuICAgICAgfSwgSC5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbihnLCB4KSB7XG4gICAgICAgIGcuaXVzaHJuKHRoaXMubiwgMCwgeCk7XG4gICAgICB9LCBILnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIGcuaW11bCh0aGlzLmspO1xuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIEsoKSB7XG4gICAgICAgIEguY2FsbChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIFwiazI1NlwiLFxuICAgICAgICAgIFwiZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmZcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgbihLLCBIKSwgSy5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbihnLCB4KSB7XG4gICAgICAgIGZvciAodmFyIHcgPSA0MTk0MzAzLCBEID0gTWF0aC5taW4oZy5sZW5ndGgsIDkpLCBPID0gMDsgTyA8IEQ7IE8rKylcbiAgICAgICAgICB4LndvcmRzW09dID0gZy53b3Jkc1tPXTtcbiAgICAgICAgaWYgKHgubGVuZ3RoID0gRCwgZy5sZW5ndGggPD0gOSkge1xuICAgICAgICAgIGcud29yZHNbMF0gPSAwLCBnLmxlbmd0aCA9IDE7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBVID0gZy53b3Jkc1s5XTtcbiAgICAgICAgZm9yICh4LndvcmRzW3gubGVuZ3RoKytdID0gVSAmIHcsIE8gPSAxMDsgTyA8IGcubGVuZ3RoOyBPKyspIHtcbiAgICAgICAgICB2YXIgViA9IGcud29yZHNbT10gfCAwO1xuICAgICAgICAgIGcud29yZHNbTyAtIDEwXSA9IChWICYgdykgPDwgNCB8IFUgPj4+IDIyLCBVID0gVjtcbiAgICAgICAgfVxuICAgICAgICBVID4+Pj0gMjIsIGcud29yZHNbTyAtIDEwXSA9IFUsIFUgPT09IDAgJiYgZy5sZW5ndGggPiAxMCA/IGcubGVuZ3RoIC09IDEwIDogZy5sZW5ndGggLT0gOTtcbiAgICAgIH0sIEsucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24oZykge1xuICAgICAgICBnLndvcmRzW2cubGVuZ3RoXSA9IDAsIGcud29yZHNbZy5sZW5ndGggKyAxXSA9IDAsIGcubGVuZ3RoICs9IDI7XG4gICAgICAgIGZvciAodmFyIHggPSAwLCB3ID0gMDsgdyA8IGcubGVuZ3RoOyB3KyspIHtcbiAgICAgICAgICB2YXIgRCA9IGcud29yZHNbd10gfCAwO1xuICAgICAgICAgIHggKz0gRCAqIDk3NywgZy53b3Jkc1t3XSA9IHggJiA2NzEwODg2MywgeCA9IEQgKiA2NCArICh4IC8gNjcxMDg4NjQgfCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZy53b3Jkc1tnLmxlbmd0aCAtIDFdID09PSAwICYmIChnLmxlbmd0aC0tLCBnLndvcmRzW2cubGVuZ3RoIC0gMV0gPT09IDAgJiYgZy5sZW5ndGgtLSksIGc7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gaigpIHtcbiAgICAgICAgSC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgXCJwMjI0XCIsXG4gICAgICAgICAgXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMVwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBuKGosIEgpO1xuICAgICAgZnVuY3Rpb24gQygpIHtcbiAgICAgICAgSC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgXCJwMTkyXCIsXG4gICAgICAgICAgXCJmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZlwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBuKEMsIEgpO1xuICAgICAgZnVuY3Rpb24gaygpIHtcbiAgICAgICAgSC5jYWxsKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgXCIyNTUxOVwiLFxuICAgICAgICAgIFwiN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBuKGssIEgpLCBrLnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IDAsIHcgPSAwOyB3IDwgZy5sZW5ndGg7IHcrKykge1xuICAgICAgICAgIHZhciBEID0gKGcud29yZHNbd10gfCAwKSAqIDE5ICsgeCwgTyA9IEQgJiA2NzEwODg2MztcbiAgICAgICAgICBEID4+Pj0gMjYsIGcud29yZHNbd10gPSBPLCB4ID0gRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCAhPT0gMCAmJiAoZy53b3Jkc1tnLmxlbmd0aCsrXSA9IHgpLCBnO1xuICAgICAgfSwgaS5fcHJpbWUgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIGlmIChNW2ddKSByZXR1cm4gTVtnXTtcbiAgICAgICAgdmFyIHg7XG4gICAgICAgIGlmIChnID09PSBcImsyNTZcIilcbiAgICAgICAgICB4ID0gbmV3IEsoKTtcbiAgICAgICAgZWxzZSBpZiAoZyA9PT0gXCJwMjI0XCIpXG4gICAgICAgICAgeCA9IG5ldyBqKCk7XG4gICAgICAgIGVsc2UgaWYgKGcgPT09IFwicDE5MlwiKVxuICAgICAgICAgIHggPSBuZXcgQygpO1xuICAgICAgICBlbHNlIGlmIChnID09PSBcInAyNTUxOVwiKVxuICAgICAgICAgIHggPSBuZXcgaygpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBwcmltZSBcIiArIGcpO1xuICAgICAgICByZXR1cm4gTVtnXSA9IHgsIHg7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gJChfKSB7XG4gICAgICAgIGlmICh0eXBlb2YgXyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgdmFyIGcgPSBpLl9wcmltZShfKTtcbiAgICAgICAgICB0aGlzLm0gPSBnLnAsIHRoaXMucHJpbWUgPSBnO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICByKF8uZ3RuKDEpLCBcIm1vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMVwiKSwgdGhpcy5tID0gXywgdGhpcy5wcmltZSA9IG51bGw7XG4gICAgICB9XG4gICAgICAkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcihnLm5lZ2F0aXZlID09PSAwLCBcInJlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzXCIpLCByKGcucmVkLCBcInJlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIik7XG4gICAgICB9LCAkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uKGcsIHgpIHtcbiAgICAgICAgcigoZy5uZWdhdGl2ZSB8IHgubmVnYXRpdmUpID09PSAwLCBcInJlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzXCIpLCByKFxuICAgICAgICAgIGcucmVkICYmIGcucmVkID09PSB4LnJlZCxcbiAgICAgICAgICBcInJlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnNcIlxuICAgICAgICApO1xuICAgICAgfSwgJC5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJpbWUgPyB0aGlzLnByaW1lLmlyZWR1Y2UoZykuX2ZvcmNlUmVkKHRoaXMpIDogKHUoZywgZy51bW9kKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpKSwgZyk7XG4gICAgICB9LCAkLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiBnLmlzWmVybygpID8gZy5jbG9uZSgpIDogdGhpcy5tLnN1YihnKS5fZm9yY2VSZWQodGhpcyk7XG4gICAgICB9LCAkLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihnLCB4KSB7XG4gICAgICAgIHRoaXMuX3ZlcmlmeTIoZywgeCk7XG4gICAgICAgIHZhciB3ID0gZy5hZGQoeCk7XG4gICAgICAgIHJldHVybiB3LmNtcCh0aGlzLm0pID49IDAgJiYgdy5pc3ViKHRoaXMubSksIHcuX2ZvcmNlUmVkKHRoaXMpO1xuICAgICAgfSwgJC5wcm90b3R5cGUuaWFkZCA9IGZ1bmN0aW9uKGcsIHgpIHtcbiAgICAgICAgdGhpcy5fdmVyaWZ5MihnLCB4KTtcbiAgICAgICAgdmFyIHcgPSBnLmlhZGQoeCk7XG4gICAgICAgIHJldHVybiB3LmNtcCh0aGlzLm0pID49IDAgJiYgdy5pc3ViKHRoaXMubSksIHc7XG4gICAgICB9LCAkLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbihnLCB4KSB7XG4gICAgICAgIHRoaXMuX3ZlcmlmeTIoZywgeCk7XG4gICAgICAgIHZhciB3ID0gZy5zdWIoeCk7XG4gICAgICAgIHJldHVybiB3LmNtcG4oMCkgPCAwICYmIHcuaWFkZCh0aGlzLm0pLCB3Ll9mb3JjZVJlZCh0aGlzKTtcbiAgICAgIH0sICQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbihnLCB4KSB7XG4gICAgICAgIHRoaXMuX3ZlcmlmeTIoZywgeCk7XG4gICAgICAgIHZhciB3ID0gZy5pc3ViKHgpO1xuICAgICAgICByZXR1cm4gdy5jbXBuKDApIDwgMCAmJiB3LmlhZGQodGhpcy5tKSwgdztcbiAgICAgIH0sICQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uKGcsIHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcmlmeTEoZyksIHRoaXMuaW1vZChnLnVzaGxuKHgpKTtcbiAgICAgIH0sICQucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbihnLCB4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92ZXJpZnkyKGcsIHgpLCB0aGlzLmltb2QoZy5pbXVsKHgpKTtcbiAgICAgIH0sICQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKGcsIHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZlcmlmeTIoZywgeCksIHRoaXMuaW1vZChnLm11bCh4KSk7XG4gICAgICB9LCAkLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gdGhpcy5pbXVsKGcsIGcuY2xvbmUoKSk7XG4gICAgICB9LCAkLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm11bChnLCBnKTtcbiAgICAgIH0sICQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIGlmIChnLmlzWmVybygpKSByZXR1cm4gZy5jbG9uZSgpO1xuICAgICAgICB2YXIgeCA9IHRoaXMubS5hbmRsbigzKTtcbiAgICAgICAgaWYgKHIoeCAlIDIgPT09IDEpLCB4ID09PSAzKSB7XG4gICAgICAgICAgdmFyIHcgPSB0aGlzLm0uYWRkKG5ldyBpKDEpKS5pdXNocm4oMik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMucG93KGcsIHcpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIEQgPSB0aGlzLm0uc3VibigxKSwgTyA9IDA7ICFELmlzWmVybygpICYmIEQuYW5kbG4oMSkgPT09IDA7IClcbiAgICAgICAgICBPKyssIEQuaXVzaHJuKDEpO1xuICAgICAgICByKCFELmlzWmVybygpKTtcbiAgICAgICAgdmFyIFUgPSBuZXcgaSgxKS50b1JlZCh0aGlzKSwgViA9IFUucmVkTmVnKCksIEwgPSB0aGlzLm0uc3VibigxKS5pdXNocm4oMSksIG0gPSB0aGlzLm0uYml0TGVuZ3RoKCk7XG4gICAgICAgIGZvciAobSA9IG5ldyBpKDIgKiBtICogbSkudG9SZWQodGhpcyk7IHRoaXMucG93KG0sIEwpLmNtcChWKSAhPT0gMDsgKVxuICAgICAgICAgIG0ucmVkSUFkZChWKTtcbiAgICAgICAgZm9yICh2YXIgdiA9IHRoaXMucG93KG0sIEQpLCBQID0gdGhpcy5wb3coZywgRC5hZGRuKDEpLml1c2hybigxKSksIE4gPSB0aGlzLnBvdyhnLCBEKSwgWSA9IE87IE4uY21wKFUpICE9PSAwOyApIHtcbiAgICAgICAgICBmb3IgKHZhciBlZSA9IE4sIGllID0gMDsgZWUuY21wKFUpICE9PSAwOyBpZSsrKVxuICAgICAgICAgICAgZWUgPSBlZS5yZWRTcXIoKTtcbiAgICAgICAgICByKGllIDwgWSk7XG4gICAgICAgICAgdmFyIGxlID0gdGhpcy5wb3codiwgbmV3IGkoMSkuaXVzaGxuKFkgLSBpZSAtIDEpKTtcbiAgICAgICAgICBQID0gUC5yZWRNdWwobGUpLCB2ID0gbGUucmVkU3FyKCksIE4gPSBOLnJlZE11bCh2KSwgWSA9IGllO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQO1xuICAgICAgfSwgJC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgdmFyIHggPSBnLl9pbnZtcCh0aGlzLm0pO1xuICAgICAgICByZXR1cm4geC5uZWdhdGl2ZSAhPT0gMCA/ICh4Lm5lZ2F0aXZlID0gMCwgdGhpcy5pbW9kKHgpLnJlZE5lZygpKSA6IHRoaXMuaW1vZCh4KTtcbiAgICAgIH0sICQucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uKGcsIHgpIHtcbiAgICAgICAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBuZXcgaSgxKS50b1JlZCh0aGlzKTtcbiAgICAgICAgaWYgKHguY21wbigxKSA9PT0gMCkgcmV0dXJuIGcuY2xvbmUoKTtcbiAgICAgICAgdmFyIHcgPSA0LCBEID0gbmV3IEFycmF5KDEgPDwgdyk7XG4gICAgICAgIERbMF0gPSBuZXcgaSgxKS50b1JlZCh0aGlzKSwgRFsxXSA9IGc7XG4gICAgICAgIGZvciAodmFyIE8gPSAyOyBPIDwgRC5sZW5ndGg7IE8rKylcbiAgICAgICAgICBEW09dID0gdGhpcy5tdWwoRFtPIC0gMV0sIGcpO1xuICAgICAgICB2YXIgVSA9IERbMF0sIFYgPSAwLCBMID0gMCwgbSA9IHguYml0TGVuZ3RoKCkgJSAyNjtcbiAgICAgICAgZm9yIChtID09PSAwICYmIChtID0gMjYpLCBPID0geC5sZW5ndGggLSAxOyBPID49IDA7IE8tLSkge1xuICAgICAgICAgIGZvciAodmFyIHYgPSB4LndvcmRzW09dLCBQID0gbSAtIDE7IFAgPj0gMDsgUC0tKSB7XG4gICAgICAgICAgICB2YXIgTiA9IHYgPj4gUCAmIDE7XG4gICAgICAgICAgICBpZiAoVSAhPT0gRFswXSAmJiAoVSA9IHRoaXMuc3FyKFUpKSwgTiA9PT0gMCAmJiBWID09PSAwKSB7XG4gICAgICAgICAgICAgIEwgPSAwO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFYgPDw9IDEsIFYgfD0gTiwgTCsrLCAhKEwgIT09IHcgJiYgKE8gIT09IDAgfHwgUCAhPT0gMCkpICYmIChVID0gdGhpcy5tdWwoVSwgRFtWXSksIEwgPSAwLCBWID0gMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG0gPSAyNjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVTtcbiAgICAgIH0sICQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgdmFyIHggPSBnLnVtb2QodGhpcy5tKTtcbiAgICAgICAgcmV0dXJuIHggPT09IGcgPyB4LmNsb25lKCkgOiB4O1xuICAgICAgfSwgJC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHZhciB4ID0gZy5jbG9uZSgpO1xuICAgICAgICByZXR1cm4geC5yZWQgPSBudWxsLCB4O1xuICAgICAgfSwgaS5tb250ID0gZnVuY3Rpb24oZykge1xuICAgICAgICByZXR1cm4gbmV3IFcoZyk7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gVyhfKSB7XG4gICAgICAgICQuY2FsbCh0aGlzLCBfKSwgdGhpcy5zaGlmdCA9IHRoaXMubS5iaXRMZW5ndGgoKSwgdGhpcy5zaGlmdCAlIDI2ICE9PSAwICYmICh0aGlzLnNoaWZ0ICs9IDI2IC0gdGhpcy5zaGlmdCAlIDI2KSwgdGhpcy5yID0gbmV3IGkoMSkuaXVzaGxuKHRoaXMuc2hpZnQpLCB0aGlzLnIyID0gdGhpcy5pbW9kKHRoaXMuci5zcXIoKSksIHRoaXMucmludiA9IHRoaXMuci5faW52bXAodGhpcy5tKSwgdGhpcy5taW52ID0gdGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pLCB0aGlzLm1pbnYgPSB0aGlzLm1pbnYudW1vZCh0aGlzLnIpLCB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG4gICAgICB9XG4gICAgICBuKFcsICQpLCBXLnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltb2QoZy51c2hsbih0aGlzLnNoaWZ0KSk7XG4gICAgICB9LCBXLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uKGcpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLmltb2QoZy5tdWwodGhpcy5yaW52KSk7XG4gICAgICAgIHJldHVybiB4LnJlZCA9IG51bGwsIHg7XG4gICAgICB9LCBXLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24oZywgeCkge1xuICAgICAgICBpZiAoZy5pc1plcm8oKSB8fCB4LmlzWmVybygpKVxuICAgICAgICAgIHJldHVybiBnLndvcmRzWzBdID0gMCwgZy5sZW5ndGggPSAxLCBnO1xuICAgICAgICB2YXIgdyA9IGcuaW11bCh4KSwgRCA9IHcubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pLCBPID0gdy5pc3ViKEQpLml1c2hybih0aGlzLnNoaWZ0KSwgVSA9IE87XG4gICAgICAgIHJldHVybiBPLmNtcCh0aGlzLm0pID49IDAgPyBVID0gTy5pc3ViKHRoaXMubSkgOiBPLmNtcG4oMCkgPCAwICYmIChVID0gTy5pYWRkKHRoaXMubSkpLCBVLl9mb3JjZVJlZCh0aGlzKTtcbiAgICAgIH0sIFcucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uKGcsIHgpIHtcbiAgICAgICAgaWYgKGcuaXNaZXJvKCkgfHwgeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBpKDApLl9mb3JjZVJlZCh0aGlzKTtcbiAgICAgICAgdmFyIHcgPSBnLm11bCh4KSwgRCA9IHcubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pLCBPID0gdy5pc3ViKEQpLml1c2hybih0aGlzLnNoaWZ0KSwgVSA9IE87XG4gICAgICAgIHJldHVybiBPLmNtcCh0aGlzLm0pID49IDAgPyBVID0gTy5pc3ViKHRoaXMubSkgOiBPLmNtcG4oMCkgPCAwICYmIChVID0gTy5pYWRkKHRoaXMubSkpLCBVLl9mb3JjZVJlZCh0aGlzKTtcbiAgICAgIH0sIFcucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbihnKSB7XG4gICAgICAgIHZhciB4ID0gdGhpcy5pbW9kKGcuX2ludm1wKHRoaXMubSkubXVsKHRoaXMucjIpKTtcbiAgICAgICAgcmV0dXJuIHguX2ZvcmNlUmVkKHRoaXMpO1xuICAgICAgfTtcbiAgICB9KShzLCBNeSk7XG4gIH0pKGNvKSksIGNvLmV4cG9ydHM7XG59XG52YXIgT3kgPSB2MCgpO1xuY29uc3QgYmQgPSAvKiBAX19QVVJFX18gKi8gRmMoT3kpO1xudmFyIFVpID0geyBleHBvcnRzOiB7fSB9O1xuLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG52YXIgVGQ7XG5mdW5jdGlvbiBCeSgpIHtcbiAgcmV0dXJuIFRkIHx8IChUZCA9IDEsIChmdW5jdGlvbihzLCBlKSB7XG4gICAgdmFyIHQgPSBLYygpLCByID0gdC5CdWZmZXI7XG4gICAgZnVuY3Rpb24gbihvLCBhKSB7XG4gICAgICBmb3IgKHZhciBsIGluIG8pXG4gICAgICAgIGFbbF0gPSBvW2xdO1xuICAgIH1cbiAgICByLmZyb20gJiYgci5hbGxvYyAmJiByLmFsbG9jVW5zYWZlICYmIHIuYWxsb2NVbnNhZmVTbG93ID8gcy5leHBvcnRzID0gdCA6IChuKHQsIGUpLCBlLkJ1ZmZlciA9IGkpO1xuICAgIGZ1bmN0aW9uIGkobywgYSwgbCkge1xuICAgICAgcmV0dXJuIHIobywgYSwgbCk7XG4gICAgfVxuICAgIGkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShyLnByb3RvdHlwZSksIG4ociwgaSksIGkuZnJvbSA9IGZ1bmN0aW9uKG8sIGEsIGwpIHtcbiAgICAgIGlmICh0eXBlb2YgbyA9PSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXJcIik7XG4gICAgICByZXR1cm4gcihvLCBhLCBsKTtcbiAgICB9LCBpLmFsbG9jID0gZnVuY3Rpb24obywgYSwgbCkge1xuICAgICAgaWYgKHR5cGVvZiBvICE9IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyXCIpO1xuICAgICAgdmFyIGMgPSByKG8pO1xuICAgICAgcmV0dXJuIGEgIT09IHZvaWQgMCA/IHR5cGVvZiBsID09IFwic3RyaW5nXCIgPyBjLmZpbGwoYSwgbCkgOiBjLmZpbGwoYSkgOiBjLmZpbGwoMCksIGM7XG4gICAgfSwgaS5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uKG8pIHtcbiAgICAgIGlmICh0eXBlb2YgbyAhPSBcIm51bWJlclwiKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlclwiKTtcbiAgICAgIHJldHVybiByKG8pO1xuICAgIH0sIGkuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24obykge1xuICAgICAgaWYgKHR5cGVvZiBvICE9IFwibnVtYmVyXCIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyXCIpO1xuICAgICAgcmV0dXJuIHQuU2xvd0J1ZmZlcihvKTtcbiAgICB9O1xuICB9KShVaSwgVWkuZXhwb3J0cykpLCBVaS5leHBvcnRzO1xufVxudmFyIHphLCB3ZDtcbmZ1bmN0aW9uIEUwKCkge1xuICBpZiAod2QpIHJldHVybiB6YTtcbiAgd2QgPSAxO1xuICB2YXIgcyA9IEJ5KCkuQnVmZmVyO1xuICBmdW5jdGlvbiBlKHQpIHtcbiAgICBpZiAodC5sZW5ndGggPj0gMjU1KVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFscGhhYmV0IHRvbyBsb25nXCIpO1xuICAgIGZvciAodmFyIHIgPSBuZXcgVWludDhBcnJheSgyNTYpLCBuID0gMDsgbiA8IHIubGVuZ3RoOyBuKyspXG4gICAgICByW25dID0gMjU1O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG8gPSB0LmNoYXJBdChpKSwgYSA9IG8uY2hhckNvZGVBdCgwKTtcbiAgICAgIGlmIChyW2FdICE9PSAyNTUpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobyArIFwiIGlzIGFtYmlndW91c1wiKTtcbiAgICAgIHJbYV0gPSBpO1xuICAgIH1cbiAgICB2YXIgbCA9IHQubGVuZ3RoLCBjID0gdC5jaGFyQXQoMCksIHUgPSBNYXRoLmxvZyhsKSAvIE1hdGgubG9nKDI1NiksIGQgPSBNYXRoLmxvZygyNTYpIC8gTWF0aC5sb2cobCk7XG4gICAgZnVuY3Rpb24gaCh5KSB7XG4gICAgICBpZiAoKEFycmF5LmlzQXJyYXkoeSkgfHwgeSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpICYmICh5ID0gcy5mcm9tKHkpKSwgIXMuaXNCdWZmZXIoeSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBCdWZmZXJcIik7XG4gICAgICBpZiAoeS5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgZm9yICh2YXIgRSA9IDAsIGIgPSAwLCBSID0gMCwgQSA9IHkubGVuZ3RoOyBSICE9PSBBICYmIHlbUl0gPT09IDA7IClcbiAgICAgICAgUisrLCBFKys7XG4gICAgICBmb3IgKHZhciBGID0gKEEgLSBSKSAqIGQgKyAxID4+PiAwLCBNID0gbmV3IFVpbnQ4QXJyYXkoRik7IFIgIT09IEE7ICkge1xuICAgICAgICBmb3IgKHZhciBIID0geVtSXSwgSyA9IDAsIGogPSBGIC0gMTsgKEggIT09IDAgfHwgSyA8IGIpICYmIGogIT09IC0xOyBqLS0sIEsrKylcbiAgICAgICAgICBIICs9IDI1NiAqIE1bal0gPj4+IDAsIE1bal0gPSBIICUgbCA+Pj4gMCwgSCA9IEggLyBsID4+PiAwO1xuICAgICAgICBpZiAoSCAhPT0gMClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb24temVybyBjYXJyeVwiKTtcbiAgICAgICAgYiA9IEssIFIrKztcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIEMgPSBGIC0gYjsgQyAhPT0gRiAmJiBNW0NdID09PSAwOyApXG4gICAgICAgIEMrKztcbiAgICAgIGZvciAodmFyIGsgPSBjLnJlcGVhdChFKTsgQyA8IEY7ICsrQylcbiAgICAgICAgayArPSB0LmNoYXJBdChNW0NdKTtcbiAgICAgIHJldHVybiBrO1xuICAgIH1cbiAgICBmdW5jdGlvbiBmKHkpIHtcbiAgICAgIGlmICh0eXBlb2YgeSAhPSBcInN0cmluZ1wiKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRXhwZWN0ZWQgU3RyaW5nXCIpO1xuICAgICAgaWYgKHkubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gcy5hbGxvYygwKTtcbiAgICAgIGZvciAodmFyIEUgPSAwLCBiID0gMCwgUiA9IDA7IHlbRV0gPT09IGM7IClcbiAgICAgICAgYisrLCBFKys7XG4gICAgICBmb3IgKHZhciBBID0gKHkubGVuZ3RoIC0gRSkgKiB1ICsgMSA+Pj4gMCwgRiA9IG5ldyBVaW50OEFycmF5KEEpOyBFIDwgeS5sZW5ndGg7ICkge1xuICAgICAgICB2YXIgTSA9IHkuY2hhckNvZGVBdChFKTtcbiAgICAgICAgaWYgKE0gPiAyNTUpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgSCA9IHJbTV07XG4gICAgICAgIGlmIChIID09PSAyNTUpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciBLID0gMCwgaiA9IEEgLSAxOyAoSCAhPT0gMCB8fCBLIDwgUikgJiYgaiAhPT0gLTE7IGotLSwgSysrKVxuICAgICAgICAgIEggKz0gbCAqIEZbal0gPj4+IDAsIEZbal0gPSBIICUgMjU2ID4+PiAwLCBIID0gSCAvIDI1NiA+Pj4gMDtcbiAgICAgICAgaWYgKEggIT09IDApXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uLXplcm8gY2FycnlcIik7XG4gICAgICAgIFIgPSBLLCBFKys7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBDID0gQSAtIFI7IEMgIT09IEEgJiYgRltDXSA9PT0gMDsgKVxuICAgICAgICBDKys7XG4gICAgICB2YXIgayA9IHMuYWxsb2NVbnNhZmUoYiArIChBIC0gQykpO1xuICAgICAgay5maWxsKDAsIDAsIGIpO1xuICAgICAgZm9yICh2YXIgJCA9IGI7IEMgIT09IEE7IClcbiAgICAgICAga1skKytdID0gRltDKytdO1xuICAgICAgcmV0dXJuIGs7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHAoeSkge1xuICAgICAgdmFyIEUgPSBmKHkpO1xuICAgICAgaWYgKEUpXG4gICAgICAgIHJldHVybiBFO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm9uLWJhc2VcIiArIGwgKyBcIiBjaGFyYWN0ZXJcIik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbmNvZGU6IGgsXG4gICAgICBkZWNvZGVVbnNhZmU6IGYsXG4gICAgICBkZWNvZGU6IHBcbiAgICB9O1xuICB9XG4gIHJldHVybiB6YSA9IGUsIHphO1xufVxudmFyIFlhLCBBZDtcbmZ1bmN0aW9uIEZ5KCkge1xuICBpZiAoQWQpIHJldHVybiBZYTtcbiAgQWQgPSAxO1xuICB2YXIgcyA9IEUwKCksIGUgPSBcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIjtcbiAgcmV0dXJuIFlhID0gcyhlKSwgWWE7XG59XG52YXIgTnkgPSBGeSgpO1xuY29uc3QgYXIgPSAvKiBAX19QVVJFX18gKi8gRmMoTnkpLCBJZCA9IFhmO1xudmFyIGV0ID0ge30sIFphLCBfZDtcbmZ1bmN0aW9uIFV5KCkge1xuICBpZiAoX2QpIHJldHVybiBaYTtcbiAgX2QgPSAxO1xuICB2YXIgcyA9IEUwKCksIGUgPSBcIjEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXpcIjtcbiAgcmV0dXJuIFphID0gcyhlKSwgWmE7XG59XG5mdW5jdGlvbiB1cyhzLCBlLCB0KSB7XG4gIHJldHVybiBlIDw9IHMgJiYgcyA8PSB0O1xufVxuZnVuY3Rpb24gY2Eocykge1xuICBpZiAocyA9PT0gdm9pZCAwKSByZXR1cm4ge307XG4gIGlmIChzID09PSBPYmplY3QocykpIHJldHVybiBzO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDb3VsZCBub3QgY29udmVydCBhcmd1bWVudCB0byBkaWN0aW9uYXJ5XCIpO1xufVxuZnVuY3Rpb24gJHkocykge1xuICBmb3IgKHZhciBlID0gU3RyaW5nKHMpLCB0ID0gZS5sZW5ndGgsIHIgPSAwLCBuID0gW107IHIgPCB0OyApIHtcbiAgICB2YXIgaSA9IGUuY2hhckNvZGVBdChyKTtcbiAgICBpZiAoaSA8IDU1Mjk2IHx8IGkgPiA1NzM0MylcbiAgICAgIG4ucHVzaChpKTtcbiAgICBlbHNlIGlmICg1NjMyMCA8PSBpICYmIGkgPD0gNTczNDMpXG4gICAgICBuLnB1c2goNjU1MzMpO1xuICAgIGVsc2UgaWYgKDU1Mjk2IDw9IGkgJiYgaSA8PSA1NjMxOSlcbiAgICAgIGlmIChyID09PSB0IC0gMSlcbiAgICAgICAgbi5wdXNoKDY1NTMzKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgbyA9IHMuY2hhckNvZGVBdChyICsgMSk7XG4gICAgICAgIGlmICg1NjMyMCA8PSBvICYmIG8gPD0gNTczNDMpIHtcbiAgICAgICAgICB2YXIgYSA9IGkgJiAxMDIzLCBsID0gbyAmIDEwMjM7XG4gICAgICAgICAgbi5wdXNoKDY1NTM2ICsgKGEgPDwgMTApICsgbCksIHIgKz0gMTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgbi5wdXNoKDY1NTMzKTtcbiAgICAgIH1cbiAgICByICs9IDE7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBHeShzKSB7XG4gIGZvciAodmFyIGUgPSBcIlwiLCB0ID0gMDsgdCA8IHMubGVuZ3RoOyArK3QpIHtcbiAgICB2YXIgciA9IHNbdF07XG4gICAgciA8PSA2NTUzNSA/IGUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShyKSA6IChyIC09IDY1NTM2LCBlICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoXG4gICAgICAociA+PiAxMCkgKyA1NTI5NixcbiAgICAgIChyICYgMTAyMykgKyA1NjMyMFxuICAgICkpO1xuICB9XG4gIHJldHVybiBlO1xufVxudmFyIEJvID0gLTE7XG5mdW5jdGlvbiBYYyhzKSB7XG4gIHRoaXMudG9rZW5zID0gW10uc2xpY2UuY2FsbChzKTtcbn1cblhjLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgZW5kLW9mLXN0cmVhbSBoYXMgYmVlbiBoaXQuXG4gICAqL1xuICBlbmRPZlN0cmVhbTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLnRva2Vucy5sZW5ndGg7XG4gIH0sXG4gIC8qKlxuICAgKiBXaGVuIGEgdG9rZW4gaXMgcmVhZCBmcm9tIGEgc3RyZWFtLCB0aGUgZmlyc3QgdG9rZW4gaW4gdGhlXG4gICAqIHN0cmVhbSBtdXN0IGJlIHJldHVybmVkIGFuZCBzdWJzZXF1ZW50bHkgcmVtb3ZlZCwgYW5kXG4gICAqIGVuZC1vZi1zdHJlYW0gbXVzdCBiZSByZXR1cm5lZCBvdGhlcndpc2UuXG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn0gR2V0IHRoZSBuZXh0IHRva2VuIGZyb20gdGhlIHN0cmVhbSwgb3JcbiAgICogZW5kX29mX3N0cmVhbS5cbiAgICovXG4gIHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnRva2Vucy5sZW5ndGggPyB0aGlzLnRva2Vucy5zaGlmdCgpIDogQm87XG4gIH0sXG4gIC8qKlxuICAgKiBXaGVuIG9uZSBvciBtb3JlIHRva2VucyBhcmUgcHJlcGVuZGVkIHRvIGEgc3RyZWFtLCB0aG9zZSB0b2tlbnNcbiAgICogbXVzdCBiZSBpbnNlcnRlZCwgaW4gZ2l2ZW4gb3JkZXIsIGJlZm9yZSB0aGUgZmlyc3QgdG9rZW4gaW4gdGhlXG4gICAqIHN0cmVhbS5cbiAgICpcbiAgICogQHBhcmFtIHsobnVtYmVyfCFBcnJheS48bnVtYmVyPil9IHRva2VuIFRoZSB0b2tlbihzKSB0byBwcmVwZW5kIHRvIHRoZSBzdHJlYW0uXG4gICAqL1xuICBwcmVwZW5kOiBmdW5jdGlvbihzKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocykpXG4gICAgICBmb3IgKHZhciBlID0gKFxuICAgICAgICAvKipAdHlwZSB7IUFycmF5LjxudW1iZXI+fSovXG4gICAgICAgIHNcbiAgICAgICk7IGUubGVuZ3RoOyApXG4gICAgICAgIHRoaXMudG9rZW5zLnVuc2hpZnQoZS5wb3AoKSk7XG4gICAgZWxzZVxuICAgICAgdGhpcy50b2tlbnMudW5zaGlmdChzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFdoZW4gb25lIG9yIG1vcmUgdG9rZW5zIGFyZSBwdXNoZWQgdG8gYSBzdHJlYW0sIHRob3NlIHRva2Vuc1xuICAgKiBtdXN0IGJlIGluc2VydGVkLCBpbiBnaXZlbiBvcmRlciwgYWZ0ZXIgdGhlIGxhc3QgdG9rZW4gaW4gdGhlXG4gICAqIHN0cmVhbS5cbiAgICpcbiAgICogQHBhcmFtIHsobnVtYmVyfCFBcnJheS48bnVtYmVyPil9IHRva2VuIFRoZSB0b2tlbnMocykgdG8gcHJlcGVuZCB0byB0aGUgc3RyZWFtLlxuICAgKi9cbiAgcHVzaDogZnVuY3Rpb24ocykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHMpKVxuICAgICAgZm9yICh2YXIgZSA9IChcbiAgICAgICAgLyoqQHR5cGUgeyFBcnJheS48bnVtYmVyPn0qL1xuICAgICAgICBzXG4gICAgICApOyBlLmxlbmd0aDsgKVxuICAgICAgICB0aGlzLnRva2Vucy5wdXNoKGUuc2hpZnQoKSk7XG4gICAgZWxzZVxuICAgICAgdGhpcy50b2tlbnMucHVzaChzKTtcbiAgfVxufTtcbnZhciBQbiA9IC0xO1xuZnVuY3Rpb24gWGEocywgZSkge1xuICBpZiAocylcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJEZWNvZGVyIGVycm9yXCIpO1xuICByZXR1cm4gZSB8fCA2NTUzMztcbn1cbnZhciBGbyA9IFwidXRmLThcIjtcbmZ1bmN0aW9uIE5vKHMsIGUpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE5vKSlcbiAgICByZXR1cm4gbmV3IE5vKHMsIGUpO1xuICBpZiAocyA9IHMgIT09IHZvaWQgMCA/IFN0cmluZyhzKS50b0xvd2VyQ2FzZSgpIDogRm8sIHMgIT09IEZvKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkVuY29kaW5nIG5vdCBzdXBwb3J0ZWQuIE9ubHkgdXRmLTggaXMgc3VwcG9ydGVkXCIpO1xuICBlID0gY2EoZSksIHRoaXMuX3N0cmVhbWluZyA9ICExLCB0aGlzLl9CT01zZWVuID0gITEsIHRoaXMuX2RlY29kZXIgPSBudWxsLCB0aGlzLl9mYXRhbCA9ICEhZS5mYXRhbCwgdGhpcy5faWdub3JlQk9NID0gISFlLmlnbm9yZUJPTSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZW5jb2RpbmdcIiwgeyB2YWx1ZTogXCJ1dGYtOFwiIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJmYXRhbFwiLCB7IHZhbHVlOiB0aGlzLl9mYXRhbCB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiaWdub3JlQk9NXCIsIHsgdmFsdWU6IHRoaXMuX2lnbm9yZUJPTSB9KTtcbn1cbk5vLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJWaWV3PX0gaW5wdXQgVGhlIGJ1ZmZlciBvZiBieXRlcyB0byBkZWNvZGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAgICovXG4gIGRlY29kZTogZnVuY3Rpb24oZSwgdCkge1xuICAgIHZhciByO1xuICAgIHR5cGVvZiBlID09IFwib2JqZWN0XCIgJiYgZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gciA9IG5ldyBVaW50OEFycmF5KGUpIDogdHlwZW9mIGUgPT0gXCJvYmplY3RcIiAmJiBcImJ1ZmZlclwiIGluIGUgJiYgZS5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IHIgPSBuZXcgVWludDhBcnJheShcbiAgICAgIGUuYnVmZmVyLFxuICAgICAgZS5ieXRlT2Zmc2V0LFxuICAgICAgZS5ieXRlTGVuZ3RoXG4gICAgKSA6IHIgPSBuZXcgVWludDhBcnJheSgwKSwgdCA9IGNhKHQpLCB0aGlzLl9zdHJlYW1pbmcgfHwgKHRoaXMuX2RlY29kZXIgPSBuZXcgVnkoeyBmYXRhbDogdGhpcy5fZmF0YWwgfSksIHRoaXMuX0JPTXNlZW4gPSAhMSksIHRoaXMuX3N0cmVhbWluZyA9ICEhdC5zdHJlYW07XG4gICAgZm9yICh2YXIgbiA9IG5ldyBYYyhyKSwgaSA9IFtdLCBvOyAhbi5lbmRPZlN0cmVhbSgpICYmIChvID0gdGhpcy5fZGVjb2Rlci5oYW5kbGVyKG4sIG4ucmVhZCgpKSwgbyAhPT0gUG4pOyApXG4gICAgICBvICE9PSBudWxsICYmIChBcnJheS5pc0FycmF5KG8pID8gaS5wdXNoLmFwcGx5KFxuICAgICAgICBpLFxuICAgICAgICAvKipAdHlwZSB7IUFycmF5LjxudW1iZXI+fSovXG4gICAgICAgIG9cbiAgICAgICkgOiBpLnB1c2gobykpO1xuICAgIGlmICghdGhpcy5fc3RyZWFtaW5nKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChvID0gdGhpcy5fZGVjb2Rlci5oYW5kbGVyKG4sIG4ucmVhZCgpKSwgbyA9PT0gUG4pXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIG8gIT09IG51bGwgJiYgKEFycmF5LmlzQXJyYXkobykgPyBpLnB1c2guYXBwbHkoXG4gICAgICAgICAgaSxcbiAgICAgICAgICAvKipAdHlwZSB7IUFycmF5LjxudW1iZXI+fSovXG4gICAgICAgICAgb1xuICAgICAgICApIDogaS5wdXNoKG8pKTtcbiAgICAgIH0gd2hpbGUgKCFuLmVuZE9mU3RyZWFtKCkpO1xuICAgICAgdGhpcy5fZGVjb2RlciA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpLmxlbmd0aCAmJiBbXCJ1dGYtOFwiXS5pbmRleE9mKHRoaXMuZW5jb2RpbmcpICE9PSAtMSAmJiAhdGhpcy5faWdub3JlQk9NICYmICF0aGlzLl9CT01zZWVuICYmIChpWzBdID09PSA2NTI3OSA/ICh0aGlzLl9CT01zZWVuID0gITAsIGkuc2hpZnQoKSkgOiB0aGlzLl9CT01zZWVuID0gITApLCBHeShpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIFVvKHMsIGUpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVvKSlcbiAgICByZXR1cm4gbmV3IFVvKHMsIGUpO1xuICBpZiAocyA9IHMgIT09IHZvaWQgMCA/IFN0cmluZyhzKS50b0xvd2VyQ2FzZSgpIDogRm8sIHMgIT09IEZvKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkVuY29kaW5nIG5vdCBzdXBwb3J0ZWQuIE9ubHkgdXRmLTggaXMgc3VwcG9ydGVkXCIpO1xuICBlID0gY2EoZSksIHRoaXMuX3N0cmVhbWluZyA9ICExLCB0aGlzLl9lbmNvZGVyID0gbnVsbCwgdGhpcy5fb3B0aW9ucyA9IHsgZmF0YWw6ICEhZS5mYXRhbCB9LCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJlbmNvZGluZ1wiLCB7IHZhbHVlOiBcInV0Zi04XCIgfSk7XG59XG5Vby5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zdHJpbmcgVGhlIHN0cmluZyB0byBlbmNvZGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSBFbmNvZGVkIGJ5dGVzLCBhcyBhIFVpbnQ4QXJyYXkuXG4gICAqL1xuICBlbmNvZGU6IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBlID0gZSA/IFN0cmluZyhlKSA6IFwiXCIsIHQgPSBjYSh0KSwgdGhpcy5fc3RyZWFtaW5nIHx8ICh0aGlzLl9lbmNvZGVyID0gbmV3IGp5KHRoaXMuX29wdGlvbnMpKSwgdGhpcy5fc3RyZWFtaW5nID0gISF0LnN0cmVhbTtcbiAgICBmb3IgKHZhciByID0gW10sIG4gPSBuZXcgWGMoJHkoZSkpLCBpOyAhbi5lbmRPZlN0cmVhbSgpICYmIChpID0gdGhpcy5fZW5jb2Rlci5oYW5kbGVyKG4sIG4ucmVhZCgpKSwgaSAhPT0gUG4pOyApXG4gICAgICBBcnJheS5pc0FycmF5KGkpID8gci5wdXNoLmFwcGx5KFxuICAgICAgICByLFxuICAgICAgICAvKipAdHlwZSB7IUFycmF5LjxudW1iZXI+fSovXG4gICAgICAgIGlcbiAgICAgICkgOiByLnB1c2goaSk7XG4gICAgaWYgKCF0aGlzLl9zdHJlYW1pbmcpIHtcbiAgICAgIGZvciAoOyBpID0gdGhpcy5fZW5jb2Rlci5oYW5kbGVyKG4sIG4ucmVhZCgpKSwgaSAhPT0gUG47IClcbiAgICAgICAgQXJyYXkuaXNBcnJheShpKSA/IHIucHVzaC5hcHBseShcbiAgICAgICAgICByLFxuICAgICAgICAgIC8qKkB0eXBlIHshQXJyYXkuPG51bWJlcj59Ki9cbiAgICAgICAgICBpXG4gICAgICAgICkgOiByLnB1c2goaSk7XG4gICAgICB0aGlzLl9lbmNvZGVyID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHIpO1xuICB9XG59O1xuZnVuY3Rpb24gVnkocykge1xuICB2YXIgZSA9IHMuZmF0YWwsIHQgPSAwLCByID0gMCwgbiA9IDAsIGkgPSAxMjgsIG8gPSAxOTE7XG4gIHRoaXMuaGFuZGxlciA9IGZ1bmN0aW9uKGEsIGwpIHtcbiAgICBpZiAobCA9PT0gQm8gJiYgbiAhPT0gMClcbiAgICAgIHJldHVybiBuID0gMCwgWGEoZSk7XG4gICAgaWYgKGwgPT09IEJvKVxuICAgICAgcmV0dXJuIFBuO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAodXMobCwgMCwgMTI3KSlcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgICBpZiAodXMobCwgMTk0LCAyMjMpKVxuICAgICAgICBuID0gMSwgdCA9IGwgLSAxOTI7XG4gICAgICBlbHNlIGlmICh1cyhsLCAyMjQsIDIzOSkpXG4gICAgICAgIGwgPT09IDIyNCAmJiAoaSA9IDE2MCksIGwgPT09IDIzNyAmJiAobyA9IDE1OSksIG4gPSAyLCB0ID0gbCAtIDIyNDtcbiAgICAgIGVsc2UgaWYgKHVzKGwsIDI0MCwgMjQ0KSlcbiAgICAgICAgbCA9PT0gMjQwICYmIChpID0gMTQ0KSwgbCA9PT0gMjQ0ICYmIChvID0gMTQzKSwgbiA9IDMsIHQgPSBsIC0gMjQwO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gWGEoZSk7XG4gICAgICByZXR1cm4gdCA9IHQgPDwgNiAqIG4sIG51bGw7XG4gICAgfVxuICAgIGlmICghdXMobCwgaSwgbykpXG4gICAgICByZXR1cm4gdCA9IG4gPSByID0gMCwgaSA9IDEyOCwgbyA9IDE5MSwgYS5wcmVwZW5kKGwpLCBYYShlKTtcbiAgICBpZiAoaSA9IDEyOCwgbyA9IDE5MSwgciArPSAxLCB0ICs9IGwgLSAxMjggPDwgNiAqIChuIC0gciksIHIgIT09IG4pXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB2YXIgYyA9IHQ7XG4gICAgcmV0dXJuIHQgPSBuID0gciA9IDAsIGM7XG4gIH07XG59XG5mdW5jdGlvbiBqeShzKSB7XG4gIHMuZmF0YWwsIHRoaXMuaGFuZGxlciA9IGZ1bmN0aW9uKGUsIHQpIHtcbiAgICBpZiAodCA9PT0gQm8pXG4gICAgICByZXR1cm4gUG47XG4gICAgaWYgKHVzKHQsIDAsIDEyNykpXG4gICAgICByZXR1cm4gdDtcbiAgICB2YXIgciwgbjtcbiAgICB1cyh0LCAxMjgsIDIwNDcpID8gKHIgPSAxLCBuID0gMTkyKSA6IHVzKHQsIDIwNDgsIDY1NTM1KSA/IChyID0gMiwgbiA9IDIyNCkgOiB1cyh0LCA2NTUzNiwgMTExNDExMSkgJiYgKHIgPSAzLCBuID0gMjQwKTtcbiAgICBmb3IgKHZhciBpID0gWyh0ID4+IDYgKiByKSArIG5dOyByID4gMDsgKSB7XG4gICAgICB2YXIgbyA9IHQgPj4gNiAqIChyIC0gMSk7XG4gICAgICBpLnB1c2goMTI4IHwgbyAmIDYzKSwgciAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfTtcbn1cbmNvbnN0IEt5ID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgVGV4dERlY29kZXI6IE5vLFxuICBUZXh0RW5jb2RlcjogVW9cbn0sIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogXCJNb2R1bGVcIiB9KSksIEh5ID0gLyogQF9fUFVSRV9fICovIE5jKEt5KTtcbnZhciBSZDtcbmZ1bmN0aW9uIHF5KCkge1xuICBpZiAoUmQpIHJldHVybiBldDtcbiAgUmQgPSAxO1xuICB2YXIgcyA9IGV0ICYmIGV0Ll9fY3JlYXRlQmluZGluZyB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihDLCBrLCAkLCBXKSB7XG4gICAgVyA9PT0gdm9pZCAwICYmIChXID0gJCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDLCBXLCB7IGVudW1lcmFibGU6ICEwLCBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGtbJF07XG4gICAgfSB9KTtcbiAgfSkgOiAoZnVuY3Rpb24oQywgaywgJCwgVykge1xuICAgIFcgPT09IHZvaWQgMCAmJiAoVyA9ICQpLCBDW1ddID0ga1skXTtcbiAgfSkpLCBlID0gZXQgJiYgZXQuX19zZXRNb2R1bGVEZWZhdWx0IHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKEMsIGspIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogITAsIHZhbHVlOiBrIH0pO1xuICB9KSA6IGZ1bmN0aW9uKEMsIGspIHtcbiAgICBDLmRlZmF1bHQgPSBrO1xuICB9KSwgdCA9IGV0ICYmIGV0Ll9fZGVjb3JhdGUgfHwgZnVuY3Rpb24oQywgaywgJCwgVykge1xuICAgIHZhciBfID0gYXJndW1lbnRzLmxlbmd0aCwgZyA9IF8gPCAzID8gayA6IFcgPT09IG51bGwgPyBXID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihrLCAkKSA6IFcsIHg7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT0gXCJmdW5jdGlvblwiKSBnID0gUmVmbGVjdC5kZWNvcmF0ZShDLCBrLCAkLCBXKTtcbiAgICBlbHNlIGZvciAodmFyIHcgPSBDLmxlbmd0aCAtIDE7IHcgPj0gMDsgdy0tKSAoeCA9IENbd10pICYmIChnID0gKF8gPCAzID8geChnKSA6IF8gPiAzID8geChrLCAkLCBnKSA6IHgoaywgJCkpIHx8IGcpO1xuICAgIHJldHVybiBfID4gMyAmJiBnICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShrLCAkLCBnKSwgZztcbiAgfSwgciA9IGV0ICYmIGV0Ll9faW1wb3J0U3RhciB8fCBmdW5jdGlvbihDKSB7XG4gICAgaWYgKEMgJiYgQy5fX2VzTW9kdWxlKSByZXR1cm4gQztcbiAgICB2YXIgayA9IHt9O1xuICAgIGlmIChDICE9IG51bGwpIGZvciAodmFyICQgaW4gQykgJCAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoQywgJCkgJiYgcyhrLCBDLCAkKTtcbiAgICByZXR1cm4gZShrLCBDKSwgaztcbiAgfSwgbiA9IGV0ICYmIGV0Ll9faW1wb3J0RGVmYXVsdCB8fCBmdW5jdGlvbihDKSB7XG4gICAgcmV0dXJuIEMgJiYgQy5fX2VzTW9kdWxlID8gQyA6IHsgZGVmYXVsdDogQyB9O1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXQsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiAhMCB9KSwgZXQuZGVzZXJpYWxpemVVbmNoZWNrZWQgPSBldC5kZXNlcmlhbGl6ZSA9IGV0LnNlcmlhbGl6ZSA9IGV0LkJpbmFyeVJlYWRlciA9IGV0LkJpbmFyeVdyaXRlciA9IGV0LkJvcnNoRXJyb3IgPSBldC5iYXNlRGVjb2RlID0gZXQuYmFzZUVuY29kZSA9IHZvaWQgMDtcbiAgY29uc3QgaSA9IG4odjAoKSksIG8gPSBuKFV5KCkpLCBhID0gcihIeSksIGwgPSB0eXBlb2YgVGV4dERlY29kZXIgIT0gXCJmdW5jdGlvblwiID8gYS5UZXh0RGVjb2RlciA6IFRleHREZWNvZGVyLCBjID0gbmV3IGwoXCJ1dGYtOFwiLCB7IGZhdGFsOiAhMCB9KTtcbiAgZnVuY3Rpb24gdShDKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBDID09IFwic3RyaW5nXCIgJiYgKEMgPSBCdWZmZXIuZnJvbShDLCBcInV0ZjhcIikpLCBvLmRlZmF1bHQuZW5jb2RlKEJ1ZmZlci5mcm9tKEMpKTtcbiAgfVxuICBldC5iYXNlRW5jb2RlID0gdTtcbiAgZnVuY3Rpb24gZChDKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKG8uZGVmYXVsdC5kZWNvZGUoQykpO1xuICB9XG4gIGV0LmJhc2VEZWNvZGUgPSBkO1xuICBjb25zdCBoID0gMTAyNDtcbiAgY2xhc3MgZiBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihrKSB7XG4gICAgICBzdXBlcihrKSwgdGhpcy5maWVsZFBhdGggPSBbXSwgdGhpcy5vcmlnaW5hbE1lc3NhZ2UgPSBrO1xuICAgIH1cbiAgICBhZGRUb0ZpZWxkUGF0aChrKSB7XG4gICAgICB0aGlzLmZpZWxkUGF0aC5zcGxpY2UoMCwgMCwgayksIHRoaXMubWVzc2FnZSA9IHRoaXMub3JpZ2luYWxNZXNzYWdlICsgXCI6IFwiICsgdGhpcy5maWVsZFBhdGguam9pbihcIi5cIik7XG4gICAgfVxuICB9XG4gIGV0LkJvcnNoRXJyb3IgPSBmO1xuICBjbGFzcyBwIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMuYnVmID0gQnVmZmVyLmFsbG9jKGgpLCB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIG1heWJlUmVzaXplKCkge1xuICAgICAgdGhpcy5idWYubGVuZ3RoIDwgMTYgKyB0aGlzLmxlbmd0aCAmJiAodGhpcy5idWYgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmJ1ZiwgQnVmZmVyLmFsbG9jKGgpXSkpO1xuICAgIH1cbiAgICB3cml0ZVU4KGspIHtcbiAgICAgIHRoaXMubWF5YmVSZXNpemUoKSwgdGhpcy5idWYud3JpdGVVSW50OChrLCB0aGlzLmxlbmd0aCksIHRoaXMubGVuZ3RoICs9IDE7XG4gICAgfVxuICAgIHdyaXRlVTE2KGspIHtcbiAgICAgIHRoaXMubWF5YmVSZXNpemUoKSwgdGhpcy5idWYud3JpdGVVSW50MTZMRShrLCB0aGlzLmxlbmd0aCksIHRoaXMubGVuZ3RoICs9IDI7XG4gICAgfVxuICAgIHdyaXRlVTMyKGspIHtcbiAgICAgIHRoaXMubWF5YmVSZXNpemUoKSwgdGhpcy5idWYud3JpdGVVSW50MzJMRShrLCB0aGlzLmxlbmd0aCksIHRoaXMubGVuZ3RoICs9IDQ7XG4gICAgfVxuICAgIHdyaXRlVTY0KGspIHtcbiAgICAgIHRoaXMubWF5YmVSZXNpemUoKSwgdGhpcy53cml0ZUJ1ZmZlcihCdWZmZXIuZnJvbShuZXcgaS5kZWZhdWx0KGspLnRvQXJyYXkoXCJsZVwiLCA4KSkpO1xuICAgIH1cbiAgICB3cml0ZVUxMjgoaykge1xuICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpLCB0aGlzLndyaXRlQnVmZmVyKEJ1ZmZlci5mcm9tKG5ldyBpLmRlZmF1bHQoaykudG9BcnJheShcImxlXCIsIDE2KSkpO1xuICAgIH1cbiAgICB3cml0ZVUyNTYoaykge1xuICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpLCB0aGlzLndyaXRlQnVmZmVyKEJ1ZmZlci5mcm9tKG5ldyBpLmRlZmF1bHQoaykudG9BcnJheShcImxlXCIsIDMyKSkpO1xuICAgIH1cbiAgICB3cml0ZVU1MTIoaykge1xuICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpLCB0aGlzLndyaXRlQnVmZmVyKEJ1ZmZlci5mcm9tKG5ldyBpLmRlZmF1bHQoaykudG9BcnJheShcImxlXCIsIDY0KSkpO1xuICAgIH1cbiAgICB3cml0ZUJ1ZmZlcihrKSB7XG4gICAgICB0aGlzLmJ1ZiA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICBCdWZmZXIuZnJvbSh0aGlzLmJ1Zi5zdWJhcnJheSgwLCB0aGlzLmxlbmd0aCkpLFxuICAgICAgICBrLFxuICAgICAgICBCdWZmZXIuYWxsb2MoaClcbiAgICAgIF0pLCB0aGlzLmxlbmd0aCArPSBrLmxlbmd0aDtcbiAgICB9XG4gICAgd3JpdGVTdHJpbmcoaykge1xuICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgY29uc3QgJCA9IEJ1ZmZlci5mcm9tKGssIFwidXRmOFwiKTtcbiAgICAgIHRoaXMud3JpdGVVMzIoJC5sZW5ndGgpLCB0aGlzLndyaXRlQnVmZmVyKCQpO1xuICAgIH1cbiAgICB3cml0ZUZpeGVkQXJyYXkoaykge1xuICAgICAgdGhpcy53cml0ZUJ1ZmZlcihCdWZmZXIuZnJvbShrKSk7XG4gICAgfVxuICAgIHdyaXRlQXJyYXkoaywgJCkge1xuICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpLCB0aGlzLndyaXRlVTMyKGsubGVuZ3RoKTtcbiAgICAgIGZvciAoY29uc3QgVyBvZiBrKVxuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCksICQoVyk7XG4gICAgfVxuICAgIHRvQXJyYXkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5idWYuc3ViYXJyYXkoMCwgdGhpcy5sZW5ndGgpO1xuICAgIH1cbiAgfVxuICBldC5CaW5hcnlXcml0ZXIgPSBwO1xuICBmdW5jdGlvbiB5KEMsIGssICQpIHtcbiAgICBjb25zdCBXID0gJC52YWx1ZTtcbiAgICAkLnZhbHVlID0gZnVuY3Rpb24oLi4uXykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIFcuYXBwbHkodGhpcywgXyk7XG4gICAgICB9IGNhdGNoIChnKSB7XG4gICAgICAgIGlmIChnIGluc3RhbmNlb2YgUmFuZ2VFcnJvcikge1xuICAgICAgICAgIGNvbnN0IHggPSBnLmNvZGU7XG4gICAgICAgICAgaWYgKFtcIkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EU1wiLCBcIkVSUl9PVVRfT0ZfUkFOR0VcIl0uaW5kZXhPZih4KSA+PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGYoXCJSZWFjaGVkIHRoZSBlbmQgb2YgYnVmZmVyIHdoZW4gZGVzZXJpYWxpemluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBnO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgY2xhc3MgRSB7XG4gICAgY29uc3RydWN0b3Ioaykge1xuICAgICAgdGhpcy5idWYgPSBrLCB0aGlzLm9mZnNldCA9IDA7XG4gICAgfVxuICAgIHJlYWRVOCgpIHtcbiAgICAgIGNvbnN0IGsgPSB0aGlzLmJ1Zi5yZWFkVUludDgodGhpcy5vZmZzZXQpO1xuICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ICs9IDEsIGs7XG4gICAgfVxuICAgIHJlYWRVMTYoKSB7XG4gICAgICBjb25zdCBrID0gdGhpcy5idWYucmVhZFVJbnQxNkxFKHRoaXMub2Zmc2V0KTtcbiAgICAgIHJldHVybiB0aGlzLm9mZnNldCArPSAyLCBrO1xuICAgIH1cbiAgICByZWFkVTMyKCkge1xuICAgICAgY29uc3QgayA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLm9mZnNldCk7XG4gICAgICByZXR1cm4gdGhpcy5vZmZzZXQgKz0gNCwgaztcbiAgICB9XG4gICAgcmVhZFU2NCgpIHtcbiAgICAgIGNvbnN0IGsgPSB0aGlzLnJlYWRCdWZmZXIoOCk7XG4gICAgICByZXR1cm4gbmV3IGkuZGVmYXVsdChrLCBcImxlXCIpO1xuICAgIH1cbiAgICByZWFkVTEyOCgpIHtcbiAgICAgIGNvbnN0IGsgPSB0aGlzLnJlYWRCdWZmZXIoMTYpO1xuICAgICAgcmV0dXJuIG5ldyBpLmRlZmF1bHQoaywgXCJsZVwiKTtcbiAgICB9XG4gICAgcmVhZFUyNTYoKSB7XG4gICAgICBjb25zdCBrID0gdGhpcy5yZWFkQnVmZmVyKDMyKTtcbiAgICAgIHJldHVybiBuZXcgaS5kZWZhdWx0KGssIFwibGVcIik7XG4gICAgfVxuICAgIHJlYWRVNTEyKCkge1xuICAgICAgY29uc3QgayA9IHRoaXMucmVhZEJ1ZmZlcig2NCk7XG4gICAgICByZXR1cm4gbmV3IGkuZGVmYXVsdChrLCBcImxlXCIpO1xuICAgIH1cbiAgICByZWFkQnVmZmVyKGspIHtcbiAgICAgIGlmICh0aGlzLm9mZnNldCArIGsgPiB0aGlzLmJ1Zi5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBmKGBFeHBlY3RlZCBidWZmZXIgbGVuZ3RoICR7a30gaXNuJ3Qgd2l0aGluIGJvdW5kc2ApO1xuICAgICAgY29uc3QgJCA9IHRoaXMuYnVmLnNsaWNlKHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArIGspO1xuICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0ICs9IGssICQ7XG4gICAgfVxuICAgIHJlYWRTdHJpbmcoKSB7XG4gICAgICBjb25zdCBrID0gdGhpcy5yZWFkVTMyKCksICQgPSB0aGlzLnJlYWRCdWZmZXIoayk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYy5kZWNvZGUoJCk7XG4gICAgICB9IGNhdGNoIChXKSB7XG4gICAgICAgIHRocm93IG5ldyBmKGBFcnJvciBkZWNvZGluZyBVVEYtOCBzdHJpbmc6ICR7V31gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVhZEZpeGVkQXJyYXkoaykge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMucmVhZEJ1ZmZlcihrKSk7XG4gICAgfVxuICAgIHJlYWRBcnJheShrKSB7XG4gICAgICBjb25zdCAkID0gdGhpcy5yZWFkVTMyKCksIFcgPSBBcnJheSgpO1xuICAgICAgZm9yIChsZXQgXyA9IDA7IF8gPCAkOyArK18pXG4gICAgICAgIFcucHVzaChrKCkpO1xuICAgICAgcmV0dXJuIFc7XG4gICAgfVxuICB9XG4gIHQoW1xuICAgIHlcbiAgXSwgRS5wcm90b3R5cGUsIFwicmVhZFU4XCIsIG51bGwpLCB0KFtcbiAgICB5XG4gIF0sIEUucHJvdG90eXBlLCBcInJlYWRVMTZcIiwgbnVsbCksIHQoW1xuICAgIHlcbiAgXSwgRS5wcm90b3R5cGUsIFwicmVhZFUzMlwiLCBudWxsKSwgdChbXG4gICAgeVxuICBdLCBFLnByb3RvdHlwZSwgXCJyZWFkVTY0XCIsIG51bGwpLCB0KFtcbiAgICB5XG4gIF0sIEUucHJvdG90eXBlLCBcInJlYWRVMTI4XCIsIG51bGwpLCB0KFtcbiAgICB5XG4gIF0sIEUucHJvdG90eXBlLCBcInJlYWRVMjU2XCIsIG51bGwpLCB0KFtcbiAgICB5XG4gIF0sIEUucHJvdG90eXBlLCBcInJlYWRVNTEyXCIsIG51bGwpLCB0KFtcbiAgICB5XG4gIF0sIEUucHJvdG90eXBlLCBcInJlYWRTdHJpbmdcIiwgbnVsbCksIHQoW1xuICAgIHlcbiAgXSwgRS5wcm90b3R5cGUsIFwicmVhZEZpeGVkQXJyYXlcIiwgbnVsbCksIHQoW1xuICAgIHlcbiAgXSwgRS5wcm90b3R5cGUsIFwicmVhZEFycmF5XCIsIG51bGwpLCBldC5CaW5hcnlSZWFkZXIgPSBFO1xuICBmdW5jdGlvbiBiKEMpIHtcbiAgICByZXR1cm4gQy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIEMuc2xpY2UoMSk7XG4gIH1cbiAgZnVuY3Rpb24gUihDLCBrLCAkLCBXLCBfKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh0eXBlb2YgVyA9PSBcInN0cmluZ1wiKVxuICAgICAgICBfW2B3cml0ZSR7YihXKX1gXSgkKTtcbiAgICAgIGVsc2UgaWYgKFcgaW5zdGFuY2VvZiBBcnJheSlcbiAgICAgICAgaWYgKHR5cGVvZiBXWzBdID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBpZiAoJC5sZW5ndGggIT09IFdbMF0pXG4gICAgICAgICAgICB0aHJvdyBuZXcgZihgRXhwZWN0aW5nIGJ5dGUgYXJyYXkgb2YgbGVuZ3RoICR7V1swXX0sIGJ1dCBnb3QgJHskLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICAgICAgICBfLndyaXRlRml4ZWRBcnJheSgkKTtcbiAgICAgICAgfSBlbHNlIGlmIChXLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgV1sxXSA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgaWYgKCQubGVuZ3RoICE9PSBXWzFdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGYoYEV4cGVjdGluZyBieXRlIGFycmF5IG9mIGxlbmd0aCAke1dbMV19LCBidXQgZ290ICR7JC5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgICAgICAgZm9yIChsZXQgZyA9IDA7IGcgPCBXWzFdOyBnKyspXG4gICAgICAgICAgICBSKEMsIG51bGwsICRbZ10sIFdbMF0sIF8pO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBfLndyaXRlQXJyYXkoJCwgKGcpID0+IHtcbiAgICAgICAgICAgIFIoQywgaywgZywgV1swXSwgXyk7XG4gICAgICAgICAgfSk7XG4gICAgICBlbHNlIGlmIChXLmtpbmQgIT09IHZvaWQgMClcbiAgICAgICAgc3dpdGNoIChXLmtpbmQpIHtcbiAgICAgICAgICBjYXNlIFwib3B0aW9uXCI6IHtcbiAgICAgICAgICAgICQgPT0gbnVsbCA/IF8ud3JpdGVVOCgwKSA6IChfLndyaXRlVTgoMSksIFIoQywgaywgJCwgVy50eXBlLCBfKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIm1hcFwiOiB7XG4gICAgICAgICAgICBfLndyaXRlVTMyKCQuc2l6ZSksICQuZm9yRWFjaCgoZywgeCkgPT4ge1xuICAgICAgICAgICAgICBSKEMsIGssIHgsIFcua2V5LCBfKSwgUihDLCBrLCBnLCBXLnZhbHVlLCBfKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgZihgRmllbGRUeXBlICR7V30gdW5yZWNvZ25pemVkYCk7XG4gICAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgQShDLCAkLCBfKTtcbiAgICB9IGNhdGNoIChnKSB7XG4gICAgICB0aHJvdyBnIGluc3RhbmNlb2YgZiAmJiBnLmFkZFRvRmllbGRQYXRoKGspLCBnO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBBKEMsIGssICQpIHtcbiAgICBpZiAodHlwZW9mIGsuYm9yc2hTZXJpYWxpemUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBrLmJvcnNoU2VyaWFsaXplKCQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBXID0gQy5nZXQoay5jb25zdHJ1Y3Rvcik7XG4gICAgaWYgKCFXKVxuICAgICAgdGhyb3cgbmV3IGYoYENsYXNzICR7ay5jb25zdHJ1Y3Rvci5uYW1lfSBpcyBtaXNzaW5nIGluIHNjaGVtYWApO1xuICAgIGlmIChXLmtpbmQgPT09IFwic3RydWN0XCIpXG4gICAgICBXLmZpZWxkcy5tYXAoKFtfLCBnXSkgPT4ge1xuICAgICAgICBSKEMsIF8sIGtbX10sIGcsICQpO1xuICAgICAgfSk7XG4gICAgZWxzZSBpZiAoVy5raW5kID09PSBcImVudW1cIikge1xuICAgICAgY29uc3QgXyA9IGtbVy5maWVsZF07XG4gICAgICBmb3IgKGxldCBnID0gMDsgZyA8IFcudmFsdWVzLmxlbmd0aDsgKytnKSB7XG4gICAgICAgIGNvbnN0IFt4LCB3XSA9IFcudmFsdWVzW2ddO1xuICAgICAgICBpZiAoeCA9PT0gXykge1xuICAgICAgICAgICQud3JpdGVVOChnKSwgUihDLCB4LCBrW3hdLCB3LCAkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgbmV3IGYoYFVuZXhwZWN0ZWQgc2NoZW1hIGtpbmQ6ICR7Vy5raW5kfSBmb3IgJHtrLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gIH1cbiAgZnVuY3Rpb24gRihDLCBrLCAkID0gcCkge1xuICAgIGNvbnN0IFcgPSBuZXcgJCgpO1xuICAgIHJldHVybiBBKEMsIGssIFcpLCBXLnRvQXJyYXkoKTtcbiAgfVxuICBldC5zZXJpYWxpemUgPSBGO1xuICBmdW5jdGlvbiBNKEMsIGssICQsIFcpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHR5cGVvZiAkID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBXW2ByZWFkJHtiKCQpfWBdKCk7XG4gICAgICBpZiAoJCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgJFswXSA9PSBcIm51bWJlclwiKVxuICAgICAgICAgIHJldHVybiBXLnJlYWRGaXhlZEFycmF5KCRbMF0pO1xuICAgICAgICBpZiAodHlwZW9mICRbMV0gPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGNvbnN0IF8gPSBbXTtcbiAgICAgICAgICBmb3IgKGxldCBnID0gMDsgZyA8ICRbMV07IGcrKylcbiAgICAgICAgICAgIF8ucHVzaChNKEMsIG51bGwsICRbMF0sIFcpKTtcbiAgICAgICAgICByZXR1cm4gXztcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgcmV0dXJuIFcucmVhZEFycmF5KCgpID0+IE0oQywgaywgJFswXSwgVykpO1xuICAgICAgfVxuICAgICAgaWYgKCQua2luZCA9PT0gXCJvcHRpb25cIilcbiAgICAgICAgcmV0dXJuIFcucmVhZFU4KCkgPyBNKEMsIGssICQudHlwZSwgVykgOiB2b2lkIDA7XG4gICAgICBpZiAoJC5raW5kID09PSBcIm1hcFwiKSB7XG4gICAgICAgIGxldCBfID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgZyA9IFcucmVhZFUzMigpO1xuICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGc7IHgrKykge1xuICAgICAgICAgIGNvbnN0IHcgPSBNKEMsIGssICQua2V5LCBXKSwgRCA9IE0oQywgaywgJC52YWx1ZSwgVyk7XG4gICAgICAgICAgXy5zZXQodywgRCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF87XG4gICAgICB9XG4gICAgICByZXR1cm4gSChDLCAkLCBXKTtcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICB0aHJvdyBfIGluc3RhbmNlb2YgZiAmJiBfLmFkZFRvRmllbGRQYXRoKGspLCBfO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBIKEMsIGssICQpIHtcbiAgICBpZiAodHlwZW9mIGsuYm9yc2hEZXNlcmlhbGl6ZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICByZXR1cm4gay5ib3JzaERlc2VyaWFsaXplKCQpO1xuICAgIGNvbnN0IFcgPSBDLmdldChrKTtcbiAgICBpZiAoIVcpXG4gICAgICB0aHJvdyBuZXcgZihgQ2xhc3MgJHtrLm5hbWV9IGlzIG1pc3NpbmcgaW4gc2NoZW1hYCk7XG4gICAgaWYgKFcua2luZCA9PT0gXCJzdHJ1Y3RcIikge1xuICAgICAgY29uc3QgXyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBbZywgeF0gb2YgQy5nZXQoaykuZmllbGRzKVxuICAgICAgICBfW2ddID0gTShDLCBnLCB4LCAkKTtcbiAgICAgIHJldHVybiBuZXcgayhfKTtcbiAgICB9XG4gICAgaWYgKFcua2luZCA9PT0gXCJlbnVtXCIpIHtcbiAgICAgIGNvbnN0IF8gPSAkLnJlYWRVOCgpO1xuICAgICAgaWYgKF8gPj0gVy52YWx1ZXMubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgZihgRW51bSBpbmRleDogJHtffSBpcyBvdXQgb2YgcmFuZ2VgKTtcbiAgICAgIGNvbnN0IFtnLCB4XSA9IFcudmFsdWVzW19dLCB3ID0gTShDLCBnLCB4LCAkKTtcbiAgICAgIHJldHVybiBuZXcgayh7IFtnXTogdyB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IGYoYFVuZXhwZWN0ZWQgc2NoZW1hIGtpbmQ6ICR7Vy5raW5kfSBmb3IgJHtrLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gIH1cbiAgZnVuY3Rpb24gSyhDLCBrLCAkLCBXID0gRSkge1xuICAgIGNvbnN0IF8gPSBuZXcgVygkKSwgZyA9IEgoQywgaywgXyk7XG4gICAgaWYgKF8ub2Zmc2V0IDwgJC5sZW5ndGgpXG4gICAgICB0aHJvdyBuZXcgZihgVW5leHBlY3RlZCAkeyQubGVuZ3RoIC0gXy5vZmZzZXR9IGJ5dGVzIGFmdGVyIGRlc2VyaWFsaXplZCBkYXRhYCk7XG4gICAgcmV0dXJuIGc7XG4gIH1cbiAgZXQuZGVzZXJpYWxpemUgPSBLO1xuICBmdW5jdGlvbiBqKEMsIGssICQsIFcgPSBFKSB7XG4gICAgY29uc3QgXyA9IG5ldyBXKCQpO1xuICAgIHJldHVybiBIKEMsIGssIF8pO1xuICB9XG4gIHJldHVybiBldC5kZXNlcmlhbGl6ZVVuY2hlY2tlZCA9IGosIGV0O1xufVxudmFyIEphID0gcXkoKSwgcmUgPSB7fSwgTGQ7XG5mdW5jdGlvbiBXeSgpIHtcbiAgaWYgKExkKSByZXR1cm4gcmU7XG4gIExkID0gMSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogITAgfSksIHJlLnMxNiA9IHJlLnM4ID0gcmUubnU2NGJlID0gcmUudTQ4YmUgPSByZS51NDBiZSA9IHJlLnUzMmJlID0gcmUudTI0YmUgPSByZS51MTZiZSA9IHJlLm51NjQgPSByZS51NDggPSByZS51NDAgPSByZS51MzIgPSByZS51MjQgPSByZS51MTYgPSByZS51OCA9IHJlLm9mZnNldCA9IHJlLmdyZWVkeSA9IHJlLkNvbnN0YW50ID0gcmUuVVRGOCA9IHJlLkNTdHJpbmcgPSByZS5CbG9iID0gcmUuQm9vbGVhbiA9IHJlLkJpdEZpZWxkID0gcmUuQml0U3RydWN0dXJlID0gcmUuVmFyaWFudExheW91dCA9IHJlLlVuaW9uID0gcmUuVW5pb25MYXlvdXREaXNjcmltaW5hdG9yID0gcmUuVW5pb25EaXNjcmltaW5hdG9yID0gcmUuU3RydWN0dXJlID0gcmUuU2VxdWVuY2UgPSByZS5Eb3VibGVCRSA9IHJlLkRvdWJsZSA9IHJlLkZsb2F0QkUgPSByZS5GbG9hdCA9IHJlLk5lYXJJbnQ2NEJFID0gcmUuTmVhckludDY0ID0gcmUuTmVhclVJbnQ2NEJFID0gcmUuTmVhclVJbnQ2NCA9IHJlLkludEJFID0gcmUuSW50ID0gcmUuVUludEJFID0gcmUuVUludCA9IHJlLk9mZnNldExheW91dCA9IHJlLkdyZWVkeUNvdW50ID0gcmUuRXh0ZXJuYWxMYXlvdXQgPSByZS5iaW5kQ29uc3RydWN0b3JMYXlvdXQgPSByZS5uYW1lV2l0aFByb3BlcnR5ID0gcmUuTGF5b3V0ID0gcmUudWludDhBcnJheVRvQnVmZmVyID0gcmUuY2hlY2tVaW50OEFycmF5ID0gdm9pZCAwLCByZS5jb25zdGFudCA9IHJlLnV0ZjggPSByZS5jc3RyID0gcmUuYmxvYiA9IHJlLnVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciA9IHJlLnVuaW9uID0gcmUuc2VxID0gcmUuYml0cyA9IHJlLnN0cnVjdCA9IHJlLmY2NGJlID0gcmUuZjY0ID0gcmUuZjMyYmUgPSByZS5mMzIgPSByZS5uczY0YmUgPSByZS5zNDhiZSA9IHJlLnM0MGJlID0gcmUuczMyYmUgPSByZS5zMjRiZSA9IHJlLnMxNmJlID0gcmUubnM2NCA9IHJlLnM0OCA9IHJlLnM0MCA9IHJlLnMzMiA9IHJlLnMyNCA9IHZvaWQgMDtcbiAgY29uc3QgcyA9IEtjKCk7XG4gIGZ1bmN0aW9uIGUobSkge1xuICAgIGlmICghKG0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJiIG11c3QgYmUgYSBVaW50OEFycmF5XCIpO1xuICB9XG4gIHJlLmNoZWNrVWludDhBcnJheSA9IGU7XG4gIGZ1bmN0aW9uIHQobSkge1xuICAgIHJldHVybiBlKG0pLCBzLkJ1ZmZlci5mcm9tKG0uYnVmZmVyLCBtLmJ5dGVPZmZzZXQsIG0ubGVuZ3RoKTtcbiAgfVxuICByZS51aW50OEFycmF5VG9CdWZmZXIgPSB0O1xuICBsZXQgciA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3Rvcih2LCBQKSB7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJzcGFuIG11c3QgYmUgYW4gaW50ZWdlclwiKTtcbiAgICAgIHRoaXMuc3BhbiA9IHYsIHRoaXMucHJvcGVydHkgPSBQO1xuICAgIH1cbiAgICAvKiogRnVuY3Rpb24gdG8gY3JlYXRlIGFuIE9iamVjdCBpbnRvIHdoaWNoIGRlY29kZWQgcHJvcGVydGllcyB3aWxsXG4gICAgICogYmUgd3JpdHRlbi5cbiAgICAgKlxuICAgICAqIFVzZWQgb25seSBmb3IgbGF5b3V0cyB0aGF0IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gdG8gT2JqZWN0XG4gICAgICogaW5zdGFuY2VzLCB3aGljaCBtZWFuczpcbiAgICAgKiAqIHtAbGluayBTdHJ1Y3R1cmV9XG4gICAgICogKiB7QGxpbmsgVW5pb259XG4gICAgICogKiB7QGxpbmsgVmFyaWFudExheW91dH1cbiAgICAgKiAqIHtAbGluayBCaXRTdHJ1Y3R1cmV9XG4gICAgICpcbiAgICAgKiBJZiBsZWZ0IHVuZGVmaW5lZCB0aGUgSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiB0aGVzZSBsYXlvdXRzXG4gICAgICogd2lsbCBiZSBPYmplY3QgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBiaW5kQ29uc3RydWN0b3JMYXlvdXR9LlxuICAgICAqL1xuICAgIG1ha2VEZXN0aW5hdGlvbk9iamVjdCgpIHtcbiAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBzcGFuIG9mIGEgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgYSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGIgLSB0aGUgYnVmZmVyIHRoYXQgY29udGFpbnMgYW4gZW5jb2RlZCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0XSAtIHRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIGVuY29kZWQgaW5zdGFuY2VcbiAgICAgKiBzdGFydHMuICBJZiBhYnNlbnQgYSB6ZXJvIG9mZnNldCBpcyBpbmZlcnJlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gLSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGNvdmVyZWQgYnkgdGhlIGxheW91dFxuICAgICAqIGluc3RhbmNlLiAgSWYgdGhpcyBtZXRob2QgaXMgbm90IG92ZXJyaWRkZW4gaW4gYSBzdWJjbGFzcyB0aGVcbiAgICAgKiBkZWZpbml0aW9uLXRpbWUgY29uc3RhbnQge0BsaW5rIExheW91dCNzcGFufHNwYW59IHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IC0gaWYgdGhlIGxlbmd0aCBvZiB0aGUgdmFsdWUgY2Fubm90IGJlXG4gICAgICogZGV0ZXJtaW5lZC5cbiAgICAgKi9cbiAgICBnZXRTcGFuKHYsIFApIHtcbiAgICAgIGlmICgwID4gdGhpcy5zcGFuKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImluZGV0ZXJtaW5hdGUgc3BhblwiKTtcbiAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxpY2F0ZSB0aGUgbGF5b3V0IHVzaW5nIGEgbmV3IHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBtdXN0IGJlIHVzZWQgdG8gZ2V0IGEgc3RydWN0dXJhbGx5LWVxdWl2YWxlbnQgbGF5b3V0XG4gICAgICogd2l0aCBhIGRpZmZlcmVudCBuYW1lIHNpbmNlIGFsbCB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZXMgYXJlXG4gICAgICogaW1tdXRhYmxlLlxuICAgICAqXG4gICAgICogKipOT1RFKiogVGhpcyBpcyBhIHNoYWxsb3cgY29weS4gIEFsbCBmaWVsZHMgZXhjZXB0IHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gYXJlIHN0cmljdGx5IGVxdWFsIHRvIHRoZSBvcmlnaW4gbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHZhbHVlIGZvciB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IGluIHRoZSByZXBsaWNhLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0xheW91dH0gLSB0aGUgY29weSB3aXRoIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9XG4gICAgICogc2V0IHRvIGBwcm9wZXJ0eWAuXG4gICAgICovXG4gICAgcmVwbGljYXRlKHYpIHtcbiAgICAgIGNvbnN0IFAgPSBPYmplY3QuY3JlYXRlKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKFAsIHRoaXMpLCBQLnByb3BlcnR5ID0gdiwgUDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIG9iamVjdCBmcm9tIGxheW91dCBwcm9wZXJ0aWVzIGFuZCBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAgaWYgaW52b2tlZCBvbiBhIGxheW91dFxuICAgICAqIHRoYXQgZG9lcyBub3QgcmV0dXJuIGl0cyB2YWx1ZSBhcyBhbiBPYmplY3QuICBPYmplY3RzIGFyZVxuICAgICAqIHJldHVybmVkIGZvciB0aGluZ3MgdGhhdCBhcmUgYSB7QGxpbmsgU3RydWN0dXJlfSwgd2hpY2ggaW5jbHVkZXNcbiAgICAgKiB7QGxpbmsgVmFyaWFudExheW91dHx2YXJpYW50IGxheW91dHN9IGlmIHRoZXkgYXJlIHN0cnVjdHVyZXMsIGFuZFxuICAgICAqIGV4Y2x1ZGVzIHtAbGluayBVbmlvbn1zLiAgSWYgeW91IHdhbnQgdGhpcyBmZWF0dXJlIGZvciBhIHVuaW9uXG4gICAgICogeW91IG11c3QgdXNlIHtAbGluayBVbmlvbi5nZXRWYXJpYW50fGdldFZhcmlhbnR9IHRvIHNlbGVjdCB0aGVcbiAgICAgKiBkZXNpcmVkIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAtIGFuIGFycmF5IG9mIHZhbHVlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlXG4gICAgICogZGVmYXVsdCBvcmRlciBmb3IgcHJvcGVydGllcy4gIEFzIHdpdGgge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfVxuICAgICAqIGxheW91dCBlbGVtZW50cyB0aGF0IGhhdmUgbm8gcHJvcGVydHkgbmFtZSBhcmUgc2tpcHBlZCB3aGVuXG4gICAgICogaXRlcmF0aW5nIG92ZXIgdGhlIGFycmF5IHZhbHVlcy4gIE9ubHkgdGhlIHRvcC1sZXZlbCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqIGFzc2lnbmVkOyBhcmd1bWVudHMgYXJlIG5vdCBhc3NpZ25lZCB0byBwcm9wZXJ0aWVzIG9mIGNvbnRhaW5lZFxuICAgICAqIGxheW91dHMuICBBbnkgdW51c2VkIHZhbHVlcyBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyhPYmplY3R8dW5kZWZpbmVkKX1cbiAgICAgKi9cbiAgICBmcm9tQXJyYXkodikge1xuICAgIH1cbiAgfTtcbiAgcmUuTGF5b3V0ID0gcjtcbiAgZnVuY3Rpb24gbihtLCB2KSB7XG4gICAgcmV0dXJuIHYucHJvcGVydHkgPyBtICsgXCJbXCIgKyB2LnByb3BlcnR5ICsgXCJdXCIgOiBtO1xuICB9XG4gIHJlLm5hbWVXaXRoUHJvcGVydHkgPSBuO1xuICBmdW5jdGlvbiBpKG0sIHYpIHtcbiAgICBpZiAodHlwZW9mIG0gIT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIG11c3QgYmUgY29uc3RydWN0b3JcIik7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtLCBcImxheW91dF9cIikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDbGFzcyBpcyBhbHJlYWR5IGJvdW5kIHRvIGEgbGF5b3V0XCIpO1xuICAgIGlmICghKHYgJiYgdiBpbnN0YW5jZW9mIHIpKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxheW91dCBtdXN0IGJlIGEgTGF5b3V0XCIpO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodiwgXCJib3VuZENvbnN0cnVjdG9yX1wiKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImxheW91dCBpcyBhbHJlYWR5IGJvdW5kIHRvIGEgY29uc3RydWN0b3JcIik7XG4gICAgbS5sYXlvdXRfID0gdiwgdi5ib3VuZENvbnN0cnVjdG9yXyA9IG0sIHYubWFrZURlc3RpbmF0aW9uT2JqZWN0ID0gKCgpID0+IG5ldyBtKCkpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobS5wcm90b3R5cGUsIFwiZW5jb2RlXCIsIHtcbiAgICAgIHZhbHVlKFAsIE4pIHtcbiAgICAgICAgcmV0dXJuIHYuZW5jb2RlKHRoaXMsIFAsIE4pO1xuICAgICAgfSxcbiAgICAgIHdyaXRhYmxlOiAhMFxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkobSwgXCJkZWNvZGVcIiwge1xuICAgICAgdmFsdWUoUCwgTikge1xuICAgICAgICByZXR1cm4gdi5kZWNvZGUoUCwgTik7XG4gICAgICB9LFxuICAgICAgd3JpdGFibGU6ICEwXG4gICAgfSk7XG4gIH1cbiAgcmUuYmluZENvbnN0cnVjdG9yTGF5b3V0ID0gaTtcbiAgY2xhc3MgbyBleHRlbmRzIHIge1xuICAgIC8qKlxuICAgICAqIFJldHVybiBgdHJ1ZWAgaWZmIHRoZSBleHRlcm5hbCBsYXlvdXQgZGVjb2RlcyB0byBhbiB1bnNpZ25lZFxuICAgICAqIGludGVnZXIgbGF5b3V0LlxuICAgICAqXG4gICAgICogSW4gdGhhdCBjYXNlIGl0IGNhbiBiZSB1c2VkIGFzIHRoZSBzb3VyY2Ugb2Yge0BsaW5rXG4gICAgICogU2VxdWVuY2UjY291bnR8U2VxdWVuY2UgY291bnRzfSwge0BsaW5rIEJsb2IjbGVuZ3RofEJsb2IgbGVuZ3Roc30sXG4gICAgICogb3IgYXMge0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciNsYXlvdXR8ZXh0ZXJuYWwgdW5pb25cbiAgICAgKiBkaXNjcmltaW5hdG9yc30uXG4gICAgICpcbiAgICAgKiBAYWJzdHJhY3RcbiAgICAgKi9cbiAgICBpc0NvdW50KCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXh0ZXJuYWxMYXlvdXQgaXMgYWJzdHJhY3RcIik7XG4gICAgfVxuICB9XG4gIHJlLkV4dGVybmFsTGF5b3V0ID0gbztcbiAgY2xhc3MgYSBleHRlbmRzIG8ge1xuICAgIGNvbnN0cnVjdG9yKHYgPSAxLCBQKSB7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodikgfHwgMCA+PSB2KVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZWxlbWVudFNwYW4gbXVzdCBiZSBhIChwb3NpdGl2ZSkgaW50ZWdlclwiKTtcbiAgICAgIHN1cGVyKC0xLCBQKSwgdGhpcy5lbGVtZW50U3BhbiA9IHY7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBpc0NvdW50KCkge1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKHYsIFAgPSAwKSB7XG4gICAgICBlKHYpO1xuICAgICAgY29uc3QgTiA9IHYubGVuZ3RoIC0gUDtcbiAgICAgIHJldHVybiBNYXRoLmZsb29yKE4gLyB0aGlzLmVsZW1lbnRTcGFuKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZSh2LCBQLCBOKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbiAgcmUuR3JlZWR5Q291bnQgPSBhO1xuICBjbGFzcyBsIGV4dGVuZHMgbyB7XG4gICAgY29uc3RydWN0b3IodiwgUCA9IDAsIE4pIHtcbiAgICAgIGlmICghKHYgaW5zdGFuY2VvZiByKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImxheW91dCBtdXN0IGJlIGEgTGF5b3V0XCIpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKFApKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwib2Zmc2V0IG11c3QgYmUgaW50ZWdlciBvciB1bmRlZmluZWRcIik7XG4gICAgICBzdXBlcih2LnNwYW4sIE4gfHwgdi5wcm9wZXJ0eSksIHRoaXMubGF5b3V0ID0gdiwgdGhpcy5vZmZzZXQgPSBQO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgaXNDb3VudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxheW91dCBpbnN0YW5jZW9mIGMgfHwgdGhpcy5sYXlvdXQgaW5zdGFuY2VvZiB1O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKHYsIFAgPSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZGVjb2RlKHYsIFAgKyB0aGlzLm9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUodiwgUCwgTiA9IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmxheW91dC5lbmNvZGUodiwgUCwgTiArIHRoaXMub2Zmc2V0KTtcbiAgICB9XG4gIH1cbiAgcmUuT2Zmc2V0TGF5b3V0ID0gbDtcbiAgY2xhc3MgYyBleHRlbmRzIHIge1xuICAgIGNvbnN0cnVjdG9yKHYsIFApIHtcbiAgICAgIGlmIChzdXBlcih2LCBQKSwgNiA8IHRoaXMuc3BhbilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzcGFuIG11c3Qgbm90IGV4Y2VlZCA2IGJ5dGVzXCIpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKHYsIFAgPSAwKSB7XG4gICAgICByZXR1cm4gdCh2KS5yZWFkVUludExFKFAsIHRoaXMuc3Bhbik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUodiwgUCwgTiA9IDApIHtcbiAgICAgIHJldHVybiB0KFApLndyaXRlVUludExFKHYsIE4sIHRoaXMuc3BhbiksIHRoaXMuc3BhbjtcbiAgICB9XG4gIH1cbiAgcmUuVUludCA9IGM7XG4gIGNsYXNzIHUgZXh0ZW5kcyByIHtcbiAgICBjb25zdHJ1Y3Rvcih2LCBQKSB7XG4gICAgICBpZiAoc3VwZXIodiwgUCksIDYgPCB0aGlzLnNwYW4pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwic3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlc1wiKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZSh2LCBQID0gMCkge1xuICAgICAgcmV0dXJuIHQodikucmVhZFVJbnRCRShQLCB0aGlzLnNwYW4pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHYsIFAsIE4gPSAwKSB7XG4gICAgICByZXR1cm4gdChQKS53cml0ZVVJbnRCRSh2LCBOLCB0aGlzLnNwYW4pLCB0aGlzLnNwYW47XG4gICAgfVxuICB9XG4gIHJlLlVJbnRCRSA9IHU7XG4gIGNsYXNzIGQgZXh0ZW5kcyByIHtcbiAgICBjb25zdHJ1Y3Rvcih2LCBQKSB7XG4gICAgICBpZiAoc3VwZXIodiwgUCksIDYgPCB0aGlzLnNwYW4pXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwic3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlc1wiKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZSh2LCBQID0gMCkge1xuICAgICAgcmV0dXJuIHQodikucmVhZEludExFKFAsIHRoaXMuc3Bhbik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUodiwgUCwgTiA9IDApIHtcbiAgICAgIHJldHVybiB0KFApLndyaXRlSW50TEUodiwgTiwgdGhpcy5zcGFuKSwgdGhpcy5zcGFuO1xuICAgIH1cbiAgfVxuICByZS5JbnQgPSBkO1xuICBjbGFzcyBoIGV4dGVuZHMgciB7XG4gICAgY29uc3RydWN0b3IodiwgUCkge1xuICAgICAgaWYgKHN1cGVyKHYsIFApLCA2IDwgdGhpcy5zcGFuKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNwYW4gbXVzdCBub3QgZXhjZWVkIDYgYnl0ZXNcIik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUodiwgUCA9IDApIHtcbiAgICAgIHJldHVybiB0KHYpLnJlYWRJbnRCRShQLCB0aGlzLnNwYW4pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHYsIFAsIE4gPSAwKSB7XG4gICAgICByZXR1cm4gdChQKS53cml0ZUludEJFKHYsIE4sIHRoaXMuc3BhbiksIHRoaXMuc3BhbjtcbiAgICB9XG4gIH1cbiAgcmUuSW50QkUgPSBoO1xuICBjb25zdCBmID0gTWF0aC5wb3coMiwgMzIpO1xuICBmdW5jdGlvbiBwKG0pIHtcbiAgICBjb25zdCB2ID0gTWF0aC5mbG9vcihtIC8gZiksIFAgPSBtIC0gdiAqIGY7XG4gICAgcmV0dXJuIHsgaGkzMjogdiwgbG8zMjogUCB9O1xuICB9XG4gIGZ1bmN0aW9uIHkobSwgdikge1xuICAgIHJldHVybiBtICogZiArIHY7XG4gIH1cbiAgY2xhc3MgRSBleHRlbmRzIHIge1xuICAgIGNvbnN0cnVjdG9yKHYpIHtcbiAgICAgIHN1cGVyKDgsIHYpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKHYsIFAgPSAwKSB7XG4gICAgICBjb25zdCBOID0gdCh2KSwgWSA9IE4ucmVhZFVJbnQzMkxFKFApLCBlZSA9IE4ucmVhZFVJbnQzMkxFKFAgKyA0KTtcbiAgICAgIHJldHVybiB5KGVlLCBZKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZSh2LCBQLCBOID0gMCkge1xuICAgICAgY29uc3QgWSA9IHAodiksIGVlID0gdChQKTtcbiAgICAgIHJldHVybiBlZS53cml0ZVVJbnQzMkxFKFkubG8zMiwgTiksIGVlLndyaXRlVUludDMyTEUoWS5oaTMyLCBOICsgNCksIDg7XG4gICAgfVxuICB9XG4gIHJlLk5lYXJVSW50NjQgPSBFO1xuICBjbGFzcyBiIGV4dGVuZHMgciB7XG4gICAgY29uc3RydWN0b3Iodikge1xuICAgICAgc3VwZXIoOCwgdik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUodiwgUCA9IDApIHtcbiAgICAgIGNvbnN0IE4gPSB0KHYpLCBZID0gTi5yZWFkVUludDMyQkUoUCksIGVlID0gTi5yZWFkVUludDMyQkUoUCArIDQpO1xuICAgICAgcmV0dXJuIHkoWSwgZWUpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHYsIFAsIE4gPSAwKSB7XG4gICAgICBjb25zdCBZID0gcCh2KSwgZWUgPSB0KFApO1xuICAgICAgcmV0dXJuIGVlLndyaXRlVUludDMyQkUoWS5oaTMyLCBOKSwgZWUud3JpdGVVSW50MzJCRShZLmxvMzIsIE4gKyA0KSwgODtcbiAgICB9XG4gIH1cbiAgcmUuTmVhclVJbnQ2NEJFID0gYjtcbiAgY2xhc3MgUiBleHRlbmRzIHIge1xuICAgIGNvbnN0cnVjdG9yKHYpIHtcbiAgICAgIHN1cGVyKDgsIHYpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKHYsIFAgPSAwKSB7XG4gICAgICBjb25zdCBOID0gdCh2KSwgWSA9IE4ucmVhZFVJbnQzMkxFKFApLCBlZSA9IE4ucmVhZEludDMyTEUoUCArIDQpO1xuICAgICAgcmV0dXJuIHkoZWUsIFkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHYsIFAsIE4gPSAwKSB7XG4gICAgICBjb25zdCBZID0gcCh2KSwgZWUgPSB0KFApO1xuICAgICAgcmV0dXJuIGVlLndyaXRlVUludDMyTEUoWS5sbzMyLCBOKSwgZWUud3JpdGVJbnQzMkxFKFkuaGkzMiwgTiArIDQpLCA4O1xuICAgIH1cbiAgfVxuICByZS5OZWFySW50NjQgPSBSO1xuICBjbGFzcyBBIGV4dGVuZHMgciB7XG4gICAgY29uc3RydWN0b3Iodikge1xuICAgICAgc3VwZXIoOCwgdik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUodiwgUCA9IDApIHtcbiAgICAgIGNvbnN0IE4gPSB0KHYpLCBZID0gTi5yZWFkSW50MzJCRShQKSwgZWUgPSBOLnJlYWRVSW50MzJCRShQICsgNCk7XG4gICAgICByZXR1cm4geShZLCBlZSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUodiwgUCwgTiA9IDApIHtcbiAgICAgIGNvbnN0IFkgPSBwKHYpLCBlZSA9IHQoUCk7XG4gICAgICByZXR1cm4gZWUud3JpdGVJbnQzMkJFKFkuaGkzMiwgTiksIGVlLndyaXRlVUludDMyQkUoWS5sbzMyLCBOICsgNCksIDg7XG4gICAgfVxuICB9XG4gIHJlLk5lYXJJbnQ2NEJFID0gQTtcbiAgY2xhc3MgRiBleHRlbmRzIHIge1xuICAgIGNvbnN0cnVjdG9yKHYpIHtcbiAgICAgIHN1cGVyKDQsIHYpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKHYsIFAgPSAwKSB7XG4gICAgICByZXR1cm4gdCh2KS5yZWFkRmxvYXRMRShQKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZSh2LCBQLCBOID0gMCkge1xuICAgICAgcmV0dXJuIHQoUCkud3JpdGVGbG9hdExFKHYsIE4pLCA0O1xuICAgIH1cbiAgfVxuICByZS5GbG9hdCA9IEY7XG4gIGNsYXNzIE0gZXh0ZW5kcyByIHtcbiAgICBjb25zdHJ1Y3Rvcih2KSB7XG4gICAgICBzdXBlcig0LCB2KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZSh2LCBQID0gMCkge1xuICAgICAgcmV0dXJuIHQodikucmVhZEZsb2F0QkUoUCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUodiwgUCwgTiA9IDApIHtcbiAgICAgIHJldHVybiB0KFApLndyaXRlRmxvYXRCRSh2LCBOKSwgNDtcbiAgICB9XG4gIH1cbiAgcmUuRmxvYXRCRSA9IE07XG4gIGNsYXNzIEggZXh0ZW5kcyByIHtcbiAgICBjb25zdHJ1Y3Rvcih2KSB7XG4gICAgICBzdXBlcig4LCB2KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZSh2LCBQID0gMCkge1xuICAgICAgcmV0dXJuIHQodikucmVhZERvdWJsZUxFKFApO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHYsIFAsIE4gPSAwKSB7XG4gICAgICByZXR1cm4gdChQKS53cml0ZURvdWJsZUxFKHYsIE4pLCA4O1xuICAgIH1cbiAgfVxuICByZS5Eb3VibGUgPSBIO1xuICBjbGFzcyBLIGV4dGVuZHMgciB7XG4gICAgY29uc3RydWN0b3Iodikge1xuICAgICAgc3VwZXIoOCwgdik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUodiwgUCA9IDApIHtcbiAgICAgIHJldHVybiB0KHYpLnJlYWREb3VibGVCRShQKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZSh2LCBQLCBOID0gMCkge1xuICAgICAgcmV0dXJuIHQoUCkud3JpdGVEb3VibGVCRSh2LCBOKSwgODtcbiAgICB9XG4gIH1cbiAgcmUuRG91YmxlQkUgPSBLO1xuICBjbGFzcyBqIGV4dGVuZHMgciB7XG4gICAgY29uc3RydWN0b3IodiwgUCwgTikge1xuICAgICAgaWYgKCEodiBpbnN0YW5jZW9mIHIpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZWxlbWVudExheW91dCBtdXN0IGJlIGEgTGF5b3V0XCIpO1xuICAgICAgaWYgKCEoUCBpbnN0YW5jZW9mIG8gJiYgUC5pc0NvdW50KCkgfHwgTnVtYmVyLmlzSW50ZWdlcihQKSAmJiAwIDw9IFApKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY291bnQgbXVzdCBiZSBub24tbmVnYXRpdmUgaW50ZWdlciBvciBhbiB1bnNpZ25lZCBpbnRlZ2VyIEV4dGVybmFsTGF5b3V0XCIpO1xuICAgICAgbGV0IFkgPSAtMTtcbiAgICAgICEoUCBpbnN0YW5jZW9mIG8pICYmIDAgPCB2LnNwYW4gJiYgKFkgPSBQICogdi5zcGFuKSwgc3VwZXIoWSwgTiksIHRoaXMuZWxlbWVudExheW91dCA9IHYsIHRoaXMuY291bnQgPSBQO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3Bhbih2LCBQID0gMCkge1xuICAgICAgaWYgKDAgPD0gdGhpcy5zcGFuKVxuICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgICAgbGV0IE4gPSAwLCBZID0gdGhpcy5jb3VudDtcbiAgICAgIGlmIChZIGluc3RhbmNlb2YgbyAmJiAoWSA9IFkuZGVjb2RlKHYsIFApKSwgMCA8IHRoaXMuZWxlbWVudExheW91dC5zcGFuKVxuICAgICAgICBOID0gWSAqIHRoaXMuZWxlbWVudExheW91dC5zcGFuO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGxldCBlZSA9IDA7XG4gICAgICAgIGZvciAoOyBlZSA8IFk7IClcbiAgICAgICAgICBOICs9IHRoaXMuZWxlbWVudExheW91dC5nZXRTcGFuKHYsIFAgKyBOKSwgKytlZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBOO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKHYsIFAgPSAwKSB7XG4gICAgICBjb25zdCBOID0gW107XG4gICAgICBsZXQgWSA9IDAsIGVlID0gdGhpcy5jb3VudDtcbiAgICAgIGZvciAoZWUgaW5zdGFuY2VvZiBvICYmIChlZSA9IGVlLmRlY29kZSh2LCBQKSk7IFkgPCBlZTsgKVxuICAgICAgICBOLnB1c2godGhpcy5lbGVtZW50TGF5b3V0LmRlY29kZSh2LCBQKSksIFAgKz0gdGhpcy5lbGVtZW50TGF5b3V0LmdldFNwYW4odiwgUCksIFkgKz0gMTtcbiAgICAgIHJldHVybiBOO1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBTZXF1ZW5jZX0uXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBJZiBgc3JjYCBpcyBzaG9ydGVyIHRoYW4ge0BsaW5rIFNlcXVlbmNlI2NvdW50fGNvdW50fSB0aGVuXG4gICAgICogdGhlIHVudXNlZCBzcGFjZSBpbiB0aGUgYnVmZmVyIGlzIGxlZnQgdW5jaGFuZ2VkLiAgSWYgYHNyY2AgaXNcbiAgICAgKiBsb25nZXIgdGhhbiB7QGxpbmsgU2VxdWVuY2UjY291bnR8Y291bnR9IHRoZSB1bm5lZWRlZCBlbGVtZW50cyBhcmVcbiAgICAgKiBpZ25vcmVkLlxuICAgICAqXG4gICAgICogKipOT1RFKiogSWYge0BsaW5rIExheW91dCNjb3VudHxjb3VudH0gaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rXG4gICAgICogRXh0ZXJuYWxMYXlvdXR9IHRoZW4gdGhlIGxlbmd0aCBvZiBgc3JjYCB3aWxsIGJlIGVuY29kZWQgYXMgdGhlXG4gICAgICogY291bnQgYWZ0ZXIgYHNyY2AgaXMgZW5jb2RlZC4gKi9cbiAgICBlbmNvZGUodiwgUCwgTiA9IDApIHtcbiAgICAgIGNvbnN0IFkgPSB0aGlzLmVsZW1lbnRMYXlvdXQsIGVlID0gdi5yZWR1Y2UoKGllLCBsZSkgPT4gaWUgKyBZLmVuY29kZShsZSwgUCwgTiArIGllKSwgMCk7XG4gICAgICByZXR1cm4gdGhpcy5jb3VudCBpbnN0YW5jZW9mIG8gJiYgdGhpcy5jb3VudC5lbmNvZGUodi5sZW5ndGgsIFAsIE4pLCBlZTtcbiAgICB9XG4gIH1cbiAgcmUuU2VxdWVuY2UgPSBqO1xuICBjbGFzcyBDIGV4dGVuZHMgciB7XG4gICAgY29uc3RydWN0b3IodiwgUCwgTikge1xuICAgICAgaWYgKCEoQXJyYXkuaXNBcnJheSh2KSAmJiB2LnJlZHVjZSgoZWUsIGllKSA9PiBlZSAmJiBpZSBpbnN0YW5jZW9mIHIsICEwKSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJmaWVsZHMgbXVzdCBiZSBhcnJheSBvZiBMYXlvdXQgaW5zdGFuY2VzXCIpO1xuICAgICAgdHlwZW9mIFAgPT0gXCJib29sZWFuXCIgJiYgTiA9PT0gdm9pZCAwICYmIChOID0gUCwgUCA9IHZvaWQgMCk7XG4gICAgICBmb3IgKGNvbnN0IGVlIG9mIHYpXG4gICAgICAgIGlmICgwID4gZWUuc3BhbiAmJiBlZS5wcm9wZXJ0eSA9PT0gdm9pZCAwKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZpZWxkcyBjYW5ub3QgY29udGFpbiB1bm5hbWVkIHZhcmlhYmxlLWxlbmd0aCBsYXlvdXRcIik7XG4gICAgICBsZXQgWSA9IC0xO1xuICAgICAgdHJ5IHtcbiAgICAgICAgWSA9IHYucmVkdWNlKChlZSwgaWUpID0+IGVlICsgaWUuZ2V0U3BhbigpLCAwKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgc3VwZXIoWSwgUCksIHRoaXMuZmllbGRzID0gdiwgdGhpcy5kZWNvZGVQcmVmaXhlcyA9ICEhTjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4odiwgUCA9IDApIHtcbiAgICAgIGlmICgwIDw9IHRoaXMuc3BhbilcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICAgIGxldCBOID0gMDtcbiAgICAgIHRyeSB7XG4gICAgICAgIE4gPSB0aGlzLmZpZWxkcy5yZWR1Y2UoKFksIGVlKSA9PiB7XG4gICAgICAgICAgY29uc3QgaWUgPSBlZS5nZXRTcGFuKHYsIFApO1xuICAgICAgICAgIHJldHVybiBQICs9IGllLCBZICsgaWU7XG4gICAgICAgIH0sIDApO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiaW5kZXRlcm1pbmF0ZSBzcGFuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE47XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUodiwgUCA9IDApIHtcbiAgICAgIGUodik7XG4gICAgICBjb25zdCBOID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgIGZvciAoY29uc3QgWSBvZiB0aGlzLmZpZWxkcylcbiAgICAgICAgaWYgKFkucHJvcGVydHkgIT09IHZvaWQgMCAmJiAoTltZLnByb3BlcnR5XSA9IFkuZGVjb2RlKHYsIFApKSwgUCArPSBZLmdldFNwYW4odiwgUCksIHRoaXMuZGVjb2RlUHJlZml4ZXMgJiYgdi5sZW5ndGggPT09IFApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICByZXR1cm4gTjtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgU3RydWN0dXJlfS5cbiAgICAgKlxuICAgICAqIElmIGBzcmNgIGlzIG1pc3NpbmcgYSBwcm9wZXJ0eSBmb3IgYSBtZW1iZXIgd2l0aCBhIGRlZmluZWQge0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB0aGUgY29ycmVzcG9uZGluZyByZWdpb24gb2YgdGhlIGJ1ZmZlciBpc1xuICAgICAqIGxlZnQgdW5tb2RpZmllZC4gKi9cbiAgICBlbmNvZGUodiwgUCwgTiA9IDApIHtcbiAgICAgIGNvbnN0IFkgPSBOO1xuICAgICAgbGV0IGVlID0gMCwgaWUgPSAwO1xuICAgICAgZm9yIChjb25zdCBsZSBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICBsZXQgVGUgPSBsZS5zcGFuO1xuICAgICAgICBpZiAoaWUgPSAwIDwgVGUgPyBUZSA6IDAsIGxlLnByb3BlcnR5ICE9PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zdCBEZSA9IHZbbGUucHJvcGVydHldO1xuICAgICAgICAgIERlICE9PSB2b2lkIDAgJiYgKGllID0gbGUuZW5jb2RlKERlLCBQLCBOKSwgMCA+IFRlICYmIChUZSA9IGxlLmdldFNwYW4oUCwgTikpKTtcbiAgICAgICAgfVxuICAgICAgICBlZSA9IE4sIE4gKz0gVGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWUgKyBpZSAtIFk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBmcm9tQXJyYXkodikge1xuICAgICAgY29uc3QgUCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgICBmb3IgKGNvbnN0IE4gb2YgdGhpcy5maWVsZHMpXG4gICAgICAgIE4ucHJvcGVydHkgIT09IHZvaWQgMCAmJiAwIDwgdi5sZW5ndGggJiYgKFBbTi5wcm9wZXJ0eV0gPSB2LnNoaWZ0KCkpO1xuICAgICAgcmV0dXJuIFA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhY2Nlc3MgdG8gdGhlIGxheW91dCBvZiBhIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHN0cnVjdHVyZSBtZW1iZXIgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtMYXlvdXR9IC0gdGhlIGxheW91dCBhc3NvY2lhdGVkIHdpdGggYHByb3BlcnR5YCwgb3JcbiAgICAgKiB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gc3VjaCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBsYXlvdXRGb3Iodikge1xuICAgICAgaWYgKHR5cGVvZiB2ICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwcm9wZXJ0eSBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgICAgIGZvciAoY29uc3QgUCBvZiB0aGlzLmZpZWxkcylcbiAgICAgICAgaWYgKFAucHJvcGVydHkgPT09IHYpXG4gICAgICAgICAgcmV0dXJuIFA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgb2Zmc2V0IG9mIGEgc3RydWN0dXJlIG1lbWJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBzdHJ1Y3R1cmUgbWVtYmVyIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAtIHRoZSBvZmZzZXQgaW4gYnl0ZXMgdG8gdGhlIHN0YXJ0IG9mIGBwcm9wZXJ0eWBcbiAgICAgKiB3aXRoaW4gdGhlIHN0cnVjdHVyZSwgb3IgdW5kZWZpbmVkIGlmIGBwcm9wZXJ0eWAgaXMgbm90IGEgZmllbGRcbiAgICAgKiB3aXRoaW4gdGhlIHN0cnVjdHVyZS4gIElmIHRoZSBwcm9wZXJ0eSBpcyBhIG1lbWJlciBidXQgZm9sbG93cyBhXG4gICAgICogdmFyaWFibGUtbGVuZ3RoIHN0cnVjdHVyZSBtZW1iZXIgYSBuZWdhdGl2ZSBudW1iZXIgd2lsbCBiZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqL1xuICAgIG9mZnNldE9mKHYpIHtcbiAgICAgIGlmICh0eXBlb2YgdiAhPSBcInN0cmluZ1wiKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwicHJvcGVydHkgbXVzdCBiZSBzdHJpbmdcIik7XG4gICAgICBsZXQgUCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IE4gb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgaWYgKE4ucHJvcGVydHkgPT09IHYpXG4gICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIDAgPiBOLnNwYW4gPyBQID0gLTEgOiAwIDw9IFAgJiYgKFAgKz0gTi5zcGFuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmUuU3RydWN0dXJlID0gQztcbiAgY2xhc3MgayB7XG4gICAgY29uc3RydWN0b3Iodikge1xuICAgICAgdGhpcy5wcm9wZXJ0eSA9IHY7XG4gICAgfVxuICAgIC8qKiBBbmFsb2cgdG8ge0BsaW5rIExheW91dCNkZWNvZGV8TGF5b3V0IGRlY29kZX0gZm9yIHVuaW9uIGRpc2NyaW1pbmF0b3JzLlxuICAgICAqXG4gICAgICogVGhlIGltcGxlbWVudGF0aW9uIG9mIHRoaXMgbWV0aG9kIG5lZWQgbm90IHJlZmVyZW5jZSB0aGUgYnVmZmVyIGlmXG4gICAgICogdmFyaWFudCBpbmZvcm1hdGlvbiBpcyBhdmFpbGFibGUgdGhyb3VnaCBvdGhlciBtZWFucy4gKi9cbiAgICBkZWNvZGUodiwgUCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5pb25EaXNjcmltaW5hdG9yIGlzIGFic3RyYWN0XCIpO1xuICAgIH1cbiAgICAvKiogQW5hbG9nIHRvIHtAbGluayBMYXlvdXQjZGVjb2RlfExheW91dCBlbmNvZGV9IGZvciB1bmlvbiBkaXNjcmltaW5hdG9ycy5cbiAgICAgKlxuICAgICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBuZWVkIG5vdCBzdG9yZSB0aGUgdmFsdWUgaWZcbiAgICAgKiB2YXJpYW50IGluZm9ybWF0aW9uIGlzIG1haW50YWluZWQgdGhyb3VnaCBvdGhlciBtZWFucy4gKi9cbiAgICBlbmNvZGUodiwgUCwgTikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5pb25EaXNjcmltaW5hdG9yIGlzIGFic3RyYWN0XCIpO1xuICAgIH1cbiAgfVxuICByZS5VbmlvbkRpc2NyaW1pbmF0b3IgPSBrO1xuICBjbGFzcyAkIGV4dGVuZHMgayB7XG4gICAgY29uc3RydWN0b3IodiwgUCkge1xuICAgICAgaWYgKCEodiBpbnN0YW5jZW9mIG8gJiYgdi5pc0NvdW50KCkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibGF5b3V0IG11c3QgYmUgYW4gdW5zaWduZWQgaW50ZWdlciBFeHRlcm5hbExheW91dFwiKTtcbiAgICAgIHN1cGVyKFAgfHwgdi5wcm9wZXJ0eSB8fCBcInZhcmlhbnRcIiksIHRoaXMubGF5b3V0ID0gdjtcbiAgICB9XG4gICAgLyoqIERlbGVnYXRlIGRlY29kaW5nIHRvIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IjbGF5b3V0fGxheW91dH0uICovXG4gICAgZGVjb2RlKHYsIFApIHtcbiAgICAgIHJldHVybiB0aGlzLmxheW91dC5kZWNvZGUodiwgUCk7XG4gICAgfVxuICAgIC8qKiBEZWxlZ2F0ZSBlbmNvZGluZyB0byB7QGxpbmsgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yI2xheW91dHxsYXlvdXR9LiAqL1xuICAgIGVuY29kZSh2LCBQLCBOKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZW5jb2RlKHYsIFAsIE4pO1xuICAgIH1cbiAgfVxuICByZS5VbmlvbkxheW91dERpc2NyaW1pbmF0b3IgPSAkO1xuICBjbGFzcyBXIGV4dGVuZHMgciB7XG4gICAgY29uc3RydWN0b3IodiwgUCwgTikge1xuICAgICAgbGV0IFk7XG4gICAgICBpZiAodiBpbnN0YW5jZW9mIGMgfHwgdiBpbnN0YW5jZW9mIHUpXG4gICAgICAgIFkgPSBuZXcgJChuZXcgbCh2KSk7XG4gICAgICBlbHNlIGlmICh2IGluc3RhbmNlb2YgbyAmJiB2LmlzQ291bnQoKSlcbiAgICAgICAgWSA9IG5ldyAkKHYpO1xuICAgICAgZWxzZSBpZiAodiBpbnN0YW5jZW9mIGspXG4gICAgICAgIFkgPSB2O1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiZGlzY3IgbXVzdCBiZSBhIFVuaW9uRGlzY3JpbWluYXRvciBvciBhbiB1bnNpZ25lZCBpbnRlZ2VyIGxheW91dFwiKTtcbiAgICAgIGlmIChQID09PSB2b2lkIDAgJiYgKFAgPSBudWxsKSwgIShQID09PSBudWxsIHx8IFAgaW5zdGFuY2VvZiByKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImRlZmF1bHRMYXlvdXQgbXVzdCBiZSBudWxsIG9yIGEgTGF5b3V0XCIpO1xuICAgICAgaWYgKFAgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKDAgPiBQLnNwYW4pXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGVmYXVsdExheW91dCBtdXN0IGhhdmUgY29uc3RhbnQgc3BhblwiKTtcbiAgICAgICAgUC5wcm9wZXJ0eSA9PT0gdm9pZCAwICYmIChQID0gUC5yZXBsaWNhdGUoXCJjb250ZW50XCIpKTtcbiAgICAgIH1cbiAgICAgIGxldCBlZSA9IC0xO1xuICAgICAgUCAmJiAoZWUgPSBQLnNwYW4sIDAgPD0gZWUgJiYgKHYgaW5zdGFuY2VvZiBjIHx8IHYgaW5zdGFuY2VvZiB1KSAmJiAoZWUgKz0gWS5sYXlvdXQuc3BhbikpLCBzdXBlcihlZSwgTiksIHRoaXMuZGlzY3JpbWluYXRvciA9IFksIHRoaXMudXNlc1ByZWZpeERpc2NyaW1pbmF0b3IgPSB2IGluc3RhbmNlb2YgYyB8fCB2IGluc3RhbmNlb2YgdSwgdGhpcy5kZWZhdWx0TGF5b3V0ID0gUCwgdGhpcy5yZWdpc3RyeSA9IHt9O1xuICAgICAgbGV0IGllID0gdGhpcy5kZWZhdWx0R2V0U291cmNlVmFyaWFudC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5nZXRTb3VyY2VWYXJpYW50ID0gZnVuY3Rpb24obGUpIHtcbiAgICAgICAgcmV0dXJuIGllKGxlKTtcbiAgICAgIH0sIHRoaXMuY29uZmlnR2V0U291cmNlVmFyaWFudCA9IGZ1bmN0aW9uKGxlKSB7XG4gICAgICAgIGllID0gbGUuYmluZCh0aGlzKTtcbiAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKHYsIFAgPSAwKSB7XG4gICAgICBpZiAoMCA8PSB0aGlzLnNwYW4pXG4gICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgICBjb25zdCBOID0gdGhpcy5nZXRWYXJpYW50KHYsIFApO1xuICAgICAgaWYgKCFOKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmFibGUgdG8gZGV0ZXJtaW5lIHNwYW4gZm9yIHVucmVjb2duaXplZCB2YXJpYW50XCIpO1xuICAgICAgcmV0dXJuIE4uZ2V0U3Bhbih2LCBQKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGluZmVyIGEgcmVnaXN0ZXJlZCBVbmlvbiB2YXJpYW50IGNvbXBhdGlibGUgd2l0aCBgc3JjYC5cbiAgICAgKlxuICAgICAqIFRoZSBmaXJzdCBzYXRpc2ZpZWQgcnVsZSBpbiB0aGUgZm9sbG93aW5nIHNlcXVlbmNlIGRlZmluZXMgdGhlXG4gICAgICogcmV0dXJuIHZhbHVlOlxuICAgICAqICogSWYgYHNyY2AgaGFzIHByb3BlcnRpZXMgbWF0Y2hpbmcgdGhlIFVuaW9uIGRpc2NyaW1pbmF0b3IgYW5kXG4gICAgICogICB0aGUgZGVmYXVsdCBsYXlvdXQsIGB1bmRlZmluZWRgIGlzIHJldHVybmVkIHJlZ2FyZGxlc3Mgb2YgdGhlXG4gICAgICogICB2YWx1ZSBvZiB0aGUgZGlzY3JpbWluYXRvciBwcm9wZXJ0eSAodGhpcyBlbnN1cmVzIHRoZSBkZWZhdWx0XG4gICAgICogICBsYXlvdXQgd2lsbCBiZSB1c2VkKTtcbiAgICAgKiAqIElmIGBzcmNgIGhhcyBhIHByb3BlcnR5IG1hdGNoaW5nIHRoZSBVbmlvbiBkaXNjcmltaW5hdG9yLCB0aGVcbiAgICAgKiAgIHZhbHVlIG9mIHRoZSBkaXNjcmltaW5hdG9yIGlkZW50aWZpZXMgYSByZWdpc3RlcmVkIHZhcmlhbnQsIGFuZFxuICAgICAqICAgZWl0aGVyIChhKSB0aGUgdmFyaWFudCBoYXMgbm8gbGF5b3V0LCBvciAoYikgYHNyY2AgaGFzIHRoZVxuICAgICAqICAgdmFyaWFudCdzIHByb3BlcnR5LCB0aGVuIHRoZSB2YXJpYW50IGlzIHJldHVybmVkIChiZWNhdXNlIHRoZVxuICAgICAqICAgc291cmNlIHNhdGlzZmllcyB0aGUgY29uc3RyYWludHMgb2YgdGhlIHZhcmlhbnQgaXQgaWRlbnRpZmllcyk7XG4gICAgICogKiBJZiBgc3JjYCBkb2VzIG5vdCBoYXZlIGEgcHJvcGVydHkgbWF0Y2hpbmcgdGhlIFVuaW9uXG4gICAgICogICBkaXNjcmltaW5hdG9yLCBidXQgZG9lcyBoYXZlIGEgcHJvcGVydHkgbWF0Y2hpbmcgYSByZWdpc3RlcmVkXG4gICAgICogICB2YXJpYW50LCB0aGVuIHRoZSB2YXJpYW50IGlzIHJldHVybmVkIChiZWNhdXNlIHRoZSBzb3VyY2VcbiAgICAgKiAgIG1hdGNoZXMgYSB2YXJpYW50IHdpdGhvdXQgYW4gZXhwbGljaXQgY29uZmxpY3QpO1xuICAgICAqICogQW4gZXJyb3IgaXMgdGhyb3duIChiZWNhdXNlIHdlIGVpdGhlciBjYW4ndCBpZGVudGlmeSBhIHZhcmlhbnQsXG4gICAgICogICBvciB3ZSB3ZXJlIGV4cGxpY2l0bHkgdG9sZCB0aGUgdmFyaWFudCBidXQgY2FuJ3Qgc2F0aXNmeSBpdCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjIC0gYW4gb2JqZWN0IHByZXN1bWVkIHRvIGJlIGNvbXBhdGlibGUgd2l0aFxuICAgICAqIHRoZSBjb250ZW50IG9mIHRoZSBVbmlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyh1bmRlZmluZWR8VmFyaWFudExheW91dCl9IC0gYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IC0gaWYgYHNyY2AgY2Fubm90IGJlIGFzc29jaWF0ZWQgd2l0aCBhIGRlZmF1bHQgb3JcbiAgICAgKiByZWdpc3RlcmVkIHZhcmlhbnQuXG4gICAgICovXG4gICAgZGVmYXVsdEdldFNvdXJjZVZhcmlhbnQodikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2LCB0aGlzLmRpc2NyaW1pbmF0b3IucHJvcGVydHkpKSB7XG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRMYXlvdXQgJiYgdGhpcy5kZWZhdWx0TGF5b3V0LnByb3BlcnR5ICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2LCB0aGlzLmRlZmF1bHRMYXlvdXQucHJvcGVydHkpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgUCA9IHRoaXMucmVnaXN0cnlbdlt0aGlzLmRpc2NyaW1pbmF0b3IucHJvcGVydHldXTtcbiAgICAgICAgaWYgKFAgJiYgKCFQLmxheW91dCB8fCBQLnByb3BlcnR5ICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2LCBQLnByb3BlcnR5KSkpXG4gICAgICAgICAgcmV0dXJuIFA7XG4gICAgICB9IGVsc2VcbiAgICAgICAgZm9yIChjb25zdCBQIGluIHRoaXMucmVnaXN0cnkpIHtcbiAgICAgICAgICBjb25zdCBOID0gdGhpcy5yZWdpc3RyeVtQXTtcbiAgICAgICAgICBpZiAoTi5wcm9wZXJ0eSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodiwgTi5wcm9wZXJ0eSkpXG4gICAgICAgICAgICByZXR1cm4gTjtcbiAgICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5hYmxlIHRvIGluZmVyIHNyYyB2YXJpYW50XCIpO1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gZm9yIHtAbGluayBVbmlvbn0uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdmFyaWFudCBpcyB7QGxpbmsgVW5pb24jYWRkVmFyaWFudHxyZWdpc3RlcmVkfSB0aGUgcmV0dXJuXG4gICAgICogdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgdGhhdCB2YXJpYW50LCB3aXRoIG5vIGV4cGxpY2l0XG4gICAgICogZGlzY3JpbWluYXRvci4gIE90aGVyd2lzZSB0aGUge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdFxuICAgICAqIGxheW91dH0gaXMgdXNlZCB0byBkZWNvZGUgdGhlIGNvbnRlbnQuICovXG4gICAgZGVjb2RlKHYsIFAgPSAwKSB7XG4gICAgICBsZXQgTjtcbiAgICAgIGNvbnN0IFkgPSB0aGlzLmRpc2NyaW1pbmF0b3IsIGVlID0gWS5kZWNvZGUodiwgUCksIGllID0gdGhpcy5yZWdpc3RyeVtlZV07XG4gICAgICBpZiAoaWUgPT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBsZSA9IHRoaXMuZGVmYXVsdExheW91dDtcbiAgICAgICAgbGV0IFRlID0gMDtcbiAgICAgICAgdGhpcy51c2VzUHJlZml4RGlzY3JpbWluYXRvciAmJiAoVGUgPSBZLmxheW91dC5zcGFuKSwgTiA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCksIE5bWS5wcm9wZXJ0eV0gPSBlZSwgTltsZS5wcm9wZXJ0eV0gPSBsZS5kZWNvZGUodiwgUCArIFRlKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBOID0gaWUuZGVjb2RlKHYsIFApO1xuICAgICAgcmV0dXJuIE47XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIFVuaW9ufS5cbiAgICAgKlxuICAgICAqIFRoaXMgQVBJIGFzc3VtZXMgdGhlIGBzcmNgIG9iamVjdCBpcyBjb25zaXN0ZW50IHdpdGggdGhlIHVuaW9uJ3NcbiAgICAgKiB7QGxpbmsgVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0uICBUbyBlbmNvZGUgdmFyaWFudHNcbiAgICAgKiB1c2UgdGhlIGFwcHJvcHJpYXRlIHZhcmlhbnQtc3BlY2lmaWMge0BsaW5rIFZhcmlhbnRMYXlvdXQjZW5jb2RlfVxuICAgICAqIG1ldGhvZC4gKi9cbiAgICBlbmNvZGUodiwgUCwgTiA9IDApIHtcbiAgICAgIGNvbnN0IFkgPSB0aGlzLmdldFNvdXJjZVZhcmlhbnQodik7XG4gICAgICBpZiAoWSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IGVlID0gdGhpcy5kaXNjcmltaW5hdG9yLCBpZSA9IHRoaXMuZGVmYXVsdExheW91dDtcbiAgICAgICAgbGV0IGxlID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMudXNlc1ByZWZpeERpc2NyaW1pbmF0b3IgJiYgKGxlID0gZWUubGF5b3V0LnNwYW4pLCBlZS5lbmNvZGUodltlZS5wcm9wZXJ0eV0sIFAsIE4pLCBsZSArIGllLmVuY29kZSh2W2llLnByb3BlcnR5XSwgUCwgTiArIGxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBZLmVuY29kZSh2LCBQLCBOKTtcbiAgICB9XG4gICAgLyoqIFJlZ2lzdGVyIGEgbmV3IHZhcmlhbnQgc3RydWN0dXJlIHdpdGhpbiBhIHVuaW9uLiAgVGhlIG5ld2x5XG4gICAgICogY3JlYXRlZCB2YXJpYW50IGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhcmlhbnQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAgICogVmFyaWFudExheW91dCN2YXJpYW50fHZhcmlhbnR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtMYXlvdXR9IGxheW91dCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICAgKiBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtWYXJpYW50TGF5b3V0fSAqL1xuICAgIGFkZFZhcmlhbnQodiwgUCwgTikge1xuICAgICAgY29uc3QgWSA9IG5ldyBfKHRoaXMsIHYsIFAsIE4pO1xuICAgICAgcmV0dXJuIHRoaXMucmVnaXN0cnlbdl0gPSBZLCBZO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxheW91dCBhc3NvY2lhdGVkIHdpdGggYSByZWdpc3RlcmVkIHZhcmlhbnQuXG4gICAgICpcbiAgICAgKiBJZiBgdmJgIGRvZXMgbm90IHByb2R1Y2UgYSByZWdpc3RlcmVkIHZhcmlhbnQgdGhlIGZ1bmN0aW9uIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7KE51bWJlcnxVaW50OEFycmF5KX0gdmIgLSBlaXRoZXIgdGhlIHZhcmlhbnQgbnVtYmVyLCBvciBhXG4gICAgICogYnVmZmVyIGZyb20gd2hpY2ggdGhlIGRpc2NyaW1pbmF0b3IgaXMgdG8gYmUgcmVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgLSBvZmZzZXQgaW50byBgdmJgIGZvciB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICogdW5pb24uICBVc2VkIG9ubHkgd2hlbiBgdmJgIGlzIGFuIGluc3RhbmNlIG9mIHtVaW50OEFycmF5fS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyh7VmFyaWFudExheW91dH18dW5kZWZpbmVkKX1cbiAgICAgKi9cbiAgICBnZXRWYXJpYW50KHYsIFAgPSAwKSB7XG4gICAgICBsZXQgTjtcbiAgICAgIHJldHVybiB2IGluc3RhbmNlb2YgVWludDhBcnJheSA/IE4gPSB0aGlzLmRpc2NyaW1pbmF0b3IuZGVjb2RlKHYsIFApIDogTiA9IHYsIHRoaXMucmVnaXN0cnlbTl07XG4gICAgfVxuICB9XG4gIHJlLlVuaW9uID0gVztcbiAgY2xhc3MgXyBleHRlbmRzIHIge1xuICAgIGNvbnN0cnVjdG9yKHYsIFAsIE4sIFkpIHtcbiAgICAgIGlmICghKHYgaW5zdGFuY2VvZiBXKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInVuaW9uIG11c3QgYmUgYSBVbmlvblwiKTtcbiAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihQKSB8fCAwID4gUClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcInZhcmlhbnQgbXVzdCBiZSBhIChub24tbmVnYXRpdmUpIGludGVnZXJcIik7XG4gICAgICBpZiAodHlwZW9mIE4gPT0gXCJzdHJpbmdcIiAmJiBZID09PSB2b2lkIDAgJiYgKFkgPSBOLCBOID0gbnVsbCksIE4pIHtcbiAgICAgICAgaWYgKCEoTiBpbnN0YW5jZW9mIHIpKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsYXlvdXQgbXVzdCBiZSBhIExheW91dFwiKTtcbiAgICAgICAgaWYgKHYuZGVmYXVsdExheW91dCAhPT0gbnVsbCAmJiAwIDw9IE4uc3BhbiAmJiBOLnNwYW4gPiB2LmRlZmF1bHRMYXlvdXQuc3BhbilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ2YXJpYW50IHNwYW4gZXhjZWVkcyBzcGFuIG9mIGNvbnRhaW5pbmcgdW5pb25cIik7XG4gICAgICAgIGlmICh0eXBlb2YgWSAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJ2YXJpYW50IG11c3QgaGF2ZSBhIFN0cmluZyBwcm9wZXJ0eVwiKTtcbiAgICAgIH1cbiAgICAgIGxldCBlZSA9IHYuc3BhbjtcbiAgICAgIDAgPiB2LnNwYW4gJiYgKGVlID0gTiA/IE4uc3BhbiA6IDAsIDAgPD0gZWUgJiYgdi51c2VzUHJlZml4RGlzY3JpbWluYXRvciAmJiAoZWUgKz0gdi5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuKSksIHN1cGVyKGVlLCBZKSwgdGhpcy51bmlvbiA9IHYsIHRoaXMudmFyaWFudCA9IFAsIHRoaXMubGF5b3V0ID0gTiB8fCBudWxsO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3Bhbih2LCBQID0gMCkge1xuICAgICAgaWYgKDAgPD0gdGhpcy5zcGFuKVxuICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgICAgbGV0IE4gPSAwO1xuICAgICAgdGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvciAmJiAoTiA9IHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3Bhbik7XG4gICAgICBsZXQgWSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5sYXlvdXQgJiYgKFkgPSB0aGlzLmxheW91dC5nZXRTcGFuKHYsIFAgKyBOKSksIE4gKyBZO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKHYsIFAgPSAwKSB7XG4gICAgICBjb25zdCBOID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgIGlmICh0aGlzICE9PSB0aGlzLnVuaW9uLmdldFZhcmlhbnQodiwgUCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInZhcmlhbnQgbWlzbWF0Y2hcIik7XG4gICAgICBsZXQgWSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvciAmJiAoWSA9IHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbiksIHRoaXMubGF5b3V0ID8gTlt0aGlzLnByb3BlcnR5XSA9IHRoaXMubGF5b3V0LmRlY29kZSh2LCBQICsgWSkgOiB0aGlzLnByb3BlcnR5ID8gTlt0aGlzLnByb3BlcnR5XSA9ICEwIDogdGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvciAmJiAoTlt0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IucHJvcGVydHldID0gdGhpcy52YXJpYW50KSwgTjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZSh2LCBQLCBOID0gMCkge1xuICAgICAgbGV0IFkgPSAwO1xuICAgICAgaWYgKHRoaXMudW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IgJiYgKFkgPSB0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW4pLCB0aGlzLmxheW91dCAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHYsIHRoaXMucHJvcGVydHkpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwidmFyaWFudCBsYWNrcyBwcm9wZXJ0eSBcIiArIHRoaXMucHJvcGVydHkpO1xuICAgICAgdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLmVuY29kZSh0aGlzLnZhcmlhbnQsIFAsIE4pO1xuICAgICAgbGV0IGVlID0gWTtcbiAgICAgIGlmICh0aGlzLmxheW91dCAmJiAodGhpcy5sYXlvdXQuZW5jb2RlKHZbdGhpcy5wcm9wZXJ0eV0sIFAsIE4gKyBZKSwgZWUgKz0gdGhpcy5sYXlvdXQuZ2V0U3BhbihQLCBOICsgWSksIDAgPD0gdGhpcy51bmlvbi5zcGFuICYmIGVlID4gdGhpcy51bmlvbi5zcGFuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZW5jb2RlZCB2YXJpYW50IG92ZXJydW5zIGNvbnRhaW5pbmcgdW5pb25cIik7XG4gICAgICByZXR1cm4gZWU7XG4gICAgfVxuICAgIC8qKiBEZWxlZ2F0ZSB7QGxpbmsgTGF5b3V0I2Zyb21BcnJheXxmcm9tQXJyYXl9IHRvIHtAbGlua1xuICAgICAqIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dH0uICovXG4gICAgZnJvbUFycmF5KHYpIHtcbiAgICAgIGlmICh0aGlzLmxheW91dClcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmZyb21BcnJheSh2KTtcbiAgICB9XG4gIH1cbiAgcmUuVmFyaWFudExheW91dCA9IF87XG4gIGZ1bmN0aW9uIGcobSkge1xuICAgIHJldHVybiAwID4gbSAmJiAobSArPSA0Mjk0OTY3Mjk2KSwgbTtcbiAgfVxuICBjbGFzcyB4IGV4dGVuZHMgciB7XG4gICAgY29uc3RydWN0b3IodiwgUCwgTikge1xuICAgICAgaWYgKCEodiBpbnN0YW5jZW9mIGMgfHwgdiBpbnN0YW5jZW9mIHUpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwid29yZCBtdXN0IGJlIGEgVUludCBvciBVSW50QkUgbGF5b3V0XCIpO1xuICAgICAgaWYgKHR5cGVvZiBQID09IFwic3RyaW5nXCIgJiYgTiA9PT0gdm9pZCAwICYmIChOID0gUCwgUCA9ICExKSwgNCA8IHYuc3BhbilcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ3b3JkIGNhbm5vdCBleGNlZWQgMzIgYml0c1wiKTtcbiAgICAgIHN1cGVyKHYuc3BhbiwgTiksIHRoaXMud29yZCA9IHYsIHRoaXMubXNiID0gISFQLCB0aGlzLmZpZWxkcyA9IFtdO1xuICAgICAgbGV0IFkgPSAwO1xuICAgICAgdGhpcy5fcGFja2VkU2V0VmFsdWUgPSBmdW5jdGlvbihlZSkge1xuICAgICAgICByZXR1cm4gWSA9IGcoZWUpLCB0aGlzO1xuICAgICAgfSwgdGhpcy5fcGFja2VkR2V0VmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFk7XG4gICAgICB9O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKHYsIFAgPSAwKSB7XG4gICAgICBjb25zdCBOID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKSwgWSA9IHRoaXMud29yZC5kZWNvZGUodiwgUCk7XG4gICAgICB0aGlzLl9wYWNrZWRTZXRWYWx1ZShZKTtcbiAgICAgIGZvciAoY29uc3QgZWUgb2YgdGhpcy5maWVsZHMpXG4gICAgICAgIGVlLnByb3BlcnR5ICE9PSB2b2lkIDAgJiYgKE5bZWUucHJvcGVydHldID0gZWUuZGVjb2RlKHYpKTtcbiAgICAgIHJldHVybiBOO1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBCaXRTdHJ1Y3R1cmV9LlxuICAgICAqXG4gICAgICogSWYgYHNyY2AgaXMgbWlzc2luZyBhIHByb3BlcnR5IGZvciBhIG1lbWJlciB3aXRoIGEgZGVmaW5lZCB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHRoZSBjb3JyZXNwb25kaW5nIHJlZ2lvbiBvZiB0aGUgcGFja2VkXG4gICAgICogdmFsdWUgaXMgbGVmdCB1bm1vZGlmaWVkLiAgVW51c2VkIGJpdHMgYXJlIGFsc28gbGVmdCB1bm1vZGlmaWVkLiAqL1xuICAgIGVuY29kZSh2LCBQLCBOID0gMCkge1xuICAgICAgY29uc3QgWSA9IHRoaXMud29yZC5kZWNvZGUoUCwgTik7XG4gICAgICB0aGlzLl9wYWNrZWRTZXRWYWx1ZShZKTtcbiAgICAgIGZvciAoY29uc3QgZWUgb2YgdGhpcy5maWVsZHMpXG4gICAgICAgIGlmIChlZS5wcm9wZXJ0eSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgY29uc3QgaWUgPSB2W2VlLnByb3BlcnR5XTtcbiAgICAgICAgICBpZSAhPT0gdm9pZCAwICYmIGVlLmVuY29kZShpZSk7XG4gICAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndvcmQuZW5jb2RlKHRoaXMuX3BhY2tlZEdldFZhbHVlKCksIFAsIE4pO1xuICAgIH1cbiAgICAvKiogUmVnaXN0ZXIgYSBuZXcgYml0ZmllbGQgd2l0aCBhIGNvbnRhaW5pbmcgYml0IHN0cnVjdHVyZS4gIFRoZVxuICAgICAqIHJlc3VsdGluZyBiaXRmaWVsZCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBiaXRzIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBCaXRGaWVsZCNiaXRzfGJpdHN9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCaXRGaWVsZH0gKi9cbiAgICBhZGRGaWVsZCh2LCBQKSB7XG4gICAgICBjb25zdCBOID0gbmV3IHcodGhpcywgdiwgUCk7XG4gICAgICByZXR1cm4gdGhpcy5maWVsZHMucHVzaChOKSwgTjtcbiAgICB9XG4gICAgLyoqIEFzIHdpdGgge0BsaW5rIEJpdFN0cnVjdHVyZSNhZGRGaWVsZHxhZGRGaWVsZH0gZm9yIHNpbmdsZS1iaXRcbiAgICAgKiBmaWVsZHMgd2l0aCBgYm9vbGVhbmAgdmFsdWUgcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICovXG4gICAgLy8gYEJvb2xlYW5gIGNvbmZsaWN0cyB3aXRoIHRoZSBuYXRpdmUgcHJpbWl0aXZlIHR5cGVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgIGFkZEJvb2xlYW4odikge1xuICAgICAgY29uc3QgUCA9IG5ldyBEKHRoaXMsIHYpO1xuICAgICAgcmV0dXJuIHRoaXMuZmllbGRzLnB1c2goUCksIFA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhY2Nlc3MgdG8gdGhlIGJpdCBmaWVsZCBmb3IgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBiaXQgZmllbGQgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCaXRGaWVsZH0gLSB0aGUgZmllbGQgYXNzb2NpYXRlZCB3aXRoIGBwcm9wZXJ0eWAsIG9yXG4gICAgICogdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIHN1Y2ggcHJvcGVydHkuXG4gICAgICovXG4gICAgZmllbGRGb3Iodikge1xuICAgICAgaWYgKHR5cGVvZiB2ICE9IFwic3RyaW5nXCIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJwcm9wZXJ0eSBtdXN0IGJlIHN0cmluZ1wiKTtcbiAgICAgIGZvciAoY29uc3QgUCBvZiB0aGlzLmZpZWxkcylcbiAgICAgICAgaWYgKFAucHJvcGVydHkgPT09IHYpXG4gICAgICAgICAgcmV0dXJuIFA7XG4gICAgfVxuICB9XG4gIHJlLkJpdFN0cnVjdHVyZSA9IHg7XG4gIGNsYXNzIHcge1xuICAgIGNvbnN0cnVjdG9yKHYsIFAsIE4pIHtcbiAgICAgIGlmICghKHYgaW5zdGFuY2VvZiB4KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNvbnRhaW5lciBtdXN0IGJlIGEgQml0U3RydWN0dXJlXCIpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKFApIHx8IDAgPj0gUClcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImJpdHMgbXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyXCIpO1xuICAgICAgY29uc3QgWSA9IDggKiB2LnNwYW4sIGVlID0gdi5maWVsZHMucmVkdWNlKChpZSwgbGUpID0+IGllICsgbGUuYml0cywgMCk7XG4gICAgICBpZiAoUCArIGVlID4gWSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYml0cyB0b28gbG9uZyBmb3Igc3BhbiByZW1haW5kZXIgKFwiICsgKFkgLSBlZSkgKyBcIiBvZiBcIiArIFkgKyBcIiByZW1haW4pXCIpO1xuICAgICAgdGhpcy5jb250YWluZXIgPSB2LCB0aGlzLmJpdHMgPSBQLCB0aGlzLnZhbHVlTWFzayA9ICgxIDw8IFApIC0gMSwgUCA9PT0gMzIgJiYgKHRoaXMudmFsdWVNYXNrID0gNDI5NDk2NzI5NSksIHRoaXMuc3RhcnQgPSBlZSwgdGhpcy5jb250YWluZXIubXNiICYmICh0aGlzLnN0YXJ0ID0gWSAtIGVlIC0gUCksIHRoaXMud29yZE1hc2sgPSBnKHRoaXMudmFsdWVNYXNrIDw8IHRoaXMuc3RhcnQpLCB0aGlzLnByb3BlcnR5ID0gTjtcbiAgICB9XG4gICAgLyoqIFN0b3JlIGEgdmFsdWUgaW50byB0aGUgY29ycmVzcG9uZGluZyBzdWJzZXF1ZW5jZSBvZiB0aGUgY29udGFpbmluZ1xuICAgICAqIGJpdCBmaWVsZC4gKi9cbiAgICBkZWNvZGUodiwgUCkge1xuICAgICAgY29uc3QgTiA9IHRoaXMuY29udGFpbmVyLl9wYWNrZWRHZXRWYWx1ZSgpO1xuICAgICAgcmV0dXJuIGcoTiAmIHRoaXMud29yZE1hc2spID4+PiB0aGlzLnN0YXJ0O1xuICAgIH1cbiAgICAvKiogU3RvcmUgYSB2YWx1ZSBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIHN1YnNlcXVlbmNlIG9mIHRoZSBjb250YWluaW5nXG4gICAgICogYml0IGZpZWxkLlxuICAgICAqXG4gICAgICogKipOT1RFKiogVGhpcyBpcyBub3QgYSBzcGVjaWFsaXphdGlvbiBvZiB7QGxpbmtcbiAgICAgKiBMYXlvdXQjZW5jb2RlfExheW91dC5lbmNvZGV9IGFuZCB0aGVyZSBpcyBubyByZXR1cm4gdmFsdWUuICovXG4gICAgZW5jb2RlKHYpIHtcbiAgICAgIGlmICh0eXBlb2YgdiAhPSBcIm51bWJlclwiIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHYpIHx8IHYgIT09IGcodiAmIHRoaXMudmFsdWVNYXNrKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihuKFwiQml0RmllbGQuZW5jb2RlXCIsIHRoaXMpICsgXCIgdmFsdWUgbXVzdCBiZSBpbnRlZ2VyIG5vdCBleGNlZWRpbmcgXCIgKyB0aGlzLnZhbHVlTWFzayk7XG4gICAgICBjb25zdCBQID0gdGhpcy5jb250YWluZXIuX3BhY2tlZEdldFZhbHVlKCksIE4gPSBnKHYgPDwgdGhpcy5zdGFydCk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5fcGFja2VkU2V0VmFsdWUoZyhQICYgfnRoaXMud29yZE1hc2spIHwgTik7XG4gICAgfVxuICB9XG4gIHJlLkJpdEZpZWxkID0gdztcbiAgY2xhc3MgRCBleHRlbmRzIHcge1xuICAgIGNvbnN0cnVjdG9yKHYsIFApIHtcbiAgICAgIHN1cGVyKHYsIDEsIFApO1xuICAgIH1cbiAgICAvKiogT3ZlcnJpZGUge0BsaW5rIEJpdEZpZWxkI2RlY29kZXxkZWNvZGV9IGZvciB7QGxpbmsgQm9vbGVhbnxCb29sZWFufS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAqL1xuICAgIGRlY29kZSh2LCBQKSB7XG4gICAgICByZXR1cm4gISFzdXBlci5kZWNvZGUodiwgUCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUodikge1xuICAgICAgdHlwZW9mIHYgPT0gXCJib29sZWFuXCIgJiYgKHYgPSArdiksIHN1cGVyLmVuY29kZSh2KTtcbiAgICB9XG4gIH1cbiAgcmUuQm9vbGVhbiA9IEQ7XG4gIGNsYXNzIE8gZXh0ZW5kcyByIHtcbiAgICBjb25zdHJ1Y3Rvcih2LCBQKSB7XG4gICAgICBpZiAoISh2IGluc3RhbmNlb2YgbyAmJiB2LmlzQ291bnQoKSB8fCBOdW1iZXIuaXNJbnRlZ2VyKHYpICYmIDAgPD0gdikpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsZW5ndGggbXVzdCBiZSBwb3NpdGl2ZSBpbnRlZ2VyIG9yIGFuIHVuc2lnbmVkIGludGVnZXIgRXh0ZXJuYWxMYXlvdXRcIik7XG4gICAgICBsZXQgTiA9IC0xO1xuICAgICAgdiBpbnN0YW5jZW9mIG8gfHwgKE4gPSB2KSwgc3VwZXIoTiwgUCksIHRoaXMubGVuZ3RoID0gdjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4odiwgUCkge1xuICAgICAgbGV0IE4gPSB0aGlzLnNwYW47XG4gICAgICByZXR1cm4gMCA+IE4gJiYgKE4gPSB0aGlzLmxlbmd0aC5kZWNvZGUodiwgUCkpLCBOO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKHYsIFAgPSAwKSB7XG4gICAgICBsZXQgTiA9IHRoaXMuc3BhbjtcbiAgICAgIHJldHVybiAwID4gTiAmJiAoTiA9IHRoaXMubGVuZ3RoLmRlY29kZSh2LCBQKSksIHQodikuc2xpY2UoUCwgUCArIE4pO1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBCbG9ifS5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIElmIHtAbGluayBMYXlvdXQjY291bnR8Y291bnR9IGlzIGFuIGluc3RhbmNlIG9mIHtAbGlua1xuICAgICAqIEV4dGVybmFsTGF5b3V0fSB0aGVuIHRoZSBsZW5ndGggb2YgYHNyY2Agd2lsbCBiZSBlbmNvZGVkIGFzIHRoZVxuICAgICAqIGNvdW50IGFmdGVyIGBzcmNgIGlzIGVuY29kZWQuICovXG4gICAgZW5jb2RlKHYsIFAsIE4pIHtcbiAgICAgIGxldCBZID0gdGhpcy5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5sZW5ndGggaW5zdGFuY2VvZiBvICYmIChZID0gdi5sZW5ndGgpLCAhKHYgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIFkgPT09IHYubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihuKFwiQmxvYi5lbmNvZGVcIiwgdGhpcykgKyBcIiByZXF1aXJlcyAobGVuZ3RoIFwiICsgWSArIFwiKSBVaW50OEFycmF5IGFzIHNyY1wiKTtcbiAgICAgIGlmIChOICsgWSA+IFAubGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImVuY29kaW5nIG92ZXJydW5zIFVpbnQ4QXJyYXlcIik7XG4gICAgICBjb25zdCBlZSA9IHQodik7XG4gICAgICByZXR1cm4gdChQKS53cml0ZShlZS50b1N0cmluZyhcImhleFwiKSwgTiwgWSwgXCJoZXhcIiksIHRoaXMubGVuZ3RoIGluc3RhbmNlb2YgbyAmJiB0aGlzLmxlbmd0aC5lbmNvZGUoWSwgUCwgTiksIFk7XG4gICAgfVxuICB9XG4gIHJlLkJsb2IgPSBPO1xuICBjbGFzcyBVIGV4dGVuZHMgciB7XG4gICAgY29uc3RydWN0b3Iodikge1xuICAgICAgc3VwZXIoLTEsIHYpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3Bhbih2LCBQID0gMCkge1xuICAgICAgZSh2KTtcbiAgICAgIGxldCBOID0gUDtcbiAgICAgIGZvciAoOyBOIDwgdi5sZW5ndGggJiYgdltOXSAhPT0gMDsgKVxuICAgICAgICBOICs9IDE7XG4gICAgICByZXR1cm4gMSArIE4gLSBQO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKHYsIFAgPSAwKSB7XG4gICAgICBjb25zdCBOID0gdGhpcy5nZXRTcGFuKHYsIFApO1xuICAgICAgcmV0dXJuIHQodikuc2xpY2UoUCwgUCArIE4gLSAxKS50b1N0cmluZyhcInV0Zi04XCIpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHYsIFAsIE4gPSAwKSB7XG4gICAgICB0eXBlb2YgdiAhPSBcInN0cmluZ1wiICYmICh2ID0gU3RyaW5nKHYpKTtcbiAgICAgIGNvbnN0IFkgPSBzLkJ1ZmZlci5mcm9tKHYsIFwidXRmOFwiKSwgZWUgPSBZLmxlbmd0aDtcbiAgICAgIGlmIChOICsgZWUgPiBQLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJlbmNvZGluZyBvdmVycnVucyBCdWZmZXJcIik7XG4gICAgICBjb25zdCBpZSA9IHQoUCk7XG4gICAgICByZXR1cm4gWS5jb3B5KGllLCBOKSwgaWVbTiArIGVlXSA9IDAsIGVlICsgMTtcbiAgICB9XG4gIH1cbiAgcmUuQ1N0cmluZyA9IFU7XG4gIGNsYXNzIFYgZXh0ZW5kcyByIHtcbiAgICBjb25zdHJ1Y3Rvcih2LCBQKSB7XG4gICAgICBpZiAodHlwZW9mIHYgPT0gXCJzdHJpbmdcIiAmJiBQID09PSB2b2lkIDAgJiYgKFAgPSB2LCB2ID0gdm9pZCAwKSwgdiA9PT0gdm9pZCAwKVxuICAgICAgICB2ID0gLTE7XG4gICAgICBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcih2KSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIm1heFNwYW4gbXVzdCBiZSBhbiBpbnRlZ2VyXCIpO1xuICAgICAgc3VwZXIoLTEsIFApLCB0aGlzLm1heFNwYW4gPSB2O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3Bhbih2LCBQID0gMCkge1xuICAgICAgcmV0dXJuIGUodiksIHYubGVuZ3RoIC0gUDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZSh2LCBQID0gMCkge1xuICAgICAgY29uc3QgTiA9IHRoaXMuZ2V0U3Bhbih2LCBQKTtcbiAgICAgIGlmICgwIDw9IHRoaXMubWF4U3BhbiAmJiB0aGlzLm1heFNwYW4gPCBOKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInRleHQgbGVuZ3RoIGV4Y2VlZHMgbWF4U3BhblwiKTtcbiAgICAgIHJldHVybiB0KHYpLnNsaWNlKFAsIFAgKyBOKS50b1N0cmluZyhcInV0Zi04XCIpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHYsIFAsIE4gPSAwKSB7XG4gICAgICB0eXBlb2YgdiAhPSBcInN0cmluZ1wiICYmICh2ID0gU3RyaW5nKHYpKTtcbiAgICAgIGNvbnN0IFkgPSBzLkJ1ZmZlci5mcm9tKHYsIFwidXRmOFwiKSwgZWUgPSBZLmxlbmd0aDtcbiAgICAgIGlmICgwIDw9IHRoaXMubWF4U3BhbiAmJiB0aGlzLm1heFNwYW4gPCBlZSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0ZXh0IGxlbmd0aCBleGNlZWRzIG1heFNwYW5cIik7XG4gICAgICBpZiAoTiArIGVlID4gUC5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiZW5jb2Rpbmcgb3ZlcnJ1bnMgQnVmZmVyXCIpO1xuICAgICAgcmV0dXJuIFkuY29weSh0KFApLCBOKSwgZWU7XG4gICAgfVxuICB9XG4gIHJlLlVURjggPSBWO1xuICBjbGFzcyBMIGV4dGVuZHMgciB7XG4gICAgY29uc3RydWN0b3IodiwgUCkge1xuICAgICAgc3VwZXIoMCwgUCksIHRoaXMudmFsdWUgPSB2O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKHYsIFApIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHYsIFAsIE4pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmUuQ29uc3RhbnQgPSBMLCByZS5ncmVlZHkgPSAoKG0sIHYpID0+IG5ldyBhKG0sIHYpKSwgcmUub2Zmc2V0ID0gKChtLCB2LCBQKSA9PiBuZXcgbChtLCB2LCBQKSksIHJlLnU4ID0gKChtKSA9PiBuZXcgYygxLCBtKSksIHJlLnUxNiA9ICgobSkgPT4gbmV3IGMoMiwgbSkpLCByZS51MjQgPSAoKG0pID0+IG5ldyBjKDMsIG0pKSwgcmUudTMyID0gKChtKSA9PiBuZXcgYyg0LCBtKSksIHJlLnU0MCA9ICgobSkgPT4gbmV3IGMoNSwgbSkpLCByZS51NDggPSAoKG0pID0+IG5ldyBjKDYsIG0pKSwgcmUubnU2NCA9ICgobSkgPT4gbmV3IEUobSkpLCByZS51MTZiZSA9ICgobSkgPT4gbmV3IHUoMiwgbSkpLCByZS51MjRiZSA9ICgobSkgPT4gbmV3IHUoMywgbSkpLCByZS51MzJiZSA9ICgobSkgPT4gbmV3IHUoNCwgbSkpLCByZS51NDBiZSA9ICgobSkgPT4gbmV3IHUoNSwgbSkpLCByZS51NDhiZSA9ICgobSkgPT4gbmV3IHUoNiwgbSkpLCByZS5udTY0YmUgPSAoKG0pID0+IG5ldyBiKG0pKSwgcmUuczggPSAoKG0pID0+IG5ldyBkKDEsIG0pKSwgcmUuczE2ID0gKChtKSA9PiBuZXcgZCgyLCBtKSksIHJlLnMyNCA9ICgobSkgPT4gbmV3IGQoMywgbSkpLCByZS5zMzIgPSAoKG0pID0+IG5ldyBkKDQsIG0pKSwgcmUuczQwID0gKChtKSA9PiBuZXcgZCg1LCBtKSksIHJlLnM0OCA9ICgobSkgPT4gbmV3IGQoNiwgbSkpLCByZS5uczY0ID0gKChtKSA9PiBuZXcgUihtKSksIHJlLnMxNmJlID0gKChtKSA9PiBuZXcgaCgyLCBtKSksIHJlLnMyNGJlID0gKChtKSA9PiBuZXcgaCgzLCBtKSksIHJlLnMzMmJlID0gKChtKSA9PiBuZXcgaCg0LCBtKSksIHJlLnM0MGJlID0gKChtKSA9PiBuZXcgaCg1LCBtKSksIHJlLnM0OGJlID0gKChtKSA9PiBuZXcgaCg2LCBtKSksIHJlLm5zNjRiZSA9ICgobSkgPT4gbmV3IEEobSkpLCByZS5mMzIgPSAoKG0pID0+IG5ldyBGKG0pKSwgcmUuZjMyYmUgPSAoKG0pID0+IG5ldyBNKG0pKSwgcmUuZjY0ID0gKChtKSA9PiBuZXcgSChtKSksIHJlLmY2NGJlID0gKChtKSA9PiBuZXcgSyhtKSksIHJlLnN0cnVjdCA9ICgobSwgdiwgUCkgPT4gbmV3IEMobSwgdiwgUCkpLCByZS5iaXRzID0gKChtLCB2LCBQKSA9PiBuZXcgeChtLCB2LCBQKSksIHJlLnNlcSA9ICgobSwgdiwgUCkgPT4gbmV3IGoobSwgdiwgUCkpLCByZS51bmlvbiA9ICgobSwgdiwgUCkgPT4gbmV3IFcobSwgdiwgUCkpLCByZS51bmlvbkxheW91dERpc2NyaW1pbmF0b3IgPSAoKG0sIHYpID0+IG5ldyAkKG0sIHYpKSwgcmUuYmxvYiA9ICgobSwgdikgPT4gbmV3IE8obSwgdikpLCByZS5jc3RyID0gKChtKSA9PiBuZXcgVShtKSksIHJlLnV0ZjggPSAoKG0sIHYpID0+IG5ldyBWKG0sIHYpKSwgcmUuY29uc3RhbnQgPSAoKG0sIHYpID0+IG5ldyBMKG0sIHYpKSwgcmU7XG59XG52YXIgeiA9IFd5KCksIHp5ID0gODA3OGUzLCBZeSA9IDgwNzgwMDEsIFp5ID0gODA3ODAwNCwgWHkgPSA4MDc4MDA1LCBKeSA9IDgwNzgwMDYsIFF5ID0gODA3ODAxMTtcbmZ1bmN0aW9uIHgwKHMpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkocykgPyBcIiU1QlwiICsgcy5tYXAoeDApLmpvaW4oXG4gICAgXCIlMkMlMjBcIlxuICAgIC8qIFwiLCBcIiAqL1xuICApICsgLyogXCJdXCIgKi9cbiAgXCIlNURcIiA6IHR5cGVvZiBzID09IFwiYmlnaW50XCIgPyBgJHtzfW5gIDogZW5jb2RlVVJJQ29tcG9uZW50KFxuICAgIFN0cmluZyhcbiAgICAgIHMgIT0gbnVsbCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YocykgPT09IG51bGwgPyAoXG4gICAgICAgIC8vIFBsYWluIG9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgZG9uJ3QgaGF2ZSBhIGB0b1N0cmluZ2AgbWV0aG9kLlxuICAgICAgICAvLyBDb252ZXJ0IHRoZW0gYmVmb3JlIHN0cmluZ2lmeWluZyB0aGVtLlxuICAgICAgICB7IC4uLnMgfVxuICAgICAgKSA6IHNcbiAgICApXG4gICk7XG59XG5mdW5jdGlvbiBldihbcywgZV0pIHtcbiAgcmV0dXJuIGAke3N9PSR7eDAoZSl9YDtcbn1cbmZ1bmN0aW9uIHR2KHMpIHtcbiAgY29uc3QgZSA9IE9iamVjdC5lbnRyaWVzKHMpLm1hcChldikuam9pbihcIiZcIik7XG4gIHJldHVybiBidG9hKGUpO1xufVxuZnVuY3Rpb24gcnYocywgZSA9IHt9KSB7XG4gIHtcbiAgICBsZXQgdCA9IGBTb2xhbmEgZXJyb3IgIyR7c307IERlY29kZSB0aGlzIGVycm9yIGJ5IHJ1bm5pbmcgXFxgbnB4IEBzb2xhbmEvZXJyb3JzIGRlY29kZSAtLSAke3N9YDtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoZSkubGVuZ3RoICYmICh0ICs9IGAgJyR7dHYoZSl9J2ApLCBgJHt0fVxcYGA7XG4gIH1cbn1cbnZhciBibiA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciguLi5bZSwgdF0pIHtcbiAgICBsZXQgciwgbjtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgeyBjYXVzZTogbywgLi4uYSB9ID0gdDtcbiAgICAgIG8gJiYgKG4gPSB7IGNhdXNlOiBvIH0pLCBPYmplY3Qua2V5cyhhKS5sZW5ndGggPiAwICYmIChyID0gYSk7XG4gICAgfVxuICAgIGNvbnN0IGkgPSBydihlLCByKTtcbiAgICBzdXBlcihpLCBuKTtcbiAgICAvKipcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIHJvb3QgY2F1c2Ugb2YgdGhpcyB7QGxpbmsgU29sYW5hRXJyb3J9LCBpZiBhbnkuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgYSB0cmFuc2FjdGlvbiBlcnJvciBtaWdodCBoYXZlIGFuIGluc3RydWN0aW9uIGVycm9yIGFzIGl0cyByb290IGNhdXNlLiBJbiB0aGlzXG4gICAgICogY2FzZSwgeW91IHdpbGwgYmUgYWJsZSB0byBhY2Nlc3MgdGhlIGluc3RydWN0aW9uIGVycm9yIG9uIHRoZSB0cmFuc2FjdGlvbiBlcnJvciBhcyBgY2F1c2VgLlxuICAgICAqL1xuICAgIENyKHRoaXMsIFwiY2F1c2VcIiwgdGhpcy5jYXVzZSk7XG4gICAgLyoqXG4gICAgICogQ29udGFpbnMgY29udGV4dCB0aGF0IGNhbiBhc3Npc3QgaW4gdW5kZXJzdGFuZGluZyBvciByZWNvdmVyaW5nIGZyb20gYSB7QGxpbmsgU29sYW5hRXJyb3J9LlxuICAgICAqL1xuICAgIENyKHRoaXMsIFwiY29udGV4dFwiKTtcbiAgICB0aGlzLmNvbnRleHQgPSB7XG4gICAgICBfX2NvZGU6IGUsXG4gICAgICAuLi5yXG4gICAgfSwgdGhpcy5uYW1lID0gXCJTb2xhbmFFcnJvclwiO1xuICB9XG59O1xuZnVuY3Rpb24gc3YocywgZSkge1xuICByZXR1cm4gXCJmaXhlZFNpemVcIiBpbiBlID8gZS5maXhlZFNpemUgOiBlLmdldFNpemVGcm9tVmFsdWUocyk7XG59XG5mdW5jdGlvbiBudihzKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAuLi5zLFxuICAgIGVuY29kZTogKGUpID0+IHtcbiAgICAgIGNvbnN0IHQgPSBuZXcgVWludDhBcnJheShzdihlLCBzKSk7XG4gICAgICByZXR1cm4gcy53cml0ZShlLCB0LCAwKSwgdDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaXYocykge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4ucyxcbiAgICBkZWNvZGU6IChlLCB0ID0gMCkgPT4gcy5yZWFkKGUsIHQpWzBdXG4gIH0pO1xufVxuZnVuY3Rpb24gZG4ocykge1xuICByZXR1cm4gXCJmaXhlZFNpemVcIiBpbiBzICYmIHR5cGVvZiBzLmZpeGVkU2l6ZSA9PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gb3YocywgZSkge1xuICBpZiAoZG4ocykgIT09IGRuKGUpKVxuICAgIHRocm93IG5ldyBibihaeSk7XG4gIGlmIChkbihzKSAmJiBkbihlKSAmJiBzLmZpeGVkU2l6ZSAhPT0gZS5maXhlZFNpemUpXG4gICAgdGhyb3cgbmV3IGJuKFh5LCB7XG4gICAgICBkZWNvZGVyRml4ZWRTaXplOiBlLmZpeGVkU2l6ZSxcbiAgICAgIGVuY29kZXJGaXhlZFNpemU6IHMuZml4ZWRTaXplXG4gICAgfSk7XG4gIGlmICghZG4ocykgJiYgIWRuKGUpICYmIHMubWF4U2l6ZSAhPT0gZS5tYXhTaXplKVxuICAgIHRocm93IG5ldyBibihKeSwge1xuICAgICAgZGVjb2Rlck1heFNpemU6IGUubWF4U2l6ZSxcbiAgICAgIGVuY29kZXJNYXhTaXplOiBzLm1heFNpemVcbiAgICB9KTtcbiAgcmV0dXJuIHtcbiAgICAuLi5lLFxuICAgIC4uLnMsXG4gICAgZGVjb2RlOiBlLmRlY29kZSxcbiAgICBlbmNvZGU6IHMuZW5jb2RlLFxuICAgIHJlYWQ6IGUucmVhZCxcbiAgICB3cml0ZTogcy53cml0ZVxuICB9O1xufVxuZnVuY3Rpb24gYXYocywgZSwgdCA9IDApIHtcbiAgaWYgKGUubGVuZ3RoIC0gdCA8PSAwKVxuICAgIHRocm93IG5ldyBibih6eSwge1xuICAgICAgY29kZWNEZXNjcmlwdGlvbjogc1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbHYocywgZSwgdCwgciA9IDApIHtcbiAgY29uc3QgbiA9IHQubGVuZ3RoIC0gcjtcbiAgaWYgKG4gPCBlKVxuICAgIHRocm93IG5ldyBibihZeSwge1xuICAgICAgYnl0ZXNMZW5ndGg6IG4sXG4gICAgICBjb2RlY0Rlc2NyaXB0aW9uOiBzLFxuICAgICAgZXhwZWN0ZWQ6IGVcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGN2KHMsIGUsIHQsIHIpIHtcbiAgaWYgKHIgPCBlIHx8IHIgPiB0KVxuICAgIHRocm93IG5ldyBibihReSwge1xuICAgICAgY29kZWNEZXNjcmlwdGlvbjogcyxcbiAgICAgIG1heDogdCxcbiAgICAgIG1pbjogZSxcbiAgICAgIHZhbHVlOiByXG4gICAgfSk7XG59XG5mdW5jdGlvbiBTMChzKSB7XG4gIHJldHVybiAocyA9PSBudWxsID8gdm9pZCAwIDogcy5lbmRpYW4pICE9PSAxO1xufVxuZnVuY3Rpb24gdXYocykge1xuICByZXR1cm4gbnYoe1xuICAgIGZpeGVkU2l6ZTogcy5zaXplLFxuICAgIHdyaXRlKGUsIHQsIHIpIHtcbiAgICAgIHMucmFuZ2UgJiYgY3Yocy5uYW1lLCBzLnJhbmdlWzBdLCBzLnJhbmdlWzFdLCBlKTtcbiAgICAgIGNvbnN0IG4gPSBuZXcgQXJyYXlCdWZmZXIocy5zaXplKTtcbiAgICAgIHJldHVybiBzLnNldChuZXcgRGF0YVZpZXcobiksIGUsIFMwKHMuY29uZmlnKSksIHQuc2V0KG5ldyBVaW50OEFycmF5KG4pLCByKSwgciArIHMuc2l6ZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZHYocykge1xuICByZXR1cm4gaXYoe1xuICAgIGZpeGVkU2l6ZTogcy5zaXplLFxuICAgIHJlYWQoZSwgdCA9IDApIHtcbiAgICAgIGF2KHMubmFtZSwgZSwgdCksIGx2KHMubmFtZSwgcy5zaXplLCBlLCB0KTtcbiAgICAgIGNvbnN0IHIgPSBuZXcgRGF0YVZpZXcoaHYoZSwgdCwgcy5zaXplKSk7XG4gICAgICByZXR1cm4gW3MuZ2V0KHIsIFMwKHMuY29uZmlnKSksIHQgKyBzLnNpemVdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBodihzLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSBzLmJ5dGVPZmZzZXQgKyAoZSA/PyAwKSwgbiA9IHQgPz8gcy5ieXRlTGVuZ3RoO1xuICByZXR1cm4gcy5idWZmZXIuc2xpY2UociwgciArIG4pO1xufVxudmFyIGZ2ID0gKHMgPSB7fSkgPT4gdXYoe1xuICBjb25maWc6IHMsXG4gIG5hbWU6IFwidTY0XCIsXG4gIHJhbmdlOiBbMG4sIEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZlwiKV0sXG4gIHNldDogKGUsIHQsIHIpID0+IGUuc2V0QmlnVWludDY0KDAsIEJpZ0ludCh0KSwgciksXG4gIHNpemU6IDhcbn0pLCBndiA9IChzID0ge30pID0+IGR2KHtcbiAgY29uZmlnOiBzLFxuICBnZXQ6IChlLCB0KSA9PiBlLmdldEJpZ1VpbnQ2NCgwLCB0KSxcbiAgbmFtZTogXCJ1NjRcIixcbiAgc2l6ZTogOFxufSksIHB2ID0gKHMgPSB7fSkgPT4gb3YoZnYocyksIGd2KHMpKTtcbmNsYXNzIG12IGV4dGVuZHMgVHlwZUVycm9yIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIGxldCByO1xuICAgIGNvbnN0IHsgbWVzc2FnZTogbiwgZXhwbGFuYXRpb246IGksIC4uLm8gfSA9IGUsIHsgcGF0aDogYSB9ID0gZSwgbCA9IGEubGVuZ3RoID09PSAwID8gbiA6IGBBdCBwYXRoOiAke2Euam9pbihcIi5cIil9IC0tICR7bn1gO1xuICAgIHN1cGVyKGkgPz8gbCksIGkgIT0gbnVsbCAmJiAodGhpcy5jYXVzZSA9IGwpLCBPYmplY3QuYXNzaWduKHRoaXMsIG8pLCB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWUsIHRoaXMuZmFpbHVyZXMgPSAoKSA9PiByID8/IChyID0gW2UsIC4uLnQoKV0pO1xuICB9XG59XG5mdW5jdGlvbiB5dihzKSB7XG4gIHJldHVybiBDaShzKSAmJiB0eXBlb2Ygc1tTeW1ib2wuaXRlcmF0b3JdID09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIENpKHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBzID09IFwib2JqZWN0XCIgJiYgcyAhPSBudWxsO1xufVxuZnVuY3Rpb24gJG8ocykge1xuICByZXR1cm4gQ2kocykgJiYgIUFycmF5LmlzQXJyYXkocyk7XG59XG5mdW5jdGlvbiBCcihzKSB7XG4gIHJldHVybiB0eXBlb2YgcyA9PSBcInN5bWJvbFwiID8gcy50b1N0cmluZygpIDogdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiA/IEpTT04uc3RyaW5naWZ5KHMpIDogYCR7c31gO1xufVxuZnVuY3Rpb24gdnYocykge1xuICBjb25zdCB7IGRvbmU6IGUsIHZhbHVlOiB0IH0gPSBzLm5leHQoKTtcbiAgcmV0dXJuIGUgPyB2b2lkIDAgOiB0O1xufVxuZnVuY3Rpb24gRXYocywgZSwgdCwgcikge1xuICBpZiAocyA9PT0gITApXG4gICAgcmV0dXJuO1xuICBzID09PSAhMSA/IHMgPSB7fSA6IHR5cGVvZiBzID09IFwic3RyaW5nXCIgJiYgKHMgPSB7IG1lc3NhZ2U6IHMgfSk7XG4gIGNvbnN0IHsgcGF0aDogbiwgYnJhbmNoOiBpIH0gPSBlLCB7IHR5cGU6IG8gfSA9IHQsIHsgcmVmaW5lbWVudDogYSwgbWVzc2FnZTogbCA9IGBFeHBlY3RlZCBhIHZhbHVlIG9mIHR5cGUgXFxgJHtvfVxcYCR7YSA/IGAgd2l0aCByZWZpbmVtZW50IFxcYCR7YX1cXGBgIDogXCJcIn0sIGJ1dCByZWNlaXZlZDogXFxgJHtCcihyKX1cXGBgIH0gPSBzO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiByLFxuICAgIHR5cGU6IG8sXG4gICAgcmVmaW5lbWVudDogYSxcbiAgICBrZXk6IG5bbi5sZW5ndGggLSAxXSxcbiAgICBwYXRoOiBuLFxuICAgIGJyYW5jaDogaSxcbiAgICAuLi5zLFxuICAgIG1lc3NhZ2U6IGxcbiAgfTtcbn1cbmZ1bmN0aW9uKiBDZChzLCBlLCB0LCByKSB7XG4gIHl2KHMpIHx8IChzID0gW3NdKTtcbiAgZm9yIChjb25zdCBuIG9mIHMpIHtcbiAgICBjb25zdCBpID0gRXYobiwgZSwgdCwgcik7XG4gICAgaSAmJiAoeWllbGQgaSk7XG4gIH1cbn1cbmZ1bmN0aW9uKiBKYyhzLCBlLCB0ID0ge30pIHtcbiAgY29uc3QgeyBwYXRoOiByID0gW10sIGJyYW5jaDogbiA9IFtzXSwgY29lcmNlOiBpID0gITEsIG1hc2s6IG8gPSAhMSB9ID0gdCwgYSA9IHsgcGF0aDogciwgYnJhbmNoOiBuLCBtYXNrOiBvIH07XG4gIGkgJiYgKHMgPSBlLmNvZXJjZXIocywgYSkpO1xuICBsZXQgbCA9IFwidmFsaWRcIjtcbiAgZm9yIChjb25zdCBjIG9mIGUudmFsaWRhdG9yKHMsIGEpKVxuICAgIGMuZXhwbGFuYXRpb24gPSB0Lm1lc3NhZ2UsIGwgPSBcIm5vdF92YWxpZFwiLCB5aWVsZCBbYywgdm9pZCAwXTtcbiAgZm9yIChsZXQgW2MsIHUsIGRdIG9mIGUuZW50cmllcyhzLCBhKSkge1xuICAgIGNvbnN0IGggPSBKYyh1LCBkLCB7XG4gICAgICBwYXRoOiBjID09PSB2b2lkIDAgPyByIDogWy4uLnIsIGNdLFxuICAgICAgYnJhbmNoOiBjID09PSB2b2lkIDAgPyBuIDogWy4uLm4sIHVdLFxuICAgICAgY29lcmNlOiBpLFxuICAgICAgbWFzazogbyxcbiAgICAgIG1lc3NhZ2U6IHQubWVzc2FnZVxuICAgIH0pO1xuICAgIGZvciAoY29uc3QgZiBvZiBoKVxuICAgICAgZlswXSA/IChsID0gZlswXS5yZWZpbmVtZW50ICE9IG51bGwgPyBcIm5vdF9yZWZpbmVkXCIgOiBcIm5vdF92YWxpZFwiLCB5aWVsZCBbZlswXSwgdm9pZCAwXSkgOiBpICYmICh1ID0gZlsxXSwgYyA9PT0gdm9pZCAwID8gcyA9IHUgOiBzIGluc3RhbmNlb2YgTWFwID8gcy5zZXQoYywgdSkgOiBzIGluc3RhbmNlb2YgU2V0ID8gcy5hZGQodSkgOiBDaShzKSAmJiAodSAhPT0gdm9pZCAwIHx8IGMgaW4gcykgJiYgKHNbY10gPSB1KSk7XG4gIH1cbiAgaWYgKGwgIT09IFwibm90X3ZhbGlkXCIpXG4gICAgZm9yIChjb25zdCBjIG9mIGUucmVmaW5lcihzLCBhKSlcbiAgICAgIGMuZXhwbGFuYXRpb24gPSB0Lm1lc3NhZ2UsIGwgPSBcIm5vdF9yZWZpbmVkXCIsIHlpZWxkIFtjLCB2b2lkIDBdO1xuICBsID09PSBcInZhbGlkXCIgJiYgKHlpZWxkIFt2b2lkIDAsIHNdKTtcbn1cbmxldCBlcyA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGNvbnN0IHsgdHlwZTogdCwgc2NoZW1hOiByLCB2YWxpZGF0b3I6IG4sIHJlZmluZXI6IGksIGNvZXJjZXI6IG8gPSAobCkgPT4gbCwgZW50cmllczogYSA9IGZ1bmN0aW9uKiAoKSB7XG4gICAgfSB9ID0gZTtcbiAgICB0aGlzLnR5cGUgPSB0LCB0aGlzLnNjaGVtYSA9IHIsIHRoaXMuZW50cmllcyA9IGEsIHRoaXMuY29lcmNlciA9IG8sIG4gPyB0aGlzLnZhbGlkYXRvciA9IChsLCBjKSA9PiB7XG4gICAgICBjb25zdCB1ID0gbihsLCBjKTtcbiAgICAgIHJldHVybiBDZCh1LCBjLCB0aGlzLCBsKTtcbiAgICB9IDogdGhpcy52YWxpZGF0b3IgPSAoKSA9PiBbXSwgaSA/IHRoaXMucmVmaW5lciA9IChsLCBjKSA9PiB7XG4gICAgICBjb25zdCB1ID0gaShsLCBjKTtcbiAgICAgIHJldHVybiBDZCh1LCBjLCB0aGlzLCBsKTtcbiAgICB9IDogdGhpcy5yZWZpbmVyID0gKCkgPT4gW107XG4gIH1cbiAgLyoqXG4gICAqIEFzc2VydCB0aGF0IGEgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uLCB0aHJvd2luZyBpZiBpdCBkb2Vzbid0LlxuICAgKi9cbiAgYXNzZXJ0KGUsIHQpIHtcbiAgICByZXR1cm4geHYoZSwgdGhpcywgdCk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIGNvZXJjaW9uIGxvZ2ljLCB0aGVuIHZhbGlkYXRlIGl0LlxuICAgKi9cbiAgY3JlYXRlKGUsIHQpIHtcbiAgICByZXR1cm4gdGkoZSwgdGhpcywgdCk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uLlxuICAgKi9cbiAgaXMoZSkge1xuICAgIHJldHVybiBiMChlLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogTWFzayBhIHZhbHVlLCBjb2VyY2luZyBhbmQgdmFsaWRhdGluZyBpdCwgYnV0IHJldHVybmluZyBvbmx5IHRoZSBzdWJzZXQgb2ZcbiAgICogcHJvcGVydGllcyBkZWZpbmVkIGJ5IHRoZSBzdHJ1Y3QncyBzY2hlbWEuIE1hc2tpbmcgYXBwbGllcyByZWN1cnNpdmVseSB0b1xuICAgKiBwcm9wcyBvZiBgb2JqZWN0YCBzdHJ1Y3RzIG9ubHkuXG4gICAqL1xuICBtYXNrKGUsIHQpIHtcbiAgICByZXR1cm4gU3YoZSwgdGhpcywgdCk7XG4gIH1cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGEgdmFsdWUgd2l0aCB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbiBsb2dpYywgcmV0dXJuaW5nIGEgdHVwbGVcbiAgICogcmVwcmVzZW50aW5nIHRoZSByZXN1bHQuXG4gICAqXG4gICAqIFlvdSBtYXkgb3B0aW9uYWxseSBwYXNzIGB0cnVlYCBmb3IgdGhlIGBjb2VyY2VgIGFyZ3VtZW50IHRvIGNvZXJjZVxuICAgKiB0aGUgdmFsdWUgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdmFsaWRhdGUgaXQuIElmIHlvdSBkbywgdGhlIHJlc3VsdCB3aWxsXG4gICAqIGNvbnRhaW4gdGhlIGNvZXJjZWQgcmVzdWx0IHdoZW4gc3VjY2Vzc2Z1bC4gQWxzbywgYG1hc2tgIHdpbGwgdHVybiBvblxuICAgKiBtYXNraW5nIG9mIHRoZSB1bmtub3duIGBvYmplY3RgIHByb3BzIHJlY3Vyc2l2ZWx5IGlmIHBhc3NlZC5cbiAgICovXG4gIHZhbGlkYXRlKGUsIHQgPSB7fSkge1xuICAgIHJldHVybiBraShlLCB0aGlzLCB0KTtcbiAgfVxufTtcbmZ1bmN0aW9uIHh2KHMsIGUsIHQpIHtcbiAgY29uc3QgciA9IGtpKHMsIGUsIHsgbWVzc2FnZTogdCB9KTtcbiAgaWYgKHJbMF0pXG4gICAgdGhyb3cgclswXTtcbn1cbmZ1bmN0aW9uIHRpKHMsIGUsIHQpIHtcbiAgY29uc3QgciA9IGtpKHMsIGUsIHsgY29lcmNlOiAhMCwgbWVzc2FnZTogdCB9KTtcbiAgaWYgKHJbMF0pXG4gICAgdGhyb3cgclswXTtcbiAgcmV0dXJuIHJbMV07XG59XG5mdW5jdGlvbiBTdihzLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSBraShzLCBlLCB7IGNvZXJjZTogITAsIG1hc2s6ICEwLCBtZXNzYWdlOiB0IH0pO1xuICBpZiAoclswXSlcbiAgICB0aHJvdyByWzBdO1xuICByZXR1cm4gclsxXTtcbn1cbmZ1bmN0aW9uIGIwKHMsIGUpIHtcbiAgcmV0dXJuICFraShzLCBlKVswXTtcbn1cbmZ1bmN0aW9uIGtpKHMsIGUsIHQgPSB7fSkge1xuICBjb25zdCByID0gSmMocywgZSwgdCksIG4gPSB2dihyKTtcbiAgcmV0dXJuIG5bMF0gPyBbbmV3IG12KG5bMF0sIGZ1bmN0aW9uKiAoKSB7XG4gICAgZm9yIChjb25zdCBvIG9mIHIpXG4gICAgICBvWzBdICYmICh5aWVsZCBvWzBdKTtcbiAgfSksIHZvaWQgMF0gOiBbdm9pZCAwLCBuWzFdXTtcbn1cbmZ1bmN0aW9uIHRuKHMsIGUpIHtcbiAgcmV0dXJuIG5ldyBlcyh7IHR5cGU6IHMsIHNjaGVtYTogbnVsbCwgdmFsaWRhdG9yOiBlIH0pO1xufVxuZnVuY3Rpb24gYnYoKSB7XG4gIHJldHVybiB0bihcImFueVwiLCAoKSA9PiAhMCk7XG59XG5mdW5jdGlvbiBmZShzKSB7XG4gIHJldHVybiBuZXcgZXMoe1xuICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICBzY2hlbWE6IHMsXG4gICAgKmVudHJpZXMoZSkge1xuICAgICAgaWYgKHMgJiYgQXJyYXkuaXNBcnJheShlKSlcbiAgICAgICAgZm9yIChjb25zdCBbdCwgcl0gb2YgZS5lbnRyaWVzKCkpXG4gICAgICAgICAgeWllbGQgW3QsIHIsIHNdO1xuICAgIH0sXG4gICAgY29lcmNlcihlKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShlKSA/IGUuc2xpY2UoKSA6IGU7XG4gICAgfSxcbiAgICB2YWxpZGF0b3IoZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZSkgfHwgYEV4cGVjdGVkIGFuIGFycmF5IHZhbHVlLCBidXQgcmVjZWl2ZWQ6ICR7QnIoZSl9YDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gWHIoKSB7XG4gIHJldHVybiB0bihcImJvb2xlYW5cIiwgKHMpID0+IHR5cGVvZiBzID09IFwiYm9vbGVhblwiKTtcbn1cbmZ1bmN0aW9uIFFjKHMpIHtcbiAgcmV0dXJuIHRuKFwiaW5zdGFuY2VcIiwgKGUpID0+IGUgaW5zdGFuY2VvZiBzIHx8IGBFeHBlY3RlZCBhIFxcYCR7cy5uYW1lfVxcYCBpbnN0YW5jZSwgYnV0IHJlY2VpdmVkOiAke0JyKGUpfWApO1xufVxuZnVuY3Rpb24gcHQocykge1xuICBjb25zdCBlID0gQnIocyksIHQgPSB0eXBlb2YgcztcbiAgcmV0dXJuIG5ldyBlcyh7XG4gICAgdHlwZTogXCJsaXRlcmFsXCIsXG4gICAgc2NoZW1hOiB0ID09PSBcInN0cmluZ1wiIHx8IHQgPT09IFwibnVtYmVyXCIgfHwgdCA9PT0gXCJib29sZWFuXCIgPyBzIDogbnVsbCxcbiAgICB2YWxpZGF0b3Iocikge1xuICAgICAgcmV0dXJuIHIgPT09IHMgfHwgYEV4cGVjdGVkIHRoZSBsaXRlcmFsIFxcYCR7ZX1cXGAsIGJ1dCByZWNlaXZlZDogJHtCcihyKX1gO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBUdigpIHtcbiAgcmV0dXJuIHRuKFwibmV2ZXJcIiwgKCkgPT4gITEpO1xufVxuZnVuY3Rpb24gZ2Uocykge1xuICByZXR1cm4gbmV3IGVzKHtcbiAgICAuLi5zLFxuICAgIHZhbGlkYXRvcjogKGUsIHQpID0+IGUgPT09IG51bGwgfHwgcy52YWxpZGF0b3IoZSwgdCksXG4gICAgcmVmaW5lcjogKGUsIHQpID0+IGUgPT09IG51bGwgfHwgcy5yZWZpbmVyKGUsIHQpXG4gIH0pO1xufVxuZnVuY3Rpb24gdGUoKSB7XG4gIHJldHVybiB0bihcIm51bWJlclwiLCAocykgPT4gdHlwZW9mIHMgPT0gXCJudW1iZXJcIiAmJiAhaXNOYU4ocykgfHwgYEV4cGVjdGVkIGEgbnVtYmVyLCBidXQgcmVjZWl2ZWQ6ICR7QnIocyl9YCk7XG59XG5mdW5jdGlvbiBTZShzKSB7XG4gIHJldHVybiBuZXcgZXMoe1xuICAgIC4uLnMsXG4gICAgdmFsaWRhdG9yOiAoZSwgdCkgPT4gZSA9PT0gdm9pZCAwIHx8IHMudmFsaWRhdG9yKGUsIHQpLFxuICAgIHJlZmluZXI6IChlLCB0KSA9PiBlID09PSB2b2lkIDAgfHwgcy5yZWZpbmVyKGUsIHQpXG4gIH0pO1xufVxuZnVuY3Rpb24gVDAocywgZSkge1xuICByZXR1cm4gbmV3IGVzKHtcbiAgICB0eXBlOiBcInJlY29yZFwiLFxuICAgIHNjaGVtYTogbnVsbCxcbiAgICAqZW50cmllcyh0KSB7XG4gICAgICBpZiAoQ2kodCkpXG4gICAgICAgIGZvciAoY29uc3QgciBpbiB0KSB7XG4gICAgICAgICAgY29uc3QgbiA9IHRbcl07XG4gICAgICAgICAgeWllbGQgW3IsIHIsIHNdLCB5aWVsZCBbciwgbiwgZV07XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHZhbGlkYXRvcih0KSB7XG4gICAgICByZXR1cm4gJG8odCkgfHwgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke0JyKHQpfWA7XG4gICAgfSxcbiAgICBjb2VyY2VyKHQpIHtcbiAgICAgIHJldHVybiAkbyh0KSA/IHsgLi4udCB9IDogdDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY2UoKSB7XG4gIHJldHVybiB0bihcInN0cmluZ1wiLCAocykgPT4gdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiB8fCBgRXhwZWN0ZWQgYSBzdHJpbmcsIGJ1dCByZWNlaXZlZDogJHtCcihzKX1gKTtcbn1cbmZ1bmN0aW9uIGV1KHMpIHtcbiAgY29uc3QgZSA9IFR2KCk7XG4gIHJldHVybiBuZXcgZXMoe1xuICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICBzY2hlbWE6IG51bGwsXG4gICAgKmVudHJpZXModCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgY29uc3QgciA9IE1hdGgubWF4KHMubGVuZ3RoLCB0Lmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgcjsgbisrKVxuICAgICAgICAgIHlpZWxkIFtuLCB0W25dLCBzW25dIHx8IGVdO1xuICAgICAgfVxuICAgIH0sXG4gICAgdmFsaWRhdG9yKHQpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHQpIHx8IGBFeHBlY3RlZCBhbiBhcnJheSwgYnV0IHJlY2VpdmVkOiAke0JyKHQpfWA7XG4gICAgfSxcbiAgICBjb2VyY2VyKHQpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHQpID8gdC5zbGljZSgpIDogdDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gb2Uocykge1xuICBjb25zdCBlID0gT2JqZWN0LmtleXMocyk7XG4gIHJldHVybiBuZXcgZXMoe1xuICAgIHR5cGU6IFwidHlwZVwiLFxuICAgIHNjaGVtYTogcyxcbiAgICAqZW50cmllcyh0KSB7XG4gICAgICBpZiAoQ2kodCkpXG4gICAgICAgIGZvciAoY29uc3QgciBvZiBlKVxuICAgICAgICAgIHlpZWxkIFtyLCB0W3JdLCBzW3JdXTtcbiAgICB9LFxuICAgIHZhbGlkYXRvcih0KSB7XG4gICAgICByZXR1cm4gJG8odCkgfHwgYEV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiAke0JyKHQpfWA7XG4gICAgfSxcbiAgICBjb2VyY2VyKHQpIHtcbiAgICAgIHJldHVybiAkbyh0KSA/IHsgLi4udCB9IDogdDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdXIocykge1xuICBjb25zdCBlID0gcy5tYXAoKHQpID0+IHQudHlwZSkuam9pbihcIiB8IFwiKTtcbiAgcmV0dXJuIG5ldyBlcyh7XG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIHNjaGVtYTogbnVsbCxcbiAgICBjb2VyY2VyKHQsIHIpIHtcbiAgICAgIGZvciAoY29uc3QgbiBvZiBzKSB7XG4gICAgICAgIGNvbnN0IFtpLCBvXSA9IG4udmFsaWRhdGUodCwge1xuICAgICAgICAgIGNvZXJjZTogITAsXG4gICAgICAgICAgbWFzazogci5tYXNrXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWkpXG4gICAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgICB9LFxuICAgIHZhbGlkYXRvcih0LCByKSB7XG4gICAgICBjb25zdCBuID0gW107XG4gICAgICBmb3IgKGNvbnN0IGkgb2Ygcykge1xuICAgICAgICBjb25zdCBbLi4ub10gPSBKYyh0LCBpLCByKSwgW2FdID0gbztcbiAgICAgICAgaWYgKGFbMF0pXG4gICAgICAgICAgZm9yIChjb25zdCBbbF0gb2YgbylcbiAgICAgICAgICAgIGwgJiYgbi5wdXNoKGwpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgYEV4cGVjdGVkIHRoZSB2YWx1ZSB0byBzYXRpc2Z5IGEgdW5pb24gb2YgXFxgJHtlfVxcYCwgYnV0IHJlY2VpdmVkOiAke0JyKHQpfWAsXG4gICAgICAgIC4uLm5cbiAgICAgIF07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIEduKCkge1xuICByZXR1cm4gdG4oXCJ1bmtub3duXCIsICgpID0+ICEwKTtcbn1cbmZ1bmN0aW9uIERpKHMsIGUsIHQpIHtcbiAgcmV0dXJuIG5ldyBlcyh7XG4gICAgLi4ucyxcbiAgICBjb2VyY2VyOiAociwgbikgPT4gYjAociwgZSkgPyBzLmNvZXJjZXIodChyLCBuKSwgbikgOiBzLmNvZXJjZXIociwgbilcbiAgfSk7XG59XG52YXIgJGksIHd2ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuZnVuY3Rpb24gdzAoKSB7XG4gIGlmICghJGkgJiYgKCRpID0gdHlwZW9mIGNyeXB0byA8IFwidVwiICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykgfHwgdHlwZW9mIG1zQ3J5cHRvIDwgXCJ1XCIgJiYgdHlwZW9mIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSBcImZ1bmN0aW9uXCIgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pLCAhJGkpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImNyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkXCIpO1xuICByZXR1cm4gJGkod3YpO1xufVxuY29uc3QgQXYgPSAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XG5mdW5jdGlvbiB1YShzKSB7XG4gIHJldHVybiB0eXBlb2YgcyA9PSBcInN0cmluZ1wiICYmIEF2LnRlc3Qocyk7XG59XG52YXIgWXQgPSBbXTtcbmZvciAodmFyIFFhID0gMDsgUWEgPCAyNTY7ICsrUWEpXG4gIFl0LnB1c2goKFFhICsgMjU2KS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbmZ1bmN0aW9uIGRhKHMpIHtcbiAgdmFyIGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHZvaWQgMCA/IGFyZ3VtZW50c1sxXSA6IDAsIHQgPSAoWXRbc1tlICsgMF1dICsgWXRbc1tlICsgMV1dICsgWXRbc1tlICsgMl1dICsgWXRbc1tlICsgM11dICsgXCItXCIgKyBZdFtzW2UgKyA0XV0gKyBZdFtzW2UgKyA1XV0gKyBcIi1cIiArIFl0W3NbZSArIDZdXSArIFl0W3NbZSArIDddXSArIFwiLVwiICsgWXRbc1tlICsgOF1dICsgWXRbc1tlICsgOV1dICsgXCItXCIgKyBZdFtzW2UgKyAxMF1dICsgWXRbc1tlICsgMTFdXSArIFl0W3NbZSArIDEyXV0gKyBZdFtzW2UgKyAxM11dICsgWXRbc1tlICsgMTRdXSArIFl0W3NbZSArIDE1XV0pLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghdWEodCkpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkXCIpO1xuICByZXR1cm4gdDtcbn1cbnZhciBrZCwgZWwsIHRsID0gMCwgcmwgPSAwO1xuZnVuY3Rpb24gSXYocywgZSwgdCkge1xuICB2YXIgciA9IGUgJiYgdCB8fCAwLCBuID0gZSB8fCBuZXcgQXJyYXkoMTYpO1xuICBzID0gcyB8fCB7fTtcbiAgdmFyIGkgPSBzLm5vZGUgfHwga2QsIG8gPSBzLmNsb2Nrc2VxICE9PSB2b2lkIDAgPyBzLmNsb2Nrc2VxIDogZWw7XG4gIGlmIChpID09IG51bGwgfHwgbyA9PSBudWxsKSB7XG4gICAgdmFyIGEgPSBzLnJhbmRvbSB8fCAocy5ybmcgfHwgdzApKCk7XG4gICAgaSA9PSBudWxsICYmIChpID0ga2QgPSBbYVswXSB8IDEsIGFbMV0sIGFbMl0sIGFbM10sIGFbNF0sIGFbNV1dKSwgbyA9PSBudWxsICYmIChvID0gZWwgPSAoYVs2XSA8PCA4IHwgYVs3XSkgJiAxNjM4Myk7XG4gIH1cbiAgdmFyIGwgPSBzLm1zZWNzICE9PSB2b2lkIDAgPyBzLm1zZWNzIDogRGF0ZS5ub3coKSwgYyA9IHMubnNlY3MgIT09IHZvaWQgMCA/IHMubnNlY3MgOiBybCArIDEsIHUgPSBsIC0gdGwgKyAoYyAtIHJsKSAvIDFlNDtcbiAgaWYgKHUgPCAwICYmIHMuY2xvY2tzZXEgPT09IHZvaWQgMCAmJiAobyA9IG8gKyAxICYgMTYzODMpLCAodSA8IDAgfHwgbCA+IHRsKSAmJiBzLm5zZWNzID09PSB2b2lkIDAgJiYgKGMgPSAwKSwgYyA+PSAxZTQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXVpZC52MSgpOiBDYW4ndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWNcIik7XG4gIHRsID0gbCwgcmwgPSBjLCBlbCA9IG8sIGwgKz0gMTIyMTkyOTI4ZTU7XG4gIHZhciBkID0gKChsICYgMjY4NDM1NDU1KSAqIDFlNCArIGMpICUgNDI5NDk2NzI5NjtcbiAgbltyKytdID0gZCA+Pj4gMjQgJiAyNTUsIG5bcisrXSA9IGQgPj4+IDE2ICYgMjU1LCBuW3IrK10gPSBkID4+PiA4ICYgMjU1LCBuW3IrK10gPSBkICYgMjU1O1xuICB2YXIgaCA9IGwgLyA0Mjk0OTY3Mjk2ICogMWU0ICYgMjY4NDM1NDU1O1xuICBuW3IrK10gPSBoID4+PiA4ICYgMjU1LCBuW3IrK10gPSBoICYgMjU1LCBuW3IrK10gPSBoID4+PiAyNCAmIDE1IHwgMTYsIG5bcisrXSA9IGggPj4+IDE2ICYgMjU1LCBuW3IrK10gPSBvID4+PiA4IHwgMTI4LCBuW3IrK10gPSBvICYgMjU1O1xuICBmb3IgKHZhciBmID0gMDsgZiA8IDY7ICsrZilcbiAgICBuW3IgKyBmXSA9IGlbZl07XG4gIHJldHVybiBlIHx8IGRhKG4pO1xufVxuZnVuY3Rpb24gQTAocykge1xuICBpZiAoIXVhKHMpKVxuICAgIHRocm93IFR5cGVFcnJvcihcIkludmFsaWQgVVVJRFwiKTtcbiAgdmFyIGUsIHQgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIHJldHVybiB0WzBdID0gKGUgPSBwYXJzZUludChzLnNsaWNlKDAsIDgpLCAxNikpID4+PiAyNCwgdFsxXSA9IGUgPj4+IDE2ICYgMjU1LCB0WzJdID0gZSA+Pj4gOCAmIDI1NSwgdFszXSA9IGUgJiAyNTUsIHRbNF0gPSAoZSA9IHBhcnNlSW50KHMuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4LCB0WzVdID0gZSAmIDI1NSwgdFs2XSA9IChlID0gcGFyc2VJbnQocy5zbGljZSgxNCwgMTgpLCAxNikpID4+PiA4LCB0WzddID0gZSAmIDI1NSwgdFs4XSA9IChlID0gcGFyc2VJbnQocy5zbGljZSgxOSwgMjMpLCAxNikpID4+PiA4LCB0WzldID0gZSAmIDI1NSwgdFsxMF0gPSAoZSA9IHBhcnNlSW50KHMuc2xpY2UoMjQsIDM2KSwgMTYpKSAvIDEwOTk1MTE2Mjc3NzYgJiAyNTUsIHRbMTFdID0gZSAvIDQyOTQ5NjcyOTYgJiAyNTUsIHRbMTJdID0gZSA+Pj4gMjQgJiAyNTUsIHRbMTNdID0gZSA+Pj4gMTYgJiAyNTUsIHRbMTRdID0gZSA+Pj4gOCAmIDI1NSwgdFsxNV0gPSBlICYgMjU1LCB0O1xufVxuZnVuY3Rpb24gX3Yocykge1xuICBzID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHMpKTtcbiAgZm9yICh2YXIgZSA9IFtdLCB0ID0gMDsgdCA8IHMubGVuZ3RoOyArK3QpXG4gICAgZS5wdXNoKHMuY2hhckNvZGVBdCh0KSk7XG4gIHJldHVybiBlO1xufVxudmFyIFJ2ID0gXCI2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzhcIiwgTHYgPSBcIjZiYTdiODExLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOFwiO1xuZnVuY3Rpb24gSTAocywgZSwgdCkge1xuICBmdW5jdGlvbiByKG4sIGksIG8sIGEpIHtcbiAgICBpZiAodHlwZW9mIG4gPT0gXCJzdHJpbmdcIiAmJiAobiA9IF92KG4pKSwgdHlwZW9mIGkgPT0gXCJzdHJpbmdcIiAmJiAoaSA9IEEwKGkpKSwgaS5sZW5ndGggIT09IDE2KVxuICAgICAgdGhyb3cgVHlwZUVycm9yKFwiTmFtZXNwYWNlIG11c3QgYmUgYXJyYXktbGlrZSAoMTYgaXRlcmFibGUgaW50ZWdlciB2YWx1ZXMsIDAtMjU1KVwiKTtcbiAgICB2YXIgbCA9IG5ldyBVaW50OEFycmF5KDE2ICsgbi5sZW5ndGgpO1xuICAgIGlmIChsLnNldChpKSwgbC5zZXQobiwgaS5sZW5ndGgpLCBsID0gdChsKSwgbFs2XSA9IGxbNl0gJiAxNSB8IGUsIGxbOF0gPSBsWzhdICYgNjMgfCAxMjgsIG8pIHtcbiAgICAgIGEgPSBhIHx8IDA7XG4gICAgICBmb3IgKHZhciBjID0gMDsgYyA8IDE2OyArK2MpXG4gICAgICAgIG9bYSArIGNdID0gbFtjXTtcbiAgICAgIHJldHVybiBvO1xuICAgIH1cbiAgICByZXR1cm4gZGEobCk7XG4gIH1cbiAgdHJ5IHtcbiAgICByLm5hbWUgPSBzO1xuICB9IGNhdGNoIHtcbiAgfVxuICByZXR1cm4gci5ETlMgPSBSdiwgci5VUkwgPSBMdiwgcjtcbn1cbmZ1bmN0aW9uIEN2KHMpIHtcbiAgaWYgKHR5cGVvZiBzID09IFwic3RyaW5nXCIpIHtcbiAgICB2YXIgZSA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzKSk7XG4gICAgcyA9IG5ldyBVaW50OEFycmF5KGUubGVuZ3RoKTtcbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IGUubGVuZ3RoOyArK3QpXG4gICAgICBzW3RdID0gZS5jaGFyQ29kZUF0KHQpO1xuICB9XG4gIHJldHVybiBrdihEdihQdihzKSwgcy5sZW5ndGggKiA4KSk7XG59XG5mdW5jdGlvbiBrdihzKSB7XG4gIGZvciAodmFyIGUgPSBbXSwgdCA9IHMubGVuZ3RoICogMzIsIHIgPSBcIjAxMjM0NTY3ODlhYmNkZWZcIiwgbiA9IDA7IG4gPCB0OyBuICs9IDgpIHtcbiAgICB2YXIgaSA9IHNbbiA+PiA1XSA+Pj4gbiAlIDMyICYgMjU1LCBvID0gcGFyc2VJbnQoci5jaGFyQXQoaSA+Pj4gNCAmIDE1KSArIHIuY2hhckF0KGkgJiAxNSksIDE2KTtcbiAgICBlLnB1c2gobyk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBfMChzKSB7XG4gIHJldHVybiAocyArIDY0ID4+PiA5IDw8IDQpICsgMTQgKyAxO1xufVxuZnVuY3Rpb24gRHYocywgZSkge1xuICBzW2UgPj4gNV0gfD0gMTI4IDw8IGUgJSAzMiwgc1tfMChlKSAtIDFdID0gZTtcbiAgZm9yICh2YXIgdCA9IDE3MzI1ODQxOTMsIHIgPSAtMjcxNzMzODc5LCBuID0gLTE3MzI1ODQxOTQsIGkgPSAyNzE3MzM4NzgsIG8gPSAwOyBvIDwgcy5sZW5ndGg7IG8gKz0gMTYpIHtcbiAgICB2YXIgYSA9IHQsIGwgPSByLCBjID0gbiwgdSA9IGk7XG4gICAgdCA9IGVyKHQsIHIsIG4sIGksIHNbb10sIDcsIC02ODA4NzY5MzYpLCBpID0gZXIoaSwgdCwgciwgbiwgc1tvICsgMV0sIDEyLCAtMzg5NTY0NTg2KSwgbiA9IGVyKG4sIGksIHQsIHIsIHNbbyArIDJdLCAxNywgNjA2MTA1ODE5KSwgciA9IGVyKHIsIG4sIGksIHQsIHNbbyArIDNdLCAyMiwgLTEwNDQ1MjUzMzApLCB0ID0gZXIodCwgciwgbiwgaSwgc1tvICsgNF0sIDcsIC0xNzY0MTg4OTcpLCBpID0gZXIoaSwgdCwgciwgbiwgc1tvICsgNV0sIDEyLCAxMjAwMDgwNDI2KSwgbiA9IGVyKG4sIGksIHQsIHIsIHNbbyArIDZdLCAxNywgLTE0NzMyMzEzNDEpLCByID0gZXIociwgbiwgaSwgdCwgc1tvICsgN10sIDIyLCAtNDU3MDU5ODMpLCB0ID0gZXIodCwgciwgbiwgaSwgc1tvICsgOF0sIDcsIDE3NzAwMzU0MTYpLCBpID0gZXIoaSwgdCwgciwgbiwgc1tvICsgOV0sIDEyLCAtMTk1ODQxNDQxNyksIG4gPSBlcihuLCBpLCB0LCByLCBzW28gKyAxMF0sIDE3LCAtNDIwNjMpLCByID0gZXIociwgbiwgaSwgdCwgc1tvICsgMTFdLCAyMiwgLTE5OTA0MDQxNjIpLCB0ID0gZXIodCwgciwgbiwgaSwgc1tvICsgMTJdLCA3LCAxODA0NjAzNjgyKSwgaSA9IGVyKGksIHQsIHIsIG4sIHNbbyArIDEzXSwgMTIsIC00MDM0MTEwMSksIG4gPSBlcihuLCBpLCB0LCByLCBzW28gKyAxNF0sIDE3LCAtMTUwMjAwMjI5MCksIHIgPSBlcihyLCBuLCBpLCB0LCBzW28gKyAxNV0sIDIyLCAxMjM2NTM1MzI5KSwgdCA9IHRyKHQsIHIsIG4sIGksIHNbbyArIDFdLCA1LCAtMTY1Nzk2NTEwKSwgaSA9IHRyKGksIHQsIHIsIG4sIHNbbyArIDZdLCA5LCAtMTA2OTUwMTYzMiksIG4gPSB0cihuLCBpLCB0LCByLCBzW28gKyAxMV0sIDE0LCA2NDM3MTc3MTMpLCByID0gdHIociwgbiwgaSwgdCwgc1tvXSwgMjAsIC0zNzM4OTczMDIpLCB0ID0gdHIodCwgciwgbiwgaSwgc1tvICsgNV0sIDUsIC03MDE1NTg2OTEpLCBpID0gdHIoaSwgdCwgciwgbiwgc1tvICsgMTBdLCA5LCAzODAxNjA4MyksIG4gPSB0cihuLCBpLCB0LCByLCBzW28gKyAxNV0sIDE0LCAtNjYwNDc4MzM1KSwgciA9IHRyKHIsIG4sIGksIHQsIHNbbyArIDRdLCAyMCwgLTQwNTUzNzg0OCksIHQgPSB0cih0LCByLCBuLCBpLCBzW28gKyA5XSwgNSwgNTY4NDQ2NDM4KSwgaSA9IHRyKGksIHQsIHIsIG4sIHNbbyArIDE0XSwgOSwgLTEwMTk4MDM2OTApLCBuID0gdHIobiwgaSwgdCwgciwgc1tvICsgM10sIDE0LCAtMTg3MzYzOTYxKSwgciA9IHRyKHIsIG4sIGksIHQsIHNbbyArIDhdLCAyMCwgMTE2MzUzMTUwMSksIHQgPSB0cih0LCByLCBuLCBpLCBzW28gKyAxM10sIDUsIC0xNDQ0NjgxNDY3KSwgaSA9IHRyKGksIHQsIHIsIG4sIHNbbyArIDJdLCA5LCAtNTE0MDM3ODQpLCBuID0gdHIobiwgaSwgdCwgciwgc1tvICsgN10sIDE0LCAxNzM1MzI4NDczKSwgciA9IHRyKHIsIG4sIGksIHQsIHNbbyArIDEyXSwgMjAsIC0xOTI2NjA3NzM0KSwgdCA9IHJyKHQsIHIsIG4sIGksIHNbbyArIDVdLCA0LCAtMzc4NTU4KSwgaSA9IHJyKGksIHQsIHIsIG4sIHNbbyArIDhdLCAxMSwgLTIwMjI1NzQ0NjMpLCBuID0gcnIobiwgaSwgdCwgciwgc1tvICsgMTFdLCAxNiwgMTgzOTAzMDU2MiksIHIgPSBycihyLCBuLCBpLCB0LCBzW28gKyAxNF0sIDIzLCAtMzUzMDk1NTYpLCB0ID0gcnIodCwgciwgbiwgaSwgc1tvICsgMV0sIDQsIC0xNTMwOTkyMDYwKSwgaSA9IHJyKGksIHQsIHIsIG4sIHNbbyArIDRdLCAxMSwgMTI3Mjg5MzM1MyksIG4gPSBycihuLCBpLCB0LCByLCBzW28gKyA3XSwgMTYsIC0xNTU0OTc2MzIpLCByID0gcnIociwgbiwgaSwgdCwgc1tvICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApLCB0ID0gcnIodCwgciwgbiwgaSwgc1tvICsgMTNdLCA0LCA2ODEyNzkxNzQpLCBpID0gcnIoaSwgdCwgciwgbiwgc1tvXSwgMTEsIC0zNTg1MzcyMjIpLCBuID0gcnIobiwgaSwgdCwgciwgc1tvICsgM10sIDE2LCAtNzIyNTIxOTc5KSwgciA9IHJyKHIsIG4sIGksIHQsIHNbbyArIDZdLCAyMywgNzYwMjkxODkpLCB0ID0gcnIodCwgciwgbiwgaSwgc1tvICsgOV0sIDQsIC02NDAzNjQ0ODcpLCBpID0gcnIoaSwgdCwgciwgbiwgc1tvICsgMTJdLCAxMSwgLTQyMTgxNTgzNSksIG4gPSBycihuLCBpLCB0LCByLCBzW28gKyAxNV0sIDE2LCA1MzA3NDI1MjApLCByID0gcnIociwgbiwgaSwgdCwgc1tvICsgMl0sIDIzLCAtOTk1MzM4NjUxKSwgdCA9IHNyKHQsIHIsIG4sIGksIHNbb10sIDYsIC0xOTg2MzA4NDQpLCBpID0gc3IoaSwgdCwgciwgbiwgc1tvICsgN10sIDEwLCAxMTI2ODkxNDE1KSwgbiA9IHNyKG4sIGksIHQsIHIsIHNbbyArIDE0XSwgMTUsIC0xNDE2MzU0OTA1KSwgciA9IHNyKHIsIG4sIGksIHQsIHNbbyArIDVdLCAyMSwgLTU3NDM0MDU1KSwgdCA9IHNyKHQsIHIsIG4sIGksIHNbbyArIDEyXSwgNiwgMTcwMDQ4NTU3MSksIGkgPSBzcihpLCB0LCByLCBuLCBzW28gKyAzXSwgMTAsIC0xODk0OTg2NjA2KSwgbiA9IHNyKG4sIGksIHQsIHIsIHNbbyArIDEwXSwgMTUsIC0xMDUxNTIzKSwgciA9IHNyKHIsIG4sIGksIHQsIHNbbyArIDFdLCAyMSwgLTIwNTQ5MjI3OTkpLCB0ID0gc3IodCwgciwgbiwgaSwgc1tvICsgOF0sIDYsIDE4NzMzMTMzNTkpLCBpID0gc3IoaSwgdCwgciwgbiwgc1tvICsgMTVdLCAxMCwgLTMwNjExNzQ0KSwgbiA9IHNyKG4sIGksIHQsIHIsIHNbbyArIDZdLCAxNSwgLTE1NjAxOTgzODApLCByID0gc3IociwgbiwgaSwgdCwgc1tvICsgMTNdLCAyMSwgMTMwOTE1MTY0OSksIHQgPSBzcih0LCByLCBuLCBpLCBzW28gKyA0XSwgNiwgLTE0NTUyMzA3MCksIGkgPSBzcihpLCB0LCByLCBuLCBzW28gKyAxMV0sIDEwLCAtMTEyMDIxMDM3OSksIG4gPSBzcihuLCBpLCB0LCByLCBzW28gKyAyXSwgMTUsIDcxODc4NzI1OSksIHIgPSBzcihyLCBuLCBpLCB0LCBzW28gKyA5XSwgMjEsIC0zNDM0ODU1NTEpLCB0ID0gTHModCwgYSksIHIgPSBMcyhyLCBsKSwgbiA9IExzKG4sIGMpLCBpID0gTHMoaSwgdSk7XG4gIH1cbiAgcmV0dXJuIFt0LCByLCBuLCBpXTtcbn1cbmZ1bmN0aW9uIFB2KHMpIHtcbiAgaWYgKHMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBbXTtcbiAgZm9yICh2YXIgZSA9IHMubGVuZ3RoICogOCwgdCA9IG5ldyBVaW50MzJBcnJheShfMChlKSksIHIgPSAwOyByIDwgZTsgciArPSA4KVxuICAgIHRbciA+PiA1XSB8PSAoc1tyIC8gOF0gJiAyNTUpIDw8IHIgJSAzMjtcbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBMcyhzLCBlKSB7XG4gIHZhciB0ID0gKHMgJiA2NTUzNSkgKyAoZSAmIDY1NTM1KSwgciA9IChzID4+IDE2KSArIChlID4+IDE2KSArICh0ID4+IDE2KTtcbiAgcmV0dXJuIHIgPDwgMTYgfCB0ICYgNjU1MzU7XG59XG5mdW5jdGlvbiBNdihzLCBlKSB7XG4gIHJldHVybiBzIDw8IGUgfCBzID4+PiAzMiAtIGU7XG59XG5mdW5jdGlvbiBoYShzLCBlLCB0LCByLCBuLCBpKSB7XG4gIHJldHVybiBMcyhNdihMcyhMcyhlLCBzKSwgTHMociwgaSkpLCBuKSwgdCk7XG59XG5mdW5jdGlvbiBlcihzLCBlLCB0LCByLCBuLCBpLCBvKSB7XG4gIHJldHVybiBoYShlICYgdCB8IH5lICYgciwgcywgZSwgbiwgaSwgbyk7XG59XG5mdW5jdGlvbiB0cihzLCBlLCB0LCByLCBuLCBpLCBvKSB7XG4gIHJldHVybiBoYShlICYgciB8IHQgJiB+ciwgcywgZSwgbiwgaSwgbyk7XG59XG5mdW5jdGlvbiBycihzLCBlLCB0LCByLCBuLCBpLCBvKSB7XG4gIHJldHVybiBoYShlIF4gdCBeIHIsIHMsIGUsIG4sIGksIG8pO1xufVxuZnVuY3Rpb24gc3IocywgZSwgdCwgciwgbiwgaSwgbykge1xuICByZXR1cm4gaGEodCBeIChlIHwgfnIpLCBzLCBlLCBuLCBpLCBvKTtcbn1cbnZhciBPdiA9IEkwKFwidjNcIiwgNDgsIEN2KTtcbmZ1bmN0aW9uIEJ2KHMsIGUsIHQpIHtcbiAgcyA9IHMgfHwge307XG4gIHZhciByID0gcy5yYW5kb20gfHwgKHMucm5nIHx8IHcwKSgpO1xuICBpZiAocls2XSA9IHJbNl0gJiAxNSB8IDY0LCByWzhdID0gcls4XSAmIDYzIHwgMTI4LCBlKSB7XG4gICAgdCA9IHQgfHwgMDtcbiAgICBmb3IgKHZhciBuID0gMDsgbiA8IDE2OyArK24pXG4gICAgICBlW3QgKyBuXSA9IHJbbl07XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgcmV0dXJuIGRhKHIpO1xufVxuZnVuY3Rpb24gRnYocywgZSwgdCwgcikge1xuICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gZSAmIHQgXiB+ZSAmIHI7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGUgXiB0IF4gcjtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZSAmIHQgXiBlICYgciBeIHQgJiByO1xuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiBlIF4gdCBeIHI7XG4gIH1cbn1cbmZ1bmN0aW9uIHNsKHMsIGUpIHtcbiAgcmV0dXJuIHMgPDwgZSB8IHMgPj4+IDMyIC0gZTtcbn1cbmZ1bmN0aW9uIE52KHMpIHtcbiAgdmFyIGUgPSBbMTUxODUwMDI0OSwgMTg1OTc3NTM5MywgMjQwMDk1OTcwOCwgMzM5NTQ2OTc4Ml0sIHQgPSBbMTczMjU4NDE5MywgNDAyMzIzMzQxNywgMjU2MjM4MzEwMiwgMjcxNzMzODc4LCAzMjg1Mzc3NTIwXTtcbiAgaWYgKHR5cGVvZiBzID09IFwic3RyaW5nXCIpIHtcbiAgICB2YXIgciA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzKSk7XG4gICAgcyA9IFtdO1xuICAgIGZvciAodmFyIG4gPSAwOyBuIDwgci5sZW5ndGg7ICsrbilcbiAgICAgIHMucHVzaChyLmNoYXJDb2RlQXQobikpO1xuICB9IGVsc2UgQXJyYXkuaXNBcnJheShzKSB8fCAocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHMpKTtcbiAgcy5wdXNoKDEyOCk7XG4gIGZvciAodmFyIGkgPSBzLmxlbmd0aCAvIDQgKyAyLCBvID0gTWF0aC5jZWlsKGkgLyAxNiksIGEgPSBuZXcgQXJyYXkobyksIGwgPSAwOyBsIDwgbzsgKytsKSB7XG4gICAgZm9yICh2YXIgYyA9IG5ldyBVaW50MzJBcnJheSgxNiksIHUgPSAwOyB1IDwgMTY7ICsrdSlcbiAgICAgIGNbdV0gPSBzW2wgKiA2NCArIHUgKiA0XSA8PCAyNCB8IHNbbCAqIDY0ICsgdSAqIDQgKyAxXSA8PCAxNiB8IHNbbCAqIDY0ICsgdSAqIDQgKyAyXSA8PCA4IHwgc1tsICogNjQgKyB1ICogNCArIDNdO1xuICAgIGFbbF0gPSBjO1xuICB9XG4gIGFbbyAtIDFdWzE0XSA9IChzLmxlbmd0aCAtIDEpICogOCAvIE1hdGgucG93KDIsIDMyKSwgYVtvIC0gMV1bMTRdID0gTWF0aC5mbG9vcihhW28gLSAxXVsxNF0pLCBhW28gLSAxXVsxNV0gPSAocy5sZW5ndGggLSAxKSAqIDggJiA0Mjk0OTY3Mjk1O1xuICBmb3IgKHZhciBkID0gMDsgZCA8IG87ICsrZCkge1xuICAgIGZvciAodmFyIGggPSBuZXcgVWludDMyQXJyYXkoODApLCBmID0gMDsgZiA8IDE2OyArK2YpXG4gICAgICBoW2ZdID0gYVtkXVtmXTtcbiAgICBmb3IgKHZhciBwID0gMTY7IHAgPCA4MDsgKytwKVxuICAgICAgaFtwXSA9IHNsKGhbcCAtIDNdIF4gaFtwIC0gOF0gXiBoW3AgLSAxNF0gXiBoW3AgLSAxNl0sIDEpO1xuICAgIGZvciAodmFyIHkgPSB0WzBdLCBFID0gdFsxXSwgYiA9IHRbMl0sIFIgPSB0WzNdLCBBID0gdFs0XSwgRiA9IDA7IEYgPCA4MDsgKytGKSB7XG4gICAgICB2YXIgTSA9IE1hdGguZmxvb3IoRiAvIDIwKSwgSCA9IHNsKHksIDUpICsgRnYoTSwgRSwgYiwgUikgKyBBICsgZVtNXSArIGhbRl0gPj4+IDA7XG4gICAgICBBID0gUiwgUiA9IGIsIGIgPSBzbChFLCAzMCkgPj4+IDAsIEUgPSB5LCB5ID0gSDtcbiAgICB9XG4gICAgdFswXSA9IHRbMF0gKyB5ID4+PiAwLCB0WzFdID0gdFsxXSArIEUgPj4+IDAsIHRbMl0gPSB0WzJdICsgYiA+Pj4gMCwgdFszXSA9IHRbM10gKyBSID4+PiAwLCB0WzRdID0gdFs0XSArIEEgPj4+IDA7XG4gIH1cbiAgcmV0dXJuIFt0WzBdID4+IDI0ICYgMjU1LCB0WzBdID4+IDE2ICYgMjU1LCB0WzBdID4+IDggJiAyNTUsIHRbMF0gJiAyNTUsIHRbMV0gPj4gMjQgJiAyNTUsIHRbMV0gPj4gMTYgJiAyNTUsIHRbMV0gPj4gOCAmIDI1NSwgdFsxXSAmIDI1NSwgdFsyXSA+PiAyNCAmIDI1NSwgdFsyXSA+PiAxNiAmIDI1NSwgdFsyXSA+PiA4ICYgMjU1LCB0WzJdICYgMjU1LCB0WzNdID4+IDI0ICYgMjU1LCB0WzNdID4+IDE2ICYgMjU1LCB0WzNdID4+IDggJiAyNTUsIHRbM10gJiAyNTUsIHRbNF0gPj4gMjQgJiAyNTUsIHRbNF0gPj4gMTYgJiAyNTUsIHRbNF0gPj4gOCAmIDI1NSwgdFs0XSAmIDI1NV07XG59XG52YXIgVXYgPSBJMChcInY1XCIsIDgwLCBOdik7XG5jb25zdCAkdiA9IFwiMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwXCI7XG5mdW5jdGlvbiBHdihzKSB7XG4gIGlmICghdWEocykpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiSW52YWxpZCBVVUlEXCIpO1xuICByZXR1cm4gcGFyc2VJbnQocy5zdWJzdHIoMTQsIDEpLCAxNik7XG59XG5jb25zdCBWdiA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZnJlZXplKC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIE5JTDogJHYsXG4gIHBhcnNlOiBBMCxcbiAgc3RyaW5naWZ5OiBkYSxcbiAgdjE6IEl2LFxuICB2MzogT3YsXG4gIHY0OiBCdixcbiAgdjU6IFV2LFxuICB2YWxpZGF0ZTogdWEsXG4gIHZlcnNpb246IEd2XG59LCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6IFwiTW9kdWxlXCIgfSkpLCBSMCA9IC8qIEBfX1BVUkVfXyAqLyBOYyhWdik7XG52YXIgbmwsIERkO1xuZnVuY3Rpb24ganYoKSB7XG4gIGlmIChEZCkgcmV0dXJuIG5sO1xuICBEZCA9IDE7XG4gIGNvbnN0IHMgPSBSMC52NDtcbiAgcmV0dXJuIG5sID0gZnVuY3Rpb24odCwgciwgbiwgaSkge1xuICAgIGlmICh0eXBlb2YgdCAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcih0ICsgXCIgbXVzdCBiZSBhIHN0cmluZ1wiKTtcbiAgICBpID0gaSB8fCB7fTtcbiAgICBjb25zdCBvID0gdHlwZW9mIGkudmVyc2lvbiA9PSBcIm51bWJlclwiID8gaS52ZXJzaW9uIDogMjtcbiAgICBpZiAobyAhPT0gMSAmJiBvICE9PSAyKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihvICsgXCIgbXVzdCBiZSAxIG9yIDJcIik7XG4gICAgY29uc3QgYSA9IHtcbiAgICAgIG1ldGhvZDogdFxuICAgIH07XG4gICAgaWYgKG8gPT09IDIgJiYgKGEuanNvbnJwYyA9IFwiMi4wXCIpLCByKSB7XG4gICAgICBpZiAodHlwZW9mIHIgIT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShyKSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihyICsgXCIgbXVzdCBiZSBhbiBvYmplY3QsIGFycmF5IG9yIG9taXR0ZWRcIik7XG4gICAgICBhLnBhcmFtcyA9IHI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbiA+IFwidVwiKSB7XG4gICAgICBjb25zdCBsID0gdHlwZW9mIGkuZ2VuZXJhdG9yID09IFwiZnVuY3Rpb25cIiA/IGkuZ2VuZXJhdG9yIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzKCk7XG4gICAgICB9O1xuICAgICAgYS5pZCA9IGwoYSwgaSk7XG4gICAgfSBlbHNlIG8gPT09IDIgJiYgbiA9PT0gbnVsbCA/IGkubm90aWZpY2F0aW9uSWROdWxsICYmIChhLmlkID0gbnVsbCkgOiBhLmlkID0gbjtcbiAgICByZXR1cm4gYTtcbiAgfSwgbmw7XG59XG52YXIgaWwsIFBkO1xuZnVuY3Rpb24gS3YoKSB7XG4gIGlmIChQZCkgcmV0dXJuIGlsO1xuICBQZCA9IDE7XG4gIGNvbnN0IHMgPSBSMC52NCwgZSA9IGp2KCksIHQgPSBmdW5jdGlvbihyLCBuKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIHQpKVxuICAgICAgcmV0dXJuIG5ldyB0KHIsIG4pO1xuICAgIG4gfHwgKG4gPSB7fSksIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHJldml2ZXI6IHR5cGVvZiBuLnJldml2ZXIgPCBcInVcIiA/IG4ucmV2aXZlciA6IG51bGwsXG4gICAgICByZXBsYWNlcjogdHlwZW9mIG4ucmVwbGFjZXIgPCBcInVcIiA/IG4ucmVwbGFjZXIgOiBudWxsLFxuICAgICAgZ2VuZXJhdG9yOiB0eXBlb2Ygbi5nZW5lcmF0b3IgPCBcInVcIiA/IG4uZ2VuZXJhdG9yIDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzKCk7XG4gICAgICB9LFxuICAgICAgdmVyc2lvbjogdHlwZW9mIG4udmVyc2lvbiA8IFwidVwiID8gbi52ZXJzaW9uIDogMixcbiAgICAgIG5vdGlmaWNhdGlvbklkTnVsbDogdHlwZW9mIG4ubm90aWZpY2F0aW9uSWROdWxsID09IFwiYm9vbGVhblwiID8gbi5ub3RpZmljYXRpb25JZE51bGwgOiAhMVxuICAgIH0sIHRoaXMuY2FsbFNlcnZlciA9IHI7XG4gIH07XG4gIHJldHVybiBpbCA9IHQsIHQucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbihyLCBuLCBpLCBvKSB7XG4gICAgY29uc3QgYSA9IHRoaXM7XG4gICAgbGV0IGwgPSBudWxsO1xuICAgIGNvbnN0IGMgPSBBcnJheS5pc0FycmF5KHIpICYmIHR5cGVvZiBuID09IFwiZnVuY3Rpb25cIjtcbiAgICBpZiAodGhpcy5vcHRpb25zLnZlcnNpb24gPT09IDEgJiYgYylcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJKU09OLVJQQyAxLjAgZG9lcyBub3Qgc3VwcG9ydCBiYXRjaGluZ1wiKTtcbiAgICBpZiAoYyB8fCAhYyAmJiByICYmIHR5cGVvZiByID09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG4gPT0gXCJmdW5jdGlvblwiKVxuICAgICAgbyA9IG4sIGwgPSByO1xuICAgIGVsc2Uge1xuICAgICAgdHlwZW9mIGkgPT0gXCJmdW5jdGlvblwiICYmIChvID0gaSwgaSA9IHZvaWQgMCk7XG4gICAgICBjb25zdCBoID0gdHlwZW9mIG8gPT0gXCJmdW5jdGlvblwiO1xuICAgICAgdHJ5IHtcbiAgICAgICAgbCA9IGUociwgbiwgaSwge1xuICAgICAgICAgIGdlbmVyYXRvcjogdGhpcy5vcHRpb25zLmdlbmVyYXRvcixcbiAgICAgICAgICB2ZXJzaW9uOiB0aGlzLm9wdGlvbnMudmVyc2lvbixcbiAgICAgICAgICBub3RpZmljYXRpb25JZE51bGw6IHRoaXMub3B0aW9ucy5ub3RpZmljYXRpb25JZE51bGxcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChmKSB7XG4gICAgICAgIGlmIChoKVxuICAgICAgICAgIHJldHVybiBvKGYpO1xuICAgICAgICB0aHJvdyBmO1xuICAgICAgfVxuICAgICAgaWYgKCFoKVxuICAgICAgICByZXR1cm4gbDtcbiAgICB9XG4gICAgbGV0IGQ7XG4gICAgdHJ5IHtcbiAgICAgIGQgPSBKU09OLnN0cmluZ2lmeShsLCB0aGlzLm9wdGlvbnMucmVwbGFjZXIpO1xuICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgIHJldHVybiBvKGgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jYWxsU2VydmVyKGQsIGZ1bmN0aW9uKGgsIGYpIHtcbiAgICAgIGEuX3BhcnNlUmVzcG9uc2UoaCwgZiwgbyk7XG4gICAgfSksIGw7XG4gIH0sIHQucHJvdG90eXBlLl9wYXJzZVJlc3BvbnNlID0gZnVuY3Rpb24ociwgbiwgaSkge1xuICAgIGlmIChyKSB7XG4gICAgICBpKHIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW4pXG4gICAgICByZXR1cm4gaSgpO1xuICAgIGxldCBvO1xuICAgIHRyeSB7XG4gICAgICBvID0gSlNPTi5wYXJzZShuLCB0aGlzLm9wdGlvbnMucmV2aXZlcik7XG4gICAgfSBjYXRjaCAoYSkge1xuICAgICAgcmV0dXJuIGkoYSk7XG4gICAgfVxuICAgIGlmIChpLmxlbmd0aCA9PT0gMylcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG8pKSB7XG4gICAgICAgIGNvbnN0IGEgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGVvZiBjLmVycm9yIDwgXCJ1XCI7XG4gICAgICAgIH0sIGwgPSBmdW5jdGlvbihjKSB7XG4gICAgICAgICAgcmV0dXJuICFhKGMpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaShudWxsLCBvLmZpbHRlcihhKSwgby5maWx0ZXIobCkpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiBpKG51bGwsIG8uZXJyb3IsIG8ucmVzdWx0KTtcbiAgICBpKG51bGwsIG8pO1xuICB9LCBpbDtcbn1cbkt2KCk7XG52YXIgb2wgPSB7IGV4cG9ydHM6IHt9IH0sIE1kO1xuZnVuY3Rpb24gSHYoKSB7XG4gIHJldHVybiBNZCB8fCAoTWQgPSAxLCAoZnVuY3Rpb24ocykge1xuICAgIHZhciBlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgdCA9IFwiflwiO1xuICAgIGZ1bmN0aW9uIHIoKSB7XG4gICAgfVxuICAgIE9iamVjdC5jcmVhdGUgJiYgKHIucHJvdG90eXBlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIG5ldyByKCkuX19wcm90b19fIHx8ICh0ID0gITEpKTtcbiAgICBmdW5jdGlvbiBuKGwsIGMsIHUpIHtcbiAgICAgIHRoaXMuZm4gPSBsLCB0aGlzLmNvbnRleHQgPSBjLCB0aGlzLm9uY2UgPSB1IHx8ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpKGwsIGMsIHUsIGQsIGgpIHtcbiAgICAgIGlmICh0eXBlb2YgdSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgdmFyIGYgPSBuZXcgbih1LCBkIHx8IGwsIGgpLCBwID0gdCA/IHQgKyBjIDogYztcbiAgICAgIHJldHVybiBsLl9ldmVudHNbcF0gPyBsLl9ldmVudHNbcF0uZm4gPyBsLl9ldmVudHNbcF0gPSBbbC5fZXZlbnRzW3BdLCBmXSA6IGwuX2V2ZW50c1twXS5wdXNoKGYpIDogKGwuX2V2ZW50c1twXSA9IGYsIGwuX2V2ZW50c0NvdW50KyspLCBsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvKGwsIGMpIHtcbiAgICAgIC0tbC5fZXZlbnRzQ291bnQgPT09IDAgPyBsLl9ldmVudHMgPSBuZXcgcigpIDogZGVsZXRlIGwuX2V2ZW50c1tjXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYSgpIHtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyByKCksIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICB9XG4gICAgYS5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGMgPSBbXSwgdSwgZDtcbiAgICAgIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIGM7XG4gICAgICBmb3IgKGQgaW4gdSA9IHRoaXMuX2V2ZW50cylcbiAgICAgICAgZS5jYWxsKHUsIGQpICYmIGMucHVzaCh0ID8gZC5zbGljZSgxKSA6IGQpO1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHUpKSA6IGM7XG4gICAgfSwgYS5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oYykge1xuICAgICAgdmFyIHUgPSB0ID8gdCArIGMgOiBjLCBkID0gdGhpcy5fZXZlbnRzW3VdO1xuICAgICAgaWYgKCFkKSByZXR1cm4gW107XG4gICAgICBpZiAoZC5mbikgcmV0dXJuIFtkLmZuXTtcbiAgICAgIGZvciAodmFyIGggPSAwLCBmID0gZC5sZW5ndGgsIHAgPSBuZXcgQXJyYXkoZik7IGggPCBmOyBoKyspXG4gICAgICAgIHBbaF0gPSBkW2hdLmZuO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSwgYS5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciB1ID0gdCA/IHQgKyBjIDogYywgZCA9IHRoaXMuX2V2ZW50c1t1XTtcbiAgICAgIHJldHVybiBkID8gZC5mbiA/IDEgOiBkLmxlbmd0aCA6IDA7XG4gICAgfSwgYS5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGMsIHUsIGQsIGgsIGYsIHApIHtcbiAgICAgIHZhciB5ID0gdCA/IHQgKyBjIDogYztcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzW3ldKSByZXR1cm4gITE7XG4gICAgICB2YXIgRSA9IHRoaXMuX2V2ZW50c1t5XSwgYiA9IGFyZ3VtZW50cy5sZW5ndGgsIFIsIEE7XG4gICAgICBpZiAoRS5mbikge1xuICAgICAgICBzd2l0Y2ggKEUub25jZSAmJiB0aGlzLnJlbW92ZUxpc3RlbmVyKGMsIEUuZm4sIHZvaWQgMCwgITApLCBiKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIEUuZm4uY2FsbChFLmNvbnRleHQpLCAhMDtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gRS5mbi5jYWxsKEUuY29udGV4dCwgdSksICEwO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBFLmZuLmNhbGwoRS5jb250ZXh0LCB1LCBkKSwgITA7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIEUuZm4uY2FsbChFLmNvbnRleHQsIHUsIGQsIGgpLCAhMDtcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gRS5mbi5jYWxsKEUuY29udGV4dCwgdSwgZCwgaCwgZiksICEwO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBFLmZuLmNhbGwoRS5jb250ZXh0LCB1LCBkLCBoLCBmLCBwKSwgITA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChBID0gMSwgUiA9IG5ldyBBcnJheShiIC0gMSk7IEEgPCBiOyBBKyspXG4gICAgICAgICAgUltBIC0gMV0gPSBhcmd1bWVudHNbQV07XG4gICAgICAgIEUuZm4uYXBwbHkoRS5jb250ZXh0LCBSKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBGID0gRS5sZW5ndGgsIE07XG4gICAgICAgIGZvciAoQSA9IDA7IEEgPCBGOyBBKyspXG4gICAgICAgICAgc3dpdGNoIChFW0FdLm9uY2UgJiYgdGhpcy5yZW1vdmVMaXN0ZW5lcihjLCBFW0FdLmZuLCB2b2lkIDAsICEwKSwgYikge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBFW0FdLmZuLmNhbGwoRVtBXS5jb250ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIEVbQV0uZm4uY2FsbChFW0FdLmNvbnRleHQsIHUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgRVtBXS5mbi5jYWxsKEVbQV0uY29udGV4dCwgdSwgZCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBFW0FdLmZuLmNhbGwoRVtBXS5jb250ZXh0LCB1LCBkLCBoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAoIVIpIGZvciAoTSA9IDEsIFIgPSBuZXcgQXJyYXkoYiAtIDEpOyBNIDwgYjsgTSsrKVxuICAgICAgICAgICAgICAgIFJbTSAtIDFdID0gYXJndW1lbnRzW01dO1xuICAgICAgICAgICAgICBFW0FdLmZuLmFwcGx5KEVbQV0uY29udGV4dCwgUik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH0sIGEucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oYywgdSwgZCkge1xuICAgICAgcmV0dXJuIGkodGhpcywgYywgdSwgZCwgITEpO1xuICAgIH0sIGEucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihjLCB1LCBkKSB7XG4gICAgICByZXR1cm4gaSh0aGlzLCBjLCB1LCBkLCAhMCk7XG4gICAgfSwgYS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihjLCB1LCBkLCBoKSB7XG4gICAgICB2YXIgZiA9IHQgPyB0ICsgYyA6IGM7XG4gICAgICBpZiAoIXRoaXMuX2V2ZW50c1tmXSkgcmV0dXJuIHRoaXM7XG4gICAgICBpZiAoIXUpXG4gICAgICAgIHJldHVybiBvKHRoaXMsIGYpLCB0aGlzO1xuICAgICAgdmFyIHAgPSB0aGlzLl9ldmVudHNbZl07XG4gICAgICBpZiAocC5mbilcbiAgICAgICAgcC5mbiA9PT0gdSAmJiAoIWggfHwgcC5vbmNlKSAmJiAoIWQgfHwgcC5jb250ZXh0ID09PSBkKSAmJiBvKHRoaXMsIGYpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIHkgPSAwLCBFID0gW10sIGIgPSBwLmxlbmd0aDsgeSA8IGI7IHkrKylcbiAgICAgICAgICAocFt5XS5mbiAhPT0gdSB8fCBoICYmICFwW3ldLm9uY2UgfHwgZCAmJiBwW3ldLmNvbnRleHQgIT09IGQpICYmIEUucHVzaChwW3ldKTtcbiAgICAgICAgRS5sZW5ndGggPyB0aGlzLl9ldmVudHNbZl0gPSBFLmxlbmd0aCA9PT0gMSA/IEVbMF0gOiBFIDogbyh0aGlzLCBmKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIGEucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciB1O1xuICAgICAgcmV0dXJuIGMgPyAodSA9IHQgPyB0ICsgYyA6IGMsIHRoaXMuX2V2ZW50c1t1XSAmJiBvKHRoaXMsIHUpKSA6ICh0aGlzLl9ldmVudHMgPSBuZXcgcigpLCB0aGlzLl9ldmVudHNDb3VudCA9IDApLCB0aGlzO1xuICAgIH0sIGEucHJvdG90eXBlLm9mZiA9IGEucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLCBhLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGEucHJvdG90eXBlLm9uLCBhLnByZWZpeGVkID0gdCwgYS5FdmVudEVtaXR0ZXIgPSBhLCBzLmV4cG9ydHMgPSBhO1xuICB9KShvbCkpLCBvbC5leHBvcnRzO1xufVxudmFyIHF2ID0gSHYoKTtcbmNvbnN0IEwwID0gLyogQF9fUFVSRV9fICovIEZjKHF2KTtcbmNsYXNzIEMwIGV4dGVuZHMgV2Yge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoKSwgdGhpcy5maW5pc2hlZCA9ICExLCB0aGlzLmRlc3Ryb3llZCA9ICExLCBIZihlKTtcbiAgICBjb25zdCByID0gSGModCk7XG4gICAgaWYgKHRoaXMuaUhhc2ggPSBlLmNyZWF0ZSgpLCB0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT0gXCJmdW5jdGlvblwiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgaW5zdGFuY2Ugb2YgY2xhc3Mgd2hpY2ggZXh0ZW5kcyB1dGlscy5IYXNoXCIpO1xuICAgIHRoaXMuYmxvY2tMZW4gPSB0aGlzLmlIYXNoLmJsb2NrTGVuLCB0aGlzLm91dHB1dExlbiA9IHRoaXMuaUhhc2gub3V0cHV0TGVuO1xuICAgIGNvbnN0IG4gPSB0aGlzLmJsb2NrTGVuLCBpID0gbmV3IFVpbnQ4QXJyYXkobik7XG4gICAgaS5zZXQoci5sZW5ndGggPiBuID8gZS5jcmVhdGUoKS51cGRhdGUocikuZGlnZXN0KCkgOiByKTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IGkubGVuZ3RoOyBvKyspXG4gICAgICBpW29dIF49IDU0O1xuICAgIHRoaXMuaUhhc2gudXBkYXRlKGkpLCB0aGlzLm9IYXNoID0gZS5jcmVhdGUoKTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IGkubGVuZ3RoOyBvKyspXG4gICAgICBpW29dIF49IDEwNjtcbiAgICB0aGlzLm9IYXNoLnVwZGF0ZShpKSwga24oaSk7XG4gIH1cbiAgdXBkYXRlKGUpIHtcbiAgICByZXR1cm4gRG8odGhpcyksIHRoaXMuaUhhc2gudXBkYXRlKGUpLCB0aGlzO1xuICB9XG4gIGRpZ2VzdEludG8oZSkge1xuICAgIERvKHRoaXMpLCBRcyhlLCB0aGlzLm91dHB1dExlbiksIHRoaXMuZmluaXNoZWQgPSAhMCwgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKGUpLCB0aGlzLm9IYXNoLnVwZGF0ZShlKSwgdGhpcy5vSGFzaC5kaWdlc3RJbnRvKGUpLCB0aGlzLmRlc3Ryb3koKTtcbiAgfVxuICBkaWdlc3QoKSB7XG4gICAgY29uc3QgZSA9IG5ldyBVaW50OEFycmF5KHRoaXMub0hhc2gub3V0cHV0TGVuKTtcbiAgICByZXR1cm4gdGhpcy5kaWdlc3RJbnRvKGUpLCBlO1xuICB9XG4gIF9jbG9uZUludG8oZSkge1xuICAgIGUgfHwgKGUgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICBjb25zdCB7IG9IYXNoOiB0LCBpSGFzaDogciwgZmluaXNoZWQ6IG4sIGRlc3Ryb3llZDogaSwgYmxvY2tMZW46IG8sIG91dHB1dExlbjogYSB9ID0gdGhpcztcbiAgICByZXR1cm4gZSA9IGUsIGUuZmluaXNoZWQgPSBuLCBlLmRlc3Ryb3llZCA9IGksIGUuYmxvY2tMZW4gPSBvLCBlLm91dHB1dExlbiA9IGEsIGUub0hhc2ggPSB0Ll9jbG9uZUludG8oZS5vSGFzaCksIGUuaUhhc2ggPSByLl9jbG9uZUludG8oZS5pSGFzaCksIGU7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSAhMCwgdGhpcy5vSGFzaC5kZXN0cm95KCksIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICB9XG59XG5jb25zdCBrMCA9IChzLCBlLCB0KSA9PiBuZXcgQzAocywgZSkudXBkYXRlKHQpLmRpZ2VzdCgpO1xuazAuY3JlYXRlID0gKHMsIGUpID0+IG5ldyBDMChzLCBlKTtcbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IE9kID0gKHMsIGUpID0+IChzICsgKHMgPj0gMCA/IGUgOiAtZSkgLyBEMCkgLyBlO1xuZnVuY3Rpb24gV3YocywgZSwgdCkge1xuICBjb25zdCBbW3IsIG5dLCBbaSwgb11dID0gZSwgYSA9IE9kKG8gKiBzLCB0KSwgbCA9IE9kKC1uICogcywgdCk7XG4gIGxldCBjID0gcyAtIGEgKiByIC0gbCAqIGksIHUgPSAtYSAqIG4gLSBsICogbztcbiAgY29uc3QgZCA9IGMgPCBocywgaCA9IHUgPCBocztcbiAgZCAmJiAoYyA9IC1jKSwgaCAmJiAodSA9IC11KTtcbiAgY29uc3QgZiA9IF9pKE1hdGguY2VpbChlMCh0KSAvIDIpKSArIFRuO1xuICBpZiAoYyA8IGhzIHx8IGMgPj0gZiB8fCB1IDwgaHMgfHwgdSA+PSBmKVxuICAgIHRocm93IG5ldyBFcnJvcihcInNwbGl0U2NhbGFyIChlbmRvbW9ycGhpc20pOiBmYWlsZWQsIGs9XCIgKyBzKTtcbiAgcmV0dXJuIHsgazFuZWc6IGQsIGsxOiBjLCBrMm5lZzogaCwgazI6IHUgfTtcbn1cbmZ1bmN0aW9uIGVjKHMpIHtcbiAgaWYgKCFbXCJjb21wYWN0XCIsIFwicmVjb3ZlcmVkXCIsIFwiZGVyXCJdLmluY2x1ZGVzKHMpKVxuICAgIHRocm93IG5ldyBFcnJvcignU2lnbmF0dXJlIGZvcm1hdCBtdXN0IGJlIFwiY29tcGFjdFwiLCBcInJlY292ZXJlZFwiLCBvciBcImRlclwiJyk7XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gYWwocywgZSkge1xuICBjb25zdCB0ID0ge307XG4gIGZvciAobGV0IHIgb2YgT2JqZWN0LmtleXMoZSkpXG4gICAgdFtyXSA9IHNbcl0gPT09IHZvaWQgMCA/IGVbcl0gOiBzW3JdO1xuICByZXR1cm4gWHModC5sb3dTLCBcImxvd1NcIiksIFhzKHQucHJlaGFzaCwgXCJwcmVoYXNoXCIpLCB0LmZvcm1hdCAhPT0gdm9pZCAwICYmIGVjKHQuZm9ybWF0KSwgdDtcbn1cbmNsYXNzIHp2IGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihlID0gXCJcIikge1xuICAgIHN1cGVyKGUpO1xuICB9XG59XG5jb25zdCBjcyA9IHtcbiAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gIEVycjogenYsXG4gIC8vIEJhc2ljIGJ1aWxkaW5nIGJsb2NrIGlzIFRMViAoVGFnLUxlbmd0aC1WYWx1ZSlcbiAgX3Rsdjoge1xuICAgIGVuY29kZTogKHMsIGUpID0+IHtcbiAgICAgIGNvbnN0IHsgRXJyOiB0IH0gPSBjcztcbiAgICAgIGlmIChzIDwgMCB8fCBzID4gMjU2KVxuICAgICAgICB0aHJvdyBuZXcgdChcInRsdi5lbmNvZGU6IHdyb25nIHRhZ1wiKTtcbiAgICAgIGlmIChlLmxlbmd0aCAmIDEpXG4gICAgICAgIHRocm93IG5ldyB0KFwidGx2LmVuY29kZTogdW5wYWRkZWQgZGF0YVwiKTtcbiAgICAgIGNvbnN0IHIgPSBlLmxlbmd0aCAvIDIsIG4gPSBOaShyKTtcbiAgICAgIGlmIChuLmxlbmd0aCAvIDIgJiAxMjgpXG4gICAgICAgIHRocm93IG5ldyB0KFwidGx2LmVuY29kZTogbG9uZyBmb3JtIGxlbmd0aCB0b28gYmlnXCIpO1xuICAgICAgY29uc3QgaSA9IHIgPiAxMjcgPyBOaShuLmxlbmd0aCAvIDIgfCAxMjgpIDogXCJcIjtcbiAgICAgIHJldHVybiBOaShzKSArIGkgKyBuICsgZTtcbiAgICB9LFxuICAgIC8vIHYgLSB2YWx1ZSwgbCAtIGxlZnQgYnl0ZXMgKHVucGFyc2VkKVxuICAgIGRlY29kZShzLCBlKSB7XG4gICAgICBjb25zdCB7IEVycjogdCB9ID0gY3M7XG4gICAgICBsZXQgciA9IDA7XG4gICAgICBpZiAocyA8IDAgfHwgcyA+IDI1NilcbiAgICAgICAgdGhyb3cgbmV3IHQoXCJ0bHYuZW5jb2RlOiB3cm9uZyB0YWdcIik7XG4gICAgICBpZiAoZS5sZW5ndGggPCAyIHx8IGVbcisrXSAhPT0gcylcbiAgICAgICAgdGhyb3cgbmV3IHQoXCJ0bHYuZGVjb2RlOiB3cm9uZyB0bHZcIik7XG4gICAgICBjb25zdCBuID0gZVtyKytdLCBpID0gISEobiAmIDEyOCk7XG4gICAgICBsZXQgbyA9IDA7XG4gICAgICBpZiAoIWkpXG4gICAgICAgIG8gPSBuO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGwgPSBuICYgMTI3O1xuICAgICAgICBpZiAoIWwpXG4gICAgICAgICAgdGhyb3cgbmV3IHQoXCJ0bHYuZGVjb2RlKGxvbmcpOiBpbmRlZmluaXRlIGxlbmd0aCBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICBpZiAobCA+IDQpXG4gICAgICAgICAgdGhyb3cgbmV3IHQoXCJ0bHYuZGVjb2RlKGxvbmcpOiBieXRlIGxlbmd0aCBpcyB0b28gYmlnXCIpO1xuICAgICAgICBjb25zdCBjID0gZS5zdWJhcnJheShyLCByICsgbCk7XG4gICAgICAgIGlmIChjLmxlbmd0aCAhPT0gbClcbiAgICAgICAgICB0aHJvdyBuZXcgdChcInRsdi5kZWNvZGU6IGxlbmd0aCBieXRlcyBub3QgY29tcGxldGVcIik7XG4gICAgICAgIGlmIChjWzBdID09PSAwKVxuICAgICAgICAgIHRocm93IG5ldyB0KFwidGx2LmRlY29kZShsb25nKTogemVybyBsZWZ0bW9zdCBieXRlXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IHUgb2YgYylcbiAgICAgICAgICBvID0gbyA8PCA4IHwgdTtcbiAgICAgICAgaWYgKHIgKz0gbCwgbyA8IDEyOClcbiAgICAgICAgICB0aHJvdyBuZXcgdChcInRsdi5kZWNvZGUobG9uZyk6IG5vdCBtaW5pbWFsIGVuY29kaW5nXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgYSA9IGUuc3ViYXJyYXkociwgciArIG8pO1xuICAgICAgaWYgKGEubGVuZ3RoICE9PSBvKVxuICAgICAgICB0aHJvdyBuZXcgdChcInRsdi5kZWNvZGU6IHdyb25nIHZhbHVlIGxlbmd0aFwiKTtcbiAgICAgIHJldHVybiB7IHY6IGEsIGw6IGUuc3ViYXJyYXkociArIG8pIH07XG4gICAgfVxuICB9LFxuICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzICduZWdhdGl2ZScgZmxhZyxcbiAgLy8gc2luY2Ugd2UgYWx3YXlzIHVzZSBwb3NpdGl2ZSBpbnRlZ2VycyBoZXJlLiBJdCBtdXN0IGFsd2F5cyBiZSBlbXB0eTpcbiAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xuICAvLyAtIGlmIG5leHQgYnl0ZSBkb2Vzbid0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXG4gIF9pbnQ6IHtcbiAgICBlbmNvZGUocykge1xuICAgICAgY29uc3QgeyBFcnI6IGUgfSA9IGNzO1xuICAgICAgaWYgKHMgPCBocylcbiAgICAgICAgdGhyb3cgbmV3IGUoXCJpbnRlZ2VyOiBuZWdhdGl2ZSBpbnRlZ2VycyBhcmUgbm90IGFsbG93ZWRcIik7XG4gICAgICBsZXQgdCA9IE5pKHMpO1xuICAgICAgaWYgKE51bWJlci5wYXJzZUludCh0WzBdLCAxNikgJiA4ICYmICh0ID0gXCIwMFwiICsgdCksIHQubGVuZ3RoICYgMSlcbiAgICAgICAgdGhyb3cgbmV3IGUoXCJ1bmV4cGVjdGVkIERFUiBwYXJzaW5nIGFzc2VydGlvbjogdW5wYWRkZWQgaGV4XCIpO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfSxcbiAgICBkZWNvZGUocykge1xuICAgICAgY29uc3QgeyBFcnI6IGUgfSA9IGNzO1xuICAgICAgaWYgKHNbMF0gJiAxMjgpXG4gICAgICAgIHRocm93IG5ldyBlKFwiaW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogbmVnYXRpdmVcIik7XG4gICAgICBpZiAoc1swXSA9PT0gMCAmJiAhKHNbMV0gJiAxMjgpKVxuICAgICAgICB0aHJvdyBuZXcgZShcImludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHVubmVjZXNzYXJ5IGxlYWRpbmcgemVyb1wiKTtcbiAgICAgIHJldHVybiBsYShzKTtcbiAgICB9XG4gIH0sXG4gIHRvU2lnKHMpIHtcbiAgICBjb25zdCB7IEVycjogZSwgX2ludDogdCwgX3RsdjogciB9ID0gY3MsIG4gPSBFdChcInNpZ25hdHVyZVwiLCBzKSwgeyB2OiBpLCBsOiBvIH0gPSByLmRlY29kZSg0OCwgbik7XG4gICAgaWYgKG8ubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IGUoXCJpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nXCIpO1xuICAgIGNvbnN0IHsgdjogYSwgbCB9ID0gci5kZWNvZGUoMiwgaSksIHsgdjogYywgbDogdSB9ID0gci5kZWNvZGUoMiwgbCk7XG4gICAgaWYgKHUubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IGUoXCJpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nXCIpO1xuICAgIHJldHVybiB7IHI6IHQuZGVjb2RlKGEpLCBzOiB0LmRlY29kZShjKSB9O1xuICB9LFxuICBoZXhGcm9tU2lnKHMpIHtcbiAgICBjb25zdCB7IF90bHY6IGUsIF9pbnQ6IHQgfSA9IGNzLCByID0gZS5lbmNvZGUoMiwgdC5lbmNvZGUocy5yKSksIG4gPSBlLmVuY29kZSgyLCB0LmVuY29kZShzLnMpKSwgaSA9IHIgKyBuO1xuICAgIHJldHVybiBlLmVuY29kZSg0OCwgaSk7XG4gIH1cbn0sIGhzID0gQmlnSW50KDApLCBUbiA9IEJpZ0ludCgxKSwgRDAgPSBCaWdJbnQoMiksIEdpID0gQmlnSW50KDMpLCBZdiA9IEJpZ0ludCg0KTtcbmZ1bmN0aW9uIEVuKHMsIGUpIHtcbiAgY29uc3QgeyBCWVRFUzogdCB9ID0gcztcbiAgbGV0IHI7XG4gIGlmICh0eXBlb2YgZSA9PSBcImJpZ2ludFwiKVxuICAgIHIgPSBlO1xuICBlbHNlIHtcbiAgICBsZXQgbiA9IEV0KFwicHJpdmF0ZSBrZXlcIiwgZSk7XG4gICAgdHJ5IHtcbiAgICAgIHIgPSBzLmZyb21CeXRlcyhuKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBwcml2YXRlIGtleTogZXhwZWN0ZWQgdWk4YSBvZiBzaXplICR7dH0sIGdvdCAke3R5cGVvZiBlfWApO1xuICAgIH1cbiAgfVxuICBpZiAoIXMuaXNWYWxpZE5vdDAocikpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwcml2YXRlIGtleTogb3V0IG9mIHJhbmdlIFsxLi5OLTFdXCIpO1xuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIFp2KHMsIGUgPSB7fSkge1xuICBjb25zdCB0ID0gbTAoXCJ3ZWllcnN0cmFzc1wiLCBzLCBlKSwgeyBGcDogciwgRm46IG4gfSA9IHQ7XG4gIGxldCBpID0gdC5DVVJWRTtcbiAgY29uc3QgeyBoOiBvLCBuOiBhIH0gPSBpO1xuICBSaShlLCB7fSwge1xuICAgIGFsbG93SW5maW5pdHlQb2ludDogXCJib29sZWFuXCIsXG4gICAgY2xlYXJDb2ZhY3RvcjogXCJmdW5jdGlvblwiLFxuICAgIGlzVG9yc2lvbkZyZWU6IFwiZnVuY3Rpb25cIixcbiAgICBmcm9tQnl0ZXM6IFwiZnVuY3Rpb25cIixcbiAgICB0b0J5dGVzOiBcImZ1bmN0aW9uXCIsXG4gICAgZW5kbzogXCJvYmplY3RcIixcbiAgICB3cmFwUHJpdmF0ZUtleTogXCJib29sZWFuXCJcbiAgfSk7XG4gIGNvbnN0IHsgZW5kbzogbCB9ID0gZTtcbiAgaWYgKGwgJiYgKCFyLmlzMChpLmEpIHx8IHR5cGVvZiBsLmJldGEgIT0gXCJiaWdpbnRcIiB8fCAhQXJyYXkuaXNBcnJheShsLmJhc2lzZXMpKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW5kbzogZXhwZWN0ZWQgXCJiZXRhXCI6IGJpZ2ludCBhbmQgXCJiYXNpc2VzXCI6IGFycmF5Jyk7XG4gIGNvbnN0IGMgPSBNMChyLCBuKTtcbiAgZnVuY3Rpb24gdSgpIHtcbiAgICBpZiAoIXIuaXNPZGQpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb21wcmVzc2lvbiBpcyBub3Qgc3VwcG9ydGVkOiBGaWVsZCBkb2VzIG5vdCBoYXZlIC5pc09kZCgpXCIpO1xuICB9XG4gIGZ1bmN0aW9uIGQoVywgXywgZykge1xuICAgIGNvbnN0IHsgeCwgeTogdyB9ID0gXy50b0FmZmluZSgpLCBEID0gci50b0J5dGVzKHgpO1xuICAgIGlmIChYcyhnLCBcImlzQ29tcHJlc3NlZFwiKSwgZykge1xuICAgICAgdSgpO1xuICAgICAgY29uc3QgTyA9ICFyLmlzT2RkKHcpO1xuICAgICAgcmV0dXJuIEtyKFAwKE8pLCBEKTtcbiAgICB9IGVsc2VcbiAgICAgIHJldHVybiBLcihVaW50OEFycmF5Lm9mKDQpLCBELCByLnRvQnl0ZXModykpO1xuICB9XG4gIGZ1bmN0aW9uIGgoVykge1xuICAgIE9yKFcsIHZvaWQgMCwgXCJQb2ludFwiKTtcbiAgICBjb25zdCB7IHB1YmxpY0tleTogXywgcHVibGljS2V5VW5jb21wcmVzc2VkOiBnIH0gPSBjLCB4ID0gVy5sZW5ndGgsIHcgPSBXWzBdLCBEID0gVy5zdWJhcnJheSgxKTtcbiAgICBpZiAoeCA9PT0gXyAmJiAodyA9PT0gMiB8fCB3ID09PSAzKSkge1xuICAgICAgY29uc3QgTyA9IHIuZnJvbUJ5dGVzKEQpO1xuICAgICAgaWYgKCFyLmlzVmFsaWQoTykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBwb2ludDogaXMgbm90IG9uIGN1cnZlLCB3cm9uZyB4XCIpO1xuICAgICAgY29uc3QgVSA9IHkoTyk7XG4gICAgICBsZXQgVjtcbiAgICAgIHRyeSB7XG4gICAgICAgIFYgPSByLnNxcnQoVSk7XG4gICAgICB9IGNhdGNoICh2KSB7XG4gICAgICAgIGNvbnN0IFAgPSB2IGluc3RhbmNlb2YgRXJyb3IgPyBcIjogXCIgKyB2Lm1lc3NhZ2UgOiBcIlwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcG9pbnQ6IGlzIG5vdCBvbiBjdXJ2ZSwgc3FydCBlcnJvclwiICsgUCk7XG4gICAgICB9XG4gICAgICB1KCk7XG4gICAgICBjb25zdCBMID0gci5pc09kZChWKTtcbiAgICAgIHJldHVybiAodyAmIDEpID09PSAxICE9PSBMICYmIChWID0gci5uZWcoVikpLCB7IHg6IE8sIHk6IFYgfTtcbiAgICB9IGVsc2UgaWYgKHggPT09IGcgJiYgdyA9PT0gNCkge1xuICAgICAgY29uc3QgTyA9IHIuQllURVMsIFUgPSByLmZyb21CeXRlcyhELnN1YmFycmF5KDAsIE8pKSwgViA9IHIuZnJvbUJ5dGVzKEQuc3ViYXJyYXkoTywgTyAqIDIpKTtcbiAgICAgIGlmICghRShVLCBWKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHBvaW50OiBpcyBub3Qgb24gY3VydmVcIik7XG4gICAgICByZXR1cm4geyB4OiBVLCB5OiBWIH07XG4gICAgfSBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBwb2ludDogZ290IGxlbmd0aCAke3h9LCBleHBlY3RlZCBjb21wcmVzc2VkPSR7X30gb3IgdW5jb21wcmVzc2VkPSR7Z31gKTtcbiAgfVxuICBjb25zdCBmID0gZS50b0J5dGVzIHx8IGQsIHAgPSBlLmZyb21CeXRlcyB8fCBoO1xuICBmdW5jdGlvbiB5KFcpIHtcbiAgICBjb25zdCBfID0gci5zcXIoVyksIGcgPSByLm11bChfLCBXKTtcbiAgICByZXR1cm4gci5hZGQoci5hZGQoZywgci5tdWwoVywgaS5hKSksIGkuYik7XG4gIH1cbiAgZnVuY3Rpb24gRShXLCBfKSB7XG4gICAgY29uc3QgZyA9IHIuc3FyKF8pLCB4ID0geShXKTtcbiAgICByZXR1cm4gci5lcWwoZywgeCk7XG4gIH1cbiAgaWYgKCFFKGkuR3gsIGkuR3kpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBjdXJ2ZSBwYXJhbXM6IGdlbmVyYXRvciBwb2ludFwiKTtcbiAgY29uc3QgYiA9IHIubXVsKHIucG93KGkuYSwgR2kpLCBZdiksIFIgPSByLm11bChyLnNxcihpLmIpLCBCaWdJbnQoMjcpKTtcbiAgaWYgKHIuaXMwKHIuYWRkKGIsIFIpKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgY3VydmUgcGFyYW1zOiBhIG9yIGJcIik7XG4gIGZ1bmN0aW9uIEEoVywgXywgZyA9ICExKSB7XG4gICAgaWYgKCFyLmlzVmFsaWQoXykgfHwgZyAmJiByLmlzMChfKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgYmFkIHBvaW50IGNvb3JkaW5hdGUgJHtXfWApO1xuICAgIHJldHVybiBfO1xuICB9XG4gIGZ1bmN0aW9uIEYoVykge1xuICAgIGlmICghKFcgaW5zdGFuY2VvZiBDKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlByb2plY3RpdmVQb2ludCBleHBlY3RlZFwiKTtcbiAgfVxuICBmdW5jdGlvbiBNKFcpIHtcbiAgICBpZiAoIWwgfHwgIWwuYmFzaXNlcylcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGVuZG9cIik7XG4gICAgcmV0dXJuIFd2KFcsIGwuYmFzaXNlcywgbi5PUkRFUik7XG4gIH1cbiAgY29uc3QgSCA9IE1vKChXLCBfKSA9PiB7XG4gICAgY29uc3QgeyBYOiBnLCBZOiB4LCBaOiB3IH0gPSBXO1xuICAgIGlmIChyLmVxbCh3LCByLk9ORSkpXG4gICAgICByZXR1cm4geyB4OiBnLCB5OiB4IH07XG4gICAgY29uc3QgRCA9IFcuaXMwKCk7XG4gICAgXyA9PSBudWxsICYmIChfID0gRCA/IHIuT05FIDogci5pbnYodykpO1xuICAgIGNvbnN0IE8gPSByLm11bChnLCBfKSwgVSA9IHIubXVsKHgsIF8pLCBWID0gci5tdWwodywgXyk7XG4gICAgaWYgKEQpXG4gICAgICByZXR1cm4geyB4OiByLlpFUk8sIHk6IHIuWkVSTyB9O1xuICAgIGlmICghci5lcWwoViwgci5PTkUpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52WiB3YXMgaW52YWxpZFwiKTtcbiAgICByZXR1cm4geyB4OiBPLCB5OiBVIH07XG4gIH0pLCBLID0gTW8oKFcpID0+IHtcbiAgICBpZiAoVy5pczAoKSkge1xuICAgICAgaWYgKGUuYWxsb3dJbmZpbml0eVBvaW50ICYmICFyLmlzMChXLlkpKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcG9pbnQ6IFpFUk9cIik7XG4gICAgfVxuICAgIGNvbnN0IHsgeDogXywgeTogZyB9ID0gVy50b0FmZmluZSgpO1xuICAgIGlmICghci5pc1ZhbGlkKF8pIHx8ICFyLmlzVmFsaWQoZykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcG9pbnQ6IHggb3IgeSBub3QgZmllbGQgZWxlbWVudHNcIik7XG4gICAgaWYgKCFFKF8sIGcpKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0XCIpO1xuICAgIGlmICghVy5pc1RvcnNpb25GcmVlKCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgcG9pbnQ6IG5vdCBpbiBwcmltZS1vcmRlciBzdWJncm91cFwiKTtcbiAgICByZXR1cm4gITA7XG4gIH0pO1xuICBmdW5jdGlvbiBqKFcsIF8sIGcsIHgsIHcpIHtcbiAgICByZXR1cm4gZyA9IG5ldyBDKHIubXVsKGcuWCwgVyksIGcuWSwgZy5aKSwgXyA9IE9vKHgsIF8pLCBnID0gT28odywgZyksIF8uYWRkKGcpO1xuICB9XG4gIGNsYXNzIEMge1xuICAgIC8qKiBEb2VzIE5PVCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgdmFsaWQuIFVzZSBgLmFzc2VydFZhbGlkaXR5KClgLiAqL1xuICAgIGNvbnN0cnVjdG9yKF8sIGcsIHgpIHtcbiAgICAgIHRoaXMuWCA9IEEoXCJ4XCIsIF8pLCB0aGlzLlkgPSBBKFwieVwiLCBnLCAhMCksIHRoaXMuWiA9IEEoXCJ6XCIsIHgpLCBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBzdGF0aWMgQ1VSVkUoKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgLyoqIERvZXMgTk9UIHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyB2YWxpZC4gVXNlIGAuYXNzZXJ0VmFsaWRpdHkoKWAuICovXG4gICAgc3RhdGljIGZyb21BZmZpbmUoXykge1xuICAgICAgY29uc3QgeyB4OiBnLCB5OiB4IH0gPSBfIHx8IHt9O1xuICAgICAgaWYgKCFfIHx8ICFyLmlzVmFsaWQoZykgfHwgIXIuaXNWYWxpZCh4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhZmZpbmUgcG9pbnRcIik7XG4gICAgICBpZiAoXyBpbnN0YW5jZW9mIEMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInByb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWRcIik7XG4gICAgICByZXR1cm4gci5pczAoZykgJiYgci5pczAoeCkgPyBDLlpFUk8gOiBuZXcgQyhnLCB4LCByLk9ORSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXMoXykge1xuICAgICAgY29uc3QgZyA9IEMuZnJvbUFmZmluZShwKE9yKF8sIHZvaWQgMCwgXCJwb2ludFwiKSkpO1xuICAgICAgcmV0dXJuIGcuYXNzZXJ0VmFsaWRpdHkoKSwgZztcbiAgICB9XG4gICAgc3RhdGljIGZyb21IZXgoXykge1xuICAgICAgcmV0dXJuIEMuZnJvbUJ5dGVzKEV0KFwicG9pbnRIZXhcIiwgXykpO1xuICAgIH1cbiAgICBnZXQgeCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICB9XG4gICAgZ2V0IHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHdpbmRvd1NpemVcbiAgICAgKiBAcGFyYW0gaXNMYXp5IHRydWUgd2lsbCBkZWZlciB0YWJsZSBjb21wdXRhdGlvbiB1bnRpbCB0aGUgZmlyc3QgbXVsdGlwbGljYXRpb25cbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHByZWNvbXB1dGUoXyA9IDgsIGcgPSAhMCkge1xuICAgICAgcmV0dXJuICQuY3JlYXRlQ2FjaGUodGhpcywgXyksIGcgfHwgdGhpcy5tdWx0aXBseShHaSksIHRoaXM7XG4gICAgfVxuICAgIC8vIFRPRE86IHJldHVybiBgdGhpc2BcbiAgICAvKiogQSBwb2ludCBvbiBjdXJ2ZSBpcyB2YWxpZCBpZiBpdCBjb25mb3JtcyB0byBlcXVhdGlvbi4gKi9cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgIEsodGhpcyk7XG4gICAgfVxuICAgIGhhc0V2ZW5ZKCkge1xuICAgICAgY29uc3QgeyB5OiBfIH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICBpZiAoIXIuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3Qgc3VwcG9ydCBpc09kZFwiKTtcbiAgICAgIHJldHVybiAhci5pc09kZChfKTtcbiAgICB9XG4gICAgLyoqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuICovXG4gICAgZXF1YWxzKF8pIHtcbiAgICAgIEYoXyk7XG4gICAgICBjb25zdCB7IFg6IGcsIFk6IHgsIFo6IHcgfSA9IHRoaXMsIHsgWDogRCwgWTogTywgWjogVSB9ID0gXywgViA9IHIuZXFsKHIubXVsKGcsIFUpLCByLm11bChELCB3KSksIEwgPSByLmVxbChyLm11bCh4LCBVKSwgci5tdWwoTywgdykpO1xuICAgICAgcmV0dXJuIFYgJiYgTDtcbiAgICB9XG4gICAgLyoqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLiAqL1xuICAgIG5lZ2F0ZSgpIHtcbiAgICAgIHJldHVybiBuZXcgQyh0aGlzLlgsIHIubmVnKHRoaXMuWSksIHRoaXMuWik7XG4gICAgfVxuICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAzXG4gICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICBkb3VibGUoKSB7XG4gICAgICBjb25zdCB7IGE6IF8sIGI6IGcgfSA9IGksIHggPSByLm11bChnLCBHaSksIHsgWDogdywgWTogRCwgWjogTyB9ID0gdGhpcztcbiAgICAgIGxldCBVID0gci5aRVJPLCBWID0gci5aRVJPLCBMID0gci5aRVJPLCBtID0gci5tdWwodywgdyksIHYgPSByLm11bChELCBEKSwgUCA9IHIubXVsKE8sIE8pLCBOID0gci5tdWwodywgRCk7XG4gICAgICByZXR1cm4gTiA9IHIuYWRkKE4sIE4pLCBMID0gci5tdWwodywgTyksIEwgPSByLmFkZChMLCBMKSwgVSA9IHIubXVsKF8sIEwpLCBWID0gci5tdWwoeCwgUCksIFYgPSByLmFkZChVLCBWKSwgVSA9IHIuc3ViKHYsIFYpLCBWID0gci5hZGQodiwgViksIFYgPSByLm11bChVLCBWKSwgVSA9IHIubXVsKE4sIFUpLCBMID0gci5tdWwoeCwgTCksIFAgPSByLm11bChfLCBQKSwgTiA9IHIuc3ViKG0sIFApLCBOID0gci5tdWwoXywgTiksIE4gPSByLmFkZChOLCBMKSwgTCA9IHIuYWRkKG0sIG0pLCBtID0gci5hZGQoTCwgbSksIG0gPSByLmFkZChtLCBQKSwgbSA9IHIubXVsKG0sIE4pLCBWID0gci5hZGQoViwgbSksIFAgPSByLm11bChELCBPKSwgUCA9IHIuYWRkKFAsIFApLCBtID0gci5tdWwoUCwgTiksIFUgPSByLnN1YihVLCBtKSwgTCA9IHIubXVsKFAsIHYpLCBMID0gci5hZGQoTCwgTCksIEwgPSByLmFkZChMLCBMKSwgbmV3IEMoVSwgViwgTCk7XG4gICAgfVxuICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBhZGRpdGlvbiBmb3JtdWxhLlxuICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgLy8gQ29zdDogMTJNICsgMFMgKyAzKmEgKyAzKmIzICsgMjNhZGQuXG4gICAgYWRkKF8pIHtcbiAgICAgIEYoXyk7XG4gICAgICBjb25zdCB7IFg6IGcsIFk6IHgsIFo6IHcgfSA9IHRoaXMsIHsgWDogRCwgWTogTywgWjogVSB9ID0gXztcbiAgICAgIGxldCBWID0gci5aRVJPLCBMID0gci5aRVJPLCBtID0gci5aRVJPO1xuICAgICAgY29uc3QgdiA9IGkuYSwgUCA9IHIubXVsKGkuYiwgR2kpO1xuICAgICAgbGV0IE4gPSByLm11bChnLCBEKSwgWSA9IHIubXVsKHgsIE8pLCBlZSA9IHIubXVsKHcsIFUpLCBpZSA9IHIuYWRkKGcsIHgpLCBsZSA9IHIuYWRkKEQsIE8pO1xuICAgICAgaWUgPSByLm11bChpZSwgbGUpLCBsZSA9IHIuYWRkKE4sIFkpLCBpZSA9IHIuc3ViKGllLCBsZSksIGxlID0gci5hZGQoZywgdyk7XG4gICAgICBsZXQgVGUgPSByLmFkZChELCBVKTtcbiAgICAgIHJldHVybiBsZSA9IHIubXVsKGxlLCBUZSksIFRlID0gci5hZGQoTiwgZWUpLCBsZSA9IHIuc3ViKGxlLCBUZSksIFRlID0gci5hZGQoeCwgdyksIFYgPSByLmFkZChPLCBVKSwgVGUgPSByLm11bChUZSwgViksIFYgPSByLmFkZChZLCBlZSksIFRlID0gci5zdWIoVGUsIFYpLCBtID0gci5tdWwodiwgbGUpLCBWID0gci5tdWwoUCwgZWUpLCBtID0gci5hZGQoViwgbSksIFYgPSByLnN1YihZLCBtKSwgbSA9IHIuYWRkKFksIG0pLCBMID0gci5tdWwoViwgbSksIFkgPSByLmFkZChOLCBOKSwgWSA9IHIuYWRkKFksIE4pLCBlZSA9IHIubXVsKHYsIGVlKSwgbGUgPSByLm11bChQLCBsZSksIFkgPSByLmFkZChZLCBlZSksIGVlID0gci5zdWIoTiwgZWUpLCBlZSA9IHIubXVsKHYsIGVlKSwgbGUgPSByLmFkZChsZSwgZWUpLCBOID0gci5tdWwoWSwgbGUpLCBMID0gci5hZGQoTCwgTiksIE4gPSByLm11bChUZSwgbGUpLCBWID0gci5tdWwoaWUsIFYpLCBWID0gci5zdWIoViwgTiksIE4gPSByLm11bChpZSwgWSksIG0gPSByLm11bChUZSwgbSksIG0gPSByLmFkZChtLCBOKSwgbmV3IEMoViwgTCwgbSk7XG4gICAgfVxuICAgIHN1YnRyYWN0KF8pIHtcbiAgICAgIHJldHVybiB0aGlzLmFkZChfLm5lZ2F0ZSgpKTtcbiAgICB9XG4gICAgaXMwKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKEMuWkVSTyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICogVXNlcyB3TkFGIG1ldGhvZC4gV2luZG93ZWQgbWV0aG9kIG1heSBiZSAxMCUgZmFzdGVyLFxuICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAqIFVzZXMgZW5kb21vcnBoaXNtIGZvciBLb2JsaXR6IGN1cnZlcy5cbiAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICovXG4gICAgbXVsdGlwbHkoXykge1xuICAgICAgY29uc3QgeyBlbmRvOiBnIH0gPSBlO1xuICAgICAgaWYgKCFuLmlzVmFsaWROb3QwKF8pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHNjYWxhcjogb3V0IG9mIHJhbmdlXCIpO1xuICAgICAgbGV0IHgsIHc7XG4gICAgICBjb25zdCBEID0gKE8pID0+ICQuY2FjaGVkKHRoaXMsIE8sIChVKSA9PiBqcyhDLCBVKSk7XG4gICAgICBpZiAoZykge1xuICAgICAgICBjb25zdCB7IGsxbmVnOiBPLCBrMTogVSwgazJuZWc6IFYsIGsyOiBMIH0gPSBNKF8pLCB7IHA6IG0sIGY6IHYgfSA9IEQoVSksIHsgcDogUCwgZjogTiB9ID0gRChMKTtcbiAgICAgICAgdyA9IHYuYWRkKE4pLCB4ID0gaihnLmJldGEsIG0sIFAsIE8sIFYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBwOiBPLCBmOiBVIH0gPSBEKF8pO1xuICAgICAgICB4ID0gTywgdyA9IFU7XG4gICAgICB9XG4gICAgICByZXR1cm4ganMoQywgW3gsIHddKVswXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAqIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICogYW4gZXhwb3NlZCBzZWNyZXQga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAqL1xuICAgIG11bHRpcGx5VW5zYWZlKF8pIHtcbiAgICAgIGNvbnN0IHsgZW5kbzogZyB9ID0gZSwgeCA9IHRoaXM7XG4gICAgICBpZiAoIW4uaXNWYWxpZChfKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzY2FsYXI6IG91dCBvZiByYW5nZVwiKTtcbiAgICAgIGlmIChfID09PSBocyB8fCB4LmlzMCgpKVxuICAgICAgICByZXR1cm4gQy5aRVJPO1xuICAgICAgaWYgKF8gPT09IFRuKVxuICAgICAgICByZXR1cm4geDtcbiAgICAgIGlmICgkLmhhc0NhY2hlKHRoaXMpKVxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShfKTtcbiAgICAgIGlmIChnKSB7XG4gICAgICAgIGNvbnN0IHsgazFuZWc6IHcsIGsxOiBELCBrMm5lZzogTywgazI6IFUgfSA9IE0oXyksIHsgcDE6IFYsIHAyOiBMIH0gPSBweShDLCB4LCBELCBVKTtcbiAgICAgICAgcmV0dXJuIGooZy5iZXRhLCBWLCBMLCB3LCBPKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICByZXR1cm4gJC51bnNhZmUoeCwgXyk7XG4gICAgfVxuICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKF8sIGcsIHgpIHtcbiAgICAgIGNvbnN0IHcgPSB0aGlzLm11bHRpcGx5VW5zYWZlKGcpLmFkZChfLm11bHRpcGx5VW5zYWZlKHgpKTtcbiAgICAgIHJldHVybiB3LmlzMCgpID8gdm9pZCAwIDogdztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSBpbnZlcnRlZFogWl4tMSAoaW52ZXJ0ZWQgemVybykgLSBvcHRpb25hbCwgcHJlY29tcHV0YXRpb24gaXMgdXNlZnVsIGZvciBpbnZlcnRCYXRjaFxuICAgICAqL1xuICAgIHRvQWZmaW5lKF8pIHtcbiAgICAgIHJldHVybiBIKHRoaXMsIF8pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBQb2ludCBpcyBmcmVlIG9mIHRvcnNpb24gZWxlbWVudHMgKGlzIGluIHByaW1lIHN1Ymdyb3VwKS5cbiAgICAgKiBBbHdheXMgdG9yc2lvbi1mcmVlIGZvciBjb2ZhY3Rvcj0xIGN1cnZlcy5cbiAgICAgKi9cbiAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgY29uc3QgeyBpc1RvcnNpb25GcmVlOiBfIH0gPSBlO1xuICAgICAgcmV0dXJuIG8gPT09IFRuID8gITAgOiBfID8gXyhDLCB0aGlzKSA6ICQudW5zYWZlKHRoaXMsIGEpLmlzMCgpO1xuICAgIH1cbiAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgY29uc3QgeyBjbGVhckNvZmFjdG9yOiBfIH0gPSBlO1xuICAgICAgcmV0dXJuIG8gPT09IFRuID8gdGhpcyA6IF8gPyBfKEMsIHRoaXMpIDogdGhpcy5tdWx0aXBseVVuc2FmZShvKTtcbiAgICB9XG4gICAgaXNTbWFsbE9yZGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUobykuaXMwKCk7XG4gICAgfVxuICAgIHRvQnl0ZXMoXyA9ICEwKSB7XG4gICAgICByZXR1cm4gWHMoXywgXCJpc0NvbXByZXNzZWRcIiksIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSwgZihDLCB0aGlzLCBfKTtcbiAgICB9XG4gICAgdG9IZXgoXyA9ICEwKSB7XG4gICAgICByZXR1cm4gSHModGhpcy50b0J5dGVzKF8pKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICByZXR1cm4gYDxQb2ludCAke3RoaXMuaXMwKCkgPyBcIlpFUk9cIiA6IHRoaXMudG9IZXgoKX0+YDtcbiAgICB9XG4gICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgZ2V0IHB4KCkge1xuICAgICAgcmV0dXJuIHRoaXMuWDtcbiAgICB9XG4gICAgZ2V0IHB5KCkge1xuICAgICAgcmV0dXJuIHRoaXMuWDtcbiAgICB9XG4gICAgZ2V0IHB6KCkge1xuICAgICAgcmV0dXJuIHRoaXMuWjtcbiAgICB9XG4gICAgdG9SYXdCeXRlcyhfID0gITApIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQnl0ZXMoXyk7XG4gICAgfVxuICAgIF9zZXRXaW5kb3dTaXplKF8pIHtcbiAgICAgIHRoaXMucHJlY29tcHV0ZShfKTtcbiAgICB9XG4gICAgc3RhdGljIG5vcm1hbGl6ZVooXykge1xuICAgICAgcmV0dXJuIGpzKEMsIF8pO1xuICAgIH1cbiAgICBzdGF0aWMgbXNtKF8sIGcpIHtcbiAgICAgIHJldHVybiBwMChDLCBuLCBfLCBnKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KF8pIHtcbiAgICAgIHJldHVybiBDLkJBU0UubXVsdGlwbHkoRW4obiwgXykpO1xuICAgIH1cbiAgfVxuICBDLkJBU0UgPSBuZXcgQyhpLkd4LCBpLkd5LCByLk9ORSksIEMuWkVSTyA9IG5ldyBDKHIuWkVSTywgci5PTkUsIHIuWkVSTyksIEMuRnAgPSByLCBDLkZuID0gbjtcbiAgY29uc3QgayA9IG4uQklUUywgJCA9IG5ldyBnMChDLCBlLmVuZG8gPyBNYXRoLmNlaWwoayAvIDIpIDogayk7XG4gIHJldHVybiBDLkJBU0UucHJlY29tcHV0ZSg4KSwgQztcbn1cbmZ1bmN0aW9uIFAwKHMpIHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkub2YocyA/IDIgOiAzKTtcbn1cbmZ1bmN0aW9uIE0wKHMsIGUpIHtcbiAgcmV0dXJuIHtcbiAgICBzZWNyZXRLZXk6IGUuQllURVMsXG4gICAgcHVibGljS2V5OiAxICsgcy5CWVRFUyxcbiAgICBwdWJsaWNLZXlVbmNvbXByZXNzZWQ6IDEgKyAyICogcy5CWVRFUyxcbiAgICBwdWJsaWNLZXlIYXNQcmVmaXg6ICEwLFxuICAgIHNpZ25hdHVyZTogMiAqIGUuQllURVNcbiAgfTtcbn1cbmZ1bmN0aW9uIFh2KHMsIGUgPSB7fSkge1xuICBjb25zdCB7IEZuOiB0IH0gPSBzLCByID0gZS5yYW5kb21CeXRlcyB8fCBxYywgbiA9IE9iamVjdC5hc3NpZ24oTTAocy5GcCwgdCksIHsgc2VlZDogZDAodC5PUkRFUikgfSk7XG4gIGZ1bmN0aW9uIGkoZikge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gISFFbih0LCBmKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbyhmLCBwKSB7XG4gICAgY29uc3QgeyBwdWJsaWNLZXk6IHksIHB1YmxpY0tleVVuY29tcHJlc3NlZDogRSB9ID0gbjtcbiAgICB0cnkge1xuICAgICAgY29uc3QgYiA9IGYubGVuZ3RoO1xuICAgICAgcmV0dXJuIHAgPT09ICEwICYmIGIgIT09IHkgfHwgcCA9PT0gITEgJiYgYiAhPT0gRSA/ICExIDogISFzLmZyb21CeXRlcyhmKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYShmID0gcihuLnNlZWQpKSB7XG4gICAgcmV0dXJuIGh5KE9yKGYsIG4uc2VlZCwgXCJzZWVkXCIpLCB0Lk9SREVSKTtcbiAgfVxuICBmdW5jdGlvbiBsKGYsIHAgPSAhMCkge1xuICAgIHJldHVybiBzLkJBU0UubXVsdGlwbHkoRW4odCwgZikpLnRvQnl0ZXMocCk7XG4gIH1cbiAgZnVuY3Rpb24gYyhmKSB7XG4gICAgY29uc3QgcCA9IGEoZik7XG4gICAgcmV0dXJuIHsgc2VjcmV0S2V5OiBwLCBwdWJsaWNLZXk6IGwocCkgfTtcbiAgfVxuICBmdW5jdGlvbiB1KGYpIHtcbiAgICBpZiAodHlwZW9mIGYgPT0gXCJiaWdpbnRcIilcbiAgICAgIHJldHVybiAhMTtcbiAgICBpZiAoZiBpbnN0YW5jZW9mIHMpXG4gICAgICByZXR1cm4gITA7XG4gICAgY29uc3QgeyBzZWNyZXRLZXk6IHAsIHB1YmxpY0tleTogeSwgcHVibGljS2V5VW5jb21wcmVzc2VkOiBFIH0gPSBuO1xuICAgIGlmICh0LmFsbG93ZWRMZW5ndGhzIHx8IHAgPT09IHkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYiA9IEV0KFwia2V5XCIsIGYpLmxlbmd0aDtcbiAgICByZXR1cm4gYiA9PT0geSB8fCBiID09PSBFO1xuICB9XG4gIGZ1bmN0aW9uIGQoZiwgcCwgeSA9ICEwKSB7XG4gICAgaWYgKHUoZikgPT09ICEwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXlcIik7XG4gICAgaWYgKHUocCkgPT09ICExKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXlcIik7XG4gICAgY29uc3QgRSA9IEVuKHQsIGYpO1xuICAgIHJldHVybiBzLmZyb21IZXgocCkubXVsdGlwbHkoRSkudG9CeXRlcyh5KTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGdldFB1YmxpY0tleTogbCwgZ2V0U2hhcmVkU2VjcmV0OiBkLCBrZXlnZW46IGMsIFBvaW50OiBzLCB1dGlsczoge1xuICAgIGlzVmFsaWRTZWNyZXRLZXk6IGksXG4gICAgaXNWYWxpZFB1YmxpY0tleTogbyxcbiAgICByYW5kb21TZWNyZXRLZXk6IGEsXG4gICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgaXNWYWxpZFByaXZhdGVLZXk6IGksXG4gICAgcmFuZG9tUHJpdmF0ZUtleTogYSxcbiAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiAoZikgPT4gRW4odCwgZiksXG4gICAgcHJlY29tcHV0ZShmID0gOCwgcCA9IHMuQkFTRSkge1xuICAgICAgcmV0dXJuIHAucHJlY29tcHV0ZShmLCAhMSk7XG4gICAgfVxuICB9LCBsZW5ndGhzOiBuIH0pO1xufVxuZnVuY3Rpb24gSnYocywgZSwgdCA9IHt9KSB7XG4gIEhmKGUpLCBSaSh0LCB7fSwge1xuICAgIGhtYWM6IFwiZnVuY3Rpb25cIixcbiAgICBsb3dTOiBcImJvb2xlYW5cIixcbiAgICByYW5kb21CeXRlczogXCJmdW5jdGlvblwiLFxuICAgIGJpdHMyaW50OiBcImZ1bmN0aW9uXCIsXG4gICAgYml0czJpbnRfbW9kTjogXCJmdW5jdGlvblwiXG4gIH0pO1xuICBjb25zdCByID0gdC5yYW5kb21CeXRlcyB8fCBxYywgbiA9IHQuaG1hYyB8fCAoKGcsIC4uLngpID0+IGswKGUsIGcsIEtyKC4uLngpKSksIHsgRnA6IGksIEZuOiBvIH0gPSBzLCB7IE9SREVSOiBhLCBCSVRTOiBsIH0gPSBvLCB7IGtleWdlbjogYywgZ2V0UHVibGljS2V5OiB1LCBnZXRTaGFyZWRTZWNyZXQ6IGQsIHV0aWxzOiBoLCBsZW5ndGhzOiBmIH0gPSBYdihzLCB0KSwgcCA9IHtcbiAgICBwcmVoYXNoOiAhMSxcbiAgICBsb3dTOiB0eXBlb2YgdC5sb3dTID09IFwiYm9vbGVhblwiID8gdC5sb3dTIDogITEsXG4gICAgZm9ybWF0OiB2b2lkIDAsXG4gICAgLy8nY29tcGFjdCcgYXMgRUNEU0FTaWdGb3JtYXQsXG4gICAgZXh0cmFFbnRyb3B5OiAhMVxuICB9LCB5ID0gXCJjb21wYWN0XCI7XG4gIGZ1bmN0aW9uIEUoZykge1xuICAgIGNvbnN0IHggPSBhID4+IFRuO1xuICAgIHJldHVybiBnID4geDtcbiAgfVxuICBmdW5jdGlvbiBiKGcsIHgpIHtcbiAgICBpZiAoIW8uaXNWYWxpZE5vdDAoeCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgc2lnbmF0dXJlICR7Z306IG91dCBvZiByYW5nZSAxLi5Qb2ludC5Gbi5PUkRFUmApO1xuICAgIHJldHVybiB4O1xuICB9XG4gIGZ1bmN0aW9uIFIoZywgeCkge1xuICAgIGVjKHgpO1xuICAgIGNvbnN0IHcgPSBmLnNpZ25hdHVyZSwgRCA9IHggPT09IFwiY29tcGFjdFwiID8gdyA6IHggPT09IFwicmVjb3ZlcmVkXCIgPyB3ICsgMSA6IHZvaWQgMDtcbiAgICByZXR1cm4gT3IoZywgRCwgYCR7eH0gc2lnbmF0dXJlYCk7XG4gIH1cbiAgY2xhc3MgQSB7XG4gICAgY29uc3RydWN0b3IoeCwgdywgRCkge1xuICAgICAgdGhpcy5yID0gYihcInJcIiwgeCksIHRoaXMucyA9IGIoXCJzXCIsIHcpLCBEICE9IG51bGwgJiYgKHRoaXMucmVjb3ZlcnkgPSBEKSwgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CeXRlcyh4LCB3ID0geSkge1xuICAgICAgUih4LCB3KTtcbiAgICAgIGxldCBEO1xuICAgICAgaWYgKHcgPT09IFwiZGVyXCIpIHtcbiAgICAgICAgY29uc3QgeyByOiBMLCBzOiBtIH0gPSBjcy50b1NpZyhPcih4KSk7XG4gICAgICAgIHJldHVybiBuZXcgQShMLCBtKTtcbiAgICAgIH1cbiAgICAgIHcgPT09IFwicmVjb3ZlcmVkXCIgJiYgKEQgPSB4WzBdLCB3ID0gXCJjb21wYWN0XCIsIHggPSB4LnN1YmFycmF5KDEpKTtcbiAgICAgIGNvbnN0IE8gPSBvLkJZVEVTLCBVID0geC5zdWJhcnJheSgwLCBPKSwgViA9IHguc3ViYXJyYXkoTywgTyAqIDIpO1xuICAgICAgcmV0dXJuIG5ldyBBKG8uZnJvbUJ5dGVzKFUpLCBvLmZyb21CeXRlcyhWKSwgRCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tSGV4KHgsIHcpIHtcbiAgICAgIHJldHVybiB0aGlzLmZyb21CeXRlcyhQbyh4KSwgdyk7XG4gICAgfVxuICAgIGFkZFJlY292ZXJ5Qml0KHgpIHtcbiAgICAgIHJldHVybiBuZXcgQSh0aGlzLnIsIHRoaXMucywgeCk7XG4gICAgfVxuICAgIHJlY292ZXJQdWJsaWNLZXkoeCkge1xuICAgICAgY29uc3QgdyA9IGkuT1JERVIsIHsgcjogRCwgczogTywgcmVjb3Zlcnk6IFUgfSA9IHRoaXM7XG4gICAgICBpZiAoVSA9PSBudWxsIHx8ICFbMCwgMSwgMiwgM10uaW5jbHVkZXMoVSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlY292ZXJ5IGlkIGludmFsaWRcIik7XG4gICAgICBpZiAoYSAqIEQwIDwgdyAmJiBVID4gMSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVjb3ZlcnkgaWQgaXMgYW1iaWd1b3VzIGZvciBoPjEgY3VydmVcIik7XG4gICAgICBjb25zdCBMID0gVSA9PT0gMiB8fCBVID09PSAzID8gRCArIGEgOiBEO1xuICAgICAgaWYgKCFpLmlzVmFsaWQoTCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInJlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkXCIpO1xuICAgICAgY29uc3QgbSA9IGkudG9CeXRlcyhMKSwgdiA9IHMuZnJvbUJ5dGVzKEtyKFAwKChVICYgMSkgPT09IDApLCBtKSksIFAgPSBvLmludihMKSwgTiA9IE0oRXQoXCJtc2dIYXNoXCIsIHgpKSwgWSA9IG8uY3JlYXRlKC1OICogUCksIGVlID0gby5jcmVhdGUoTyAqIFApLCBpZSA9IHMuQkFTRS5tdWx0aXBseVVuc2FmZShZKS5hZGQodi5tdWx0aXBseVVuc2FmZShlZSkpO1xuICAgICAgaWYgKGllLmlzMCgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb2ludCBhdCBpbmZpbmlmeVwiKTtcbiAgICAgIHJldHVybiBpZS5hc3NlcnRWYWxpZGl0eSgpLCBpZTtcbiAgICB9XG4gICAgLy8gU2lnbmF0dXJlcyBzaG91bGQgYmUgbG93LXMsIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5LlxuICAgIGhhc0hpZ2hTKCkge1xuICAgICAgcmV0dXJuIEUodGhpcy5zKTtcbiAgICB9XG4gICAgdG9CeXRlcyh4ID0geSkge1xuICAgICAgaWYgKGVjKHgpLCB4ID09PSBcImRlclwiKVxuICAgICAgICByZXR1cm4gUG8oY3MuaGV4RnJvbVNpZyh0aGlzKSk7XG4gICAgICBjb25zdCB3ID0gby50b0J5dGVzKHRoaXMuciksIEQgPSBvLnRvQnl0ZXModGhpcy5zKTtcbiAgICAgIGlmICh4ID09PSBcInJlY292ZXJlZFwiKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY292ZXJ5ID09IG51bGwpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVjb3ZlcnkgYml0IG11c3QgYmUgcHJlc2VudFwiKTtcbiAgICAgICAgcmV0dXJuIEtyKFVpbnQ4QXJyYXkub2YodGhpcy5yZWNvdmVyeSksIHcsIEQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEtyKHcsIEQpO1xuICAgIH1cbiAgICB0b0hleCh4KSB7XG4gICAgICByZXR1cm4gSHModGhpcy50b0J5dGVzKHgpKTtcbiAgICB9XG4gICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQ29tcGFjdCh4KSB7XG4gICAgICByZXR1cm4gQS5mcm9tQnl0ZXMoRXQoXCJzaWdcIiwgeCksIFwiY29tcGFjdFwiKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21ERVIoeCkge1xuICAgICAgcmV0dXJuIEEuZnJvbUJ5dGVzKEV0KFwic2lnXCIsIHgpLCBcImRlclwiKTtcbiAgICB9XG4gICAgbm9ybWFsaXplUygpIHtcbiAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgQSh0aGlzLnIsIG8ubmVnKHRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICB9XG4gICAgdG9ERVJSYXdCeXRlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQnl0ZXMoXCJkZXJcIik7XG4gICAgfVxuICAgIHRvREVSSGV4KCkge1xuICAgICAgcmV0dXJuIEhzKHRoaXMudG9CeXRlcyhcImRlclwiKSk7XG4gICAgfVxuICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9CeXRlcyhcImNvbXBhY3RcIik7XG4gICAgfVxuICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgIHJldHVybiBIcyh0aGlzLnRvQnl0ZXMoXCJjb21wYWN0XCIpKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgRiA9IHQuYml0czJpbnQgfHwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4Lmxlbmd0aCA+IDgxOTIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnB1dCBpcyB0b28gbGFyZ2VcIik7XG4gICAgY29uc3QgdyA9IGxhKHgpLCBEID0geC5sZW5ndGggKiA4IC0gbDtcbiAgICByZXR1cm4gRCA+IDAgPyB3ID4+IEJpZ0ludChEKSA6IHc7XG4gIH0sIE0gPSB0LmJpdHMyaW50X21vZE4gfHwgZnVuY3Rpb24oeCkge1xuICAgIHJldHVybiBvLmNyZWF0ZShGKHgpKTtcbiAgfSwgSCA9IF9pKGwpO1xuICBmdW5jdGlvbiBLKGcpIHtcbiAgICByZXR1cm4gUWwoXCJudW0gPCAyXlwiICsgbCwgZywgaHMsIEgpLCBvLnRvQnl0ZXMoZyk7XG4gIH1cbiAgZnVuY3Rpb24gaihnLCB4KSB7XG4gICAgcmV0dXJuIE9yKGcsIHZvaWQgMCwgXCJtZXNzYWdlXCIpLCB4ID8gT3IoZShnKSwgdm9pZCAwLCBcInByZWhhc2hlZCBtZXNzYWdlXCIpIDogZztcbiAgfVxuICBmdW5jdGlvbiBDKGcsIHgsIHcpIHtcbiAgICBpZiAoW1wicmVjb3ZlcmVkXCIsIFwiY2Fub25pY2FsXCJdLnNvbWUoKFkpID0+IFkgaW4gdykpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICBjb25zdCB7IGxvd1M6IEQsIHByZWhhc2g6IE8sIGV4dHJhRW50cm9weTogVSB9ID0gYWwodywgcCk7XG4gICAgZyA9IGooZywgTyk7XG4gICAgY29uc3QgViA9IE0oZyksIEwgPSBFbihvLCB4KSwgbSA9IFtLKEwpLCBLKFYpXTtcbiAgICBpZiAoVSAhPSBudWxsICYmIFUgIT09ICExKSB7XG4gICAgICBjb25zdCBZID0gVSA9PT0gITAgPyByKGYuc2VjcmV0S2V5KSA6IFU7XG4gICAgICBtLnB1c2goRXQoXCJleHRyYUVudHJvcHlcIiwgWSkpO1xuICAgIH1cbiAgICBjb25zdCB2ID0gS3IoLi4ubSksIFAgPSBWO1xuICAgIGZ1bmN0aW9uIE4oWSkge1xuICAgICAgY29uc3QgZWUgPSBGKFkpO1xuICAgICAgaWYgKCFvLmlzVmFsaWROb3QwKGVlKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgaWUgPSBvLmludihlZSksIGxlID0gcy5CQVNFLm11bHRpcGx5KGVlKS50b0FmZmluZSgpLCBUZSA9IG8uY3JlYXRlKGxlLngpO1xuICAgICAgaWYgKFRlID09PSBocylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgRGUgPSBvLmNyZWF0ZShpZSAqIG8uY3JlYXRlKFAgKyBUZSAqIEwpKTtcbiAgICAgIGlmIChEZSA9PT0gaHMpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCB6ZSA9IChsZS54ID09PSBUZSA/IDAgOiAyKSB8IE51bWJlcihsZS55ICYgVG4pLCBfZSA9IERlO1xuICAgICAgcmV0dXJuIEQgJiYgRShEZSkgJiYgKF9lID0gby5uZWcoRGUpLCB6ZSBePSAxKSwgbmV3IEEoVGUsIF9lLCB6ZSk7XG4gICAgfVxuICAgIHJldHVybiB7IHNlZWQ6IHYsIGsyc2lnOiBOIH07XG4gIH1cbiAgZnVuY3Rpb24gayhnLCB4LCB3ID0ge30pIHtcbiAgICBnID0gRXQoXCJtZXNzYWdlXCIsIGcpO1xuICAgIGNvbnN0IHsgc2VlZDogRCwgazJzaWc6IE8gfSA9IEMoZywgeCwgdyk7XG4gICAgcmV0dXJuIHJ5KGUub3V0cHV0TGVuLCBvLkJZVEVTLCBuKShELCBPKTtcbiAgfVxuICBmdW5jdGlvbiAkKGcpIHtcbiAgICBsZXQgeDtcbiAgICBjb25zdCB3ID0gdHlwZW9mIGcgPT0gXCJzdHJpbmdcIiB8fCBJaShnKSwgRCA9ICF3ICYmIGcgIT09IG51bGwgJiYgdHlwZW9mIGcgPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZy5yID09IFwiYmlnaW50XCIgJiYgdHlwZW9mIGcucyA9PSBcImJpZ2ludFwiO1xuICAgIGlmICghdyAmJiAhRClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2lnbmF0dXJlLCBleHBlY3RlZCBVaW50OEFycmF5LCBoZXggc3RyaW5nIG9yIFNpZ25hdHVyZSBpbnN0YW5jZVwiKTtcbiAgICBpZiAoRClcbiAgICAgIHggPSBuZXcgQShnLnIsIGcucyk7XG4gICAgZWxzZSBpZiAodykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgeCA9IEEuZnJvbUJ5dGVzKEV0KFwic2lnXCIsIGcpLCBcImRlclwiKTtcbiAgICAgIH0gY2F0Y2ggKE8pIHtcbiAgICAgICAgaWYgKCEoTyBpbnN0YW5jZW9mIGNzLkVycikpXG4gICAgICAgICAgdGhyb3cgTztcbiAgICAgIH1cbiAgICAgIGlmICgheClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB4ID0gQS5mcm9tQnl0ZXMoRXQoXCJzaWdcIiwgZyksIFwiY29tcGFjdFwiKTtcbiAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB4IHx8ICExO1xuICB9XG4gIGZ1bmN0aW9uIFcoZywgeCwgdywgRCA9IHt9KSB7XG4gICAgY29uc3QgeyBsb3dTOiBPLCBwcmVoYXNoOiBVLCBmb3JtYXQ6IFYgfSA9IGFsKEQsIHApO1xuICAgIGlmICh3ID0gRXQoXCJwdWJsaWNLZXlcIiwgdyksIHggPSBqKEV0KFwibWVzc2FnZVwiLCB4KSwgVSksIFwic3RyaWN0XCIgaW4gRClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1NcIik7XG4gICAgY29uc3QgTCA9IFYgPT09IHZvaWQgMCA/ICQoZykgOiBBLmZyb21CeXRlcyhFdChcInNpZ1wiLCBnKSwgVik7XG4gICAgaWYgKEwgPT09ICExKVxuICAgICAgcmV0dXJuICExO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBtID0gcy5mcm9tQnl0ZXModyk7XG4gICAgICBpZiAoTyAmJiBMLmhhc0hpZ2hTKCkpXG4gICAgICAgIHJldHVybiAhMTtcbiAgICAgIGNvbnN0IHsgcjogdiwgczogUCB9ID0gTCwgTiA9IE0oeCksIFkgPSBvLmludihQKSwgZWUgPSBvLmNyZWF0ZShOICogWSksIGllID0gby5jcmVhdGUodiAqIFkpLCBsZSA9IHMuQkFTRS5tdWx0aXBseVVuc2FmZShlZSkuYWRkKG0ubXVsdGlwbHlVbnNhZmUoaWUpKTtcbiAgICAgIHJldHVybiBsZS5pczAoKSA/ICExIDogby5jcmVhdGUobGUueCkgPT09IHY7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gITE7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIF8oZywgeCwgdyA9IHt9KSB7XG4gICAgY29uc3QgeyBwcmVoYXNoOiBEIH0gPSBhbCh3LCBwKTtcbiAgICByZXR1cm4geCA9IGooeCwgRCksIEEuZnJvbUJ5dGVzKGcsIFwicmVjb3ZlcmVkXCIpLnJlY292ZXJQdWJsaWNLZXkoeCkudG9CeXRlcygpO1xuICB9XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICBrZXlnZW46IGMsXG4gICAgZ2V0UHVibGljS2V5OiB1LFxuICAgIGdldFNoYXJlZFNlY3JldDogZCxcbiAgICB1dGlsczogaCxcbiAgICBsZW5ndGhzOiBmLFxuICAgIFBvaW50OiBzLFxuICAgIHNpZ246IGssXG4gICAgdmVyaWZ5OiBXLFxuICAgIHJlY292ZXJQdWJsaWNLZXk6IF8sXG4gICAgU2lnbmF0dXJlOiBBLFxuICAgIGhhc2g6IGVcbiAgfSk7XG59XG5mdW5jdGlvbiBRdihzKSB7XG4gIGNvbnN0IGUgPSB7XG4gICAgYTogcy5hLFxuICAgIGI6IHMuYixcbiAgICBwOiBzLkZwLk9SREVSLFxuICAgIG46IHMubixcbiAgICBoOiBzLmgsXG4gICAgR3g6IHMuR3gsXG4gICAgR3k6IHMuR3lcbiAgfSwgdCA9IHMuRnA7XG4gIGxldCByID0gcy5hbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMgPyBBcnJheS5mcm9tKG5ldyBTZXQocy5hbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMubWFwKChvKSA9PiBNYXRoLmNlaWwobyAvIDIpKSkpIDogdm9pZCAwO1xuICBjb25zdCBuID0gZW4oZS5uLCB7XG4gICAgQklUUzogcy5uQml0TGVuZ3RoLFxuICAgIGFsbG93ZWRMZW5ndGhzOiByLFxuICAgIG1vZEZyb21CeXRlczogcy53cmFwUHJpdmF0ZUtleVxuICB9KSwgaSA9IHtcbiAgICBGcDogdCxcbiAgICBGbjogbixcbiAgICBhbGxvd0luZmluaXR5UG9pbnQ6IHMuYWxsb3dJbmZpbml0eVBvaW50LFxuICAgIGVuZG86IHMuZW5kbyxcbiAgICBpc1RvcnNpb25GcmVlOiBzLmlzVG9yc2lvbkZyZWUsXG4gICAgY2xlYXJDb2ZhY3Rvcjogcy5jbGVhckNvZmFjdG9yLFxuICAgIGZyb21CeXRlczogcy5mcm9tQnl0ZXMsXG4gICAgdG9CeXRlczogcy50b0J5dGVzXG4gIH07XG4gIHJldHVybiB7IENVUlZFOiBlLCBjdXJ2ZU9wdHM6IGkgfTtcbn1cbmZ1bmN0aW9uIGVFKHMpIHtcbiAgY29uc3QgeyBDVVJWRTogZSwgY3VydmVPcHRzOiB0IH0gPSBRdihzKSwgciA9IHtcbiAgICBobWFjOiBzLmhtYWMsXG4gICAgcmFuZG9tQnl0ZXM6IHMucmFuZG9tQnl0ZXMsXG4gICAgbG93Uzogcy5sb3dTLFxuICAgIGJpdHMyaW50OiBzLmJpdHMyaW50LFxuICAgIGJpdHMyaW50X21vZE46IHMuYml0czJpbnRfbW9kTlxuICB9O1xuICByZXR1cm4geyBDVVJWRTogZSwgY3VydmVPcHRzOiB0LCBoYXNoOiBzLmhhc2gsIGVjZHNhT3B0czogciB9O1xufVxuZnVuY3Rpb24gdEUocywgZSkge1xuICBjb25zdCB0ID0gZS5Qb2ludDtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGUsIHtcbiAgICBQcm9qZWN0aXZlUG9pbnQ6IHQsXG4gICAgQ1VSVkU6IE9iamVjdC5hc3NpZ24oe30sIHMsIGMwKHQuRm4uT1JERVIsIHQuRm4uQklUUykpXG4gIH0pO1xufVxuZnVuY3Rpb24gckUocykge1xuICBjb25zdCB7IENVUlZFOiBlLCBjdXJ2ZU9wdHM6IHQsIGhhc2g6IHIsIGVjZHNhT3B0czogbiB9ID0gZUUocyksIGkgPSBadihlLCB0KSwgbyA9IEp2KGksIHIsIG4pO1xuICByZXR1cm4gdEUocywgbyk7XG59XG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5mdW5jdGlvbiBzRShzLCBlKSB7XG4gIGNvbnN0IHQgPSAocikgPT4gckUoeyAuLi5zLCBoYXNoOiByIH0pO1xuICByZXR1cm4geyAuLi50KGUpLCBjcmVhdGU6IHQgfTtcbn1cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmNvbnN0IHR1ID0ge1xuICBwOiBCaWdJbnQoXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmZcIiksXG4gIG46IEJpZ0ludChcIjB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MVwiKSxcbiAgaDogQmlnSW50KDEpLFxuICBhOiBCaWdJbnQoMCksXG4gIGI6IEJpZ0ludCg3KSxcbiAgR3g6IEJpZ0ludChcIjB4NzliZTY2N2VmOWRjYmJhYzU1YTA2Mjk1Y2U4NzBiMDcwMjliZmNkYjJkY2UyOGQ5NTlmMjgxNWIxNmY4MTc5OFwiKSxcbiAgR3k6IEJpZ0ludChcIjB4NDgzYWRhNzcyNmEzYzQ2NTVkYTRmYmZjMGUxMTA4YThmZDE3YjQ0OGE2ODU1NDE5OWM0N2QwOGZmYjEwZDRiOFwiKVxufSwgbkUgPSB7XG4gIGJldGE6IEJpZ0ludChcIjB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZVwiKSxcbiAgYmFzaXNlczogW1xuICAgIFtCaWdJbnQoXCIweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1XCIpLCAtQmlnSW50KFwiMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjM1wiKV0sXG4gICAgW0JpZ0ludChcIjB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4XCIpLCBCaWdJbnQoXCIweDMwODZkMjIxYTdkNDZiY2RlODZjOTBlNDkyODRlYjE1XCIpXVxuICBdXG59LCBCZCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMik7XG5mdW5jdGlvbiBpRShzKSB7XG4gIGNvbnN0IGUgPSB0dS5wLCB0ID0gQmlnSW50KDMpLCByID0gQmlnSW50KDYpLCBuID0gQmlnSW50KDExKSwgaSA9IEJpZ0ludCgyMiksIG8gPSBCaWdJbnQoMjMpLCBhID0gQmlnSW50KDQ0KSwgbCA9IEJpZ0ludCg4OCksIGMgPSBzICogcyAqIHMgJSBlLCB1ID0gYyAqIGMgKiBzICUgZSwgZCA9IHZ0KHUsIHQsIGUpICogdSAlIGUsIGggPSB2dChkLCB0LCBlKSAqIHUgJSBlLCBmID0gdnQoaCwgQmQsIGUpICogYyAlIGUsIHAgPSB2dChmLCBuLCBlKSAqIGYgJSBlLCB5ID0gdnQocCwgaSwgZSkgKiBwICUgZSwgRSA9IHZ0KHksIGEsIGUpICogeSAlIGUsIGIgPSB2dChFLCBsLCBlKSAqIEUgJSBlLCBSID0gdnQoYiwgYSwgZSkgKiB5ICUgZSwgQSA9IHZ0KFIsIHQsIGUpICogdSAlIGUsIEYgPSB2dChBLCBvLCBlKSAqIHAgJSBlLCBNID0gdnQoRiwgciwgZSkgKiBjICUgZSwgSCA9IHZ0KE0sIEJkLCBlKTtcbiAgaWYgKCF0Yy5lcWwodGMuc3FyKEgpLCBzKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBzcXVhcmUgcm9vdFwiKTtcbiAgcmV0dXJuIEg7XG59XG5jb25zdCB0YyA9IGVuKHR1LnAsIHsgc3FydDogaUUgfSksIG9FID0gc0UoeyAuLi50dSwgRnA6IHRjLCBsb3dTOiAhMCwgZW5kbzogbkUgfSwgWGYpO1xuTGkudXRpbHMucmFuZG9tUHJpdmF0ZUtleTtcbkxpLmdldFB1YmxpY0tleTtcbmZ1bmN0aW9uIEZkKHMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gTGkuRXh0ZW5kZWRQb2ludC5mcm9tSGV4KHMpLCAhMDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5jb25zdCBPMCA9IChzLCBlKSA9PiBMaS5zaWduKHMsIGUuc2xpY2UoMCwgMzIpKSwgYUUgPSBMaS52ZXJpZnksIHJ1ID0gKHMpID0+IEhlLkJ1ZmZlci5pc0J1ZmZlcihzKSA/IHMgOiBzIGluc3RhbmNlb2YgVWludDhBcnJheSA/IEhlLkJ1ZmZlci5mcm9tKHMuYnVmZmVyLCBzLmJ5dGVPZmZzZXQsIHMuYnl0ZUxlbmd0aCkgOiBIZS5CdWZmZXIuZnJvbShzKTtcbmNsYXNzIGxFIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgZSk7XG4gIH1cbiAgZW5jb2RlKCkge1xuICAgIHJldHVybiBIZS5CdWZmZXIuZnJvbShKYS5zZXJpYWxpemUodW8sIHRoaXMpKTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlKGUpIHtcbiAgICByZXR1cm4gSmEuZGVzZXJpYWxpemUodW8sIHRoaXMsIGUpO1xuICB9XG4gIHN0YXRpYyBkZWNvZGVVbmNoZWNrZWQoZSkge1xuICAgIHJldHVybiBKYS5kZXNlcmlhbGl6ZVVuY2hlY2tlZCh1bywgdGhpcywgZSk7XG4gIH1cbn1cbmNvbnN0IHVvID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbnZhciBCMDtcbmNvbnN0IGNFID0gMzIsIGtzID0gMzI7XG5mdW5jdGlvbiB1RShzKSB7XG4gIHJldHVybiBzLl9ibiAhPT0gdm9pZCAwO1xufVxubGV0IE5kID0gMTtcbmNsYXNzIE9lIGV4dGVuZHMgbEUge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFB1YmxpY0tleSBvYmplY3RcbiAgICogQHBhcmFtIHZhbHVlIGVkMjU1MTkgcHVibGljIGtleSBhcyBidWZmZXIgb3IgYmFzZS01OCBlbmNvZGVkIHN0cmluZ1xuICAgKi9cbiAgY29uc3RydWN0b3IoZSkge1xuICAgIGlmIChzdXBlcih7fSksIHRoaXMuX2JuID0gdm9pZCAwLCB1RShlKSlcbiAgICAgIHRoaXMuX2JuID0gZS5fYm47XG4gICAgZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCB0ID0gYXIuZGVjb2RlKGUpO1xuICAgICAgICBpZiAodC5sZW5ndGggIT0ga3MpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwdWJsaWMga2V5IGlucHV0XCIpO1xuICAgICAgICB0aGlzLl9ibiA9IG5ldyBiZCh0KTtcbiAgICAgIH0gZWxzZVxuICAgICAgICB0aGlzLl9ibiA9IG5ldyBiZChlKTtcbiAgICAgIGlmICh0aGlzLl9ibi5ieXRlTGVuZ3RoKCkgPiBrcylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwdWJsaWMga2V5IGlucHV0XCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBhIHVuaXF1ZSBQdWJsaWNLZXkgZm9yIHRlc3RzIGFuZCBiZW5jaG1hcmtzIHVzaW5nIGEgY291bnRlclxuICAgKi9cbiAgc3RhdGljIHVuaXF1ZSgpIHtcbiAgICBjb25zdCBlID0gbmV3IE9lKE5kKTtcbiAgICByZXR1cm4gTmQgKz0gMSwgbmV3IE9lKGUudG9CdWZmZXIoKSk7XG4gIH1cbiAgLyoqXG4gICAqIERlZmF1bHQgcHVibGljIGtleSB2YWx1ZS4gVGhlIGJhc2U1OC1lbmNvZGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBpcyBhbGwgb25lcyAoYXMgc2VlbiBiZWxvdylcbiAgICogVGhlIHVuZGVybHlpbmcgQk4gbnVtYmVyIGlzIDMyIGJ5dGVzIHRoYXQgYXJlIGFsbCB6ZXJvc1xuICAgKi9cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0d28gcHVibGljS2V5cyBhcmUgZXF1YWxcbiAgICovXG4gIGVxdWFscyhlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JuLmVxKGUuX2JuKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBiYXNlLTU4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5XG4gICAqL1xuICB0b0Jhc2U1OCgpIHtcbiAgICByZXR1cm4gYXIuZW5jb2RlKHRoaXMudG9CeXRlcygpKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CYXNlNTgoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBieXRlIGFycmF5IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5IGluIGJpZyBlbmRpYW5cbiAgICovXG4gIHRvQnl0ZXMoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMudG9CdWZmZXIoKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZS5idWZmZXIsIGUuYnl0ZU9mZnNldCwgZS5ieXRlTGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIHRoZSBCdWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXkgaW4gYmlnIGVuZGlhblxuICAgKi9cbiAgdG9CdWZmZXIoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuX2JuLnRvQXJyYXlMaWtlKEhlLkJ1ZmZlcik7XG4gICAgaWYgKGUubGVuZ3RoID09PSBrcylcbiAgICAgIHJldHVybiBlO1xuICAgIGNvbnN0IHQgPSBIZS5CdWZmZXIuYWxsb2MoMzIpO1xuICAgIHJldHVybiBlLmNvcHkodCwgMzIgLSBlLmxlbmd0aCksIHQ7XG4gIH1cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCkge1xuICAgIHJldHVybiBgUHVibGljS2V5KCR7dGhpcy50b1N0cmluZygpfSlgO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGJhc2UtNTggcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICovXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLnRvQmFzZTU4KCk7XG4gIH1cbiAgLyoqXG4gICAqIERlcml2ZSBhIHB1YmxpYyBrZXkgZnJvbSBhbm90aGVyIGtleSwgYSBzZWVkLCBhbmQgYSBwcm9ncmFtIElELlxuICAgKiBUaGUgcHJvZ3JhbSBJRCB3aWxsIGFsc28gc2VydmUgYXMgdGhlIG93bmVyIG9mIHRoZSBwdWJsaWMga2V5LCBnaXZpbmdcbiAgICogaXQgcGVybWlzc2lvbiB0byB3cml0ZSBkYXRhIHRvIHRoZSBhY2NvdW50LlxuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1hd2FpdCAqL1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlV2l0aFNlZWQoZSwgdCwgcikge1xuICAgIGNvbnN0IG4gPSBIZS5CdWZmZXIuY29uY2F0KFtlLnRvQnVmZmVyKCksIEhlLkJ1ZmZlci5mcm9tKHQpLCByLnRvQnVmZmVyKCldKSwgaSA9IElkKG4pO1xuICAgIHJldHVybiBuZXcgT2UoaSk7XG4gIH1cbiAgLyoqXG4gICAqIERlcml2ZSBhIHByb2dyYW0gYWRkcmVzcyBmcm9tIHNlZWRzIGFuZCBhIHByb2dyYW0gSUQuXG4gICAqL1xuICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIHN0YXRpYyBjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmMoZSwgdCkge1xuICAgIGxldCByID0gSGUuQnVmZmVyLmFsbG9jKDApO1xuICAgIGUuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICBpZiAoaS5sZW5ndGggPiBjRSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk1heCBzZWVkIGxlbmd0aCBleGNlZWRlZFwiKTtcbiAgICAgIHIgPSBIZS5CdWZmZXIuY29uY2F0KFtyLCBydShpKV0pO1xuICAgIH0pLCByID0gSGUuQnVmZmVyLmNvbmNhdChbciwgdC50b0J1ZmZlcigpLCBIZS5CdWZmZXIuZnJvbShcIlByb2dyYW1EZXJpdmVkQWRkcmVzc1wiKV0pO1xuICAgIGNvbnN0IG4gPSBJZChyKTtcbiAgICBpZiAoRmQobikpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNlZWRzLCBhZGRyZXNzIG11c3QgZmFsbCBvZmYgdGhlIGN1cnZlXCIpO1xuICAgIHJldHVybiBuZXcgT2Uobik7XG4gIH1cbiAgLyoqXG4gICAqIEFzeW5jIHZlcnNpb24gb2YgY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jXG4gICAqIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGNyZWF0ZVByb2dyYW1BZGRyZXNzU3luY30gaW5zdGVhZFxuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1hd2FpdCAqL1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlUHJvZ3JhbUFkZHJlc3MoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVByb2dyYW1BZGRyZXNzU3luYyhlLCB0KTtcbiAgfVxuICAvKipcbiAgICogRmluZCBhIHZhbGlkIHByb2dyYW0gYWRkcmVzc1xuICAgKlxuICAgKiBWYWxpZCBwcm9ncmFtIGFkZHJlc3NlcyBtdXN0IGZhbGwgb2ZmIHRoZSBlZDI1NTE5IGN1cnZlLiAgVGhpcyBmdW5jdGlvblxuICAgKiBpdGVyYXRlcyBhIG5vbmNlIHVudGlsIGl0IGZpbmRzIG9uZSB0aGF0IHdoZW4gY29tYmluZWQgd2l0aCB0aGUgc2VlZHNcbiAgICogcmVzdWx0cyBpbiBhIHZhbGlkIHByb2dyYW0gYWRkcmVzcy5cbiAgICovXG4gIHN0YXRpYyBmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jKGUsIHQpIHtcbiAgICBsZXQgciA9IDI1NSwgbjtcbiAgICBmb3IgKDsgciAhPSAwOyApIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGkgPSBlLmNvbmNhdChIZS5CdWZmZXIuZnJvbShbcl0pKTtcbiAgICAgICAgbiA9IHRoaXMuY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jKGksIHQpO1xuICAgICAgfSBjYXRjaCAoaSkge1xuICAgICAgICBpZiAoaSBpbnN0YW5jZW9mIFR5cGVFcnJvcilcbiAgICAgICAgICB0aHJvdyBpO1xuICAgICAgICByLS07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtuLCByXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZpbmQgYSB2aWFibGUgcHJvZ3JhbSBhZGRyZXNzIG5vbmNlXCIpO1xuICB9XG4gIC8qKlxuICAgKiBBc3luYyB2ZXJzaW9uIG9mIGZpbmRQcm9ncmFtQWRkcmVzc1N5bmNcbiAgICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgZmluZFByb2dyYW1BZGRyZXNzU3luY30gaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGFzeW5jIGZpbmRQcm9ncmFtQWRkcmVzcyhlLCB0KSB7XG4gICAgcmV0dXJuIHRoaXMuZmluZFByb2dyYW1BZGRyZXNzU3luYyhlLCB0KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgdGhhdCBhIHB1YmtleSBpcyBvbiB0aGUgZWQyNTUxOSBjdXJ2ZS5cbiAgICovXG4gIHN0YXRpYyBpc09uQ3VydmUoZSkge1xuICAgIGNvbnN0IHQgPSBuZXcgT2UoZSk7XG4gICAgcmV0dXJuIEZkKHQudG9CeXRlcygpKTtcbiAgfVxufVxuQjAgPSBPZTtcbk9lLmRlZmF1bHQgPSBuZXcgQjAoXCIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVwiKTtcbnVvLnNldChPZSwge1xuICBraW5kOiBcInN0cnVjdFwiLFxuICBmaWVsZHM6IFtbXCJfYm5cIiwgXCJ1MjU2XCJdXVxufSk7XG5uZXcgT2UoXCJCUEZMb2FkZXIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXCIpO1xuY29uc3Qgd24gPSAxMjMyLCBzdSA9IDEyNywgR28gPSA2NDtcbmNsYXNzIFZvIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSB2b2lkIDAsIHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IHZvaWQgMCwgdGhpcy5zdGF0aWNBY2NvdW50S2V5cyA9IGUsIHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IHQ7XG4gIH1cbiAga2V5U2VnbWVudHMoKSB7XG4gICAgY29uc3QgZSA9IFt0aGlzLnN0YXRpY0FjY291bnRLZXlzXTtcbiAgICByZXR1cm4gdGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzICYmIChlLnB1c2godGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLndyaXRhYmxlKSwgZS5wdXNoKHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3Vwcy5yZWFkb25seSkpLCBlO1xuICB9XG4gIGdldChlKSB7XG4gICAgZm9yIChjb25zdCB0IG9mIHRoaXMua2V5U2VnbWVudHMoKSkge1xuICAgICAgaWYgKGUgPCB0Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHRbZV07XG4gICAgICBlIC09IHQubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmtleVNlZ21lbnRzKCkuZmxhdCgpLmxlbmd0aDtcbiAgfVxuICBjb21waWxlSW5zdHJ1Y3Rpb25zKGUpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAyNTYpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBY2NvdW50IGluZGV4IG92ZXJmbG93IGVuY291bnRlcmVkIGR1cmluZyBjb21waWxhdGlvblwiKTtcbiAgICBjb25zdCByID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICB0aGlzLmtleVNlZ21lbnRzKCkuZmxhdCgpLmZvckVhY2goKGksIG8pID0+IHtcbiAgICAgIHIuc2V0KGkudG9CYXNlNTgoKSwgbyk7XG4gICAgfSk7XG4gICAgY29uc3QgbiA9IChpKSA9PiB7XG4gICAgICBjb25zdCBvID0gci5nZXQoaS50b0Jhc2U1OCgpKTtcbiAgICAgIGlmIChvID09PSB2b2lkIDApIHRocm93IG5ldyBFcnJvcihcIkVuY291bnRlcmVkIGFuIHVua25vd24gaW5zdHJ1Y3Rpb24gYWNjb3VudCBrZXkgZHVyaW5nIGNvbXBpbGF0aW9uXCIpO1xuICAgICAgcmV0dXJuIG87XG4gICAgfTtcbiAgICByZXR1cm4gZS5tYXAoKGkpID0+ICh7XG4gICAgICBwcm9ncmFtSWRJbmRleDogbihpLnByb2dyYW1JZCksXG4gICAgICBhY2NvdW50S2V5SW5kZXhlczogaS5rZXlzLm1hcCgobykgPT4gbihvLnB1YmtleSkpLFxuICAgICAgZGF0YTogaS5kYXRhXG4gICAgfSkpO1xuICB9XG59XG5jb25zdCBXZSA9IChzID0gXCJwdWJsaWNLZXlcIikgPT4gei5ibG9iKDMyLCBzKSwgZEUgPSAocyA9IFwic2lnbmF0dXJlXCIpID0+IHouYmxvYig2NCwgcyksIHhuID0gKHMgPSBcInN0cmluZ1wiKSA9PiB7XG4gIGNvbnN0IGUgPSB6LnN0cnVjdChbei51MzIoXCJsZW5ndGhcIiksIHoudTMyKFwibGVuZ3RoUGFkZGluZ1wiKSwgei5ibG9iKHoub2Zmc2V0KHoudTMyKCksIC04KSwgXCJjaGFyc1wiKV0sIHMpLCB0ID0gZS5kZWNvZGUuYmluZChlKSwgciA9IGUuZW5jb2RlLmJpbmQoZSksIG4gPSBlO1xuICByZXR1cm4gbi5kZWNvZGUgPSAoaSwgbykgPT4gdChpLCBvKS5jaGFycy50b1N0cmluZygpLCBuLmVuY29kZSA9IChpLCBvLCBhKSA9PiB7XG4gICAgY29uc3QgbCA9IHtcbiAgICAgIGNoYXJzOiBIZS5CdWZmZXIuZnJvbShpLCBcInV0ZjhcIilcbiAgICB9O1xuICAgIHJldHVybiByKGwsIG8sIGEpO1xuICB9LCBuLmFsbG9jID0gKGkpID0+IHoudTMyKCkuc3BhbiArIHoudTMyKCkuc3BhbiArIEhlLkJ1ZmZlci5mcm9tKGksIFwidXRmOFwiKS5sZW5ndGgsIG47XG59LCBoRSA9IChzID0gXCJhdXRob3JpemVkXCIpID0+IHouc3RydWN0KFtXZShcInN0YWtlclwiKSwgV2UoXCJ3aXRoZHJhd2VyXCIpXSwgcyksIGZFID0gKHMgPSBcImxvY2t1cFwiKSA9PiB6LnN0cnVjdChbei5uczY0KFwidW5peFRpbWVzdGFtcFwiKSwgei5uczY0KFwiZXBvY2hcIiksIFdlKFwiY3VzdG9kaWFuXCIpXSwgcyksIGdFID0gKHMgPSBcInZvdGVJbml0XCIpID0+IHouc3RydWN0KFtXZShcIm5vZGVQdWJrZXlcIiksIFdlKFwiYXV0aG9yaXplZFZvdGVyXCIpLCBXZShcImF1dGhvcml6ZWRXaXRoZHJhd2VyXCIpLCB6LnU4KFwiY29tbWlzc2lvblwiKV0sIHMpLCBwRSA9IChzID0gXCJ2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzXCIpID0+IHouc3RydWN0KFt6LnUzMihcInZvdGVBdXRob3JpemF0aW9uVHlwZVwiKSwgV2UoXCJjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5XCIpLCB4bihcImN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZFwiKSwgV2UoXCJuZXdBdXRob3JpemVkXCIpXSwgcyk7XG5mdW5jdGlvbiBFcihzKSB7XG4gIGxldCBlID0gMCwgdCA9IDA7XG4gIGZvciAoOyA7ICkge1xuICAgIGxldCByID0gcy5zaGlmdCgpO1xuICAgIGlmIChlIHw9IChyICYgMTI3KSA8PCB0ICogNywgdCArPSAxLCAociAmIDEyOCkgPT09IDApXG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHhyKHMsIGUpIHtcbiAgbGV0IHQgPSBlO1xuICBmb3IgKDsgOyApIHtcbiAgICBsZXQgciA9IHQgJiAxMjc7XG4gICAgaWYgKHQgPj49IDcsIHQgPT0gMCkge1xuICAgICAgcy5wdXNoKHIpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlXG4gICAgICByIHw9IDEyOCwgcy5wdXNoKHIpO1xuICB9XG59XG5mdW5jdGlvbiBLdChzLCBlKSB7XG4gIGlmICghcylcbiAgICB0aHJvdyBuZXcgRXJyb3IoZSB8fCBcIkFzc2VydGlvbiBmYWlsZWRcIik7XG59XG5jbGFzcyBmYSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLnBheWVyID0gdm9pZCAwLCB0aGlzLmtleU1ldGFNYXAgPSB2b2lkIDAsIHRoaXMucGF5ZXIgPSBlLCB0aGlzLmtleU1ldGFNYXAgPSB0O1xuICB9XG4gIHN0YXRpYyBjb21waWxlKGUsIHQpIHtcbiAgICBjb25zdCByID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgbiA9IChvKSA9PiB7XG4gICAgICBjb25zdCBhID0gby50b0Jhc2U1OCgpO1xuICAgICAgbGV0IGwgPSByLmdldChhKTtcbiAgICAgIHJldHVybiBsID09PSB2b2lkIDAgJiYgKGwgPSB7XG4gICAgICAgIGlzU2lnbmVyOiAhMSxcbiAgICAgICAgaXNXcml0YWJsZTogITEsXG4gICAgICAgIGlzSW52b2tlZDogITFcbiAgICAgIH0sIHIuc2V0KGEsIGwpKSwgbDtcbiAgICB9LCBpID0gbih0KTtcbiAgICBpLmlzU2lnbmVyID0gITAsIGkuaXNXcml0YWJsZSA9ICEwO1xuICAgIGZvciAoY29uc3QgbyBvZiBlKSB7XG4gICAgICBuKG8ucHJvZ3JhbUlkKS5pc0ludm9rZWQgPSAhMDtcbiAgICAgIGZvciAoY29uc3QgYSBvZiBvLmtleXMpIHtcbiAgICAgICAgY29uc3QgbCA9IG4oYS5wdWJrZXkpO1xuICAgICAgICBsLmlzU2lnbmVyIHx8IChsLmlzU2lnbmVyID0gYS5pc1NpZ25lciksIGwuaXNXcml0YWJsZSB8fCAobC5pc1dyaXRhYmxlID0gYS5pc1dyaXRhYmxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBmYSh0LCByKTtcbiAgfVxuICBnZXRNZXNzYWdlQ29tcG9uZW50cygpIHtcbiAgICBjb25zdCBlID0gWy4uLnRoaXMua2V5TWV0YU1hcC5lbnRyaWVzKCldO1xuICAgIEt0KGUubGVuZ3RoIDw9IDI1NiwgXCJNYXggc3RhdGljIGFjY291bnQga2V5cyBsZW5ndGggZXhjZWVkZWRcIik7XG4gICAgY29uc3QgdCA9IGUuZmlsdGVyKChbLCBsXSkgPT4gbC5pc1NpZ25lciAmJiBsLmlzV3JpdGFibGUpLCByID0gZS5maWx0ZXIoKFssIGxdKSA9PiBsLmlzU2lnbmVyICYmICFsLmlzV3JpdGFibGUpLCBuID0gZS5maWx0ZXIoKFssIGxdKSA9PiAhbC5pc1NpZ25lciAmJiBsLmlzV3JpdGFibGUpLCBpID0gZS5maWx0ZXIoKFssIGxdKSA9PiAhbC5pc1NpZ25lciAmJiAhbC5pc1dyaXRhYmxlKSwgbyA9IHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogdC5sZW5ndGggKyByLmxlbmd0aCxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IHIubGVuZ3RoLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiBpLmxlbmd0aFxuICAgIH07XG4gICAge1xuICAgICAgS3QodC5sZW5ndGggPiAwLCBcIkV4cGVjdGVkIGF0IGxlYXN0IG9uZSB3cml0YWJsZSBzaWduZXIga2V5XCIpO1xuICAgICAgY29uc3QgW2xdID0gdFswXTtcbiAgICAgIEt0KGwgPT09IHRoaXMucGF5ZXIudG9CYXNlNTgoKSwgXCJFeHBlY3RlZCBmaXJzdCB3cml0YWJsZSBzaWduZXIga2V5IHRvIGJlIHRoZSBmZWUgcGF5ZXJcIik7XG4gICAgfVxuICAgIGNvbnN0IGEgPSBbLi4udC5tYXAoKFtsXSkgPT4gbmV3IE9lKGwpKSwgLi4uci5tYXAoKFtsXSkgPT4gbmV3IE9lKGwpKSwgLi4ubi5tYXAoKFtsXSkgPT4gbmV3IE9lKGwpKSwgLi4uaS5tYXAoKFtsXSkgPT4gbmV3IE9lKGwpKV07XG4gICAgcmV0dXJuIFtvLCBhXTtcbiAgfVxuICBleHRyYWN0VGFibGVMb29rdXAoZSkge1xuICAgIGNvbnN0IFt0LCByXSA9IHRoaXMuZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlKGUuc3RhdGUuYWRkcmVzc2VzLCAobykgPT4gIW8uaXNTaWduZXIgJiYgIW8uaXNJbnZva2VkICYmIG8uaXNXcml0YWJsZSksIFtuLCBpXSA9IHRoaXMuZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlKGUuc3RhdGUuYWRkcmVzc2VzLCAobykgPT4gIW8uaXNTaWduZXIgJiYgIW8uaXNJbnZva2VkICYmICFvLmlzV3JpdGFibGUpO1xuICAgIGlmICghKHQubGVuZ3RoID09PSAwICYmIG4ubGVuZ3RoID09PSAwKSlcbiAgICAgIHJldHVybiBbe1xuICAgICAgICBhY2NvdW50S2V5OiBlLmtleSxcbiAgICAgICAgd3JpdGFibGVJbmRleGVzOiB0LFxuICAgICAgICByZWFkb25seUluZGV4ZXM6IG5cbiAgICAgIH0sIHtcbiAgICAgICAgd3JpdGFibGU6IHIsXG4gICAgICAgIHJlYWRvbmx5OiBpXG4gICAgICB9XTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGRyYWluS2V5c0ZvdW5kSW5Mb29rdXBUYWJsZShlLCB0KSB7XG4gICAgY29uc3QgciA9IG5ldyBBcnJheSgpLCBuID0gbmV3IEFycmF5KCk7XG4gICAgZm9yIChjb25zdCBbaSwgb10gb2YgdGhpcy5rZXlNZXRhTWFwLmVudHJpZXMoKSlcbiAgICAgIGlmICh0KG8pKSB7XG4gICAgICAgIGNvbnN0IGEgPSBuZXcgT2UoaSksIGwgPSBlLmZpbmRJbmRleCgoYykgPT4gYy5lcXVhbHMoYSkpO1xuICAgICAgICBsID49IDAgJiYgKEt0KGwgPCAyNTYsIFwiTWF4IGxvb2t1cCB0YWJsZSBpbmRleCBleGNlZWRlZFwiKSwgci5wdXNoKGwpLCBuLnB1c2goYSksIHRoaXMua2V5TWV0YU1hcC5kZWxldGUoaSkpO1xuICAgICAgfVxuICAgIHJldHVybiBbciwgbl07XG4gIH1cbn1cbmNvbnN0IEYwID0gXCJSZWFjaGVkIGVuZCBvZiBidWZmZXIgdW5leHBlY3RlZGx5XCI7XG5mdW5jdGlvbiBkcyhzKSB7XG4gIGlmIChzLmxlbmd0aCA9PT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoRjApO1xuICByZXR1cm4gcy5zaGlmdCgpO1xufVxuZnVuY3Rpb24gU3IocywgLi4uZSkge1xuICBjb25zdCBbdF0gPSBlO1xuICBpZiAoZS5sZW5ndGggPT09IDIgPyB0ICsgKGVbMV0gPz8gMCkgPiBzLmxlbmd0aCA6IHQgPj0gcy5sZW5ndGgpXG4gICAgdGhyb3cgbmV3IEVycm9yKEYwKTtcbiAgcmV0dXJuIHMuc3BsaWNlKC4uLmUpO1xufVxuY2xhc3MgTW4ge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5oZWFkZXIgPSB2b2lkIDAsIHRoaXMuYWNjb3VudEtleXMgPSB2b2lkIDAsIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwLCB0aGlzLmluc3RydWN0aW9ucyA9IHZvaWQgMCwgdGhpcy5pbmRleFRvUHJvZ3JhbUlkcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHRoaXMuaGVhZGVyID0gZS5oZWFkZXIsIHRoaXMuYWNjb3VudEtleXMgPSBlLmFjY291bnRLZXlzLm1hcCgodCkgPT4gbmV3IE9lKHQpKSwgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBlLnJlY2VudEJsb2NraGFzaCwgdGhpcy5pbnN0cnVjdGlvbnMgPSBlLmluc3RydWN0aW9ucywgdGhpcy5pbnN0cnVjdGlvbnMuZm9yRWFjaCgodCkgPT4gdGhpcy5pbmRleFRvUHJvZ3JhbUlkcy5zZXQodC5wcm9ncmFtSWRJbmRleCwgdGhpcy5hY2NvdW50S2V5c1t0LnByb2dyYW1JZEluZGV4XSkpO1xuICB9XG4gIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiBcImxlZ2FjeVwiO1xuICB9XG4gIGdldCBzdGF0aWNBY2NvdW50S2V5cygpIHtcbiAgICByZXR1cm4gdGhpcy5hY2NvdW50S2V5cztcbiAgfVxuICBnZXQgY29tcGlsZWRJbnN0cnVjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25zLm1hcCgoZSkgPT4gKHtcbiAgICAgIHByb2dyYW1JZEluZGV4OiBlLnByb2dyYW1JZEluZGV4LFxuICAgICAgYWNjb3VudEtleUluZGV4ZXM6IGUuYWNjb3VudHMsXG4gICAgICBkYXRhOiBhci5kZWNvZGUoZS5kYXRhKVxuICAgIH0pKTtcbiAgfVxuICBnZXQgYWRkcmVzc1RhYmxlTG9va3VwcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0QWNjb3VudEtleXMoKSB7XG4gICAgcmV0dXJuIG5ldyBWbyh0aGlzLnN0YXRpY0FjY291bnRLZXlzKTtcbiAgfVxuICBzdGF0aWMgY29tcGlsZShlKSB7XG4gICAgY29uc3QgdCA9IGZhLmNvbXBpbGUoZS5pbnN0cnVjdGlvbnMsIGUucGF5ZXJLZXkpLCBbciwgbl0gPSB0LmdldE1lc3NhZ2VDb21wb25lbnRzKCksIG8gPSBuZXcgVm8obikuY29tcGlsZUluc3RydWN0aW9ucyhlLmluc3RydWN0aW9ucykubWFwKChhKSA9PiAoe1xuICAgICAgcHJvZ3JhbUlkSW5kZXg6IGEucHJvZ3JhbUlkSW5kZXgsXG4gICAgICBhY2NvdW50czogYS5hY2NvdW50S2V5SW5kZXhlcyxcbiAgICAgIGRhdGE6IGFyLmVuY29kZShhLmRhdGEpXG4gICAgfSkpO1xuICAgIHJldHVybiBuZXcgTW4oe1xuICAgICAgaGVhZGVyOiByLFxuICAgICAgYWNjb3VudEtleXM6IG4sXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGUucmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiBvXG4gICAgfSk7XG4gIH1cbiAgaXNBY2NvdW50U2lnbmVyKGUpIHtcbiAgICByZXR1cm4gZSA8IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgfVxuICBpc0FjY291bnRXcml0YWJsZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgICBpZiAoZSA+PSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpIHtcbiAgICAgIGNvbnN0IHIgPSBlIC0gdCwgaSA9IHRoaXMuYWNjb3VudEtleXMubGVuZ3RoIC0gdCAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cztcbiAgICAgIHJldHVybiByIDwgaTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgciA9IHQgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIGUgPCByO1xuICAgIH1cbiAgfVxuICBpc1Byb2dyYW1JZChlKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5kZXhUb1Byb2dyYW1JZHMuaGFzKGUpO1xuICB9XG4gIHByb2dyYW1JZHMoKSB7XG4gICAgcmV0dXJuIFsuLi50aGlzLmluZGV4VG9Qcm9ncmFtSWRzLnZhbHVlcygpXTtcbiAgfVxuICBub25Qcm9ncmFtSWRzKCkge1xuICAgIHJldHVybiB0aGlzLmFjY291bnRLZXlzLmZpbHRlcigoZSwgdCkgPT4gIXRoaXMuaXNQcm9ncmFtSWQodCkpO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5hY2NvdW50S2V5cy5sZW5ndGg7XG4gICAgbGV0IHQgPSBbXTtcbiAgICB4cih0LCBlKTtcbiAgICBjb25zdCByID0gdGhpcy5pbnN0cnVjdGlvbnMubWFwKChkKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjY291bnRzOiBoLFxuICAgICAgICBwcm9ncmFtSWRJbmRleDogZlxuICAgICAgfSA9IGQsIHAgPSBBcnJheS5mcm9tKGFyLmRlY29kZShkLmRhdGEpKTtcbiAgICAgIGxldCB5ID0gW107XG4gICAgICB4cih5LCBoLmxlbmd0aCk7XG4gICAgICBsZXQgRSA9IFtdO1xuICAgICAgcmV0dXJuIHhyKEUsIHAubGVuZ3RoKSwge1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogZixcbiAgICAgICAga2V5SW5kaWNlc0NvdW50OiBIZS5CdWZmZXIuZnJvbSh5KSxcbiAgICAgICAga2V5SW5kaWNlczogaCxcbiAgICAgICAgZGF0YUxlbmd0aDogSGUuQnVmZmVyLmZyb20oRSksXG4gICAgICAgIGRhdGE6IHBcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbGV0IG4gPSBbXTtcbiAgICB4cihuLCByLmxlbmd0aCk7XG4gICAgbGV0IGkgPSBIZS5CdWZmZXIuYWxsb2Mod24pO1xuICAgIEhlLkJ1ZmZlci5mcm9tKG4pLmNvcHkoaSk7XG4gICAgbGV0IG8gPSBuLmxlbmd0aDtcbiAgICByLmZvckVhY2goKGQpID0+IHtcbiAgICAgIGNvbnN0IGYgPSB6LnN0cnVjdChbei51OChcInByb2dyYW1JZEluZGV4XCIpLCB6LmJsb2IoZC5rZXlJbmRpY2VzQ291bnQubGVuZ3RoLCBcImtleUluZGljZXNDb3VudFwiKSwgei5zZXEoei51OChcImtleUluZGV4XCIpLCBkLmtleUluZGljZXMubGVuZ3RoLCBcImtleUluZGljZXNcIiksIHouYmxvYihkLmRhdGFMZW5ndGgubGVuZ3RoLCBcImRhdGFMZW5ndGhcIiksIHouc2VxKHoudTgoXCJ1c2VyZGF0dW1cIiksIGQuZGF0YS5sZW5ndGgsIFwiZGF0YVwiKV0pLmVuY29kZShkLCBpLCBvKTtcbiAgICAgIG8gKz0gZjtcbiAgICB9KSwgaSA9IGkuc2xpY2UoMCwgbyk7XG4gICAgY29uc3QgYSA9IHouc3RydWN0KFt6LmJsb2IoMSwgXCJudW1SZXF1aXJlZFNpZ25hdHVyZXNcIiksIHouYmxvYigxLCBcIm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHNcIiksIHouYmxvYigxLCBcIm51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50c1wiKSwgei5ibG9iKHQubGVuZ3RoLCBcImtleUNvdW50XCIpLCB6LnNlcShXZShcImtleVwiKSwgZSwgXCJrZXlzXCIpLCBXZShcInJlY2VudEJsb2NraGFzaFwiKV0pLCBsID0ge1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiBIZS5CdWZmZXIuZnJvbShbdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzXSksXG4gICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiBIZS5CdWZmZXIuZnJvbShbdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlTaWduZWRBY2NvdW50c10pLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiBIZS5CdWZmZXIuZnJvbShbdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXSksXG4gICAgICBrZXlDb3VudDogSGUuQnVmZmVyLmZyb20odCksXG4gICAgICBrZXlzOiB0aGlzLmFjY291bnRLZXlzLm1hcCgoZCkgPT4gcnUoZC50b0J5dGVzKCkpKSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYXIuZGVjb2RlKHRoaXMucmVjZW50QmxvY2toYXNoKVxuICAgIH07XG4gICAgbGV0IGMgPSBIZS5CdWZmZXIuYWxsb2MoMjA0OCk7XG4gICAgY29uc3QgdSA9IGEuZW5jb2RlKGwsIGMpO1xuICAgIHJldHVybiBpLmNvcHkoYywgdSksIGMuc2xpY2UoMCwgdSArIGkubGVuZ3RoKTtcbiAgfVxuICAvKipcbiAgICogRGVjb2RlIGEgY29tcGlsZWQgbWVzc2FnZSBpbnRvIGEgTWVzc2FnZSBvYmplY3QuXG4gICAqL1xuICBzdGF0aWMgZnJvbShlKSB7XG4gICAgbGV0IHQgPSBbLi4uZV07XG4gICAgY29uc3QgciA9IGRzKHQpO1xuICAgIGlmIChyICE9PSAociAmIHN1KSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlZlcnNpb25lZCBtZXNzYWdlcyBtdXN0IGJlIGRlc2VyaWFsaXplZCB3aXRoIFZlcnNpb25lZE1lc3NhZ2UuZGVzZXJpYWxpemUoKVwiKTtcbiAgICBjb25zdCBuID0gZHModCksIGkgPSBkcyh0KSwgbyA9IEVyKHQpO1xuICAgIGxldCBhID0gW107XG4gICAgZm9yIChsZXQgaCA9IDA7IGggPCBvOyBoKyspIHtcbiAgICAgIGNvbnN0IGYgPSBTcih0LCAwLCBrcyk7XG4gICAgICBhLnB1c2gobmV3IE9lKEhlLkJ1ZmZlci5mcm9tKGYpKSk7XG4gICAgfVxuICAgIGNvbnN0IGwgPSBTcih0LCAwLCBrcyksIGMgPSBFcih0KTtcbiAgICBsZXQgdSA9IFtdO1xuICAgIGZvciAobGV0IGggPSAwOyBoIDwgYzsgaCsrKSB7XG4gICAgICBjb25zdCBmID0gZHModCksIHAgPSBFcih0KSwgeSA9IFNyKHQsIDAsIHApLCBFID0gRXIodCksIGIgPSBTcih0LCAwLCBFKSwgUiA9IGFyLmVuY29kZShIZS5CdWZmZXIuZnJvbShiKSk7XG4gICAgICB1LnB1c2goe1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogZixcbiAgICAgICAgYWNjb3VudHM6IHksXG4gICAgICAgIGRhdGE6IFJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBkID0ge1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogcixcbiAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogbixcbiAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiBpXG4gICAgICB9LFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBhci5lbmNvZGUoSGUuQnVmZmVyLmZyb20obCkpLFxuICAgICAgYWNjb3VudEtleXM6IGEsXG4gICAgICBpbnN0cnVjdGlvbnM6IHVcbiAgICB9O1xuICAgIHJldHVybiBuZXcgTW4oZCk7XG4gIH1cbn1cbmNsYXNzIGpvIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuaGVhZGVyID0gdm9pZCAwLCB0aGlzLnN0YXRpY0FjY291bnRLZXlzID0gdm9pZCAwLCB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHZvaWQgMCwgdGhpcy5jb21waWxlZEluc3RydWN0aW9ucyA9IHZvaWQgMCwgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzID0gdm9pZCAwLCB0aGlzLmhlYWRlciA9IGUuaGVhZGVyLCB0aGlzLnN0YXRpY0FjY291bnRLZXlzID0gZS5zdGF0aWNBY2NvdW50S2V5cywgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBlLnJlY2VudEJsb2NraGFzaCwgdGhpcy5jb21waWxlZEluc3RydWN0aW9ucyA9IGUuY29tcGlsZWRJbnN0cnVjdGlvbnMsIHRoaXMuYWRkcmVzc1RhYmxlTG9va3VwcyA9IGUuYWRkcmVzc1RhYmxlTG9va3VwcztcbiAgfVxuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXQgbnVtQWNjb3VudEtleXNGcm9tTG9va3VwcygpIHtcbiAgICBsZXQgZSA9IDA7XG4gICAgZm9yIChjb25zdCB0IG9mIHRoaXMuYWRkcmVzc1RhYmxlTG9va3VwcylcbiAgICAgIGUgKz0gdC5yZWFkb25seUluZGV4ZXMubGVuZ3RoICsgdC53cml0YWJsZUluZGV4ZXMubGVuZ3RoO1xuICAgIHJldHVybiBlO1xuICB9XG4gIGdldEFjY291bnRLZXlzKGUpIHtcbiAgICBsZXQgdDtcbiAgICBpZiAoZSAmJiBcImFjY291bnRLZXlzRnJvbUxvb2t1cHNcIiBpbiBlICYmIGUuYWNjb3VudEtleXNGcm9tTG9va3Vwcykge1xuICAgICAgaWYgKHRoaXMubnVtQWNjb3VudEtleXNGcm9tTG9va3VwcyAhPSBlLmFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUubGVuZ3RoICsgZS5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5Lmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGdldCBhY2NvdW50IGtleXMgYmVjYXVzZSBvZiBhIG1pc21hdGNoIGluIHRoZSBudW1iZXIgb2YgYWNjb3VudCBrZXlzIGZyb20gbG9va3Vwc1wiKTtcbiAgICAgIHQgPSBlLmFjY291bnRLZXlzRnJvbUxvb2t1cHM7XG4gICAgfSBlbHNlIGlmIChlICYmIFwiYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHNcIiBpbiBlICYmIGUuYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpXG4gICAgICB0ID0gdGhpcy5yZXNvbHZlQWRkcmVzc1RhYmxlTG9va3VwcyhlLmFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKTtcbiAgICBlbHNlIGlmICh0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMubGVuZ3RoID4gMClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBnZXQgYWNjb3VudCBrZXlzIGJlY2F1c2UgYWRkcmVzcyB0YWJsZSBsb29rdXBzIHdlcmUgbm90IHJlc29sdmVkXCIpO1xuICAgIHJldHVybiBuZXcgVm8odGhpcy5zdGF0aWNBY2NvdW50S2V5cywgdCk7XG4gIH1cbiAgaXNBY2NvdW50U2lnbmVyKGUpIHtcbiAgICByZXR1cm4gZSA8IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgfVxuICBpc0FjY291bnRXcml0YWJsZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcywgciA9IHRoaXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoO1xuICAgIGlmIChlID49IHIpIHtcbiAgICAgIGNvbnN0IG4gPSBlIC0gciwgaSA9IHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5yZWR1Y2UoKG8sIGEpID0+IG8gKyBhLndyaXRhYmxlSW5kZXhlcy5sZW5ndGgsIDApO1xuICAgICAgcmV0dXJuIG4gPCBpO1xuICAgIH0gZWxzZSBpZiAoZSA+PSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpIHtcbiAgICAgIGNvbnN0IG4gPSBlIC0gdCwgbyA9IHIgLSB0IC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzO1xuICAgICAgcmV0dXJuIG4gPCBvO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuID0gdCAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM7XG4gICAgICByZXR1cm4gZSA8IG47XG4gICAgfVxuICB9XG4gIHJlc29sdmVBZGRyZXNzVGFibGVMb29rdXBzKGUpIHtcbiAgICBjb25zdCB0ID0ge1xuICAgICAgd3JpdGFibGU6IFtdLFxuICAgICAgcmVhZG9ubHk6IFtdXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzKSB7XG4gICAgICBjb25zdCBuID0gZS5maW5kKChpKSA9PiBpLmtleS5lcXVhbHMoci5hY2NvdW50S2V5KSk7XG4gICAgICBpZiAoIW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgYWRkcmVzcyBsb29rdXAgdGFibGUgYWNjb3VudCBmb3IgdGFibGUga2V5ICR7ci5hY2NvdW50S2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgICBmb3IgKGNvbnN0IGkgb2Ygci53cml0YWJsZUluZGV4ZXMpXG4gICAgICAgIGlmIChpIDwgbi5zdGF0ZS5hZGRyZXNzZXMubGVuZ3RoKVxuICAgICAgICAgIHQud3JpdGFibGUucHVzaChuLnN0YXRlLmFkZHJlc3Nlc1tpXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBmaW5kIGFkZHJlc3MgZm9yIGluZGV4ICR7aX0gaW4gYWRkcmVzcyBsb29rdXAgdGFibGUgJHtyLmFjY291bnRLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgIGZvciAoY29uc3QgaSBvZiByLnJlYWRvbmx5SW5kZXhlcylcbiAgICAgICAgaWYgKGkgPCBuLnN0YXRlLmFkZHJlc3Nlcy5sZW5ndGgpXG4gICAgICAgICAgdC5yZWFkb25seS5wdXNoKG4uc3RhdGUuYWRkcmVzc2VzW2ldKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgYWRkcmVzcyBmb3IgaW5kZXggJHtpfSBpbiBhZGRyZXNzIGxvb2t1cCB0YWJsZSAke3IuYWNjb3VudEtleS50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfVxuICBzdGF0aWMgY29tcGlsZShlKSB7XG4gICAgY29uc3QgdCA9IGZhLmNvbXBpbGUoZS5pbnN0cnVjdGlvbnMsIGUucGF5ZXJLZXkpLCByID0gbmV3IEFycmF5KCksIG4gPSB7XG4gICAgICB3cml0YWJsZTogbmV3IEFycmF5KCksXG4gICAgICByZWFkb25seTogbmV3IEFycmF5KClcbiAgICB9LCBpID0gZS5hZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cyB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IHUgb2YgaSkge1xuICAgICAgY29uc3QgZCA9IHQuZXh0cmFjdFRhYmxlTG9va3VwKHUpO1xuICAgICAgaWYgKGQgIT09IHZvaWQgMCkge1xuICAgICAgICBjb25zdCBbaCwge1xuICAgICAgICAgIHdyaXRhYmxlOiBmLFxuICAgICAgICAgIHJlYWRvbmx5OiBwXG4gICAgICAgIH1dID0gZDtcbiAgICAgICAgci5wdXNoKGgpLCBuLndyaXRhYmxlLnB1c2goLi4uZiksIG4ucmVhZG9ubHkucHVzaCguLi5wKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgW28sIGFdID0gdC5nZXRNZXNzYWdlQ29tcG9uZW50cygpLCBjID0gbmV3IFZvKGEsIG4pLmNvbXBpbGVJbnN0cnVjdGlvbnMoZS5pbnN0cnVjdGlvbnMpO1xuICAgIHJldHVybiBuZXcgam8oe1xuICAgICAgaGVhZGVyOiBvLFxuICAgICAgc3RhdGljQWNjb3VudEtleXM6IGEsXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGUucmVjZW50QmxvY2toYXNoLFxuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnM6IGMsXG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzOiByXG4gICAgfSk7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IGUgPSBBcnJheSgpO1xuICAgIHhyKGUsIHRoaXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoKTtcbiAgICBjb25zdCB0ID0gdGhpcy5zZXJpYWxpemVJbnN0cnVjdGlvbnMoKSwgciA9IEFycmF5KCk7XG4gICAgeHIociwgdGhpcy5jb21waWxlZEluc3RydWN0aW9ucy5sZW5ndGgpO1xuICAgIGNvbnN0IG4gPSB0aGlzLnNlcmlhbGl6ZUFkZHJlc3NUYWJsZUxvb2t1cHMoKSwgaSA9IEFycmF5KCk7XG4gICAgeHIoaSwgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzLmxlbmd0aCk7XG4gICAgY29uc3QgbyA9IHouc3RydWN0KFt6LnU4KFwicHJlZml4XCIpLCB6LnN0cnVjdChbei51OChcIm51bVJlcXVpcmVkU2lnbmF0dXJlc1wiKSwgei51OChcIm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHNcIiksIHoudTgoXCJudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHNcIildLCBcImhlYWRlclwiKSwgei5ibG9iKGUubGVuZ3RoLCBcInN0YXRpY0FjY291bnRLZXlzTGVuZ3RoXCIpLCB6LnNlcShXZSgpLCB0aGlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCwgXCJzdGF0aWNBY2NvdW50S2V5c1wiKSwgV2UoXCJyZWNlbnRCbG9ja2hhc2hcIiksIHouYmxvYihyLmxlbmd0aCwgXCJpbnN0cnVjdGlvbnNMZW5ndGhcIiksIHouYmxvYih0Lmxlbmd0aCwgXCJzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zXCIpLCB6LmJsb2IoaS5sZW5ndGgsIFwiYWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aFwiKSwgei5ibG9iKG4ubGVuZ3RoLCBcInNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzXCIpXSksIGEgPSBuZXcgVWludDhBcnJheSh3biksIGMgPSBvLmVuY29kZSh7XG4gICAgICBwcmVmaXg6IDEyOCxcbiAgICAgIGhlYWRlcjogdGhpcy5oZWFkZXIsXG4gICAgICBzdGF0aWNBY2NvdW50S2V5c0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZSksXG4gICAgICBzdGF0aWNBY2NvdW50S2V5czogdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5tYXAoKHUpID0+IHUudG9CeXRlcygpKSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYXIuZGVjb2RlKHRoaXMucmVjZW50QmxvY2toYXNoKSxcbiAgICAgIGluc3RydWN0aW9uc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkociksXG4gICAgICBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zOiB0LFxuICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoaSksXG4gICAgICBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwczogblxuICAgIH0sIGEpO1xuICAgIHJldHVybiBhLnNsaWNlKDAsIGMpO1xuICB9XG4gIHNlcmlhbGl6ZUluc3RydWN0aW9ucygpIHtcbiAgICBsZXQgZSA9IDA7XG4gICAgY29uc3QgdCA9IG5ldyBVaW50OEFycmF5KHduKTtcbiAgICBmb3IgKGNvbnN0IHIgb2YgdGhpcy5jb21waWxlZEluc3RydWN0aW9ucykge1xuICAgICAgY29uc3QgbiA9IEFycmF5KCk7XG4gICAgICB4cihuLCByLmFjY291bnRLZXlJbmRleGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBpID0gQXJyYXkoKTtcbiAgICAgIHhyKGksIHIuZGF0YS5sZW5ndGgpO1xuICAgICAgY29uc3QgbyA9IHouc3RydWN0KFt6LnU4KFwicHJvZ3JhbUlkSW5kZXhcIiksIHouYmxvYihuLmxlbmd0aCwgXCJlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGhcIiksIHouc2VxKHoudTgoKSwgci5hY2NvdW50S2V5SW5kZXhlcy5sZW5ndGgsIFwiYWNjb3VudEtleUluZGV4ZXNcIiksIHouYmxvYihpLmxlbmd0aCwgXCJlbmNvZGVkRGF0YUxlbmd0aFwiKSwgei5ibG9iKHIuZGF0YS5sZW5ndGgsIFwiZGF0YVwiKV0pO1xuICAgICAgZSArPSBvLmVuY29kZSh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4OiByLnByb2dyYW1JZEluZGV4LFxuICAgICAgICBlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KG4pLFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlczogci5hY2NvdW50S2V5SW5kZXhlcyxcbiAgICAgICAgZW5jb2RlZERhdGFMZW5ndGg6IG5ldyBVaW50OEFycmF5KGkpLFxuICAgICAgICBkYXRhOiByLmRhdGFcbiAgICAgIH0sIHQsIGUpO1xuICAgIH1cbiAgICByZXR1cm4gdC5zbGljZSgwLCBlKTtcbiAgfVxuICBzZXJpYWxpemVBZGRyZXNzVGFibGVMb29rdXBzKCkge1xuICAgIGxldCBlID0gMDtcbiAgICBjb25zdCB0ID0gbmV3IFVpbnQ4QXJyYXkod24pO1xuICAgIGZvciAoY29uc3QgciBvZiB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMpIHtcbiAgICAgIGNvbnN0IG4gPSBBcnJheSgpO1xuICAgICAgeHIobiwgci53cml0YWJsZUluZGV4ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGkgPSBBcnJheSgpO1xuICAgICAgeHIoaSwgci5yZWFkb25seUluZGV4ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IG8gPSB6LnN0cnVjdChbV2UoXCJhY2NvdW50S2V5XCIpLCB6LmJsb2Iobi5sZW5ndGgsIFwiZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aFwiKSwgei5zZXEoei51OCgpLCByLndyaXRhYmxlSW5kZXhlcy5sZW5ndGgsIFwid3JpdGFibGVJbmRleGVzXCIpLCB6LmJsb2IoaS5sZW5ndGgsIFwiZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aFwiKSwgei5zZXEoei51OCgpLCByLnJlYWRvbmx5SW5kZXhlcy5sZW5ndGgsIFwicmVhZG9ubHlJbmRleGVzXCIpXSk7XG4gICAgICBlICs9IG8uZW5jb2RlKHtcbiAgICAgICAgYWNjb3VudEtleTogci5hY2NvdW50S2V5LnRvQnl0ZXMoKSxcbiAgICAgICAgZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkobiksXG4gICAgICAgIHdyaXRhYmxlSW5kZXhlczogci53cml0YWJsZUluZGV4ZXMsXG4gICAgICAgIGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGkpLFxuICAgICAgICByZWFkb25seUluZGV4ZXM6IHIucmVhZG9ubHlJbmRleGVzXG4gICAgICB9LCB0LCBlKTtcbiAgICB9XG4gICAgcmV0dXJuIHQuc2xpY2UoMCwgZSk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKGUpIHtcbiAgICBsZXQgdCA9IFsuLi5lXTtcbiAgICBjb25zdCByID0gZHModCksIG4gPSByICYgc3U7XG4gICAgS3QociAhPT0gbiwgXCJFeHBlY3RlZCB2ZXJzaW9uZWQgbWVzc2FnZSBidXQgcmVjZWl2ZWQgbGVnYWN5IG1lc3NhZ2VcIik7XG4gICAgY29uc3QgaSA9IG47XG4gICAgS3QoaSA9PT0gMCwgYEV4cGVjdGVkIHZlcnNpb25lZCBtZXNzYWdlIHdpdGggdmVyc2lvbiAwIGJ1dCBmb3VuZCB2ZXJzaW9uICR7aX1gKTtcbiAgICBjb25zdCBvID0ge1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiBkcyh0KSxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IGRzKHQpLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiBkcyh0KVxuICAgIH0sIGEgPSBbXSwgbCA9IEVyKHQpO1xuICAgIGZvciAobGV0IHAgPSAwOyBwIDwgbDsgcCsrKVxuICAgICAgYS5wdXNoKG5ldyBPZShTcih0LCAwLCBrcykpKTtcbiAgICBjb25zdCBjID0gYXIuZW5jb2RlKFNyKHQsIDAsIGtzKSksIHUgPSBFcih0KSwgZCA9IFtdO1xuICAgIGZvciAobGV0IHAgPSAwOyBwIDwgdTsgcCsrKSB7XG4gICAgICBjb25zdCB5ID0gZHModCksIEUgPSBFcih0KSwgYiA9IFNyKHQsIDAsIEUpLCBSID0gRXIodCksIEEgPSBuZXcgVWludDhBcnJheShTcih0LCAwLCBSKSk7XG4gICAgICBkLnB1c2goe1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogeSxcbiAgICAgICAgYWNjb3VudEtleUluZGV4ZXM6IGIsXG4gICAgICAgIGRhdGE6IEFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBoID0gRXIodCksIGYgPSBbXTtcbiAgICBmb3IgKGxldCBwID0gMDsgcCA8IGg7IHArKykge1xuICAgICAgY29uc3QgeSA9IG5ldyBPZShTcih0LCAwLCBrcykpLCBFID0gRXIodCksIGIgPSBTcih0LCAwLCBFKSwgUiA9IEVyKHQpLCBBID0gU3IodCwgMCwgUik7XG4gICAgICBmLnB1c2goe1xuICAgICAgICBhY2NvdW50S2V5OiB5LFxuICAgICAgICB3cml0YWJsZUluZGV4ZXM6IGIsXG4gICAgICAgIHJlYWRvbmx5SW5kZXhlczogQVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgam8oe1xuICAgICAgaGVhZGVyOiBvLFxuICAgICAgc3RhdGljQWNjb3VudEtleXM6IGEsXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGMsXG4gICAgICBjb21waWxlZEluc3RydWN0aW9uczogZCxcbiAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHM6IGZcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgbnUgPSB7XG4gIGRlc2VyaWFsaXplTWVzc2FnZVZlcnNpb24ocykge1xuICAgIGNvbnN0IGUgPSBzWzBdLCB0ID0gZSAmIHN1O1xuICAgIHJldHVybiB0ID09PSBlID8gXCJsZWdhY3lcIiA6IHQ7XG4gIH0sXG4gIGRlc2VyaWFsaXplOiAocykgPT4ge1xuICAgIGNvbnN0IGUgPSBudS5kZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uKHMpO1xuICAgIGlmIChlID09PSBcImxlZ2FjeVwiKVxuICAgICAgcmV0dXJuIE1uLmZyb20ocyk7XG4gICAgaWYgKGUgPT09IDApXG4gICAgICByZXR1cm4gam8uZGVzZXJpYWxpemUocyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBtZXNzYWdlIHZlcnNpb24gJHtlfSBkZXNlcmlhbGl6YXRpb24gaXMgbm90IHN1cHBvcnRlZGApO1xuICB9XG59LCBtRSA9IEhlLkJ1ZmZlci5hbGxvYyhHbykuZmlsbCgwKTtcbmNsYXNzIFVkIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMua2V5cyA9IHZvaWQgMCwgdGhpcy5wcm9ncmFtSWQgPSB2b2lkIDAsIHRoaXMuZGF0YSA9IEhlLkJ1ZmZlci5hbGxvYygwKSwgdGhpcy5wcm9ncmFtSWQgPSBlLnByb2dyYW1JZCwgdGhpcy5rZXlzID0gZS5rZXlzLCBlLmRhdGEgJiYgKHRoaXMuZGF0YSA9IGUuZGF0YSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlzOiB0aGlzLmtleXMubWFwKCh7XG4gICAgICAgIHB1YmtleTogZSxcbiAgICAgICAgaXNTaWduZXI6IHQsXG4gICAgICAgIGlzV3JpdGFibGU6IHJcbiAgICAgIH0pID0+ICh7XG4gICAgICAgIHB1YmtleTogZS50b0pTT04oKSxcbiAgICAgICAgaXNTaWduZXI6IHQsXG4gICAgICAgIGlzV3JpdGFibGU6IHJcbiAgICAgIH0pKSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQudG9KU09OKCksXG4gICAgICBkYXRhOiBbLi4udGhpcy5kYXRhXVxuICAgIH07XG4gIH1cbn1cbmNsYXNzIEtvIHtcbiAgLyoqXG4gICAqIFRoZSBmaXJzdCAocGF5ZXIpIFRyYW5zYWN0aW9uIHNpZ25hdHVyZVxuICAgKlxuICAgKiBAcmV0dXJucyB7QnVmZmVyIHwgbnVsbH0gQnVmZmVyIG9mIHBheWVyJ3Mgc2lnbmF0dXJlXG4gICAqL1xuICBnZXQgc2lnbmF0dXJlKCkge1xuICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZXMubGVuZ3RoID4gMCA/IHRoaXMuc2lnbmF0dXJlc1swXS5zaWduYXR1cmUgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgdHJhbnNhY3Rpb24gZmVlIHBheWVyXG4gICAqL1xuICAvLyBDb25zdHJ1Y3QgYSB0cmFuc2FjdGlvbiB3aXRoIGEgYmxvY2toYXNoIGFuZCBsYXN0VmFsaWRCbG9ja0hlaWdodFxuICAvLyBDb25zdHJ1Y3QgYSB0cmFuc2FjdGlvbiB1c2luZyBhIGR1cmFibGUgbm9uY2VcbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIGBUcmFuc2FjdGlvbkN0b3JGaWVsZHNgIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlxuICAgKiBQbGVhc2Ugc3VwcGx5IGEgYFRyYW5zYWN0aW9uQmxvY2toYXNoQ3RvcmAgaW5zdGVhZC5cbiAgICovXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYW4gZW1wdHkgVHJhbnNhY3Rpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBpZiAodGhpcy5zaWduYXR1cmVzID0gW10sIHRoaXMuZmVlUGF5ZXIgPSB2b2lkIDAsIHRoaXMuaW5zdHJ1Y3Rpb25zID0gW10sIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwLCB0aGlzLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gdm9pZCAwLCB0aGlzLm5vbmNlSW5mbyA9IHZvaWQgMCwgdGhpcy5taW5Ob25jZUNvbnRleHRTbG90ID0gdm9pZCAwLCB0aGlzLl9tZXNzYWdlID0gdm9pZCAwLCB0aGlzLl9qc29uID0gdm9pZCAwLCAhIWUpXG4gICAgICBpZiAoZS5mZWVQYXllciAmJiAodGhpcy5mZWVQYXllciA9IGUuZmVlUGF5ZXIpLCBlLnNpZ25hdHVyZXMgJiYgKHRoaXMuc2lnbmF0dXJlcyA9IGUuc2lnbmF0dXJlcyksIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCBcIm5vbmNlSW5mb1wiKSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbWluQ29udGV4dFNsb3Q6IHQsXG4gICAgICAgICAgbm9uY2VJbmZvOiByXG4gICAgICAgIH0gPSBlO1xuICAgICAgICB0aGlzLm1pbk5vbmNlQ29udGV4dFNsb3QgPSB0LCB0aGlzLm5vbmNlSW5mbyA9IHI7XG4gICAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLCBcImxhc3RWYWxpZEJsb2NrSGVpZ2h0XCIpKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBibG9ja2hhc2g6IHQsXG4gICAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IHJcbiAgICAgICAgfSA9IGU7XG4gICAgICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdCwgdGhpcy5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IHI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmVjZW50QmxvY2toYXNoOiB0LFxuICAgICAgICAgIG5vbmNlSW5mbzogclxuICAgICAgICB9ID0gZTtcbiAgICAgICAgciAmJiAodGhpcy5ub25jZUluZm8gPSByKSwgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSB0O1xuICAgICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVjZW50QmxvY2toYXNoOiB0aGlzLnJlY2VudEJsb2NraGFzaCB8fCBudWxsLFxuICAgICAgZmVlUGF5ZXI6IHRoaXMuZmVlUGF5ZXIgPyB0aGlzLmZlZVBheWVyLnRvSlNPTigpIDogbnVsbCxcbiAgICAgIG5vbmNlSW5mbzogdGhpcy5ub25jZUluZm8gPyB7XG4gICAgICAgIG5vbmNlOiB0aGlzLm5vbmNlSW5mby5ub25jZSxcbiAgICAgICAgbm9uY2VJbnN0cnVjdGlvbjogdGhpcy5ub25jZUluZm8ubm9uY2VJbnN0cnVjdGlvbi50b0pTT04oKVxuICAgICAgfSA6IG51bGwsXG4gICAgICBpbnN0cnVjdGlvbnM6IHRoaXMuaW5zdHJ1Y3Rpb25zLm1hcCgoZSkgPT4gZS50b0pTT04oKSksXG4gICAgICBzaWduZXJzOiB0aGlzLnNpZ25hdHVyZXMubWFwKCh7XG4gICAgICAgIHB1YmxpY0tleTogZVxuICAgICAgfSkgPT4gZS50b0pTT04oKSlcbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBBZGQgb25lIG9yIG1vcmUgaW5zdHJ1Y3Rpb25zIHRvIHRoaXMgVHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTwgVHJhbnNhY3Rpb24gfCBUcmFuc2FjdGlvbkluc3RydWN0aW9uIHwgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbkN0b3JGaWVsZHMgPn0gaXRlbXMgLSBJbnN0cnVjdGlvbnMgdG8gYWRkIHRvIHRoZSBUcmFuc2FjdGlvblxuICAgKi9cbiAgYWRkKC4uLmUpIHtcbiAgICBpZiAoZS5sZW5ndGggPT09IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBpbnN0cnVjdGlvbnNcIik7XG4gICAgcmV0dXJuIGUuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgXCJpbnN0cnVjdGlvbnNcIiBpbiB0ID8gdGhpcy5pbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucy5jb25jYXQodC5pbnN0cnVjdGlvbnMpIDogXCJkYXRhXCIgaW4gdCAmJiBcInByb2dyYW1JZFwiIGluIHQgJiYgXCJrZXlzXCIgaW4gdCA/IHRoaXMuaW5zdHJ1Y3Rpb25zLnB1c2godCkgOiB0aGlzLmluc3RydWN0aW9ucy5wdXNoKG5ldyBVZCh0KSk7XG4gICAgfSksIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIENvbXBpbGUgdHJhbnNhY3Rpb24gZGF0YVxuICAgKi9cbiAgY29tcGlsZU1lc3NhZ2UoKSB7XG4gICAgaWYgKHRoaXMuX21lc3NhZ2UgJiYgSlNPTi5zdHJpbmdpZnkodGhpcy50b0pTT04oKSkgPT09IEpTT04uc3RyaW5naWZ5KHRoaXMuX2pzb24pKVxuICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2U7XG4gICAgbGV0IGUsIHQ7XG4gICAgaWYgKHRoaXMubm9uY2VJbmZvID8gKGUgPSB0aGlzLm5vbmNlSW5mby5ub25jZSwgdGhpcy5pbnN0cnVjdGlvbnNbMF0gIT0gdGhpcy5ub25jZUluZm8ubm9uY2VJbnN0cnVjdGlvbiA/IHQgPSBbdGhpcy5ub25jZUluZm8ubm9uY2VJbnN0cnVjdGlvbiwgLi4udGhpcy5pbnN0cnVjdGlvbnNdIDogdCA9IHRoaXMuaW5zdHJ1Y3Rpb25zKSA6IChlID0gdGhpcy5yZWNlbnRCbG9ja2hhc2gsIHQgPSB0aGlzLmluc3RydWN0aW9ucyksICFlKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gcmVjZW50QmxvY2toYXNoIHJlcXVpcmVkXCIpO1xuICAgIHQubGVuZ3RoIDwgMSAmJiBjb25zb2xlLndhcm4oXCJObyBpbnN0cnVjdGlvbnMgcHJvdmlkZWRcIik7XG4gICAgbGV0IHI7XG4gICAgaWYgKHRoaXMuZmVlUGF5ZXIpXG4gICAgICByID0gdGhpcy5mZWVQYXllcjtcbiAgICBlbHNlIGlmICh0aGlzLnNpZ25hdHVyZXMubGVuZ3RoID4gMCAmJiB0aGlzLnNpZ25hdHVyZXNbMF0ucHVibGljS2V5KVxuICAgICAgciA9IHRoaXMuc2lnbmF0dXJlc1swXS5wdWJsaWNLZXk7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gZmVlIHBheWVyIHJlcXVpcmVkXCIpO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgdC5sZW5ndGg7IHkrKylcbiAgICAgIGlmICh0W3ldLnByb2dyYW1JZCA9PT0gdm9pZCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uIGluc3RydWN0aW9uIGluZGV4ICR7eX0gaGFzIHVuZGVmaW5lZCBwcm9ncmFtIGlkYCk7XG4gICAgY29uc3QgbiA9IFtdLCBpID0gW107XG4gICAgdC5mb3JFYWNoKCh5KSA9PiB7XG4gICAgICB5LmtleXMuZm9yRWFjaCgoYikgPT4ge1xuICAgICAgICBpLnB1c2goe1xuICAgICAgICAgIC4uLmJcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IEUgPSB5LnByb2dyYW1JZC50b1N0cmluZygpO1xuICAgICAgbi5pbmNsdWRlcyhFKSB8fCBuLnB1c2goRSk7XG4gICAgfSksIG4uZm9yRWFjaCgoeSkgPT4ge1xuICAgICAgaS5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBuZXcgT2UoeSksXG4gICAgICAgIGlzU2lnbmVyOiAhMSxcbiAgICAgICAgaXNXcml0YWJsZTogITFcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGNvbnN0IG8gPSBbXTtcbiAgICBpLmZvckVhY2goKHkpID0+IHtcbiAgICAgIGNvbnN0IEUgPSB5LnB1YmtleS50b1N0cmluZygpLCBiID0gby5maW5kSW5kZXgoKFIpID0+IFIucHVia2V5LnRvU3RyaW5nKCkgPT09IEUpO1xuICAgICAgYiA+IC0xID8gKG9bYl0uaXNXcml0YWJsZSA9IG9bYl0uaXNXcml0YWJsZSB8fCB5LmlzV3JpdGFibGUsIG9bYl0uaXNTaWduZXIgPSBvW2JdLmlzU2lnbmVyIHx8IHkuaXNTaWduZXIpIDogby5wdXNoKHkpO1xuICAgIH0pLCBvLnNvcnQoZnVuY3Rpb24oeSwgRSkge1xuICAgICAgaWYgKHkuaXNTaWduZXIgIT09IEUuaXNTaWduZXIpXG4gICAgICAgIHJldHVybiB5LmlzU2lnbmVyID8gLTEgOiAxO1xuICAgICAgaWYgKHkuaXNXcml0YWJsZSAhPT0gRS5pc1dyaXRhYmxlKVxuICAgICAgICByZXR1cm4geS5pc1dyaXRhYmxlID8gLTEgOiAxO1xuICAgICAgY29uc3QgYiA9IHtcbiAgICAgICAgbG9jYWxlTWF0Y2hlcjogXCJiZXN0IGZpdFwiLFxuICAgICAgICB1c2FnZTogXCJzb3J0XCIsXG4gICAgICAgIHNlbnNpdGl2aXR5OiBcInZhcmlhbnRcIixcbiAgICAgICAgaWdub3JlUHVuY3R1YXRpb246ICExLFxuICAgICAgICBudW1lcmljOiAhMSxcbiAgICAgICAgY2FzZUZpcnN0OiBcImxvd2VyXCJcbiAgICAgIH07XG4gICAgICByZXR1cm4geS5wdWJrZXkudG9CYXNlNTgoKS5sb2NhbGVDb21wYXJlKEUucHVia2V5LnRvQmFzZTU4KCksIFwiZW5cIiwgYik7XG4gICAgfSk7XG4gICAgY29uc3QgYSA9IG8uZmluZEluZGV4KCh5KSA9PiB5LnB1YmtleS5lcXVhbHMocikpO1xuICAgIGlmIChhID4gLTEpIHtcbiAgICAgIGNvbnN0IFt5XSA9IG8uc3BsaWNlKGEsIDEpO1xuICAgICAgeS5pc1NpZ25lciA9ICEwLCB5LmlzV3JpdGFibGUgPSAhMCwgby51bnNoaWZ0KHkpO1xuICAgIH0gZWxzZVxuICAgICAgby51bnNoaWZ0KHtcbiAgICAgICAgcHVia2V5OiByLFxuICAgICAgICBpc1NpZ25lcjogITAsXG4gICAgICAgIGlzV3JpdGFibGU6ICEwXG4gICAgICB9KTtcbiAgICBmb3IgKGNvbnN0IHkgb2YgdGhpcy5zaWduYXR1cmVzKSB7XG4gICAgICBjb25zdCBFID0gby5maW5kSW5kZXgoKGIpID0+IGIucHVia2V5LmVxdWFscyh5LnB1YmxpY0tleSkpO1xuICAgICAgaWYgKEUgPiAtMSlcbiAgICAgICAgb1tFXS5pc1NpZ25lciB8fCAob1tFXS5pc1NpZ25lciA9ICEwLCBjb25zb2xlLndhcm4oXCJUcmFuc2FjdGlvbiByZWZlcmVuY2VzIGEgc2lnbmF0dXJlIHRoYXQgaXMgdW5uZWNlc3NhcnksIG9ubHkgdGhlIGZlZSBwYXllciBhbmQgaW5zdHJ1Y3Rpb24gc2lnbmVyIGFjY291bnRzIHNob3VsZCBzaWduIGEgdHJhbnNhY3Rpb24uIFRoaXMgYmVoYXZpb3IgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCB0aHJvdyBhbiBlcnJvciBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIHJlbGVhc2UuXCIpKTtcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHNpZ25lcjogJHt5LnB1YmxpY0tleS50b1N0cmluZygpfWApO1xuICAgIH1cbiAgICBsZXQgbCA9IDAsIGMgPSAwLCB1ID0gMDtcbiAgICBjb25zdCBkID0gW10sIGggPSBbXTtcbiAgICBvLmZvckVhY2goKHtcbiAgICAgIHB1YmtleTogeSxcbiAgICAgIGlzU2lnbmVyOiBFLFxuICAgICAgaXNXcml0YWJsZTogYlxuICAgIH0pID0+IHtcbiAgICAgIEUgPyAoZC5wdXNoKHkudG9TdHJpbmcoKSksIGwgKz0gMSwgYiB8fCAoYyArPSAxKSkgOiAoaC5wdXNoKHkudG9TdHJpbmcoKSksIGIgfHwgKHUgKz0gMSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGYgPSBkLmNvbmNhdChoKSwgcCA9IHQubWFwKCh5KSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGE6IEUsXG4gICAgICAgIHByb2dyYW1JZDogYlxuICAgICAgfSA9IHk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwcm9ncmFtSWRJbmRleDogZi5pbmRleE9mKGIudG9TdHJpbmcoKSksXG4gICAgICAgIGFjY291bnRzOiB5LmtleXMubWFwKChSKSA9PiBmLmluZGV4T2YoUi5wdWJrZXkudG9TdHJpbmcoKSkpLFxuICAgICAgICBkYXRhOiBhci5lbmNvZGUoRSlcbiAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIHAuZm9yRWFjaCgoeSkgPT4ge1xuICAgICAgS3QoeS5wcm9ncmFtSWRJbmRleCA+PSAwKSwgeS5hY2NvdW50cy5mb3JFYWNoKChFKSA9PiBLdChFID49IDApKTtcbiAgICB9KSwgbmV3IE1uKHtcbiAgICAgIGhlYWRlcjoge1xuICAgICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IGwsXG4gICAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IGMsXG4gICAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogdVxuICAgICAgfSxcbiAgICAgIGFjY291bnRLZXlzOiBmLFxuICAgICAgcmVjZW50QmxvY2toYXNoOiBlLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiBwXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2NvbXBpbGUoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuY29tcGlsZU1lc3NhZ2UoKSwgdCA9IGUuYWNjb3VudEtleXMuc2xpY2UoMCwgZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKTtcbiAgICByZXR1cm4gdGhpcy5zaWduYXR1cmVzLmxlbmd0aCA9PT0gdC5sZW5ndGggJiYgdGhpcy5zaWduYXR1cmVzLmV2ZXJ5KChuLCBpKSA9PiB0W2ldLmVxdWFscyhuLnB1YmxpY0tleSkpIHx8ICh0aGlzLnNpZ25hdHVyZXMgPSB0Lm1hcCgocikgPT4gKHtcbiAgICAgIHNpZ25hdHVyZTogbnVsbCxcbiAgICAgIHB1YmxpY0tleTogclxuICAgIH0pKSksIGU7XG4gIH1cbiAgLyoqXG4gICAqIEdldCBhIGJ1ZmZlciBvZiB0aGUgVHJhbnNhY3Rpb24gZGF0YSB0aGF0IG5lZWQgdG8gYmUgY292ZXJlZCBieSBzaWduYXR1cmVzXG4gICAqL1xuICBzZXJpYWxpemVNZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb21waWxlKCkuc2VyaWFsaXplKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZXN0aW1hdGVkIGZlZSBhc3NvY2lhdGVkIHdpdGggYSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb24gQ29ubmVjdGlvbiB0byBSUEMgRW5kcG9pbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlciB8IG51bGw+fSBUaGUgZXN0aW1hdGVkIGZlZSBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBhc3luYyBnZXRFc3RpbWF0ZWRGZWUoZSkge1xuICAgIHJldHVybiAoYXdhaXQgZS5nZXRGZWVGb3JNZXNzYWdlKHRoaXMuY29tcGlsZU1lc3NhZ2UoKSkpLnZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBTcGVjaWZ5IHRoZSBwdWJsaWMga2V5cyB3aGljaCB3aWxsIGJlIHVzZWQgdG8gc2lnbiB0aGUgVHJhbnNhY3Rpb24uXG4gICAqIFRoZSBmaXJzdCBzaWduZXIgd2lsbCBiZSB1c2VkIGFzIHRoZSB0cmFuc2FjdGlvbiBmZWUgcGF5ZXIgYWNjb3VudC5cbiAgICpcbiAgICogU2lnbmF0dXJlcyBjYW4gYmUgYWRkZWQgd2l0aCBlaXRoZXIgYHBhcnRpYWxTaWduYCBvciBgYWRkU2lnbmF0dXJlYFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIHYwLjg0LjAuIE9ubHkgdGhlIGZlZSBwYXllciBuZWVkcyB0byBiZVxuICAgKiBzcGVjaWZpZWQgYW5kIGl0IGNhbiBiZSBzZXQgaW4gdGhlIFRyYW5zYWN0aW9uIGNvbnN0cnVjdG9yIG9yIHdpdGggdGhlXG4gICAqIGBmZWVQYXllcmAgcHJvcGVydHkuXG4gICAqL1xuICBzZXRTaWduZXJzKC4uLmUpIHtcbiAgICBpZiAoZS5sZW5ndGggPT09IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXJzXCIpO1xuICAgIGNvbnN0IHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgIHRoaXMuc2lnbmF0dXJlcyA9IGUuZmlsdGVyKChyKSA9PiB7XG4gICAgICBjb25zdCBuID0gci50b1N0cmluZygpO1xuICAgICAgcmV0dXJuIHQuaGFzKG4pID8gITEgOiAodC5hZGQobiksICEwKTtcbiAgICB9KS5tYXAoKHIpID0+ICh7XG4gICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICBwdWJsaWNLZXk6IHJcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIFNpZ24gdGhlIFRyYW5zYWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBzaWduZXJzLiBNdWx0aXBsZSBzaWduYXR1cmVzIG1heVxuICAgKiBiZSBhcHBsaWVkIHRvIGEgVHJhbnNhY3Rpb24uIFRoZSBmaXJzdCBzaWduYXR1cmUgaXMgY29uc2lkZXJlZCBcInByaW1hcnlcIlxuICAgKiBhbmQgaXMgdXNlZCBpZGVudGlmeSBhbmQgY29uZmlybSB0cmFuc2FjdGlvbnMuXG4gICAqXG4gICAqIElmIHRoZSBUcmFuc2FjdGlvbiBgZmVlUGF5ZXJgIGlzIG5vdCBzZXQsIHRoZSBmaXJzdCBzaWduZXIgd2lsbCBiZSB1c2VkXG4gICAqIGFzIHRoZSB0cmFuc2FjdGlvbiBmZWUgcGF5ZXIgYWNjb3VudC5cbiAgICpcbiAgICogVHJhbnNhY3Rpb24gZmllbGRzIHNob3VsZCBub3QgYmUgbW9kaWZpZWQgYWZ0ZXIgdGhlIGZpcnN0IGNhbGwgdG8gYHNpZ25gLFxuICAgKiBhcyBkb2luZyBzbyBtYXkgaW52YWxpZGF0ZSB0aGUgc2lnbmF0dXJlIGFuZCBjYXVzZSB0aGUgVHJhbnNhY3Rpb24gdG8gYmVcbiAgICogcmVqZWN0ZWQuXG4gICAqXG4gICAqIFRoZSBUcmFuc2FjdGlvbiBtdXN0IGJlIGFzc2lnbmVkIGEgdmFsaWQgYHJlY2VudEJsb2NraGFzaGAgYmVmb3JlIGludm9raW5nIHRoaXMgbWV0aG9kXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8U2lnbmVyPn0gc2lnbmVycyBBcnJheSBvZiBzaWduZXJzIHRoYXQgd2lsbCBzaWduIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgc2lnbiguLi5lKSB7XG4gICAgaWYgKGUubGVuZ3RoID09PSAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gc2lnbmVyc1wiKTtcbiAgICBjb25zdCB0ID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgciA9IFtdO1xuICAgIGZvciAoY29uc3QgaSBvZiBlKSB7XG4gICAgICBjb25zdCBvID0gaS5wdWJsaWNLZXkudG9TdHJpbmcoKTtcbiAgICAgIHQuaGFzKG8pIHx8ICh0LmFkZChvKSwgci5wdXNoKGkpKTtcbiAgICB9XG4gICAgdGhpcy5zaWduYXR1cmVzID0gci5tYXAoKGkpID0+ICh7XG4gICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICBwdWJsaWNLZXk6IGkucHVibGljS2V5XG4gICAgfSkpO1xuICAgIGNvbnN0IG4gPSB0aGlzLl9jb21waWxlKCk7XG4gICAgdGhpcy5fcGFydGlhbFNpZ24obiwgLi4ucik7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnRpYWxseSBzaWduIGEgdHJhbnNhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIGFjY291bnRzLiBBbGwgYWNjb3VudHMgbXVzdFxuICAgKiBjb3JyZXNwb25kIHRvIGVpdGhlciB0aGUgZmVlIHBheWVyIG9yIGEgc2lnbmVyIGFjY291bnQgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAqIGluc3RydWN0aW9ucy5cbiAgICpcbiAgICogQWxsIHRoZSBjYXZlYXRzIGZyb20gdGhlIGBzaWduYCBtZXRob2QgYXBwbHkgdG8gYHBhcnRpYWxTaWduYFxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5PFNpZ25lcj59IHNpZ25lcnMgQXJyYXkgb2Ygc2lnbmVycyB0aGF0IHdpbGwgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICovXG4gIHBhcnRpYWxTaWduKC4uLmUpIHtcbiAgICBpZiAoZS5sZW5ndGggPT09IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBzaWduZXJzXCIpO1xuICAgIGNvbnN0IHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLCByID0gW107XG4gICAgZm9yIChjb25zdCBpIG9mIGUpIHtcbiAgICAgIGNvbnN0IG8gPSBpLnB1YmxpY0tleS50b1N0cmluZygpO1xuICAgICAgdC5oYXMobykgfHwgKHQuYWRkKG8pLCByLnB1c2goaSkpO1xuICAgIH1cbiAgICBjb25zdCBuID0gdGhpcy5fY29tcGlsZSgpO1xuICAgIHRoaXMuX3BhcnRpYWxTaWduKG4sIC4uLnIpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9wYXJ0aWFsU2lnbihlLCAuLi50KSB7XG4gICAgY29uc3QgciA9IGUuc2VyaWFsaXplKCk7XG4gICAgdC5mb3JFYWNoKChuKSA9PiB7XG4gICAgICBjb25zdCBpID0gTzAociwgbi5zZWNyZXRLZXkpO1xuICAgICAgdGhpcy5fYWRkU2lnbmF0dXJlKG4ucHVibGljS2V5LCBydShpKSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFkZCBhbiBleHRlcm5hbGx5IGNyZWF0ZWQgc2lnbmF0dXJlIHRvIGEgdHJhbnNhY3Rpb24uIFRoZSBwdWJsaWMga2V5XG4gICAqIG11c3QgY29ycmVzcG9uZCB0byBlaXRoZXIgdGhlIGZlZSBwYXllciBvciBhIHNpZ25lciBhY2NvdW50IGluIHRoZSB0cmFuc2FjdGlvblxuICAgKiBpbnN0cnVjdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7UHVibGljS2V5fSBwdWJrZXkgUHVibGljIGtleSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHRyYW5zYWN0aW9uLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gc2lnbmF0dXJlIEFuIGV4dGVybmFsbHkgY3JlYXRlZCBzaWduYXR1cmUgdG8gYWRkIHRvIHRoZSB0cmFuc2FjdGlvbi5cbiAgICovXG4gIGFkZFNpZ25hdHVyZShlLCB0KSB7XG4gICAgdGhpcy5fY29tcGlsZSgpLCB0aGlzLl9hZGRTaWduYXR1cmUoZSwgdCk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2FkZFNpZ25hdHVyZShlLCB0KSB7XG4gICAgS3QodC5sZW5ndGggPT09IDY0KTtcbiAgICBjb25zdCByID0gdGhpcy5zaWduYXR1cmVzLmZpbmRJbmRleCgobikgPT4gZS5lcXVhbHMobi5wdWJsaWNLZXkpKTtcbiAgICBpZiAociA8IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gc2lnbmVyOiAke2UudG9TdHJpbmcoKX1gKTtcbiAgICB0aGlzLnNpZ25hdHVyZXNbcl0uc2lnbmF0dXJlID0gSGUuQnVmZmVyLmZyb20odCk7XG4gIH1cbiAgLyoqXG4gICAqIFZlcmlmeSBzaWduYXR1cmVzIG9mIGEgVHJhbnNhY3Rpb25cbiAgICogT3B0aW9uYWwgcGFyYW1ldGVyIHNwZWNpZmllcyBpZiB3ZSdyZSBleHBlY3RpbmcgYSBmdWxseSBzaWduZWQgVHJhbnNhY3Rpb24gb3IgYSBwYXJ0aWFsbHkgc2lnbmVkIG9uZS5cbiAgICogSWYgbm8gYm9vbGVhbiBpcyBwcm92aWRlZCwgd2UgZXhwZWN0IGEgZnVsbHkgc2lnbmVkIFRyYW5zYWN0aW9uIGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVpcmVBbGxTaWduYXR1cmVzPXRydWVdIFJlcXVpcmUgYSBmdWxseSBzaWduZWQgVHJhbnNhY3Rpb25cbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZXMoZSA9ICEwKSB7XG4gICAgcmV0dXJuICF0aGlzLl9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyh0aGlzLnNlcmlhbGl6ZU1lc3NhZ2UoKSwgZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2dldE1lc3NhZ2VTaWduZWRuZXNzRXJyb3JzKGUsIHQpIHtcbiAgICBjb25zdCByID0ge307XG4gICAgZm9yIChjb25zdCB7XG4gICAgICBzaWduYXR1cmU6IG4sXG4gICAgICBwdWJsaWNLZXk6IGlcbiAgICB9IG9mIHRoaXMuc2lnbmF0dXJlcylcbiAgICAgIG4gPT09IG51bGwgPyB0ICYmIChyLm1pc3NpbmcgfHwgKHIubWlzc2luZyA9IFtdKSkucHVzaChpKSA6IGFFKG4sIGUsIGkudG9CeXRlcygpKSB8fCAoci5pbnZhbGlkIHx8IChyLmludmFsaWQgPSBbXSkpLnB1c2goaSk7XG4gICAgcmV0dXJuIHIuaW52YWxpZCB8fCByLm1pc3NpbmcgPyByIDogdm9pZCAwO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIFRyYW5zYWN0aW9uIGluIHRoZSB3aXJlIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtjb25maWddIENvbmZpZyBvZiB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge0J1ZmZlcn0gU2lnbmF0dXJlIG9mIHRyYW5zYWN0aW9uIGluIHdpcmUgZm9ybWF0LlxuICAgKi9cbiAgc2VyaWFsaXplKGUpIHtcbiAgICBjb25zdCB7XG4gICAgICByZXF1aXJlQWxsU2lnbmF0dXJlczogdCxcbiAgICAgIHZlcmlmeVNpZ25hdHVyZXM6IHJcbiAgICB9ID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICByZXF1aXJlQWxsU2lnbmF0dXJlczogITAsXG4gICAgICB2ZXJpZnlTaWduYXR1cmVzOiAhMFxuICAgIH0sIGUpLCBuID0gdGhpcy5zZXJpYWxpemVNZXNzYWdlKCk7XG4gICAgaWYgKHIpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLl9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyhuLCB0KTtcbiAgICAgIGlmIChpKSB7XG4gICAgICAgIGxldCBvID0gXCJTaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZC5cIjtcbiAgICAgICAgdGhyb3cgaS5pbnZhbGlkICYmIChvICs9IGBcbkludmFsaWQgc2lnbmF0dXJlIGZvciBwdWJsaWMga2V5JHtpLmludmFsaWQubGVuZ3RoID09PSAxID8gXCJcIiA6IFwiKHMpXCJ9IFtcXGAke2kuaW52YWxpZC5tYXAoKGEpID0+IGEudG9CYXNlNTgoKSkuam9pbihcImAsIGBcIil9XFxgXS5gKSwgaS5taXNzaW5nICYmIChvICs9IGBcbk1pc3Npbmcgc2lnbmF0dXJlIGZvciBwdWJsaWMga2V5JHtpLm1pc3NpbmcubGVuZ3RoID09PSAxID8gXCJcIiA6IFwiKHMpXCJ9IFtcXGAke2kubWlzc2luZy5tYXAoKGEpID0+IGEudG9CYXNlNTgoKSkuam9pbihcImAsIGBcIil9XFxgXS5gKSwgbmV3IEVycm9yKG8pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXplKG4pO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXJpYWxpemUoZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNpZ25hdHVyZXM6IHRcbiAgICB9ID0gdGhpcywgciA9IFtdO1xuICAgIHhyKHIsIHQubGVuZ3RoKTtcbiAgICBjb25zdCBuID0gci5sZW5ndGggKyB0Lmxlbmd0aCAqIDY0ICsgZS5sZW5ndGgsIGkgPSBIZS5CdWZmZXIuYWxsb2Mobik7XG4gICAgcmV0dXJuIEt0KHQubGVuZ3RoIDwgMjU2KSwgSGUuQnVmZmVyLmZyb20ocikuY29weShpLCAwKSwgdC5mb3JFYWNoKCh7XG4gICAgICBzaWduYXR1cmU6IG9cbiAgICB9LCBhKSA9PiB7XG4gICAgICBvICE9PSBudWxsICYmIChLdChvLmxlbmd0aCA9PT0gNjQsIFwic2lnbmF0dXJlIGhhcyBpbnZhbGlkIGxlbmd0aFwiKSwgSGUuQnVmZmVyLmZyb20obykuY29weShpLCByLmxlbmd0aCArIGEgKiA2NCkpO1xuICAgIH0pLCBlLmNvcHkoaSwgci5sZW5ndGggKyB0Lmxlbmd0aCAqIDY0KSwgS3QoaS5sZW5ndGggPD0gd24sIGBUcmFuc2FjdGlvbiB0b28gbGFyZ2U6ICR7aS5sZW5ndGh9ID4gJHt3bn1gKSwgaTtcbiAgfVxuICAvKipcbiAgICogRGVwcmVjYXRlZCBtZXRob2RcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQga2V5cygpIHtcbiAgICByZXR1cm4gS3QodGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoID09PSAxKSwgdGhpcy5pbnN0cnVjdGlvbnNbMF0ua2V5cy5tYXAoKGUpID0+IGUucHVia2V5KTtcbiAgfVxuICAvKipcbiAgICogRGVwcmVjYXRlZCBtZXRob2RcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQgcHJvZ3JhbUlkKCkge1xuICAgIHJldHVybiBLdCh0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPT09IDEpLCB0aGlzLmluc3RydWN0aW9uc1swXS5wcm9ncmFtSWQ7XG4gIH1cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgbWV0aG9kXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIEt0KHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMSksIHRoaXMuaW5zdHJ1Y3Rpb25zWzBdLmRhdGE7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGEgd2lyZSB0cmFuc2FjdGlvbiBpbnRvIGEgVHJhbnNhY3Rpb24gb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlciB8IFVpbnQ4QXJyYXkgfCBBcnJheTxudW1iZXI+fSBidWZmZXIgU2lnbmF0dXJlIG9mIHdpcmUgVHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufSBUcmFuc2FjdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHNpZ25hdHVyZVxuICAgKi9cbiAgc3RhdGljIGZyb20oZSkge1xuICAgIGxldCB0ID0gWy4uLmVdO1xuICAgIGNvbnN0IHIgPSBFcih0KTtcbiAgICBsZXQgbiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcjsgaSsrKSB7XG4gICAgICBjb25zdCBvID0gU3IodCwgMCwgR28pO1xuICAgICAgbi5wdXNoKGFyLmVuY29kZShIZS5CdWZmZXIuZnJvbShvKSkpO1xuICAgIH1cbiAgICByZXR1cm4gS28ucG9wdWxhdGUoTW4uZnJvbSh0KSwgbik7XG4gIH1cbiAgLyoqXG4gICAqIFBvcHVsYXRlIFRyYW5zYWN0aW9uIG9iamVjdCBmcm9tIG1lc3NhZ2UgYW5kIHNpZ25hdHVyZXNcbiAgICpcbiAgICogQHBhcmFtIHtNZXNzYWdlfSBtZXNzYWdlIE1lc3NhZ2Ugb2YgdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBzaWduYXR1cmVzIExpc3Qgb2Ygc2lnbmF0dXJlcyB0byBhc3NpZ24gdG8gdGhlIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEByZXR1cm5zIHtUcmFuc2FjdGlvbn0gVGhlIHBvcHVsYXRlZCBUcmFuc2FjdGlvblxuICAgKi9cbiAgc3RhdGljIHBvcHVsYXRlKGUsIHQgPSBbXSkge1xuICAgIGNvbnN0IHIgPSBuZXcgS28oKTtcbiAgICByZXR1cm4gci5yZWNlbnRCbG9ja2hhc2ggPSBlLnJlY2VudEJsb2NraGFzaCwgZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzID4gMCAmJiAoci5mZWVQYXllciA9IGUuYWNjb3VudEtleXNbMF0pLCB0LmZvckVhY2goKG4sIGkpID0+IHtcbiAgICAgIGNvbnN0IG8gPSB7XG4gICAgICAgIHNpZ25hdHVyZTogbiA9PSBhci5lbmNvZGUobUUpID8gbnVsbCA6IGFyLmRlY29kZShuKSxcbiAgICAgICAgcHVibGljS2V5OiBlLmFjY291bnRLZXlzW2ldXG4gICAgICB9O1xuICAgICAgci5zaWduYXR1cmVzLnB1c2gobyk7XG4gICAgfSksIGUuaW5zdHJ1Y3Rpb25zLmZvckVhY2goKG4pID0+IHtcbiAgICAgIGNvbnN0IGkgPSBuLmFjY291bnRzLm1hcCgobykgPT4ge1xuICAgICAgICBjb25zdCBhID0gZS5hY2NvdW50S2V5c1tvXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwdWJrZXk6IGEsXG4gICAgICAgICAgaXNTaWduZXI6IHIuc2lnbmF0dXJlcy5zb21lKChsKSA9PiBsLnB1YmxpY0tleS50b1N0cmluZygpID09PSBhLnRvU3RyaW5nKCkpIHx8IGUuaXNBY2NvdW50U2lnbmVyKG8pLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGUuaXNBY2NvdW50V3JpdGFibGUobylcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgci5pbnN0cnVjdGlvbnMucHVzaChuZXcgVWQoe1xuICAgICAgICBrZXlzOiBpLFxuICAgICAgICBwcm9ncmFtSWQ6IGUuYWNjb3VudEtleXNbbi5wcm9ncmFtSWRJbmRleF0sXG4gICAgICAgIGRhdGE6IGFyLmRlY29kZShuLmRhdGEpXG4gICAgICB9KSk7XG4gICAgfSksIHIuX21lc3NhZ2UgPSBlLCByLl9qc29uID0gci50b0pTT04oKSwgcjtcbiAgfVxufVxuY2xhc3MgaXUge1xuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlLnZlcnNpb247XG4gIH1cbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIGlmICh0aGlzLnNpZ25hdHVyZXMgPSB2b2lkIDAsIHRoaXMubWVzc2FnZSA9IHZvaWQgMCwgdCAhPT0gdm9pZCAwKVxuICAgICAgS3QodC5sZW5ndGggPT09IGUuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcywgXCJFeHBlY3RlZCBzaWduYXR1cmVzIGxlbmd0aCB0byBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHJlcXVpcmVkIHNpZ25hdHVyZXNcIiksIHRoaXMuc2lnbmF0dXJlcyA9IHQ7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCByID0gW107XG4gICAgICBmb3IgKGxldCBuID0gMDsgbiA8IGUuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlczsgbisrKVxuICAgICAgICByLnB1c2gobmV3IFVpbnQ4QXJyYXkoR28pKTtcbiAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IHI7XG4gICAgfVxuICAgIHRoaXMubWVzc2FnZSA9IGU7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm1lc3NhZ2Uuc2VyaWFsaXplKCksIHQgPSBBcnJheSgpO1xuICAgIHhyKHQsIHRoaXMuc2lnbmF0dXJlcy5sZW5ndGgpO1xuICAgIGNvbnN0IHIgPSB6LnN0cnVjdChbei5ibG9iKHQubGVuZ3RoLCBcImVuY29kZWRTaWduYXR1cmVzTGVuZ3RoXCIpLCB6LnNlcShkRSgpLCB0aGlzLnNpZ25hdHVyZXMubGVuZ3RoLCBcInNpZ25hdHVyZXNcIiksIHouYmxvYihlLmxlbmd0aCwgXCJzZXJpYWxpemVkTWVzc2FnZVwiKV0pLCBuID0gbmV3IFVpbnQ4QXJyYXkoMjA0OCksIGkgPSByLmVuY29kZSh7XG4gICAgICBlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkodCksXG4gICAgICBzaWduYXR1cmVzOiB0aGlzLnNpZ25hdHVyZXMsXG4gICAgICBzZXJpYWxpemVkTWVzc2FnZTogZVxuICAgIH0sIG4pO1xuICAgIHJldHVybiBuLnNsaWNlKDAsIGkpO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShlKSB7XG4gICAgbGV0IHQgPSBbLi4uZV07XG4gICAgY29uc3QgciA9IFtdLCBuID0gRXIodCk7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBuOyBvKyspXG4gICAgICByLnB1c2gobmV3IFVpbnQ4QXJyYXkoU3IodCwgMCwgR28pKSk7XG4gICAgY29uc3QgaSA9IG51LmRlc2VyaWFsaXplKG5ldyBVaW50OEFycmF5KHQpKTtcbiAgICByZXR1cm4gbmV3IGl1KGksIHIpO1xuICB9XG4gIHNpZ24oZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm1lc3NhZ2Uuc2VyaWFsaXplKCksIHIgPSB0aGlzLm1lc3NhZ2Uuc3RhdGljQWNjb3VudEtleXMuc2xpY2UoMCwgdGhpcy5tZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpO1xuICAgIGZvciAoY29uc3QgbiBvZiBlKSB7XG4gICAgICBjb25zdCBpID0gci5maW5kSW5kZXgoKG8pID0+IG8uZXF1YWxzKG4ucHVibGljS2V5KSk7XG4gICAgICBLdChpID49IDAsIGBDYW5ub3Qgc2lnbiB3aXRoIG5vbiBzaWduZXIga2V5ICR7bi5wdWJsaWNLZXkudG9CYXNlNTgoKX1gKSwgdGhpcy5zaWduYXR1cmVzW2ldID0gTzAodCwgbi5zZWNyZXRLZXkpO1xuICAgIH1cbiAgfVxuICBhZGRTaWduYXR1cmUoZSwgdCkge1xuICAgIEt0KHQuYnl0ZUxlbmd0aCA9PT0gNjQsIFwiU2lnbmF0dXJlIG11c3QgYmUgNjQgYnl0ZXMgbG9uZ1wiKTtcbiAgICBjb25zdCBuID0gdGhpcy5tZXNzYWdlLnN0YXRpY0FjY291bnRLZXlzLnNsaWNlKDAsIHRoaXMubWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKS5maW5kSW5kZXgoKGkpID0+IGkuZXF1YWxzKGUpKTtcbiAgICBLdChuID49IDAsIGBDYW4gbm90IGFkZCBzaWduYXR1cmU7IFxcYCR7ZS50b0Jhc2U1OCgpfVxcYCBpcyBub3QgcmVxdWlyZWQgdG8gc2lnbiB0aGlzIHRyYW5zYWN0aW9uYCksIHRoaXMuc2lnbmF0dXJlc1tuXSA9IHQ7XG4gIH1cbn1cbm5ldyBPZShcIlN5c3ZhckMxb2NrMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcIik7XG5uZXcgT2UoXCJTeXN2YXJFcG9jaFNjaGVkdTFlMTExMTExMTExMTExMTExMTExMTExMTExXCIpO1xubmV3IE9lKFwiU3lzdmFyMW5zdHJ1Y3Rpb25zMTExMTExMTExMTExMTExMTExMTExMTExMVwiKTtcbm5ldyBPZShcIlN5c3ZhclJlY2VudEIxb2NrSGFzaGVzMTExMTExMTExMTExMTExMTExMTFcIik7XG5uZXcgT2UoXCJTeXN2YXJSZW50MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXCIpO1xubmV3IE9lKFwiU3lzdmFyUmV3YXJkczExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVwiKTtcbm5ldyBPZShcIlN5c3ZhclMxb3RIYXNoZXMxMTExMTExMTExMTExMTExMTExMTExMTExMTFcIik7XG5uZXcgT2UoXCJTeXN2YXJTMW90SGlzdG9yeTExMTExMTExMTExMTExMTExMTExMTExMTExXCIpO1xubmV3IE9lKFwiU3lzdmFyU3Rha2VIaXN0b3J5MTExMTExMTExMTExMTExMTExMTExMTExMVwiKTtcbmNvbnN0IHlFID0gei5udTY0KFwibGFtcG9ydHNQZXJTaWduYXR1cmVcIiksIHZFID0gei5zdHJ1Y3QoW3oudTMyKFwidmVyc2lvblwiKSwgei51MzIoXCJzdGF0ZVwiKSwgV2UoXCJhdXRob3JpemVkUHVia2V5XCIpLCBXZShcIm5vbmNlXCIpLCB6LnN0cnVjdChbeUVdLCBcImZlZUNhbGN1bGF0b3JcIildKTtcbnZFLnNwYW47XG5mdW5jdGlvbiBPbihzKSB7XG4gIGNvbnN0IGUgPSB6LmJsb2IoOCwgcyksIHQgPSBlLmRlY29kZS5iaW5kKGUpLCByID0gZS5lbmNvZGUuYmluZChlKSwgbiA9IGUsIGkgPSBwdigpO1xuICByZXR1cm4gbi5kZWNvZGUgPSAobywgYSkgPT4ge1xuICAgIGNvbnN0IGwgPSB0KG8sIGEpO1xuICAgIHJldHVybiBpLmRlY29kZShsKTtcbiAgfSwgbi5lbmNvZGUgPSAobywgYSwgbCkgPT4ge1xuICAgIGNvbnN0IGMgPSBpLmVuY29kZShvKTtcbiAgICByZXR1cm4gcihjLCBhLCBsKTtcbiAgfSwgbjtcbn1cbk9iamVjdC5mcmVlemUoe1xuICBDcmVhdGU6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IHouc3RydWN0KFt6LnUzMihcImluc3RydWN0aW9uXCIpLCB6Lm5zNjQoXCJsYW1wb3J0c1wiKSwgei5uczY0KFwic3BhY2VcIiksIFdlKFwicHJvZ3JhbUlkXCIpXSlcbiAgfSxcbiAgQXNzaWduOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiB6LnN0cnVjdChbei51MzIoXCJpbnN0cnVjdGlvblwiKSwgV2UoXCJwcm9ncmFtSWRcIildKVxuICB9LFxuICBUcmFuc2Zlcjoge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogei5zdHJ1Y3QoW3oudTMyKFwiaW5zdHJ1Y3Rpb25cIiksIE9uKFwibGFtcG9ydHNcIildKVxuICB9LFxuICBDcmVhdGVXaXRoU2VlZDoge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogei5zdHJ1Y3QoW3oudTMyKFwiaW5zdHJ1Y3Rpb25cIiksIFdlKFwiYmFzZVwiKSwgeG4oXCJzZWVkXCIpLCB6Lm5zNjQoXCJsYW1wb3J0c1wiKSwgei5uczY0KFwic3BhY2VcIiksIFdlKFwicHJvZ3JhbUlkXCIpXSlcbiAgfSxcbiAgQWR2YW5jZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogei5zdHJ1Y3QoW3oudTMyKFwiaW5zdHJ1Y3Rpb25cIildKVxuICB9LFxuICBXaXRoZHJhd05vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA1LFxuICAgIGxheW91dDogei5zdHJ1Y3QoW3oudTMyKFwiaW5zdHJ1Y3Rpb25cIiksIHoubnM2NChcImxhbXBvcnRzXCIpXSlcbiAgfSxcbiAgSW5pdGlhbGl6ZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA2LFxuICAgIGxheW91dDogei5zdHJ1Y3QoW3oudTMyKFwiaW5zdHJ1Y3Rpb25cIiksIFdlKFwiYXV0aG9yaXplZFwiKV0pXG4gIH0sXG4gIEF1dGhvcml6ZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA3LFxuICAgIGxheW91dDogei5zdHJ1Y3QoW3oudTMyKFwiaW5zdHJ1Y3Rpb25cIiksIFdlKFwiYXV0aG9yaXplZFwiKV0pXG4gIH0sXG4gIEFsbG9jYXRlOiB7XG4gICAgaW5kZXg6IDgsXG4gICAgbGF5b3V0OiB6LnN0cnVjdChbei51MzIoXCJpbnN0cnVjdGlvblwiKSwgei5uczY0KFwic3BhY2VcIildKVxuICB9LFxuICBBbGxvY2F0ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDksXG4gICAgbGF5b3V0OiB6LnN0cnVjdChbei51MzIoXCJpbnN0cnVjdGlvblwiKSwgV2UoXCJiYXNlXCIpLCB4bihcInNlZWRcIiksIHoubnM2NChcInNwYWNlXCIpLCBXZShcInByb2dyYW1JZFwiKV0pXG4gIH0sXG4gIEFzc2lnbldpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDEwLFxuICAgIGxheW91dDogei5zdHJ1Y3QoW3oudTMyKFwiaW5zdHJ1Y3Rpb25cIiksIFdlKFwiYmFzZVwiKSwgeG4oXCJzZWVkXCIpLCBXZShcInByb2dyYW1JZFwiKV0pXG4gIH0sXG4gIFRyYW5zZmVyV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogMTEsXG4gICAgbGF5b3V0OiB6LnN0cnVjdChbei51MzIoXCJpbnN0cnVjdGlvblwiKSwgT24oXCJsYW1wb3J0c1wiKSwgeG4oXCJzZWVkXCIpLCBXZShcInByb2dyYW1JZFwiKV0pXG4gIH0sXG4gIFVwZ3JhZGVOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogMTIsXG4gICAgbGF5b3V0OiB6LnN0cnVjdChbei51MzIoXCJpbnN0cnVjdGlvblwiKV0pXG4gIH1cbn0pO1xubmV3IE9lKFwiMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcIik7XG5uZXcgT2UoXCJCUEZMb2FkZXIyMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXCIpO1xuei5zdHJ1Y3QoW1xuICB6LnUzMihcInR5cGVJbmRleFwiKSxcbiAgT24oXCJkZWFjdGl2YXRpb25TbG90XCIpLFxuICB6Lm51NjQoXCJsYXN0RXh0ZW5kZWRTbG90XCIpLFxuICB6LnU4KFwibGFzdEV4dGVuZGVkU3RhcnRJbmRleFwiKSxcbiAgei51OCgpLFxuICAvLyBvcHRpb25cbiAgei5zZXEoV2UoKSwgei5vZmZzZXQoei51OCgpLCAtMSksIFwiYXV0aG9yaXR5XCIpXG5dKTtcbmNvbnN0IFN0ID0gRGkoUWMoT2UpLCBjZSgpLCAocykgPT4gbmV3IE9lKHMpKSwgTjAgPSBldShbY2UoKSwgcHQoXCJiYXNlNjRcIildKSwgb3UgPSBEaShRYyhIZS5CdWZmZXIpLCBOMCwgKHMpID0+IEhlLkJ1ZmZlci5mcm9tKHNbMF0sIFwiYmFzZTY0XCIpKTtcbmZ1bmN0aW9uIFUwKHMpIHtcbiAgcmV0dXJuIHVyKFtvZSh7XG4gICAganNvbnJwYzogcHQoXCIyLjBcIiksXG4gICAgaWQ6IGNlKCksXG4gICAgcmVzdWx0OiBzXG4gIH0pLCBvZSh7XG4gICAganNvbnJwYzogcHQoXCIyLjBcIiksXG4gICAgaWQ6IGNlKCksXG4gICAgZXJyb3I6IG9lKHtcbiAgICAgIGNvZGU6IEduKCksXG4gICAgICBtZXNzYWdlOiBjZSgpLFxuICAgICAgZGF0YTogU2UoYnYoKSlcbiAgICB9KVxuICB9KV0pO1xufVxuY29uc3QgRUUgPSBVMChHbigpKTtcbmZ1bmN0aW9uIGx0KHMpIHtcbiAgcmV0dXJuIERpKFUwKHMpLCBFRSwgKGUpID0+IFwiZXJyb3JcIiBpbiBlID8gZSA6IHtcbiAgICAuLi5lLFxuICAgIHJlc3VsdDogdGkoZS5yZXN1bHQsIHMpXG4gIH0pO1xufVxuZnVuY3Rpb24gRnIocykge1xuICByZXR1cm4gbHQob2Uoe1xuICAgIGNvbnRleHQ6IG9lKHtcbiAgICAgIHNsb3Q6IHRlKClcbiAgICB9KSxcbiAgICB2YWx1ZTogc1xuICB9KSk7XG59XG5mdW5jdGlvbiBnYShzKSB7XG4gIHJldHVybiBvZSh7XG4gICAgY29udGV4dDogb2Uoe1xuICAgICAgc2xvdDogdGUoKVxuICAgIH0pLFxuICAgIHZhbHVlOiBzXG4gIH0pO1xufVxuY29uc3QgeEUgPSBvZSh7XG4gIGZvdW5kYXRpb246IHRlKCksXG4gIGZvdW5kYXRpb25UZXJtOiB0ZSgpLFxuICBpbml0aWFsOiB0ZSgpLFxuICB0YXBlcjogdGUoKSxcbiAgdGVybWluYWw6IHRlKClcbn0pO1xubHQoZmUoZ2Uob2Uoe1xuICBlcG9jaDogdGUoKSxcbiAgZWZmZWN0aXZlU2xvdDogdGUoKSxcbiAgYW1vdW50OiB0ZSgpLFxuICBwb3N0QmFsYW5jZTogdGUoKSxcbiAgY29tbWlzc2lvbjogU2UoZ2UodGUoKSkpXG59KSkpKTtcbmNvbnN0IFNFID0gZmUob2Uoe1xuICBzbG90OiB0ZSgpLFxuICBwcmlvcml0aXphdGlvbkZlZTogdGUoKVxufSkpLCBiRSA9IG9lKHtcbiAgdG90YWw6IHRlKCksXG4gIHZhbGlkYXRvcjogdGUoKSxcbiAgZm91bmRhdGlvbjogdGUoKSxcbiAgZXBvY2g6IHRlKClcbn0pLCBURSA9IG9lKHtcbiAgZXBvY2g6IHRlKCksXG4gIHNsb3RJbmRleDogdGUoKSxcbiAgc2xvdHNJbkVwb2NoOiB0ZSgpLFxuICBhYnNvbHV0ZVNsb3Q6IHRlKCksXG4gIGJsb2NrSGVpZ2h0OiBTZSh0ZSgpKSxcbiAgdHJhbnNhY3Rpb25Db3VudDogU2UodGUoKSlcbn0pLCB3RSA9IG9lKHtcbiAgc2xvdHNQZXJFcG9jaDogdGUoKSxcbiAgbGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0OiB0ZSgpLFxuICB3YXJtdXA6IFhyKCksXG4gIGZpcnN0Tm9ybWFsRXBvY2g6IHRlKCksXG4gIGZpcnN0Tm9ybWFsU2xvdDogdGUoKVxufSksIEFFID0gVDAoY2UoKSwgZmUodGUoKSkpLCBybiA9IGdlKHVyKFtvZSh7fSksIGNlKCldKSksIElFID0gb2Uoe1xuICBlcnI6IHJuXG59KSwgX0UgPSBwdChcInJlY2VpdmVkU2lnbmF0dXJlXCIpO1xub2Uoe1xuICBcInNvbGFuYS1jb3JlXCI6IGNlKCksXG4gIFwiZmVhdHVyZS1zZXRcIjogU2UodGUoKSlcbn0pO1xuY29uc3QgUkUgPSBvZSh7XG4gIHByb2dyYW06IGNlKCksXG4gIHByb2dyYW1JZDogU3QsXG4gIHBhcnNlZDogR24oKVxufSksIExFID0gb2Uoe1xuICBwcm9ncmFtSWQ6IFN0LFxuICBhY2NvdW50czogZmUoU3QpLFxuICBkYXRhOiBjZSgpXG59KTtcbkZyKG9lKHtcbiAgZXJyOiBnZSh1cihbb2Uoe30pLCBjZSgpXSkpLFxuICBsb2dzOiBnZShmZShjZSgpKSksXG4gIGFjY291bnRzOiBTZShnZShmZShnZShvZSh7XG4gICAgZXhlY3V0YWJsZTogWHIoKSxcbiAgICBvd25lcjogY2UoKSxcbiAgICBsYW1wb3J0czogdGUoKSxcbiAgICBkYXRhOiBmZShjZSgpKSxcbiAgICByZW50RXBvY2g6IFNlKHRlKCkpXG4gIH0pKSkpKSxcbiAgdW5pdHNDb25zdW1lZDogU2UodGUoKSksXG4gIHJldHVybkRhdGE6IFNlKGdlKG9lKHtcbiAgICBwcm9ncmFtSWQ6IGNlKCksXG4gICAgZGF0YTogZXUoW2NlKCksIHB0KFwiYmFzZTY0XCIpXSlcbiAgfSkpKSxcbiAgaW5uZXJJbnN0cnVjdGlvbnM6IFNlKGdlKGZlKG9lKHtcbiAgICBpbmRleDogdGUoKSxcbiAgICBpbnN0cnVjdGlvbnM6IGZlKHVyKFtSRSwgTEVdKSlcbiAgfSkpKSlcbn0pKTtcbkZyKG9lKHtcbiAgYnlJZGVudGl0eTogVDAoY2UoKSwgZmUodGUoKSkpLFxuICByYW5nZTogb2Uoe1xuICAgIGZpcnN0U2xvdDogdGUoKSxcbiAgICBsYXN0U2xvdDogdGUoKVxuICB9KVxufSkpO1xubHQoeEUpO1xubHQoYkUpO1xubHQoU0UpO1xubHQoVEUpO1xubHQod0UpO1xubHQoQUUpO1xubHQodGUoKSk7XG5GcihvZSh7XG4gIHRvdGFsOiB0ZSgpLFxuICBjaXJjdWxhdGluZzogdGUoKSxcbiAgbm9uQ2lyY3VsYXRpbmc6IHRlKCksXG4gIG5vbkNpcmN1bGF0aW5nQWNjb3VudHM6IGZlKFN0KVxufSkpO1xuY29uc3QgQ0UgPSBvZSh7XG4gIGFtb3VudDogY2UoKSxcbiAgdWlBbW91bnQ6IGdlKHRlKCkpLFxuICBkZWNpbWFsczogdGUoKSxcbiAgdWlBbW91bnRTdHJpbmc6IFNlKGNlKCkpXG59KTtcbkZyKGZlKG9lKHtcbiAgYWRkcmVzczogU3QsXG4gIGFtb3VudDogY2UoKSxcbiAgdWlBbW91bnQ6IGdlKHRlKCkpLFxuICBkZWNpbWFsczogdGUoKSxcbiAgdWlBbW91bnRTdHJpbmc6IFNlKGNlKCkpXG59KSkpO1xuRnIoZmUob2Uoe1xuICBwdWJrZXk6IFN0LFxuICBhY2NvdW50OiBvZSh7XG4gICAgZXhlY3V0YWJsZTogWHIoKSxcbiAgICBvd25lcjogU3QsXG4gICAgbGFtcG9ydHM6IHRlKCksXG4gICAgZGF0YTogb3UsXG4gICAgcmVudEVwb2NoOiB0ZSgpXG4gIH0pXG59KSkpO1xuY29uc3QgcmMgPSBvZSh7XG4gIHByb2dyYW06IGNlKCksXG4gIHBhcnNlZDogR24oKSxcbiAgc3BhY2U6IHRlKClcbn0pO1xuRnIoZmUob2Uoe1xuICBwdWJrZXk6IFN0LFxuICBhY2NvdW50OiBvZSh7XG4gICAgZXhlY3V0YWJsZTogWHIoKSxcbiAgICBvd25lcjogU3QsXG4gICAgbGFtcG9ydHM6IHRlKCksXG4gICAgZGF0YTogcmMsXG4gICAgcmVudEVwb2NoOiB0ZSgpXG4gIH0pXG59KSkpO1xuRnIoZmUob2Uoe1xuICBsYW1wb3J0czogdGUoKSxcbiAgYWRkcmVzczogU3Rcbn0pKSk7XG5jb25zdCBhdSA9IG9lKHtcbiAgZXhlY3V0YWJsZTogWHIoKSxcbiAgb3duZXI6IFN0LFxuICBsYW1wb3J0czogdGUoKSxcbiAgZGF0YTogb3UsXG4gIHJlbnRFcG9jaDogdGUoKVxufSk7XG5vZSh7XG4gIHB1YmtleTogU3QsXG4gIGFjY291bnQ6IGF1XG59KTtcbmNvbnN0IGtFID0gRGkodXIoW1FjKEhlLkJ1ZmZlciksIHJjXSksIHVyKFtOMCwgcmNdKSwgKHMpID0+IEFycmF5LmlzQXJyYXkocykgPyB0aShzLCBvdSkgOiBzKSwgREUgPSBvZSh7XG4gIGV4ZWN1dGFibGU6IFhyKCksXG4gIG93bmVyOiBTdCxcbiAgbGFtcG9ydHM6IHRlKCksXG4gIGRhdGE6IGtFLFxuICByZW50RXBvY2g6IHRlKClcbn0pO1xub2Uoe1xuICBwdWJrZXk6IFN0LFxuICBhY2NvdW50OiBERVxufSk7XG5vZSh7XG4gIHN0YXRlOiB1cihbcHQoXCJhY3RpdmVcIiksIHB0KFwiaW5hY3RpdmVcIiksIHB0KFwiYWN0aXZhdGluZ1wiKSwgcHQoXCJkZWFjdGl2YXRpbmdcIildKSxcbiAgYWN0aXZlOiB0ZSgpLFxuICBpbmFjdGl2ZTogdGUoKVxufSk7XG5sdChmZShvZSh7XG4gIHNpZ25hdHVyZTogY2UoKSxcbiAgc2xvdDogdGUoKSxcbiAgZXJyOiBybixcbiAgbWVtbzogZ2UoY2UoKSksXG4gIGJsb2NrVGltZTogU2UoZ2UodGUoKSkpXG59KSkpO1xubHQoZmUob2Uoe1xuICBzaWduYXR1cmU6IGNlKCksXG4gIHNsb3Q6IHRlKCksXG4gIGVycjogcm4sXG4gIG1lbW86IGdlKGNlKCkpLFxuICBibG9ja1RpbWU6IFNlKGdlKHRlKCkpKVxufSkpKTtcbm9lKHtcbiAgc3Vic2NyaXB0aW9uOiB0ZSgpLFxuICByZXN1bHQ6IGdhKGF1KVxufSk7XG5jb25zdCBQRSA9IG9lKHtcbiAgcHVia2V5OiBTdCxcbiAgYWNjb3VudDogYXVcbn0pO1xub2Uoe1xuICBzdWJzY3JpcHRpb246IHRlKCksXG4gIHJlc3VsdDogZ2EoUEUpXG59KTtcbmNvbnN0IE1FID0gb2Uoe1xuICBwYXJlbnQ6IHRlKCksXG4gIHNsb3Q6IHRlKCksXG4gIHJvb3Q6IHRlKClcbn0pO1xub2Uoe1xuICBzdWJzY3JpcHRpb246IHRlKCksXG4gIHJlc3VsdDogTUVcbn0pO1xuY29uc3QgT0UgPSB1cihbb2Uoe1xuICB0eXBlOiB1cihbcHQoXCJmaXJzdFNocmVkUmVjZWl2ZWRcIiksIHB0KFwiY29tcGxldGVkXCIpLCBwdChcIm9wdGltaXN0aWNDb25maXJtYXRpb25cIiksIHB0KFwicm9vdFwiKV0pLFxuICBzbG90OiB0ZSgpLFxuICB0aW1lc3RhbXA6IHRlKClcbn0pLCBvZSh7XG4gIHR5cGU6IHB0KFwiY3JlYXRlZEJhbmtcIiksXG4gIHBhcmVudDogdGUoKSxcbiAgc2xvdDogdGUoKSxcbiAgdGltZXN0YW1wOiB0ZSgpXG59KSwgb2Uoe1xuICB0eXBlOiBwdChcImZyb3plblwiKSxcbiAgc2xvdDogdGUoKSxcbiAgdGltZXN0YW1wOiB0ZSgpLFxuICBzdGF0czogb2Uoe1xuICAgIG51bVRyYW5zYWN0aW9uRW50cmllczogdGUoKSxcbiAgICBudW1TdWNjZXNzZnVsVHJhbnNhY3Rpb25zOiB0ZSgpLFxuICAgIG51bUZhaWxlZFRyYW5zYWN0aW9uczogdGUoKSxcbiAgICBtYXhUcmFuc2FjdGlvbnNQZXJFbnRyeTogdGUoKVxuICB9KVxufSksIG9lKHtcbiAgdHlwZTogcHQoXCJkZWFkXCIpLFxuICBzbG90OiB0ZSgpLFxuICB0aW1lc3RhbXA6IHRlKCksXG4gIGVycjogY2UoKVxufSldKTtcbm9lKHtcbiAgc3Vic2NyaXB0aW9uOiB0ZSgpLFxuICByZXN1bHQ6IE9FXG59KTtcbm9lKHtcbiAgc3Vic2NyaXB0aW9uOiB0ZSgpLFxuICByZXN1bHQ6IGdhKHVyKFtJRSwgX0VdKSlcbn0pO1xub2Uoe1xuICBzdWJzY3JpcHRpb246IHRlKCksXG4gIHJlc3VsdDogdGUoKVxufSk7XG5vZSh7XG4gIHB1YmtleTogY2UoKSxcbiAgZ29zc2lwOiBnZShjZSgpKSxcbiAgdHB1OiBnZShjZSgpKSxcbiAgcnBjOiBnZShjZSgpKSxcbiAgdmVyc2lvbjogZ2UoY2UoKSlcbn0pO1xuY29uc3QgJGQgPSBvZSh7XG4gIHZvdGVQdWJrZXk6IGNlKCksXG4gIG5vZGVQdWJrZXk6IGNlKCksXG4gIGFjdGl2YXRlZFN0YWtlOiB0ZSgpLFxuICBlcG9jaFZvdGVBY2NvdW50OiBYcigpLFxuICBlcG9jaENyZWRpdHM6IGZlKGV1KFt0ZSgpLCB0ZSgpLCB0ZSgpXSkpLFxuICBjb21taXNzaW9uOiB0ZSgpLFxuICBsYXN0Vm90ZTogdGUoKSxcbiAgcm9vdFNsb3Q6IGdlKHRlKCkpXG59KTtcbmx0KG9lKHtcbiAgY3VycmVudDogZmUoJGQpLFxuICBkZWxpbnF1ZW50OiBmZSgkZClcbn0pKTtcbmNvbnN0IEJFID0gdXIoW3B0KFwicHJvY2Vzc2VkXCIpLCBwdChcImNvbmZpcm1lZFwiKSwgcHQoXCJmaW5hbGl6ZWRcIildKSwgRkUgPSBvZSh7XG4gIHNsb3Q6IHRlKCksXG4gIGNvbmZpcm1hdGlvbnM6IGdlKHRlKCkpLFxuICBlcnI6IHJuLFxuICBjb25maXJtYXRpb25TdGF0dXM6IFNlKEJFKVxufSk7XG5GcihmZShnZShGRSkpKTtcbmx0KHRlKCkpO1xuY29uc3QgJDAgPSBvZSh7XG4gIGFjY291bnRLZXk6IFN0LFxuICB3cml0YWJsZUluZGV4ZXM6IGZlKHRlKCkpLFxuICByZWFkb25seUluZGV4ZXM6IGZlKHRlKCkpXG59KSwgbHUgPSBvZSh7XG4gIHNpZ25hdHVyZXM6IGZlKGNlKCkpLFxuICBtZXNzYWdlOiBvZSh7XG4gICAgYWNjb3VudEtleXM6IGZlKGNlKCkpLFxuICAgIGhlYWRlcjogb2Uoe1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiB0ZSgpLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogdGUoKSxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogdGUoKVxuICAgIH0pLFxuICAgIGluc3RydWN0aW9uczogZmUob2Uoe1xuICAgICAgYWNjb3VudHM6IGZlKHRlKCkpLFxuICAgICAgZGF0YTogY2UoKSxcbiAgICAgIHByb2dyYW1JZEluZGV4OiB0ZSgpXG4gICAgfSkpLFxuICAgIHJlY2VudEJsb2NraGFzaDogY2UoKSxcbiAgICBhZGRyZXNzVGFibGVMb29rdXBzOiBTZShmZSgkMCkpXG4gIH0pXG59KSwgRzAgPSBvZSh7XG4gIHB1YmtleTogU3QsXG4gIHNpZ25lcjogWHIoKSxcbiAgd3JpdGFibGU6IFhyKCksXG4gIHNvdXJjZTogU2UodXIoW3B0KFwidHJhbnNhY3Rpb25cIiksIHB0KFwibG9va3VwVGFibGVcIildKSlcbn0pLCBWMCA9IG9lKHtcbiAgYWNjb3VudEtleXM6IGZlKEcwKSxcbiAgc2lnbmF0dXJlczogZmUoY2UoKSlcbn0pLCBqMCA9IG9lKHtcbiAgcGFyc2VkOiBHbigpLFxuICBwcm9ncmFtOiBjZSgpLFxuICBwcm9ncmFtSWQ6IFN0XG59KSwgSzAgPSBvZSh7XG4gIGFjY291bnRzOiBmZShTdCksXG4gIGRhdGE6IGNlKCksXG4gIHByb2dyYW1JZDogU3Rcbn0pLCBORSA9IHVyKFtLMCwgajBdKSwgVUUgPSB1cihbb2Uoe1xuICBwYXJzZWQ6IEduKCksXG4gIHByb2dyYW06IGNlKCksXG4gIHByb2dyYW1JZDogY2UoKVxufSksIG9lKHtcbiAgYWNjb3VudHM6IGZlKGNlKCkpLFxuICBkYXRhOiBjZSgpLFxuICBwcm9ncmFtSWQ6IGNlKClcbn0pXSksIEgwID0gRGkoTkUsIFVFLCAocykgPT4gXCJhY2NvdW50c1wiIGluIHMgPyB0aShzLCBLMCkgOiB0aShzLCBqMCkpLCBxMCA9IG9lKHtcbiAgc2lnbmF0dXJlczogZmUoY2UoKSksXG4gIG1lc3NhZ2U6IG9lKHtcbiAgICBhY2NvdW50S2V5czogZmUoRzApLFxuICAgIGluc3RydWN0aW9uczogZmUoSDApLFxuICAgIHJlY2VudEJsb2NraGFzaDogY2UoKSxcbiAgICBhZGRyZXNzVGFibGVMb29rdXBzOiBTZShnZShmZSgkMCkpKVxuICB9KVxufSksIEhvID0gb2Uoe1xuICBhY2NvdW50SW5kZXg6IHRlKCksXG4gIG1pbnQ6IGNlKCksXG4gIG93bmVyOiBTZShjZSgpKSxcbiAgcHJvZ3JhbUlkOiBTZShjZSgpKSxcbiAgdWlUb2tlbkFtb3VudDogQ0Vcbn0pLCBXMCA9IG9lKHtcbiAgd3JpdGFibGU6IGZlKFN0KSxcbiAgcmVhZG9ubHk6IGZlKFN0KVxufSksIHBhID0gb2Uoe1xuICBlcnI6IHJuLFxuICBmZWU6IHRlKCksXG4gIGlubmVySW5zdHJ1Y3Rpb25zOiBTZShnZShmZShvZSh7XG4gICAgaW5kZXg6IHRlKCksXG4gICAgaW5zdHJ1Y3Rpb25zOiBmZShvZSh7XG4gICAgICBhY2NvdW50czogZmUodGUoKSksXG4gICAgICBkYXRhOiBjZSgpLFxuICAgICAgcHJvZ3JhbUlkSW5kZXg6IHRlKClcbiAgICB9KSlcbiAgfSkpKSksXG4gIHByZUJhbGFuY2VzOiBmZSh0ZSgpKSxcbiAgcG9zdEJhbGFuY2VzOiBmZSh0ZSgpKSxcbiAgbG9nTWVzc2FnZXM6IFNlKGdlKGZlKGNlKCkpKSksXG4gIHByZVRva2VuQmFsYW5jZXM6IFNlKGdlKGZlKEhvKSkpLFxuICBwb3N0VG9rZW5CYWxhbmNlczogU2UoZ2UoZmUoSG8pKSksXG4gIGxvYWRlZEFkZHJlc3NlczogU2UoVzApLFxuICBjb21wdXRlVW5pdHNDb25zdW1lZDogU2UodGUoKSksXG4gIGNvc3RVbml0czogU2UodGUoKSlcbn0pLCBjdSA9IG9lKHtcbiAgZXJyOiBybixcbiAgZmVlOiB0ZSgpLFxuICBpbm5lckluc3RydWN0aW9uczogU2UoZ2UoZmUob2Uoe1xuICAgIGluZGV4OiB0ZSgpLFxuICAgIGluc3RydWN0aW9uczogZmUoSDApXG4gIH0pKSkpLFxuICBwcmVCYWxhbmNlczogZmUodGUoKSksXG4gIHBvc3RCYWxhbmNlczogZmUodGUoKSksXG4gIGxvZ01lc3NhZ2VzOiBTZShnZShmZShjZSgpKSkpLFxuICBwcmVUb2tlbkJhbGFuY2VzOiBTZShnZShmZShIbykpKSxcbiAgcG9zdFRva2VuQmFsYW5jZXM6IFNlKGdlKGZlKEhvKSkpLFxuICBsb2FkZWRBZGRyZXNzZXM6IFNlKFcwKSxcbiAgY29tcHV0ZVVuaXRzQ29uc3VtZWQ6IFNlKHRlKCkpLFxuICBjb3N0VW5pdHM6IFNlKHRlKCkpXG59KSwgVm4gPSB1cihbcHQoMCksIHB0KFwibGVnYWN5XCIpXSksIHNuID0gb2Uoe1xuICBwdWJrZXk6IGNlKCksXG4gIGxhbXBvcnRzOiB0ZSgpLFxuICBwb3N0QmFsYW5jZTogZ2UodGUoKSksXG4gIHJld2FyZFR5cGU6IGdlKGNlKCkpLFxuICBjb21taXNzaW9uOiBTZShnZSh0ZSgpKSlcbn0pO1xubHQoZ2Uob2Uoe1xuICBibG9ja2hhc2g6IGNlKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBjZSgpLFxuICBwYXJlbnRTbG90OiB0ZSgpLFxuICB0cmFuc2FjdGlvbnM6IGZlKG9lKHtcbiAgICB0cmFuc2FjdGlvbjogbHUsXG4gICAgbWV0YTogZ2UocGEpLFxuICAgIHZlcnNpb246IFNlKFZuKVxuICB9KSksXG4gIHJld2FyZHM6IFNlKGZlKHNuKSksXG4gIGJsb2NrVGltZTogZ2UodGUoKSksXG4gIGJsb2NrSGVpZ2h0OiBnZSh0ZSgpKVxufSkpKTtcbmx0KGdlKG9lKHtcbiAgYmxvY2toYXNoOiBjZSgpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogY2UoKSxcbiAgcGFyZW50U2xvdDogdGUoKSxcbiAgcmV3YXJkczogU2UoZmUoc24pKSxcbiAgYmxvY2tUaW1lOiBnZSh0ZSgpKSxcbiAgYmxvY2tIZWlnaHQ6IGdlKHRlKCkpXG59KSkpO1xubHQoZ2Uob2Uoe1xuICBibG9ja2hhc2g6IGNlKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBjZSgpLFxuICBwYXJlbnRTbG90OiB0ZSgpLFxuICB0cmFuc2FjdGlvbnM6IGZlKG9lKHtcbiAgICB0cmFuc2FjdGlvbjogVjAsXG4gICAgbWV0YTogZ2UocGEpLFxuICAgIHZlcnNpb246IFNlKFZuKVxuICB9KSksXG4gIHJld2FyZHM6IFNlKGZlKHNuKSksXG4gIGJsb2NrVGltZTogZ2UodGUoKSksXG4gIGJsb2NrSGVpZ2h0OiBnZSh0ZSgpKVxufSkpKTtcbmx0KGdlKG9lKHtcbiAgYmxvY2toYXNoOiBjZSgpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogY2UoKSxcbiAgcGFyZW50U2xvdDogdGUoKSxcbiAgdHJhbnNhY3Rpb25zOiBmZShvZSh7XG4gICAgdHJhbnNhY3Rpb246IHEwLFxuICAgIG1ldGE6IGdlKGN1KSxcbiAgICB2ZXJzaW9uOiBTZShWbilcbiAgfSkpLFxuICByZXdhcmRzOiBTZShmZShzbikpLFxuICBibG9ja1RpbWU6IGdlKHRlKCkpLFxuICBibG9ja0hlaWdodDogZ2UodGUoKSlcbn0pKSk7XG5sdChnZShvZSh7XG4gIGJsb2NraGFzaDogY2UoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IGNlKCksXG4gIHBhcmVudFNsb3Q6IHRlKCksXG4gIHRyYW5zYWN0aW9uczogZmUob2Uoe1xuICAgIHRyYW5zYWN0aW9uOiBWMCxcbiAgICBtZXRhOiBnZShjdSksXG4gICAgdmVyc2lvbjogU2UoVm4pXG4gIH0pKSxcbiAgcmV3YXJkczogU2UoZmUoc24pKSxcbiAgYmxvY2tUaW1lOiBnZSh0ZSgpKSxcbiAgYmxvY2tIZWlnaHQ6IGdlKHRlKCkpXG59KSkpO1xubHQoZ2Uob2Uoe1xuICBibG9ja2hhc2g6IGNlKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBjZSgpLFxuICBwYXJlbnRTbG90OiB0ZSgpLFxuICByZXdhcmRzOiBTZShmZShzbikpLFxuICBibG9ja1RpbWU6IGdlKHRlKCkpLFxuICBibG9ja0hlaWdodDogZ2UodGUoKSlcbn0pKSk7XG5sdChnZShvZSh7XG4gIGJsb2NraGFzaDogY2UoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IGNlKCksXG4gIHBhcmVudFNsb3Q6IHRlKCksXG4gIHRyYW5zYWN0aW9uczogZmUob2Uoe1xuICAgIHRyYW5zYWN0aW9uOiBsdSxcbiAgICBtZXRhOiBnZShwYSlcbiAgfSkpLFxuICByZXdhcmRzOiBTZShmZShzbikpLFxuICBibG9ja1RpbWU6IGdlKHRlKCkpXG59KSkpO1xubHQoZ2Uob2Uoe1xuICBibG9ja2hhc2g6IGNlKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBjZSgpLFxuICBwYXJlbnRTbG90OiB0ZSgpLFxuICBzaWduYXR1cmVzOiBmZShjZSgpKSxcbiAgYmxvY2tUaW1lOiBnZSh0ZSgpKVxufSkpKTtcbmx0KGdlKG9lKHtcbiAgc2xvdDogdGUoKSxcbiAgbWV0YTogZ2UocGEpLFxuICBibG9ja1RpbWU6IFNlKGdlKHRlKCkpKSxcbiAgdHJhbnNhY3Rpb246IGx1LFxuICB2ZXJzaW9uOiBTZShWbilcbn0pKSk7XG5sdChnZShvZSh7XG4gIHNsb3Q6IHRlKCksXG4gIHRyYW5zYWN0aW9uOiBxMCxcbiAgbWV0YTogZ2UoY3UpLFxuICBibG9ja1RpbWU6IFNlKGdlKHRlKCkpKSxcbiAgdmVyc2lvbjogU2UoVm4pXG59KSkpO1xuRnIob2Uoe1xuICBibG9ja2hhc2g6IGNlKCksXG4gIGxhc3RWYWxpZEJsb2NrSGVpZ2h0OiB0ZSgpXG59KSk7XG5GcihYcigpKTtcbmNvbnN0ICRFID0gb2Uoe1xuICBzbG90OiB0ZSgpLFxuICBudW1UcmFuc2FjdGlvbnM6IHRlKCksXG4gIG51bVNsb3RzOiB0ZSgpLFxuICBzYW1wbGVQZXJpb2RTZWNzOiB0ZSgpXG59KTtcbmx0KGZlKCRFKSk7XG5GcihnZShvZSh7XG4gIGZlZUNhbGN1bGF0b3I6IG9lKHtcbiAgICBsYW1wb3J0c1BlclNpZ25hdHVyZTogdGUoKVxuICB9KVxufSkpKTtcbmx0KGNlKCkpO1xubHQoY2UoKSk7XG5jb25zdCBHRSA9IG9lKHtcbiAgZXJyOiBybixcbiAgbG9nczogZmUoY2UoKSksXG4gIHNpZ25hdHVyZTogY2UoKVxufSk7XG5vZSh7XG4gIHJlc3VsdDogZ2EoR0UpLFxuICBzdWJzY3JpcHRpb246IHRlKClcbn0pO1xuT2JqZWN0LmZyZWV6ZSh7XG4gIENyZWF0ZUxvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiB6LnN0cnVjdChbei51MzIoXCJpbnN0cnVjdGlvblwiKSwgT24oXCJyZWNlbnRTbG90XCIpLCB6LnU4KFwiYnVtcFNlZWRcIildKVxuICB9LFxuICBGcmVlemVMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogei5zdHJ1Y3QoW3oudTMyKFwiaW5zdHJ1Y3Rpb25cIildKVxuICB9LFxuICBFeHRlbmRMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogei5zdHJ1Y3QoW3oudTMyKFwiaW5zdHJ1Y3Rpb25cIiksIE9uKCksIHouc2VxKFdlKCksIHoub2Zmc2V0KHoudTMyKCksIC04KSwgXCJhZGRyZXNzZXNcIildKVxuICB9LFxuICBEZWFjdGl2YXRlTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IHouc3RydWN0KFt6LnUzMihcImluc3RydWN0aW9uXCIpXSlcbiAgfSxcbiAgQ2xvc2VMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogei5zdHJ1Y3QoW3oudTMyKFwiaW5zdHJ1Y3Rpb25cIildKVxuICB9XG59KTtcbm5ldyBPZShcIkFkZHJlc3NMb29rdXBUYWIxZTExMTExMTExMTExMTExMTExMTExMTExMTFcIik7XG5PYmplY3QuZnJlZXplKHtcbiAgUmVxdWVzdFVuaXRzOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiB6LnN0cnVjdChbei51OChcImluc3RydWN0aW9uXCIpLCB6LnUzMihcInVuaXRzXCIpLCB6LnUzMihcImFkZGl0aW9uYWxGZWVcIildKVxuICB9LFxuICBSZXF1ZXN0SGVhcEZyYW1lOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiB6LnN0cnVjdChbei51OChcImluc3RydWN0aW9uXCIpLCB6LnUzMihcImJ5dGVzXCIpXSlcbiAgfSxcbiAgU2V0Q29tcHV0ZVVuaXRMaW1pdDoge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogei5zdHJ1Y3QoW3oudTgoXCJpbnN0cnVjdGlvblwiKSwgei51MzIoXCJ1bml0c1wiKV0pXG4gIH0sXG4gIFNldENvbXB1dGVVbml0UHJpY2U6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IHouc3RydWN0KFt6LnU4KFwiaW5zdHJ1Y3Rpb25cIiksIE9uKFwibWljcm9MYW1wb3J0c1wiKV0pXG4gIH1cbn0pO1xubmV3IE9lKFwiQ29tcHV0ZUJ1ZGdldDExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVwiKTtcbnouc3RydWN0KFt6LnU4KFwibnVtU2lnbmF0dXJlc1wiKSwgei51OChcInBhZGRpbmdcIiksIHoudTE2KFwic2lnbmF0dXJlT2Zmc2V0XCIpLCB6LnUxNihcInNpZ25hdHVyZUluc3RydWN0aW9uSW5kZXhcIiksIHoudTE2KFwicHVibGljS2V5T2Zmc2V0XCIpLCB6LnUxNihcInB1YmxpY0tleUluc3RydWN0aW9uSW5kZXhcIiksIHoudTE2KFwibWVzc2FnZURhdGFPZmZzZXRcIiksIHoudTE2KFwibWVzc2FnZURhdGFTaXplXCIpLCB6LnUxNihcIm1lc3NhZ2VJbnN0cnVjdGlvbkluZGV4XCIpXSk7XG5uZXcgT2UoXCJFZDI1NTE5U2lnVmVyaWZ5MTExMTExMTExMTExMTExMTExMTExMTExMTExXCIpO1xub0UudXRpbHMuaXNWYWxpZFByaXZhdGVLZXk7XG56LnN0cnVjdChbei51OChcIm51bVNpZ25hdHVyZXNcIiksIHoudTE2KFwic2lnbmF0dXJlT2Zmc2V0XCIpLCB6LnU4KFwic2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleFwiKSwgei51MTYoXCJldGhBZGRyZXNzT2Zmc2V0XCIpLCB6LnU4KFwiZXRoQWRkcmVzc0luc3RydWN0aW9uSW5kZXhcIiksIHoudTE2KFwibWVzc2FnZURhdGFPZmZzZXRcIiksIHoudTE2KFwibWVzc2FnZURhdGFTaXplXCIpLCB6LnU4KFwibWVzc2FnZUluc3RydWN0aW9uSW5kZXhcIiksIHouYmxvYigyMCwgXCJldGhBZGRyZXNzXCIpLCB6LmJsb2IoNjQsIFwic2lnbmF0dXJlXCIpLCB6LnU4KFwicmVjb3ZlcnlJZFwiKV0pO1xubmV3IE9lKFwiS2VjY2FrU2VjcDI1NmsxMTExMTExMTExMTExMTExMTExMTExMTExMTExMVwiKTtcbnZhciB6MDtcbm5ldyBPZShcIlN0YWtlQ29uZmlnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcIik7XG5jbGFzcyBZMCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgTG9ja3VwIG9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IoZSwgdCwgcikge1xuICAgIHRoaXMudW5peFRpbWVzdGFtcCA9IHZvaWQgMCwgdGhpcy5lcG9jaCA9IHZvaWQgMCwgdGhpcy5jdXN0b2RpYW4gPSB2b2lkIDAsIHRoaXMudW5peFRpbWVzdGFtcCA9IGUsIHRoaXMuZXBvY2ggPSB0LCB0aGlzLmN1c3RvZGlhbiA9IHI7XG4gIH1cbiAgLyoqXG4gICAqIERlZmF1bHQsIGluYWN0aXZlIExvY2t1cCB2YWx1ZVxuICAgKi9cbn1cbnowID0gWTA7XG5ZMC5kZWZhdWx0ID0gbmV3IHowKDAsIDAsIE9lLmRlZmF1bHQpO1xuT2JqZWN0LmZyZWV6ZSh7XG4gIEluaXRpYWxpemU6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IHouc3RydWN0KFt6LnUzMihcImluc3RydWN0aW9uXCIpLCBoRSgpLCBmRSgpXSlcbiAgfSxcbiAgQXV0aG9yaXplOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiB6LnN0cnVjdChbei51MzIoXCJpbnN0cnVjdGlvblwiKSwgV2UoXCJuZXdBdXRob3JpemVkXCIpLCB6LnUzMihcInN0YWtlQXV0aG9yaXphdGlvblR5cGVcIildKVxuICB9LFxuICBEZWxlZ2F0ZToge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogei5zdHJ1Y3QoW3oudTMyKFwiaW5zdHJ1Y3Rpb25cIildKVxuICB9LFxuICBTcGxpdDoge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogei5zdHJ1Y3QoW3oudTMyKFwiaW5zdHJ1Y3Rpb25cIiksIHoubnM2NChcImxhbXBvcnRzXCIpXSlcbiAgfSxcbiAgV2l0aGRyYXc6IHtcbiAgICBpbmRleDogNCxcbiAgICBsYXlvdXQ6IHouc3RydWN0KFt6LnUzMihcImluc3RydWN0aW9uXCIpLCB6Lm5zNjQoXCJsYW1wb3J0c1wiKV0pXG4gIH0sXG4gIERlYWN0aXZhdGU6IHtcbiAgICBpbmRleDogNSxcbiAgICBsYXlvdXQ6IHouc3RydWN0KFt6LnUzMihcImluc3RydWN0aW9uXCIpXSlcbiAgfSxcbiAgTWVyZ2U6IHtcbiAgICBpbmRleDogNyxcbiAgICBsYXlvdXQ6IHouc3RydWN0KFt6LnUzMihcImluc3RydWN0aW9uXCIpXSlcbiAgfSxcbiAgQXV0aG9yaXplV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogOCxcbiAgICBsYXlvdXQ6IHouc3RydWN0KFt6LnUzMihcImluc3RydWN0aW9uXCIpLCBXZShcIm5ld0F1dGhvcml6ZWRcIiksIHoudTMyKFwic3Rha2VBdXRob3JpemF0aW9uVHlwZVwiKSwgeG4oXCJhdXRob3JpdHlTZWVkXCIpLCBXZShcImF1dGhvcml0eU93bmVyXCIpXSlcbiAgfVxufSk7XG5uZXcgT2UoXCJTdGFrZTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExXCIpO1xuT2JqZWN0LmZyZWV6ZSh7XG4gIEluaXRpYWxpemVBY2NvdW50OiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiB6LnN0cnVjdChbei51MzIoXCJpbnN0cnVjdGlvblwiKSwgZ0UoKV0pXG4gIH0sXG4gIEF1dGhvcml6ZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogei5zdHJ1Y3QoW3oudTMyKFwiaW5zdHJ1Y3Rpb25cIiksIFdlKFwibmV3QXV0aG9yaXplZFwiKSwgei51MzIoXCJ2b3RlQXV0aG9yaXphdGlvblR5cGVcIildKVxuICB9LFxuICBXaXRoZHJhdzoge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogei5zdHJ1Y3QoW3oudTMyKFwiaW5zdHJ1Y3Rpb25cIiksIHoubnM2NChcImxhbXBvcnRzXCIpXSlcbiAgfSxcbiAgVXBkYXRlVmFsaWRhdG9ySWRlbnRpdHk6IHtcbiAgICBpbmRleDogNCxcbiAgICBsYXlvdXQ6IHouc3RydWN0KFt6LnUzMihcImluc3RydWN0aW9uXCIpXSlcbiAgfSxcbiAgQXV0aG9yaXplV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogMTAsXG4gICAgbGF5b3V0OiB6LnN0cnVjdChbei51MzIoXCJpbnN0cnVjdGlvblwiKSwgcEUoKV0pXG4gIH1cbn0pO1xubmV3IE9lKFwiVm90ZTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVwiKTtcbm5ldyBPZShcIlZhMWlkYXRvcjFuZm8xMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcIik7XG5vZSh7XG4gIG5hbWU6IGNlKCksXG4gIHdlYnNpdGU6IFNlKGNlKCkpLFxuICBkZXRhaWxzOiBTZShjZSgpKSxcbiAgaWNvblVybDogU2UoY2UoKSksXG4gIGtleWJhc2VVc2VybmFtZTogU2UoY2UoKSlcbn0pO1xubmV3IE9lKFwiVm90ZTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMVwiKTtcbnouc3RydWN0KFtcbiAgV2UoXCJub2RlUHVia2V5XCIpLFxuICBXZShcImF1dGhvcml6ZWRXaXRoZHJhd2VyXCIpLFxuICB6LnU4KFwiY29tbWlzc2lvblwiKSxcbiAgei5udTY0KCksXG4gIC8vIHZvdGVzLmxlbmd0aFxuICB6LnNlcSh6LnN0cnVjdChbei5udTY0KFwic2xvdFwiKSwgei51MzIoXCJjb25maXJtYXRpb25Db3VudFwiKV0pLCB6Lm9mZnNldCh6LnUzMigpLCAtOCksIFwidm90ZXNcIiksXG4gIHoudTgoXCJyb290U2xvdFZhbGlkXCIpLFxuICB6Lm51NjQoXCJyb290U2xvdFwiKSxcbiAgei5udTY0KCksXG4gIC8vIGF1dGhvcml6ZWRWb3RlcnMubGVuZ3RoXG4gIHouc2VxKHouc3RydWN0KFt6Lm51NjQoXCJlcG9jaFwiKSwgV2UoXCJhdXRob3JpemVkVm90ZXJcIildKSwgei5vZmZzZXQoei51MzIoKSwgLTgpLCBcImF1dGhvcml6ZWRWb3RlcnNcIiksXG4gIHouc3RydWN0KFt6LnNlcSh6LnN0cnVjdChbV2UoXCJhdXRob3JpemVkUHVia2V5XCIpLCB6Lm51NjQoXCJlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2hcIiksIHoubnU2NChcInRhcmdldEVwb2NoXCIpXSksIDMyLCBcImJ1ZlwiKSwgei5udTY0KFwiaWR4XCIpLCB6LnU4KFwiaXNFbXB0eVwiKV0sIFwicHJpb3JWb3RlcnNcIiksXG4gIHoubnU2NCgpLFxuICAvLyBlcG9jaENyZWRpdHMubGVuZ3RoXG4gIHouc2VxKHouc3RydWN0KFt6Lm51NjQoXCJlcG9jaFwiKSwgei5udTY0KFwiY3JlZGl0c1wiKSwgei5udTY0KFwicHJldkNyZWRpdHNcIildKSwgei5vZmZzZXQoei51MzIoKSwgLTgpLCBcImVwb2NoQ3JlZGl0c1wiKSxcbiAgei5zdHJ1Y3QoW3oubnU2NChcInNsb3RcIiksIHoubnU2NChcInRpbWVzdGFtcFwiKV0sIFwibGFzdFRpbWVzdGFtcFwiKVxuXSk7XG5jb25zdCBWRSA9IChzKSA9PiAoe1xuICByZXF1ZXN0OiBzLFxuICBzaWduTWVzc2FnZTogKGUpID0+IHMoeyBtZXRob2Q6IFwic2lnbk1lc3NhZ2VcIiwgcGFyYW1zOiB7IG1lc3NhZ2U6IGUgfSB9KSxcbiAgc2lnblRyYW5zYWN0aW9uOiAoZSkgPT4gcyh7IG1ldGhvZDogXCJzaWduVHJhbnNhY3Rpb25cIiwgcGFyYW1zOiB7IHRyYW5zYWN0aW9uOiBlIH0gfSksXG4gIHNpZ25BbmRTZW5kVHJhbnNhY3Rpb246IChlKSA9PiBzKHtcbiAgICBtZXRob2Q6IFwic2lnbkFuZFNlbmRUcmFuc2FjdGlvblwiLFxuICAgIHBhcmFtczogZVxuICB9KVxufSk7XG5mdW5jdGlvbiBHZChzKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShzLnNlcmlhbGl6ZSh7XG4gICAgdmVyaWZ5U2lnbmF0dXJlczogITFcbiAgfSkpLnRvU3RyaW5nKFwiYmFzZTY0XCIpO1xufVxuZnVuY3Rpb24gakUocykge1xuICBjb25zdCBlID0gQnVmZmVyLmZyb20ocywgXCJiYXNlNjRcIik7XG4gIHJldHVybiBudS5kZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uKGUpID09PSBcImxlZ2FjeVwiID8gaXUuZGVzZXJpYWxpemUoZSkgOiBLby5mcm9tKGUpO1xufVxuZnVuY3Rpb24gS0Uocykge1xuICByZXR1cm4gYXN5bmMgKHQpID0+IHtcbiAgICBpZiAodC5tZXRob2QgPT09IFwiY29ubmVjdFwiKVxuICAgICAgcmV0dXJuIGF3YWl0IHModCk7XG4gICAgaWYgKHQubWV0aG9kID09PSBcInNpZ25NZXNzYWdlXCIpXG4gICAgICByZXR1cm4gYXdhaXQgcyh0KTtcbiAgICBpZiAodC5tZXRob2QgPT09IFwic2lnbkFuZFNlbmRUcmFuc2FjdGlvblwiKSB7XG4gICAgICBjb25zdCB7IHRyYW5zYWN0aW9uOiByIH0gPSB0LnBhcmFtcywgbiA9IHtcbiAgICAgICAgdHJhbnNhY3Rpb246IEdkKHIpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGF3YWl0IHMoe1xuICAgICAgICBtZXRob2Q6IFwic2lnbkFuZFNlbmRUcmFuc2FjdGlvblwiLFxuICAgICAgICBwYXJhbXM6IG5cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAodC5tZXRob2QgPT09IFwic2lnblRyYW5zYWN0aW9uXCIpIHtcbiAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb246IHIgfSA9IHQucGFyYW1zLCBuID0ge1xuICAgICAgICB0cmFuc2FjdGlvbjogR2QocilcbiAgICAgIH0sIHsgc2lnbmVkVHJhbnNhY3Rpb246IGkgfSA9IGF3YWl0IHMoe1xuICAgICAgICBtZXRob2Q6IFwic2lnblRyYW5zYWN0aW9uXCIsXG4gICAgICAgIHBhcmFtczogblxuICAgICAgfSk7XG4gICAgICByZXR1cm4geyBzaWduZWRUcmFuc2FjdGlvbjogakUoaSkgfTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBIRSA9ICh7IG1pbmlBcHBIb3N0OiBzLCBlbWl0dGVyOiBlIH0pID0+IHtcbiAgbGV0IHQsIHIgPSBudWxsO1xuICByZXR1cm4ge1xuICAgIHZpc2libGU6ICExLFxuICAgIGdldCBvbmJhY2soKSB7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuICAgIHNldCBvbmJhY2sobikge1xuICAgICAgciAmJiBlLnJlbW92ZUxpc3RlbmVyKFwiYmFja05hdmlnYXRpb25UcmlnZ2VyZWRcIiwgciksIHIgPSBuLCBuICYmIGUuYWRkTGlzdGVuZXIoXCJiYWNrTmF2aWdhdGlvblRyaWdnZXJlZFwiLCBuKTtcbiAgICB9LFxuICAgIGFzeW5jIHNob3coKSB7XG4gICAgICBhd2FpdCBzLnVwZGF0ZUJhY2tTdGF0ZSh7XG4gICAgICAgIHZpc2libGU6ICEwXG4gICAgICB9KSwgdGhpcy52aXNpYmxlID0gITA7XG4gICAgfSxcbiAgICBhc3luYyBoaWRlKCkge1xuICAgICAgYXdhaXQgcy51cGRhdGVCYWNrU3RhdGUoe1xuICAgICAgICB2aXNpYmxlOiAhMVxuICAgICAgfSksIHRoaXMudmlzaWJsZSA9ICExO1xuICAgIH0sXG4gICAgYXN5bmMgZW5hYmxlV2ViTmF2aWdhdGlvbigpIHtcbiAgICAgIHQgPSBxRSh7XG4gICAgICAgIGJhY2s6IHRoaXMsXG4gICAgICAgIGVtaXR0ZXI6IGVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgYXN5bmMgZGlzYWJsZVdlYk5hdmlnYXRpb24oKSB7XG4gICAgICB0ID09IG51bGwgfHwgdCgpLCB0ID0gdm9pZCAwO1xuICAgIH1cbiAgfTtcbn07XG5mdW5jdGlvbiBxRSh7IGVtaXR0ZXI6IHMsIGJhY2s6IGUgfSkge1xuICBjb25zdCB0ID0gV0UoKTtcbiAgaWYgKHQpXG4gICAgcmV0dXJuIHpFKHsgZW1pdHRlcjogcywgYmFjazogZSwgbmF2aWdhdGlvbjogdCB9KTtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIilcbiAgICByZXR1cm4gWUUoeyBlbWl0dGVyOiBzLCBiYWNrOiBlLCB3aW5kb3cgfSk7XG59XG5mdW5jdGlvbiBXRSgpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPCBcInVcIiAmJiB3aW5kb3cubmF2aWdhdGlvbiAhPT0gdm9pZCAwKVxuICAgIHJldHVybiB3aW5kb3cubmF2aWdhdGlvbjtcbn1cbmZ1bmN0aW9uIHpFKHsgZW1pdHRlcjogcywgYmFjazogZSwgbmF2aWdhdGlvbjogdCB9KSB7XG4gIGZ1bmN0aW9uIHIoKSB7XG4gICAgdC5jYW5Hb0JhY2sgPyBlLnNob3coKSA6IGUuaGlkZSgpO1xuICB9XG4gIGZ1bmN0aW9uIG4oKSB7XG4gICAgZS52aXNpYmxlICYmIHQuY2FuR29CYWNrICYmIHQuYmFjaygpO1xuICB9XG4gIHJldHVybiB0LmFkZEV2ZW50TGlzdGVuZXIoXCJuYXZpZ2F0ZXN1Y2Nlc3NcIiwgciksIHMuYWRkTGlzdGVuZXIoXCJiYWNrTmF2aWdhdGlvblRyaWdnZXJlZFwiLCBuKSwgKCkgPT4ge1xuICAgIHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm5hdmlnYXRlc3VjY2Vzc1wiLCByKSwgcy5yZW1vdmVMaXN0ZW5lcihcImJhY2tOYXZpZ2F0aW9uVHJpZ2dlcmVkXCIsIG4pO1xuICB9O1xufVxuZnVuY3Rpb24gWUUoeyBlbWl0dGVyOiBzLCBiYWNrOiBlLCB3aW5kb3c6IHQgfSkge1xuICBlLnNob3coKTtcbiAgZnVuY3Rpb24gcigpIHtcbiAgICBlLnZpc2libGUgJiYgdC5oaXN0b3J5LmJhY2soKTtcbiAgfVxuICByZXR1cm4gcy5hZGRMaXN0ZW5lcihcImJhY2tOYXZpZ2F0aW9uVHJpZ2dlcmVkXCIsIHIpLCAoKSA9PiB7XG4gICAgcy5yZW1vdmVMaXN0ZW5lcihcImJhY2tOYXZpZ2F0aW9uVHJpZ2dlcmVkXCIsIHIpO1xuICB9O1xufVxuY29uc3QgWkUgPSBcIjAuMS4xXCI7XG5mdW5jdGlvbiBYRSgpIHtcbiAgcmV0dXJuIFpFO1xufVxubGV0IEpFID0gY2xhc3Mgc2MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGUsIHQgPSB7fSkge1xuICAgIGNvbnN0IHIgPSAoKCkgPT4ge1xuICAgICAgdmFyIGw7XG4gICAgICBpZiAodC5jYXVzZSBpbnN0YW5jZW9mIHNjKSB7XG4gICAgICAgIGlmICh0LmNhdXNlLmRldGFpbHMpXG4gICAgICAgICAgcmV0dXJuIHQuY2F1c2UuZGV0YWlscztcbiAgICAgICAgaWYgKHQuY2F1c2Uuc2hvcnRNZXNzYWdlKVxuICAgICAgICAgIHJldHVybiB0LmNhdXNlLnNob3J0TWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAobCA9IHQuY2F1c2UpICE9IG51bGwgJiYgbC5tZXNzYWdlID8gdC5jYXVzZS5tZXNzYWdlIDogdC5kZXRhaWxzO1xuICAgIH0pKCksIG4gPSB0LmNhdXNlIGluc3RhbmNlb2Ygc2MgJiYgdC5jYXVzZS5kb2NzUGF0aCB8fCB0LmRvY3NQYXRoLCBvID0gYGh0dHBzOi8vb3hsaWIuc2gke24gPz8gXCJcIn1gLCBhID0gW1xuICAgICAgZSB8fCBcIkFuIGVycm9yIG9jY3VycmVkLlwiLFxuICAgICAgLi4udC5tZXRhTWVzc2FnZXMgPyBbXCJcIiwgLi4udC5tZXRhTWVzc2FnZXNdIDogW10sXG4gICAgICAuLi5yIHx8IG4gPyBbXG4gICAgICAgIFwiXCIsXG4gICAgICAgIHIgPyBgRGV0YWlsczogJHtyfWAgOiB2b2lkIDAsXG4gICAgICAgIG4gPyBgU2VlOiAke299YCA6IHZvaWQgMFxuICAgICAgXSA6IFtdXG4gICAgXS5maWx0ZXIoKGwpID0+IHR5cGVvZiBsID09IFwic3RyaW5nXCIpLmpvaW4oYFxuYCk7XG4gICAgc3VwZXIoYSwgdC5jYXVzZSA/IHsgY2F1c2U6IHQuY2F1c2UgfSA6IHZvaWQgMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRldGFpbHNcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkb2NzXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZG9jc1BhdGhcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJzaG9ydE1lc3NhZ2VcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYXVzZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IFwiQmFzZUVycm9yXCJcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmVyc2lvblwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogYG94QCR7WEUoKX1gXG4gICAgfSksIHRoaXMuY2F1c2UgPSB0LmNhdXNlLCB0aGlzLmRldGFpbHMgPSByLCB0aGlzLmRvY3MgPSBvLCB0aGlzLmRvY3NQYXRoID0gbiwgdGhpcy5zaG9ydE1lc3NhZ2UgPSBlO1xuICB9XG4gIHdhbGsoZSkge1xuICAgIHJldHVybiBaMCh0aGlzLCBlKTtcbiAgfVxufTtcbmZ1bmN0aW9uIFowKHMsIGUpIHtcbiAgcmV0dXJuIGUgIT0gbnVsbCAmJiBlKHMpID8gcyA6IHMgJiYgdHlwZW9mIHMgPT0gXCJvYmplY3RcIiAmJiBcImNhdXNlXCIgaW4gcyAmJiBzLmNhdXNlID8gWjAocy5jYXVzZSwgZSkgOiBlID8gbnVsbCA6IHM7XG59XG5mdW5jdGlvbiBYMChzLCBlID0ge30pIHtcbiAgY29uc3QgeyByYXc6IHQgPSAhMSB9ID0gZSwgciA9IHM7XG4gIGlmICh0KVxuICAgIHJldHVybiBzO1xuICBpZiAoci5lcnJvcikge1xuICAgIGNvbnN0IHsgY29kZTogbiB9ID0gci5lcnJvciwgaSA9IG4gPT09IEJuLmNvZGUgPyBCbiA6IG4gPT09IHJpLmNvZGUgPyByaSA6IG4gPT09IGRpLmNvZGUgPyBkaSA6IG4gPT09IGNpLmNvZGUgPyBjaSA6IG4gPT09IGFpLmNvZGUgPyBhaSA6IG4gPT09IHVpLmNvZGUgPyB1aSA6IG4gPT09IG9pLmNvZGUgPyBvaSA6IG4gPT09IGhpLmNvZGUgPyBoaSA6IG4gPT09IHNpLmNvZGUgPyBzaSA6IG4gPT09IG5pLmNvZGUgPyBuaSA6IG4gPT09IGlpLmNvZGUgPyBpaSA6IG4gPT09IGxpLmNvZGUgPyBsaSA6IG1yO1xuICAgIHRocm93IG5ldyBpKHIuZXJyb3IpO1xuICB9XG4gIHJldHVybiByLnJlc3VsdDtcbn1cbmxldCBtciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgY29uc3QgeyBjb2RlOiB0LCBtZXNzYWdlOiByLCBkYXRhOiBuIH0gPSBlO1xuICAgIHN1cGVyKHIpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiBcIlJwY1Jlc3BvbnNlLkJhc2VFcnJvclwiXG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IHZvaWQgMFxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJkYXRhXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KSwgdGhpcy5jb2RlID0gdCwgdGhpcy5kYXRhID0gbjtcbiAgfVxufTtcbmNsYXNzIHJpIGV4dGVuZHMgbXIge1xuICBjb25zdHJ1Y3RvcihlID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBtZXNzYWdlOiBcIk1pc3Npbmcgb3IgaW52YWxpZCBwYXJhbWV0ZXJzLlwiLFxuICAgICAgLi4uZSxcbiAgICAgIGNvZGU6IHJpLmNvZGVcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogLTMyZTNcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogXCJScGNSZXNwb25zZS5JbnZhbGlkSW5wdXRFcnJvclwiXG4gICAgfSk7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShyaSwgXCJjb2RlXCIsIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGNvbmZpZ3VyYWJsZTogITAsXG4gIHdyaXRhYmxlOiAhMCxcbiAgdmFsdWU6IC0zMmUzXG59KTtcbmNsYXNzIHNpIGV4dGVuZHMgbXIge1xuICBjb25zdHJ1Y3RvcihlID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBtZXNzYWdlOiBcIlJlcXVlc3RlZCByZXNvdXJjZSBub3QgZm91bmQuXCIsXG4gICAgICAuLi5lLFxuICAgICAgY29kZTogc2kuY29kZVxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiAtMzIwMDFcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogXCJScGNSZXNwb25zZS5SZXNvdXJjZU5vdEZvdW5kRXJyb3JcIlxuICAgIH0pO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoc2ksIFwiY29kZVwiLCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlOiAtMzIwMDFcbn0pO1xuY2xhc3MgbmkgZXh0ZW5kcyBtciB7XG4gIGNvbnN0cnVjdG9yKGUgPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1lc3NhZ2U6IFwiUmVxdWVzdGVkIHJlc291cmNlIG5vdCBhdmFpbGFibGUuXCIsXG4gICAgICAuLi5lLFxuICAgICAgY29kZTogbmkuY29kZVxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiAtMzIwMDJcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogXCJScGNSZXNwb25zZS5SZXNvdXJjZVVuYXZhaWxhYmxlRXJyb3JcIlxuICAgIH0pO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkobmksIFwiY29kZVwiLCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlOiAtMzIwMDJcbn0pO1xuY2xhc3MgaWkgZXh0ZW5kcyBtciB7XG4gIGNvbnN0cnVjdG9yKGUgPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1lc3NhZ2U6IFwiVHJhbnNhY3Rpb24gY3JlYXRpb24gZmFpbGVkLlwiLFxuICAgICAgLi4uZSxcbiAgICAgIGNvZGU6IGlpLmNvZGVcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogLTMyMDAzXG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IFwiUnBjUmVzcG9uc2UuVHJhbnNhY3Rpb25SZWplY3RlZEVycm9yXCJcbiAgICB9KTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGlpLCBcImNvZGVcIiwge1xuICBlbnVtZXJhYmxlOiAhMCxcbiAgY29uZmlndXJhYmxlOiAhMCxcbiAgd3JpdGFibGU6ICEwLFxuICB2YWx1ZTogLTMyMDAzXG59KTtcbmNsYXNzIG9pIGV4dGVuZHMgbXIge1xuICBjb25zdHJ1Y3RvcihlID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBtZXNzYWdlOiBcIk1ldGhvZCBpcyBub3QgaW1wbGVtZW50ZWQuXCIsXG4gICAgICAuLi5lLFxuICAgICAgY29kZTogb2kuY29kZVxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiAtMzIwMDRcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogXCJScGNSZXNwb25zZS5NZXRob2ROb3RTdXBwb3J0ZWRFcnJvclwiXG4gICAgfSk7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShvaSwgXCJjb2RlXCIsIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGNvbmZpZ3VyYWJsZTogITAsXG4gIHdyaXRhYmxlOiAhMCxcbiAgdmFsdWU6IC0zMjAwNFxufSk7XG5jbGFzcyBhaSBleHRlbmRzIG1yIHtcbiAgY29uc3RydWN0b3IoZSA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbWVzc2FnZTogXCJSYXRlIGxpbWl0IGV4Y2VlZGVkLlwiLFxuICAgICAgLi4uZSxcbiAgICAgIGNvZGU6IGFpLmNvZGVcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogLTMyMDA1XG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IFwiUnBjUmVzcG9uc2UuTGltaXRFeGNlZWRlZEVycm9yXCJcbiAgICB9KTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGFpLCBcImNvZGVcIiwge1xuICBlbnVtZXJhYmxlOiAhMCxcbiAgY29uZmlndXJhYmxlOiAhMCxcbiAgd3JpdGFibGU6ICEwLFxuICB2YWx1ZTogLTMyMDA1XG59KTtcbmNsYXNzIGxpIGV4dGVuZHMgbXIge1xuICBjb25zdHJ1Y3RvcihlID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBtZXNzYWdlOiBcIkpTT04tUlBDIHZlcnNpb24gbm90IHN1cHBvcnRlZC5cIixcbiAgICAgIC4uLmUsXG4gICAgICBjb2RlOiBsaS5jb2RlXG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvZGVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IC0zMjAwNlxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiBcIlJwY1Jlc3BvbnNlLlZlcnNpb25Ob3RTdXBwb3J0ZWRFcnJvclwiXG4gICAgfSk7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShsaSwgXCJjb2RlXCIsIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGNvbmZpZ3VyYWJsZTogITAsXG4gIHdyaXRhYmxlOiAhMCxcbiAgdmFsdWU6IC0zMjAwNlxufSk7XG5jbGFzcyBjaSBleHRlbmRzIG1yIHtcbiAgY29uc3RydWN0b3IoZSA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbWVzc2FnZTogXCJJbnB1dCBpcyBub3QgYSB2YWxpZCBKU09OLVJQQyByZXF1ZXN0LlwiLFxuICAgICAgLi4uZSxcbiAgICAgIGNvZGU6IGNpLmNvZGVcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogLTMyNjAwXG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IFwiUnBjUmVzcG9uc2UuSW52YWxpZFJlcXVlc3RFcnJvclwiXG4gICAgfSk7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShjaSwgXCJjb2RlXCIsIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGNvbmZpZ3VyYWJsZTogITAsXG4gIHdyaXRhYmxlOiAhMCxcbiAgdmFsdWU6IC0zMjYwMFxufSk7XG5jbGFzcyB1aSBleHRlbmRzIG1yIHtcbiAgY29uc3RydWN0b3IoZSA9IHt9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbWVzc2FnZTogXCJNZXRob2QgZG9lcyBub3QgZXhpc3QuXCIsXG4gICAgICAuLi5lLFxuICAgICAgY29kZTogdWkuY29kZVxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiAtMzI2MDFcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogXCJScGNSZXNwb25zZS5NZXRob2ROb3RGb3VuZEVycm9yXCJcbiAgICB9KTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHVpLCBcImNvZGVcIiwge1xuICBlbnVtZXJhYmxlOiAhMCxcbiAgY29uZmlndXJhYmxlOiAhMCxcbiAgd3JpdGFibGU6ICEwLFxuICB2YWx1ZTogLTMyNjAxXG59KTtcbmNsYXNzIGRpIGV4dGVuZHMgbXIge1xuICBjb25zdHJ1Y3RvcihlID0ge30pIHtcbiAgICBzdXBlcih7XG4gICAgICBtZXNzYWdlOiBcIkludmFsaWQgbWV0aG9kIHBhcmFtZXRlcnMuXCIsXG4gICAgICAuLi5lLFxuICAgICAgY29kZTogZGkuY29kZVxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiAtMzI2MDJcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogXCJScGNSZXNwb25zZS5JbnZhbGlkUGFyYW1zRXJyb3JcIlxuICAgIH0pO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZGksIFwiY29kZVwiLCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlOiAtMzI2MDJcbn0pO1xuY2xhc3MgQm4gZXh0ZW5kcyBtciB7XG4gIGNvbnN0cnVjdG9yKGUgPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1lc3NhZ2U6IFwiSW50ZXJuYWwgSlNPTi1SUEMgZXJyb3IuXCIsXG4gICAgICAuLi5lLFxuICAgICAgY29kZTogQm4uY29kZVxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiAtMzI2MDNcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogXCJScGNSZXNwb25zZS5JbnRlcm5hbEVycm9yRXJyb3JcIlxuICAgIH0pO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQm4sIFwiY29kZVwiLCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlOiAtMzI2MDNcbn0pO1xuY2xhc3MgaGkgZXh0ZW5kcyBtciB7XG4gIGNvbnN0cnVjdG9yKGUgPSB7fSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHBhcnNlIEpTT04tUlBDIHJlc3BvbnNlLlwiLFxuICAgICAgLi4uZSxcbiAgICAgIGNvZGU6IGhpLmNvZGVcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogLTMyNzAwXG4gICAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IFwiUnBjUmVzcG9uc2UuUGFyc2VFcnJvclwiXG4gICAgfSk7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShoaSwgXCJjb2RlXCIsIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGNvbmZpZ3VyYWJsZTogITAsXG4gIHdyaXRhYmxlOiAhMCxcbiAgdmFsdWU6IC0zMjcwMFxufSk7XG5jbGFzcyBubiBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiBcIlByb3ZpZGVyUnBjRXJyb3JcIlxuICAgIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiZGV0YWlsc1wiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogdm9pZCAwXG4gICAgfSksIHRoaXMuY29kZSA9IGUsIHRoaXMuZGV0YWlscyA9IHQ7XG4gIH1cbn1cbmNsYXNzIEowIGV4dGVuZHMgbm4ge1xuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2U6IGUgPSBcIlRoZSB1c2VyIHJlamVjdGVkIHRoZSByZXF1ZXN0LlwiIH0gPSB7fSkge1xuICAgIHN1cGVyKDQwMDEsIGUpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiBcIlByb3ZpZGVyLlVzZXJSZWplY3RlZFJlcXVlc3RFcnJvclwiXG4gICAgfSk7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShKMCwgXCJjb2RlXCIsIHtcbiAgZW51bWVyYWJsZTogITAsXG4gIGNvbmZpZ3VyYWJsZTogITAsXG4gIHdyaXRhYmxlOiAhMCxcbiAgdmFsdWU6IDQwMDFcbn0pO1xuY2xhc3MgUTAgZXh0ZW5kcyBubiB7XG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZTogZSA9IFwiVGhlIHJlcXVlc3RlZCBtZXRob2QgYW5kL29yIGFjY291bnQgaGFzIG5vdCBiZWVuIGF1dGhvcml6ZWQgYnkgdGhlIHVzZXIuXCIgfSA9IHt9KSB7XG4gICAgc3VwZXIoNDEwMCwgZSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwLFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgdmFsdWU6IFwiUHJvdmlkZXIuVW5hdXRob3JpemVkRXJyb3JcIlxuICAgIH0pO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUTAsIFwiY29kZVwiLCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlOiA0MTAwXG59KTtcbmNsYXNzIGVnIGV4dGVuZHMgbm4ge1xuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2U6IGUgPSBcIlRoZSBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSByZXF1ZXN0ZWQgbWV0aG9kLlwiIH0gPSB7fSkge1xuICAgIHN1cGVyKDQyMDAsIGUpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiBcIlByb3ZpZGVyLlVuc3VwcG9ydGVkTWV0aG9kRXJyb3JcIlxuICAgIH0pO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZWcsIFwiY29kZVwiLCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlOiA0MjAwXG59KTtcbmNsYXNzIHRnIGV4dGVuZHMgbm4ge1xuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2U6IGUgPSBcIlRoZSBwcm92aWRlciBpcyBkaXNjb25uZWN0ZWQgZnJvbSBhbGwgY2hhaW5zLlwiIH0gPSB7fSkge1xuICAgIHN1cGVyKDQ5MDAsIGUpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiBcIlByb3ZpZGVyLkRpc2Nvbm5lY3RlZEVycm9yXCJcbiAgICB9KTtcbiAgfVxufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KHRnLCBcImNvZGVcIiwge1xuICBlbnVtZXJhYmxlOiAhMCxcbiAgY29uZmlndXJhYmxlOiAhMCxcbiAgd3JpdGFibGU6ICEwLFxuICB2YWx1ZTogNDkwMFxufSk7XG5jbGFzcyByZyBleHRlbmRzIG5uIHtcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlOiBlID0gXCJUaGUgcHJvdmlkZXIgaXMgbm90IGNvbm5lY3RlZCB0byB0aGUgcmVxdWVzdGVkIGNoYWluLlwiIH0gPSB7fSkge1xuICAgIHN1cGVyKDQ5MDEsIGUpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIHZhbHVlOiBcIlByb3ZpZGVyLkNoYWluRGlzY29ubmVjdGVkRXJyb3JcIlxuICAgIH0pO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocmcsIFwiY29kZVwiLCB7XG4gIGVudW1lcmFibGU6ICEwLFxuICBjb25maWd1cmFibGU6ICEwLFxuICB3cml0YWJsZTogITAsXG4gIHZhbHVlOiA0OTAxXG59KTtcbmZ1bmN0aW9uIFFFKCkge1xuICBjb25zdCBzID0gbmV3IEwwKCk7XG4gIHJldHVybiB7XG4gICAgZ2V0IGV2ZW50TmFtZXMoKSB7XG4gICAgICByZXR1cm4gcy5ldmVudE5hbWVzLmJpbmQocyk7XG4gICAgfSxcbiAgICBnZXQgbGlzdGVuZXJDb3VudCgpIHtcbiAgICAgIHJldHVybiBzLmxpc3RlbmVyQ291bnQuYmluZChzKTtcbiAgICB9LFxuICAgIGdldCBsaXN0ZW5lcnMoKSB7XG4gICAgICByZXR1cm4gcy5saXN0ZW5lcnMuYmluZChzKTtcbiAgICB9LFxuICAgIGFkZExpc3RlbmVyOiBzLmFkZExpc3RlbmVyLmJpbmQocyksXG4gICAgZW1pdDogcy5lbWl0LmJpbmQocyksXG4gICAgb2ZmOiBzLm9mZi5iaW5kKHMpLFxuICAgIG9uOiBzLm9uLmJpbmQocyksXG4gICAgb25jZTogcy5vbmNlLmJpbmQocyksXG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzOiBzLnJlbW92ZUFsbExpc3RlbmVycy5iaW5kKHMpLFxuICAgIHJlbW92ZUxpc3RlbmVyOiBzLnJlbW92ZUxpc3RlbmVyLmJpbmQocylcbiAgfTtcbn1cbmZ1bmN0aW9uIGV4KHMsIGUgPSB7fSkge1xuICB2YXIgciwgbjtcbiAgY29uc3QgeyBpbmNsdWRlRXZlbnRzOiB0ID0gITAgfSA9IGU7XG4gIGlmICghcylcbiAgICB0aHJvdyBuZXcgdHgoKTtcbiAgcmV0dXJuIHtcbiAgICAuLi50ID8ge1xuICAgICAgb246IChyID0gcy5vbikgPT0gbnVsbCA/IHZvaWQgMCA6IHIuYmluZChzKSxcbiAgICAgIHJlbW92ZUxpc3RlbmVyOiAobiA9IHMucmVtb3ZlTGlzdGVuZXIpID09IG51bGwgPyB2b2lkIDAgOiBuLmJpbmQocylcbiAgICB9IDoge30sXG4gICAgYXN5bmMgcmVxdWVzdChpKSB7XG4gICAgICBjb25zdCBvID0gYXdhaXQgcy5yZXF1ZXN0KGkpO1xuICAgICAgcmV0dXJuIG8gJiYgdHlwZW9mIG8gPT0gXCJvYmplY3RcIiAmJiBcImpzb25ycGNcIiBpbiBvID8gWDAobykgOiBvO1xuICAgIH1cbiAgfTtcbn1cbmNsYXNzIHR4IGV4dGVuZHMgSkUge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihcImBwcm92aWRlcmAgaXMgdW5kZWZpbmVkLlwiKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICB2YWx1ZTogXCJQcm92aWRlci5Jc1VuZGVmaW5lZEVycm9yXCJcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcngocyA9IHt9KSB7XG4gIGxldCBlID0gcy5pZCA/PyAwO1xuICByZXR1cm4ge1xuICAgIHByZXBhcmUodCkge1xuICAgICAgcmV0dXJuIHN4KHtcbiAgICAgICAgaWQ6IGUrKyxcbiAgICAgICAgLi4udFxuICAgICAgfSk7XG4gICAgfSxcbiAgICBnZXQgaWQoKSB7XG4gICAgICByZXR1cm4gZTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBzeChzKSB7XG4gIHJldHVybiB7XG4gICAgLi4ucyxcbiAgICBqc29ucnBjOiBcIjIuMFwiXG4gIH07XG59XG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKiBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuICovXG5jb25zdCBzZyA9IFN5bWJvbChcIkNvbWxpbmsucHJveHlcIiksIG54ID0gU3ltYm9sKFwiQ29tbGluay5lbmRwb2ludFwiKSwgaXggPSBTeW1ib2woXCJDb21saW5rLnJlbGVhc2VQcm94eVwiKSwgbGwgPSBTeW1ib2woXCJDb21saW5rLmZpbmFsaXplclwiKSwgaG8gPSBTeW1ib2woXCJDb21saW5rLnRocm93blwiKSwgbmcgPSAocykgPT4gdHlwZW9mIHMgPT0gXCJvYmplY3RcIiAmJiBzICE9PSBudWxsIHx8IHR5cGVvZiBzID09IFwiZnVuY3Rpb25cIiwgb3ggPSB7XG4gIGNhbkhhbmRsZTogKHMpID0+IG5nKHMpICYmIHNbc2ddLFxuICBzZXJpYWxpemUocykge1xuICAgIGNvbnN0IHsgcG9ydDE6IGUsIHBvcnQyOiB0IH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICByZXR1cm4gb2cocywgZSksIFt0LCBbdF1dO1xuICB9LFxuICBkZXNlcmlhbGl6ZShzKSB7XG4gICAgcmV0dXJuIHMuc3RhcnQoKSwgbGcocyk7XG4gIH1cbn0sIGF4ID0ge1xuICBjYW5IYW5kbGU6IChzKSA9PiBuZyhzKSAmJiBobyBpbiBzLFxuICBzZXJpYWxpemUoeyB2YWx1ZTogcyB9KSB7XG4gICAgbGV0IGU7XG4gICAgcmV0dXJuIHMgaW5zdGFuY2VvZiBFcnJvciA/IGUgPSB7XG4gICAgICBpc0Vycm9yOiAhMCxcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIG1lc3NhZ2U6IHMubWVzc2FnZSxcbiAgICAgICAgbmFtZTogcy5uYW1lLFxuICAgICAgICBzdGFjazogcy5zdGFja1xuICAgICAgfVxuICAgIH0gOiBlID0geyBpc0Vycm9yOiAhMSwgdmFsdWU6IHMgfSwgW2UsIFtdXTtcbiAgfSxcbiAgZGVzZXJpYWxpemUocykge1xuICAgIHRocm93IHMuaXNFcnJvciA/IE9iamVjdC5hc3NpZ24obmV3IEVycm9yKHMudmFsdWUubWVzc2FnZSksIHMudmFsdWUpIDogcy52YWx1ZTtcbiAgfVxufSwgaWcgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFtcInByb3h5XCIsIG94XSxcbiAgW1widGhyb3dcIiwgYXhdXG5dKTtcbmZ1bmN0aW9uIGx4KHMsIGUpIHtcbiAgZm9yIChjb25zdCB0IG9mIHMpXG4gICAgaWYgKGUgPT09IHQgfHwgdCA9PT0gXCIqXCIgfHwgdCBpbnN0YW5jZW9mIFJlZ0V4cCAmJiB0LnRlc3QoZSkpXG4gICAgICByZXR1cm4gITA7XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIG9nKHMsIGUgPSBnbG9iYWxUaGlzLCB0ID0gW1wiKlwiXSkge1xuICBlLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uIHIobikge1xuICAgIGlmICghbiB8fCAhbi5kYXRhKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICghbHgodCwgbi5vcmlnaW4pKSB7XG4gICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgb3JpZ2luICcke24ub3JpZ2lufScgZm9yIGNvbWxpbmsgcHJveHlgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBpZDogaSwgdHlwZTogbywgcGF0aDogYSB9ID0gT2JqZWN0LmFzc2lnbih7IHBhdGg6IFtdIH0sIG4uZGF0YSksIGwgPSAobi5kYXRhLmFyZ3VtZW50TGlzdCB8fCBbXSkubWFwKCRzKTtcbiAgICBsZXQgYztcbiAgICB0cnkge1xuICAgICAgY29uc3QgdSA9IGEuc2xpY2UoMCwgLTEpLnJlZHVjZSgoaCwgZikgPT4gaFtmXSwgcyksIGQgPSBhLnJlZHVjZSgoaCwgZikgPT4gaFtmXSwgcyk7XG4gICAgICBzd2l0Y2ggKG8pIHtcbiAgICAgICAgY2FzZSBcIkdFVFwiOlxuICAgICAgICAgIGMgPSBkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiU0VUXCI6XG4gICAgICAgICAgdVthLnNsaWNlKC0xKVswXV0gPSAkcyhuLmRhdGEudmFsdWUpLCBjID0gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJBUFBMWVwiOlxuICAgICAgICAgIGMgPSBkLmFwcGx5KHUsIGwpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQ09OU1RSVUNUXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgaCA9IG5ldyBkKC4uLmwpO1xuICAgICAgICAgICAgYyA9IGd4KGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkVORFBPSU5UXCI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgeyBwb3J0MTogaCwgcG9ydDI6IGYgfSA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICAgICAgb2cocywgZiksIGMgPSBmeChoLCBbaF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlJFTEVBU0VcIjpcbiAgICAgICAgICBjID0gdm9pZCAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGNhdGNoICh1KSB7XG4gICAgICBjID0geyB2YWx1ZTogdSwgW2hvXTogMCB9O1xuICAgIH1cbiAgICBQcm9taXNlLnJlc29sdmUoYykuY2F0Y2goKHUpID0+ICh7IHZhbHVlOiB1LCBbaG9dOiAwIH0pKS50aGVuKCh1KSA9PiB7XG4gICAgICBjb25zdCBbZCwgaF0gPSB6byh1KTtcbiAgICAgIGUucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkKSwgeyBpZDogaSB9KSwgaCksIG8gPT09IFwiUkVMRUFTRVwiICYmIChlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHIpLCBhZyhlKSwgbGwgaW4gcyAmJiB0eXBlb2Ygc1tsbF0gPT0gXCJmdW5jdGlvblwiICYmIHNbbGxdKCkpO1xuICAgIH0pLmNhdGNoKCh1KSA9PiB7XG4gICAgICBjb25zdCBbZCwgaF0gPSB6byh7XG4gICAgICAgIHZhbHVlOiBuZXcgVHlwZUVycm9yKFwiVW5zZXJpYWxpemFibGUgcmV0dXJuIHZhbHVlXCIpLFxuICAgICAgICBbaG9dOiAwXG4gICAgICB9KTtcbiAgICAgIGUucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkKSwgeyBpZDogaSB9KSwgaCk7XG4gICAgfSk7XG4gIH0pLCBlLnN0YXJ0ICYmIGUuc3RhcnQoKTtcbn1cbmZ1bmN0aW9uIGN4KHMpIHtcbiAgcmV0dXJuIHMuY29uc3RydWN0b3IubmFtZSA9PT0gXCJNZXNzYWdlUG9ydFwiO1xufVxuZnVuY3Rpb24gYWcocykge1xuICBjeChzKSAmJiBzLmNsb3NlKCk7XG59XG5mdW5jdGlvbiBsZyhzLCBlKSB7XG4gIGNvbnN0IHQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICByZXR1cm4gcy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbihuKSB7XG4gICAgY29uc3QgeyBkYXRhOiBpIH0gPSBuO1xuICAgIGlmICghaSB8fCAhaS5pZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvID0gdC5nZXQoaS5pZCk7XG4gICAgaWYgKG8pXG4gICAgICB0cnkge1xuICAgICAgICBvKGkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdC5kZWxldGUoaS5pZCk7XG4gICAgICB9XG4gIH0pLCBuYyhzLCB0LCBbXSwgZSk7XG59XG5mdW5jdGlvbiBWaShzKSB7XG4gIGlmIChzKVxuICAgIHRocm93IG5ldyBFcnJvcihcIlByb3h5IGhhcyBiZWVuIHJlbGVhc2VkIGFuZCBpcyBub3QgdXNlYWJsZVwiKTtcbn1cbmZ1bmN0aW9uIGNnKHMpIHtcbiAgcmV0dXJuIHluKHMsIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIHtcbiAgICB0eXBlOiBcIlJFTEVBU0VcIlxuICB9KS50aGVuKCgpID0+IHtcbiAgICBhZyhzKTtcbiAgfSk7XG59XG5jb25zdCBxbyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpLCBXbyA9IFwiRmluYWxpemF0aW9uUmVnaXN0cnlcIiBpbiBnbG9iYWxUaGlzICYmIG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgocykgPT4ge1xuICBjb25zdCBlID0gKHFvLmdldChzKSB8fCAwKSAtIDE7XG4gIHFvLnNldChzLCBlKSwgZSA9PT0gMCAmJiBjZyhzKTtcbn0pO1xuZnVuY3Rpb24gdXgocywgZSkge1xuICBjb25zdCB0ID0gKHFvLmdldChlKSB8fCAwKSArIDE7XG4gIHFvLnNldChlLCB0KSwgV28gJiYgV28ucmVnaXN0ZXIocywgZSwgcyk7XG59XG5mdW5jdGlvbiBkeChzKSB7XG4gIFdvICYmIFdvLnVucmVnaXN0ZXIocyk7XG59XG5mdW5jdGlvbiBuYyhzLCBlLCB0ID0gW10sIHIgPSBmdW5jdGlvbigpIHtcbn0pIHtcbiAgbGV0IG4gPSAhMTtcbiAgY29uc3QgaSA9IG5ldyBQcm94eShyLCB7XG4gICAgZ2V0KG8sIGEpIHtcbiAgICAgIGlmIChWaShuKSwgYSA9PT0gaXgpXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgZHgoaSksIGNnKHMpLCBlLmNsZWFyKCksIG4gPSAhMDtcbiAgICAgICAgfTtcbiAgICAgIGlmIChhID09PSBcInRoZW5cIikge1xuICAgICAgICBpZiAodC5sZW5ndGggPT09IDApXG4gICAgICAgICAgcmV0dXJuIHsgdGhlbjogKCkgPT4gaSB9O1xuICAgICAgICBjb25zdCBsID0geW4ocywgZSwge1xuICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgcGF0aDogdC5tYXAoKGMpID0+IGMudG9TdHJpbmcoKSlcbiAgICAgICAgfSkudGhlbigkcyk7XG4gICAgICAgIHJldHVybiBsLnRoZW4uYmluZChsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuYyhzLCBlLCBbLi4udCwgYV0pO1xuICAgIH0sXG4gICAgc2V0KG8sIGEsIGwpIHtcbiAgICAgIFZpKG4pO1xuICAgICAgY29uc3QgW2MsIHVdID0gem8obCk7XG4gICAgICByZXR1cm4geW4ocywgZSwge1xuICAgICAgICB0eXBlOiBcIlNFVFwiLFxuICAgICAgICBwYXRoOiBbLi4udCwgYV0ubWFwKChkKSA9PiBkLnRvU3RyaW5nKCkpLFxuICAgICAgICB2YWx1ZTogY1xuICAgICAgfSwgdSkudGhlbigkcyk7XG4gICAgfSxcbiAgICBhcHBseShvLCBhLCBsKSB7XG4gICAgICBWaShuKTtcbiAgICAgIGNvbnN0IGMgPSB0W3QubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoYyA9PT0gbngpXG4gICAgICAgIHJldHVybiB5bihzLCBlLCB7XG4gICAgICAgICAgdHlwZTogXCJFTkRQT0lOVFwiXG4gICAgICAgIH0pLnRoZW4oJHMpO1xuICAgICAgaWYgKGMgPT09IFwiYmluZFwiKVxuICAgICAgICByZXR1cm4gbmMocywgZSwgdC5zbGljZSgwLCAtMSkpO1xuICAgICAgY29uc3QgW3UsIGRdID0gVmQobCk7XG4gICAgICByZXR1cm4geW4ocywgZSwge1xuICAgICAgICB0eXBlOiBcIkFQUExZXCIsXG4gICAgICAgIHBhdGg6IHQubWFwKChoKSA9PiBoLnRvU3RyaW5nKCkpLFxuICAgICAgICBhcmd1bWVudExpc3Q6IHVcbiAgICAgIH0sIGQpLnRoZW4oJHMpO1xuICAgIH0sXG4gICAgY29uc3RydWN0KG8sIGEpIHtcbiAgICAgIFZpKG4pO1xuICAgICAgY29uc3QgW2wsIGNdID0gVmQoYSk7XG4gICAgICByZXR1cm4geW4ocywgZSwge1xuICAgICAgICB0eXBlOiBcIkNPTlNUUlVDVFwiLFxuICAgICAgICBwYXRoOiB0Lm1hcCgodSkgPT4gdS50b1N0cmluZygpKSxcbiAgICAgICAgYXJndW1lbnRMaXN0OiBsXG4gICAgICB9LCBjKS50aGVuKCRzKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdXgoaSwgcyksIGk7XG59XG5mdW5jdGlvbiBoeChzKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBzKTtcbn1cbmZ1bmN0aW9uIFZkKHMpIHtcbiAgY29uc3QgZSA9IHMubWFwKHpvKTtcbiAgcmV0dXJuIFtlLm1hcCgodCkgPT4gdFswXSksIGh4KGUubWFwKCh0KSA9PiB0WzFdKSldO1xufVxuY29uc3QgdWcgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGZ4KHMsIGUpIHtcbiAgcmV0dXJuIHVnLnNldChzLCBlKSwgcztcbn1cbmZ1bmN0aW9uIGd4KHMpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocywgeyBbc2ddOiAhMCB9KTtcbn1cbmZ1bmN0aW9uIHB4KHMsIGUgPSBnbG9iYWxUaGlzLCB0ID0gXCIqXCIpIHtcbiAgcmV0dXJuIHtcbiAgICBwb3N0TWVzc2FnZTogKHIsIG4pID0+IHMucG9zdE1lc3NhZ2UociwgdCwgbiksXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZS5hZGRFdmVudExpc3RlbmVyLmJpbmQoZSksXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZS5yZW1vdmVFdmVudExpc3RlbmVyLmJpbmQoZSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHpvKHMpIHtcbiAgZm9yIChjb25zdCBbZSwgdF0gb2YgaWcpXG4gICAgaWYgKHQuY2FuSGFuZGxlKHMpKSB7XG4gICAgICBjb25zdCBbciwgbl0gPSB0LnNlcmlhbGl6ZShzKTtcbiAgICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcIkhBTkRMRVJcIixcbiAgICAgICAgICBuYW1lOiBlLFxuICAgICAgICAgIHZhbHVlOiByXG4gICAgICAgIH0sXG4gICAgICAgIG5cbiAgICAgIF07XG4gICAgfVxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIHR5cGU6IFwiUkFXXCIsXG4gICAgICB2YWx1ZTogc1xuICAgIH0sXG4gICAgdWcuZ2V0KHMpIHx8IFtdXG4gIF07XG59XG5mdW5jdGlvbiAkcyhzKSB7XG4gIHN3aXRjaCAocy50eXBlKSB7XG4gICAgY2FzZSBcIkhBTkRMRVJcIjpcbiAgICAgIHJldHVybiBpZy5nZXQocy5uYW1lKS5kZXNlcmlhbGl6ZShzLnZhbHVlKTtcbiAgICBjYXNlIFwiUkFXXCI6XG4gICAgICByZXR1cm4gcy52YWx1ZTtcbiAgfVxufVxuZnVuY3Rpb24geW4ocywgZSwgdCwgcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoKG4pID0+IHtcbiAgICBjb25zdCBpID0gbXgoKTtcbiAgICBlLnNldChpLCBuKSwgcy5zdGFydCAmJiBzLnN0YXJ0KCksIHMucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbih7IGlkOiBpIH0sIHQpLCByKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBteCgpIHtcbiAgcmV0dXJuIG5ldyBBcnJheSg0KS5maWxsKDApLm1hcCgoKSA9PiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUikudG9TdHJpbmcoMTYpKS5qb2luKFwiLVwiKTtcbn1cbmNvbnN0IHl4ID0ge1xuICBwb3N0TWVzc2FnZSgpIHtcbiAgfSxcbiAgYWRkRXZlbnRMaXN0ZW5lcjogKCkgPT4ge1xuICB9LFxuICByZW1vdmVFdmVudExpc3RlbmVyOiAoKSA9PiB7XG4gIH1cbn0sIHZ4ID0ge1xuICBwb3N0TWVzc2FnZTogKHMpID0+IHtcbiAgICB3aW5kb3cuUmVhY3ROYXRpdmVXZWJWaWV3LnBvc3RNZXNzYWdlKEpTT04uc3RyaW5naWZ5KHMpKTtcbiAgfSxcbiAgYWRkRXZlbnRMaXN0ZW5lcjogKHMsIGUsIC4uLnQpID0+IHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRmFyY2FzdGVyRnJhbWVDYWxsYmFja1wiLCBlLCAuLi50KTtcbiAgfSxcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogKHMsIGUpID0+IHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiRmFyY2FzdGVyRnJhbWVDYWxsYmFja1wiLCBlKTtcbiAgfVxufSwgRXggPSB0eXBlb2Ygd2luZG93ID4gXCJ1XCIgPyB5eCA6IHdpbmRvdyAhPSBudWxsICYmIHdpbmRvdy5SZWFjdE5hdGl2ZVdlYlZpZXcgPyB2eCA6IHB4KCh3aW5kb3cgPT0gbnVsbCA/IHZvaWQgMCA6IHdpbmRvdy5wYXJlbnQpID8/IHdpbmRvdyksIE1lID0gbGcoRXgpLCB1dSA9IFFFKCksIHh4ID0gcngoKTtcbmZ1bmN0aW9uIFN4KHsgY29kZTogcywgZGV0YWlsczogZSB9KSB7XG4gIHN3aXRjaCAocykge1xuICAgIGNhc2UgNDAwMTpcbiAgICAgIHJldHVybiBuZXcgSjAoKTtcbiAgICBjYXNlIDQxMDA6XG4gICAgICByZXR1cm4gbmV3IFEwKCk7XG4gICAgY2FzZSA0MjAwOlxuICAgICAgcmV0dXJuIG5ldyBlZygpO1xuICAgIGNhc2UgNDkwMDpcbiAgICAgIHJldHVybiBuZXcgdGcoKTtcbiAgICBjYXNlIDQ5MDE6XG4gICAgICByZXR1cm4gbmV3IHJnKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBuZXcgbm4ocywgZSA/PyBcIlVua25vd24gcHJvdmlkZXIgUlBDIGVycm9yXCIpO1xuICB9XG59XG5jb25zdCBmaSA9IGV4KHtcbiAgLi4udXUsXG4gIGFzeW5jIHJlcXVlc3Qocykge1xuICAgIGNvbnN0IGUgPSB4eC5wcmVwYXJlKHMpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB0ID0gYXdhaXQgTWUuZXRoUHJvdmlkZXJSZXF1ZXN0VjIoZSkudGhlbigocikgPT4gWDAociwgeyByZXF1ZXN0OiBlLCByYXc6ICEwIH0pKTtcbiAgICAgIGlmICh0LmVycm9yKVxuICAgICAgICB0aHJvdyBTeCh0LmVycm9yKTtcbiAgICAgIHJldHVybiB0LnJlc3VsdDtcbiAgICB9IGNhdGNoICh0KSB7XG4gICAgICBpZiAodCBpbnN0YW5jZW9mIEVycm9yICYmIHQubWVzc2FnZS5tYXRjaCgvY2Fubm90IHJlYWQgcHJvcGVydHkgJ2FwcGx5Jy9pKSlcbiAgICAgICAgcmV0dXJuIGF3YWl0IE1lLmV0aFByb3ZpZGVyUmVxdWVzdChlKTtcbiAgICAgIHRocm93IHQgaW5zdGFuY2VvZiBubiB8fCB0IGluc3RhbmNlb2YgbXIgPyB0IDogbmV3IEJuKHtcbiAgICAgICAgbWVzc2FnZTogdCBpbnN0YW5jZW9mIEVycm9yID8gdC5tZXNzYWdlIDogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pO1xuYXN5bmMgZnVuY3Rpb24gYngoKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcyA9IGF3YWl0IE1lLmdldENhcGFiaWxpdGllcygpO1xuICAgIHJldHVybiAhcy5pbmNsdWRlcyhcIndhbGxldC5nZXRFdGhlcmV1bVByb3ZpZGVyXCIpICYmICFzLmluY2x1ZGVzKFwid2FsbGV0LmdldEV2bVByb3ZpZGVyXCIpID8gdm9pZCAwIDogZmk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmaTtcbiAgfVxufVxuZnVuY3Rpb24gZGcocykge1xuICBjb25zdCBlID0gbmV3IEN1c3RvbUV2ZW50KFwiZWlwNjk2Mzphbm5vdW5jZVByb3ZpZGVyXCIsIHsgZGV0YWlsOiBPYmplY3QuZnJlZXplKHMpIH0pO1xuICB3aW5kb3cuZGlzcGF0Y2hFdmVudChlKTtcbiAgY29uc3QgdCA9ICgpID0+IHdpbmRvdy5kaXNwYXRjaEV2ZW50KGUpO1xuICByZXR1cm4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJlaXA2OTYzOnJlcXVlc3RQcm92aWRlclwiLCB0KSwgKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlaXA2OTYzOnJlcXVlc3RQcm92aWRlclwiLCB0KTtcbn1cbnR5cGVvZiBkb2N1bWVudCA8IFwidVwiICYmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZWlwNjk2MzpyZXF1ZXN0UHJvdmlkZXJcIiwgKCkgPT4ge1xuICBNZS5laXA2OTYzUmVxdWVzdFByb3ZpZGVyKCk7XG59KSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkZhcmNhc3RlckZyYW1lRXRoUHJvdmlkZXJFdmVudFwiLCAocykgPT4ge1xuICBpZiAocyBpbnN0YW5jZW9mIE1lc3NhZ2VFdmVudCkge1xuICAgIGNvbnN0IGUgPSBzLmRhdGE7XG4gICAgdXUuZW1pdChlLmV2ZW50LCAuLi5lLnBhcmFtcyk7XG4gIH1cbn0pLCBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRmFyY2FzdGVyRnJhbWVFdmVudFwiLCAocykgPT4ge1xuICBpZiAocyBpbnN0YW5jZW9mIE1lc3NhZ2VFdmVudCkge1xuICAgIGNvbnN0IGUgPSBzLmRhdGE7XG4gICAgZS5ldmVudCA9PT0gXCJlaXA2OTYzOmFubm91bmNlUHJvdmlkZXJcIiAmJiBkZyh7XG4gICAgICBpbmZvOiBlLmluZm8sXG4gICAgICBwcm92aWRlcjogZmlcbiAgICB9KTtcbiAgfVxufSkpO1xudHlwZW9mIHdpbmRvdyA8IFwidVwiICYmICh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImVpcDY5NjM6cmVxdWVzdFByb3ZpZGVyXCIsICgpID0+IHtcbiAgTWUuZWlwNjk2M1JlcXVlc3RQcm92aWRlcigpO1xufSksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCAocykgPT4ge1xuICBpZiAocyBpbnN0YW5jZW9mIE1lc3NhZ2VFdmVudCAmJiBzLmRhdGEudHlwZSA9PT0gXCJmcmFtZUV0aFByb3ZpZGVyRXZlbnRcIikge1xuICAgIGNvbnN0IGUgPSBzLmRhdGE7XG4gICAgdXUuZW1pdChlLmV2ZW50LCAuLi5lLnBhcmFtcyk7XG4gIH1cbn0pLCB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKHMpID0+IHtcbiAgaWYgKHMgaW5zdGFuY2VvZiBNZXNzYWdlRXZlbnQgJiYgcy5kYXRhLnR5cGUgPT09IFwiZnJhbWVFdmVudFwiKSB7XG4gICAgY29uc3QgZSA9IHMuZGF0YS5ldmVudDtcbiAgICBlLmV2ZW50ID09PSBcImVpcDY5NjM6YW5ub3VuY2VQcm92aWRlclwiICYmIGRnKHtcbiAgICAgIGluZm86IGUuaW5mbyxcbiAgICAgIHByb3ZpZGVyOiBmaVxuICAgIH0pO1xuICB9XG59KSk7XG5uZXcgVGV4dEVuY29kZXIoKTtcbmNvbnN0IGhnID0gbmV3IFRleHREZWNvZGVyKCksIFR4ID0gKHMpID0+IHtcbiAgY29uc3QgZSA9IGF0b2IocyksIHQgPSBuZXcgVWludDhBcnJheShlLmxlbmd0aCk7XG4gIGZvciAobGV0IHIgPSAwOyByIDwgZS5sZW5ndGg7IHIrKylcbiAgICB0W3JdID0gZS5jaGFyQ29kZUF0KHIpO1xuICByZXR1cm4gdDtcbn0sIHd4ID0gKHMpID0+IHtcbiAgbGV0IGUgPSBzO1xuICBlIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiAoZSA9IGhnLmRlY29kZShlKSksIGUgPSBlLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpLnJlcGxhY2UoL1xccy9nLCBcIlwiKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gVHgoZSk7XG4gIH0gY2F0Y2gge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgaW5wdXQgdG8gYmUgZGVjb2RlZCBpcyBub3QgY29ycmVjdGx5IGVuY29kZWQuXCIpO1xuICB9XG59LCBBeCA9IHd4O1xuZnVuY3Rpb24gSXgocykge1xuICByZXR1cm4gdHlwZW9mIHMgPT0gXCJvYmplY3RcIiAmJiBzICE9PSBudWxsO1xufVxuZnVuY3Rpb24gX3gocykge1xuICBpZiAoIUl4KHMpIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIilcbiAgICByZXR1cm4gITE7XG4gIGlmIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocykgPT09IG51bGwpXG4gICAgcmV0dXJuICEwO1xuICBsZXQgZSA9IHM7XG4gIGZvciAoOyBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSkgIT09IG51bGw7IClcbiAgICBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGUpO1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKHMpID09PSBlO1xufVxuY2xhc3MgZHIgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB2YXIgcjtcbiAgICBzdXBlcihlLCB0KSwgdGhpcy5jb2RlID0gXCJFUlJfSk9TRV9HRU5FUklDXCIsIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZSwgKHIgPSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkgPT0gbnVsbCB8fCByLmNhbGwoRXJyb3IsIHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB9XG59XG5kci5jb2RlID0gXCJFUlJfSk9TRV9HRU5FUklDXCI7XG5jbGFzcyBSeCBleHRlbmRzIGRyIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgciA9IFwidW5zcGVjaWZpZWRcIiwgbiA9IFwidW5zcGVjaWZpZWRcIikge1xuICAgIHN1cGVyKGUsIHsgY2F1c2U6IHsgY2xhaW06IHIsIHJlYXNvbjogbiwgcGF5bG9hZDogdCB9IH0pLCB0aGlzLmNvZGUgPSBcIkVSUl9KV1RfQ0xBSU1fVkFMSURBVElPTl9GQUlMRURcIiwgdGhpcy5jbGFpbSA9IHIsIHRoaXMucmVhc29uID0gbiwgdGhpcy5wYXlsb2FkID0gdDtcbiAgfVxufVxuUnguY29kZSA9IFwiRVJSX0pXVF9DTEFJTV9WQUxJREFUSU9OX0ZBSUxFRFwiO1xuY2xhc3MgTHggZXh0ZW5kcyBkciB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHIgPSBcInVuc3BlY2lmaWVkXCIsIG4gPSBcInVuc3BlY2lmaWVkXCIpIHtcbiAgICBzdXBlcihlLCB7IGNhdXNlOiB7IGNsYWltOiByLCByZWFzb246IG4sIHBheWxvYWQ6IHQgfSB9KSwgdGhpcy5jb2RlID0gXCJFUlJfSldUX0VYUElSRURcIiwgdGhpcy5jbGFpbSA9IHIsIHRoaXMucmVhc29uID0gbiwgdGhpcy5wYXlsb2FkID0gdDtcbiAgfVxufVxuTHguY29kZSA9IFwiRVJSX0pXVF9FWFBJUkVEXCI7XG5jbGFzcyBDeCBleHRlbmRzIGRyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5jb2RlID0gXCJFUlJfSk9TRV9BTEdfTk9UX0FMTE9XRURcIjtcbiAgfVxufVxuQ3guY29kZSA9IFwiRVJSX0pPU0VfQUxHX05PVF9BTExPV0VEXCI7XG5jbGFzcyBreCBleHRlbmRzIGRyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKSwgdGhpcy5jb2RlID0gXCJFUlJfSk9TRV9OT1RfU1VQUE9SVEVEXCI7XG4gIH1cbn1cbmt4LmNvZGUgPSBcIkVSUl9KT1NFX05PVF9TVVBQT1JURURcIjtcbmNsYXNzIER4IGV4dGVuZHMgZHIge1xuICBjb25zdHJ1Y3RvcihlID0gXCJkZWNyeXB0aW9uIG9wZXJhdGlvbiBmYWlsZWRcIiwgdCkge1xuICAgIHN1cGVyKGUsIHQpLCB0aGlzLmNvZGUgPSBcIkVSUl9KV0VfREVDUllQVElPTl9GQUlMRURcIjtcbiAgfVxufVxuRHguY29kZSA9IFwiRVJSX0pXRV9ERUNSWVBUSU9OX0ZBSUxFRFwiO1xuY2xhc3MgUHggZXh0ZW5kcyBkciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuY29kZSA9IFwiRVJSX0pXRV9JTlZBTElEXCI7XG4gIH1cbn1cblB4LmNvZGUgPSBcIkVSUl9KV0VfSU5WQUxJRFwiO1xuY2xhc3MgTXggZXh0ZW5kcyBkciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuY29kZSA9IFwiRVJSX0pXU19JTlZBTElEXCI7XG4gIH1cbn1cbk14LmNvZGUgPSBcIkVSUl9KV1NfSU5WQUxJRFwiO1xuY2xhc3MgVHMgZXh0ZW5kcyBkciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuY29kZSA9IFwiRVJSX0pXVF9JTlZBTElEXCI7XG4gIH1cbn1cblRzLmNvZGUgPSBcIkVSUl9KV1RfSU5WQUxJRFwiO1xuY2xhc3MgT3ggZXh0ZW5kcyBkciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuY29kZSA9IFwiRVJSX0pXS19JTlZBTElEXCI7XG4gIH1cbn1cbk94LmNvZGUgPSBcIkVSUl9KV0tfSU5WQUxJRFwiO1xuY2xhc3MgQnggZXh0ZW5kcyBkciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyksIHRoaXMuY29kZSA9IFwiRVJSX0pXS1NfSU5WQUxJRFwiO1xuICB9XG59XG5CeC5jb2RlID0gXCJFUlJfSldLU19JTlZBTElEXCI7XG5jbGFzcyBGeCBleHRlbmRzIGRyIHtcbiAgY29uc3RydWN0b3IoZSA9IFwibm8gYXBwbGljYWJsZSBrZXkgZm91bmQgaW4gdGhlIEpTT04gV2ViIEtleSBTZXRcIiwgdCkge1xuICAgIHN1cGVyKGUsIHQpLCB0aGlzLmNvZGUgPSBcIkVSUl9KV0tTX05PX01BVENISU5HX0tFWVwiO1xuICB9XG59XG5GeC5jb2RlID0gXCJFUlJfSldLU19OT19NQVRDSElOR19LRVlcIjtcbmNsYXNzIE54IGV4dGVuZHMgZHIge1xuICBjb25zdHJ1Y3RvcihlID0gXCJtdWx0aXBsZSBtYXRjaGluZyBrZXlzIGZvdW5kIGluIHRoZSBKU09OIFdlYiBLZXkgU2V0XCIsIHQpIHtcbiAgICBzdXBlcihlLCB0KSwgdGhpcy5jb2RlID0gXCJFUlJfSldLU19NVUxUSVBMRV9NQVRDSElOR19LRVlTXCI7XG4gIH1cbn1cbk54LmNvZGUgPSBcIkVSUl9KV0tTX01VTFRJUExFX01BVENISU5HX0tFWVNcIjtcbmNsYXNzIFV4IGV4dGVuZHMgZHIge1xuICBjb25zdHJ1Y3RvcihlID0gXCJyZXF1ZXN0IHRpbWVkIG91dFwiLCB0KSB7XG4gICAgc3VwZXIoZSwgdCksIHRoaXMuY29kZSA9IFwiRVJSX0pXS1NfVElNRU9VVFwiO1xuICB9XG59XG5VeC5jb2RlID0gXCJFUlJfSldLU19USU1FT1VUXCI7XG5jbGFzcyAkeCBleHRlbmRzIGRyIHtcbiAgY29uc3RydWN0b3IoZSA9IFwic2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWRcIiwgdCkge1xuICAgIHN1cGVyKGUsIHQpLCB0aGlzLmNvZGUgPSBcIkVSUl9KV1NfU0lHTkFUVVJFX1ZFUklGSUNBVElPTl9GQUlMRURcIjtcbiAgfVxufVxuJHguY29kZSA9IFwiRVJSX0pXU19TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxFRFwiO1xuZnVuY3Rpb24gR3gocykge1xuICBpZiAodHlwZW9mIHMgIT0gXCJzdHJpbmdcIilcbiAgICB0aHJvdyBuZXcgVHMoXCJKV1RzIG11c3QgdXNlIENvbXBhY3QgSldTIHNlcmlhbGl6YXRpb24sIEpXVCBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICBjb25zdCB7IDE6IGUsIGxlbmd0aDogdCB9ID0gcy5zcGxpdChcIi5cIik7XG4gIGlmICh0ID09PSA1KVxuICAgIHRocm93IG5ldyBUcyhcIk9ubHkgSldUcyB1c2luZyBDb21wYWN0IEpXUyBzZXJpYWxpemF0aW9uIGNhbiBiZSBkZWNvZGVkXCIpO1xuICBpZiAodCAhPT0gMylcbiAgICB0aHJvdyBuZXcgVHMoXCJJbnZhbGlkIEpXVFwiKTtcbiAgaWYgKCFlKVxuICAgIHRocm93IG5ldyBUcyhcIkpXVHMgbXVzdCBjb250YWluIGEgcGF5bG9hZFwiKTtcbiAgbGV0IHI7XG4gIHRyeSB7XG4gICAgciA9IEF4KGUpO1xuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBuZXcgVHMoXCJGYWlsZWQgdG8gYmFzZTY0dXJsIGRlY29kZSB0aGUgcGF5bG9hZFwiKTtcbiAgfVxuICBsZXQgbjtcbiAgdHJ5IHtcbiAgICBuID0gSlNPTi5wYXJzZShoZy5kZWNvZGUocikpO1xuICB9IGNhdGNoIHtcbiAgICB0aHJvdyBuZXcgVHMoXCJGYWlsZWQgdG8gcGFyc2UgdGhlIGRlY29kZWQgcGF5bG9hZCBhcyBKU09OXCIpO1xuICB9XG4gIGlmICghX3gobikpXG4gICAgdGhyb3cgbmV3IFRzKFwiSW52YWxpZCBKV1QgQ2xhaW1zIFNldFwiKTtcbiAgcmV0dXJuIG47XG59XG5mdW5jdGlvbiBWeChzKSB7XG4gIHJldHVybiBHeChzKTtcbn1cbmNsYXNzIG1hIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihlLCB0ID0ge30pIHtcbiAgICBjb25zdCByID0gKCgpID0+IHtcbiAgICAgIHZhciBpO1xuICAgICAgaWYgKHQuY2F1c2UgaW5zdGFuY2VvZiBtYSkge1xuICAgICAgICBpZiAodC5jYXVzZS5kZXRhaWxzKVxuICAgICAgICAgIHJldHVybiB0LmNhdXNlLmRldGFpbHM7XG4gICAgICAgIGlmICh0LmNhdXNlLnNob3J0TWVzc2FnZSlcbiAgICAgICAgICByZXR1cm4gdC5jYXVzZS5zaG9ydE1lc3NhZ2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdC5jYXVzZSAmJiBcImRldGFpbHNcIiBpbiB0LmNhdXNlICYmIHR5cGVvZiB0LmNhdXNlLmRldGFpbHMgPT0gXCJzdHJpbmdcIiA/IHQuY2F1c2UuZGV0YWlscyA6IChpID0gdC5jYXVzZSkgIT0gbnVsbCAmJiBpLm1lc3NhZ2UgPyB0LmNhdXNlLm1lc3NhZ2UgOiB0LmRldGFpbHM7XG4gICAgfSkoKSwgbiA9IFtcbiAgICAgIGUgfHwgXCJBbiBlcnJvciBvY2N1cnJlZC5cIixcbiAgICAgIC4uLnQubWV0YU1lc3NhZ2VzID8gW1wiXCIsIC4uLnQubWV0YU1lc3NhZ2VzXSA6IFtdLFxuICAgICAgLi4uciA/IFtcbiAgICAgICAgXCJcIixcbiAgICAgICAgciA/IGBEZXRhaWxzOiAke3J9YCA6IHZvaWQgMFxuICAgICAgXSA6IFtdXG4gICAgXS5maWx0ZXIoKGkpID0+IHR5cGVvZiBpID09IFwic3RyaW5nXCIpLmpvaW4oYFxuYCk7XG4gICAgc3VwZXIobiwgdC5jYXVzZSA/IHsgY2F1c2U6IHQuY2F1c2UgfSA6IHZvaWQgMCksIHRoaXMubmFtZSA9IFwiQmFzZUVycm9yXCIsIHRoaXMuY2F1c2UgPSB0LmNhdXNlLCB0aGlzLmRldGFpbHMgPSByLCB0aGlzLnNob3J0TWVzc2FnZSA9IGU7XG4gIH1cbn1cbmNsYXNzIGZnIGV4dGVuZHMgbWEge1xuICBjb25zdHJ1Y3Rvcih7IHN0YXR1czogZSB9KSB7XG4gICAgc3VwZXIoYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzICR7ZX1gKSwgdGhpcy5uYW1lID0gXCJSZXF1ZXN0RmFpbGVkRXJyb3JcIjtcbiAgfVxufVxuY2xhc3MganggZXh0ZW5kcyBtYSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlKSwgdGhpcy5uYW1lID0gXCJJbnZhbGlkVG9rZW5cIjtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gS3goeyBvcmlnaW46IHMgfSkge1xuICBjb25zdCBlID0gYXdhaXQgZmV0Y2goYCR7c30vbm9uY2VgLCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIlxuICB9KTtcbiAgaWYgKCFlLm9rKVxuICAgIHRocm93IG5ldyBmZyh7IHN0YXR1czogZS5zdGF0dXMgfSk7XG4gIHJldHVybiBhd2FpdCBlLmpzb24oKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIEh4KHsgb3JpZ2luOiBzIH0sIGUpIHtcbiAgY29uc3QgdCA9IGF3YWl0IGZldGNoKGAke3N9L3ZlcmlmeS1zaXdmYCwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgaGVhZGVyczogbmV3IEhlYWRlcnMoeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9KSxcbiAgICBib2R5OiBKU09OLnN0cmluZ2lmeShlKVxuICB9KTtcbiAgaWYgKCF0Lm9rKVxuICAgIHRocm93IG5ldyBmZyh7IHN0YXR1czogdC5zdGF0dXMgfSk7XG4gIGNvbnN0IHIgPSBhd2FpdCB0Lmpzb24oKTtcbiAgaWYgKHIudmFsaWQgPT09ICExKVxuICAgIHRocm93IG5ldyBqeChyLm1lc3NhZ2UgPz8gXCJ1bmtub3duXCIpO1xuICByZXR1cm4geyB0b2tlbjogci50b2tlbiB9O1xufVxuZnVuY3Rpb24gcXgocyA9IHt9KSB7XG4gIHJldHVybiB7XG4gICAgb3JpZ2luOiBzLm9yaWdpbiA/PyBcImh0dHBzOi8vYXV0aC5mYXJjYXN0ZXIueHl6XCJcbiAgfTtcbn1cbmZ1bmN0aW9uIFd4KHMgPSB7fSkge1xuICBjb25zdCBlID0gcXgocyk7XG4gIHJldHVybiB7XG4gICAgZ2VuZXJhdGVOb25jZTogKCkgPT4gS3goZSksXG4gICAgdmVyaWZ5U2l3ZjogKHQpID0+IEh4KGUsIHQpXG4gIH07XG59XG5jb25zdCB6eCA9IC9eKD86KD88c2NoZW1lPlthLXpBLVpdW2EtekEtWjAtOSstLl0qKTpcXC9cXC8pPyg/PGRvbWFpbj5bYS16QS1aMC05Ky0uXSooPzo6WzAtOV17MSw1fSk/KSAoPzp3YW50cyB5b3UgdG8gc2lnbiBpbiB3aXRoIHlvdXIgRXRoZXJldW0gYWNjb3VudDpcXG4pKD88YWRkcmVzcz4weFthLWZBLUYwLTldezQwfSlcXG5cXG4oPzooPzxzdGF0ZW1lbnQ+LiopXFxuXFxuKT8vLCBZeCA9IC8oPzpVUkk6ICg/PHVyaT4uKykpXFxuKD86VmVyc2lvbjogKD88dmVyc2lvbj4uKykpXFxuKD86Q2hhaW4gSUQ6ICg/PGNoYWluSWQ+XFxkKykpXFxuKD86Tm9uY2U6ICg/PG5vbmNlPlthLXpBLVowLTldKykpXFxuKD86SXNzdWVkIEF0OiAoPzxpc3N1ZWRBdD4uKykpKD86XFxuRXhwaXJhdGlvbiBUaW1lOiAoPzxleHBpcmF0aW9uVGltZT4uKykpPyg/Olxcbk5vdCBCZWZvcmU6ICg/PG5vdEJlZm9yZT4uKykpPyg/OlxcblJlcXVlc3QgSUQ6ICg/PHJlcXVlc3RJZD4uKykpPy87XG5mdW5jdGlvbiBaeChzKSB7XG4gIHZhciBkLCBoLCBmO1xuICBjb25zdCB7IHNjaGVtZTogZSwgc3RhdGVtZW50OiB0LCAuLi5yIH0gPSAoKGQgPSBzLm1hdGNoKHp4KSkgPT0gbnVsbCA/IHZvaWQgMCA6IGQuZ3JvdXBzKSA/PyB7fSwgeyBjaGFpbklkOiBuLCBleHBpcmF0aW9uVGltZTogaSwgaXNzdWVkQXQ6IG8sIG5vdEJlZm9yZTogYSwgcmVxdWVzdElkOiBsLCAuLi5jIH0gPSAoKGggPSBzLm1hdGNoKFl4KSkgPT0gbnVsbCA/IHZvaWQgMCA6IGguZ3JvdXBzKSA/PyB7fSwgdSA9IChmID0gcy5zcGxpdChcIlJlc291cmNlczpcIilbMV0pID09IG51bGwgPyB2b2lkIDAgOiBmLnNwbGl0KGBcbi0gYCkuc2xpY2UoMSk7XG4gIHJldHVybiB7XG4gICAgLi4ucixcbiAgICAuLi5jLFxuICAgIC4uLm4gPyB7IGNoYWluSWQ6IE51bWJlcihuKSB9IDoge30sXG4gICAgLi4uaSA/IHsgZXhwaXJhdGlvblRpbWU6IG5ldyBEYXRlKGkpIH0gOiB7fSxcbiAgICAuLi5vID8geyBpc3N1ZWRBdDogbmV3IERhdGUobykgfSA6IHt9LFxuICAgIC4uLmEgPyB7IG5vdEJlZm9yZTogbmV3IERhdGUoYSkgfSA6IHt9LFxuICAgIC4uLmwgPyB7IHJlcXVlc3RJZDogbCB9IDoge30sXG4gICAgLi4udSA/IHsgcmVzb3VyY2VzOiB1IH0gOiB7fSxcbiAgICAuLi5lID8geyBzY2hlbWU6IGUgfSA6IHt9LFxuICAgIC4uLnQgPyB7IHN0YXRlbWVudDogdCB9IDoge31cbiAgfTtcbn1cbmNvbnN0IGpkID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIGxldCBzLCBlO1xuICBhc3luYyBmdW5jdGlvbiB0KHIpIHtcbiAgICBjb25zdCBuID0gV3goe1xuICAgICAgb3JpZ2luOiByLnF1aWNrQXV0aFNlcnZlck9yaWdpblxuICAgIH0pLCB7IG5vbmNlOiBpIH0gPSBhd2FpdCBuLmdlbmVyYXRlTm9uY2UoKSwgbyA9IGF3YWl0IE1lLnNpZ25Jbih7XG4gICAgICBub25jZTogaSxcbiAgICAgIGFjY2VwdEF1dGhBZGRyZXNzOiAhMFxuICAgIH0pO1xuICAgIGlmIChvLnJlc3VsdCkge1xuICAgICAgY29uc3QgYSA9IFp4KG8ucmVzdWx0Lm1lc3NhZ2UpO1xuICAgICAgaWYgKCFhLmRvbWFpbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBkb21haW4gb24gU0lXRSBtZXNzYWdlXCIpO1xuICAgICAgY29uc3QgbCA9IGF3YWl0IG4udmVyaWZ5U2l3Zih7XG4gICAgICAgIGRvbWFpbjogYS5kb21haW4sXG4gICAgICAgIG1lc3NhZ2U6IG8ucmVzdWx0Lm1lc3NhZ2UsXG4gICAgICAgIHNpZ25hdHVyZTogby5yZXN1bHQuc2lnbmF0dXJlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBzID0ge1xuICAgICAgICB0b2tlbjogbC50b2tlbixcbiAgICAgICAgcGF5bG9hZDogVngobC50b2tlbilcbiAgICAgIH0sIGw7XG4gICAgfVxuICAgIHRocm93IG8uZXJyb3IudHlwZSA9PT0gXCJyZWplY3RlZF9ieV91c2VyXCIgPyBuZXcgT2YoKSA6IG5ldyBFcnJvcihcIlVucmVhY2hhYmxlXCIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZ2V0IHRva2VuKCkge1xuICAgICAgaWYgKHMgJiYgbmV3IERhdGUocy5wYXlsb2FkLmV4cCAqIDFlMykgPiBuZXcgRGF0ZShEYXRlLm5vdygpICsgMTVlMykpXG4gICAgICAgIHJldHVybiBzLnRva2VuO1xuICAgIH0sXG4gICAgYXN5bmMgZ2V0VG9rZW4ociA9IHt9KSB7XG4gICAgICBjb25zdCBuID0gci5mb3JjZSA/PyAhMTtcbiAgICAgIHJldHVybiBzICYmICFuICYmIG5ldyBEYXRlKHMucGF5bG9hZC5leHAgKiAxZTMpID4gbmV3IERhdGUoRGF0ZS5ub3coKSArIDE1ZTMpID8geyB0b2tlbjogcy50b2tlbiB9IDogKGUgfHwgKGUgPSB0KHIpKSwgZS5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgZSA9IHZvaWQgMDtcbiAgICAgIH0pLCBlKTtcbiAgICB9LFxuICAgIGFzeW5jIGZldGNoKHIsIG4pIHtcbiAgICAgIGNvbnN0IHsgdG9rZW46IGkgfSA9IGF3YWl0IHRoaXMuZ2V0VG9rZW4oKSwgbyA9IG5ldyBIZWFkZXJzKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uaGVhZGVycyk7XG4gICAgICByZXR1cm4gby5zZXQoXCJBdXRob3JpemF0aW9uXCIsIGBCZWFyZXIgJHtpfWApLCBmZXRjaChyLCB7XG4gICAgICAgIC4uLm4sXG4gICAgICAgIGhlYWRlcnM6IG9cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0pKCk7XG5mdW5jdGlvbiBYeCgpIHtcbiAgY29uc3QgcyA9IG5ldyBMMCgpO1xuICByZXR1cm4ge1xuICAgIGdldCBldmVudE5hbWVzKCkge1xuICAgICAgcmV0dXJuIHMuZXZlbnROYW1lcy5iaW5kKHMpO1xuICAgIH0sXG4gICAgZ2V0IGxpc3RlbmVyQ291bnQoKSB7XG4gICAgICByZXR1cm4gcy5saXN0ZW5lckNvdW50LmJpbmQocyk7XG4gICAgfSxcbiAgICBnZXQgbGlzdGVuZXJzKCkge1xuICAgICAgcmV0dXJuIHMubGlzdGVuZXJzLmJpbmQocyk7XG4gICAgfSxcbiAgICBhZGRMaXN0ZW5lcjogcy5hZGRMaXN0ZW5lci5iaW5kKHMpLFxuICAgIGVtaXQ6IHMuZW1pdC5iaW5kKHMpLFxuICAgIG9mZjogcy5vZmYuYmluZChzKSxcbiAgICBvbjogcy5vbi5iaW5kKHMpLFxuICAgIG9uY2U6IHMub25jZS5iaW5kKHMpLFxuICAgIHJlbW92ZUFsbExpc3RlbmVyczogcy5yZW1vdmVBbGxMaXN0ZW5lcnMuYmluZChzKSxcbiAgICByZW1vdmVMaXN0ZW5lcjogcy5yZW1vdmVMaXN0ZW5lci5iaW5kKHMpXG4gIH07XG59XG5jb25zdCBuciA9IFh4KCksIHsgc29sYW5hUHJvdmlkZXJSZXF1ZXN0OiBLZCB9ID0gTWU7XG5sZXQgZ2c7XG5LZCAmJiAoZ2cgPSBWRShLRShLZCkpKTtcbmFzeW5jIGZ1bmN0aW9uIEhkKCkge1xuICBsZXQgcztcbiAgdHJ5IHtcbiAgICBzID0gYXdhaXQgTWUuZ2V0Q2FwYWJpbGl0aWVzKCk7XG4gIH0gY2F0Y2gge1xuICB9XG4gIGlmIChzICE9IG51bGwgJiYgcy5pbmNsdWRlcyhcIndhbGxldC5nZXRTb2xhbmFQcm92aWRlclwiKSlcbiAgICByZXR1cm4gZ2c7XG59XG5sZXQgcWQgPSBudWxsO1xuYXN5bmMgZnVuY3Rpb24gSngocyA9IDFlMykge1xuICBpZiAocWQgPT09ICEwKVxuICAgIHJldHVybiAhMDtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPiBcInVcIiB8fCAhd2luZG93LlJlYWN0TmF0aXZlV2ViVmlldyAmJiB3aW5kb3cgPT09IHdpbmRvdy5wYXJlbnQpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBlID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICBNZS5jb250ZXh0LnRoZW4oKHQpID0+ICEhdCksXG4gICAgLy8gQ2hlY2sgaWYgY29udGV4dCByZXNvbHZlcyB0byB0cnV0aHlcbiAgICBuZXcgUHJvbWlzZSgodCkgPT4ge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB0KCExKSwgcyk7XG4gICAgfSlcbiAgXSkuY2F0Y2goKCkgPT4gITEpO1xuICByZXR1cm4gZSAmJiAocWQgPSAhMCksIGU7XG59XG5jb25zdCBXZCA9IGFzeW5jICgpID0+IHtcbiAgY29uc3QgcyA9IGF3YWl0IE1lLmFkZEZyYW1lKCk7XG4gIGlmIChzLnJlc3VsdClcbiAgICByZXR1cm4gcy5yZXN1bHQ7XG4gIHRocm93IHMuZXJyb3IudHlwZSA9PT0gXCJpbnZhbGlkX2RvbWFpbl9tYW5pZmVzdFwiID8gbmV3IFRtKCkgOiBzLmVycm9yLnR5cGUgPT09IFwicmVqZWN0ZWRfYnlfdXNlclwiID8gbmV3IHdtKCkgOiBuZXcgRXJyb3IoXCJVbnJlYWNoYWJsZVwiKTtcbn0sIGh0ID0ge1xuICAuLi5ucixcbiAgZ2V0Q2FwYWJpbGl0aWVzOiBNZS5nZXRDYXBhYmlsaXRpZXMsXG4gIGdldENoYWluczogTWUuZ2V0Q2hhaW5zLFxuICBpc0luTWluaUFwcDogSngsXG4gIGNvbnRleHQ6IE1lLmNvbnRleHQsXG4gIGJhY2s6IEhFKHsgbWluaUFwcEhvc3Q6IE1lLCBlbWl0dGVyOiBuciB9KSxcbiAgcXVpY2tBdXRoOiBqZCxcbiAgYWN0aW9uczoge1xuICAgIHNldFByaW1hcnlCdXR0b246IE1lLnNldFByaW1hcnlCdXR0b24uYmluZChNZSksXG4gICAgcmVhZHk6IGFzeW5jIChzID0ge30pID0+IGF3YWl0IE1lLnJlYWR5KHMpLFxuICAgIGNsb3NlOiBNZS5jbG9zZS5iaW5kKE1lKSxcbiAgICB2aWV3Q2FzdDogTWUudmlld0Nhc3QuYmluZChNZSksXG4gICAgdmlld1Byb2ZpbGU6IE1lLnZpZXdQcm9maWxlLmJpbmQoTWUpLFxuICAgIG9wZW5NaW5pQXBwOiBNZS5vcGVuTWluaUFwcC5iaW5kKE1lKSxcbiAgICBzaWduSW46IGFzeW5jIChzKSA9PiB7XG4gICAgICBjb25zdCBlID0gYXdhaXQgTWUuc2lnbkluKHMpO1xuICAgICAgaWYgKGUucmVzdWx0KVxuICAgICAgICByZXR1cm4gZS5yZXN1bHQ7XG4gICAgICB0aHJvdyBlLmVycm9yLnR5cGUgPT09IFwicmVqZWN0ZWRfYnlfdXNlclwiID8gbmV3IE9mKCkgOiBuZXcgRXJyb3IoXCJVbnJlYWNoYWJsZVwiKTtcbiAgICB9LFxuICAgIG9wZW5Vcmw6IChzKSA9PiB7XG4gICAgICBjb25zdCBlID0gdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiA/IHMgOiBzLnVybDtcbiAgICAgIHJldHVybiBNZS5vcGVuVXJsKGUudHJpbSgpKTtcbiAgICB9LFxuICAgIGFkZEZyYW1lOiBXZCxcbiAgICBhZGRNaW5pQXBwOiBXZCxcbiAgICBjb21wb3NlQ2FzdChzID0ge30pIHtcbiAgICAgIHJldHVybiBNZS5jb21wb3NlQ2FzdChzKTtcbiAgICB9LFxuICAgIHZpZXdUb2tlbjogTWUudmlld1Rva2VuLmJpbmQoTWUpLFxuICAgIHNlbmRUb2tlbjogTWUuc2VuZFRva2VuLmJpbmQoTWUpLFxuICAgIHN3YXBUb2tlbjogTWUuc3dhcFRva2VuLmJpbmQoTWUpLFxuICAgIHJlcXVlc3RDYW1lcmFBbmRNaWNyb3Bob25lQWNjZXNzOiBNZS5yZXF1ZXN0Q2FtZXJhQW5kTWljcm9waG9uZUFjY2Vzcy5iaW5kKE1lKVxuICB9LFxuICBleHBlcmltZW50YWw6IHtcbiAgICBnZXRTb2xhbmFQcm92aWRlcjogSGQsXG4gICAgc2lnbk1hbmlmZXN0OiBhc3luYyAocykgPT4ge1xuICAgICAgY29uc3QgZSA9IGF3YWl0IE1lLnNpZ25NYW5pZmVzdChzKTtcbiAgICAgIGlmIChlLnJlc3VsdClcbiAgICAgICAgcmV0dXJuIGUucmVzdWx0O1xuICAgICAgdGhyb3cgZS5lcnJvci50eXBlID09PSBcInJlamVjdGVkX2J5X3VzZXJcIiA/IG5ldyBBbSgpIDogZS5lcnJvci50eXBlID09PSBcImludmFsaWRfZG9tYWluXCIgPyBuZXcgSW0oKSA6IGUuZXJyb3IudHlwZSA9PT0gXCJnZW5lcmljX2Vycm9yXCIgPyBuZXcgX20oZS5lcnJvci5tZXNzYWdlKSA6IG5ldyBFcnJvcihcIlVucmVhY2hhYmxlXCIpO1xuICAgIH0sXG4gICAgcXVpY2tBdXRoKHMpIHtcbiAgICAgIHJldHVybiBqZC5nZXRUb2tlbihzKTtcbiAgICB9XG4gIH0sXG4gIHdhbGxldDoge1xuICAgIGV0aFByb3ZpZGVyOiBmaSxcbiAgICBnZXRFdGhlcmV1bVByb3ZpZGVyOiBieCxcbiAgICBnZXRTb2xhbmFQcm92aWRlcjogSGRcbiAgfSxcbiAgaGFwdGljczoge1xuICAgIGltcGFjdE9jY3VycmVkOiBNZS5pbXBhY3RPY2N1cnJlZC5iaW5kKE1lKSxcbiAgICBub3RpZmljYXRpb25PY2N1cnJlZDogTWUubm90aWZpY2F0aW9uT2NjdXJyZWQuYmluZChNZSksXG4gICAgc2VsZWN0aW9uQ2hhbmdlZDogTWUuc2VsZWN0aW9uQ2hhbmdlZC5iaW5kKE1lKVxuICB9XG59O1xudHlwZW9mIGRvY3VtZW50IDwgXCJ1XCIgJiYgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkZhcmNhc3RlckZyYW1lRXZlbnRcIiwgKHMpID0+IHtcbiAgaWYgKHMgaW5zdGFuY2VvZiBNZXNzYWdlRXZlbnQpIHtcbiAgICBjb25zdCBlID0gcy5kYXRhO1xuICAgIGUuZXZlbnQgPT09IFwicHJpbWFyeV9idXR0b25fY2xpY2tlZFwiID8gbnIuZW1pdChcInByaW1hcnlCdXR0b25DbGlja2VkXCIpIDogZS5ldmVudCA9PT0gXCJtaW5pYXBwX2FkZGVkXCIgPyBuci5lbWl0KFwibWluaUFwcEFkZGVkXCIsIHtcbiAgICAgIG5vdGlmaWNhdGlvbkRldGFpbHM6IGUubm90aWZpY2F0aW9uRGV0YWlsc1xuICAgIH0pIDogZS5ldmVudCA9PT0gXCJtaW5pYXBwX2FkZF9yZWplY3RlZFwiID8gbnIuZW1pdChcIm1pbmlBcHBBZGRSZWplY3RlZFwiLCB7IHJlYXNvbjogZS5yZWFzb24gfSkgOiBlLmV2ZW50ID09PSBcIm1pbmlhcHBfcmVtb3ZlZFwiID8gbnIuZW1pdChcIm1pbmlBcHBSZW1vdmVkXCIpIDogZS5ldmVudCA9PT0gXCJub3RpZmljYXRpb25zX2VuYWJsZWRcIiA/IG5yLmVtaXQoXCJub3RpZmljYXRpb25zRW5hYmxlZFwiLCB7XG4gICAgICBub3RpZmljYXRpb25EZXRhaWxzOiBlLm5vdGlmaWNhdGlvbkRldGFpbHNcbiAgICB9KSA6IGUuZXZlbnQgPT09IFwibm90aWZpY2F0aW9uc19kaXNhYmxlZFwiID8gbnIuZW1pdChcIm5vdGlmaWNhdGlvbnNEaXNhYmxlZFwiKSA6IGUuZXZlbnQgPT09IFwiYmFja19uYXZpZ2F0aW9uX3RyaWdnZXJlZFwiICYmIG5yLmVtaXQoXCJiYWNrTmF2aWdhdGlvblRyaWdnZXJlZFwiKTtcbiAgfVxufSk7XG50eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChzKSA9PiB7XG4gIGlmIChzIGluc3RhbmNlb2YgTWVzc2FnZUV2ZW50ICYmIHMuZGF0YS50eXBlID09PSBcImZyYW1lRXZlbnRcIikge1xuICAgIGNvbnN0IGUgPSBzLmRhdGEuZXZlbnQ7XG4gICAgZS5ldmVudCA9PT0gXCJwcmltYXJ5X2J1dHRvbl9jbGlja2VkXCIgPyBuci5lbWl0KFwicHJpbWFyeUJ1dHRvbkNsaWNrZWRcIikgOiBlLmV2ZW50ID09PSBcIm1pbmlhcHBfYWRkZWRcIiA/IG5yLmVtaXQoXCJtaW5pQXBwQWRkZWRcIiwge1xuICAgICAgbm90aWZpY2F0aW9uRGV0YWlsczogZS5ub3RpZmljYXRpb25EZXRhaWxzXG4gICAgfSkgOiBlLmV2ZW50ID09PSBcIm1pbmlhcHBfYWRkX3JlamVjdGVkXCIgPyBuci5lbWl0KFwibWluaUFwcEFkZFJlamVjdGVkXCIsIHsgcmVhc29uOiBlLnJlYXNvbiB9KSA6IGUuZXZlbnQgPT09IFwibWluaWFwcF9yZW1vdmVkXCIgPyBuci5lbWl0KFwibWluaUFwcFJlbW92ZWRcIikgOiBlLmV2ZW50ID09PSBcIm5vdGlmaWNhdGlvbnNfZW5hYmxlZFwiID8gbnIuZW1pdChcIm5vdGlmaWNhdGlvbnNFbmFibGVkXCIsIHtcbiAgICAgIG5vdGlmaWNhdGlvbkRldGFpbHM6IGUubm90aWZpY2F0aW9uRGV0YWlsc1xuICAgIH0pIDogZS5ldmVudCA9PT0gXCJub3RpZmljYXRpb25zX2Rpc2FibGVkXCIgPyBuci5lbWl0KFwibm90aWZpY2F0aW9uc0Rpc2FibGVkXCIpIDogZS5ldmVudCA9PT0gXCJiYWNrX25hdmlnYXRpb25fdHJpZ2dlcmVkXCIgJiYgbnIuZW1pdChcImJhY2tOYXZpZ2F0aW9uVHJpZ2dlcmVkXCIpO1xuICB9XG59KTtcbmZ1bmN0aW9uIFF4KHMpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPiBcInVcIilcbiAgICByZXR1cm47XG4gIGNvbnN0IGUgPSAodCkgPT4gcyh0LmRldGFpbCk7XG4gIHJldHVybiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImVpcDY5NjM6YW5ub3VuY2VQcm92aWRlclwiLCBlKSwgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiZWlwNjk2MzpyZXF1ZXN0UHJvdmlkZXJcIikpLCAoKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVpcDY5NjM6YW5ub3VuY2VQcm92aWRlclwiLCBlKTtcbn1cbmZ1bmN0aW9uIGVTKCkge1xuICBjb25zdCBzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgbGV0IGUgPSBbXTtcbiAgY29uc3QgdCA9ICgpID0+IFF4KChuKSA9PiB7XG4gICAgZS5zb21lKCh7IGluZm86IGkgfSkgPT4gaS51dWlkID09PSBuLmluZm8udXVpZCkgfHwgKGUgPSBbLi4uZSwgbl0sIHMuZm9yRWFjaCgoaSkgPT4gaShlLCB7IGFkZGVkOiBbbl0gfSkpKTtcbiAgfSk7XG4gIGxldCByID0gdCgpO1xuICByZXR1cm4ge1xuICAgIF9saXN0ZW5lcnMoKSB7XG4gICAgICByZXR1cm4gcztcbiAgICB9LFxuICAgIGNsZWFyKCkge1xuICAgICAgcy5mb3JFYWNoKChuKSA9PiBuKFtdLCB7IHJlbW92ZWQ6IFsuLi5lXSB9KSksIGUgPSBbXTtcbiAgICB9LFxuICAgIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmNsZWFyKCksIHMuY2xlYXIoKSwgciA9PSBudWxsIHx8IHIoKTtcbiAgICB9LFxuICAgIGZpbmRQcm92aWRlcih7IHJkbnM6IG4gfSkge1xuICAgICAgcmV0dXJuIGUuZmluZCgoaSkgPT4gaS5pbmZvLnJkbnMgPT09IG4pO1xuICAgIH0sXG4gICAgZ2V0UHJvdmlkZXJzKCkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSxcbiAgICByZXNldCgpIHtcbiAgICAgIHRoaXMuY2xlYXIoKSwgciA9PSBudWxsIHx8IHIoKSwgciA9IHQoKTtcbiAgICB9LFxuICAgIHN1YnNjcmliZShuLCB7IGVtaXRJbW1lZGlhdGVseTogaSB9ID0ge30pIHtcbiAgICAgIHJldHVybiBzLmFkZChuKSwgaSAmJiBuKGUsIHsgYWRkZWQ6IGUgfSksICgpID0+IHMuZGVsZXRlKG4pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHRTKHMsIGUgPSB7fSwgdCkge1xuICBpZiAoIXQgfHwgdCA9PT0gXCJcIikge1xuICAgIGNvbnNvbGUuZGVidWcoXCJBbXBsaXR1ZGU6IFNraXBwaW5nIGV2ZW50IHRyYWNraW5nIC0gbm8gdXNlcklkIGF2YWlsYWJsZSB5ZXRcIik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHIgPSB7XG4gICAgZXZlbnRfdHlwZTogcyxcbiAgICBhcGlfa2V5OiBcIjBjNGZlNDYxNzFiOWJiOGVjYTJjYTYxZWI3MWYyZTE5XCIsXG4gICAgdGltZTogRGF0ZS5ub3coKSxcbiAgICB1c2VyX2lkOiB0LFxuICAgIC4uLk9iamVjdC5rZXlzKGUpLmxlbmd0aCAmJiB7XG4gICAgICBldmVudF9wcm9wZXJ0aWVzOiBlXG4gICAgfVxuICB9O1xuICBmZXRjaChcImh0dHBzOi8vYXBpMi5hbXBsaXR1ZGUuY29tLzIvaHR0cGFwaVwiLCB7XG4gICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgIH0sXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgYXBpX2tleTogXCIwYzRmZTQ2MTcxYjliYjhlY2EyY2E2MWViNzFmMmUxOVwiLFxuICAgICAgZXZlbnRzOiBbcl1cbiAgICB9KVxuICB9KS50aGVuKChuKSA9PiB7XG4gICAgbi5vayB8fCBjb25zb2xlLmRlYnVnKFwiQW1wbGl0dWRlIHJlc3BvbnNlIGVycm9yOlwiLCBuLnN0YXR1cywgbi5zdGF0dXNUZXh0KTtcbiAgfSkuY2F0Y2goKG4pID0+IHtcbiAgICBjb25zb2xlLmRlYnVnKFwiQW1wbGl0dWRlIHRyYWNraW5nIGVycm9yOlwiLCBuKTtcbiAgfSk7XG59XG5jb25zdCBwZyA9IGFhKHtcbiAgYW5hbHl0aWNzRW5hYmxlZDogITEsXG4gIGJhY2tCdXR0b25FbmFibGVkOiAhMSxcbiAgcmV0dXJuVXJsOiB2b2lkIDBcbn0pLCBtZyA9IHN0LmNyZWF0ZUNvbnRleHQodm9pZCAwKTtcbmZ1bmN0aW9uIHJTKCkge1xuICBjb25zdCB7XG4gICAgYW5hbHl0aWNzRW5hYmxlZDogcyxcbiAgICBiYWNrQnV0dG9uRW5hYmxlZDogZSxcbiAgICByZXR1cm5Vcmw6IHRcbiAgfSA9IEFpKHBnKSwgW3IsIG5dID0gcWUoITEpLCBbaSwgb10gPSBxZShudWxsKSwgW2EsIGxdID0gcWUoITEpLCBbYywgdV0gPSBxZShudWxsKSwgW2QsIGhdID0gcWUoXCJcIiksIFtmLCBwXSA9IHFlKHt9KSwgW3ksIEVdID0gcWUoXCJcIiksIFtiLCBSXSA9IHFlKFtdKSwgW0EsIEZdID0gcWUoXCJcIiksIE0gPSBidCgvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKSwgSCA9IGJ0KC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpLCBLID0gYnQoe30pLCBqID0gYnQoXCJcIik7XG4gIEsuY3VycmVudCA9IGYsIGouY3VycmVudCA9IHk7XG4gIGNvbnN0IEMgPSB1dCgobSwgdiA9IHt9LCBQKSA9PiB7XG4gICAgcyAmJiB0UyhtLCB2LCBQKTtcbiAgfSwgW3NdKSwgayA9IHV0KChtKSA9PiB7XG4gICAgUigodikgPT4ge1xuICAgICAgY29uc3QgUCA9IFsuLi52LCBtXTtcbiAgICAgIHJldHVybiBDKFwibmF2aWdhdGlvbi5zZXRBY3RpdmVUYWJcIiwge1xuICAgICAgICAuLi5LLmN1cnJlbnQsXG4gICAgICAgIHRvVGFiOiBtLFxuICAgICAgICBoaXN0b3J5TGVuZ3RoOiBQLmxlbmd0aFxuICAgICAgfSwgai5jdXJyZW50KSwgUDtcbiAgICB9KSwgRihtKTtcbiAgfSwgW0NdKSwgJCA9IHV0KGFzeW5jIChtKSA9PiB7XG4gICAgY29uc3QgdiA9IHR5cGVvZiBtID09IFwic3RyaW5nXCIgPyBtIDogbS51cmw7XG4gICAgYXdhaXQgaHQuaXNJbk1pbmlBcHAoKSA/IGF3YWl0IGh0LmFjdGlvbnMub3BlblVybCh2KSA6IHdpbmRvdy5vcGVuKHYsIFwiX2JsYW5rXCIpO1xuICB9LCBbXSksIFcgPSB1dChhc3luYyAoKSA9PiB7XG4gICAgYXdhaXQgaHQuaXNJbk1pbmlBcHAoKSA/IGF3YWl0IGh0LmFjdGlvbnMuY2xvc2UoKSA6IHdpbmRvdy5jbG9zZSgpO1xuICB9LCBbXSksIF8gPSB1dCgoKSA9PiB7XG4gICAgUigobSkgPT4ge1xuICAgICAgaWYgKG0ubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdCAmJiAkKHQpLCBtO1xuICAgICAgY29uc3QgdiA9IG0uc2xpY2UoMCwgLTEpLCBQID0gdi5sZW5ndGggPiAwID8gdlt2Lmxlbmd0aCAtIDFdIDogXCJcIjtcbiAgICAgIHJldHVybiBGKFApLCBDKFwibmF2aWdhdGlvbi5uYXZCYWNrXCIsIHtcbiAgICAgICAgLi4uSy5jdXJyZW50LFxuICAgICAgICBmcm9tVGFiOiBtW20ubGVuZ3RoIC0gMV0sXG4gICAgICAgIHRvVGFiOiBQLFxuICAgICAgICBoaXN0b3J5TGVuZ3RoOiB2Lmxlbmd0aFxuICAgICAgfSwgai5jdXJyZW50KSwgdjtcbiAgICB9KTtcbiAgfSwgW0MsIHQsICRdKSwgZyA9IHV0KChtKSA9PiB7XG4gICAgUihbbV0pLCBGKG0pLCBDKFwibmF2aWdhdGlvbi5zZXRJbml0aWFsVGFiXCIsIHtcbiAgICAgIC4uLksuY3VycmVudCxcbiAgICAgIHRhYjogbVxuICAgIH0sIGouY3VycmVudCk7XG4gIH0sIFtDXSksIHggPSB1dChhc3luYyAobSkgPT4gKEMoXCJoYXB0aWNzLmltcGFjdE9jY3VycmVkXCIsIHtcbiAgICAuLi5LLmN1cnJlbnQsXG4gICAgaGFwdGljVHlwZTogbVxuICB9LCBqLmN1cnJlbnQpLCBodC5oYXB0aWNzLmltcGFjdE9jY3VycmVkKG0pKSwgW0NdKSwgdyA9IHV0KGFzeW5jIChtKSA9PiAoQyhcImhhcHRpY3Mubm90aWZpY2F0aW9uT2NjdXJyZWRcIiwge1xuICAgIC4uLksuY3VycmVudCxcbiAgICBoYXB0aWNUeXBlOiBtXG4gIH0sIGouY3VycmVudCksIGh0LmhhcHRpY3Mubm90aWZpY2F0aW9uT2NjdXJyZWQobSkpLCBbQ10pLCBEID0gdXQoYXN5bmMgKCkgPT4gKEMoXCJoYXB0aWNzLnNlbGVjdGlvbkNoYW5nZWRcIiwge1xuICAgIC4uLksuY3VycmVudFxuICB9LCBqLmN1cnJlbnQpLCBodC5oYXB0aWNzLnNlbGVjdGlvbkNoYW5nZWQoKSksIFtDXSksIE8gPSB1dChhc3luYyAobSwgdikgPT4gKHYgJiYgcyAmJiBDKFwiY2FzdC5jb21wb3NlZFwiLCB7XG4gICAgLi4uSy5jdXJyZW50LFxuICAgIGNhc3RUZXh0OiBtID09IG51bGwgPyB2b2lkIDAgOiBtLnRleHQsXG4gICAgc291cmNlOiB2XG4gIH0sIGouY3VycmVudCksIGh0LmFjdGlvbnMuY29tcG9zZUNhc3QobSkpLCBbcywgQ10pLCBVID0gYnQoXyk7XG4gIFUuY3VycmVudCA9IF8sIGZ0KCgpID0+IHtcbiAgICBpZiAocilcbiAgICAgIHJldHVybjtcbiAgICBsZXQgbSA9ICEwLCB2ID0gbnVsbDtcbiAgICBjb25zdCBQID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgTiA9IGF3YWl0IGh0LmNvbnRleHQ7XG4gICAgICBpZiAoIW0pIHJldHVybjtcbiAgICAgIGlmIChvKE4pLCBodC5vbihcIm1pbmlBcHBBZGRlZFwiLCAoe1xuICAgICAgICBub3RpZmljYXRpb25EZXRhaWxzOiBlZVxuICAgICAgfSkgPT4ge1xuICAgICAgICBsKCEwKSwgdShlZSA/PyBudWxsKSwgaChcIkZyYW1lIGFkZGVkXCIpLCBDKFwiZnJhbWUuYWRkZWRcIiwgSy5jdXJyZW50LCBqLmN1cnJlbnQpO1xuICAgICAgfSksIGh0Lm9uKFwibWluaUFwcEFkZFJlamVjdGVkXCIsICh7XG4gICAgICAgIHJlYXNvbjogZWVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgbCghMSksIGgoYEZyYW1lIGFkZCByZWplY3RlZDogJHtlZX1gKSwgQyhcImZyYW1lLmFkZC5yZWplY3RlZFwiLCBLLmN1cnJlbnQsIGouY3VycmVudCk7XG4gICAgICB9KSwgaHQub24oXCJtaW5pQXBwUmVtb3ZlZFwiLCAoKSA9PiB7XG4gICAgICAgIGwoITEpLCBoKFwiRnJhbWUgcmVtb3ZlZFwiKSwgQyhcImZyYW1lLnJlbW92ZWRcIiwgSy5jdXJyZW50LCBqLmN1cnJlbnQpO1xuICAgICAgfSksIGh0Lm9uKFwibm90aWZpY2F0aW9uc0VuYWJsZWRcIiwgKHtcbiAgICAgICAgbm90aWZpY2F0aW9uRGV0YWlsczogZWVcbiAgICAgIH0pID0+IHtcbiAgICAgICAgdShlZSA/PyBudWxsKSwgaChcIk5vdGlmaWNhdGlvbnMgZW5hYmxlZFwiKSwgQyhcIm5vdGlmaWNhdGlvbnMuZW5hYmxlZFwiLCBLLmN1cnJlbnQsIGouY3VycmVudCk7XG4gICAgICB9KSwgaHQub24oXCJub3RpZmljYXRpb25zRGlzYWJsZWRcIiwgKCkgPT4ge1xuICAgICAgICB1KG51bGwpLCBoKFwiTm90aWZpY2F0aW9ucyBkaXNhYmxlZFwiKSwgQyhcIm5vdGlmaWNhdGlvbnMuZGlzYWJsZWRcIiwgSy5jdXJyZW50LCBqLmN1cnJlbnQpO1xuICAgICAgfSksIGh0Lm9uKFwicHJpbWFyeUJ1dHRvbkNsaWNrZWRcIiwgKCkgPT4ge1xuICAgICAgICBoKFwiUHJpbWFyeSBidXR0b24gY2xpY2tlZFwiKSwgQyhcInByaW1hcnktYnV0dG9uLmNsaWNrZWRcIiwgSy5jdXJyZW50LCBqLmN1cnJlbnQpO1xuICAgICAgfSksIHYgPSBlUygpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICB9KSwgYXdhaXQgaHQuYWN0aW9ucy5yZWFkeSgpLCBlKVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGh0LmJhY2sub25iYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgQyhcImJhY2stYnV0dG9uLmNsaWNrZWRcIiwgSy5jdXJyZW50LCBqLmN1cnJlbnQpLCBVLmN1cnJlbnQoKTtcbiAgICAgICAgICB9LCBhd2FpdCBodC5iYWNrLnNob3coKTtcbiAgICAgICAgfSBjYXRjaCAoZWUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJCYWNrIGJ1dHRvbiBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgY2xpZW50OlwiLCBlZSk7XG4gICAgICAgIH1cbiAgICAgIG0gJiYgbighMCk7XG4gICAgfTtcbiAgICBpZiAoaHQpXG4gICAgICByZXR1cm4gUCgpLCAoKSA9PiB7XG4gICAgICAgIG0gPSAhMSwgaHQucmVtb3ZlQWxsTGlzdGVuZXJzKCksIGh0LmJhY2sub25iYWNrID0gbnVsbCwgaHQuYmFjay5oaWRlKCksIHYgJiYgdigpLCBILmN1cnJlbnQuZm9yRWFjaCgoTikgPT4gY2xlYXJUaW1lb3V0KE4pKSwgSC5jdXJyZW50LmNsZWFyKCksIE0uY3VycmVudC5jbGVhcigpO1xuICAgICAgfTtcbiAgfSwgW1xuICAgIC8vIE9ubHkgaW5jbHVkZSBzdGFibGUgcmVmZXJlbmNlcyB0aGF0IHdvbid0IGNoYW5nZVxuICAgIGUsXG4gICAgQ1xuICBdKSwgZnQoKCkgPT4ge1xuICAgIGkgIT0gbnVsbCAmJiBpLnVzZXIgJiYgKGkgIT0gbnVsbCAmJiBpLmNsaWVudCkgJiYgKHAoe1xuICAgICAgdXNlcm5hbWU6IGkudXNlci51c2VybmFtZSxcbiAgICAgIGNsaWVudEZpZDogaS5jbGllbnQuY2xpZW50RmlkXG4gICAgfSksIEUoYCR7aS51c2VyLmZpZH1gKSwgQyhcImZyYW1lLm9wZW5lZFwiLCB7XG4gICAgICB1c2VybmFtZTogaS51c2VyLnVzZXJuYW1lLFxuICAgICAgY2xpZW50RmlkOiBpLmNsaWVudC5jbGllbnRGaWQsXG4gICAgICBsb2NhdGlvbjogaS5sb2NhdGlvbixcbiAgICAgIGFkZGVkOiBpLmNsaWVudC5hZGRlZFxuICAgIH0sIGAke2kudXNlci5maWR9YCkpO1xuICB9LCBbaSwgQ10pO1xuICBjb25zdCBbViwgTF0gPSBxZShcIlwiKTtcbiAgcmV0dXJuIGZ0KCgpID0+IHtcbiAgICBjb25zdCBtID0gKCkgPT4ge1xuICAgICAgTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgfTtcbiAgICBtKCksIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgbSk7XG4gICAgY29uc3QgdiA9IHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSwgUCA9IHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZTtcbiAgICByZXR1cm4gd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlID0gZnVuY3Rpb24oLi4uTikge1xuICAgICAgdi5hcHBseSh3aW5kb3cuaGlzdG9yeSwgTiksIG0oKTtcbiAgICB9LCB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiguLi5OKSB7XG4gICAgICBQLmFwcGx5KHdpbmRvdy5oaXN0b3J5LCBOKSwgbSgpO1xuICAgIH0sICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgbSksIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSA9IHYsIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZSA9IFA7XG4gICAgfTtcbiAgfSwgW10pLCBmdCgoKSA9PiB7XG4gICAgdmFyIFksIGVlO1xuICAgIGlmICghKChZID0gaSA9PSBudWxsID8gdm9pZCAwIDogaS51c2VyKSAhPSBudWxsICYmIFkuZmlkKSB8fCAhKChlZSA9IGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuY2xpZW50KSAhPSBudWxsICYmIGVlLmNsaWVudEZpZCkgfHwgIVYpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbSA9IG5ldyBVUkxTZWFyY2hQYXJhbXMod2luZG93LmxvY2F0aW9uLnNlYXJjaCksIHYgPSBtLmdldChcInV0bV9zb3VyY2VcIiksIFAgPSBtLmdldChcInV0bV9tZWRpdW1cIiksIE4gPSBtLmdldChcInV0bV9jYW1wYWlnblwiKTtcbiAgICBpZiAodiA9PT0gXCJuZXluYXJcIiAmJiAoUCAhPSBudWxsICYmIFAuc3RhcnRzV2l0aChcInNoYXJlLWNhc3QtXCIpKSkge1xuICAgICAgY29uc3QgaWUgPSBQLnJlcGxhY2UoXCJzaGFyZS1jYXN0LVwiLCBcIlwiKTtcbiAgICAgIEMoXCJjYXN0LnNoYXJlZFwiLCB7XG4gICAgICAgIHVzZXJuYW1lOiBpLnVzZXIudXNlcm5hbWUsXG4gICAgICAgIGNsaWVudEZpZDogaS5jbGllbnQuY2xpZW50RmlkLFxuICAgICAgICBzaGFyZWRCeUZpZDogaWVcbiAgICAgIH0sIGAke2kudXNlci5maWR9YCk7XG4gICAgfVxuICAgIGlmICh2ID09PSBcIm5leW5hclwiICYmIE4pIHtcbiAgICAgIGNvbnN0IGllID0gYCR7Tn1fJHtpLnVzZXIuZmlkfV8ke0RhdGUubm93KCl9YDtcbiAgICAgIGlmIChNLmN1cnJlbnQuaGFzKGllKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgVGUgPSBILmN1cnJlbnQuZ2V0KGllKTtcbiAgICAgIFRlICYmIGNsZWFyVGltZW91dChUZSksIE0uY3VycmVudC5hZGQoaWUpO1xuICAgICAgY29uc3QgRGUgPSBzZXRUaW1lb3V0KGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB6ZSA9IGF3YWl0IGZldGNoKFwiaHR0cHM6Ly9hcGkubmV5bmFyLmNvbS92Mi9mYXJjYXN0ZXIvZnJhbWUvbm90aWZpY2F0aW9ucy9vcGVuXCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgIFwiY29udGVudC10eXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICBjYW1wYWlnbl9pZDogTixcbiAgICAgICAgICAgICAgZmlkOiBpLnVzZXIuZmlkLFxuICAgICAgICAgICAgICBhcHBfZmlkOiBpLmNsaWVudC5jbGllbnRGaWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgemUub2sgfHwgY29uc29sZS5lcnJvcihcIkZhaWxlZCB0byBtYXJrIG5vdGlmaWNhdGlvbiBhcyBvcGVuZWQ6IFwiLCBhd2FpdCB6ZS50ZXh0KCkpO1xuICAgICAgICB9IGNhdGNoICh6ZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBtYXJraW5nIG5vdGlmaWNhdGlvbiBhcyBvcGVuZWQ6IFwiLCB6ZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgTS5jdXJyZW50LmRlbGV0ZShpZSksIEguY3VycmVudC5kZWxldGUoaWUpO1xuICAgICAgICB9XG4gICAgICB9LCAxZTMpO1xuICAgICAgSC5jdXJyZW50LnNldChpZSwgRGUpO1xuICAgIH1cbiAgfSwgW2ksIEMsIFZdKSwge1xuICAgIC4uLmh0LFxuICAgIGlzU0RLTG9hZGVkOiByLFxuICAgIGNvbnRleHQ6IGksXG4gICAgYWRkZWQ6IGEsXG4gICAgbm90aWZpY2F0aW9uRGV0YWlsczogYyxcbiAgICBsYXN0RXZlbnQ6IGQsXG4gICAgY3VycmVudFRhYjogQSxcbiAgICBzZXRBY3RpdmVUYWI6IGssXG4gICAgc2V0SW5pdGlhbFRhYjogZyxcbiAgICBoYXB0aWNzOiB7XG4gICAgICBpbXBhY3RPY2N1cnJlZDogeCxcbiAgICAgIG5vdGlmaWNhdGlvbk9jY3VycmVkOiB3LFxuICAgICAgc2VsZWN0aW9uQ2hhbmdlZDogRFxuICAgIH0sXG4gICAgYWN0aW9uczoge1xuICAgICAgLi4uaHQuYWN0aW9ucyxcbiAgICAgIG9wZW5Vcmw6ICQsXG4gICAgICBjbG9zZTogVyxcbiAgICAgIGNvbXBvc2VDYXN0OiBPXG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc1Moe1xuICBjaGlsZHJlbjogc1xufSkge1xuICBjb25zdCBlID0gclMoKTtcbiAgcmV0dXJuIGUuaXNTREtMb2FkZWQgPyAvKiBAX19QVVJFX18gKi8gcS5qc3gobWcuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZSxcbiAgICBjaGlsZHJlbjogc1xuICB9KSA6IG51bGw7XG59XG5mdW5jdGlvbiBkUih7XG4gIGNoaWxkcmVuOiBzLFxuICBhbmFseXRpY3NFbmFibGVkOiBlID0gITEsXG4gIGJhY2tCdXR0b25FbmFibGVkOiB0ID0gITEsXG4gIHJldHVyblVybDogclxufSkge1xuICBjb25zdCBuID0gWnIoKCkgPT4gKHtcbiAgICBhbmFseXRpY3NFbmFibGVkOiBlLFxuICAgIGJhY2tCdXR0b25FbmFibGVkOiB0LFxuICAgIHJldHVyblVybDogclxuICB9KSwgW2UsIHQsIHJdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChwZy5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBuLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gcS5qc3goc1MsIHtcbiAgICAgIGNoaWxkcmVuOiBzXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBoUigpIHtcbiAgY29uc3QgcyA9IEFpKG1nKTtcbiAgaWYgKHMgPT09IHZvaWQgMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1c2VNaW5pQXBwIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBNaW5pQXBwUHJvdmlkZXJcIik7XG4gIHJldHVybiBzO1xufVxudmFyIHlnID0gLyogQF9fUFVSRV9fICovICgocykgPT4gKHMuTGlnaHQgPSBcImxpZ2h0XCIsIHMuRGFyayA9IFwiZGFya1wiLCBzKSkoeWcgfHwge30pLCBncyA9IC8qIEBfX1BVUkVfXyAqLyAoKHMpID0+IChzLkZBUkNBU1RFUiA9IFwiZmFyY2FzdGVyXCIsIHMuTkVZTkFSID0gXCJuZXluYXJcIiwgcy5XQVJQQ0FTVCA9IFwid2FycGNhc3RcIiwgcykpKGdzIHx8IHt9KTtcbmZ1bmN0aW9uIGR1KHMsIGUgPSBcIlwiLCB7XG4gIHNlcmlhbGl6ZTogdCA9IEpTT04uc3RyaW5naWZ5LFxuICBkZXNlcmlhbGl6ZTogciA9IEpTT04ucGFyc2Vcbn0gPSB7fSkge1xuICBjb25zdCBbbiwgaV0gPSBxZSgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPiBcInVcIilcbiAgICAgIHJldHVybiBlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBsID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKHMpO1xuICAgICAgcmV0dXJuIGwgPyByKGwpIDogZTtcbiAgICB9IGNhdGNoIChsKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkVycm9yIHJlYWRpbmcgZnJvbSBsb2NhbFN0b3JhZ2VcIiwgbCksIGU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIFtuLCAobCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjID0gbCBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gbChuKSA6IGw7XG4gICAgICBpKGMpLCB0eXBlb2Ygd2luZG93IDwgXCJ1XCIgJiYgd2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKHMsIHQoYykpO1xuICAgIH0gY2F0Y2ggKGMpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3cml0aW5nIHRvIGxvY2FsU3RvcmFnZVwiLCBjKTtcbiAgICB9XG4gIH0sICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHMpLCBpKGUpO1xuICAgIH0gY2F0Y2ggKGwpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciByZW1vdmluZyBmcm9tIGxvY2FsU3RvcmFnZVwiLCBsKTtcbiAgICB9XG4gIH1dO1xufVxudmFyIGpuID0gLyogQF9fUFVSRV9fICovICgocykgPT4gKHMuTkVZTkFSX0FVVEhFTlRJQ0FURURfVVNFUiA9IFwibmV5bmFyX2F1dGhlbnRpY2F0ZWRfdXNlclwiLCBzKSkoam4gfHwge30pO1xuY29uc3QgdmcgPSBhYSh2b2lkIDApLCBuUyA9ICh7XG4gIGNoaWxkcmVuOiBzLFxuICBfc2V0SXNBdXRoZW50aWNhdGVkOiBlLFxuICBfc2V0VXNlcjogdCxcbiAgX29uQXV0aFN1Y2Nlc3M6IHIsXG4gIF9vblNpZ25vdXQ6IG5cbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIGlzQXV0aGVudGljYXRlZDogaVxuICB9ID0gdHMoKSwgW28sIGFdID0gcWUoITEpLCBbbCwgY10gPSBxZShudWxsKSwgW3VdID0gZHUoam4uTkVZTkFSX0FVVEhFTlRJQ0FURURfVVNFUik7XG4gIGZ0KCgpID0+IHtcbiAgICBlKG8pO1xuICB9LCBbb10pLCBmdCgoKSA9PiB7XG4gICAgYShpKTtcbiAgfSwgW2ldKSwgZnQoKCkgPT4ge1xuICAgIHUgPyAoYyh1KSwgYSghMCkpIDogKGMobnVsbCksIGEoITEpKTtcbiAgfSwgW10pLCBmdCgoKSA9PiB7XG4gICAgdChsKTtcbiAgfSwgW2xdKTtcbiAgY29uc3QgZCA9IChwKSA9PiB7XG4gICAgciAmJiByKHApO1xuICB9LCBoID0gKHApID0+IHtcbiAgICBuICYmIG4ocCk7XG4gIH0sIGYgPSBacigoKSA9PiAoe1xuICAgIGlzQXV0aGVudGljYXRlZDogbyxcbiAgICB1c2VyOiBsLFxuICAgIHNldElzQXV0aGVudGljYXRlZDogYSxcbiAgICBzZXRVc2VyOiBjLFxuICAgIG9uQXV0aFN1Y2Nlc3M6IGQsXG4gICAgb25TaWdub3V0OiBoXG4gIH0pLCBbbywgbF0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIHEuanN4KHZnLlByb3ZpZGVyLCB7XG4gICAgdmFsdWU6IGYsXG4gICAgY2hpbGRyZW46IHNcbiAgfSk7XG59LCBFZyA9ICgpID0+IHtcbiAgY29uc3QgcyA9IEFpKHZnKTtcbiAgaWYgKCFzKVxuICAgIHRocm93IG5ldyBFcnJvcihcInVzZUF1dGggbXVzdCBiZSB1c2VkIHdpdGhpbiBhIEF1dGhDb250ZXh0UHJvdmlkZXJcIik7XG4gIHJldHVybiBzO1xufSwgaVMgPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJ0YmFvbTdjXCJdXG59KSwgb1MgPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJ0MWZmNDR6aVwiXSxcbiAgdmFyaWFudHM6IFt7XG4gICAgcHJvcHM6IHtcbiAgICAgIHR5cGU6IFwic3VjY2Vzc1wiXG4gICAgfSxcbiAgICBjbGFzc05hbWU6IFwidDFmZjQ0emktMVwiXG4gIH0sIHtcbiAgICBwcm9wczoge1xuICAgICAgdHlwZTogXCJlcnJvclwiXG4gICAgfSxcbiAgICBjbGFzc05hbWU6IFwidDFmZjQ0emktMlwiXG4gIH0sIHtcbiAgICBwcm9wczoge1xuICAgICAgdHlwZTogXCJ3YXJuaW5nXCJcbiAgICB9LFxuICAgIGNsYXNzTmFtZTogXCJ0MWZmNDR6aS0zXCJcbiAgfSwge1xuICAgIHByb3BzOiB7XG4gICAgICB0eXBlOiBcImluZm9cIlxuICAgIH0sXG4gICAgY2xhc3NOYW1lOiBcInQxZmY0NHppLTRcIlxuICB9XVxufSk7XG52YXIgeGcgPSAvKiBAX19QVVJFX18gKi8gKChzKSA9PiAocy5TdWNjZXNzID0gXCJzdWNjZXNzXCIsIHMuRXJyb3IgPSBcImVycm9yXCIsIHMuV2FybmluZyA9IFwid2FybmluZ1wiLCBzLkluZm8gPSBcImluZm9cIiwgcykpKHhnIHx8IHt9KTtcbmNvbnN0IFNnID0gYWEodm9pZCAwKSwgZlIgPSAoe1xuICBjaGlsZHJlbjogcyxcbiAgc2V0dGluZ3M6IHtcbiAgICBjbGllbnRJZDogZSxcbiAgICBkZWZhdWx0VGhlbWU6IHQgPSB5Zy5MaWdodCxcbiAgICBldmVudHNDYWxsYmFja3M6IHJcbiAgfVxufSkgPT4ge1xuICBjb25zdCBbbl0gPSBxZShlKSwgW2ksIG9dID0gcWUoITEpLCBbYSwgbF0gPSBxZSh0KSwgW2MsIHVdID0gcWUoW10pLCBbZCwgaF0gPSBxZShudWxsKSwgZiA9IChBLCBGKSA9PiB7XG4gICAgY29uc3QgTSA9IHtcbiAgICAgIHR5cGU6IEEsXG4gICAgICBtZXNzYWdlOiBGXG4gICAgfTtcbiAgICB1KChIKSA9PiBbLi4uSCwgTV0pLCBzZXRUaW1lb3V0KCgpID0+IHAoTSksIDVlMyk7XG4gIH0sIHAgPSAoQSkgPT4ge1xuICAgIHUoKEYpID0+IEYuZmlsdGVyKChNKSA9PiBNICE9PSBBKSk7XG4gIH07XG4gIGZ0KCgpID0+IHtcbiAgICBjb25zdCBBID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIjpyb290XCIpO1xuICAgIEEgJiYgKGEgPT09IFwibGlnaHRcIiA/IChBLmNsYXNzTGlzdC5hZGQoXCJ0aGVtZS1saWdodFwiKSwgQS5jbGFzc0xpc3QucmVtb3ZlKFwidGhlbWUtZGFya1wiKSkgOiBhID09PSBcImRhcmtcIiAmJiAoQS5jbGFzc0xpc3QuYWRkKFwidGhlbWUtZGFya1wiKSwgQS5jbGFzc0xpc3QucmVtb3ZlKFwidGhlbWUtbGlnaHRcIikpKTtcbiAgfSwgW2FdKTtcbiAgY29uc3QgeSA9IChBKSA9PiB7XG4gICAgbyhBKTtcbiAgfSwgRSA9IChBKSA9PiB7XG4gICAgaChBKTtcbiAgfSwgYiA9ICgpID0+IHtcbiAgICBpZiAoZCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaWduZXJfdXVpZDogQSxcbiAgICAgICAgLi4uRlxuICAgICAgfSA9IGQ7XG4gICAgICBoKG51bGwpLCBvKCExKSwgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oam4uTkVZTkFSX0FVVEhFTlRJQ0FURURfVVNFUiksIHIgIT0gbnVsbCAmJiByLm9uU2lnbm91dCAmJiByLm9uU2lnbm91dChGKTtcbiAgICB9XG4gIH0sIFIgPSBacigoKSA9PiAoe1xuICAgIGNsaWVudF9pZDogbixcbiAgICB0aGVtZTogYSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IGksXG4gICAgdXNlcjogZCxcbiAgICBzZXRUaGVtZTogbCxcbiAgICBzaG93VG9hc3Q6IGYsXG4gICAgbG9nb3V0VXNlcjogYlxuICB9KSwgW24sIGEsIGksIGQsIGwsIGYsIGJdKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChTZy5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBSLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gcS5qc3hzKG5TLCB7XG4gICAgICBfc2V0SXNBdXRoZW50aWNhdGVkOiB5LFxuICAgICAgX3NldFVzZXI6IEUsXG4gICAgICBfb25BdXRoU3VjY2VzczogciA9PSBudWxsID8gdm9pZCAwIDogci5vbkF1dGhTdWNjZXNzLFxuICAgICAgX29uU2lnbm91dDogciA9PSBudWxsID8gdm9pZCAwIDogci5vblNpZ25vdXQsXG4gICAgICBjaGlsZHJlbjogW3MsIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChpUywge1xuICAgICAgICBjaGlsZHJlbjogYy5tYXAoKEEsIEYpID0+IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChvUywge1xuICAgICAgICAgIHR5cGU6IEEudHlwZSxcbiAgICAgICAgICBjaGlsZHJlbjogQS5tZXNzYWdlXG4gICAgICAgIH0sIEYpKVxuICAgICAgfSldXG4gICAgfSlcbiAgfSk7XG59LCB0cyA9ICgpID0+IHtcbiAgY29uc3QgcyA9IEFpKFNnKTtcbiAgaWYgKCFzKVxuICAgIHRocm93IG5ldyBFcnJvcihcInVzZU5leW5hckNvbnRleHQgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIE5leW5hckNvbnRleHRQcm92aWRlclwiKTtcbiAgcmV0dXJuIHM7XG59LCBhUyA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoXCJzdmdcIiwge1xuICB3aWR0aDogXCIxOFwiLFxuICBoZWlnaHQ6IFwiMTdcIixcbiAgdmlld0JveDogXCIwIDAgMTggMTdcIixcbiAgZmlsbDogXCJub25lXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIHEuanN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTMuNzIyMiAwSDQuMjc3NzhDMi4xOTEzNyAwIDAuNSAxLjY5MTM3IDAuNSAzLjc3Nzc4VjEzLjIyMjJDMC41IDE1LjMwODYgMi4xOTEzNyAxNyA0LjI3Nzc4IDE3SDEzLjcyMjJDMTUuODA4NiAxNyAxNy41IDE1LjMwODYgMTcuNSAxMy4yMjIyVjMuNzc3NzhDMTcuNSAxLjY5MTM3IDE1LjgwODYgMCAxMy43MjIyIDBaXCIsXG4gICAgZmlsbDogXCIjODU1RENEXCJcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTQuODgyODEgMi42NDQ1M0gxMy4xMTg0VjE0LjM1NTZIMTEuOTA5NVY4Ljk5MTJIMTEuODk3NkMxMS43NjQgNy41MDg1OSAxMC41MTggNi4zNDY3NSA5LjAwMDU5IDYuMzQ2NzVDNy40ODMyIDYuMzQ2NzUgNi4yMzcxNyA3LjUwODU5IDYuMTAzNTYgOC45OTEySDYuMDkxN1YxNC4zNTU2SDQuODgyODFWMi42NDQ1M1pcIixcbiAgICBmaWxsOiBcIndoaXRlXCJcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChcInBhdGhcIiwge1xuICAgIGQ6IFwiTTIuNjkxNDEgNC4zMDY2NEwzLjE4MjUyIDUuOTY4ODZIMy41OTgwN1YxMi42OTMzQzMuMzg5NDMgMTIuNjkzMyAzLjIyMDMgMTIuODYyNSAzLjIyMDMgMTMuMDcxMVYxMy41MjQ0SDMuMTQ0NzRDMi45MzYxIDEzLjUyNDQgMi43NjY5NiAxMy42OTM2IDIuNzY2OTYgMTMuOTAyMlYxNC4zNTU1SDYuOTk4MDdWMTMuOTAyMkM2Ljk5ODA3IDEzLjY5MzYgNi44Mjg5MyAxMy41MjQ0IDYuNjIwMyAxMy41MjQ0SDYuNTQ0NzRWMTMuMDcxMUM2LjU0NDc0IDEyLjg2MjUgNi4zNzU2IDEyLjY5MzMgNi4xNjY5NiAxMi42OTMzSDUuNzEzNjNWNC4zMDY2NEgyLjY5MTQxWlwiLFxuICAgIGZpbGw6IFwid2hpdGVcIlxuICB9KSwgLyogQF9fUFVSRV9fICovIHEuanN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTEuOTg1NCAxMi42OTMzQzExLjc3NjggMTIuNjkzMyAxMS42MDc2IDEyLjg2MjUgMTEuNjA3NiAxMy4wNzExVjEzLjUyNDRIMTEuNTMyMUMxMS4zMjM1IDEzLjUyNDQgMTEuMTU0MyAxMy42OTM2IDExLjE1NDMgMTMuOTAyMlYxNC4zNTU1SDE1LjM4NTRWMTMuOTAyMkMxNS4zODU0IDEzLjY5MzYgMTUuMjE2MiAxMy41MjQ0IDE1LjAwNzYgMTMuNTI0NEgxNC45MzIxVjEzLjA3MTFDMTQuOTMyMSAxMi44NjI1IDE0Ljc2MjkgMTIuNjkzMyAxNC41NTQzIDEyLjY5MzNWNS45Njg4NkgxNC45Njk5TDE1LjQ2MSA0LjMwNjY0SDEyLjQzODdWMTIuNjkzM0gxMS45ODU0WlwiLFxuICAgIGZpbGw6IFwid2hpdGVcIlxuICB9KV1cbn0pLCB6ZCA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoXCJzdmdcIiwge1xuICB3aWR0aDogXCIzMlwiLFxuICBoZWlnaHQ6IFwiMTdcIixcbiAgdmlld0JveDogXCIwIDAgNTAgMjhcIixcbiAgZmlsbDogXCJub25lXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIHEuanN4KFwicGF0aFwiLCB7XG4gICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGNsaXBSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBkOiBcIk0zOC4zNzQ0IDEzLjczMTFDMzguMzc0NCAxNi4xMjA5IDM3Ljc2MzkgMTguMzY4IDM2LjY5MDQgMjAuMzI1MkMzMi41Njg1IDE5Ljg1MjUgMjcuODQ3IDE4Ljk1MDMgMjIuODk5OSAxNy42MjQ3QzIwLjQwNTggMTYuOTU2NCAxOC4wMTUxIDE2LjIyMzYgMTUuNzY5NyAxNS40NDk1TDE1Ljc2OTMgMTUuNDQ4NkMxNS43NTc5IDE1LjQ0NSAxNS43NDY1IDE1LjQ0MTMgMTUuNzM1MSAxNS40Mzc2QzE1LjY0NDggMTUuNDA2NCAxNS41NTQ3IDE1LjM3NTIgMTUuNDY0OSAxNS4zNDM5QzEyLjg5NzggMTQuMzk5IDExLjIzNTYgMTIuMjA1NiAxMS40MTY4IDEwLjAzMTVMMTEuNDQ4MiAxMC4wMzk5TDExLjQyMTUgMTAuMDEzM0MxMy4wNDI3IDQuMjM2MTIgMTguMzQ4MyAwIDI0LjY0MzQgMEMzMi4yMjY4IDAgMzguMzc0NCA2LjE0NzYyIDM4LjM3NDQgMTMuNzMxMVpcIixcbiAgICBmaWxsOiBcImJsYWNrXCJcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChcInBhdGhcIiwge1xuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCIsXG4gICAgZDogXCJNMTEuMzgwNCAxNy4yOTg3QzEyLjQ4ODIgMTYuNTMxMyAxMy45NjU4IDE2LjE4MDQgMTUuNTAwMiAxNi4zOTUzQzE3Ljc3MzEgMTcuMTU2IDIwLjE2ODIgMTcuODc4MiAyMi42NTM1IDE4LjU0NDFDMjcuMzk3IDE5LjgxNTEgMzEuOTU4NCAyMC43NDQ0IDM2LjA4MzMgMjEuMzI3NUMzMy42MjMgMjUuMDI1MiAyOS40MTc3IDI3LjQ2MTkgMjQuNjQzNCAyNy40NjE5QzE4LjI5NCAyNy40NjE5IDEyLjk1MTEgMjMuMTUyNCAxMS4zODA0IDE3LjI5ODdaXCIsXG4gICAgZmlsbDogXCJibGFja1wiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gcS5qc3goXCJwYXRoXCIsIHtcbiAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTQzLjA5MTcgMTMuNDQ1OEM0MS42NDYxIDEyLjY2NDggMzkuOTc1NiAxMS44NzU5IDM4LjEyMzMgMTEuMTAyOUMzOC4wMzYzIDEwLjY1NDQgMzcuOTI3NSAxMC4yMTM2IDM3Ljc5ODEgOS43ODE3NEMzOS45ODA2IDEwLjY2NDggNDEuOTQwMyAxMS41NzUyIDQzLjYxMzkgMTIuNDc5NEM0NS43MDA3IDEzLjYwNjkgNDcuMzcwMyAxNC43Mzk0IDQ4LjQ3MTQgMTUuODE2QzQ5LjUzNTYgMTYuODU2NiA1MC4yMjk1IDE4LjAwNjMgNDkuOTMgMTkuMTI0MUM0OS42MzA0IDIwLjI0MTkgNDguNDU0NyAyMC44OTA2IDQ3LjAxMjggMjEuMjU5N0M0NS41MjA5IDIxLjY0MTUgNDMuNTA4NyAyMS43ODc1IDQxLjEzNzcgMjEuNzIwNkMzOS42MDQ2IDIxLjY3NzMgMzcuOTA4MiAyMS41NDQ0IDM2LjA4NjQgMjEuMzIzNEMzNi4zMDg2IDIwLjk4OTEgMzYuNTE2NSAyMC42NDQ2IDM2LjcwOTQgMjAuMjkwNkMzOC4zMTM0IDIwLjQ3MzMgMzkuODA5MSAyMC41ODQxIDQxLjE2ODcgMjAuNjIyNUM0My40OTQ2IDIwLjY4ODIgNDUuMzkwOCAyMC41NDA5IDQ2Ljc0MDQgMjAuMTk1NUM0OC4xNCAxOS44MzczIDQ4LjczODkgMTkuMzI0OSA0OC44Njg5IDE4LjgzOThDNDguOTk4OSAxOC4zNTQ3IDQ4LjczNjQgMTcuNjExNSA0Ny43MDM0IDE2LjYwMTVDNDYuNzA3MyAxNS42Mjc1IDQ1LjEzODggMTQuNTUxOSA0My4wOTE3IDEzLjQ0NThaTTguODYyMjkgMy4xNjc3MkMxMC43NTgzIDMuMjIxMjggMTIuOTAzOCAzLjQxMTc3IDE1LjIyNzggMy43MzY2MUMxNC44OTc0IDQuMDQ4MDMgMTQuNTgyNCA0LjM3NTY2IDE0LjI4NDEgNC43MTgyMkMxMi4zMDE2IDQuNDYzMTQgMTAuNDY3OCA0LjMxMiA4LjgzMTI3IDQuMjY1NzdDNi41MDU0MSA0LjIwMDA2IDQuNjA5MiA0LjM0NzM3IDMuMjU5NTggNC42OTI3OUMxLjg2MDAxIDUuMDUwOTkgMS4yNjEwNyA1LjU2MzQyIDEuMTMxMDkgNi4wNDg0OUMxLjAwMTEyIDYuNTMzNTYgMS4yNjM2IDcuMjc2ODEgMi4yOTY1NyA4LjI4NjhDMy4yOTI2NyA5LjI2MDc1IDQuODYxMTggMTAuMzM2NCA2LjkwODI4IDExLjQ0MjVDNi45NDE4MSAxMS40NjA2IDYuOTc1NDYgMTEuNDc4NyA3LjAwOTIzIDExLjQ5NjhDNi44NDI1MSAxMS41OTM4IDYuNzI1NzQgMTEuNzE2MSA2LjY2MzUzIDExLjg2NDVDNi41Nzc5MSAxMi4wNjg4IDYuNjAwMTMgMTIuMzEyMSA2LjcyMDEzIDEyLjU4NzRDNi42MDc1NyAxMi41Mjc5IDYuNDk2MjMgMTIuNDY4NCA2LjM4NjEyIDEyLjQwODlDNC4yOTkyNiAxMS4yODE0IDIuNjI5NzEgMTAuMTQ4OSAxLjUyODYgOS4wNzIyM0MwLjQ2NDM2NyA4LjAzMTY2IC0wLjIyOTQ4NSA2Ljg4MiAwLjA3MDAzNTQgNS43NjQxOEMwLjM2OTU1NiA0LjY0NjM1IDEuNTQ1MjggMy45OTc2NCAyLjk4NzIyIDMuNjI4NkM0LjQ3OTExIDMuMjQ2NzcgNi40OTEyNiAzLjEwMDc0IDguODYyMjkgMy4xNjc3MlpcIixcbiAgICBmaWxsOiBcImJsYWNrXCJcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChcImVsbGlwc2VcIiwge1xuICAgIGN4OiBcIjUuOTQ4NjZcIixcbiAgICBjeTogXCIxMS41MzA5XCIsXG4gICAgcng6IFwiMy43NjAwOVwiLFxuICAgIHJ5OiBcIjAuNTc1ODMyXCIsXG4gICAgdHJhbnNmb3JtOiBcInJvdGF0ZSgyOS4yODI0IDUuOTQ4NjYgMTEuNTMwOSlcIixcbiAgICBmaWxsOiBcImJsYWNrXCJcbiAgfSldXG59KSwgbFMgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gcS5qc3hzKFwic3ZnXCIsIHtcbiAgd2lkdGg6IFwiMTdcIixcbiAgaGVpZ2h0OiBcIjE3XCIsXG4gIHZpZXdCb3g6IFwiMCAwIDE3IDE3XCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBxLmpzeChcIm1hc2tcIiwge1xuICAgIGlkOiBcIm1hc2swXzg3NV80OFwiLFxuICAgIG1hc2tVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiLFxuICAgIHg6IFwiMFwiLFxuICAgIHk6IFwiMFwiLFxuICAgIHdpZHRoOiBcIjE3XCIsXG4gICAgaGVpZ2h0OiBcIjE3XCIsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNMTYuOTk0NyAwSDBWMTYuOTk0N0gxNi45OTQ3VjBaXCIsXG4gICAgICBmaWxsOiBcIndoaXRlXCJcbiAgICB9KVxuICB9KSwgLyogQF9fUFVSRV9fICovIHEuanN4cyhcImdcIiwge1xuICAgIG1hc2s6IFwidXJsKCNtYXNrMF84NzVfNDgpXCIsXG4gICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTEyLjc4NzEgMTYuOTk0N0g0LjIwNzY1QzEuODg3NTUgMTYuOTk0NyAwIDE1LjEwNzMgMCAxMi43ODcxVjQuMjA3NzFDMCAxLjg4NzU2IDEuODg3NTUgMCA0LjIwNzY1IDBIMTIuNzg3MUMxNS4xMDcyIDAgMTYuOTk0NyAxLjg4NzU2IDE2Ljk5NDcgNC4yMDc3MVYxMi43ODcxQzE2Ljk5NDcgMTUuMTA3MyAxNS4xMDcyIDE2Ljk5NDcgMTIuNzg3MSAxNi45OTQ3WlwiLFxuICAgICAgZmlsbDogXCIjNDcyQTkxXCJcbiAgICB9KSwgLyogQF9fUFVSRV9fICovIHEuanN4KFwicGF0aFwiLCB7XG4gICAgICBkOiBcIk0xMS4xNTIzIDUuMzc4OTFMMTAuMzE0MyA4LjUyNjAxTDkuNDczNjQgNS4zNzg5MUg3LjUzODkzTDYuNjkwMTcgOC41NDkxOUw1Ljg0NDE5IDUuMzc4OTFIMy42NDA2Mkw1LjY4ODIzIDEyLjMzNzFINy41ODkzMUw4LjQ5ODM1IDkuMTA1OTlMOS40MDczNiAxMi4zMzcxSDExLjMxMjVMMTMuMzU1NyA1LjM3ODkxSDExLjE1MjNaXCIsXG4gICAgICBmaWxsOiBcIndoaXRlXCJcbiAgICB9KV1cbiAgfSldXG59KTtcbnZhciBjUyA9IHt9O1xuY29uc3QgaWMgPSAvKiBAX19QVVJFX18gKi8gZGUoXCJpbWdcIikoe1xuICBjbGFzc2VzOiBbXCJpcHBmc3FyXCJdXG59KSwgdVMgPSAvKiBAX19QVVJFX18gKi8gZGUoXCJidXR0b25cIikoe1xuICBjbGFzc2VzOiBbXCJiMXl6c3NqYlwiXVxufSksIGRTID0gLyogQF9fUFVSRV9fICovIGRlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wibTF4bjhiMmVcIl1cbn0pLCBoUyA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImJ1dHRvblwiKSh7XG4gIGNsYXNzZXM6IFtcIm13dWlxeWdcIl1cbn0pLCBmUyA9IChzLCBlKSA9PiB7XG4gIGlmIChlKVxuICAgIHJldHVybiBlO1xuICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlIGdzLkZBUkNBU1RFUjpcbiAgICAgIHJldHVybiBcIlNpZ24gaW4gd2l0aCBGYXJjYXN0ZXJcIjtcbiAgICBjYXNlIGdzLk5FWU5BUjpcbiAgICAgIHJldHVybiBcIlNpZ24gaW4gd2l0aCBOZXluYXJcIjtcbiAgICBjYXNlIGdzLldBUlBDQVNUOlxuICAgICAgcmV0dXJuIFwiU2lnbiBpbiB3aXRoIFdhcnBjYXN0XCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBcIlNpZ24gaW4gd2l0aCBOZXluYXJcIjtcbiAgfVxufSwgZ1MgPSAocywgZSwgdCkgPT4ge1xuICBpZiAoZSlcbiAgICByZXR1cm4gZTtcbiAgaWYgKHQpXG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChpYywge1xuICAgICAgc3JjOiB0LFxuICAgICAgYWx0OiBcIkN1c3RvbSBsb2dvXCJcbiAgICB9KTtcbiAgc3dpdGNoIChzKSB7XG4gICAgY2FzZSBncy5GQVJDQVNURVI6XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIHEuanN4KGFTLCB7fSk7XG4gICAgY2FzZSBncy5ORVlOQVI6XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIHEuanN4KHpkLCB7fSk7XG4gICAgY2FzZSBncy5XQVJQQ0FTVDpcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gcS5qc3gobFMsIHt9KTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBxLmpzeCh6ZCwge30pO1xuICB9XG59LCBwUyA9ICh7XG4gIGNoaWxkcmVuOiBzLFxuICBsYWJlbDogZSxcbiAgdmFyaWFudDogdCA9IGdzLk5FWU5BUixcbiAgaWNvbjogcixcbiAgY3VzdG9tTG9nb1VybDogbixcbiAgbW9kYWxTdHlsZTogaSA9IHt9LFxuICBtb2RhbEJ1dHRvblN0eWxlOiBvID0ge30sXG4gIC4uLmFcbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIGNsaWVudF9pZDogbCxcbiAgICB1c2VyOiBjLFxuICAgIGlzQXV0aGVudGljYXRlZDogdVxuICB9ID0gdHMoKSwge1xuICAgIHNldElzQXV0aGVudGljYXRlZDogZCxcbiAgICBzZXRVc2VyOiBoLFxuICAgIG9uQXV0aFN1Y2Nlc3M6IGYsXG4gICAgb25TaWdub3V0OiBwXG4gIH0gPSBFZygpLCBbeSwgRSwgYl0gPSBkdShqbi5ORVlOQVJfQVVUSEVOVElDQVRFRF9VU0VSKSwgW1IsIEFdID0gcWUoITEpLCBGID0gYnQobnVsbCksIE0gPSBgJHtjUy5ORVlOQVJfTE9HSU5fVVJMID8/IFwiaHR0cHM6Ly9hcHAubmV5bmFyLmNvbS9sb2dpblwifT9jbGllbnRfaWQ9JHtsfWAsIEggPSBuZXcgVVJMKE0pLm9yaWdpbiwgSyA9IGJ0KG51bGwpLCBqID0gdXQoYXN5bmMgKGcpID0+IHtcbiAgICB2YXIgeDtcbiAgICBpZiAoZy5vcmlnaW4gPT09IEggJiYgZy5kYXRhICYmIGcuZGF0YS5pc19hdXRoZW50aWNhdGVkKSB7XG4gICAgICBkKCEwKSwgKHggPSBGLmN1cnJlbnQpID09IG51bGwgfHwgeC5jbG9zZSgpLCB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaik7XG4gICAgICBjb25zdCB3ID0ge1xuICAgICAgICBzaWduZXJfdXVpZDogZy5kYXRhLnNpZ25lcl91dWlkLFxuICAgICAgICAuLi5nLmRhdGEudXNlclxuICAgICAgfTtcbiAgICAgIEUodyksIGgodyksIGYoe1xuICAgICAgICB1c2VyOiB3XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFtsLCBkXSksIEMgPSB1dCgoKSA9PiB7XG4gICAgY29uc3QgdyA9IHdpbmRvdy5zY3JlZW4ud2lkdGggLyAyIC0gMzAwLCBPID0gYHdpZHRoPTYwMCxoZWlnaHQ9NzAwLHRvcD0ke3dpbmRvdy5zY3JlZW4uaGVpZ2h0IC8gMiAtIDcwMCAvIDJ9LGxlZnQ9JHt3fWA7XG4gICAgaWYgKEYuY3VycmVudCA9IHdpbmRvdy5vcGVuKE0sIFwiX2JsYW5rXCIsIE8pLCAhRi5jdXJyZW50KSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIG9wZW4gdGhlIGF1dGhlbnRpY2F0aW9uIHdpbmRvdy4gUGxlYXNlIGNoZWNrIHlvdXIgcG9wLXVwIGJsb2NrZXIgc2V0dGluZ3MuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaiwgITEpO1xuICB9LCBbbCwgal0pLCBrID0gKCkgPT4ge1xuICAgIGlmIChjKSB7XG4gICAgICBjb25zdCBnID0gYztcbiAgICAgIGIoKSwgZCghMSksIFcoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2lnbmVyX3V1aWQ6IHgsXG4gICAgICAgIC4uLndcbiAgICAgIH0gPSBnO1xuICAgICAgcCh3KTtcbiAgICB9XG4gIH0sICQgPSAoKSA9PiBBKCEwKSwgVyA9ICgpID0+IEEoITEpO1xuICBmdCgoKSA9PiAoKSA9PiB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGopO1xuICB9LCBbal0pO1xuICBjb25zdCBfID0gdXQoKGcpID0+IHtcbiAgICBLLmN1cnJlbnQgJiYgIUsuY3VycmVudC5jb250YWlucyhnLnRhcmdldCkgJiYgVygpO1xuICB9LCBbXSk7XG4gIHJldHVybiBmdCgoKSA9PiAoUiA/IGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgXykgOiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIF8pLCAoKSA9PiB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBfKTtcbiAgfSksIFtSLCBfXSksIC8qIEBfX1BVUkVfXyAqLyBxLmpzeHMocS5GcmFnbWVudCwge1xuICAgIGNoaWxkcmVuOiBbUiAmJiAvKiBAX19QVVJFX18gKi8gcS5qc3hzKGRTLCB7XG4gICAgICBzdHlsZTogaSxcbiAgICAgIHJlZjogSyxcbiAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIHEuanN4KGljLCB7XG4gICAgICAgIHNyYzogYyA9PSBudWxsID8gdm9pZCAwIDogYy5wZnBfdXJsLFxuICAgICAgICBhbHQ6IGMgPT0gbnVsbCA/IHZvaWQgMCA6IGMudXNlcm5hbWVcbiAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gcS5qc3hzKFwic3BhblwiLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbXCJAXCIsIGMgPT0gbnVsbCA/IHZvaWQgMCA6IGMudXNlcm5hbWVdXG4gICAgICB9KSwgLyogQF9fUFVSRV9fICovIHEuanN4KGhTLCB7XG4gICAgICAgIHN0eWxlOiBvLFxuICAgICAgICBvbkNsaWNrOiBrLFxuICAgICAgICBjaGlsZHJlbjogXCJTaWduIG91dFwiXG4gICAgICB9KV1cbiAgICB9KSwgLyogQF9fUFVSRV9fICovIHEuanN4KHVTLCB7XG4gICAgICBvbkNsaWNrOiB1ID8gJCA6IEMsXG4gICAgICAuLi5hLFxuICAgICAgY2hpbGRyZW46IHUgPyAvKiBAX19QVVJFX18gKi8gcS5qc3hzKHEuRnJhZ21lbnQsIHtcbiAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3goaWMsIHtcbiAgICAgICAgICBzcmM6IGMgPT0gbnVsbCA/IHZvaWQgMCA6IGMucGZwX3VybCxcbiAgICAgICAgICBhbHQ6IGAke2MgPT0gbnVsbCA/IHZvaWQgMCA6IGMudXNlcm5hbWV9IHByb2ZpbGUgcGljdHVyZWBcbiAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoXCJzcGFuXCIsIHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgbWFyZ2luTGVmdDogXCIxMHB4XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoaWxkcmVuOiBbXCJAXCIsIGMgPT0gbnVsbCA/IHZvaWQgMCA6IGMudXNlcm5hbWVdXG4gICAgICAgIH0pXVxuICAgICAgfSkgOiAvKiBAX19QVVJFX18gKi8gcS5qc3hzKHEuRnJhZ21lbnQsIHtcbiAgICAgICAgY2hpbGRyZW46IFtnUyh0LCByLCBuKSwgLyogQF9fUFVSRV9fICovIHEuanN4KFwic3BhblwiLCB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IFwiNXB4XCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoaWxkcmVuOiBmUyh0LCBlKVxuICAgICAgICB9KV1cbiAgICAgIH0pXG4gICAgfSldXG4gIH0pO1xufSwgWW8gPSAvKiBAX19QVVJFX18gKi8gZGUoXCJpbWdcIikoe1xuICBjbGFzc2VzOiBbXCJhMTFwdDB4cFwiXSxcbiAgdmFyczoge1xuICAgIFwiYTExcHQweHAtMFwiOiBbKHMsIGUgPSBHcikgPT4gcy53aWR0aCB8fCBcIjQ1cHhcIiwgITFdLFxuICAgIFwiYTExcHQweHAtMVwiOiBbKHMsIGUgPSBHcikgPT4gcy53aWR0aCB8fCBcIjQ1cHhcIiwgITFdXG4gIH1cbn0pLCBZZCA9IFwiaHR0cHM6Ly9mYXJjYXN0ZXIueHl6XCIsIGJnID0gLyhefFxccylcXC9cXHcrL2csIFRnID0gL0BcXHcrKFxcLmV0aCk/L2csIHdnID0gLygoaHR0cHM/OlxcL1xcLyk/KFthLXpBLVowLTkuLV0rXFwuW2EtekEtWl17Mix9KShcXC9bXlxcc10qKT8pL2csIFpkID0gbmV3IFJlZ0V4cChgKCR7Ymcuc291cmNlfSl8KCR7VGcuc291cmNlfSl8KCR7d2cuc291cmNlfSlgLCBcImdcIiksIG1TID0gKHMpID0+IGJnLnRlc3QocykgPyBgJHtZZH0vfi9jaGFubmVsJHtzLnRyaW0oKX1gIDogVGcudGVzdChzKSA/IGAke1lkfS8ke3Muc3Vic3RyaW5nKDEpfWAgOiB3Zy50ZXN0KHMpID8gcy5zdGFydHNXaXRoKFwiaHR0cFwiKSA/IHMgOiBgaHR0cDovLyR7c31gIDogXCJcIiwgeVMgPSAvKiBAX19QVVJFX18gKi8gZGUoXCJhXCIpKHtcbiAgY2xhc3NlczogW1wiczR4eW1xc1wiXVxufSksIHZTID0gKHMpID0+IHMuZmlsdGVyKChlKSA9PiBlLnVybCkubWFwKChlKSA9PiBlLnVybCksIEVTID0gKHMsIGUpID0+IHtcbiAgaWYgKCFzKSByZXR1cm4gW107XG4gIGNvbnN0IHQgPSB2UyhlKSwgciA9IFtdO1xuICBsZXQgbiA9IDAsIGk7XG4gIGZvciAoOyAoaSA9IFpkLmV4ZWMocykpICE9PSBudWxsOyApIHtcbiAgICBjb25zdCBvID0gaS5pbmRleDtcbiAgICBuIDwgbyAmJiByLnB1c2gocy5zbGljZShuLCBvKSk7XG4gICAgY29uc3QgYSA9IGlbMF0udHJpbSgpO1xuICAgIGlmICh0LmluY2x1ZGVzKGEpKVxuICAgICAgci5wdXNoKGEpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbCA9IG1TKGEpO1xuICAgICAgci5wdXNoKC8qIEBfX1BVUkVfXyAqLyBxLmpzeCh5Uywge1xuICAgICAgICBocmVmOiBsLFxuICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgIGNoaWxkcmVuOiBhXG4gICAgICB9LCBvKSk7XG4gICAgfVxuICAgIG4gPSBaZC5sYXN0SW5kZXg7XG4gIH1cbiAgcmV0dXJuIG4gPCBzLmxlbmd0aCAmJiByLnB1c2gocy5zbGljZShuKSksIHI7XG59LCBJciA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcImJlODdtMG1cIl0sXG4gIHZhcnM6IHtcbiAgICBcImJlODdtMG0tMFwiOiBbKHMsIGUgPSBHcikgPT4gcy5hbGlnbkl0ZW1zIHx8IFwiZmxleC1zdGFydFwiLCAhMV0sXG4gICAgXCJiZTg3bTBtLTFcIjogWyhzLCBlID0gR3IpID0+IHMuanVzdGlmeUNvbnRlbnQgfHwgXCJmbGV4LXN0YXJ0XCIsICExXSxcbiAgICBcImJlODdtMG0tMlwiOiBbKHMsIGUgPSBHcikgPT4gcy5mbGV4R3JvdyB8fCBcImluaXRpYWxcIiwgITBdLFxuICAgIFwiYmU4N20wbS0zXCI6IFsocywgZSA9IEdyKSA9PiBzLmZsZXhTaHJpbmsgfHwgXCJpbml0aWFsXCIsICEwXSxcbiAgICBcImJlODdtMG0tNFwiOiBbKHMsIGUgPSBHcikgPT4gcy5zcGFjaW5nID8/IHMuc3BhY2luZ1ZlcnRpY2FsID8/IHMuc3BhY2luZ1RvcCA/PyBcIjBweFwiLCAhMV0sXG4gICAgXCJiZTg3bTBtLTVcIjogWyhzLCBlID0gR3IpID0+IHMuc3BhY2luZyA/PyBzLnNwYWNpbmdIb3Jpem9udGFsID8/IHMuc3BhY2luZ1JpZ2h0ID8/IFwiMHB4XCIsICExXSxcbiAgICBcImJlODdtMG0tNlwiOiBbKHMsIGUgPSBHcikgPT4gcy5zcGFjaW5nID8/IHMuc3BhY2luZ1ZlcnRpY2FsID8/IHMuc3BhY2luZ0JvdHRvbSA/PyBcIjBweFwiLCAhMV0sXG4gICAgXCJiZTg3bTBtLTdcIjogWyhzLCBlID0gR3IpID0+IHMuc3BhY2luZyA/PyBzLnNwYWNpbmdIb3Jpem9udGFsID8/IHMuc3BhY2luZ0xlZnQgPz8gXCIwcHhcIiwgITFdXG4gIH1cbn0pLCB4UyA9ICgpID0+IElyLCBQciA9IC8qIEBfX1BVUkVfXyAqLyBkZSh4UygpKSh7XG4gIGNsYXNzZXM6IFtcImhhMWR2cGlcIl1cbn0pLCB1ZSA9IE51bWJlci5pc0Zpbml0ZSB8fCBmdW5jdGlvbihzKSB7XG4gIHJldHVybiB0eXBlb2YgcyA9PSBcIm51bWJlclwiICYmIGlzRmluaXRlKHMpO1xufSwgU1MgPSBOdW1iZXIuaXNTYWZlSW50ZWdlciB8fCBmdW5jdGlvbihzKSB7XG4gIHJldHVybiB0eXBlb2YgcyA9PSBcIm51bWJlclwiICYmIE1hdGguYWJzKHMpIDw9IGJTO1xufSwgYlMgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiB8fCA5MDA3MTk5MjU0NzQwOTkxO1xubGV0IHZlID0gLyogQF9fUFVSRV9fICovIChmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzLk5FVFdPUktfRVJST1IgPSBcIm5ldHdvcmtFcnJvclwiLCBzLk1FRElBX0VSUk9SID0gXCJtZWRpYUVycm9yXCIsIHMuS0VZX1NZU1RFTV9FUlJPUiA9IFwia2V5U3lzdGVtRXJyb3JcIiwgcy5NVVhfRVJST1IgPSBcIm11eEVycm9yXCIsIHMuT1RIRVJfRVJST1IgPSBcIm90aGVyRXJyb3JcIiwgcztcbn0pKHt9KSwgSiA9IC8qIEBfX1BVUkVfXyAqLyAoZnVuY3Rpb24ocykge1xuICByZXR1cm4gcy5LRVlfU1lTVEVNX05PX0tFWVMgPSBcImtleVN5c3RlbU5vS2V5c1wiLCBzLktFWV9TWVNURU1fTk9fQUNDRVNTID0gXCJrZXlTeXN0ZW1Ob0FjY2Vzc1wiLCBzLktFWV9TWVNURU1fTk9fU0VTU0lPTiA9IFwia2V5U3lzdGVtTm9TZXNzaW9uXCIsIHMuS0VZX1NZU1RFTV9OT19DT05GSUdVUkVEX0xJQ0VOU0UgPSBcImtleVN5c3RlbU5vQ29uZmlndXJlZExpY2Vuc2VcIiwgcy5LRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQgPSBcImtleVN5c3RlbUxpY2Vuc2VSZXF1ZXN0RmFpbGVkXCIsIHMuS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfUkVRVUVTVF9GQUlMRUQgPSBcImtleVN5c3RlbVNlcnZlckNlcnRpZmljYXRlUmVxdWVzdEZhaWxlZFwiLCBzLktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1VQREFURV9GQUlMRUQgPSBcImtleVN5c3RlbVNlcnZlckNlcnRpZmljYXRlVXBkYXRlRmFpbGVkXCIsIHMuS0VZX1NZU1RFTV9TRVNTSU9OX1VQREFURV9GQUlMRUQgPSBcImtleVN5c3RlbVNlc3Npb25VcGRhdGVGYWlsZWRcIiwgcy5LRVlfU1lTVEVNX1NUQVRVU19PVVRQVVRfUkVTVFJJQ1RFRCA9IFwia2V5U3lzdGVtU3RhdHVzT3V0cHV0UmVzdHJpY3RlZFwiLCBzLktFWV9TWVNURU1fU1RBVFVTX0lOVEVSTkFMX0VSUk9SID0gXCJrZXlTeXN0ZW1TdGF0dXNJbnRlcm5hbEVycm9yXCIsIHMuS0VZX1NZU1RFTV9ERVNUUk9ZX01FRElBX0tFWVNfRVJST1IgPSBcImtleVN5c3RlbURlc3Ryb3lNZWRpYUtleXNFcnJvclwiLCBzLktFWV9TWVNURU1fREVTVFJPWV9DTE9TRV9TRVNTSU9OX0VSUk9SID0gXCJrZXlTeXN0ZW1EZXN0cm95Q2xvc2VTZXNzaW9uRXJyb3JcIiwgcy5LRVlfU1lTVEVNX0RFU1RST1lfUkVNT1ZFX1NFU1NJT05fRVJST1IgPSBcImtleVN5c3RlbURlc3Ryb3lSZW1vdmVTZXNzaW9uRXJyb3JcIiwgcy5NQU5JRkVTVF9MT0FEX0VSUk9SID0gXCJtYW5pZmVzdExvYWRFcnJvclwiLCBzLk1BTklGRVNUX0xPQURfVElNRU9VVCA9IFwibWFuaWZlc3RMb2FkVGltZU91dFwiLCBzLk1BTklGRVNUX1BBUlNJTkdfRVJST1IgPSBcIm1hbmlmZXN0UGFyc2luZ0Vycm9yXCIsIHMuTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUiA9IFwibWFuaWZlc3RJbmNvbXBhdGlibGVDb2RlY3NFcnJvclwiLCBzLkxFVkVMX0VNUFRZX0VSUk9SID0gXCJsZXZlbEVtcHR5RXJyb3JcIiwgcy5MRVZFTF9MT0FEX0VSUk9SID0gXCJsZXZlbExvYWRFcnJvclwiLCBzLkxFVkVMX0xPQURfVElNRU9VVCA9IFwibGV2ZWxMb2FkVGltZU91dFwiLCBzLkxFVkVMX1BBUlNJTkdfRVJST1IgPSBcImxldmVsUGFyc2luZ0Vycm9yXCIsIHMuTEVWRUxfU1dJVENIX0VSUk9SID0gXCJsZXZlbFN3aXRjaEVycm9yXCIsIHMuQVVESU9fVFJBQ0tfTE9BRF9FUlJPUiA9IFwiYXVkaW9UcmFja0xvYWRFcnJvclwiLCBzLkFVRElPX1RSQUNLX0xPQURfVElNRU9VVCA9IFwiYXVkaW9UcmFja0xvYWRUaW1lT3V0XCIsIHMuU1VCVElUTEVfTE9BRF9FUlJPUiA9IFwic3VidGl0bGVUcmFja0xvYWRFcnJvclwiLCBzLlNVQlRJVExFX1RSQUNLX0xPQURfVElNRU9VVCA9IFwic3VidGl0bGVUcmFja0xvYWRUaW1lT3V0XCIsIHMuRlJBR19MT0FEX0VSUk9SID0gXCJmcmFnTG9hZEVycm9yXCIsIHMuRlJBR19MT0FEX1RJTUVPVVQgPSBcImZyYWdMb2FkVGltZU91dFwiLCBzLkZSQUdfREVDUllQVF9FUlJPUiA9IFwiZnJhZ0RlY3J5cHRFcnJvclwiLCBzLkZSQUdfUEFSU0lOR19FUlJPUiA9IFwiZnJhZ1BhcnNpbmdFcnJvclwiLCBzLkZSQUdfR0FQID0gXCJmcmFnR2FwXCIsIHMuUkVNVVhfQUxMT0NfRVJST1IgPSBcInJlbXV4QWxsb2NFcnJvclwiLCBzLktFWV9MT0FEX0VSUk9SID0gXCJrZXlMb2FkRXJyb3JcIiwgcy5LRVlfTE9BRF9USU1FT1VUID0gXCJrZXlMb2FkVGltZU91dFwiLCBzLkJVRkZFUl9BRERfQ09ERUNfRVJST1IgPSBcImJ1ZmZlckFkZENvZGVjRXJyb3JcIiwgcy5CVUZGRVJfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUiA9IFwiYnVmZmVySW5jb21wYXRpYmxlQ29kZWNzRXJyb3JcIiwgcy5CVUZGRVJfQVBQRU5EX0VSUk9SID0gXCJidWZmZXJBcHBlbmRFcnJvclwiLCBzLkJVRkZFUl9BUFBFTkRJTkdfRVJST1IgPSBcImJ1ZmZlckFwcGVuZGluZ0Vycm9yXCIsIHMuQlVGRkVSX1NUQUxMRURfRVJST1IgPSBcImJ1ZmZlclN0YWxsZWRFcnJvclwiLCBzLkJVRkZFUl9GVUxMX0VSUk9SID0gXCJidWZmZXJGdWxsRXJyb3JcIiwgcy5CVUZGRVJfU0VFS19PVkVSX0hPTEUgPSBcImJ1ZmZlclNlZWtPdmVySG9sZVwiLCBzLkJVRkZFUl9OVURHRV9PTl9TVEFMTCA9IFwiYnVmZmVyTnVkZ2VPblN0YWxsXCIsIHMuQVNTRVRfTElTVF9MT0FEX0VSUk9SID0gXCJhc3NldExpc3RMb2FkRXJyb3JcIiwgcy5BU1NFVF9MSVNUX0xPQURfVElNRU9VVCA9IFwiYXNzZXRMaXN0TG9hZFRpbWVvdXRcIiwgcy5BU1NFVF9MSVNUX1BBUlNJTkdfRVJST1IgPSBcImFzc2V0TGlzdFBhcnNpbmdFcnJvclwiLCBzLklOVEVSU1RJVElBTF9BU1NFVF9JVEVNX0VSUk9SID0gXCJpbnRlcnN0aXRpYWxBc3NldEl0ZW1FcnJvclwiLCBzLklOVEVSTkFMX0VYQ0VQVElPTiA9IFwiaW50ZXJuYWxFeGNlcHRpb25cIiwgcy5JTlRFUk5BTF9BQk9SVEVEID0gXCJhYm9ydGVkXCIsIHMuQVRUQUNIX01FRElBX0VSUk9SID0gXCJhdHRhY2hNZWRpYUVycm9yXCIsIHMuVU5LTk9XTiA9IFwidW5rbm93blwiLCBzO1xufSkoe30pLCBJID0gLyogQF9fUFVSRV9fICovIChmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzLk1FRElBX0FUVEFDSElORyA9IFwiaGxzTWVkaWFBdHRhY2hpbmdcIiwgcy5NRURJQV9BVFRBQ0hFRCA9IFwiaGxzTWVkaWFBdHRhY2hlZFwiLCBzLk1FRElBX0RFVEFDSElORyA9IFwiaGxzTWVkaWFEZXRhY2hpbmdcIiwgcy5NRURJQV9ERVRBQ0hFRCA9IFwiaGxzTWVkaWFEZXRhY2hlZFwiLCBzLk1FRElBX0VOREVEID0gXCJobHNNZWRpYUVuZGVkXCIsIHMuU1RBTExfUkVTT0xWRUQgPSBcImhsc1N0YWxsUmVzb2x2ZWRcIiwgcy5CVUZGRVJfUkVTRVQgPSBcImhsc0J1ZmZlclJlc2V0XCIsIHMuQlVGRkVSX0NPREVDUyA9IFwiaGxzQnVmZmVyQ29kZWNzXCIsIHMuQlVGRkVSX0NSRUFURUQgPSBcImhsc0J1ZmZlckNyZWF0ZWRcIiwgcy5CVUZGRVJfQVBQRU5ESU5HID0gXCJobHNCdWZmZXJBcHBlbmRpbmdcIiwgcy5CVUZGRVJfQVBQRU5ERUQgPSBcImhsc0J1ZmZlckFwcGVuZGVkXCIsIHMuQlVGRkVSX0VPUyA9IFwiaGxzQnVmZmVyRW9zXCIsIHMuQlVGRkVSRURfVE9fRU5EID0gXCJobHNCdWZmZXJlZFRvRW5kXCIsIHMuQlVGRkVSX0ZMVVNISU5HID0gXCJobHNCdWZmZXJGbHVzaGluZ1wiLCBzLkJVRkZFUl9GTFVTSEVEID0gXCJobHNCdWZmZXJGbHVzaGVkXCIsIHMuTUFOSUZFU1RfTE9BRElORyA9IFwiaGxzTWFuaWZlc3RMb2FkaW5nXCIsIHMuTUFOSUZFU1RfTE9BREVEID0gXCJobHNNYW5pZmVzdExvYWRlZFwiLCBzLk1BTklGRVNUX1BBUlNFRCA9IFwiaGxzTWFuaWZlc3RQYXJzZWRcIiwgcy5MRVZFTF9TV0lUQ0hJTkcgPSBcImhsc0xldmVsU3dpdGNoaW5nXCIsIHMuTEVWRUxfU1dJVENIRUQgPSBcImhsc0xldmVsU3dpdGNoZWRcIiwgcy5MRVZFTF9MT0FESU5HID0gXCJobHNMZXZlbExvYWRpbmdcIiwgcy5MRVZFTF9MT0FERUQgPSBcImhsc0xldmVsTG9hZGVkXCIsIHMuTEVWRUxfVVBEQVRFRCA9IFwiaGxzTGV2ZWxVcGRhdGVkXCIsIHMuTEVWRUxfUFRTX1VQREFURUQgPSBcImhsc0xldmVsUHRzVXBkYXRlZFwiLCBzLkxFVkVMU19VUERBVEVEID0gXCJobHNMZXZlbHNVcGRhdGVkXCIsIHMuQVVESU9fVFJBQ0tTX1VQREFURUQgPSBcImhsc0F1ZGlvVHJhY2tzVXBkYXRlZFwiLCBzLkFVRElPX1RSQUNLX1NXSVRDSElORyA9IFwiaGxzQXVkaW9UcmFja1N3aXRjaGluZ1wiLCBzLkFVRElPX1RSQUNLX1NXSVRDSEVEID0gXCJobHNBdWRpb1RyYWNrU3dpdGNoZWRcIiwgcy5BVURJT19UUkFDS19MT0FESU5HID0gXCJobHNBdWRpb1RyYWNrTG9hZGluZ1wiLCBzLkFVRElPX1RSQUNLX0xPQURFRCA9IFwiaGxzQXVkaW9UcmFja0xvYWRlZFwiLCBzLkFVRElPX1RSQUNLX1VQREFURUQgPSBcImhsc0F1ZGlvVHJhY2tVcGRhdGVkXCIsIHMuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQgPSBcImhsc1N1YnRpdGxlVHJhY2tzVXBkYXRlZFwiLCBzLlNVQlRJVExFX1RSQUNLU19DTEVBUkVEID0gXCJobHNTdWJ0aXRsZVRyYWNrc0NsZWFyZWRcIiwgcy5TVUJUSVRMRV9UUkFDS19TV0lUQ0ggPSBcImhsc1N1YnRpdGxlVHJhY2tTd2l0Y2hcIiwgcy5TVUJUSVRMRV9UUkFDS19MT0FESU5HID0gXCJobHNTdWJ0aXRsZVRyYWNrTG9hZGluZ1wiLCBzLlNVQlRJVExFX1RSQUNLX0xPQURFRCA9IFwiaGxzU3VidGl0bGVUcmFja0xvYWRlZFwiLCBzLlNVQlRJVExFX1RSQUNLX1VQREFURUQgPSBcImhsc1N1YnRpdGxlVHJhY2tVcGRhdGVkXCIsIHMuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQgPSBcImhsc1N1YnRpdGxlRnJhZ1Byb2Nlc3NlZFwiLCBzLkNVRVNfUEFSU0VEID0gXCJobHNDdWVzUGFyc2VkXCIsIHMuTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORCA9IFwiaGxzTm9uTmF0aXZlVGV4dFRyYWNrc0ZvdW5kXCIsIHMuSU5JVF9QVFNfRk9VTkQgPSBcImhsc0luaXRQdHNGb3VuZFwiLCBzLkZSQUdfTE9BRElORyA9IFwiaGxzRnJhZ0xvYWRpbmdcIiwgcy5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQgPSBcImhsc0ZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZFwiLCBzLkZSQUdfTE9BREVEID0gXCJobHNGcmFnTG9hZGVkXCIsIHMuRlJBR19ERUNSWVBURUQgPSBcImhsc0ZyYWdEZWNyeXB0ZWRcIiwgcy5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5UID0gXCJobHNGcmFnUGFyc2luZ0luaXRTZWdtZW50XCIsIHMuRlJBR19QQVJTSU5HX1VTRVJEQVRBID0gXCJobHNGcmFnUGFyc2luZ1VzZXJkYXRhXCIsIHMuRlJBR19QQVJTSU5HX01FVEFEQVRBID0gXCJobHNGcmFnUGFyc2luZ01ldGFkYXRhXCIsIHMuRlJBR19QQVJTRUQgPSBcImhsc0ZyYWdQYXJzZWRcIiwgcy5GUkFHX0JVRkZFUkVEID0gXCJobHNGcmFnQnVmZmVyZWRcIiwgcy5GUkFHX0NIQU5HRUQgPSBcImhsc0ZyYWdDaGFuZ2VkXCIsIHMuRlBTX0RST1AgPSBcImhsc0Zwc0Ryb3BcIiwgcy5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HID0gXCJobHNGcHNEcm9wTGV2ZWxDYXBwaW5nXCIsIHMuTUFYX0FVVE9fTEVWRUxfVVBEQVRFRCA9IFwiaGxzTWF4QXV0b0xldmVsVXBkYXRlZFwiLCBzLkVSUk9SID0gXCJobHNFcnJvclwiLCBzLkRFU1RST1lJTkcgPSBcImhsc0Rlc3Ryb3lpbmdcIiwgcy5LRVlfTE9BRElORyA9IFwiaGxzS2V5TG9hZGluZ1wiLCBzLktFWV9MT0FERUQgPSBcImhsc0tleUxvYWRlZFwiLCBzLkxJVkVfQkFDS19CVUZGRVJfUkVBQ0hFRCA9IFwiaGxzTGl2ZUJhY2tCdWZmZXJSZWFjaGVkXCIsIHMuQkFDS19CVUZGRVJfUkVBQ0hFRCA9IFwiaGxzQmFja0J1ZmZlclJlYWNoZWRcIiwgcy5TVEVFUklOR19NQU5JRkVTVF9MT0FERUQgPSBcImhsc1N0ZWVyaW5nTWFuaWZlc3RMb2FkZWRcIiwgcy5BU1NFVF9MSVNUX0xPQURJTkcgPSBcImhsc0Fzc2V0TGlzdExvYWRpbmdcIiwgcy5BU1NFVF9MSVNUX0xPQURFRCA9IFwiaGxzQXNzZXRMaXN0TG9hZGVkXCIsIHMuSU5URVJTVElUSUFMU19VUERBVEVEID0gXCJobHNJbnRlcnN0aXRpYWxzVXBkYXRlZFwiLCBzLklOVEVSU1RJVElBTFNfQlVGRkVSRURfVE9fQk9VTkRBUlkgPSBcImhsc0ludGVyc3RpdGlhbHNCdWZmZXJlZFRvQm91bmRhcnlcIiwgcy5JTlRFUlNUSVRJQUxfQVNTRVRfUExBWUVSX0NSRUFURUQgPSBcImhsc0ludGVyc3RpdGlhbEFzc2V0UGxheWVyQ3JlYXRlZFwiLCBzLklOVEVSU1RJVElBTF9TVEFSVEVEID0gXCJobHNJbnRlcnN0aXRpYWxTdGFydGVkXCIsIHMuSU5URVJTVElUSUFMX0FTU0VUX1NUQVJURUQgPSBcImhsc0ludGVyc3RpdGlhbEFzc2V0U3RhcnRlZFwiLCBzLklOVEVSU1RJVElBTF9BU1NFVF9FTkRFRCA9IFwiaGxzSW50ZXJzdGl0aWFsQXNzZXRFbmRlZFwiLCBzLklOVEVSU1RJVElBTF9BU1NFVF9FUlJPUiA9IFwiaGxzSW50ZXJzdGl0aWFsQXNzZXRFcnJvclwiLCBzLklOVEVSU1RJVElBTF9FTkRFRCA9IFwiaGxzSW50ZXJzdGl0aWFsRW5kZWRcIiwgcy5JTlRFUlNUSVRJQUxTX1BSSU1BUllfUkVTVU1FRCA9IFwiaGxzSW50ZXJzdGl0aWFsc1ByaW1hcnlSZXN1bWVkXCIsIHMuUExBWU9VVF9MSU1JVF9SRUFDSEVEID0gXCJobHNQbGF5b3V0TGltaXRSZWFjaGVkXCIsIHMuRVZFTlRfQ1VFX0VOVEVSID0gXCJobHNFdmVudEN1ZUVudGVyXCIsIHM7XG59KSh7fSk7XG52YXIgS2UgPSB7XG4gIE1BTklGRVNUOiBcIm1hbmlmZXN0XCIsXG4gIExFVkVMOiBcImxldmVsXCIsXG4gIEFVRElPX1RSQUNLOiBcImF1ZGlvVHJhY2tcIixcbiAgU1VCVElUTEVfVFJBQ0s6IFwic3VidGl0bGVUcmFja1wiXG59LCBwZSA9IHtcbiAgTUFJTjogXCJtYWluXCIsXG4gIEFVRElPOiBcImF1ZGlvXCIsXG4gIFNVQlRJVExFOiBcInN1YnRpdGxlXCJcbn07XG5jbGFzcyBobiB7XG4gIC8vICBBYm91dCBoYWxmIG9mIHRoZSBlc3RpbWF0ZWQgdmFsdWUgd2lsbCBiZSBmcm9tIHRoZSBsYXN0IHxoYWxmTGlmZXwgc2FtcGxlcyBieSB3ZWlnaHQuXG4gIGNvbnN0cnVjdG9yKGUsIHQgPSAwLCByID0gMCkge1xuICAgIHRoaXMuaGFsZkxpZmUgPSB2b2lkIDAsIHRoaXMuYWxwaGFfID0gdm9pZCAwLCB0aGlzLmVzdGltYXRlXyA9IHZvaWQgMCwgdGhpcy50b3RhbFdlaWdodF8gPSB2b2lkIDAsIHRoaXMuaGFsZkxpZmUgPSBlLCB0aGlzLmFscGhhXyA9IGUgPyBNYXRoLmV4cChNYXRoLmxvZygwLjUpIC8gZSkgOiAwLCB0aGlzLmVzdGltYXRlXyA9IHQsIHRoaXMudG90YWxXZWlnaHRfID0gcjtcbiAgfVxuICBzYW1wbGUoZSwgdCkge1xuICAgIGNvbnN0IHIgPSBNYXRoLnBvdyh0aGlzLmFscGhhXywgZSk7XG4gICAgdGhpcy5lc3RpbWF0ZV8gPSB0ICogKDEgLSByKSArIHIgKiB0aGlzLmVzdGltYXRlXywgdGhpcy50b3RhbFdlaWdodF8gKz0gZTtcbiAgfVxuICBnZXRUb3RhbFdlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy50b3RhbFdlaWdodF87XG4gIH1cbiAgZ2V0RXN0aW1hdGUoKSB7XG4gICAgaWYgKHRoaXMuYWxwaGFfKSB7XG4gICAgICBjb25zdCBlID0gMSAtIE1hdGgucG93KHRoaXMuYWxwaGFfLCB0aGlzLnRvdGFsV2VpZ2h0Xyk7XG4gICAgICBpZiAoZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfIC8gZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXN0aW1hdGVfO1xuICB9XG59XG5jbGFzcyBUUyB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHIsIG4gPSAxMDApIHtcbiAgICB0aGlzLmRlZmF1bHRFc3RpbWF0ZV8gPSB2b2lkIDAsIHRoaXMubWluV2VpZ2h0XyA9IHZvaWQgMCwgdGhpcy5taW5EZWxheU1zXyA9IHZvaWQgMCwgdGhpcy5zbG93XyA9IHZvaWQgMCwgdGhpcy5mYXN0XyA9IHZvaWQgMCwgdGhpcy5kZWZhdWx0VFRGQl8gPSB2b2lkIDAsIHRoaXMudHRmYl8gPSB2b2lkIDAsIHRoaXMuZGVmYXVsdEVzdGltYXRlXyA9IHIsIHRoaXMubWluV2VpZ2h0XyA9IDFlLTMsIHRoaXMubWluRGVsYXlNc18gPSA1MCwgdGhpcy5zbG93XyA9IG5ldyBobihlKSwgdGhpcy5mYXN0XyA9IG5ldyBobih0KSwgdGhpcy5kZWZhdWx0VFRGQl8gPSBuLCB0aGlzLnR0ZmJfID0gbmV3IGhuKGUpO1xuICB9XG4gIHVwZGF0ZShlLCB0KSB7XG4gICAgY29uc3Qge1xuICAgICAgc2xvd186IHIsXG4gICAgICBmYXN0XzogbixcbiAgICAgIHR0ZmJfOiBpXG4gICAgfSA9IHRoaXM7XG4gICAgci5oYWxmTGlmZSAhPT0gZSAmJiAodGhpcy5zbG93XyA9IG5ldyBobihlLCByLmdldEVzdGltYXRlKCksIHIuZ2V0VG90YWxXZWlnaHQoKSkpLCBuLmhhbGZMaWZlICE9PSB0ICYmICh0aGlzLmZhc3RfID0gbmV3IGhuKHQsIG4uZ2V0RXN0aW1hdGUoKSwgbi5nZXRUb3RhbFdlaWdodCgpKSksIGkuaGFsZkxpZmUgIT09IGUgJiYgKHRoaXMudHRmYl8gPSBuZXcgaG4oZSwgaS5nZXRFc3RpbWF0ZSgpLCBpLmdldFRvdGFsV2VpZ2h0KCkpKTtcbiAgfVxuICBzYW1wbGUoZSwgdCkge1xuICAgIGUgPSBNYXRoLm1heChlLCB0aGlzLm1pbkRlbGF5TXNfKTtcbiAgICBjb25zdCByID0gOCAqIHQsIG4gPSBlIC8gMWUzLCBpID0gciAvIG47XG4gICAgdGhpcy5mYXN0Xy5zYW1wbGUobiwgaSksIHRoaXMuc2xvd18uc2FtcGxlKG4sIGkpO1xuICB9XG4gIHNhbXBsZVRURkIoZSkge1xuICAgIGNvbnN0IHQgPSBlIC8gMWUzLCByID0gTWF0aC5zcXJ0KDIpICogTWF0aC5leHAoLU1hdGgucG93KHQsIDIpIC8gMik7XG4gICAgdGhpcy50dGZiXy5zYW1wbGUociwgTWF0aC5tYXgoZSwgNSkpO1xuICB9XG4gIGNhbkVzdGltYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmZhc3RfLmdldFRvdGFsV2VpZ2h0KCkgPj0gdGhpcy5taW5XZWlnaHRfO1xuICB9XG4gIGdldEVzdGltYXRlKCkge1xuICAgIHJldHVybiB0aGlzLmNhbkVzdGltYXRlKCkgPyBNYXRoLm1pbih0aGlzLmZhc3RfLmdldEVzdGltYXRlKCksIHRoaXMuc2xvd18uZ2V0RXN0aW1hdGUoKSkgOiB0aGlzLmRlZmF1bHRFc3RpbWF0ZV87XG4gIH1cbiAgZ2V0RXN0aW1hdGVUVEZCKCkge1xuICAgIHJldHVybiB0aGlzLnR0ZmJfLmdldFRvdGFsV2VpZ2h0KCkgPj0gdGhpcy5taW5XZWlnaHRfID8gdGhpcy50dGZiXy5nZXRFc3RpbWF0ZSgpIDogdGhpcy5kZWZhdWx0VFRGQl87XG4gIH1cbiAgZ2V0IGRlZmF1bHRFc3RpbWF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0RXN0aW1hdGVfO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gIH1cbn1cbmZ1bmN0aW9uIHdTKHMsIGUsIHQpIHtcbiAgcmV0dXJuIChlID0gSVMoZSkpIGluIHMgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkocywgZSwge1xuICAgIHZhbHVlOiB0LFxuICAgIGVudW1lcmFibGU6ICEwLFxuICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgd3JpdGFibGU6ICEwXG4gIH0pIDogc1tlXSA9IHQsIHM7XG59XG5mdW5jdGlvbiBudCgpIHtcbiAgcmV0dXJuIG50ID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24ocykge1xuICAgIGZvciAodmFyIGUgPSAxOyBlIDwgYXJndW1lbnRzLmxlbmd0aDsgZSsrKSB7XG4gICAgICB2YXIgdCA9IGFyZ3VtZW50c1tlXTtcbiAgICAgIGZvciAodmFyIHIgaW4gdCkgKHt9KS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsIHIpICYmIChzW3JdID0gdFtyXSk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9LCBudC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gWGQocywgZSkge1xuICB2YXIgdCA9IE9iamVjdC5rZXlzKHMpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciByID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTtcbiAgICBlICYmIChyID0gci5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocywgbikuZW51bWVyYWJsZTtcbiAgICB9KSksIHQucHVzaC5hcHBseSh0LCByKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIHR0KHMpIHtcbiAgZm9yICh2YXIgZSA9IDE7IGUgPCBhcmd1bWVudHMubGVuZ3RoOyBlKyspIHtcbiAgICB2YXIgdCA9IGFyZ3VtZW50c1tlXSAhPSBudWxsID8gYXJndW1lbnRzW2VdIDoge307XG4gICAgZSAlIDIgPyBYZChPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uKHIpIHtcbiAgICAgIHdTKHMsIHIsIHRbcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBYZChPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHMsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gQVMocywgZSkge1xuICBpZiAodHlwZW9mIHMgIT0gXCJvYmplY3RcIiB8fCAhcykgcmV0dXJuIHM7XG4gIHZhciB0ID0gc1tTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodCAhPT0gdm9pZCAwKSB7XG4gICAgdmFyIHIgPSB0LmNhbGwocywgZSk7XG4gICAgaWYgKHR5cGVvZiByICE9IFwib2JqZWN0XCIpIHJldHVybiByO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGUgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKHMpO1xufVxuZnVuY3Rpb24gSVMocykge1xuICB2YXIgZSA9IEFTKHMsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gdHlwZW9mIGUgPT0gXCJzeW1ib2xcIiA/IGUgOiBlICsgXCJcIjtcbn1cbmNsYXNzIExyIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMudHJhY2UgPSB2b2lkIDAsIHRoaXMuZGVidWcgPSB2b2lkIDAsIHRoaXMubG9nID0gdm9pZCAwLCB0aGlzLndhcm4gPSB2b2lkIDAsIHRoaXMuaW5mbyA9IHZvaWQgMCwgdGhpcy5lcnJvciA9IHZvaWQgMDtcbiAgICBjb25zdCByID0gYFske2V9XTpgO1xuICAgIHRoaXMudHJhY2UgPSBBcywgdGhpcy5kZWJ1ZyA9IHQuZGVidWcuYmluZChudWxsLCByKSwgdGhpcy5sb2cgPSB0LmxvZy5iaW5kKG51bGwsIHIpLCB0aGlzLndhcm4gPSB0Lndhcm4uYmluZChudWxsLCByKSwgdGhpcy5pbmZvID0gdC5pbmZvLmJpbmQobnVsbCwgciksIHRoaXMuZXJyb3IgPSB0LmVycm9yLmJpbmQobnVsbCwgcik7XG4gIH1cbn1cbmNvbnN0IEFzID0gZnVuY3Rpb24oKSB7XG59LCBfUyA9IHtcbiAgdHJhY2U6IEFzLFxuICBkZWJ1ZzogQXMsXG4gIGxvZzogQXMsXG4gIHdhcm46IEFzLFxuICBpbmZvOiBBcyxcbiAgZXJyb3I6IEFzXG59O1xuZnVuY3Rpb24gb2MoKSB7XG4gIHJldHVybiBudCh7fSwgX1MpO1xufVxuZnVuY3Rpb24gUlMocywgZSkge1xuICBjb25zdCB0ID0gc2VsZi5jb25zb2xlW3NdO1xuICByZXR1cm4gdCA/IHQuYmluZChzZWxmLmNvbnNvbGUsIGAke2UgPyBcIltcIiArIGUgKyBcIl0gXCIgOiBcIlwifVske3N9XSA+YCkgOiBBcztcbn1cbmZ1bmN0aW9uIEpkKHMsIGUsIHQpIHtcbiAgcmV0dXJuIGVbc10gPyBlW3NdLmJpbmQoZSkgOiBSUyhzLCB0KTtcbn1cbmNvbnN0IGFjID0gb2MoKTtcbmZ1bmN0aW9uIExTKHMsIGUsIHQpIHtcbiAgY29uc3QgciA9IG9jKCk7XG4gIGlmICh0eXBlb2YgY29uc29sZSA9PSBcIm9iamVjdFwiICYmIHMgPT09ICEwIHx8IHR5cGVvZiBzID09IFwib2JqZWN0XCIpIHtcbiAgICBjb25zdCBuID0gW1xuICAgICAgLy8gUmVtb3ZlIG91dCBmcm9tIGxpc3QgaGVyZSB0byBoYXJkLWRpc2FibGUgYSBsb2ctbGV2ZWxcbiAgICAgIC8vICd0cmFjZScsXG4gICAgICBcImRlYnVnXCIsXG4gICAgICBcImxvZ1wiLFxuICAgICAgXCJpbmZvXCIsXG4gICAgICBcIndhcm5cIixcbiAgICAgIFwiZXJyb3JcIlxuICAgIF07XG4gICAgbi5mb3JFYWNoKChpKSA9PiB7XG4gICAgICByW2ldID0gSmQoaSwgcywgdCk7XG4gICAgfSk7XG4gICAgdHJ5IHtcbiAgICAgIHIubG9nKGBEZWJ1ZyBsb2dzIGVuYWJsZWQgZm9yIFwiJHtlfVwiIGluIGhscy5qcyB2ZXJzaW9uIDEuNi4xMmApO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIG9jKCk7XG4gICAgfVxuICAgIG4uZm9yRWFjaCgoaSkgPT4ge1xuICAgICAgYWNbaV0gPSBKZChpLCBzKTtcbiAgICB9KTtcbiAgfSBlbHNlXG4gICAgbnQoYWMsIHIpO1xuICByZXR1cm4gcjtcbn1cbmNvbnN0IHJ0ID0gYWM7XG5mdW5jdGlvbiBNcyhzID0gITApIHtcbiAgcmV0dXJuIHR5cGVvZiBzZWxmID4gXCJ1XCIgPyB2b2lkIDAgOiAocyB8fCAhc2VsZi5NZWRpYVNvdXJjZSkgJiYgc2VsZi5NYW5hZ2VkTWVkaWFTb3VyY2UgfHwgc2VsZi5NZWRpYVNvdXJjZSB8fCBzZWxmLldlYktpdE1lZGlhU291cmNlO1xufVxuZnVuY3Rpb24gQ1Mocykge1xuICByZXR1cm4gdHlwZW9mIHNlbGYgPCBcInVcIiAmJiBzID09PSBzZWxmLk1hbmFnZWRNZWRpYVNvdXJjZTtcbn1cbmZ1bmN0aW9uIEFnKHMsIGUpIHtcbiAgY29uc3QgdCA9IE9iamVjdC5rZXlzKHMpLCByID0gT2JqZWN0LmtleXMoZSksIG4gPSB0Lmxlbmd0aCwgaSA9IHIubGVuZ3RoO1xuICByZXR1cm4gIW4gfHwgIWkgfHwgbiA9PT0gaSAmJiAhdC5zb21lKChvKSA9PiByLmluZGV4T2YobykgPT09IC0xKTtcbn1cbmZ1bmN0aW9uIFRyKHMsIGUgPSAhMSkge1xuICBpZiAodHlwZW9mIFRleHREZWNvZGVyIDwgXCJ1XCIpIHtcbiAgICBjb25zdCBjID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIikuZGVjb2RlKHMpO1xuICAgIGlmIChlKSB7XG4gICAgICBjb25zdCB1ID0gYy5pbmRleE9mKFwiXFwwXCIpO1xuICAgICAgcmV0dXJuIHUgIT09IC0xID8gYy5zdWJzdHJpbmcoMCwgdSkgOiBjO1xuICAgIH1cbiAgICByZXR1cm4gYy5yZXBsYWNlKC9cXDAvZywgXCJcIik7XG4gIH1cbiAgY29uc3QgdCA9IHMubGVuZ3RoO1xuICBsZXQgciwgbiwgaSwgbyA9IFwiXCIsIGEgPSAwO1xuICBmb3IgKDsgYSA8IHQ7ICkge1xuICAgIGlmIChyID0gc1thKytdLCByID09PSAwICYmIGUpXG4gICAgICByZXR1cm4gbztcbiAgICBpZiAociA9PT0gMCB8fCByID09PSAzKVxuICAgICAgY29udGludWU7XG4gICAgc3dpdGNoIChyID4+IDQpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgIGNhc2UgMTpcbiAgICAgIGNhc2UgMjpcbiAgICAgIGNhc2UgMzpcbiAgICAgIGNhc2UgNDpcbiAgICAgIGNhc2UgNTpcbiAgICAgIGNhc2UgNjpcbiAgICAgIGNhc2UgNzpcbiAgICAgICAgbyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTI6XG4gICAgICBjYXNlIDEzOlxuICAgICAgICBuID0gc1thKytdLCBvICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKHIgJiAzMSkgPDwgNiB8IG4gJiA2Myk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxNDpcbiAgICAgICAgbiA9IHNbYSsrXSwgaSA9IHNbYSsrXSwgbyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChyICYgMTUpIDw8IDEyIHwgKG4gJiA2MykgPDwgNiB8IChpICYgNjMpIDw8IDApO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBmcihzKSB7XG4gIGxldCBlID0gXCJcIjtcbiAgZm9yIChsZXQgdCA9IDA7IHQgPCBzLmxlbmd0aDsgdCsrKSB7XG4gICAgbGV0IHIgPSBzW3RdLnRvU3RyaW5nKDE2KTtcbiAgICByLmxlbmd0aCA8IDIgJiYgKHIgPSBcIjBcIiArIHIpLCBlICs9IHI7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBJZyhzKSB7XG4gIHJldHVybiBVaW50OEFycmF5LmZyb20ocy5yZXBsYWNlKC9eMHgvLCBcIlwiKS5yZXBsYWNlKC8oW1xcZGEtZkEtRl17Mn0pID8vZywgXCIweCQxIFwiKS5yZXBsYWNlKC8gKyQvLCBcIlwiKS5zcGxpdChcIiBcIikpLmJ1ZmZlcjtcbn1cbmZ1bmN0aW9uIGtTKHMpIHtcbiAgcmV0dXJuIHMgJiYgcy5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBcImRlZmF1bHRcIikgPyBzLmRlZmF1bHQgOiBzO1xufVxudmFyIGNsID0geyBleHBvcnRzOiB7fSB9LCBRZDtcbmZ1bmN0aW9uIERTKCkge1xuICByZXR1cm4gUWQgfHwgKFFkID0gMSwgKGZ1bmN0aW9uKHMsIGUpIHtcbiAgICAoZnVuY3Rpb24odCkge1xuICAgICAgdmFyIHIgPSAvXig/PSgoPzpbYS16QS1aMC05K1xcLS5dKzopPykpXFwxKD89KCg/OlxcL1xcL1teXFwvPyNdKik/KSlcXDIoPz0oKD86KD86W14/I1xcL10qXFwvKSpbXjs/I1xcL10qKT8pKVxcMygoPzo7W14/I10qKT8pKFxcP1teI10qKT8oI1teXSopPyQvLCBuID0gL14oPz0oW15cXC8/I10qKSlcXDEoW15dKikkLywgaSA9IC8oPzpcXC98XilcXC4oPz1cXC8pL2csIG8gPSAvKD86XFwvfF4pXFwuXFwuXFwvKD8hXFwuXFwuXFwvKVteXFwvXSooPz1cXC8pL2csIGEgPSB7XG4gICAgICAgIC8vIElmIG9wdHMuYWx3YXlzTm9ybWFsaXplIGlzIHRydWUgdGhlbiB0aGUgcGF0aCB3aWxsIGFsd2F5cyBiZSBub3JtYWxpemVkIGV2ZW4gd2hlbiBpdCBzdGFydHMgd2l0aCAvIG9yIC8vXG4gICAgICAgIC8vIEUuZ1xuICAgICAgICAvLyBXaXRoIG9wdHMuYWx3YXlzTm9ybWFsaXplID0gZmFsc2UgKGRlZmF1bHQsIHNwZWMgY29tcGxpYW50KVxuICAgICAgICAvLyBodHRwOi8vYS5jb20vYi9jZCArIC9lL2YvLi4vZyA9PiBodHRwOi8vYS5jb20vZS9mLy4uL2dcbiAgICAgICAgLy8gV2l0aCBvcHRzLmFsd2F5c05vcm1hbGl6ZSA9IHRydWUgKG5vdCBzcGVjIGNvbXBsaWFudClcbiAgICAgICAgLy8gaHR0cDovL2EuY29tL2IvY2QgKyAvZS9mLy4uL2cgPT4gaHR0cDovL2EuY29tL2UvZ1xuICAgICAgICBidWlsZEFic29sdXRlVVJMOiBmdW5jdGlvbihsLCBjLCB1KSB7XG4gICAgICAgICAgaWYgKHUgPSB1IHx8IHt9LCBsID0gbC50cmltKCksIGMgPSBjLnRyaW0oKSwgIWMpIHtcbiAgICAgICAgICAgIGlmICghdS5hbHdheXNOb3JtYWxpemUpXG4gICAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICAgICAgdmFyIGQgPSBhLnBhcnNlVVJMKGwpO1xuICAgICAgICAgICAgaWYgKCFkKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciB0cnlpbmcgdG8gcGFyc2UgYmFzZSBVUkwuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGQucGF0aCA9IGEubm9ybWFsaXplUGF0aChcbiAgICAgICAgICAgICAgZC5wYXRoXG4gICAgICAgICAgICApLCBhLmJ1aWxkVVJMRnJvbVBhcnRzKGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgaCA9IGEucGFyc2VVUkwoYyk7XG4gICAgICAgICAgaWYgKCFoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgdHJ5aW5nIHRvIHBhcnNlIHJlbGF0aXZlIFVSTC5cIik7XG4gICAgICAgICAgaWYgKGguc2NoZW1lKVxuICAgICAgICAgICAgcmV0dXJuIHUuYWx3YXlzTm9ybWFsaXplID8gKGgucGF0aCA9IGEubm9ybWFsaXplUGF0aChoLnBhdGgpLCBhLmJ1aWxkVVJMRnJvbVBhcnRzKGgpKSA6IGM7XG4gICAgICAgICAgdmFyIGYgPSBhLnBhcnNlVVJMKGwpO1xuICAgICAgICAgIGlmICghZilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIHRyeWluZyB0byBwYXJzZSBiYXNlIFVSTC5cIik7XG4gICAgICAgICAgaWYgKCFmLm5ldExvYyAmJiBmLnBhdGggJiYgZi5wYXRoWzBdICE9PSBcIi9cIikge1xuICAgICAgICAgICAgdmFyIHAgPSBuLmV4ZWMoZi5wYXRoKTtcbiAgICAgICAgICAgIGYubmV0TG9jID0gcFsxXSwgZi5wYXRoID0gcFsyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZi5uZXRMb2MgJiYgIWYucGF0aCAmJiAoZi5wYXRoID0gXCIvXCIpO1xuICAgICAgICAgIHZhciB5ID0ge1xuICAgICAgICAgICAgLy8gMmMpIE90aGVyd2lzZSwgdGhlIGVtYmVkZGVkIFVSTCBpbmhlcml0cyB0aGUgc2NoZW1lIG9mXG4gICAgICAgICAgICAvLyB0aGUgYmFzZSBVUkwuXG4gICAgICAgICAgICBzY2hlbWU6IGYuc2NoZW1lLFxuICAgICAgICAgICAgbmV0TG9jOiBoLm5ldExvYyxcbiAgICAgICAgICAgIHBhdGg6IG51bGwsXG4gICAgICAgICAgICBwYXJhbXM6IGgucGFyYW1zLFxuICAgICAgICAgICAgcXVlcnk6IGgucXVlcnksXG4gICAgICAgICAgICBmcmFnbWVudDogaC5mcmFnbWVudFxuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKCFoLm5ldExvYyAmJiAoeS5uZXRMb2MgPSBmLm5ldExvYywgaC5wYXRoWzBdICE9PSBcIi9cIikpXG4gICAgICAgICAgICBpZiAoIWgucGF0aClcbiAgICAgICAgICAgICAgeS5wYXRoID0gZi5wYXRoLCBoLnBhcmFtcyB8fCAoeS5wYXJhbXMgPSBmLnBhcmFtcywgaC5xdWVyeSB8fCAoeS5xdWVyeSA9IGYucXVlcnkpKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgRSA9IGYucGF0aCwgYiA9IEUuc3Vic3RyaW5nKDAsIEUubGFzdEluZGV4T2YoXCIvXCIpICsgMSkgKyBoLnBhdGg7XG4gICAgICAgICAgICAgIHkucGF0aCA9IGEubm9ybWFsaXplUGF0aChiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geS5wYXRoID09PSBudWxsICYmICh5LnBhdGggPSB1LmFsd2F5c05vcm1hbGl6ZSA/IGEubm9ybWFsaXplUGF0aChoLnBhdGgpIDogaC5wYXRoKSwgYS5idWlsZFVSTEZyb21QYXJ0cyh5KTtcbiAgICAgICAgfSxcbiAgICAgICAgcGFyc2VVUkw6IGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICB2YXIgYyA9IHIuZXhlYyhsKTtcbiAgICAgICAgICByZXR1cm4gYyA/IHtcbiAgICAgICAgICAgIHNjaGVtZTogY1sxXSB8fCBcIlwiLFxuICAgICAgICAgICAgbmV0TG9jOiBjWzJdIHx8IFwiXCIsXG4gICAgICAgICAgICBwYXRoOiBjWzNdIHx8IFwiXCIsXG4gICAgICAgICAgICBwYXJhbXM6IGNbNF0gfHwgXCJcIixcbiAgICAgICAgICAgIHF1ZXJ5OiBjWzVdIHx8IFwiXCIsXG4gICAgICAgICAgICBmcmFnbWVudDogY1s2XSB8fCBcIlwiXG4gICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIG5vcm1hbGl6ZVBhdGg6IGZ1bmN0aW9uKGwpIHtcbiAgICAgICAgICBmb3IgKGwgPSBsLnNwbGl0KFwiXCIpLnJldmVyc2UoKS5qb2luKFwiXCIpLnJlcGxhY2UoaSwgXCJcIik7IGwubGVuZ3RoICE9PSAobCA9IGwucmVwbGFjZShvLCBcIlwiKSkubGVuZ3RoOyApXG4gICAgICAgICAgICA7XG4gICAgICAgICAgcmV0dXJuIGwuc3BsaXQoXCJcIikucmV2ZXJzZSgpLmpvaW4oXCJcIik7XG4gICAgICAgIH0sXG4gICAgICAgIGJ1aWxkVVJMRnJvbVBhcnRzOiBmdW5jdGlvbihsKSB7XG4gICAgICAgICAgcmV0dXJuIGwuc2NoZW1lICsgbC5uZXRMb2MgKyBsLnBhdGggKyBsLnBhcmFtcyArIGwucXVlcnkgKyBsLmZyYWdtZW50O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcy5leHBvcnRzID0gYTtcbiAgICB9KSgpO1xuICB9KShjbCkpLCBjbC5leHBvcnRzO1xufVxudmFyIGh1ID0gRFMoKTtcbmNsYXNzIGZ1IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5hYm9ydGVkID0gITEsIHRoaXMubG9hZGVkID0gMCwgdGhpcy5yZXRyeSA9IDAsIHRoaXMudG90YWwgPSAwLCB0aGlzLmNodW5rQ291bnQgPSAwLCB0aGlzLmJ3RXN0aW1hdGUgPSAwLCB0aGlzLmxvYWRpbmcgPSB7XG4gICAgICBzdGFydDogMCxcbiAgICAgIGZpcnN0OiAwLFxuICAgICAgZW5kOiAwXG4gICAgfSwgdGhpcy5wYXJzaW5nID0ge1xuICAgICAgc3RhcnQ6IDAsXG4gICAgICBlbmQ6IDBcbiAgICB9LCB0aGlzLmJ1ZmZlcmluZyA9IHtcbiAgICAgIHN0YXJ0OiAwLFxuICAgICAgZmlyc3Q6IDAsXG4gICAgICBlbmQ6IDBcbiAgICB9O1xuICB9XG59XG52YXIgb3QgPSB7XG4gIEFVRElPOiBcImF1ZGlvXCIsXG4gIFZJREVPOiBcInZpZGVvXCIsXG4gIEFVRElPVklERU86IFwiYXVkaW92aWRlb1wiXG59O1xuY2xhc3MgX2cge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5fYnl0ZVJhbmdlID0gbnVsbCwgdGhpcy5fdXJsID0gbnVsbCwgdGhpcy5fc3RhdHMgPSBudWxsLCB0aGlzLl9zdHJlYW1zID0gbnVsbCwgdGhpcy5iYXNlID0gdm9pZCAwLCB0aGlzLnJlbHVybCA9IHZvaWQgMCwgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiAmJiAoZSA9IHtcbiAgICAgIHVybDogZVxuICAgIH0pLCB0aGlzLmJhc2UgPSBlLCBNUyh0aGlzLCBcInN0YXRzXCIpO1xuICB9XG4gIC8vIHNldEJ5dGVSYW5nZSBjb252ZXJ0cyBhIEVYVC1YLUJZVEVSQU5HRSBhdHRyaWJ1dGUgaW50byBhIHR3byBlbGVtZW50IGFycmF5XG4gIHNldEJ5dGVSYW5nZShlLCB0KSB7XG4gICAgY29uc3QgciA9IGUuc3BsaXQoXCJAXCIsIDIpO1xuICAgIGxldCBuO1xuICAgIHIubGVuZ3RoID09PSAxID8gbiA9ICh0ID09IG51bGwgPyB2b2lkIDAgOiB0LmJ5dGVSYW5nZUVuZE9mZnNldCkgfHwgMCA6IG4gPSBwYXJzZUludChyWzFdKSwgdGhpcy5fYnl0ZVJhbmdlID0gW24sIHBhcnNlSW50KHJbMF0pICsgbl07XG4gIH1cbiAgZ2V0IGJhc2V1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZS51cmw7XG4gIH1cbiAgZ2V0IGJ5dGVSYW5nZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYnl0ZVJhbmdlID09PSBudWxsID8gW10gOiB0aGlzLl9ieXRlUmFuZ2U7XG4gIH1cbiAgZ2V0IGJ5dGVSYW5nZVN0YXJ0T2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVswXTtcbiAgfVxuICBnZXQgYnl0ZVJhbmdlRW5kT2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmJ5dGVSYW5nZVsxXTtcbiAgfVxuICBnZXQgZWxlbWVudGFyeVN0cmVhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0cmVhbXMgPT09IG51bGwgJiYgKHRoaXMuX3N0cmVhbXMgPSB7XG4gICAgICBbb3QuQVVESU9dOiBudWxsLFxuICAgICAgW290LlZJREVPXTogbnVsbCxcbiAgICAgIFtvdC5BVURJT1ZJREVPXTogbnVsbFxuICAgIH0pLCB0aGlzLl9zdHJlYW1zO1xuICB9XG4gIHNldCBlbGVtZW50YXJ5U3RyZWFtcyhlKSB7XG4gICAgdGhpcy5fc3RyZWFtcyA9IGU7XG4gIH1cbiAgZ2V0IGhhc1N0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0cyAhPT0gbnVsbDtcbiAgfVxuICBnZXQgaGFzU3RyZWFtcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RyZWFtcyAhPT0gbnVsbDtcbiAgfVxuICBnZXQgc3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRzID09PSBudWxsICYmICh0aGlzLl9zdGF0cyA9IG5ldyBmdSgpKSwgdGhpcy5fc3RhdHM7XG4gIH1cbiAgc2V0IHN0YXRzKGUpIHtcbiAgICB0aGlzLl9zdGF0cyA9IGU7XG4gIH1cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gIXRoaXMuX3VybCAmJiB0aGlzLmJhc2V1cmwgJiYgdGhpcy5yZWx1cmwgJiYgKHRoaXMuX3VybCA9IGh1LmJ1aWxkQWJzb2x1dGVVUkwodGhpcy5iYXNldXJsLCB0aGlzLnJlbHVybCwge1xuICAgICAgYWx3YXlzTm9ybWFsaXplOiAhMFxuICAgIH0pKSwgdGhpcy5fdXJsIHx8IFwiXCI7XG4gIH1cbiAgc2V0IHVybChlKSB7XG4gICAgdGhpcy5fdXJsID0gZTtcbiAgfVxuICBjbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRhcnlTdHJlYW1zOiBlXG4gICAgfSA9IHRoaXM7XG4gICAgZVtvdC5BVURJT10gPSBudWxsLCBlW290LlZJREVPXSA9IG51bGwsIGVbb3QuQVVESU9WSURFT10gPSBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBWdChzKSB7XG4gIHJldHVybiBzLnNuICE9PSBcImluaXRTZWdtZW50XCI7XG59XG5jbGFzcyB1bCBleHRlbmRzIF9nIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKHQpLCB0aGlzLl9kZWNyeXB0ZGF0YSA9IG51bGwsIHRoaXMuX3Byb2dyYW1EYXRlVGltZSA9IG51bGwsIHRoaXMuX3JlZiA9IG51bGwsIHRoaXMuX2JpdHJhdGUgPSB2b2lkIDAsIHRoaXMucmF3UHJvZ3JhbURhdGVUaW1lID0gbnVsbCwgdGhpcy50YWdMaXN0ID0gW10sIHRoaXMuZHVyYXRpb24gPSAwLCB0aGlzLnNuID0gMCwgdGhpcy5sZXZlbGtleXMgPSB2b2lkIDAsIHRoaXMudHlwZSA9IHZvaWQgMCwgdGhpcy5sb2FkZXIgPSBudWxsLCB0aGlzLmtleUxvYWRlciA9IG51bGwsIHRoaXMubGV2ZWwgPSAtMSwgdGhpcy5jYyA9IDAsIHRoaXMuc3RhcnRQVFMgPSB2b2lkIDAsIHRoaXMuZW5kUFRTID0gdm9pZCAwLCB0aGlzLnN0YXJ0RFRTID0gdm9pZCAwLCB0aGlzLmVuZERUUyA9IHZvaWQgMCwgdGhpcy5zdGFydCA9IDAsIHRoaXMucGxheWxpc3RPZmZzZXQgPSAwLCB0aGlzLmRlbHRhUFRTID0gdm9pZCAwLCB0aGlzLm1heFN0YXJ0UFRTID0gdm9pZCAwLCB0aGlzLm1pbkVuZFBUUyA9IHZvaWQgMCwgdGhpcy5kYXRhID0gdm9pZCAwLCB0aGlzLmJpdHJhdGVUZXN0ID0gITEsIHRoaXMudGl0bGUgPSBudWxsLCB0aGlzLmluaXRTZWdtZW50ID0gbnVsbCwgdGhpcy5lbmRMaXN0ID0gdm9pZCAwLCB0aGlzLmdhcCA9IHZvaWQgMCwgdGhpcy51cmxJZCA9IDAsIHRoaXMudHlwZSA9IGU7XG4gIH1cbiAgZ2V0IGJ5dGVMZW5ndGgoKSB7XG4gICAgaWYgKHRoaXMuaGFzU3RhdHMpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLnN0YXRzLnRvdGFsO1xuICAgICAgaWYgKGUpXG4gICAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBpZiAodGhpcy5ieXRlUmFuZ2UubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlID0gdGhpcy5ieXRlUmFuZ2VbMF0sIHQgPSB0aGlzLmJ5dGVSYW5nZVsxXTtcbiAgICAgIGlmICh1ZShlKSAmJiB1ZSh0KSlcbiAgICAgICAgcmV0dXJuIHQgLSBlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgYml0cmF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5ieXRlTGVuZ3RoID8gdGhpcy5ieXRlTGVuZ3RoICogOCAvIHRoaXMuZHVyYXRpb24gOiB0aGlzLl9iaXRyYXRlID8gdGhpcy5fYml0cmF0ZSA6IG51bGw7XG4gIH1cbiAgc2V0IGJpdHJhdGUoZSkge1xuICAgIHRoaXMuX2JpdHJhdGUgPSBlO1xuICB9XG4gIGdldCBkZWNyeXB0ZGF0YSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbGtleXM6IGVcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWUgJiYgIXRoaXMuX2RlY3J5cHRkYXRhKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKCF0aGlzLl9kZWNyeXB0ZGF0YSAmJiB0aGlzLmxldmVsa2V5cyAmJiAhdGhpcy5sZXZlbGtleXMuTk9ORSkge1xuICAgICAgY29uc3QgdCA9IHRoaXMubGV2ZWxrZXlzLmlkZW50aXR5O1xuICAgICAgaWYgKHQpXG4gICAgICAgIHRoaXMuX2RlY3J5cHRkYXRhID0gdC5nZXREZWNyeXB0RGF0YSh0aGlzLnNuKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCByID0gT2JqZWN0LmtleXModGhpcy5sZXZlbGtleXMpO1xuICAgICAgICBpZiAoci5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBjb25zdCBuID0gdGhpcy5fZGVjcnlwdGRhdGEgPSB0aGlzLmxldmVsa2V5c1tyWzBdXSB8fCBudWxsO1xuICAgICAgICAgIGlmIChuKVxuICAgICAgICAgICAgcmV0dXJuIG4uZ2V0RGVjcnlwdERhdGEodGhpcy5zbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2RlY3J5cHRkYXRhO1xuICB9XG4gIGdldCBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuICB9XG4gIGdldCBlbmRQcm9ncmFtRGF0ZVRpbWUoKSB7XG4gICAgaWYgKHRoaXMucHJvZ3JhbURhdGVUaW1lID09PSBudWxsKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgZSA9IHVlKHRoaXMuZHVyYXRpb24pID8gdGhpcy5kdXJhdGlvbiA6IDA7XG4gICAgcmV0dXJuIHRoaXMucHJvZ3JhbURhdGVUaW1lICsgZSAqIDFlMztcbiAgfVxuICBnZXQgZW5jcnlwdGVkKCkge1xuICAgIHZhciBlO1xuICAgIGlmICgoZSA9IHRoaXMuX2RlY3J5cHRkYXRhKSAhPSBudWxsICYmIGUuZW5jcnlwdGVkKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGlmICh0aGlzLmxldmVsa2V5cykge1xuICAgICAgdmFyIHQ7XG4gICAgICBjb25zdCByID0gT2JqZWN0LmtleXModGhpcy5sZXZlbGtleXMpLCBuID0gci5sZW5ndGg7XG4gICAgICBpZiAobiA+IDEgfHwgbiA9PT0gMSAmJiAodCA9IHRoaXMubGV2ZWxrZXlzW3JbMF1dKSAhPSBudWxsICYmIHQuZW5jcnlwdGVkKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBnZXQgcHJvZ3JhbURhdGVUaW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm9ncmFtRGF0ZVRpbWUgPT09IG51bGwgJiYgdGhpcy5yYXdQcm9ncmFtRGF0ZVRpbWUgJiYgKHRoaXMucHJvZ3JhbURhdGVUaW1lID0gRGF0ZS5wYXJzZSh0aGlzLnJhd1Byb2dyYW1EYXRlVGltZSkpLCB0aGlzLl9wcm9ncmFtRGF0ZVRpbWU7XG4gIH1cbiAgc2V0IHByb2dyYW1EYXRlVGltZShlKSB7XG4gICAgaWYgKCF1ZShlKSkge1xuICAgICAgdGhpcy5fcHJvZ3JhbURhdGVUaW1lID0gdGhpcy5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBudWxsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9wcm9ncmFtRGF0ZVRpbWUgPSBlO1xuICB9XG4gIGdldCByZWYoKSB7XG4gICAgcmV0dXJuIFZ0KHRoaXMpID8gKHRoaXMuX3JlZiB8fCAodGhpcy5fcmVmID0ge1xuICAgICAgYmFzZTogdGhpcy5iYXNlLFxuICAgICAgc3RhcnQ6IHRoaXMuc3RhcnQsXG4gICAgICBkdXJhdGlvbjogdGhpcy5kdXJhdGlvbixcbiAgICAgIHNuOiB0aGlzLnNuLFxuICAgICAgcHJvZ3JhbURhdGVUaW1lOiB0aGlzLnByb2dyYW1EYXRlVGltZVxuICAgIH0pLCB0aGlzLl9yZWYpIDogbnVsbDtcbiAgfVxuICBhZGRTdGFydChlKSB7XG4gICAgdGhpcy5zZXRTdGFydCh0aGlzLnN0YXJ0ICsgZSk7XG4gIH1cbiAgc2V0U3RhcnQoZSkge1xuICAgIHRoaXMuc3RhcnQgPSBlLCB0aGlzLl9yZWYgJiYgKHRoaXMuX3JlZi5zdGFydCA9IGUpO1xuICB9XG4gIHNldER1cmF0aW9uKGUpIHtcbiAgICB0aGlzLmR1cmF0aW9uID0gZSwgdGhpcy5fcmVmICYmICh0aGlzLl9yZWYuZHVyYXRpb24gPSBlKTtcbiAgfVxuICBzZXRLZXlGb3JtYXQoZSkge1xuICAgIGlmICh0aGlzLmxldmVsa2V5cykge1xuICAgICAgY29uc3QgdCA9IHRoaXMubGV2ZWxrZXlzW2VdO1xuICAgICAgdCAmJiAhdGhpcy5fZGVjcnlwdGRhdGEgJiYgKHRoaXMuX2RlY3J5cHRkYXRhID0gdC5nZXREZWNyeXB0RGF0YSh0aGlzLnNuKSk7XG4gICAgfVxuICB9XG4gIGFib3J0UmVxdWVzdHMoKSB7XG4gICAgdmFyIGUsIHQ7XG4gICAgKGUgPSB0aGlzLmxvYWRlcikgPT0gbnVsbCB8fCBlLmFib3J0KCksICh0ID0gdGhpcy5rZXlMb2FkZXIpID09IG51bGwgfHwgdC5hYm9ydCgpO1xuICB9XG4gIHNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKGUsIHQsIHIsIG4sIGksIG8gPSAhMSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRhcnlTdHJlYW1zOiBhXG4gICAgfSA9IHRoaXMsIGwgPSBhW2VdO1xuICAgIGlmICghbCkge1xuICAgICAgYVtlXSA9IHtcbiAgICAgICAgc3RhcnRQVFM6IHQsXG4gICAgICAgIGVuZFBUUzogcixcbiAgICAgICAgc3RhcnREVFM6IG4sXG4gICAgICAgIGVuZERUUzogaSxcbiAgICAgICAgcGFydGlhbDogb1xuICAgICAgfTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbC5zdGFydFBUUyA9IE1hdGgubWluKGwuc3RhcnRQVFMsIHQpLCBsLmVuZFBUUyA9IE1hdGgubWF4KGwuZW5kUFRTLCByKSwgbC5zdGFydERUUyA9IE1hdGgubWluKGwuc3RhcnREVFMsIG4pLCBsLmVuZERUUyA9IE1hdGgubWF4KGwuZW5kRFRTLCBpKTtcbiAgfVxufVxuY2xhc3MgUFMgZXh0ZW5kcyBfZyB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHIsIG4sIGkpIHtcbiAgICBzdXBlcihyKSwgdGhpcy5mcmFnT2Zmc2V0ID0gMCwgdGhpcy5kdXJhdGlvbiA9IDAsIHRoaXMuZ2FwID0gITEsIHRoaXMuaW5kZXBlbmRlbnQgPSAhMSwgdGhpcy5yZWx1cmwgPSB2b2lkIDAsIHRoaXMuZnJhZ21lbnQgPSB2b2lkIDAsIHRoaXMuaW5kZXggPSB2b2lkIDAsIHRoaXMuZHVyYXRpb24gPSBlLmRlY2ltYWxGbG9hdGluZ1BvaW50KFwiRFVSQVRJT05cIiksIHRoaXMuZ2FwID0gZS5ib29sKFwiR0FQXCIpLCB0aGlzLmluZGVwZW5kZW50ID0gZS5ib29sKFwiSU5ERVBFTkRFTlRcIiksIHRoaXMucmVsdXJsID0gZS5lbnVtZXJhdGVkU3RyaW5nKFwiVVJJXCIpLCB0aGlzLmZyYWdtZW50ID0gdCwgdGhpcy5pbmRleCA9IG47XG4gICAgY29uc3QgbyA9IGUuZW51bWVyYXRlZFN0cmluZyhcIkJZVEVSQU5HRVwiKTtcbiAgICBvICYmIHRoaXMuc2V0Qnl0ZVJhbmdlKG8sIGkpLCBpICYmICh0aGlzLmZyYWdPZmZzZXQgPSBpLmZyYWdPZmZzZXQgKyBpLmR1cmF0aW9uKTtcbiAgfVxuICBnZXQgc3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJhZ21lbnQuc3RhcnQgKyB0aGlzLmZyYWdPZmZzZXQ7XG4gIH1cbiAgZ2V0IGVuZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFydCArIHRoaXMuZHVyYXRpb247XG4gIH1cbiAgZ2V0IGxvYWRlZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50YXJ5U3RyZWFtczogZVxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiAhIShlLmF1ZGlvIHx8IGUudmlkZW8gfHwgZS5hdWRpb3ZpZGVvKTtcbiAgfVxufVxuZnVuY3Rpb24gUmcocywgZSkge1xuICBjb25zdCB0ID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHMpO1xuICBpZiAodCkge1xuICAgIGNvbnN0IHIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIGUpO1xuICAgIHJldHVybiByIHx8IFJnKHQsIGUpO1xuICB9XG59XG5mdW5jdGlvbiBNUyhzLCBlKSB7XG4gIGNvbnN0IHQgPSBSZyhzLCBlKTtcbiAgdCAmJiAodC5lbnVtZXJhYmxlID0gITAsIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLCBlLCB0KSk7XG59XG5jb25zdCBlaCA9IE1hdGgucG93KDIsIDMyKSAtIDEsIE9TID0gW10ucHVzaCwgTGcgPSB7XG4gIHZpZGVvOiAxLFxuICBhdWRpbzogMixcbiAgaWQzOiAzLFxuICB0ZXh0OiA0XG59O1xuZnVuY3Rpb24ganQocykge1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBzKTtcbn1cbmZ1bmN0aW9uIENnKHMsIGUpIHtcbiAgY29uc3QgdCA9IHNbZV0gPDwgOCB8IHNbZSArIDFdO1xuICByZXR1cm4gdCA8IDAgPyA2NTUzNiArIHQgOiB0O1xufVxuZnVuY3Rpb24gSWUocywgZSkge1xuICBjb25zdCB0ID0ga2cocywgZSk7XG4gIHJldHVybiB0IDwgMCA/IDQyOTQ5NjcyOTYgKyB0IDogdDtcbn1cbmZ1bmN0aW9uIHRoKHMsIGUpIHtcbiAgbGV0IHQgPSBJZShzLCBlKTtcbiAgcmV0dXJuIHQgKj0gTWF0aC5wb3coMiwgMzIpLCB0ICs9IEllKHMsIGUgKyA0KSwgdDtcbn1cbmZ1bmN0aW9uIGtnKHMsIGUpIHtcbiAgcmV0dXJuIHNbZV0gPDwgMjQgfCBzW2UgKyAxXSA8PCAxNiB8IHNbZSArIDJdIDw8IDggfCBzW2UgKyAzXTtcbn1cbmZ1bmN0aW9uIEJTKHMpIHtcbiAgY29uc3QgZSA9IHMuYnl0ZUxlbmd0aDtcbiAgZm9yIChsZXQgdCA9IDA7IHQgPCBlOyApIHtcbiAgICBjb25zdCByID0gSWUocywgdCk7XG4gICAgaWYgKHIgPiA4ICYmIHNbdCArIDRdID09PSAxMDkgJiYgc1t0ICsgNV0gPT09IDExMSAmJiBzW3QgKyA2XSA9PT0gMTExICYmIHNbdCArIDddID09PSAxMDIpXG4gICAgICByZXR1cm4gITA7XG4gICAgdCA9IHIgPiAxID8gdCArIHIgOiBlO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIEdlKHMsIGUpIHtcbiAgY29uc3QgdCA9IFtdO1xuICBpZiAoIWUubGVuZ3RoKVxuICAgIHJldHVybiB0O1xuICBjb25zdCByID0gcy5ieXRlTGVuZ3RoO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IHI7ICkge1xuICAgIGNvbnN0IGkgPSBJZShzLCBuKSwgbyA9IGp0KHMuc3ViYXJyYXkobiArIDQsIG4gKyA4KSksIGEgPSBpID4gMSA/IG4gKyBpIDogcjtcbiAgICBpZiAobyA9PT0gZVswXSlcbiAgICAgIGlmIChlLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgdC5wdXNoKHMuc3ViYXJyYXkobiArIDgsIGEpKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBsID0gR2Uocy5zdWJhcnJheShuICsgOCwgYSksIGUuc2xpY2UoMSkpO1xuICAgICAgICBsLmxlbmd0aCAmJiBPUy5hcHBseSh0LCBsKTtcbiAgICAgIH1cbiAgICBuID0gYTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIEZTKHMpIHtcbiAgY29uc3QgZSA9IFtdLCB0ID0gc1swXTtcbiAgbGV0IHIgPSA4O1xuICBjb25zdCBuID0gSWUocywgcik7XG4gIHIgKz0gNDtcbiAgbGV0IGkgPSAwLCBvID0gMDtcbiAgdCA9PT0gMCA/IChpID0gSWUocywgciksIG8gPSBJZShzLCByICsgNCksIHIgKz0gOCkgOiAoaSA9IHRoKHMsIHIpLCBvID0gdGgocywgciArIDgpLCByICs9IDE2KSwgciArPSAyO1xuICBsZXQgYSA9IHMubGVuZ3RoICsgbztcbiAgY29uc3QgbCA9IENnKHMsIHIpO1xuICByICs9IDI7XG4gIGZvciAobGV0IGMgPSAwOyBjIDwgbDsgYysrKSB7XG4gICAgbGV0IHUgPSByO1xuICAgIGNvbnN0IGQgPSBJZShzLCB1KTtcbiAgICB1ICs9IDQ7XG4gICAgY29uc3QgaCA9IGQgJiAyMTQ3NDgzNjQ3O1xuICAgIGlmICgoZCAmIDIxNDc0ODM2NDgpID4+PiAzMSA9PT0gMSlcbiAgICAgIHJldHVybiBydC53YXJuKFwiU0lEWCBoYXMgaGllcmFyY2hpY2FsIHJlZmVyZW5jZXMgKG5vdCBzdXBwb3J0ZWQpXCIpLCBudWxsO1xuICAgIGNvbnN0IHAgPSBJZShzLCB1KTtcbiAgICB1ICs9IDQsIGUucHVzaCh7XG4gICAgICByZWZlcmVuY2VTaXplOiBoLFxuICAgICAgc3Vic2VnbWVudER1cmF0aW9uOiBwLFxuICAgICAgLy8gdW5zY2FsZWRcbiAgICAgIGluZm86IHtcbiAgICAgICAgZHVyYXRpb246IHAgLyBuLFxuICAgICAgICBzdGFydDogYSxcbiAgICAgICAgZW5kOiBhICsgaCAtIDFcbiAgICAgIH1cbiAgICB9KSwgYSArPSBoLCB1ICs9IDQsIHIgPSB1O1xuICB9XG4gIHJldHVybiB7XG4gICAgZWFybGllc3RQcmVzZW50YXRpb25UaW1lOiBpLFxuICAgIHRpbWVzY2FsZTogbixcbiAgICB2ZXJzaW9uOiB0LFxuICAgIHJlZmVyZW5jZXNDb3VudDogbCxcbiAgICByZWZlcmVuY2VzOiBlXG4gIH07XG59XG5mdW5jdGlvbiBEZyhzKSB7XG4gIGNvbnN0IGUgPSBbXSwgdCA9IEdlKHMsIFtcIm1vb3ZcIiwgXCJ0cmFrXCJdKTtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgY29uc3QgaSA9IHRbbl0sIG8gPSBHZShpLCBbXCJ0a2hkXCJdKVswXTtcbiAgICBpZiAobykge1xuICAgICAgbGV0IGEgPSBvWzBdO1xuICAgICAgY29uc3QgbCA9IEllKG8sIGEgPT09IDAgPyAxMiA6IDIwKSwgYyA9IEdlKGksIFtcIm1kaWFcIiwgXCJtZGhkXCJdKVswXTtcbiAgICAgIGlmIChjKSB7XG4gICAgICAgIGEgPSBjWzBdO1xuICAgICAgICBjb25zdCB1ID0gSWUoYywgYSA9PT0gMCA/IDEyIDogMjApLCBkID0gR2UoaSwgW1wibWRpYVwiLCBcImhkbHJcIl0pWzBdO1xuICAgICAgICBpZiAoZCkge1xuICAgICAgICAgIGNvbnN0IGggPSBqdChkLnN1YmFycmF5KDgsIDEyKSksIGYgPSB7XG4gICAgICAgICAgICBzb3VuOiBvdC5BVURJTyxcbiAgICAgICAgICAgIHZpZGU6IG90LlZJREVPXG4gICAgICAgICAgfVtoXSwgcCA9IEdlKGksIFtcIm1kaWFcIiwgXCJtaW5mXCIsIFwic3RibFwiLCBcInN0c2RcIl0pWzBdLCB5ID0gTlMocCk7XG4gICAgICAgICAgZiA/IChlW2xdID0ge1xuICAgICAgICAgICAgdGltZXNjYWxlOiB1LFxuICAgICAgICAgICAgdHlwZTogZixcbiAgICAgICAgICAgIHN0c2Q6IHlcbiAgICAgICAgICB9LCBlW2ZdID0gdHQoe1xuICAgICAgICAgICAgdGltZXNjYWxlOiB1LFxuICAgICAgICAgICAgaWQ6IGxcbiAgICAgICAgICB9LCB5KSkgOiBlW2xdID0ge1xuICAgICAgICAgICAgdGltZXNjYWxlOiB1LFxuICAgICAgICAgICAgdHlwZTogaCxcbiAgICAgICAgICAgIHN0c2Q6IHlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBHZShzLCBbXCJtb292XCIsIFwibXZleFwiLCBcInRyZXhcIl0pLmZvckVhY2goKG4pID0+IHtcbiAgICBjb25zdCBpID0gSWUobiwgNCksIG8gPSBlW2ldO1xuICAgIG8gJiYgKG8uZGVmYXVsdCA9IHtcbiAgICAgIGR1cmF0aW9uOiBJZShuLCAxMiksXG4gICAgICBmbGFnczogSWUobiwgMjApXG4gICAgfSk7XG4gIH0pLCBlO1xufVxuZnVuY3Rpb24gTlMocykge1xuICBjb25zdCBlID0gcy5zdWJhcnJheSg4KSwgdCA9IGUuc3ViYXJyYXkoODYpLCByID0ganQoZS5zdWJhcnJheSg0LCA4KSk7XG4gIGxldCBuID0gciwgaTtcbiAgY29uc3QgbyA9IHIgPT09IFwiZW5jYVwiIHx8IHIgPT09IFwiZW5jdlwiO1xuICBpZiAobykge1xuICAgIGNvbnN0IGMgPSBHZShlLCBbcl0pWzBdLnN1YmFycmF5KHIgPT09IFwiZW5jYVwiID8gMjggOiA3OCk7XG4gICAgR2UoYywgW1wic2luZlwiXSkuZm9yRWFjaCgoZCkgPT4ge1xuICAgICAgY29uc3QgaCA9IEdlKGQsIFtcInNjaG1cIl0pWzBdO1xuICAgICAgaWYgKGgpIHtcbiAgICAgICAgY29uc3QgZiA9IGp0KGguc3ViYXJyYXkoNCwgOCkpO1xuICAgICAgICBpZiAoZiA9PT0gXCJjYmNzXCIgfHwgZiA9PT0gXCJjZW5jXCIpIHtcbiAgICAgICAgICBjb25zdCBwID0gR2UoZCwgW1wiZnJtYVwiXSlbMF07XG4gICAgICAgICAgcCAmJiAobiA9IGp0KHApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGEgPSBuO1xuICBzd2l0Y2ggKG4pIHtcbiAgICBjYXNlIFwiYXZjMVwiOlxuICAgIGNhc2UgXCJhdmMyXCI6XG4gICAgY2FzZSBcImF2YzNcIjpcbiAgICBjYXNlIFwiYXZjNFwiOiB7XG4gICAgICBjb25zdCBsID0gR2UodCwgW1wiYXZjQ1wiXSlbMF07XG4gICAgICBsICYmIGwubGVuZ3RoID4gMyAmJiAobiArPSBcIi5cIiArIEtpKGxbMV0pICsgS2kobFsyXSkgKyBLaShsWzNdKSwgaSA9IGppKGEgPT09IFwiYXZjMVwiID8gXCJkdmExXCIgOiBcImR2YXZcIiwgdCkpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJtcDRhXCI6IHtcbiAgICAgIGNvbnN0IGwgPSBHZShlLCBbcl0pWzBdLCBjID0gR2UobC5zdWJhcnJheSgyOCksIFtcImVzZHNcIl0pWzBdO1xuICAgICAgaWYgKGMgJiYgYy5sZW5ndGggPiA3KSB7XG4gICAgICAgIGxldCB1ID0gNDtcbiAgICAgICAgaWYgKGNbdSsrXSAhPT0gMylcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgdSA9IGRsKGMsIHUpLCB1ICs9IDI7XG4gICAgICAgIGNvbnN0IGQgPSBjW3UrK107XG4gICAgICAgIGlmIChkICYgMTI4ICYmICh1ICs9IDIpLCBkICYgNjQgJiYgKHUgKz0gY1t1KytdKSwgY1t1KytdICE9PSA0KVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB1ID0gZGwoYywgdSk7XG4gICAgICAgIGNvbnN0IGggPSBjW3UrK107XG4gICAgICAgIGlmIChoID09PSA2NClcbiAgICAgICAgICBuICs9IFwiLlwiICsgS2koaCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHUgKz0gMTIsIGNbdSsrXSAhPT0gNSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgdSA9IGRsKGMsIHUpO1xuICAgICAgICBjb25zdCBmID0gY1t1KytdO1xuICAgICAgICBsZXQgcCA9IChmICYgMjQ4KSA+PiAzO1xuICAgICAgICBwID09PSAzMSAmJiAocCArPSAxICsgKChmICYgNykgPDwgMykgKyAoKGNbdV0gJiAyMjQpID4+IDUpKSwgbiArPSBcIi5cIiArIHA7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImh2YzFcIjpcbiAgICBjYXNlIFwiaGV2MVwiOiB7XG4gICAgICBjb25zdCBsID0gR2UodCwgW1wiaHZjQ1wiXSlbMF07XG4gICAgICBpZiAobCAmJiBsLmxlbmd0aCA+IDEyKSB7XG4gICAgICAgIGNvbnN0IGMgPSBsWzFdLCB1ID0gW1wiXCIsIFwiQVwiLCBcIkJcIiwgXCJDXCJdW2MgPj4gNl0sIGQgPSBjICYgMzEsIGggPSBJZShsLCAyKSwgZiA9IChjICYgMzIpID4+IDUgPyBcIkhcIiA6IFwiTFwiLCBwID0gbFsxMl0sIHkgPSBsLnN1YmFycmF5KDYsIDEyKTtcbiAgICAgICAgbiArPSBcIi5cIiArIHUgKyBkLCBuICs9IFwiLlwiICsgVVMoaCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCksIG4gKz0gXCIuXCIgKyBmICsgcDtcbiAgICAgICAgbGV0IEUgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBiID0geS5sZW5ndGg7IGItLTsgKSB7XG4gICAgICAgICAgY29uc3QgUiA9IHlbYl07XG4gICAgICAgICAgKFIgfHwgRSkgJiYgKEUgPSBcIi5cIiArIFIudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyBFKTtcbiAgICAgICAgfVxuICAgICAgICBuICs9IEU7XG4gICAgICB9XG4gICAgICBpID0gamkoYSA9PSBcImhldjFcIiA/IFwiZHZoZVwiIDogXCJkdmgxXCIsIHQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJkdmgxXCI6XG4gICAgY2FzZSBcImR2aGVcIjpcbiAgICBjYXNlIFwiZHZhdlwiOlxuICAgIGNhc2UgXCJkdmExXCI6XG4gICAgY2FzZSBcImRhdjFcIjoge1xuICAgICAgbiA9IGppKG4sIHQpIHx8IG47XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInZwMDlcIjoge1xuICAgICAgY29uc3QgbCA9IEdlKHQsIFtcInZwY0NcIl0pWzBdO1xuICAgICAgaWYgKGwgJiYgbC5sZW5ndGggPiA2KSB7XG4gICAgICAgIGNvbnN0IGMgPSBsWzRdLCB1ID0gbFs1XSwgZCA9IGxbNl0gPj4gNCAmIDE1O1xuICAgICAgICBuICs9IFwiLlwiICsgVnIoYykgKyBcIi5cIiArIFZyKHUpICsgXCIuXCIgKyBWcihkKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwiYXYwMVwiOiB7XG4gICAgICBjb25zdCBsID0gR2UodCwgW1wiYXYxQ1wiXSlbMF07XG4gICAgICBpZiAobCAmJiBsLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgY29uc3QgYyA9IGxbMV0gPj4+IDUsIHUgPSBsWzFdICYgMzEsIGQgPSBsWzJdID4+PiA3ID8gXCJIXCIgOiBcIk1cIiwgaCA9IChsWzJdICYgNjQpID4+IDYsIGYgPSAobFsyXSAmIDMyKSA+PiA1LCBwID0gYyA9PT0gMiAmJiBoID8gZiA/IDEyIDogMTAgOiBoID8gMTAgOiA4LCB5ID0gKGxbMl0gJiAxNikgPj4gNCwgRSA9IChsWzJdICYgOCkgPj4gMywgYiA9IChsWzJdICYgNCkgPj4gMiwgUiA9IGxbMl0gJiAzO1xuICAgICAgICBuICs9IFwiLlwiICsgYyArIFwiLlwiICsgVnIodSkgKyBkICsgXCIuXCIgKyBWcihwKSArIFwiLlwiICsgeSArIFwiLlwiICsgRSArIGIgKyBSICsgXCIuXCIgKyBWcigxKSArIFwiLlwiICsgVnIoMSkgKyBcIi5cIiArIFZyKDEpICsgXCIuXCIgKyAwLCBpID0gamkoXCJkYXYxXCIsIHQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgY29kZWM6IG4sXG4gICAgZW5jcnlwdGVkOiBvLFxuICAgIHN1cHBsZW1lbnRhbDogaVxuICB9O1xufVxuZnVuY3Rpb24gamkocywgZSkge1xuICBjb25zdCB0ID0gR2UoZSwgW1wiZHZ2Q1wiXSksIHIgPSB0Lmxlbmd0aCA/IHRbMF0gOiBHZShlLCBbXCJkdmNDXCJdKVswXTtcbiAgaWYgKHIpIHtcbiAgICBjb25zdCBuID0gclsyXSA+PiAxICYgMTI3LCBpID0gclsyXSA8PCA1ICYgMzIgfCByWzNdID4+IDMgJiAzMTtcbiAgICByZXR1cm4gcyArIFwiLlwiICsgVnIobikgKyBcIi5cIiArIFZyKGkpO1xuICB9XG59XG5mdW5jdGlvbiBVUyhzKSB7XG4gIGxldCBlID0gMDtcbiAgZm9yIChsZXQgdCA9IDA7IHQgPCAzMjsgdCsrKVxuICAgIGUgfD0gKHMgPj4gdCAmIDEpIDw8IDMxIC0gdDtcbiAgcmV0dXJuIGUgPj4+IDA7XG59XG5mdW5jdGlvbiBkbChzLCBlKSB7XG4gIGNvbnN0IHQgPSBlICsgNTtcbiAgZm9yICg7IHNbZSsrXSAmIDEyOCAmJiBlIDwgdDsgKVxuICAgIDtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiBLaShzKSB7XG4gIHJldHVybiAoXCIwXCIgKyBzLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpKS5zbGljZSgtMik7XG59XG5mdW5jdGlvbiBWcihzKSB7XG4gIHJldHVybiAocyA8IDEwID8gXCIwXCIgOiBcIlwiKSArIHM7XG59XG5mdW5jdGlvbiAkUyhzLCBlKSB7XG4gIGlmICghcyB8fCAhZSlcbiAgICByZXR1cm47XG4gIGNvbnN0IHQgPSBlLmtleUlkO1xuICB0ICYmIGUuaXNDb21tb25FbmNyeXB0aW9uICYmIEdlKHMsIFtcIm1vb3ZcIiwgXCJ0cmFrXCJdKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgY29uc3QgbyA9IEdlKG4sIFtcIm1kaWFcIiwgXCJtaW5mXCIsIFwic3RibFwiLCBcInN0c2RcIl0pWzBdLnN1YmFycmF5KDgpO1xuICAgIGxldCBhID0gR2UobywgW1wiZW5jYVwiXSk7XG4gICAgY29uc3QgbCA9IGEubGVuZ3RoID4gMDtcbiAgICBsIHx8IChhID0gR2UobywgW1wiZW5jdlwiXSkpLCBhLmZvckVhY2goKGMpID0+IHtcbiAgICAgIGNvbnN0IHUgPSBsID8gYy5zdWJhcnJheSgyOCkgOiBjLnN1YmFycmF5KDc4KTtcbiAgICAgIEdlKHUsIFtcInNpbmZcIl0pLmZvckVhY2goKGgpID0+IHtcbiAgICAgICAgY29uc3QgZiA9IFBnKGgpO1xuICAgICAgICBpZiAoZikge1xuICAgICAgICAgIGNvbnN0IHAgPSBmLnN1YmFycmF5KDgsIDI0KTtcbiAgICAgICAgICBwLnNvbWUoKHkpID0+IHkgIT09IDApIHx8IChydC5sb2coYFtlbWVdIFBhdGNoaW5nIGtleUlkIGluICdlbmMke2wgPyBcImFcIiA6IFwidlwifT5zaW5mPj50ZW5jJyBib3g6ICR7ZnIocCl9IC0+ICR7ZnIodCl9YCksIGYuc2V0KHQsIDgpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gUGcocykge1xuICBjb25zdCBlID0gR2UocywgW1wic2NobVwiXSlbMF07XG4gIGlmIChlKSB7XG4gICAgY29uc3QgdCA9IGp0KGUuc3ViYXJyYXkoNCwgOCkpO1xuICAgIGlmICh0ID09PSBcImNiY3NcIiB8fCB0ID09PSBcImNlbmNcIilcbiAgICAgIHJldHVybiBHZShzLCBbXCJzY2hpXCIsIFwidGVuY1wiXSlbMF07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBHUyhzLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSB7fSwgbiA9IEdlKHMsIFtcIm1vb2ZcIiwgXCJ0cmFmXCJdKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbyA9IG5baV0sIGEgPSBHZShvLCBbXCJ0ZmhkXCJdKVswXSwgbCA9IEllKGEsIDQpLCBjID0gZVtsXTtcbiAgICBpZiAoIWMpXG4gICAgICBjb250aW51ZTtcbiAgICByW2xdIHx8IChyW2xdID0ge1xuICAgICAgc3RhcnQ6IE5hTixcbiAgICAgIGR1cmF0aW9uOiAwLFxuICAgICAgc2FtcGxlQ291bnQ6IDAsXG4gICAgICB0aW1lc2NhbGU6IGMudGltZXNjYWxlLFxuICAgICAgdHlwZTogYy50eXBlXG4gICAgfSk7XG4gICAgY29uc3QgdSA9IHJbbF0sIGQgPSBHZShvLCBbXCJ0ZmR0XCJdKVswXTtcbiAgICBpZiAoZCkge1xuICAgICAgY29uc3QgQSA9IGRbMF07XG4gICAgICBsZXQgRiA9IEllKGQsIDQpO1xuICAgICAgQSA9PT0gMSAmJiAoRiA9PT0gZWggPyB0Lndhcm4oXCJbbXA0LWRlbXV4ZXJdOiBJZ25vcmluZyBhc3N1bWVkIGludmFsaWQgc2lnbmVkIDY0LWJpdCB0cmFjayBmcmFnbWVudCBkZWNvZGUgdGltZVwiKSA6IChGICo9IGVoICsgMSwgRiArPSBJZShkLCA4KSkpLCB1ZShGKSAmJiAoIXVlKHUuc3RhcnQpIHx8IEYgPCB1LnN0YXJ0KSAmJiAodS5zdGFydCA9IEYpO1xuICAgIH1cbiAgICBjb25zdCBoID0gYy5kZWZhdWx0LCBmID0gSWUoYSwgMCkgfCAoaCA9PSBudWxsID8gdm9pZCAwIDogaC5mbGFncyk7XG4gICAgbGV0IHAgPSAoaCA9PSBudWxsID8gdm9pZCAwIDogaC5kdXJhdGlvbikgfHwgMDtcbiAgICBmICYgOCAmJiAoZiAmIDIgPyBwID0gSWUoYSwgMTIpIDogcCA9IEllKGEsIDgpKTtcbiAgICBjb25zdCB5ID0gR2UobywgW1widHJ1blwiXSk7XG4gICAgbGV0IEUgPSB1LnN0YXJ0IHx8IDAsIGIgPSAwLCBSID0gcDtcbiAgICBmb3IgKGxldCBBID0gMDsgQSA8IHkubGVuZ3RoOyBBKyspIHtcbiAgICAgIGNvbnN0IEYgPSB5W0FdLCBNID0gSWUoRiwgNCksIEggPSB1LnNhbXBsZUNvdW50O1xuICAgICAgdS5zYW1wbGVDb3VudCArPSBNO1xuICAgICAgY29uc3QgSyA9IEZbM10gJiAxLCBqID0gRlszXSAmIDQsIEMgPSBGWzJdICYgMSwgayA9IEZbMl0gJiAyLCAkID0gRlsyXSAmIDQsIFcgPSBGWzJdICYgODtcbiAgICAgIGxldCBfID0gOCwgZyA9IE07XG4gICAgICBmb3IgKEsgJiYgKF8gKz0gNCksIGogJiYgTSAmJiAoIShGW18gKyAxXSAmIDEpICYmIHUua2V5RnJhbWVJbmRleCA9PT0gdm9pZCAwICYmICh1LmtleUZyYW1lSW5kZXggPSBIKSwgXyArPSA0LCBDID8gKFIgPSBJZShGLCBfKSwgXyArPSA0KSA6IFIgPSBwLCBrICYmIChfICs9IDQpLCBXICYmIChfICs9IDQpLCBFICs9IFIsIGIgKz0gUiwgZy0tKTsgZy0tOyApXG4gICAgICAgIEMgPyAoUiA9IEllKEYsIF8pLCBfICs9IDQpIDogUiA9IHAsIGsgJiYgKF8gKz0gNCksICQgJiYgKEZbXyArIDFdICYgMSB8fCB1LmtleUZyYW1lSW5kZXggPT09IHZvaWQgMCAmJiAodS5rZXlGcmFtZUluZGV4ID0gdS5zYW1wbGVDb3VudCAtIChnICsgMSksIHUua2V5RnJhbWVTdGFydCA9IEUpLCBfICs9IDQpLCBXICYmIChfICs9IDQpLCBFICs9IFIsIGIgKz0gUjtcbiAgICAgICFiICYmIHAgJiYgKGIgKz0gcCAqIE0pO1xuICAgIH1cbiAgICB1LmR1cmF0aW9uICs9IGI7XG4gIH1cbiAgaWYgKCFPYmplY3Qua2V5cyhyKS5zb21lKChpKSA9PiByW2ldLmR1cmF0aW9uKSkge1xuICAgIGxldCBpID0gMSAvIDAsIG8gPSAwO1xuICAgIGNvbnN0IGEgPSBHZShzLCBbXCJzaWR4XCJdKTtcbiAgICBmb3IgKGxldCBsID0gMDsgbCA8IGEubGVuZ3RoOyBsKyspIHtcbiAgICAgIGNvbnN0IGMgPSBGUyhhW2xdKTtcbiAgICAgIGlmIChjICE9IG51bGwgJiYgYy5yZWZlcmVuY2VzKSB7XG4gICAgICAgIGkgPSBNYXRoLm1pbihpLCBjLmVhcmxpZXN0UHJlc2VudGF0aW9uVGltZSAvIGMudGltZXNjYWxlKTtcbiAgICAgICAgY29uc3QgdSA9IGMucmVmZXJlbmNlcy5yZWR1Y2UoKGQsIGgpID0+IGQgKyBoLmluZm8uZHVyYXRpb24gfHwgMCwgMCk7XG4gICAgICAgIG8gPSBNYXRoLm1heChvLCB1ICsgYy5lYXJsaWVzdFByZXNlbnRhdGlvblRpbWUgLyBjLnRpbWVzY2FsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIG8gJiYgdWUobykgJiYgT2JqZWN0LmtleXMocikuZm9yRWFjaCgobCkgPT4ge1xuICAgICAgcltsXS5kdXJhdGlvbiB8fCAocltsXS5kdXJhdGlvbiA9IG8gKiByW2xdLnRpbWVzY2FsZSAtIHJbbF0uc3RhcnQpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24gVlMocykge1xuICBjb25zdCBlID0ge1xuICAgIHZhbGlkOiBudWxsLFxuICAgIHJlbWFpbmRlcjogbnVsbFxuICB9LCB0ID0gR2UocywgW1wibW9vZlwiXSk7XG4gIGlmICh0Lmxlbmd0aCA8IDIpXG4gICAgcmV0dXJuIGUucmVtYWluZGVyID0gcywgZTtcbiAgY29uc3QgciA9IHRbdC5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGUudmFsaWQgPSBzLnNsaWNlKDAsIHIuYnl0ZU9mZnNldCAtIDgpLCBlLnJlbWFpbmRlciA9IHMuc2xpY2Uoci5ieXRlT2Zmc2V0IC0gOCksIGU7XG59XG5mdW5jdGlvbiBfcihzLCBlKSB7XG4gIGNvbnN0IHQgPSBuZXcgVWludDhBcnJheShzLmxlbmd0aCArIGUubGVuZ3RoKTtcbiAgcmV0dXJuIHQuc2V0KHMpLCB0LnNldChlLCBzLmxlbmd0aCksIHQ7XG59XG5mdW5jdGlvbiByaChzLCBlKSB7XG4gIGNvbnN0IHQgPSBbXSwgciA9IGUuc2FtcGxlcywgbiA9IGUudGltZXNjYWxlLCBpID0gZS5pZDtcbiAgbGV0IG8gPSAhMTtcbiAgcmV0dXJuIEdlKHIsIFtcIm1vb2ZcIl0pLm1hcCgobCkgPT4ge1xuICAgIGNvbnN0IGMgPSBsLmJ5dGVPZmZzZXQgLSA4O1xuICAgIEdlKGwsIFtcInRyYWZcIl0pLm1hcCgoZCkgPT4ge1xuICAgICAgY29uc3QgaCA9IEdlKGQsIFtcInRmZHRcIl0pLm1hcCgoZikgPT4ge1xuICAgICAgICBjb25zdCBwID0gZlswXTtcbiAgICAgICAgbGV0IHkgPSBJZShmLCA0KTtcbiAgICAgICAgcmV0dXJuIHAgPT09IDEgJiYgKHkgKj0gTWF0aC5wb3coMiwgMzIpLCB5ICs9IEllKGYsIDgpKSwgeSAvIG47XG4gICAgICB9KVswXTtcbiAgICAgIHJldHVybiBoICE9PSB2b2lkIDAgJiYgKHMgPSBoKSwgR2UoZCwgW1widGZoZFwiXSkubWFwKChmKSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBJZShmLCA0KSwgeSA9IEllKGYsIDApICYgMTY3NzcyMTUsIEUgPSAoeSAmIDEpICE9PSAwLCBiID0gKHkgJiAyKSAhPT0gMCwgUiA9ICh5ICYgOCkgIT09IDA7XG4gICAgICAgIGxldCBBID0gMDtcbiAgICAgICAgY29uc3QgRiA9ICh5ICYgMTYpICE9PSAwO1xuICAgICAgICBsZXQgTSA9IDA7XG4gICAgICAgIGNvbnN0IEggPSAoeSAmIDMyKSAhPT0gMDtcbiAgICAgICAgbGV0IEsgPSA4O1xuICAgICAgICBwID09PSBpICYmIChFICYmIChLICs9IDgpLCBiICYmIChLICs9IDQpLCBSICYmIChBID0gSWUoZiwgSyksIEsgKz0gNCksIEYgJiYgKE0gPSBJZShmLCBLKSwgSyArPSA0KSwgSCAmJiAoSyArPSA0KSwgZS50eXBlID09PSBcInZpZGVvXCIgJiYgKG8gPSB5YShlLmNvZGVjKSksIEdlKGQsIFtcInRydW5cIl0pLm1hcCgoaikgPT4ge1xuICAgICAgICAgIGNvbnN0IEMgPSBqWzBdLCBrID0gSWUoaiwgMCkgJiAxNjc3NzIxNSwgJCA9IChrICYgMSkgIT09IDA7XG4gICAgICAgICAgbGV0IFcgPSAwO1xuICAgICAgICAgIGNvbnN0IF8gPSAoayAmIDQpICE9PSAwLCBnID0gKGsgJiAyNTYpICE9PSAwO1xuICAgICAgICAgIGxldCB4ID0gMDtcbiAgICAgICAgICBjb25zdCB3ID0gKGsgJiA1MTIpICE9PSAwO1xuICAgICAgICAgIGxldCBEID0gMDtcbiAgICAgICAgICBjb25zdCBPID0gKGsgJiAxMDI0KSAhPT0gMCwgVSA9IChrICYgMjA0OCkgIT09IDA7XG4gICAgICAgICAgbGV0IFYgPSAwO1xuICAgICAgICAgIGNvbnN0IEwgPSBJZShqLCA0KTtcbiAgICAgICAgICBsZXQgbSA9IDg7XG4gICAgICAgICAgJCAmJiAoVyA9IEllKGosIG0pLCBtICs9IDQpLCBfICYmIChtICs9IDQpO1xuICAgICAgICAgIGxldCB2ID0gVyArIGM7XG4gICAgICAgICAgZm9yIChsZXQgUCA9IDA7IFAgPCBMOyBQKyspIHtcbiAgICAgICAgICAgIGlmIChnID8gKHggPSBJZShqLCBtKSwgbSArPSA0KSA6IHggPSBBLCB3ID8gKEQgPSBJZShqLCBtKSwgbSArPSA0KSA6IEQgPSBNLCBPICYmIChtICs9IDQpLCBVICYmIChDID09PSAwID8gViA9IEllKGosIG0pIDogViA9IGtnKGosIG0pLCBtICs9IDQpLCBlLnR5cGUgPT09IG90LlZJREVPKSB7XG4gICAgICAgICAgICAgIGxldCBOID0gMDtcbiAgICAgICAgICAgICAgZm9yICg7IE4gPCBEOyApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBZID0gSWUociwgdik7XG4gICAgICAgICAgICAgICAgaWYgKHYgKz0gNCwgalMobywgclt2XSkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGVlID0gci5zdWJhcnJheSh2LCB2ICsgWSk7XG4gICAgICAgICAgICAgICAgICBndShlZSwgbyA/IDIgOiAxLCBzICsgViAvIG4sIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2ICs9IFksIE4gKz0gWSArIDQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMgKz0geCAvIG47XG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSksIHQ7XG59XG5mdW5jdGlvbiB5YShzKSB7XG4gIGlmICghcylcbiAgICByZXR1cm4gITE7XG4gIGNvbnN0IGUgPSBzLnN1YnN0cmluZygwLCA0KTtcbiAgcmV0dXJuIGUgPT09IFwiaHZjMVwiIHx8IGUgPT09IFwiaGV2MVwiIHx8IC8vIERvbGJ5IFZpc2lvblxuICBlID09PSBcImR2aDFcIiB8fCBlID09PSBcImR2aGVcIjtcbn1cbmZ1bmN0aW9uIGpTKHMsIGUpIHtcbiAgaWYgKHMpIHtcbiAgICBjb25zdCB0ID0gZSA+PiAxICYgNjM7XG4gICAgcmV0dXJuIHQgPT09IDM5IHx8IHQgPT09IDQwO1xuICB9IGVsc2VcbiAgICByZXR1cm4gKGUgJiAzMSkgPT09IDY7XG59XG5mdW5jdGlvbiBndShzLCBlLCB0LCByKSB7XG4gIGNvbnN0IG4gPSBNZyhzKTtcbiAgbGV0IGkgPSAwO1xuICBpICs9IGU7XG4gIGxldCBvID0gMCwgYSA9IDAsIGwgPSAwO1xuICBmb3IgKDsgaSA8IG4ubGVuZ3RoOyApIHtcbiAgICBvID0gMDtcbiAgICBkbyB7XG4gICAgICBpZiAoaSA+PSBuLmxlbmd0aClcbiAgICAgICAgYnJlYWs7XG4gICAgICBsID0gbltpKytdLCBvICs9IGw7XG4gICAgfSB3aGlsZSAobCA9PT0gMjU1KTtcbiAgICBhID0gMDtcbiAgICBkbyB7XG4gICAgICBpZiAoaSA+PSBuLmxlbmd0aClcbiAgICAgICAgYnJlYWs7XG4gICAgICBsID0gbltpKytdLCBhICs9IGw7XG4gICAgfSB3aGlsZSAobCA9PT0gMjU1KTtcbiAgICBjb25zdCBjID0gbi5sZW5ndGggLSBpO1xuICAgIGxldCB1ID0gaTtcbiAgICBpZiAoYSA8IGMpXG4gICAgICBpICs9IGE7XG4gICAgZWxzZSBpZiAoYSA+IGMpIHtcbiAgICAgIHJ0LmVycm9yKGBNYWxmb3JtZWQgU0VJIHBheWxvYWQuICR7YX0gaXMgdG9vIHNtYWxsLCBvbmx5ICR7Y30gYnl0ZXMgbGVmdCB0byBwYXJzZS5gKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAobyA9PT0gNCkge1xuICAgICAgaWYgKG5bdSsrXSA9PT0gMTgxKSB7XG4gICAgICAgIGNvbnN0IGggPSBDZyhuLCB1KTtcbiAgICAgICAgaWYgKHUgKz0gMiwgaCA9PT0gNDkpIHtcbiAgICAgICAgICBjb25zdCBmID0gSWUobiwgdSk7XG4gICAgICAgICAgaWYgKHUgKz0gNCwgZiA9PT0gMTE5NTQ1NjgyMCkge1xuICAgICAgICAgICAgY29uc3QgcCA9IG5bdSsrXTtcbiAgICAgICAgICAgIGlmIChwID09PSAzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHkgPSBuW3UrK10sIEUgPSAzMSAmIHksIGIgPSA2NCAmIHksIFIgPSBiID8gMiArIEUgKiAzIDogMCwgQSA9IG5ldyBVaW50OEFycmF5KFIpO1xuICAgICAgICAgICAgICBpZiAoYikge1xuICAgICAgICAgICAgICAgIEFbMF0gPSB5O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IEYgPSAxOyBGIDwgUjsgRisrKVxuICAgICAgICAgICAgICAgICAgQVtGXSA9IG5bdSsrXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IHAsXG4gICAgICAgICAgICAgICAgcGF5bG9hZFR5cGU6IG8sXG4gICAgICAgICAgICAgICAgcHRzOiB0LFxuICAgICAgICAgICAgICAgIGJ5dGVzOiBBXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobyA9PT0gNSAmJiBhID4gMTYpIHtcbiAgICAgIGNvbnN0IGQgPSBbXTtcbiAgICAgIGZvciAobGV0IHAgPSAwOyBwIDwgMTY7IHArKykge1xuICAgICAgICBjb25zdCB5ID0gblt1KytdLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgZC5wdXNoKHkubGVuZ3RoID09IDEgPyBcIjBcIiArIHkgOiB5KSwgKHAgPT09IDMgfHwgcCA9PT0gNSB8fCBwID09PSA3IHx8IHAgPT09IDkpICYmIGQucHVzaChcIi1cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBoID0gYSAtIDE2LCBmID0gbmV3IFVpbnQ4QXJyYXkoaCk7XG4gICAgICBmb3IgKGxldCBwID0gMDsgcCA8IGg7IHArKylcbiAgICAgICAgZltwXSA9IG5bdSsrXTtcbiAgICAgIHIucHVzaCh7XG4gICAgICAgIHBheWxvYWRUeXBlOiBvLFxuICAgICAgICBwdHM6IHQsXG4gICAgICAgIHV1aWQ6IGQuam9pbihcIlwiKSxcbiAgICAgICAgdXNlckRhdGE6IFRyKGYpLFxuICAgICAgICB1c2VyRGF0YUJ5dGVzOiBmXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIE1nKHMpIHtcbiAgY29uc3QgZSA9IHMuYnl0ZUxlbmd0aCwgdCA9IFtdO1xuICBsZXQgciA9IDE7XG4gIGZvciAoOyByIDwgZSAtIDI7IClcbiAgICBzW3JdID09PSAwICYmIHNbciArIDFdID09PSAwICYmIHNbciArIDJdID09PSAzID8gKHQucHVzaChyICsgMiksIHIgKz0gMikgOiByKys7XG4gIGlmICh0Lmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gcztcbiAgY29uc3QgbiA9IGUgLSB0Lmxlbmd0aCwgaSA9IG5ldyBVaW50OEFycmF5KG4pO1xuICBsZXQgbyA9IDA7XG4gIGZvciAociA9IDA7IHIgPCBuOyBvKyssIHIrKylcbiAgICBvID09PSB0WzBdICYmIChvKyssIHQuc2hpZnQoKSksIGlbcl0gPSBzW29dO1xuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIEtTKHMpIHtcbiAgY29uc3QgZSA9IHNbMF07XG4gIGxldCB0ID0gXCJcIiwgciA9IFwiXCIsIG4gPSAwLCBpID0gMCwgbyA9IDAsIGEgPSAwLCBsID0gMCwgYyA9IDA7XG4gIGlmIChlID09PSAwKSB7XG4gICAgZm9yICg7IGp0KHMuc3ViYXJyYXkoYywgYyArIDEpKSAhPT0gXCJcXDBcIjsgKVxuICAgICAgdCArPSBqdChzLnN1YmFycmF5KGMsIGMgKyAxKSksIGMgKz0gMTtcbiAgICBmb3IgKHQgKz0ganQocy5zdWJhcnJheShjLCBjICsgMSkpLCBjICs9IDE7IGp0KHMuc3ViYXJyYXkoYywgYyArIDEpKSAhPT0gXCJcXDBcIjsgKVxuICAgICAgciArPSBqdChzLnN1YmFycmF5KGMsIGMgKyAxKSksIGMgKz0gMTtcbiAgICByICs9IGp0KHMuc3ViYXJyYXkoYywgYyArIDEpKSwgYyArPSAxLCBuID0gSWUocywgMTIpLCBpID0gSWUocywgMTYpLCBhID0gSWUocywgMjApLCBsID0gSWUocywgMjQpLCBjID0gMjg7XG4gIH0gZWxzZSBpZiAoZSA9PT0gMSkge1xuICAgIGMgKz0gNCwgbiA9IEllKHMsIGMpLCBjICs9IDQ7XG4gICAgY29uc3QgZCA9IEllKHMsIGMpO1xuICAgIGMgKz0gNDtcbiAgICBjb25zdCBoID0gSWUocywgYyk7XG4gICAgZm9yIChjICs9IDQsIG8gPSAyICoqIDMyICogZCArIGgsIFNTKG8pIHx8IChvID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsIHJ0Lndhcm4oXCJQcmVzZW50YXRpb24gdGltZSBleGNlZWRzIHNhZmUgaW50ZWdlciBsaW1pdCBhbmQgd3JhcHBlZCB0byBtYXggc2FmZSBpbnRlZ2VyIGluIHBhcnNpbmcgZW1zZyBib3hcIikpLCBhID0gSWUocywgYyksIGMgKz0gNCwgbCA9IEllKHMsIGMpLCBjICs9IDQ7IGp0KHMuc3ViYXJyYXkoYywgYyArIDEpKSAhPT0gXCJcXDBcIjsgKVxuICAgICAgdCArPSBqdChzLnN1YmFycmF5KGMsIGMgKyAxKSksIGMgKz0gMTtcbiAgICBmb3IgKHQgKz0ganQocy5zdWJhcnJheShjLCBjICsgMSkpLCBjICs9IDE7IGp0KHMuc3ViYXJyYXkoYywgYyArIDEpKSAhPT0gXCJcXDBcIjsgKVxuICAgICAgciArPSBqdChzLnN1YmFycmF5KGMsIGMgKyAxKSksIGMgKz0gMTtcbiAgICByICs9IGp0KHMuc3ViYXJyYXkoYywgYyArIDEpKSwgYyArPSAxO1xuICB9XG4gIGNvbnN0IHUgPSBzLnN1YmFycmF5KGMsIHMuYnl0ZUxlbmd0aCk7XG4gIHJldHVybiB7XG4gICAgc2NoZW1lSWRVcmk6IHQsXG4gICAgdmFsdWU6IHIsXG4gICAgdGltZVNjYWxlOiBuLFxuICAgIHByZXNlbnRhdGlvblRpbWU6IG8sXG4gICAgcHJlc2VudGF0aW9uVGltZURlbHRhOiBpLFxuICAgIGV2ZW50RHVyYXRpb246IGEsXG4gICAgaWQ6IGwsXG4gICAgcGF5bG9hZDogdVxuICB9O1xufVxuZnVuY3Rpb24gSFMocywgLi4uZSkge1xuICBjb25zdCB0ID0gZS5sZW5ndGg7XG4gIGxldCByID0gOCwgbiA9IHQ7XG4gIGZvciAoOyBuLS07IClcbiAgICByICs9IGVbbl0uYnl0ZUxlbmd0aDtcbiAgY29uc3QgaSA9IG5ldyBVaW50OEFycmF5KHIpO1xuICBmb3IgKGlbMF0gPSByID4+IDI0ICYgMjU1LCBpWzFdID0gciA+PiAxNiAmIDI1NSwgaVsyXSA9IHIgPj4gOCAmIDI1NSwgaVszXSA9IHIgJiAyNTUsIGkuc2V0KHMsIDQpLCBuID0gMCwgciA9IDg7IG4gPCB0OyBuKyspXG4gICAgaS5zZXQoZVtuXSwgciksIHIgKz0gZVtuXS5ieXRlTGVuZ3RoO1xuICByZXR1cm4gaTtcbn1cbmZ1bmN0aW9uIHFTKHMsIGUsIHQpIHtcbiAgaWYgKHMuYnl0ZUxlbmd0aCAhPT0gMTYpXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHN5c3RlbSBpZFwiKTtcbiAgbGV0IHIsIG47XG4gIHIgPSAwLCBuID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgbGV0IGk7XG4gIHIgPiAwID8gKGkgPSBuZXcgVWludDhBcnJheSg0KSwgZS5sZW5ndGggPiAwICYmIG5ldyBEYXRhVmlldyhpLmJ1ZmZlcikuc2V0VWludDMyKDAsIGUubGVuZ3RoLCAhMSkpIDogaSA9IG5ldyBVaW50OEFycmF5KCk7XG4gIGNvbnN0IG8gPSBuZXcgVWludDhBcnJheSg0KTtcbiAgcmV0dXJuIHQuYnl0ZUxlbmd0aCA+IDAgJiYgbmV3IERhdGFWaWV3KG8uYnVmZmVyKS5zZXRVaW50MzIoMCwgdC5ieXRlTGVuZ3RoLCAhMSksIEhTKFxuICAgIFsxMTIsIDExNSwgMTE1LCAxMDRdLFxuICAgIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIHIsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDBcbiAgICAgIC8vIEZsYWdzXG4gICAgXSksXG4gICAgcyxcbiAgICAvLyAxNiBieXRlc1xuICAgIGksXG4gICAgbixcbiAgICBvLFxuICAgIHRcbiAgKTtcbn1cbmZ1bmN0aW9uIFdTKHMpIHtcbiAgY29uc3QgZSA9IFtdO1xuICBpZiAocyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgY29uc3QgdCA9IHMuYnl0ZUxlbmd0aDtcbiAgICBsZXQgciA9IDA7XG4gICAgZm9yICg7IHIgKyAzMiA8IHQ7ICkge1xuICAgICAgY29uc3QgbiA9IG5ldyBEYXRhVmlldyhzLCByKSwgaSA9IHpTKG4pO1xuICAgICAgZS5wdXNoKGkpLCByICs9IGkuc2l6ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiB6UyhzKSB7XG4gIGNvbnN0IGUgPSBzLmdldFVpbnQzMigwKSwgdCA9IHMuYnl0ZU9mZnNldCwgciA9IHMuYnl0ZUxlbmd0aDtcbiAgaWYgKHIgPCBlKVxuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXQ6IHQsXG4gICAgICBzaXplOiByXG4gICAgfTtcbiAgaWYgKHMuZ2V0VWludDMyKDQpICE9PSAxODg2NjE0Mzc2KVxuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXQ6IHQsXG4gICAgICBzaXplOiBlXG4gICAgfTtcbiAgY29uc3QgaSA9IHMuZ2V0VWludDMyKDgpID4+PiAyNDtcbiAgaWYgKGkgIT09IDAgJiYgaSAhPT0gMSlcbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0OiB0LFxuICAgICAgc2l6ZTogZVxuICAgIH07XG4gIGNvbnN0IG8gPSBzLmJ1ZmZlciwgYSA9IGZyKG5ldyBVaW50OEFycmF5KG8sIHQgKyAxMiwgMTYpKTtcbiAgbGV0IGwgPSBudWxsLCBjID0gbnVsbCwgdSA9IDA7XG4gIGlmIChpID09PSAwKVxuICAgIHUgPSAyODtcbiAgZWxzZSB7XG4gICAgY29uc3QgaCA9IHMuZ2V0VWludDMyKDI4KTtcbiAgICBpZiAoIWggfHwgciA8IDMyICsgaCAqIDE2KVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgb2Zmc2V0OiB0LFxuICAgICAgICBzaXplOiBlXG4gICAgICB9O1xuICAgIGwgPSBbXTtcbiAgICBmb3IgKGxldCBmID0gMDsgZiA8IGg7IGYrKylcbiAgICAgIGwucHVzaChuZXcgVWludDhBcnJheShvLCB0ICsgMzIgKyBmICogMTYsIDE2KSk7XG4gICAgdSA9IDMyICsgaCAqIDE2O1xuICB9XG4gIGlmICghdSlcbiAgICByZXR1cm4ge1xuICAgICAgb2Zmc2V0OiB0LFxuICAgICAgc2l6ZTogZVxuICAgIH07XG4gIGNvbnN0IGQgPSBzLmdldFVpbnQzMih1KTtcbiAgcmV0dXJuIGUgLSAzMiA8IGQgPyB7XG4gICAgb2Zmc2V0OiB0LFxuICAgIHNpemU6IGVcbiAgfSA6IChjID0gbmV3IFVpbnQ4QXJyYXkobywgdCArIHUgKyA0LCBkKSwge1xuICAgIHZlcnNpb246IGksXG4gICAgc3lzdGVtSWQ6IGEsXG4gICAga2lkczogbCxcbiAgICBkYXRhOiBjLFxuICAgIG9mZnNldDogdCxcbiAgICBzaXplOiBlXG4gIH0pO1xufVxuY29uc3QgT2cgPSAoKSA9PiAvXFwoV2luZG93cy4rRmlyZWZveFxcLy9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCksIEZuID0ge1xuICBhdWRpbzoge1xuICAgIGEzZHM6IDEsXG4gICAgXCJhYy0zXCI6IDAuOTUsXG4gICAgXCJhYy00XCI6IDEsXG4gICAgYWxhYzogMC45LFxuICAgIGFsYXc6IDEsXG4gICAgZHJhMTogMSxcbiAgICBcImR0cytcIjogMSxcbiAgICBcImR0cy1cIjogMSxcbiAgICBkdHNjOiAxLFxuICAgIGR0c2U6IDEsXG4gICAgZHRzaDogMSxcbiAgICBcImVjLTNcIjogMC45LFxuICAgIGVuY2E6IDEsXG4gICAgZkxhQzogMC45LFxuICAgIC8vIE1QNC1SQSBsaXN0ZWQgY29kZWMgZW50cnkgZm9yIEZMQUNcbiAgICBmbGFjOiAwLjksXG4gICAgLy8gbGVnYWN5IGJyb3dzZXIgY29kZWMgbmFtZSBmb3IgRkxBQ1xuICAgIEZMQUM6IDAuOSxcbiAgICAvLyBzb21lIG1hbmlmZXN0cyBtYXkgbGlzdCBcIkZMQUNcIiB3aXRoIEFwcGxlJ3MgdG9vbHNcbiAgICBnNzE5OiAxLFxuICAgIGc3MjY6IDEsXG4gICAgbTRhZTogMSxcbiAgICBtaGExOiAxLFxuICAgIG1oYTI6IDEsXG4gICAgbWhtMTogMSxcbiAgICBtaG0yOiAxLFxuICAgIG1scGE6IDEsXG4gICAgbXA0YTogMSxcbiAgICBcInJhdyBcIjogMSxcbiAgICBPcHVzOiAxLFxuICAgIG9wdXM6IDEsXG4gICAgLy8gYnJvd3NlcnMgZXhwZWN0IHRoaXMgdG8gYmUgbG93ZXJjYXNlIGRlc3BpdGUgTVA0UkEgc2F5cyAnT3B1cydcbiAgICBzYW1yOiAxLFxuICAgIHNhd2I6IDEsXG4gICAgc2F3cDogMSxcbiAgICBzZXZjOiAxLFxuICAgIHNxY3A6IDEsXG4gICAgc3NtdjogMSxcbiAgICB0d29zOiAxLFxuICAgIHVsYXc6IDFcbiAgfSxcbiAgdmlkZW86IHtcbiAgICBhdmMxOiAxLFxuICAgIGF2YzI6IDEsXG4gICAgYXZjMzogMSxcbiAgICBhdmM0OiAxLFxuICAgIGF2Y3A6IDEsXG4gICAgYXYwMTogMC44LFxuICAgIGRhdjE6IDAuOCxcbiAgICBkcmFjOiAxLFxuICAgIGR2YTE6IDEsXG4gICAgZHZhdjogMSxcbiAgICBkdmgxOiAwLjcsXG4gICAgZHZoZTogMC43LFxuICAgIGVuY3Y6IDEsXG4gICAgaGV2MTogMC43NSxcbiAgICBodmMxOiAwLjc1LFxuICAgIG1qcDI6IDEsXG4gICAgbXA0djogMSxcbiAgICBtdmMxOiAxLFxuICAgIG12YzI6IDEsXG4gICAgbXZjMzogMSxcbiAgICBtdmM0OiAxLFxuICAgIHJlc3Y6IDEsXG4gICAgcnY2MDogMSxcbiAgICBzMjYzOiAxLFxuICAgIHN2YzE6IDEsXG4gICAgc3ZjMjogMSxcbiAgICBcInZjLTFcIjogMSxcbiAgICB2cDA4OiAxLFxuICAgIHZwMDk6IDAuOVxuICB9LFxuICB0ZXh0OiB7XG4gICAgc3RwcDogMSxcbiAgICB3dnR0OiAxXG4gIH1cbn07XG5mdW5jdGlvbiBwdShzLCBlKSB7XG4gIGNvbnN0IHQgPSBGbltlXTtcbiAgcmV0dXJuICEhdCAmJiAhIXRbcy5zbGljZSgwLCA0KV07XG59XG5mdW5jdGlvbiBnaShzLCBlLCB0ID0gITApIHtcbiAgcmV0dXJuICFzLnNwbGl0KFwiLFwiKS5zb21lKChyKSA9PiAhbXUociwgZSwgdCkpO1xufVxuZnVuY3Rpb24gbXUocywgZSwgdCA9ICEwKSB7XG4gIHZhciByO1xuICBjb25zdCBuID0gTXModCk7XG4gIHJldHVybiAociA9IG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uaXNUeXBlU3VwcG9ydGVkKHBpKHMsIGUpKSkgIT0gbnVsbCA/IHIgOiAhMTtcbn1cbmZ1bmN0aW9uIHBpKHMsIGUpIHtcbiAgcmV0dXJuIGAke2V9L21wNDtjb2RlY3M9JHtzfWA7XG59XG5mdW5jdGlvbiBzaChzKSB7XG4gIGlmIChzKSB7XG4gICAgY29uc3QgZSA9IHMuc3Vic3RyaW5nKDAsIDQpO1xuICAgIHJldHVybiBGbi52aWRlb1tlXTtcbiAgfVxuICByZXR1cm4gMjtcbn1cbmZ1bmN0aW9uIFpvKHMpIHtcbiAgY29uc3QgZSA9IE9nKCk7XG4gIHJldHVybiBzLnNwbGl0KFwiLFwiKS5yZWR1Y2UoKHQsIHIpID0+IHtcbiAgICBjb25zdCBpID0gZSAmJiB5YShyKSA/IDkgOiBGbi52aWRlb1tyXTtcbiAgICByZXR1cm4gaSA/IChpICogMiArIHQpIC8gKHQgPyAzIDogMikgOiAoRm4uYXVkaW9bcl0gKyB0KSAvICh0ID8gMiA6IDEpO1xuICB9LCAwKTtcbn1cbmNvbnN0IGhsID0ge307XG5mdW5jdGlvbiBZUyhzLCBlID0gITApIHtcbiAgaWYgKGhsW3NdKVxuICAgIHJldHVybiBobFtzXTtcbiAgY29uc3QgdCA9IHtcbiAgICAvLyBJZGVhbHkgZkxhQyBhbmQgT3B1cyB3b3VsZCBiZSBmaXJzdCAoc3BlYy1jb21wbGlhbnQpIGJ1dFxuICAgIC8vIHNvbWUgYnJvd3NlcnMgd2lsbCByZXBvcnQgdGhhdCBmTGFDIGlzIHN1cHBvcnRlZCB0aGVuIGZhaWwuXG4gICAgLy8gc2VlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0xNDIyNzI4XG4gICAgZmxhYzogW1wiZmxhY1wiLCBcImZMYUNcIiwgXCJGTEFDXCJdLFxuICAgIG9wdXM6IFtcIm9wdXNcIiwgXCJPcHVzXCJdLFxuICAgIC8vIFJlcGxhY2UgYXVkaW8gY29kZWMgaW5mbyBpZiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbXA0YS40MC4zNCxcbiAgICAvLyBhbmQgZGVtdXhlciBjYW4gZmFsbGJhY2sgdG8gJ2F1ZGlvL21wZWcnIG9yICdhdWRpby9tcDQ7Y29kZWNzPVwibXAzXCInXG4gICAgXCJtcDRhLjQwLjM0XCI6IFtcIm1wM1wiXVxuICB9W3NdO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHtcbiAgICB2YXIgcjtcbiAgICBpZiAobXUodFtuXSwgXCJhdWRpb1wiLCBlKSlcbiAgICAgIHJldHVybiBobFtzXSA9IHRbbl0sIHRbbl07XG4gICAgaWYgKHRbbl0gPT09IFwibXAzXCIgJiYgKHIgPSBNcyhlKSkgIT0gbnVsbCAmJiByLmlzVHlwZVN1cHBvcnRlZChcImF1ZGlvL21wZWdcIikpXG4gICAgICByZXR1cm4gXCJcIjtcbiAgfVxuICByZXR1cm4gcztcbn1cbmNvbnN0IFpTID0gL2ZsYWN8b3B1c3xtcDRhXFwuNDBcXC4zNC9pO1xuZnVuY3Rpb24gWG8ocywgZSA9ICEwKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoWlMsICh0KSA9PiBZUyh0LnRvTG93ZXJDYXNlKCksIGUpKTtcbn1cbmZ1bmN0aW9uIFhTKHMsIGUpIHtcbiAgY29uc3QgdCA9IFtdO1xuICBpZiAocykge1xuICAgIGNvbnN0IHIgPSBzLnNwbGl0KFwiLFwiKTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IHIubGVuZ3RoOyBuKyspXG4gICAgICBwdShyW25dLCBcInZpZGVvXCIpIHx8IHQucHVzaChyW25dKTtcbiAgfVxuICByZXR1cm4gZSAmJiB0LnB1c2goZSksIHQuam9pbihcIixcIik7XG59XG5mdW5jdGlvbiBmbyhzLCBlKSB7XG4gIGlmIChzICYmIChzLmxlbmd0aCA+IDQgfHwgW1wiYWMtM1wiLCBcImVjLTNcIiwgXCJhbGFjXCIsIFwiZkxhQ1wiLCBcIk9wdXNcIl0uaW5kZXhPZihzKSAhPT0gLTEpICYmIChuaChzLCBcImF1ZGlvXCIpIHx8IG5oKHMsIFwidmlkZW9cIikpKVxuICAgIHJldHVybiBzO1xuICBpZiAoZSkge1xuICAgIGNvbnN0IHQgPSBlLnNwbGl0KFwiLFwiKTtcbiAgICBpZiAodC5sZW5ndGggPiAxKSB7XG4gICAgICBpZiAocykge1xuICAgICAgICBmb3IgKGxldCByID0gdC5sZW5ndGg7IHItLTsgKVxuICAgICAgICAgIGlmICh0W3JdLnN1YnN0cmluZygwLCA0KSA9PT0gcy5zdWJzdHJpbmcoMCwgNCkpXG4gICAgICAgICAgICByZXR1cm4gdFtyXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0WzBdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZSB8fCBzO1xufVxuZnVuY3Rpb24gbmgocywgZSkge1xuICByZXR1cm4gcHUocywgZSkgJiYgbXUocywgZSk7XG59XG5mdW5jdGlvbiBKUyhzKSB7XG4gIGNvbnN0IGUgPSBzLnNwbGl0KFwiLFwiKTtcbiAgZm9yIChsZXQgdCA9IDA7IHQgPCBlLmxlbmd0aDsgdCsrKSB7XG4gICAgY29uc3QgciA9IGVbdF0uc3BsaXQoXCIuXCIpO1xuICAgIHIubGVuZ3RoID4gMiAmJiByWzBdID09PSBcImF2YzFcIiAmJiAoZVt0XSA9IGBhdmMxLiR7cGFyc2VJbnQoclsxXSkudG9TdHJpbmcoMTYpfSR7KFwiMDAwXCIgKyBwYXJzZUludChyWzJdKS50b1N0cmluZygxNikpLnNsaWNlKC00KX1gKTtcbiAgfVxuICByZXR1cm4gZS5qb2luKFwiLFwiKTtcbn1cbmZ1bmN0aW9uIFFTKHMpIHtcbiAgaWYgKHMuc3RhcnRzV2l0aChcImF2MDEuXCIpKSB7XG4gICAgY29uc3QgZSA9IHMuc3BsaXQoXCIuXCIpLCB0ID0gW1wiMFwiLCBcIjExMVwiLCBcIjAxXCIsIFwiMDFcIiwgXCIwMVwiLCBcIjBcIl07XG4gICAgZm9yIChsZXQgciA9IGUubGVuZ3RoOyByID4gNCAmJiByIDwgMTA7IHIrKylcbiAgICAgIGVbcl0gPSB0W3IgLSA0XTtcbiAgICByZXR1cm4gZS5qb2luKFwiLlwiKTtcbiAgfVxuICByZXR1cm4gcztcbn1cbmZ1bmN0aW9uIGloKHMpIHtcbiAgY29uc3QgZSA9IE1zKHMpIHx8IHtcbiAgICBpc1R5cGVTdXBwb3J0ZWQ6ICgpID0+ICExXG4gIH07XG4gIHJldHVybiB7XG4gICAgbXBlZzogZS5pc1R5cGVTdXBwb3J0ZWQoXCJhdWRpby9tcGVnXCIpLFxuICAgIG1wMzogZS5pc1R5cGVTdXBwb3J0ZWQoJ2F1ZGlvL21wNDsgY29kZWNzPVwibXAzXCInKSxcbiAgICBhYzM6IGUuaXNUeXBlU3VwcG9ydGVkKCdhdWRpby9tcDQ7IGNvZGVjcz1cImFjLTNcIicpXG4gIH07XG59XG5mdW5jdGlvbiBsYyhzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL14uK2NvZGVjcz1bXCInXT8oW15cIiddKykuKiQvLCBcIiQxXCIpO1xufVxuY29uc3QgZWIgPSB7XG4gIHN1cHBvcnRlZDogITAsXG4gIHBvd2VyRWZmaWNpZW50OiAhMCxcbiAgc21vb3RoOiAhMFxuICAvLyBrZXlTeXN0ZW1BY2Nlc3M6IG51bGwsXG59LCB0YiA9IHtcbiAgc3VwcG9ydGVkOiAhMSxcbiAgc21vb3RoOiAhMSxcbiAgcG93ZXJFZmZpY2llbnQ6ICExXG4gIC8vIGtleVN5c3RlbUFjY2VzczogbnVsbCxcbn0sIEJnID0ge1xuICBzdXBwb3J0ZWQ6ICEwLFxuICBjb25maWd1cmF0aW9uczogW10sXG4gIGRlY29kaW5nSW5mb1Jlc3VsdHM6IFtlYl1cbn07XG5mdW5jdGlvbiBGZyhzLCBlKSB7XG4gIHJldHVybiB7XG4gICAgc3VwcG9ydGVkOiAhMSxcbiAgICBjb25maWd1cmF0aW9uczogZSxcbiAgICBkZWNvZGluZ0luZm9SZXN1bHRzOiBbdGJdLFxuICAgIGVycm9yOiBzXG4gIH07XG59XG5mdW5jdGlvbiByYihzLCBlLCB0LCByLCBuLCBpKSB7XG4gIGNvbnN0IG8gPSBzLnZpZGVvQ29kZWMsIGEgPSBzLmF1ZGlvQ29kZWMgPyBzLmF1ZGlvR3JvdXBzIDogbnVsbCwgbCA9IGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuYXVkaW9Db2RlYywgYyA9IGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuY2hhbm5lbHMsIHUgPSBjID8gcGFyc2VJbnQoYykgOiBsID8gMSAvIDAgOiAyO1xuICBsZXQgZCA9IG51bGw7XG4gIGlmIChhICE9IG51bGwgJiYgYS5sZW5ndGgpXG4gICAgdHJ5IHtcbiAgICAgIGEubGVuZ3RoID09PSAxICYmIGFbMF0gPyBkID0gZS5ncm91cHNbYVswXV0uY2hhbm5lbHMgOiBkID0gYS5yZWR1Y2UoKGgsIGYpID0+IHtcbiAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICBjb25zdCBwID0gZS5ncm91cHNbZl07XG4gICAgICAgICAgaWYgKCFwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdWRpbyB0cmFjayBncm91cCAke2Z9IG5vdCBmb3VuZGApO1xuICAgICAgICAgIE9iamVjdC5rZXlzKHAuY2hhbm5lbHMpLmZvckVhY2goKHkpID0+IHtcbiAgICAgICAgICAgIGhbeV0gPSAoaFt5XSB8fCAwKSArIHAuY2hhbm5lbHNbeV07XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGg7XG4gICAgICB9LCB7XG4gICAgICAgIDI6IDBcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgcmV0dXJuIG8gIT09IHZvaWQgMCAmJiAvLyBGb3JjZSBtZWRpYSBjYXBhYmlsaXRpZXMgY2hlY2sgZm9yIEhFVkMgdG8gYXZvaWQgZmFpbHVyZSBvbiBXaW5kb3dzXG4gIChvLnNwbGl0KFwiLFwiKS5zb21lKChoKSA9PiB5YShoKSkgfHwgcy53aWR0aCA+IDE5MjAgJiYgcy5oZWlnaHQgPiAxMDg4IHx8IHMuaGVpZ2h0ID4gMTkyMCAmJiBzLndpZHRoID4gMTA4OCB8fCBzLmZyYW1lUmF0ZSA+IE1hdGgubWF4KHIsIDMwKSB8fCBzLnZpZGVvUmFuZ2UgIT09IFwiU0RSXCIgJiYgcy52aWRlb1JhbmdlICE9PSB0IHx8IHMuYml0cmF0ZSA+IE1hdGgubWF4KG4sIDhlNikpIHx8ICEhZCAmJiB1ZSh1KSAmJiBPYmplY3Qua2V5cyhkKS5zb21lKChoKSA9PiBwYXJzZUludChoKSA+IHUpO1xufVxuZnVuY3Rpb24gTmcocywgZSwgdCwgciA9IHt9KSB7XG4gIGNvbnN0IG4gPSBzLnZpZGVvQ29kZWM7XG4gIGlmICghbiAmJiAhcy5hdWRpb0NvZGVjIHx8ICF0KVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoQmcpO1xuICBjb25zdCBpID0gW10sIG8gPSBzYihzKSwgYSA9IG8ubGVuZ3RoLCBsID0gbmIocywgZSwgYSA+IDApLCBjID0gbC5sZW5ndGg7XG4gIGZvciAobGV0IHUgPSBhIHx8IDEgKiBjIHx8IDE7IHUtLTsgKSB7XG4gICAgY29uc3QgZCA9IHtcbiAgICAgIHR5cGU6IFwibWVkaWEtc291cmNlXCJcbiAgICB9O1xuICAgIGlmIChhICYmIChkLnZpZGVvID0gb1t1ICUgYV0pLCBjKSB7XG4gICAgICBkLmF1ZGlvID0gbFt1ICUgY107XG4gICAgICBjb25zdCBoID0gZC5hdWRpby5iaXRyYXRlO1xuICAgICAgZC52aWRlbyAmJiBoICYmIChkLnZpZGVvLmJpdHJhdGUgLT0gaCk7XG4gICAgfVxuICAgIGkucHVzaChkKTtcbiAgfVxuICBpZiAobikge1xuICAgIGNvbnN0IHUgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuICAgIGlmIChuLnNwbGl0KFwiLFwiKS5zb21lKChkKSA9PiB5YShkKSkgJiYgT2coKSlcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoRmcobmV3IEVycm9yKGBPdmVycmlkaW5nIFdpbmRvd3MgRmlyZWZveCBIRVZDIE1lZGlhQ2FwYWJpbGl0aWVzIHJlc3VsdCBiYXNlZCBvbiB1c2VyLWFnZW50IHN0cmluZzogKCR7dX0pYCksIGkpKTtcbiAgfVxuICByZXR1cm4gUHJvbWlzZS5hbGwoaS5tYXAoKHUpID0+IHtcbiAgICBjb25zdCBkID0gb2IodSk7XG4gICAgcmV0dXJuIHJbZF0gfHwgKHJbZF0gPSB0LmRlY29kaW5nSW5mbyh1KSk7XG4gIH0pKS50aGVuKCh1KSA9PiAoe1xuICAgIHN1cHBvcnRlZDogIXUuc29tZSgoZCkgPT4gIWQuc3VwcG9ydGVkKSxcbiAgICBjb25maWd1cmF0aW9uczogaSxcbiAgICBkZWNvZGluZ0luZm9SZXN1bHRzOiB1XG4gIH0pKS5jYXRjaCgodSkgPT4gKHtcbiAgICBzdXBwb3J0ZWQ6ICExLFxuICAgIGNvbmZpZ3VyYXRpb25zOiBpLFxuICAgIGRlY29kaW5nSW5mb1Jlc3VsdHM6IFtdLFxuICAgIGVycm9yOiB1XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIHNiKHMpIHtcbiAgdmFyIGU7XG4gIGNvbnN0IHQgPSAoZSA9IHMudmlkZW9Db2RlYykgPT0gbnVsbCA/IHZvaWQgMCA6IGUuc3BsaXQoXCIsXCIpLCByID0gVWcocyksIG4gPSBzLndpZHRoIHx8IDY0MCwgaSA9IHMuaGVpZ2h0IHx8IDQ4MCwgbyA9IHMuZnJhbWVSYXRlIHx8IDMwLCBhID0gcy52aWRlb1JhbmdlLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiB0ID8gdC5tYXAoKGwpID0+IHtcbiAgICBjb25zdCBjID0ge1xuICAgICAgY29udGVudFR5cGU6IHBpKFFTKGwpLCBcInZpZGVvXCIpLFxuICAgICAgd2lkdGg6IG4sXG4gICAgICBoZWlnaHQ6IGksXG4gICAgICBiaXRyYXRlOiByLFxuICAgICAgZnJhbWVyYXRlOiBvXG4gICAgfTtcbiAgICByZXR1cm4gYSAhPT0gXCJzZHJcIiAmJiAoYy50cmFuc2ZlckZ1bmN0aW9uID0gYSksIGM7XG4gIH0pIDogW107XG59XG5mdW5jdGlvbiBuYihzLCBlLCB0KSB7XG4gIHZhciByO1xuICBjb25zdCBuID0gKHIgPSBzLmF1ZGlvQ29kZWMpID09IG51bGwgPyB2b2lkIDAgOiByLnNwbGl0KFwiLFwiKSwgaSA9IFVnKHMpO1xuICByZXR1cm4gbiAmJiBzLmF1ZGlvR3JvdXBzID8gcy5hdWRpb0dyb3Vwcy5yZWR1Y2UoKG8sIGEpID0+IHtcbiAgICB2YXIgbDtcbiAgICBjb25zdCBjID0gYSA/IChsID0gZS5ncm91cHNbYV0pID09IG51bGwgPyB2b2lkIDAgOiBsLnRyYWNrcyA6IG51bGw7XG4gICAgcmV0dXJuIGMgPyBjLnJlZHVjZSgodSwgZCkgPT4ge1xuICAgICAgaWYgKGQuZ3JvdXBJZCA9PT0gYSkge1xuICAgICAgICBjb25zdCBoID0gcGFyc2VGbG9hdChkLmNoYW5uZWxzIHx8IFwiXCIpO1xuICAgICAgICBuLmZvckVhY2goKGYpID0+IHtcbiAgICAgICAgICBjb25zdCBwID0ge1xuICAgICAgICAgICAgY29udGVudFR5cGU6IHBpKGYsIFwiYXVkaW9cIiksXG4gICAgICAgICAgICBiaXRyYXRlOiB0ID8gaWIoZiwgaSkgOiBpXG4gICAgICAgICAgfTtcbiAgICAgICAgICBoICYmIChwLmNoYW5uZWxzID0gXCJcIiArIGgpLCB1LnB1c2gocCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHU7XG4gICAgfSwgbykgOiBvO1xuICB9LCBbXSkgOiBbXTtcbn1cbmZ1bmN0aW9uIGliKHMsIGUpIHtcbiAgaWYgKGUgPD0gMSlcbiAgICByZXR1cm4gMTtcbiAgbGV0IHQgPSAxMjhlMztcbiAgcmV0dXJuIHMgPT09IFwiZWMtM1wiID8gdCA9IDc2OGUzIDogcyA9PT0gXCJhYy0zXCIgJiYgKHQgPSA2NGU0KSwgTWF0aC5taW4oZSAvIDIsIHQpO1xufVxuZnVuY3Rpb24gVWcocykge1xuICByZXR1cm4gTWF0aC5jZWlsKE1hdGgubWF4KHMuYml0cmF0ZSAqIDAuOSwgcy5hdmVyYWdlQml0cmF0ZSkgLyAxZTMpICogMWUzIHx8IDE7XG59XG5mdW5jdGlvbiBvYihzKSB7XG4gIGxldCBlID0gXCJcIjtcbiAgY29uc3Qge1xuICAgIGF1ZGlvOiB0LFxuICAgIHZpZGVvOiByXG4gIH0gPSBzO1xuICBpZiAocikge1xuICAgIGNvbnN0IG4gPSBsYyhyLmNvbnRlbnRUeXBlKTtcbiAgICBlICs9IGAke259X3Ike3IuaGVpZ2h0fXgke3Iud2lkdGh9ZiR7TWF0aC5jZWlsKHIuZnJhbWVyYXRlKX0ke3IudHJhbnNmZXJGdW5jdGlvbiB8fCBcInNkXCJ9XyR7TWF0aC5jZWlsKHIuYml0cmF0ZSAvIDFlNSl9YDtcbiAgfVxuICBpZiAodCkge1xuICAgIGNvbnN0IG4gPSBsYyh0LmNvbnRlbnRUeXBlKTtcbiAgICBlICs9IGAke3IgPyBcIl9cIiA6IFwiXCJ9JHtufV9jJHt0LmNoYW5uZWxzfWA7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5jb25zdCBjYyA9IFtcIk5PTkVcIiwgXCJUWVBFLTBcIiwgXCJUWVBFLTFcIiwgbnVsbF07XG5mdW5jdGlvbiBhYihzKSB7XG4gIHJldHVybiBjYy5pbmRleE9mKHMpID4gLTE7XG59XG5jb25zdCBKbyA9IFtcIlNEUlwiLCBcIlBRXCIsIFwiSExHXCJdO1xuZnVuY3Rpb24gbGIocykge1xuICByZXR1cm4gISFzICYmIEpvLmluZGV4T2YocykgPiAtMTtcbn1cbnZhciBnbyA9IHtcbiAgTm86IFwiXCIsXG4gIFllczogXCJZRVNcIixcbiAgdjI6IFwidjJcIlxufTtcbmZ1bmN0aW9uIG9oKHMpIHtcbiAgY29uc3Qge1xuICAgIGNhblNraXBVbnRpbDogZSxcbiAgICBjYW5Ta2lwRGF0ZVJhbmdlczogdCxcbiAgICBhZ2U6IHJcbiAgfSA9IHMsIG4gPSByIDwgZSAvIDI7XG4gIHJldHVybiBlICYmIG4gPyB0ID8gZ28udjIgOiBnby5ZZXMgOiBnby5Obztcbn1cbmNsYXNzIGFoIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcikge1xuICAgIHRoaXMubXNuID0gdm9pZCAwLCB0aGlzLnBhcnQgPSB2b2lkIDAsIHRoaXMuc2tpcCA9IHZvaWQgMCwgdGhpcy5tc24gPSBlLCB0aGlzLnBhcnQgPSB0LCB0aGlzLnNraXAgPSByO1xuICB9XG4gIGFkZERpcmVjdGl2ZXMoZSkge1xuICAgIGNvbnN0IHQgPSBuZXcgc2VsZi5VUkwoZSk7XG4gICAgcmV0dXJuIHRoaXMubXNuICE9PSB2b2lkIDAgJiYgdC5zZWFyY2hQYXJhbXMuc2V0KFwiX0hMU19tc25cIiwgdGhpcy5tc24udG9TdHJpbmcoKSksIHRoaXMucGFydCAhPT0gdm9pZCAwICYmIHQuc2VhcmNoUGFyYW1zLnNldChcIl9ITFNfcGFydFwiLCB0aGlzLnBhcnQudG9TdHJpbmcoKSksIHRoaXMuc2tpcCAmJiB0LnNlYXJjaFBhcmFtcy5zZXQoXCJfSExTX3NraXBcIiwgdGhpcy5za2lwKSwgdC5ocmVmO1xuICB9XG59XG5jbGFzcyBtaSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBpZiAodGhpcy5fYXR0cnMgPSB2b2lkIDAsIHRoaXMuYXVkaW9Db2RlYyA9IHZvaWQgMCwgdGhpcy5iaXRyYXRlID0gdm9pZCAwLCB0aGlzLmNvZGVjU2V0ID0gdm9pZCAwLCB0aGlzLnVybCA9IHZvaWQgMCwgdGhpcy5mcmFtZVJhdGUgPSB2b2lkIDAsIHRoaXMuaGVpZ2h0ID0gdm9pZCAwLCB0aGlzLmlkID0gdm9pZCAwLCB0aGlzLm5hbWUgPSB2b2lkIDAsIHRoaXMuc3VwcGxlbWVudGFsID0gdm9pZCAwLCB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDAsIHRoaXMud2lkdGggPSB2b2lkIDAsIHRoaXMuZGV0YWlscyA9IHZvaWQgMCwgdGhpcy5mcmFnbWVudEVycm9yID0gMCwgdGhpcy5sb2FkRXJyb3IgPSAwLCB0aGlzLmxvYWRlZCA9IHZvaWQgMCwgdGhpcy5yZWFsQml0cmF0ZSA9IDAsIHRoaXMuc3VwcG9ydGVkUHJvbWlzZSA9IHZvaWQgMCwgdGhpcy5zdXBwb3J0ZWRSZXN1bHQgPSB2b2lkIDAsIHRoaXMuX2F2Z0JpdHJhdGUgPSAwLCB0aGlzLl9hdWRpb0dyb3VwcyA9IHZvaWQgMCwgdGhpcy5fc3VidGl0bGVHcm91cHMgPSB2b2lkIDAsIHRoaXMuX3VybElkID0gMCwgdGhpcy51cmwgPSBbZS51cmxdLCB0aGlzLl9hdHRycyA9IFtlLmF0dHJzXSwgdGhpcy5iaXRyYXRlID0gZS5iaXRyYXRlLCBlLmRldGFpbHMgJiYgKHRoaXMuZGV0YWlscyA9IGUuZGV0YWlscyksIHRoaXMuaWQgPSBlLmlkIHx8IDAsIHRoaXMubmFtZSA9IGUubmFtZSwgdGhpcy53aWR0aCA9IGUud2lkdGggfHwgMCwgdGhpcy5oZWlnaHQgPSBlLmhlaWdodCB8fCAwLCB0aGlzLmZyYW1lUmF0ZSA9IGUuYXR0cnMub3B0aW9uYWxGbG9hdChcIkZSQU1FLVJBVEVcIiwgMCksIHRoaXMuX2F2Z0JpdHJhdGUgPSBlLmF0dHJzLmRlY2ltYWxJbnRlZ2VyKFwiQVZFUkFHRS1CQU5EV0lEVEhcIiksIHRoaXMuYXVkaW9Db2RlYyA9IGUuYXVkaW9Db2RlYywgdGhpcy52aWRlb0NvZGVjID0gZS52aWRlb0NvZGVjLCB0aGlzLmNvZGVjU2V0ID0gW2UudmlkZW9Db2RlYywgZS5hdWRpb0NvZGVjXS5maWx0ZXIoKHIpID0+ICEhcikubWFwKChyKSA9PiByLnN1YnN0cmluZygwLCA0KSkuam9pbihcIixcIiksIFwic3VwcGxlbWVudGFsXCIgaW4gZSkge1xuICAgICAgdmFyIHQ7XG4gICAgICB0aGlzLnN1cHBsZW1lbnRhbCA9IGUuc3VwcGxlbWVudGFsO1xuICAgICAgY29uc3QgciA9ICh0ID0gZS5zdXBwbGVtZW50YWwpID09IG51bGwgPyB2b2lkIDAgOiB0LnZpZGVvQ29kZWM7XG4gICAgICByICYmIHIgIT09IGUudmlkZW9Db2RlYyAmJiAodGhpcy5jb2RlY1NldCArPSBgLCR7ci5zdWJzdHJpbmcoMCwgNCl9YCk7XG4gICAgfVxuICAgIHRoaXMuYWRkR3JvdXBJZChcImF1ZGlvXCIsIGUuYXR0cnMuQVVESU8pLCB0aGlzLmFkZEdyb3VwSWQoXCJ0ZXh0XCIsIGUuYXR0cnMuU1VCVElUTEVTKTtcbiAgfVxuICBnZXQgbWF4Qml0cmF0ZSgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5yZWFsQml0cmF0ZSwgdGhpcy5iaXRyYXRlKTtcbiAgfVxuICBnZXQgYXZlcmFnZUJpdHJhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F2Z0JpdHJhdGUgfHwgdGhpcy5yZWFsQml0cmF0ZSB8fCB0aGlzLmJpdHJhdGU7XG4gIH1cbiAgZ2V0IGF0dHJzKCkge1xuICAgIHJldHVybiB0aGlzLl9hdHRyc1swXTtcbiAgfVxuICBnZXQgY29kZWNzKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJzLkNPREVDUyB8fCBcIlwiO1xuICB9XG4gIGdldCBwYXRod2F5SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cnNbXCJQQVRIV0FZLUlEXCJdIHx8IFwiLlwiO1xuICB9XG4gIGdldCB2aWRlb1JhbmdlKCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJzW1wiVklERU8tUkFOR0VcIl0gfHwgXCJTRFJcIjtcbiAgfVxuICBnZXQgc2NvcmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0cnMub3B0aW9uYWxGbG9hdChcIlNDT1JFXCIsIDApO1xuICB9XG4gIGdldCB1cmkoKSB7XG4gICAgcmV0dXJuIHRoaXMudXJsWzBdIHx8IFwiXCI7XG4gIH1cbiAgaGFzQXVkaW9Hcm91cChlKSB7XG4gICAgcmV0dXJuIGxoKHRoaXMuX2F1ZGlvR3JvdXBzLCBlKTtcbiAgfVxuICBoYXNTdWJ0aXRsZUdyb3VwKGUpIHtcbiAgICByZXR1cm4gbGgodGhpcy5fc3VidGl0bGVHcm91cHMsIGUpO1xuICB9XG4gIGdldCBhdWRpb0dyb3VwcygpIHtcbiAgICByZXR1cm4gdGhpcy5fYXVkaW9Hcm91cHM7XG4gIH1cbiAgZ2V0IHN1YnRpdGxlR3JvdXBzKCkge1xuICAgIHJldHVybiB0aGlzLl9zdWJ0aXRsZUdyb3VwcztcbiAgfVxuICBhZGRHcm91cElkKGUsIHQpIHtcbiAgICBpZiAodCkge1xuICAgICAgaWYgKGUgPT09IFwiYXVkaW9cIikge1xuICAgICAgICBsZXQgciA9IHRoaXMuX2F1ZGlvR3JvdXBzO1xuICAgICAgICByIHx8IChyID0gdGhpcy5fYXVkaW9Hcm91cHMgPSBbXSksIHIuaW5kZXhPZih0KSA9PT0gLTEgJiYgci5wdXNoKHQpO1xuICAgICAgfSBlbHNlIGlmIChlID09PSBcInRleHRcIikge1xuICAgICAgICBsZXQgciA9IHRoaXMuX3N1YnRpdGxlR3JvdXBzO1xuICAgICAgICByIHx8IChyID0gdGhpcy5fc3VidGl0bGVHcm91cHMgPSBbXSksIHIuaW5kZXhPZih0KSA9PT0gLTEgJiYgci5wdXNoKHQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBEZXByZWNhdGVkIG1ldGhvZHMgKHJldGFpbmVkIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSlcbiAgZ2V0IHVybElkKCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHNldCB1cmxJZChlKSB7XG4gIH1cbiAgZ2V0IGF1ZGlvR3JvdXBJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXVkaW9Hcm91cHMgPyBbdGhpcy5hdWRpb0dyb3VwSWRdIDogdm9pZCAwO1xuICB9XG4gIGdldCB0ZXh0R3JvdXBJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3VidGl0bGVHcm91cHMgPyBbdGhpcy50ZXh0R3JvdXBJZF0gOiB2b2lkIDA7XG4gIH1cbiAgZ2V0IGF1ZGlvR3JvdXBJZCgpIHtcbiAgICB2YXIgZTtcbiAgICByZXR1cm4gKGUgPSB0aGlzLmF1ZGlvR3JvdXBzKSA9PSBudWxsID8gdm9pZCAwIDogZVswXTtcbiAgfVxuICBnZXQgdGV4dEdyb3VwSWQoKSB7XG4gICAgdmFyIGU7XG4gICAgcmV0dXJuIChlID0gdGhpcy5zdWJ0aXRsZUdyb3VwcykgPT0gbnVsbCA/IHZvaWQgMCA6IGVbMF07XG4gIH1cbiAgYWRkRmFsbGJhY2soKSB7XG4gIH1cbn1cbmZ1bmN0aW9uIGxoKHMsIGUpIHtcbiAgcmV0dXJuICFlIHx8ICFzID8gITEgOiBzLmluZGV4T2YoZSkgIT09IC0xO1xufVxuZnVuY3Rpb24gY2IoKSB7XG4gIGlmICh0eXBlb2YgbWF0Y2hNZWRpYSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCBzID0gbWF0Y2hNZWRpYShcIihkeW5hbWljLXJhbmdlOiBoaWdoKVwiKSwgZSA9IG1hdGNoTWVkaWEoXCJiYWQgcXVlcnlcIik7XG4gICAgaWYgKHMubWVkaWEgIT09IGUubWVkaWEpXG4gICAgICByZXR1cm4gcy5tYXRjaGVzID09PSAhMDtcbiAgfVxuICByZXR1cm4gITE7XG59XG5mdW5jdGlvbiB1YihzLCBlKSB7XG4gIGxldCB0ID0gITEsIHIgPSBbXTtcbiAgaWYgKHMgJiYgKHQgPSBzICE9PSBcIlNEUlwiLCByID0gW3NdKSwgZSkge1xuICAgIHIgPSBlLmFsbG93ZWRWaWRlb1JhbmdlcyB8fCBKby5zbGljZSgwKTtcbiAgICBjb25zdCBuID0gci5qb2luKFwiXCIpICE9PSBcIlNEUlwiICYmICFlLnZpZGVvQ29kZWM7XG4gICAgdCA9IGUucHJlZmVySERSICE9PSB2b2lkIDAgPyBlLnByZWZlckhEUiA6IG4gJiYgY2IoKSwgdCB8fCAociA9IFtcIlNEUlwiXSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwcmVmZXJIRFI6IHQsXG4gICAgYWxsb3dlZFZpZGVvUmFuZ2VzOiByXG4gIH07XG59XG5jb25zdCBkYiA9IChzKSA9PiB7XG4gIGNvbnN0IGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtTZXQoKTtcbiAgcmV0dXJuICh0LCByKSA9PiB7XG4gICAgaWYgKHMgJiYgKHIgPSBzKHQsIHIpKSwgdHlwZW9mIHIgPT0gXCJvYmplY3RcIiAmJiByICE9PSBudWxsKSB7XG4gICAgICBpZiAoZS5oYXMocikpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGUuYWRkKHIpO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcbn0sIGF0ID0gKHMsIGUpID0+IEpTT04uc3RyaW5naWZ5KHMsIGRiKGUpKTtcbmZ1bmN0aW9uIGhiKHMsIGUsIHQsIHIsIG4pIHtcbiAgY29uc3QgaSA9IE9iamVjdC5rZXlzKHMpLCBvID0gciA9PSBudWxsID8gdm9pZCAwIDogci5jaGFubmVscywgYSA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuYXVkaW9Db2RlYywgbCA9IG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4udmlkZW9Db2RlYywgYyA9IG8gJiYgcGFyc2VJbnQobykgPT09IDI7XG4gIGxldCB1ID0gITEsIGQgPSAhMSwgaCA9IDEgLyAwLCBmID0gMSAvIDAsIHAgPSAxIC8gMCwgeSA9IDEgLyAwLCBFID0gMCwgYiA9IFtdO1xuICBjb25zdCB7XG4gICAgcHJlZmVySERSOiBSLFxuICAgIGFsbG93ZWRWaWRlb1JhbmdlczogQVxuICB9ID0gdWIoZSwgbik7XG4gIGZvciAobGV0IGogPSBpLmxlbmd0aDsgai0tOyApIHtcbiAgICBjb25zdCBDID0gc1tpW2pdXTtcbiAgICB1IHx8ICh1ID0gQy5jaGFubmVsc1syXSA+IDApLCBoID0gTWF0aC5taW4oaCwgQy5taW5IZWlnaHQpLCBmID0gTWF0aC5taW4oZiwgQy5taW5GcmFtZXJhdGUpLCBwID0gTWF0aC5taW4ocCwgQy5taW5CaXRyYXRlKSwgQS5maWx0ZXIoKCQpID0+IEMudmlkZW9SYW5nZXNbJF0gPiAwKS5sZW5ndGggPiAwICYmIChkID0gITApO1xuICB9XG4gIGggPSB1ZShoKSA/IGggOiAwLCBmID0gdWUoZikgPyBmIDogMDtcbiAgY29uc3QgRiA9IE1hdGgubWF4KDEwODAsIGgpLCBNID0gTWF0aC5tYXgoMzAsIGYpO1xuICBwID0gdWUocCkgPyBwIDogdCwgdCA9IE1hdGgubWF4KHAsIHQpLCBkIHx8IChlID0gdm9pZCAwKTtcbiAgY29uc3QgSCA9IGkubGVuZ3RoID4gMTtcbiAgcmV0dXJuIHtcbiAgICBjb2RlY1NldDogaS5yZWR1Y2UoKGosIEMpID0+IHtcbiAgICAgIGNvbnN0IGsgPSBzW0NdO1xuICAgICAgaWYgKEMgPT09IGopXG4gICAgICAgIHJldHVybiBqO1xuICAgICAgaWYgKGIgPSBkID8gQS5maWx0ZXIoKCQpID0+IGsudmlkZW9SYW5nZXNbJF0gPiAwKSA6IFtdLCBIKSB7XG4gICAgICAgIGlmIChrLm1pbkJpdHJhdGUgPiB0KVxuICAgICAgICAgIHJldHVybiBVcihDLCBgbWluIGJpdHJhdGUgb2YgJHtrLm1pbkJpdHJhdGV9ID4gY3VycmVudCBlc3RpbWF0ZSBvZiAke3R9YCksIGo7XG4gICAgICAgIGlmICghay5oYXNEZWZhdWx0QXVkaW8pXG4gICAgICAgICAgcmV0dXJuIFVyKEMsIFwibm8gcmVuZGl0aW9ucyB3aXRoIGRlZmF1bHQgb3IgYXV0by1zZWxlY3Qgc291bmQgZm91bmRcIiksIGo7XG4gICAgICAgIGlmIChhICYmIEMuaW5kZXhPZihhLnN1YnN0cmluZygwLCA0KSkgJSA1ICE9PSAwKVxuICAgICAgICAgIHJldHVybiBVcihDLCBgYXVkaW8gY29kZWMgcHJlZmVyZW5jZSBcIiR7YX1cIiBub3QgZm91bmRgKSwgajtcbiAgICAgICAgaWYgKG8gJiYgIWMpIHtcbiAgICAgICAgICBpZiAoIWsuY2hhbm5lbHNbb10pXG4gICAgICAgICAgICByZXR1cm4gVXIoQywgYG5vIHJlbmRpdGlvbnMgd2l0aCAke299IGNoYW5uZWwgc291bmQgZm91bmQgKGNoYW5uZWxzIG9wdGlvbnM6ICR7T2JqZWN0LmtleXMoay5jaGFubmVscyl9KWApLCBqO1xuICAgICAgICB9IGVsc2UgaWYgKCghYSB8fCBjKSAmJiB1ICYmIGsuY2hhbm5lbHNbMl0gPT09IDApXG4gICAgICAgICAgcmV0dXJuIFVyKEMsIFwibm8gcmVuZGl0aW9ucyB3aXRoIHN0ZXJlbyBzb3VuZCBmb3VuZFwiKSwgajtcbiAgICAgICAgaWYgKGsubWluSGVpZ2h0ID4gRilcbiAgICAgICAgICByZXR1cm4gVXIoQywgYG1pbiByZXNvbHV0aW9uIG9mICR7ay5taW5IZWlnaHR9ID4gbWF4aW11bSBvZiAke0Z9YCksIGo7XG4gICAgICAgIGlmIChrLm1pbkZyYW1lcmF0ZSA+IE0pXG4gICAgICAgICAgcmV0dXJuIFVyKEMsIGBtaW4gZnJhbWVyYXRlIG9mICR7ay5taW5GcmFtZXJhdGV9ID4gbWF4aW11bSBvZiAke019YCksIGo7XG4gICAgICAgIGlmICghYi5zb21lKCgkKSA9PiBrLnZpZGVvUmFuZ2VzWyRdID4gMCkpXG4gICAgICAgICAgcmV0dXJuIFVyKEMsIGBubyB2YXJpYW50cyB3aXRoIFZJREVPLVJBTkdFIG9mICR7YXQoYil9IGZvdW5kYCksIGo7XG4gICAgICAgIGlmIChsICYmIEMuaW5kZXhPZihsLnN1YnN0cmluZygwLCA0KSkgJSA1ICE9PSAwKVxuICAgICAgICAgIHJldHVybiBVcihDLCBgdmlkZW8gY29kZWMgcHJlZmVyZW5jZSBcIiR7bH1cIiBub3QgZm91bmRgKSwgajtcbiAgICAgICAgaWYgKGsubWF4U2NvcmUgPCBFKVxuICAgICAgICAgIHJldHVybiBVcihDLCBgbWF4IHNjb3JlIG9mICR7ay5tYXhTY29yZX0gPCBzZWxlY3RlZCBtYXggb2YgJHtFfWApLCBqO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGogJiYgKFpvKEMpID49IFpvKGopIHx8IGsuZnJhZ21lbnRFcnJvciA+IHNbal0uZnJhZ21lbnRFcnJvcikgPyBqIDogKHkgPSBrLm1pbkluZGV4LCBFID0gay5tYXhTY29yZSwgQyk7XG4gICAgfSwgdm9pZCAwKSxcbiAgICB2aWRlb1JhbmdlczogYixcbiAgICBwcmVmZXJIRFI6IFIsXG4gICAgbWluRnJhbWVyYXRlOiBmLFxuICAgIG1pbkJpdHJhdGU6IHAsXG4gICAgbWluSW5kZXg6IHlcbiAgfTtcbn1cbmZ1bmN0aW9uIFVyKHMsIGUpIHtcbiAgcnQubG9nKGBbYWJyXSBzdGFydCBjYW5kaWRhdGVzIHdpdGggXCIke3N9XCIgaWdub3JlZCBiZWNhdXNlICR7ZX1gKTtcbn1cbmZ1bmN0aW9uICRnKHMpIHtcbiAgcmV0dXJuIHMucmVkdWNlKChlLCB0KSA9PiB7XG4gICAgbGV0IHIgPSBlLmdyb3Vwc1t0Lmdyb3VwSWRdO1xuICAgIHIgfHwgKHIgPSBlLmdyb3Vwc1t0Lmdyb3VwSWRdID0ge1xuICAgICAgdHJhY2tzOiBbXSxcbiAgICAgIGNoYW5uZWxzOiB7XG4gICAgICAgIDI6IDBcbiAgICAgIH0sXG4gICAgICBoYXNEZWZhdWx0OiAhMSxcbiAgICAgIGhhc0F1dG9TZWxlY3Q6ICExXG4gICAgfSksIHIudHJhY2tzLnB1c2godCk7XG4gICAgY29uc3QgbiA9IHQuY2hhbm5lbHMgfHwgXCIyXCI7XG4gICAgcmV0dXJuIHIuY2hhbm5lbHNbbl0gPSAoci5jaGFubmVsc1tuXSB8fCAwKSArIDEsIHIuaGFzRGVmYXVsdCA9IHIuaGFzRGVmYXVsdCB8fCB0LmRlZmF1bHQsIHIuaGFzQXV0b1NlbGVjdCA9IHIuaGFzQXV0b1NlbGVjdCB8fCB0LmF1dG9zZWxlY3QsIHIuaGFzRGVmYXVsdCAmJiAoZS5oYXNEZWZhdWx0QXVkaW8gPSAhMCksIHIuaGFzQXV0b1NlbGVjdCAmJiAoZS5oYXNBdXRvU2VsZWN0QXVkaW8gPSAhMCksIGU7XG4gIH0sIHtcbiAgICBoYXNEZWZhdWx0QXVkaW86ICExLFxuICAgIGhhc0F1dG9TZWxlY3RBdWRpbzogITEsXG4gICAgZ3JvdXBzOiB7fVxuICB9KTtcbn1cbmZ1bmN0aW9uIGZiKHMsIGUsIHQsIHIpIHtcbiAgcmV0dXJuIHMuc2xpY2UodCwgciArIDEpLnJlZHVjZSgobiwgaSwgbykgPT4ge1xuICAgIGlmICghaS5jb2RlY1NldClcbiAgICAgIHJldHVybiBuO1xuICAgIGNvbnN0IGEgPSBpLmF1ZGlvR3JvdXBzO1xuICAgIGxldCBsID0gbltpLmNvZGVjU2V0XTtcbiAgICBsIHx8IChuW2kuY29kZWNTZXRdID0gbCA9IHtcbiAgICAgIG1pbkJpdHJhdGU6IDEgLyAwLFxuICAgICAgbWluSGVpZ2h0OiAxIC8gMCxcbiAgICAgIG1pbkZyYW1lcmF0ZTogMSAvIDAsXG4gICAgICBtaW5JbmRleDogbyxcbiAgICAgIG1heFNjb3JlOiAwLFxuICAgICAgdmlkZW9SYW5nZXM6IHtcbiAgICAgICAgU0RSOiAwXG4gICAgICB9LFxuICAgICAgY2hhbm5lbHM6IHtcbiAgICAgICAgMjogMFxuICAgICAgfSxcbiAgICAgIGhhc0RlZmF1bHRBdWRpbzogIWEsXG4gICAgICBmcmFnbWVudEVycm9yOiAwXG4gICAgfSksIGwubWluQml0cmF0ZSA9IE1hdGgubWluKGwubWluQml0cmF0ZSwgaS5iaXRyYXRlKTtcbiAgICBjb25zdCBjID0gTWF0aC5taW4oaS5oZWlnaHQsIGkud2lkdGgpO1xuICAgIHJldHVybiBsLm1pbkhlaWdodCA9IE1hdGgubWluKGwubWluSGVpZ2h0LCBjKSwgbC5taW5GcmFtZXJhdGUgPSBNYXRoLm1pbihsLm1pbkZyYW1lcmF0ZSwgaS5mcmFtZVJhdGUpLCBsLm1pbkluZGV4ID0gTWF0aC5taW4obC5taW5JbmRleCwgbyksIGwubWF4U2NvcmUgPSBNYXRoLm1heChsLm1heFNjb3JlLCBpLnNjb3JlKSwgbC5mcmFnbWVudEVycm9yICs9IGkuZnJhZ21lbnRFcnJvciwgbC52aWRlb1Jhbmdlc1tpLnZpZGVvUmFuZ2VdID0gKGwudmlkZW9SYW5nZXNbaS52aWRlb1JhbmdlXSB8fCAwKSArIDEsIGEgJiYgYS5mb3JFYWNoKCh1KSA9PiB7XG4gICAgICBpZiAoIXUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGQgPSBlLmdyb3Vwc1t1XTtcbiAgICAgIGQgJiYgKGwuaGFzRGVmYXVsdEF1ZGlvID0gbC5oYXNEZWZhdWx0QXVkaW8gfHwgZS5oYXNEZWZhdWx0QXVkaW8gPyBkLmhhc0RlZmF1bHQgOiBkLmhhc0F1dG9TZWxlY3QgfHwgIWUuaGFzRGVmYXVsdEF1ZGlvICYmICFlLmhhc0F1dG9TZWxlY3RBdWRpbywgT2JqZWN0LmtleXMoZC5jaGFubmVscykuZm9yRWFjaCgoaCkgPT4ge1xuICAgICAgICBsLmNoYW5uZWxzW2hdID0gKGwuY2hhbm5lbHNbaF0gfHwgMCkgKyBkLmNoYW5uZWxzW2hdO1xuICAgICAgfSkpO1xuICAgIH0pLCBuO1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBjaChzKSB7XG4gIGlmICghcylcbiAgICByZXR1cm4gcztcbiAgY29uc3Qge1xuICAgIGxhbmc6IGUsXG4gICAgYXNzb2NMYW5nOiB0LFxuICAgIGNoYXJhY3RlcmlzdGljczogcixcbiAgICBjaGFubmVsczogbixcbiAgICBhdWRpb0NvZGVjOiBpXG4gIH0gPSBzO1xuICByZXR1cm4ge1xuICAgIGxhbmc6IGUsXG4gICAgYXNzb2NMYW5nOiB0LFxuICAgIGNoYXJhY3RlcmlzdGljczogcixcbiAgICBjaGFubmVsczogbixcbiAgICBhdWRpb0NvZGVjOiBpXG4gIH07XG59XG5mdW5jdGlvbiBXcihzLCBlLCB0KSB7XG4gIGlmIChcImF0dHJzXCIgaW4gcykge1xuICAgIGNvbnN0IHIgPSBlLmluZGV4T2Yocyk7XG4gICAgaWYgKHIgIT09IC0xKVxuICAgICAgcmV0dXJuIHI7XG4gIH1cbiAgZm9yIChsZXQgciA9IDA7IHIgPCBlLmxlbmd0aDsgcisrKSB7XG4gICAgY29uc3QgbiA9IGVbcl07XG4gICAgaWYgKHFzKHMsIG4sIHQpKVxuICAgICAgcmV0dXJuIHI7XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gcXMocywgZSwgdCkge1xuICBjb25zdCB7XG4gICAgZ3JvdXBJZDogcixcbiAgICBuYW1lOiBuLFxuICAgIGxhbmc6IGksXG4gICAgYXNzb2NMYW5nOiBvLFxuICAgIGRlZmF1bHQ6IGFcbiAgfSA9IHMsIGwgPSBzLmZvcmNlZDtcbiAgcmV0dXJuIChyID09PSB2b2lkIDAgfHwgZS5ncm91cElkID09PSByKSAmJiAobiA9PT0gdm9pZCAwIHx8IGUubmFtZSA9PT0gbikgJiYgKGkgPT09IHZvaWQgMCB8fCBnYihpLCBlLmxhbmcpKSAmJiAoaSA9PT0gdm9pZCAwIHx8IGUuYXNzb2NMYW5nID09PSBvKSAmJiAoYSA9PT0gdm9pZCAwIHx8IGUuZGVmYXVsdCA9PT0gYSkgJiYgKGwgPT09IHZvaWQgMCB8fCBlLmZvcmNlZCA9PT0gbCkgJiYgKCEoXCJjaGFyYWN0ZXJpc3RpY3NcIiBpbiBzKSB8fCBwYihzLmNoYXJhY3RlcmlzdGljcyB8fCBcIlwiLCBlLmNoYXJhY3RlcmlzdGljcykpICYmICh0ID09PSB2b2lkIDAgfHwgdChzLCBlKSk7XG59XG5mdW5jdGlvbiBnYihzLCBlID0gXCItLVwiKSB7XG4gIHJldHVybiBzLmxlbmd0aCA9PT0gZS5sZW5ndGggPyBzID09PSBlIDogcy5zdGFydHNXaXRoKGUpIHx8IGUuc3RhcnRzV2l0aChzKTtcbn1cbmZ1bmN0aW9uIHBiKHMsIGUgPSBcIlwiKSB7XG4gIGNvbnN0IHQgPSBzLnNwbGl0KFwiLFwiKSwgciA9IGUuc3BsaXQoXCIsXCIpO1xuICByZXR1cm4gdC5sZW5ndGggPT09IHIubGVuZ3RoICYmICF0LnNvbWUoKG4pID0+IHIuaW5kZXhPZihuKSA9PT0gLTEpO1xufVxuZnVuY3Rpb24gVXMocywgZSkge1xuICBjb25zdCB7XG4gICAgYXVkaW9Db2RlYzogdCxcbiAgICBjaGFubmVsczogclxuICB9ID0gcztcbiAgcmV0dXJuICh0ID09PSB2b2lkIDAgfHwgKGUuYXVkaW9Db2RlYyB8fCBcIlwiKS5zdWJzdHJpbmcoMCwgNCkgPT09IHQuc3Vic3RyaW5nKDAsIDQpKSAmJiAociA9PT0gdm9pZCAwIHx8IHIgPT09IChlLmNoYW5uZWxzIHx8IFwiMlwiKSk7XG59XG5mdW5jdGlvbiBtYihzLCBlLCB0LCByLCBuKSB7XG4gIGNvbnN0IGkgPSBlW3JdLCBhID0gZS5yZWR1Y2UoKGgsIGYsIHApID0+IHtcbiAgICBjb25zdCB5ID0gZi51cmk7XG4gICAgcmV0dXJuIChoW3ldIHx8IChoW3ldID0gW10pKS5wdXNoKHApLCBoO1xuICB9LCB7fSlbaS51cmldO1xuICBhLmxlbmd0aCA+IDEgJiYgKHIgPSBNYXRoLm1heC5hcHBseShNYXRoLCBhKSk7XG4gIGNvbnN0IGwgPSBpLnZpZGVvUmFuZ2UsIGMgPSBpLmZyYW1lUmF0ZSwgdSA9IGkuY29kZWNTZXQuc3Vic3RyaW5nKDAsIDQpLCBkID0gdWgoZSwgciwgKGgpID0+IHtcbiAgICBpZiAoaC52aWRlb1JhbmdlICE9PSBsIHx8IGguZnJhbWVSYXRlICE9PSBjIHx8IGguY29kZWNTZXQuc3Vic3RyaW5nKDAsIDQpICE9PSB1KVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGYgPSBoLmF1ZGlvR3JvdXBzLCBwID0gdC5maWx0ZXIoKHkpID0+ICFmIHx8IGYuaW5kZXhPZih5Lmdyb3VwSWQpICE9PSAtMSk7XG4gICAgcmV0dXJuIFdyKHMsIHAsIG4pID4gLTE7XG4gIH0pO1xuICByZXR1cm4gZCA+IC0xID8gZCA6IHVoKGUsIHIsIChoKSA9PiB7XG4gICAgY29uc3QgZiA9IGguYXVkaW9Hcm91cHMsIHAgPSB0LmZpbHRlcigoeSkgPT4gIWYgfHwgZi5pbmRleE9mKHkuZ3JvdXBJZCkgIT09IC0xKTtcbiAgICByZXR1cm4gV3IocywgcCwgbikgPiAtMTtcbiAgfSk7XG59XG5mdW5jdGlvbiB1aChzLCBlLCB0KSB7XG4gIGZvciAobGV0IHIgPSBlOyByID4gLTE7IHItLSlcbiAgICBpZiAodChzW3JdKSlcbiAgICAgIHJldHVybiByO1xuICBmb3IgKGxldCByID0gZSArIDE7IHIgPCBzLmxlbmd0aDsgcisrKVxuICAgIGlmICh0KHNbcl0pKVxuICAgICAgcmV0dXJuIHI7XG4gIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIFFvKHMsIGUpIHtcbiAgdmFyIHQ7XG4gIHJldHVybiAhIXMgJiYgcyAhPT0gKCh0ID0gZS5sb2FkTGV2ZWxPYmopID09IG51bGwgPyB2b2lkIDAgOiB0LnVyaSk7XG59XG5jbGFzcyB5YiBleHRlbmRzIExyIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKFwiYWJyXCIsIGUubG9nZ2VyKSwgdGhpcy5obHMgPSB2b2lkIDAsIHRoaXMubGFzdExldmVsTG9hZFNlYyA9IDAsIHRoaXMubGFzdExvYWRlZEZyYWdMZXZlbCA9IC0xLCB0aGlzLmZpcnN0U2VsZWN0aW9uID0gLTEsIHRoaXMuX25leHRBdXRvTGV2ZWwgPSAtMSwgdGhpcy5uZXh0QXV0b0xldmVsS2V5ID0gXCJcIiwgdGhpcy5hdWRpb1RyYWNrc0J5R3JvdXAgPSBudWxsLCB0aGlzLmNvZGVjVGllcnMgPSBudWxsLCB0aGlzLnRpbWVyID0gLTEsIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsLCB0aGlzLnBhcnRDdXJyZW50ID0gbnVsbCwgdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gMCwgdGhpcy5yZWJ1ZmZlck5vdGljZSA9IC0xLCB0aGlzLnN1cHBvcnRlZENhY2hlID0ge30sIHRoaXMuYndFc3RpbWF0b3IgPSB2b2lkIDAsIHRoaXMuX2FiYW5kb25SdWxlc0NoZWNrID0gKHQpID0+IHtcbiAgICAgIHZhciByO1xuICAgICAgY29uc3Qge1xuICAgICAgICBmcmFnQ3VycmVudDogbixcbiAgICAgICAgcGFydEN1cnJlbnQ6IGksXG4gICAgICAgIGhsczogb1xuICAgICAgfSA9IHRoaXMsIHtcbiAgICAgICAgYXV0b0xldmVsRW5hYmxlZDogYSxcbiAgICAgICAgbWVkaWE6IGxcbiAgICAgIH0gPSBvO1xuICAgICAgaWYgKCFuIHx8ICFsKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBjID0gcGVyZm9ybWFuY2Uubm93KCksIHUgPSBpID8gaS5zdGF0cyA6IG4uc3RhdHMsIGQgPSBpID8gaS5kdXJhdGlvbiA6IG4uZHVyYXRpb24sIGggPSBjIC0gdS5sb2FkaW5nLnN0YXJ0LCBmID0gby5taW5BdXRvTGV2ZWwsIHAgPSBuLmxldmVsLCB5ID0gdGhpcy5fbmV4dEF1dG9MZXZlbDtcbiAgICAgIGlmICh1LmFib3J0ZWQgfHwgdS5sb2FkZWQgJiYgdS5sb2FkZWQgPT09IHUudG90YWwgfHwgcCA8PSBmKSB7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lcigpLCB0aGlzLl9uZXh0QXV0b0xldmVsID0gLTE7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghYSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgRSA9IHkgPiAtMSAmJiB5ICE9PSBwLCBiID0gISF0IHx8IEU7XG4gICAgICBpZiAoIWIgJiYgKGwucGF1c2VkIHx8ICFsLnBsYXliYWNrUmF0ZSB8fCAhbC5yZWFkeVN0YXRlKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgUiA9IG8ubWFpbkZvcndhcmRCdWZmZXJJbmZvO1xuICAgICAgaWYgKCFiICYmIFIgPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IEEgPSB0aGlzLmJ3RXN0aW1hdG9yLmdldEVzdGltYXRlVFRGQigpLCBGID0gTWF0aC5hYnMobC5wbGF5YmFja1JhdGUpO1xuICAgICAgaWYgKGggPD0gTWF0aC5tYXgoQSwgMWUzICogKGQgLyAoRiAqIDIpKSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IE0gPSBSID8gUi5sZW4gLyBGIDogMCwgSCA9IHUubG9hZGluZy5maXJzdCA/IHUubG9hZGluZy5maXJzdCAtIHUubG9hZGluZy5zdGFydCA6IC0xLCBLID0gdS5sb2FkZWQgJiYgSCA+IC0xLCBqID0gdGhpcy5nZXRCd0VzdGltYXRlKCksIEMgPSBvLmxldmVscywgayA9IENbcF0sICQgPSBNYXRoLm1heCh1LmxvYWRlZCwgTWF0aC5yb3VuZChkICogKG4uYml0cmF0ZSB8fCBrLmF2ZXJhZ2VCaXRyYXRlKSAvIDgpKTtcbiAgICAgIGxldCBXID0gSyA/IGggLSBIIDogaDtcbiAgICAgIFcgPCAxICYmIEsgJiYgKFcgPSBNYXRoLm1pbihoLCB1LmxvYWRlZCAqIDggLyBqKSk7XG4gICAgICBjb25zdCBfID0gSyA/IHUubG9hZGVkICogMWUzIC8gVyA6IDAsIGcgPSBBIC8gMWUzLCB4ID0gXyA/ICgkIC0gdS5sb2FkZWQpIC8gXyA6ICQgKiA4IC8gaiArIGc7XG4gICAgICBpZiAoeCA8PSBNKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCB3ID0gXyA/IF8gKiA4IDogaiwgRCA9ICgociA9ICh0ID09IG51bGwgPyB2b2lkIDAgOiB0LmRldGFpbHMpIHx8IHRoaXMuaGxzLmxhdGVzdExldmVsRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IHIubGl2ZSkgPT09ICEwLCBPID0gdGhpcy5obHMuY29uZmlnLmFickJhbmRXaWR0aFVwRmFjdG9yO1xuICAgICAgbGV0IFUgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIFY7XG4gICAgICBmb3IgKFYgPSBwIC0gMTsgViA+IGY7IFYtLSkge1xuICAgICAgICBjb25zdCBQID0gQ1tWXS5tYXhCaXRyYXRlLCBOID0gIUNbVl0uZGV0YWlscyB8fCBEO1xuICAgICAgICBpZiAoVSA9IHRoaXMuZ2V0VGltZVRvTG9hZEZyYWcoZywgdywgZCAqIFAsIE4pLCBVIDwgTWF0aC5taW4oTSwgZCArIGcpKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKFUgPj0geCB8fCBVID4gZCAqIDEwKVxuICAgICAgICByZXR1cm47XG4gICAgICBLID8gdGhpcy5id0VzdGltYXRvci5zYW1wbGUoaCAtIE1hdGgubWluKEEsIEgpLCB1LmxvYWRlZCkgOiB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZVRURkIoaCk7XG4gICAgICBjb25zdCBMID0gQ1tWXS5tYXhCaXRyYXRlO1xuICAgICAgdGhpcy5nZXRCd0VzdGltYXRlKCkgKiBPID4gTCAmJiB0aGlzLnJlc2V0RXN0aW1hdG9yKEwpO1xuICAgICAgY29uc3QgbSA9IHRoaXMuZmluZEJlc3RMZXZlbChMLCBmLCBWLCAwLCBNLCAxLCAxKTtcbiAgICAgIG0gPiAtMSAmJiAoViA9IG0pLCB0aGlzLndhcm4oYEZyYWdtZW50ICR7bi5zbn0ke2kgPyBcIiBwYXJ0IFwiICsgaS5pbmRleCA6IFwiXCJ9IG9mIGxldmVsICR7cH0gaXMgbG9hZGluZyB0b28gc2xvd2x5O1xuICAgICAgRnJhZ21lbnQgZHVyYXRpb246ICR7bi5kdXJhdGlvbi50b0ZpeGVkKDMpfVxuICAgICAgVGltZSB0byB1bmRlcmJ1ZmZlcjogJHtNLnRvRml4ZWQoMyl9IHNcbiAgICAgIEVzdGltYXRlZCBsb2FkIHRpbWUgZm9yIGN1cnJlbnQgZnJhZ21lbnQ6ICR7eC50b0ZpeGVkKDMpfSBzXG4gICAgICBFc3RpbWF0ZWQgbG9hZCB0aW1lIGZvciBkb3duIHN3aXRjaCBmcmFnbWVudDogJHtVLnRvRml4ZWQoMyl9IHNcbiAgICAgIFRURkIgZXN0aW1hdGU6ICR7SCB8IDB9IG1zXG4gICAgICBDdXJyZW50IEJXIGVzdGltYXRlOiAke3VlKGopID8gaiB8IDAgOiBcIlVua25vd25cIn0gYnBzXG4gICAgICBOZXcgQlcgZXN0aW1hdGU6ICR7dGhpcy5nZXRCd0VzdGltYXRlKCkgfCAwfSBicHNcbiAgICAgIFN3aXRjaGluZyB0byBsZXZlbCAke1Z9IEAgJHtMIHwgMH0gYnBzYCksIG8ubmV4dExvYWRMZXZlbCA9IG8ubmV4dEF1dG9MZXZlbCA9IFYsIHRoaXMuY2xlYXJUaW1lcigpO1xuICAgICAgY29uc3QgdiA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuY2xlYXJUaW1lcigpLCB0aGlzLmZyYWdDdXJyZW50ID09PSBuICYmIHRoaXMuaGxzLmxvYWRMZXZlbCA9PT0gViAmJiBWID4gMCkge1xuICAgICAgICAgIGNvbnN0IFAgPSB0aGlzLmdldFN0YXJ2YXRpb25EZWxheSgpO1xuICAgICAgICAgIGlmICh0aGlzLndhcm4oYEFib3J0aW5nIGluZmxpZ2h0IHJlcXVlc3QgJHtWID4gMCA/IFwiYW5kIHN3aXRjaGluZyBkb3duXCIgOiBcIlwifVxuICAgICAgRnJhZ21lbnQgZHVyYXRpb246ICR7bi5kdXJhdGlvbi50b0ZpeGVkKDMpfSBzXG4gICAgICBUaW1lIHRvIHVuZGVyYnVmZmVyOiAke1AudG9GaXhlZCgzKX0gc2ApLCBuLmFib3J0UmVxdWVzdHMoKSwgdGhpcy5mcmFnQ3VycmVudCA9IHRoaXMucGFydEN1cnJlbnQgPSBudWxsLCBWID4gZikge1xuICAgICAgICAgICAgbGV0IE4gPSB0aGlzLmZpbmRCZXN0TGV2ZWwodGhpcy5obHMubGV2ZWxzW2ZdLmJpdHJhdGUsIGYsIFYsIDAsIFAsIDEsIDEpO1xuICAgICAgICAgICAgTiA9PT0gLTEgJiYgKE4gPSBmKSwgdGhpcy5obHMubmV4dExvYWRMZXZlbCA9IHRoaXMuaGxzLm5leHRBdXRvTGV2ZWwgPSBOLCB0aGlzLnJlc2V0RXN0aW1hdG9yKHRoaXMuaGxzLmxldmVsc1tOXS5iaXRyYXRlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBFIHx8IHggPiBVICogMiA/IHYoKSA6IHRoaXMudGltZXIgPSBzZWxmLnNldEludGVydmFsKHYsIFUgKiAxZTMpLCBvLnRyaWdnZXIoSS5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHtcbiAgICAgICAgZnJhZzogbixcbiAgICAgICAgcGFydDogaSxcbiAgICAgICAgc3RhdHM6IHVcbiAgICAgIH0pO1xuICAgIH0sIHRoaXMuaGxzID0gZSwgdGhpcy5id0VzdGltYXRvciA9IHRoaXMuaW5pdEVzdGltYXRvcigpLCB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVzZXRFc3RpbWF0b3IoZSkge1xuICAgIGUgJiYgKHRoaXMubG9nKGBzZXR0aW5nIGluaXRpYWwgYndlIHRvICR7ZX1gKSwgdGhpcy5obHMuY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGUgPSBlKSwgdGhpcy5maXJzdFNlbGVjdGlvbiA9IC0xLCB0aGlzLmJ3RXN0aW1hdG9yID0gdGhpcy5pbml0RXN0aW1hdG9yKCk7XG4gIH1cbiAgaW5pdEVzdGltYXRvcigpIHtcbiAgICBjb25zdCBlID0gdGhpcy5obHMuY29uZmlnO1xuICAgIHJldHVybiBuZXcgVFMoZS5hYnJFd21hU2xvd1ZvRCwgZS5hYnJFd21hRmFzdFZvRCwgZS5hYnJFd21hRGVmYXVsdEVzdGltYXRlKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHM6IGVcbiAgICB9ID0gdGhpcztcbiAgICBlLm9uKEkuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyksIGUub24oSS5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyksIGUub24oSS5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpLCBlLm9uKEkuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyksIGUub24oSS5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyksIGUub24oSS5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyksIGUub24oSS5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpLCBlLm9uKEkuTUFYX0FVVE9fTEVWRUxfVVBEQVRFRCwgdGhpcy5vbk1heEF1dG9MZXZlbFVwZGF0ZWQsIHRoaXMpLCBlLm9uKEkuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHM6IGVcbiAgICB9ID0gdGhpcztcbiAgICBlICYmIChlLm9mZihJLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpLCBlLm9mZihJLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKSwgZS5vZmYoSS5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpLCBlLm9mZihJLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpLCBlLm9mZihJLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKSwgZS5vZmYoSS5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyksIGUub2ZmKEkuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKSwgZS5vZmYoSS5NQVhfQVVUT19MRVZFTF9VUERBVEVELCB0aGlzLm9uTWF4QXV0b0xldmVsVXBkYXRlZCwgdGhpcyksIGUub2ZmKEkuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcykpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCksIHRoaXMuY2xlYXJUaW1lcigpLCB0aGlzLmhscyA9IHRoaXMuX2FiYW5kb25SdWxlc0NoZWNrID0gdGhpcy5zdXBwb3J0ZWRDYWNoZSA9IG51bGwsIHRoaXMuZnJhZ0N1cnJlbnQgPSB0aGlzLnBhcnRDdXJyZW50ID0gbnVsbDtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZyhlLCB0KSB7XG4gICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gLTEsIHRoaXMuZmlyc3RTZWxlY3Rpb24gPSAtMSwgdGhpcy5sYXN0TGV2ZWxMb2FkU2VjID0gMCwgdGhpcy5zdXBwb3J0ZWRDYWNoZSA9IHt9LCB0aGlzLmZyYWdDdXJyZW50ID0gdGhpcy5wYXJ0Q3VycmVudCA9IG51bGwsIHRoaXMub25MZXZlbHNVcGRhdGVkKCksIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9XG4gIG9uTGV2ZWxzVXBkYXRlZCgpIHtcbiAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPiAtMSAmJiB0aGlzLmZyYWdDdXJyZW50ICYmICh0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSB0aGlzLmZyYWdDdXJyZW50LmxldmVsKSwgdGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xLCB0aGlzLm9uTWF4QXV0b0xldmVsVXBkYXRlZCgpLCB0aGlzLmNvZGVjVGllcnMgPSBudWxsLCB0aGlzLmF1ZGlvVHJhY2tzQnlHcm91cCA9IG51bGw7XG4gIH1cbiAgb25NYXhBdXRvTGV2ZWxVcGRhdGVkKCkge1xuICAgIHRoaXMuZmlyc3RTZWxlY3Rpb24gPSAtMSwgdGhpcy5uZXh0QXV0b0xldmVsS2V5ID0gXCJcIjtcbiAgfVxuICBvbkZyYWdMb2FkaW5nKGUsIHQpIHtcbiAgICBjb25zdCByID0gdC5mcmFnO1xuICAgIGlmICghdGhpcy5pZ25vcmVGcmFnbWVudChyKSkge1xuICAgICAgaWYgKCFyLmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIHZhciBuO1xuICAgICAgICB0aGlzLmZyYWdDdXJyZW50ID0gciwgdGhpcy5wYXJ0Q3VycmVudCA9IChuID0gdC5wYXJ0KSAhPSBudWxsID8gbiA6IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWFyVGltZXIoKSwgdGhpcy50aW1lciA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5fYWJhbmRvblJ1bGVzQ2hlY2ssIDEwMCk7XG4gICAgfVxuICB9XG4gIG9uTGV2ZWxTd2l0Y2hpbmcoZSwgdCkge1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9XG4gIG9uRXJyb3IoZSwgdCkge1xuICAgIGlmICghdC5mYXRhbClcbiAgICAgIHN3aXRjaCAodC5kZXRhaWxzKSB7XG4gICAgICAgIGNhc2UgSi5CVUZGRVJfQUREX0NPREVDX0VSUk9SOlxuICAgICAgICBjYXNlIEouQlVGRkVSX0FQUEVORF9FUlJPUjpcbiAgICAgICAgICB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPSAtMSwgdGhpcy5maXJzdFNlbGVjdGlvbiA9IC0xO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEouRlJBR19MT0FEX1RJTUVPVVQ6IHtcbiAgICAgICAgICBjb25zdCByID0gdC5mcmFnLCB7XG4gICAgICAgICAgICBmcmFnQ3VycmVudDogbixcbiAgICAgICAgICAgIHBhcnRDdXJyZW50OiBpXG4gICAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgICAgaWYgKHIgJiYgbiAmJiByLnNuID09PSBuLnNuICYmIHIubGV2ZWwgPT09IG4ubGV2ZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IG8gPSBwZXJmb3JtYW5jZS5ub3coKSwgYSA9IGkgPyBpLnN0YXRzIDogci5zdGF0cywgbCA9IG8gLSBhLmxvYWRpbmcuc3RhcnQsIGMgPSBhLmxvYWRpbmcuZmlyc3QgPyBhLmxvYWRpbmcuZmlyc3QgLSBhLmxvYWRpbmcuc3RhcnQgOiAtMTtcbiAgICAgICAgICAgIGlmIChhLmxvYWRlZCAmJiBjID4gLTEpIHtcbiAgICAgICAgICAgICAgY29uc3QgZCA9IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCk7XG4gICAgICAgICAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKGwgLSBNYXRoLm1pbihkLCBjKSwgYS5sb2FkZWQpO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlVFRGQihsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuICBnZXRUaW1lVG9Mb2FkRnJhZyhlLCB0LCByLCBuKSB7XG4gICAgY29uc3QgaSA9IGUgKyByIC8gdCwgbyA9IG4gPyBlICsgdGhpcy5sYXN0TGV2ZWxMb2FkU2VjIDogMDtcbiAgICByZXR1cm4gaSArIG87XG4gIH1cbiAgb25MZXZlbExvYWRlZChlLCB0KSB7XG4gICAgY29uc3QgciA9IHRoaXMuaGxzLmNvbmZpZywge1xuICAgICAgbG9hZGluZzogblxuICAgIH0gPSB0LnN0YXRzLCBpID0gbi5lbmQgLSBuLmZpcnN0O1xuICAgIHVlKGkpICYmICh0aGlzLmxhc3RMZXZlbExvYWRTZWMgPSBpIC8gMWUzKSwgdC5kZXRhaWxzLmxpdmUgPyB0aGlzLmJ3RXN0aW1hdG9yLnVwZGF0ZShyLmFickV3bWFTbG93TGl2ZSwgci5hYnJFd21hRmFzdExpdmUpIDogdGhpcy5id0VzdGltYXRvci51cGRhdGUoci5hYnJFd21hU2xvd1ZvRCwgci5hYnJFd21hRmFzdFZvRCksIHRoaXMudGltZXIgPiAtMSAmJiB0aGlzLl9hYmFuZG9uUnVsZXNDaGVjayh0LmxldmVsSW5mbyk7XG4gIH1cbiAgb25GcmFnTG9hZGVkKGUsIHtcbiAgICBmcmFnOiB0LFxuICAgIHBhcnQ6IHJcbiAgfSkge1xuICAgIGNvbnN0IG4gPSByID8gci5zdGF0cyA6IHQuc3RhdHM7XG4gICAgaWYgKHQudHlwZSA9PT0gcGUuTUFJTiAmJiB0aGlzLmJ3RXN0aW1hdG9yLnNhbXBsZVRURkIobi5sb2FkaW5nLmZpcnN0IC0gbi5sb2FkaW5nLnN0YXJ0KSwgIXRoaXMuaWdub3JlRnJhZ21lbnQodCkpIHtcbiAgICAgIGlmICh0aGlzLmNsZWFyVGltZXIoKSwgdC5sZXZlbCA9PT0gdGhpcy5fbmV4dEF1dG9MZXZlbCAmJiAodGhpcy5fbmV4dEF1dG9MZXZlbCA9IC0xKSwgdGhpcy5maXJzdFNlbGVjdGlvbiA9IC0xLCB0aGlzLmhscy5jb25maWcuYWJyTWF4V2l0aFJlYWxCaXRyYXRlKSB7XG4gICAgICAgIGNvbnN0IGkgPSByID8gci5kdXJhdGlvbiA6IHQuZHVyYXRpb24sIG8gPSB0aGlzLmhscy5sZXZlbHNbdC5sZXZlbF0sIGEgPSAoby5sb2FkZWQgPyBvLmxvYWRlZC5ieXRlcyA6IDApICsgbi5sb2FkZWQsIGwgPSAoby5sb2FkZWQgPyBvLmxvYWRlZC5kdXJhdGlvbiA6IDApICsgaTtcbiAgICAgICAgby5sb2FkZWQgPSB7XG4gICAgICAgICAgYnl0ZXM6IGEsXG4gICAgICAgICAgZHVyYXRpb246IGxcbiAgICAgICAgfSwgby5yZWFsQml0cmF0ZSA9IE1hdGgucm91bmQoOCAqIGEgLyBsKTtcbiAgICAgIH1cbiAgICAgIGlmICh0LmJpdHJhdGVUZXN0KSB7XG4gICAgICAgIGNvbnN0IGkgPSB7XG4gICAgICAgICAgc3RhdHM6IG4sXG4gICAgICAgICAgZnJhZzogdCxcbiAgICAgICAgICBwYXJ0OiByLFxuICAgICAgICAgIGlkOiB0LnR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vbkZyYWdCdWZmZXJlZChJLkZSQUdfQlVGRkVSRUQsIGkpLCB0LmJpdHJhdGVUZXN0ID0gITE7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsID0gdC5sZXZlbDtcbiAgICB9XG4gIH1cbiAgb25GcmFnQnVmZmVyZWQoZSwgdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWc6IHIsXG4gICAgICBwYXJ0OiBuXG4gICAgfSA9IHQsIGkgPSBuICE9IG51bGwgJiYgbi5zdGF0cy5sb2FkZWQgPyBuLnN0YXRzIDogci5zdGF0cztcbiAgICBpZiAoaS5hYm9ydGVkIHx8IHRoaXMuaWdub3JlRnJhZ21lbnQocikpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbyA9IGkucGFyc2luZy5lbmQgLSBpLmxvYWRpbmcuc3RhcnQgLSBNYXRoLm1pbihpLmxvYWRpbmcuZmlyc3QgLSBpLmxvYWRpbmcuc3RhcnQsIHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCkpO1xuICAgIHRoaXMuYndFc3RpbWF0b3Iuc2FtcGxlKG8sIGkubG9hZGVkKSwgaS5id0VzdGltYXRlID0gdGhpcy5nZXRCd0VzdGltYXRlKCksIHIuYml0cmF0ZVRlc3QgPyB0aGlzLmJpdHJhdGVUZXN0RGVsYXkgPSBvIC8gMWUzIDogdGhpcy5iaXRyYXRlVGVzdERlbGF5ID0gMDtcbiAgfVxuICBpZ25vcmVGcmFnbWVudChlKSB7XG4gICAgcmV0dXJuIGUudHlwZSAhPT0gcGUuTUFJTiB8fCBlLnNuID09PSBcImluaXRTZWdtZW50XCI7XG4gIH1cbiAgY2xlYXJUaW1lcigpIHtcbiAgICB0aGlzLnRpbWVyID4gLTEgJiYgKHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKSwgdGhpcy50aW1lciA9IC0xKTtcbiAgfVxuICBnZXQgZmlyc3RBdXRvTGV2ZWwoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWF4QXV0b0xldmVsOiBlLFxuICAgICAgbWluQXV0b0xldmVsOiB0XG4gICAgfSA9IHRoaXMuaGxzLCByID0gdGhpcy5nZXRCd0VzdGltYXRlKCksIG4gPSB0aGlzLmhscy5jb25maWcubWF4U3RhcnZhdGlvbkRlbGF5LCBpID0gdGhpcy5maW5kQmVzdExldmVsKHIsIHQsIGUsIDAsIG4sIDEsIDEpO1xuICAgIGlmIChpID4gLTEpXG4gICAgICByZXR1cm4gaTtcbiAgICBjb25zdCBvID0gdGhpcy5obHMuZmlyc3RMZXZlbCwgYSA9IE1hdGgubWluKE1hdGgubWF4KG8sIHQpLCBlKTtcbiAgICByZXR1cm4gdGhpcy53YXJuKGBDb3VsZCBub3QgZmluZCBiZXN0IHN0YXJ0aW5nIGF1dG8gbGV2ZWwuIERlZmF1bHRpbmcgdG8gZmlyc3QgaW4gcGxheWxpc3QgJHtvfSBjbGFtcGVkIHRvICR7YX1gKSwgYTtcbiAgfVxuICBnZXQgZm9yY2VkQXV0b0xldmVsKCkge1xuICAgIHJldHVybiB0aGlzLm5leHRBdXRvTGV2ZWxLZXkgPyAtMSA6IHRoaXMuX25leHRBdXRvTGV2ZWw7XG4gIH1cbiAgLy8gcmV0dXJuIG5leHQgYXV0byBsZXZlbFxuICBnZXQgbmV4dEF1dG9MZXZlbCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5mb3JjZWRBdXRvTGV2ZWwsIHIgPSB0aGlzLmJ3RXN0aW1hdG9yLmNhbkVzdGltYXRlKCksIG4gPSB0aGlzLmxhc3RMb2FkZWRGcmFnTGV2ZWwgPiAtMTtcbiAgICBpZiAoZSAhPT0gLTEgJiYgKCFyIHx8ICFuIHx8IHRoaXMubmV4dEF1dG9MZXZlbEtleSA9PT0gdGhpcy5nZXRBdXRvTGV2ZWxLZXkoKSkpXG4gICAgICByZXR1cm4gZTtcbiAgICBjb25zdCBpID0gciAmJiBuID8gdGhpcy5nZXROZXh0QUJSQXV0b0xldmVsKCkgOiB0aGlzLmZpcnN0QXV0b0xldmVsO1xuICAgIGlmIChlICE9PSAtMSkge1xuICAgICAgY29uc3QgbyA9IHRoaXMuaGxzLmxldmVscztcbiAgICAgIGlmIChvLmxlbmd0aCA+IE1hdGgubWF4KGUsIGkpICYmIG9bZV0ubG9hZEVycm9yIDw9IG9baV0ubG9hZEVycm9yKVxuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX25leHRBdXRvTGV2ZWwgPSBpLCB0aGlzLm5leHRBdXRvTGV2ZWxLZXkgPSB0aGlzLmdldEF1dG9MZXZlbEtleSgpLCBpO1xuICB9XG4gIGdldEF1dG9MZXZlbEtleSgpIHtcbiAgICByZXR1cm4gYCR7dGhpcy5nZXRCd0VzdGltYXRlKCl9XyR7dGhpcy5nZXRTdGFydmF0aW9uRGVsYXkoKS50b0ZpeGVkKDIpfWA7XG4gIH1cbiAgZ2V0TmV4dEFCUkF1dG9MZXZlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnQ3VycmVudDogZSxcbiAgICAgIHBhcnRDdXJyZW50OiB0LFxuICAgICAgaGxzOiByXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHIubGV2ZWxzLmxlbmd0aCA8PSAxKVxuICAgICAgcmV0dXJuIHIubG9hZExldmVsO1xuICAgIGNvbnN0IHtcbiAgICAgIG1heEF1dG9MZXZlbDogbixcbiAgICAgIGNvbmZpZzogaSxcbiAgICAgIG1pbkF1dG9MZXZlbDogb1xuICAgIH0gPSByLCBhID0gdCA/IHQuZHVyYXRpb24gOiBlID8gZS5kdXJhdGlvbiA6IDAsIGwgPSB0aGlzLmdldEJ3RXN0aW1hdGUoKSwgYyA9IHRoaXMuZ2V0U3RhcnZhdGlvbkRlbGF5KCk7XG4gICAgbGV0IHUgPSBpLmFickJhbmRXaWR0aEZhY3RvciwgZCA9IGkuYWJyQmFuZFdpZHRoVXBGYWN0b3I7XG4gICAgaWYgKGMpIHtcbiAgICAgIGNvbnN0IEUgPSB0aGlzLmZpbmRCZXN0TGV2ZWwobCwgbywgbiwgYywgMCwgdSwgZCk7XG4gICAgICBpZiAoRSA+PSAwKVxuICAgICAgICByZXR1cm4gdGhpcy5yZWJ1ZmZlck5vdGljZSA9IC0xLCBFO1xuICAgIH1cbiAgICBsZXQgaCA9IGEgPyBNYXRoLm1pbihhLCBpLm1heFN0YXJ2YXRpb25EZWxheSkgOiBpLm1heFN0YXJ2YXRpb25EZWxheTtcbiAgICBpZiAoIWMpIHtcbiAgICAgIGNvbnN0IEUgPSB0aGlzLmJpdHJhdGVUZXN0RGVsYXk7XG4gICAgICBFICYmIChoID0gKGEgPyBNYXRoLm1pbihhLCBpLm1heExvYWRpbmdEZWxheSkgOiBpLm1heExvYWRpbmdEZWxheSkgLSBFLCB0aGlzLmluZm8oYGJpdHJhdGUgdGVzdCB0b29rICR7TWF0aC5yb3VuZCgxZTMgKiBFKX1tcywgc2V0IGZpcnN0IGZyYWdtZW50IG1heCBmZXRjaER1cmF0aW9uIHRvICR7TWF0aC5yb3VuZCgxZTMgKiBoKX0gbXNgKSwgdSA9IGQgPSAxKTtcbiAgICB9XG4gICAgY29uc3QgZiA9IHRoaXMuZmluZEJlc3RMZXZlbChsLCBvLCBuLCBjLCBoLCB1LCBkKTtcbiAgICBpZiAodGhpcy5yZWJ1ZmZlck5vdGljZSAhPT0gZiAmJiAodGhpcy5yZWJ1ZmZlck5vdGljZSA9IGYsIHRoaXMuaW5mbyhgJHtjID8gXCJyZWJ1ZmZlcmluZyBleHBlY3RlZFwiIDogXCJidWZmZXIgaXMgZW1wdHlcIn0sIG9wdGltYWwgcXVhbGl0eSBsZXZlbCAke2Z9YCkpLCBmID4gLTEpXG4gICAgICByZXR1cm4gZjtcbiAgICBjb25zdCBwID0gci5sZXZlbHNbb10sIHkgPSByLmxvYWRMZXZlbE9iajtcbiAgICByZXR1cm4geSAmJiAocCA9PSBudWxsID8gdm9pZCAwIDogcC5iaXRyYXRlKSA8IHkuYml0cmF0ZSA/IG8gOiByLmxvYWRMZXZlbDtcbiAgfVxuICBnZXRTdGFydmF0aW9uRGVsYXkoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuaGxzLCB0ID0gZS5tZWRpYTtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm4gMSAvIDA7XG4gICAgY29uc3QgciA9IHQgJiYgdC5wbGF5YmFja1JhdGUgIT09IDAgPyBNYXRoLmFicyh0LnBsYXliYWNrUmF0ZSkgOiAxLCBuID0gZS5tYWluRm9yd2FyZEJ1ZmZlckluZm87XG4gICAgcmV0dXJuIChuID8gbi5sZW4gOiAwKSAvIHI7XG4gIH1cbiAgZ2V0QndFc3RpbWF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5id0VzdGltYXRvci5jYW5Fc3RpbWF0ZSgpID8gdGhpcy5id0VzdGltYXRvci5nZXRFc3RpbWF0ZSgpIDogdGhpcy5obHMuY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGU7XG4gIH1cbiAgZmluZEJlc3RMZXZlbChlLCB0LCByLCBuLCBpLCBvLCBhKSB7XG4gICAgdmFyIGw7XG4gICAgY29uc3QgYyA9IG4gKyBpLCB1ID0gdGhpcy5sYXN0TG9hZGVkRnJhZ0xldmVsLCBkID0gdSA9PT0gLTEgPyB0aGlzLmhscy5maXJzdExldmVsIDogdSwge1xuICAgICAgZnJhZ0N1cnJlbnQ6IGgsXG4gICAgICBwYXJ0Q3VycmVudDogZlxuICAgIH0gPSB0aGlzLCB7XG4gICAgICBsZXZlbHM6IHAsXG4gICAgICBhbGxBdWRpb1RyYWNrczogeSxcbiAgICAgIGxvYWRMZXZlbDogRSxcbiAgICAgIGNvbmZpZzogYlxuICAgIH0gPSB0aGlzLmhscztcbiAgICBpZiAocC5sZW5ndGggPT09IDEpXG4gICAgICByZXR1cm4gMDtcbiAgICBjb25zdCBSID0gcFtkXSwgQSA9ICEhKChsID0gdGhpcy5obHMubGF0ZXN0TGV2ZWxEZXRhaWxzKSAhPSBudWxsICYmIGwubGl2ZSksIEYgPSBFID09PSAtMSB8fCB1ID09PSAtMTtcbiAgICBsZXQgTSwgSCA9IFwiU0RSXCIsIEsgPSAoUiA9PSBudWxsID8gdm9pZCAwIDogUi5mcmFtZVJhdGUpIHx8IDA7XG4gICAgY29uc3Qge1xuICAgICAgYXVkaW9QcmVmZXJlbmNlOiBqLFxuICAgICAgdmlkZW9QcmVmZXJlbmNlOiBDXG4gICAgfSA9IGIsIGsgPSB0aGlzLmF1ZGlvVHJhY2tzQnlHcm91cCB8fCAodGhpcy5hdWRpb1RyYWNrc0J5R3JvdXAgPSAkZyh5KSk7XG4gICAgbGV0ICQgPSAtMTtcbiAgICBpZiAoRikge1xuICAgICAgaWYgKHRoaXMuZmlyc3RTZWxlY3Rpb24gIT09IC0xKVxuICAgICAgICByZXR1cm4gdGhpcy5maXJzdFNlbGVjdGlvbjtcbiAgICAgIGNvbnN0IHcgPSB0aGlzLmNvZGVjVGllcnMgfHwgKHRoaXMuY29kZWNUaWVycyA9IGZiKHAsIGssIHQsIHIpKSwgRCA9IGhiKHcsIEgsIGUsIGosIEMpLCB7XG4gICAgICAgIGNvZGVjU2V0OiBPLFxuICAgICAgICB2aWRlb1JhbmdlczogVSxcbiAgICAgICAgbWluRnJhbWVyYXRlOiBWLFxuICAgICAgICBtaW5CaXRyYXRlOiBMLFxuICAgICAgICBtaW5JbmRleDogbSxcbiAgICAgICAgcHJlZmVySERSOiB2XG4gICAgICB9ID0gRDtcbiAgICAgICQgPSBtLCBNID0gTywgSCA9IHYgPyBVW1UubGVuZ3RoIC0gMV0gOiBVWzBdLCBLID0gViwgZSA9IE1hdGgubWF4KGUsIEwpLCB0aGlzLmxvZyhgcGlja2VkIHN0YXJ0IHRpZXIgJHthdChEKX1gKTtcbiAgICB9IGVsc2VcbiAgICAgIE0gPSBSID09IG51bGwgPyB2b2lkIDAgOiBSLmNvZGVjU2V0LCBIID0gUiA9PSBudWxsID8gdm9pZCAwIDogUi52aWRlb1JhbmdlO1xuICAgIGNvbnN0IFcgPSBmID8gZi5kdXJhdGlvbiA6IGggPyBoLmR1cmF0aW9uIDogMCwgXyA9IHRoaXMuYndFc3RpbWF0b3IuZ2V0RXN0aW1hdGVUVEZCKCkgLyAxZTMsIGcgPSBbXTtcbiAgICBmb3IgKGxldCB3ID0gcjsgdyA+PSB0OyB3LS0pIHtcbiAgICAgIHZhciB4O1xuICAgICAgY29uc3QgRCA9IHBbd10sIE8gPSB3ID4gZDtcbiAgICAgIGlmICghRClcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoYi51c2VNZWRpYUNhcGFiaWxpdGllcyAmJiAhRC5zdXBwb3J0ZWRSZXN1bHQgJiYgIUQuc3VwcG9ydGVkUHJvbWlzZSkge1xuICAgICAgICBjb25zdCBOID0gbmF2aWdhdG9yLm1lZGlhQ2FwYWJpbGl0aWVzO1xuICAgICAgICB0eXBlb2YgKE4gPT0gbnVsbCA/IHZvaWQgMCA6IE4uZGVjb2RpbmdJbmZvKSA9PSBcImZ1bmN0aW9uXCIgJiYgcmIoRCwgaywgSCwgSywgZSwgaikgPyAoRC5zdXBwb3J0ZWRQcm9taXNlID0gTmcoRCwgaywgTiwgdGhpcy5zdXBwb3J0ZWRDYWNoZSksIEQuc3VwcG9ydGVkUHJvbWlzZS50aGVuKChZKSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLmhscylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBELnN1cHBvcnRlZFJlc3VsdCA9IFk7XG4gICAgICAgICAgY29uc3QgZWUgPSB0aGlzLmhscy5sZXZlbHMsIGllID0gZWUuaW5kZXhPZihEKTtcbiAgICAgICAgICBZLmVycm9yID8gdGhpcy53YXJuKGBNZWRpYUNhcGFiaWxpdGllcyBkZWNvZGluZ0luZm8gZXJyb3I6IFwiJHtZLmVycm9yfVwiIGZvciBsZXZlbCAke2llfSAke2F0KFkpfWApIDogWS5zdXBwb3J0ZWQgPyBZLmRlY29kaW5nSW5mb1Jlc3VsdHMuc29tZSgobGUpID0+IGxlLnNtb290aCA9PT0gITEgfHwgbGUucG93ZXJFZmZpY2llbnQgPT09ICExKSAmJiB0aGlzLmxvZyhgTWVkaWFDYXBhYmlsaXRpZXMgZGVjb2RpbmdJbmZvIGZvciBsZXZlbCAke2llfSBub3Qgc21vb3RoIG9yIHBvd2VyRWZmaWNpZW50OiAke2F0KFkpfWApIDogKHRoaXMud2FybihgVW5zdXBwb3J0ZWQgTWVkaWFDYXBhYmlsaXRpZXMgZGVjb2RpbmdJbmZvIHJlc3VsdCBmb3IgbGV2ZWwgJHtpZX0gJHthdChZKX1gKSwgaWUgPiAtMSAmJiBlZS5sZW5ndGggPiAxICYmICh0aGlzLmxvZyhgUmVtb3ZpbmcgdW5zdXBwb3J0ZWQgbGV2ZWwgJHtpZX1gKSwgdGhpcy5obHMucmVtb3ZlTGV2ZWwoaWUpLCB0aGlzLmhscy5sb2FkTGV2ZWwgPT09IC0xICYmICh0aGlzLmhscy5uZXh0TG9hZExldmVsID0gMCkpKTtcbiAgICAgICAgfSkuY2F0Y2goKFkpID0+IHtcbiAgICAgICAgICB0aGlzLndhcm4oYEVycm9yIGhhbmRsaW5nIE1lZGlhQ2FwYWJpbGl0aWVzIGRlY29kaW5nSW5mbzogJHtZfWApO1xuICAgICAgICB9KSkgOiBELnN1cHBvcnRlZFJlc3VsdCA9IEJnO1xuICAgICAgfVxuICAgICAgaWYgKChNICYmIEQuY29kZWNTZXQgIT09IE0gfHwgSCAmJiBELnZpZGVvUmFuZ2UgIT09IEggfHwgTyAmJiBLID4gRC5mcmFtZVJhdGUgfHwgIU8gJiYgSyA+IDAgJiYgSyA8IEQuZnJhbWVSYXRlIHx8ICh4ID0gRC5zdXBwb3J0ZWRSZXN1bHQpICE9IG51bGwgJiYgKHggPSB4LmRlY29kaW5nSW5mb1Jlc3VsdHMpICE9IG51bGwgJiYgeC5zb21lKChOKSA9PiBOLnNtb290aCA9PT0gITEpKSAmJiAoIUYgfHwgdyAhPT0gJCkpIHtcbiAgICAgICAgZy5wdXNoKHcpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFUgPSBELmRldGFpbHMsIFYgPSAoZiA/IFUgPT0gbnVsbCA/IHZvaWQgMCA6IFUucGFydFRhcmdldCA6IFUgPT0gbnVsbCA/IHZvaWQgMCA6IFUuYXZlcmFnZXRhcmdldGR1cmF0aW9uKSB8fCBXO1xuICAgICAgbGV0IEw7XG4gICAgICBPID8gTCA9IGEgKiBlIDogTCA9IG8gKiBlO1xuICAgICAgY29uc3QgbSA9IFcgJiYgbiA+PSBXICogMiAmJiBpID09PSAwID8gRC5hdmVyYWdlQml0cmF0ZSA6IEQubWF4Qml0cmF0ZSwgdiA9IHRoaXMuZ2V0VGltZVRvTG9hZEZyYWcoXywgTCwgbSAqIFYsIFUgPT09IHZvaWQgMCk7XG4gICAgICBpZiAoXG4gICAgICAgIC8vIGlmIGFkanVzdGVkIGJ3IGlzIGdyZWF0ZXIgdGhhbiBsZXZlbCBiaXRyYXRlIEFORFxuICAgICAgICBMID49IG0gJiYgLy8gbm8gbGV2ZWwgY2hhbmdlLCBvciBuZXcgbGV2ZWwgaGFzIG5vIGVycm9yIGhpc3RvcnlcbiAgICAgICAgKHcgPT09IHUgfHwgRC5sb2FkRXJyb3IgPT09IDAgJiYgRC5mcmFnbWVudEVycm9yID09PSAwKSAmJiAvLyBmcmFnbWVudCBmZXRjaER1cmF0aW9uIHVua25vd24gT1IgbGl2ZSBzdHJlYW0gT1IgZnJhZ21lbnQgZmV0Y2hEdXJhdGlvbiBsZXNzIHRoYW4gbWF4IGFsbG93ZWQgZmV0Y2ggZHVyYXRpb24sIHRoZW4gdGhpcyBsZXZlbCBtYXRjaGVzXG4gICAgICAgIC8vIHdlIGRvbid0IGFjY291bnQgZm9yIG1heCBGZXRjaCBEdXJhdGlvbiBmb3IgbGl2ZSBzdHJlYW1zLCB0aGlzIGlzIHRvIGF2b2lkIHN3aXRjaGluZyBkb3duIHdoZW4gbmVhciB0aGUgZWRnZSBvZiBsaXZlIHNsaWRpbmcgd2luZG93IC4uLlxuICAgICAgICAvLyBzcGVjaWFsIGNhc2UgdG8gc3VwcG9ydCBzdGFydExldmVsID0gLTEgKGJpdHJhdGVUZXN0KSBvbiBsaXZlIHN0cmVhbXMgOiBpbiB0aGF0IGNhc2Ugd2Ugc2hvdWxkIG5vdCBleGl0IGxvb3Agc28gdGhhdCBmaW5kQmVzdExldmVsIHdpbGwgcmV0dXJuIC0xXG4gICAgICAgICh2IDw9IF8gfHwgIXVlKHYpIHx8IEEgJiYgIXRoaXMuYml0cmF0ZVRlc3REZWxheSB8fCB2IDwgYylcbiAgICAgICkge1xuICAgICAgICBjb25zdCBOID0gdGhpcy5mb3JjZWRBdXRvTGV2ZWw7XG4gICAgICAgIHJldHVybiB3ICE9PSBFICYmIChOID09PSAtMSB8fCBOICE9PSBFKSAmJiAoZy5sZW5ndGggJiYgdGhpcy50cmFjZShgU2tpcHBlZCBsZXZlbChzKSAke2cuam9pbihcIixcIil9IG9mICR7cn0gbWF4IHdpdGggQ09ERUNTIGFuZCBWSURFTy1SQU5HRTpcIiR7cFtnWzBdXS5jb2RlY3N9XCIgJHtwW2dbMF1dLnZpZGVvUmFuZ2V9OyBub3QgY29tcGF0aWJsZSB3aXRoIFwiJHtNfVwiICR7SH1gKSwgdGhpcy5pbmZvKGBzd2l0Y2ggY2FuZGlkYXRlOiR7ZH0tPiR7d30gYWRqdXN0ZWRidygke01hdGgucm91bmQoTCl9KS1iaXRyYXRlPSR7TWF0aC5yb3VuZChMIC0gbSl9IHR0ZmI6JHtfLnRvRml4ZWQoMSl9IGF2Z0R1cmF0aW9uOiR7Vi50b0ZpeGVkKDEpfSBtYXhGZXRjaER1cmF0aW9uOiR7Yy50b0ZpeGVkKDEpfSBmZXRjaER1cmF0aW9uOiR7di50b0ZpeGVkKDEpfSBmaXJzdFNlbGVjdGlvbjoke0Z9IGNvZGVjU2V0OiR7RC5jb2RlY1NldH0gdmlkZW9SYW5nZToke0QudmlkZW9SYW5nZX0gaGxzLmxvYWRMZXZlbDoke0V9YCkpLCBGICYmICh0aGlzLmZpcnN0U2VsZWN0aW9uID0gdyksIHc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBzZXQgbmV4dEF1dG9MZXZlbChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZGVyaXZlTmV4dEF1dG9MZXZlbChlKTtcbiAgICB0aGlzLl9uZXh0QXV0b0xldmVsICE9PSB0ICYmICh0aGlzLm5leHRBdXRvTGV2ZWxLZXkgPSBcIlwiLCB0aGlzLl9uZXh0QXV0b0xldmVsID0gdCk7XG4gIH1cbiAgZGVyaXZlTmV4dEF1dG9MZXZlbChlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWF4QXV0b0xldmVsOiB0LFxuICAgICAgbWluQXV0b0xldmVsOiByXG4gICAgfSA9IHRoaXMuaGxzO1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChlLCByKSwgdCk7XG4gIH1cbn1cbmNvbnN0IEdnID0ge1xuICAvKipcbiAgICogU2VhcmNoZXMgZm9yIGFuIGl0ZW0gaW4gYW4gYXJyYXkgd2hpY2ggbWF0Y2hlcyBhIGNlcnRhaW4gY29uZGl0aW9uLlxuICAgKiBUaGlzIHJlcXVpcmVzIHRoZSBjb25kaXRpb24gdG8gb25seSBtYXRjaCBvbmUgaXRlbSBpbiB0aGUgYXJyYXksXG4gICAqIGFuZCBmb3IgdGhlIGFycmF5IHRvIGJlIG9yZGVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSBsaXN0IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSBjb21wYXJpc29uRm5cbiAgICogICAgICBDYWxsZWQgYW5kIHByb3ZpZGVkIGEgY2FuZGlkYXRlIGl0ZW0gYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgKiAgICAgIFNob3VsZCByZXR1cm46XG4gICAqICAgICAgICAgID4gLTEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBsb3dlciBpbmRleCB0aGFuIHRoZSBwcm92aWRlZCBpdGVtLlxuICAgKiAgICAgICAgICA+IDEgaWYgdGhlIGl0ZW0gc2hvdWxkIGJlIGxvY2F0ZWQgYXQgYSBoaWdoZXIgaW5kZXggdGhhbiB0aGUgcHJvdmlkZWQgaXRlbS5cbiAgICogICAgICAgICAgPiAwIGlmIHRoZSBpdGVtIGlzIHRoZSBpdGVtIHlvdSdyZSBsb29raW5nIGZvci5cbiAgICpcbiAgICogQHJldHVybnMgdGhlIG9iamVjdCBpZiBmb3VuZCwgb3RoZXJ3aXNlIHJldHVybnMgbnVsbFxuICAgKi9cbiAgc2VhcmNoOiBmdW5jdGlvbihzLCBlKSB7XG4gICAgbGV0IHQgPSAwLCByID0gcy5sZW5ndGggLSAxLCBuID0gbnVsbCwgaSA9IG51bGw7XG4gICAgZm9yICg7IHQgPD0gcjsgKSB7XG4gICAgICBuID0gKHQgKyByKSAvIDIgfCAwLCBpID0gc1tuXTtcbiAgICAgIGNvbnN0IG8gPSBlKGkpO1xuICAgICAgaWYgKG8gPiAwKVxuICAgICAgICB0ID0gbiArIDE7XG4gICAgICBlbHNlIGlmIChvIDwgMClcbiAgICAgICAgciA9IG4gLSAxO1xuICAgICAgZWxzZVxuICAgICAgICByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5mdW5jdGlvbiB2YihzLCBlLCB0KSB7XG4gIGlmIChlID09PSBudWxsIHx8ICFBcnJheS5pc0FycmF5KHMpIHx8ICFzLmxlbmd0aCB8fCAhdWUoZSkpXG4gICAgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHIgPSBzWzBdLnByb2dyYW1EYXRlVGltZTtcbiAgaWYgKGUgPCAociB8fCAwKSlcbiAgICByZXR1cm4gbnVsbDtcbiAgY29uc3QgbiA9IHNbcy5sZW5ndGggLSAxXS5lbmRQcm9ncmFtRGF0ZVRpbWU7XG4gIGlmIChlID49IChuIHx8IDApKVxuICAgIHJldHVybiBudWxsO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBvID0gc1tpXTtcbiAgICBpZiAoeGIoZSwgdCwgbykpXG4gICAgICByZXR1cm4gbztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIEpzKHMsIGUsIHQgPSAwLCByID0gMCwgbiA9IDVlLTMpIHtcbiAgbGV0IGkgPSBudWxsO1xuICBpZiAocykge1xuICAgIGkgPSBlWzEgKyBzLnNuIC0gZVswXS5zbl0gfHwgbnVsbDtcbiAgICBjb25zdCBhID0gcy5lbmREVFMgLSB0O1xuICAgIGEgPiAwICYmIGEgPCAxNWUtNyAmJiAodCArPSAxNWUtNyksIGkgJiYgcy5sZXZlbCAhPT0gaS5sZXZlbCAmJiBpLmVuZCA8PSBzLmVuZCAmJiAoaSA9IGVbMiArIHMuc24gLSBlWzBdLnNuXSB8fCBudWxsKTtcbiAgfSBlbHNlIHQgPT09IDAgJiYgZVswXS5zdGFydCA9PT0gMCAmJiAoaSA9IGVbMF0pO1xuICBpZiAoaSAmJiAoKCFzIHx8IHMubGV2ZWwgPT09IGkubGV2ZWwpICYmIGRoKHQsIHIsIGkpID09PSAwIHx8IEViKGksIHMsIE1hdGgubWluKG4sIHIpKSkpXG4gICAgcmV0dXJuIGk7XG4gIGNvbnN0IG8gPSBHZy5zZWFyY2goZSwgZGguYmluZChudWxsLCB0LCByKSk7XG4gIHJldHVybiBvICYmIChvICE9PSBzIHx8ICFpKSA/IG8gOiBpO1xufVxuZnVuY3Rpb24gRWIocywgZSwgdCkge1xuICBpZiAoZSAmJiBlLnN0YXJ0ID09PSAwICYmIGUubGV2ZWwgPCBzLmxldmVsICYmIChlLmVuZFBUUyB8fCAwKSA+IDApIHtcbiAgICBjb25zdCByID0gZS50YWdMaXN0LnJlZHVjZSgobiwgaSkgPT4gKGlbMF0gPT09IFwiSU5GXCIgJiYgKG4gKz0gcGFyc2VGbG9hdChpWzFdKSksIG4pLCB0KTtcbiAgICByZXR1cm4gcy5zdGFydCA8PSByO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIGRoKHMgPSAwLCBlID0gMCwgdCkge1xuICBpZiAodC5zdGFydCA8PSBzICYmIHQuc3RhcnQgKyB0LmR1cmF0aW9uID4gcylcbiAgICByZXR1cm4gMDtcbiAgY29uc3QgciA9IE1hdGgubWluKGUsIHQuZHVyYXRpb24gKyAodC5kZWx0YVBUUyA/IHQuZGVsdGFQVFMgOiAwKSk7XG4gIHJldHVybiB0LnN0YXJ0ICsgdC5kdXJhdGlvbiAtIHIgPD0gcyA/IDEgOiB0LnN0YXJ0IC0gciA+IHMgJiYgdC5zdGFydCA/IC0xIDogMDtcbn1cbmZ1bmN0aW9uIHhiKHMsIGUsIHQpIHtcbiAgY29uc3QgciA9IE1hdGgubWluKGUsIHQuZHVyYXRpb24gKyAodC5kZWx0YVBUUyA/IHQuZGVsdGFQVFMgOiAwKSkgKiAxZTM7XG4gIHJldHVybiAodC5lbmRQcm9ncmFtRGF0ZVRpbWUgfHwgMCkgLSByID4gcztcbn1cbmZ1bmN0aW9uIFZnKHMsIGUsIHQpIHtcbiAgaWYgKHMgJiYgcy5zdGFydENDIDw9IGUgJiYgcy5lbmRDQyA+PSBlKSB7XG4gICAgbGV0IHIgPSBzLmZyYWdtZW50cztcbiAgICBjb25zdCB7XG4gICAgICBmcmFnbWVudEhpbnQ6IG5cbiAgICB9ID0gcztcbiAgICBuICYmIChyID0gci5jb25jYXQobikpO1xuICAgIGxldCBpO1xuICAgIHJldHVybiBHZy5zZWFyY2gociwgKG8pID0+IG8uY2MgPCBlID8gMSA6IG8uY2MgPiBlID8gLTEgOiAoaSA9IG8sIG8uZW5kIDw9IHQgPyAxIDogby5zdGFydCA+IHQgPyAtMSA6IDApKSwgaSB8fCBudWxsO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZWEocykge1xuICBzd2l0Y2ggKHMuZGV0YWlscykge1xuICAgIGNhc2UgSi5GUkFHX0xPQURfVElNRU9VVDpcbiAgICBjYXNlIEouS0VZX0xPQURfVElNRU9VVDpcbiAgICBjYXNlIEouTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgIGNhc2UgSi5NQU5JRkVTVF9MT0FEX1RJTUVPVVQ6XG4gICAgICByZXR1cm4gITA7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuZnVuY3Rpb24gamcocykge1xuICByZXR1cm4gcy5kZXRhaWxzLnN0YXJ0c1dpdGgoXCJrZXlcIik7XG59XG5mdW5jdGlvbiBLZyhzKSB7XG4gIHJldHVybiBqZyhzKSAmJiAhIXMuZnJhZyAmJiAhcy5mcmFnLmRlY3J5cHRkYXRhO1xufVxuZnVuY3Rpb24gaGgocywgZSkge1xuICBjb25zdCB0ID0gZWEoZSk7XG4gIHJldHVybiBzLmRlZmF1bHRbYCR7dCA/IFwidGltZW91dFwiIDogXCJlcnJvclwifVJldHJ5YF07XG59XG5mdW5jdGlvbiB5dShzLCBlKSB7XG4gIGNvbnN0IHQgPSBzLmJhY2tvZmYgPT09IFwibGluZWFyXCIgPyAxIDogTWF0aC5wb3coMiwgZSk7XG4gIHJldHVybiBNYXRoLm1pbih0ICogcy5yZXRyeURlbGF5TXMsIHMubWF4UmV0cnlEZWxheU1zKTtcbn1cbmZ1bmN0aW9uIGZoKHMpIHtcbiAgcmV0dXJuIHR0KHR0KHt9LCBzKSwge1xuICAgIGVycm9yUmV0cnk6IG51bGwsXG4gICAgdGltZW91dFJldHJ5OiBudWxsXG4gIH0pO1xufVxuZnVuY3Rpb24gdGEocywgZSwgdCwgcikge1xuICBpZiAoIXMpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBuID0gciA9PSBudWxsID8gdm9pZCAwIDogci5jb2RlLCBpID0gZSA8IHMubWF4TnVtUmV0cnkgJiYgKFNiKG4pIHx8ICEhdCk7XG4gIHJldHVybiBzLnNob3VsZFJldHJ5ID8gcy5zaG91bGRSZXRyeShzLCBlLCB0LCByLCBpKSA6IGk7XG59XG5mdW5jdGlvbiBTYihzKSB7XG4gIHJldHVybiB1YyhzKSB8fCAhIXMgJiYgKHMgPCA0MDAgfHwgcyA+IDQ5OSk7XG59XG5mdW5jdGlvbiB1YyhzKSB7XG4gIHJldHVybiBzID09PSAwICYmIG5hdmlnYXRvci5vbkxpbmUgPT09ICExO1xufVxudmFyIFp0ID0ge1xuICBEb05vdGhpbmc6IDAsXG4gIFNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3g6IDIsXG4gIFJlbW92ZUFsdGVybmF0ZVBlcm1hbmVudGx5OiAzLFxuICBSZXRyeVJlcXVlc3Q6IDVcbn0sIHZyID0ge1xuICBOb25lOiAwLFxuICBNb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdDogMSxcbiAgTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hEQ1A6IDIsXG4gIE1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdLZXk6IDRcbn07XG5jbGFzcyBiYiBleHRlbmRzIExyIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKFwiZXJyb3ItY29udHJvbGxlclwiLCBlLmxvZ2dlciksIHRoaXMuaGxzID0gdm9pZCAwLCB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwLCB0aGlzLmhscyA9IGUsIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5obHM7XG4gICAgZS5vbihJLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpLCBlLm9uKEkuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyksIGUub24oSS5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmhscztcbiAgICBlICYmIChlLm9mZihJLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpLCBlLm9mZihJLkVSUk9SLCB0aGlzLm9uRXJyb3JPdXQsIHRoaXMpLCBlLm9mZihJLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpLCBlLm9mZihJLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpLCB0aGlzLmhscyA9IG51bGw7XG4gIH1cbiAgc3RhcnRMb2FkKGUpIHtcbiAgfVxuICBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwO1xuICB9XG4gIGdldFZhcmlhbnRMZXZlbEluZGV4KGUpIHtcbiAgICByZXR1cm4gKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUudHlwZSkgPT09IHBlLk1BSU4gPyBlLmxldmVsIDogdGhpcy5nZXRWYXJpYW50SW5kZXgoKTtcbiAgfVxuICBnZXRWYXJpYW50SW5kZXgoKSB7XG4gICAgdmFyIGU7XG4gICAgY29uc3QgdCA9IHRoaXMuaGxzLCByID0gdC5jdXJyZW50TGV2ZWw7XG4gICAgcmV0dXJuIChlID0gdC5sb2FkTGV2ZWxPYmopICE9IG51bGwgJiYgZS5kZXRhaWxzIHx8IHIgPT09IC0xID8gdC5sb2FkTGV2ZWwgOiByO1xuICB9XG4gIHZhcmlhbnRIYXNLZXkoZSwgdCkge1xuICAgIGlmIChlKSB7XG4gICAgICB2YXIgcjtcbiAgICAgIGlmICgociA9IGUuZGV0YWlscykgIT0gbnVsbCAmJiByLmhhc0tleSh0KSlcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgY29uc3QgbiA9IGUuYXVkaW9Hcm91cHM7XG4gICAgICBpZiAobilcbiAgICAgICAgcmV0dXJuIHRoaXMuaGxzLmFsbEF1ZGlvVHJhY2tzLmZpbHRlcigobykgPT4gbi5pbmRleE9mKG8uZ3JvdXBJZCkgPj0gMCkuc29tZSgobykgPT4ge1xuICAgICAgICAgIHZhciBhO1xuICAgICAgICAgIHJldHVybiAoYSA9IG8uZGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IGEuaGFzS2V5KHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMucGxheWxpc3RFcnJvciA9IDA7XG4gIH1cbiAgb25MZXZlbFVwZGF0ZWQoKSB7XG4gICAgdGhpcy5wbGF5bGlzdEVycm9yID0gMDtcbiAgfVxuICBvbkVycm9yKGUsIHQpIHtcbiAgICB2YXIgcjtcbiAgICBpZiAodC5mYXRhbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuID0gdGhpcy5obHMsIGkgPSB0LmNvbnRleHQ7XG4gICAgc3dpdGNoICh0LmRldGFpbHMpIHtcbiAgICAgIGNhc2UgSi5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEouRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEouS0VZX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEouS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgdC5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0RnJhZ1JldHJ5T3JTd2l0Y2hBY3Rpb24odCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgSi5GUkFHX1BBUlNJTkdfRVJST1I6XG4gICAgICAgIGlmICgociA9IHQuZnJhZykgIT0gbnVsbCAmJiByLmdhcCkge1xuICAgICAgICAgIHQuZXJyb3JBY3Rpb24gPSBBbigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSBKLkZSQUdfR0FQOlxuICAgICAgY2FzZSBKLkZSQUdfREVDUllQVF9FUlJPUjoge1xuICAgICAgICB0LmVycm9yQWN0aW9uID0gdGhpcy5nZXRGcmFnUmV0cnlPclN3aXRjaEFjdGlvbih0KSwgdC5lcnJvckFjdGlvbi5hY3Rpb24gPSBadC5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYXNlIEouTEVWRUxfRU1QVFlfRVJST1I6XG4gICAgICBjYXNlIEouTEVWRUxfUEFSU0lOR19FUlJPUjpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBvO1xuICAgICAgICAgIGNvbnN0IGwgPSB0LnBhcmVudCA9PT0gcGUuTUFJTiA/IHQubGV2ZWwgOiBuLmxvYWRMZXZlbDtcbiAgICAgICAgICB0LmRldGFpbHMgPT09IEouTEVWRUxfRU1QVFlfRVJST1IgJiYgKChvID0gdC5jb250ZXh0KSAhPSBudWxsICYmIChvID0gby5sZXZlbERldGFpbHMpICE9IG51bGwgJiYgby5saXZlKSA/IHQuZXJyb3JBY3Rpb24gPSB0aGlzLmdldFBsYXlsaXN0UmV0cnlPclN3aXRjaEFjdGlvbih0LCBsKSA6ICh0LmxldmVsUmV0cnkgPSAhMSwgdC5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24odCwgbCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIGNhc2UgSi5MRVZFTF9MT0FEX0VSUk9SOlxuICAgICAgY2FzZSBKLkxFVkVMX0xPQURfVElNRU9VVDpcbiAgICAgICAgdHlwZW9mIChpID09IG51bGwgPyB2b2lkIDAgOiBpLmxldmVsKSA9PSBcIm51bWJlclwiICYmICh0LmVycm9yQWN0aW9uID0gdGhpcy5nZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24odCwgaS5sZXZlbCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEouQVVESU9fVFJBQ0tfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgSi5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEouU1VCVElUTEVfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgSi5TVUJUSVRMRV9UUkFDS19MT0FEX1RJTUVPVVQ6XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgY29uc3QgbCA9IG4ubG9hZExldmVsT2JqO1xuICAgICAgICAgIGlmIChsICYmIChpLnR5cGUgPT09IEtlLkFVRElPX1RSQUNLICYmIGwuaGFzQXVkaW9Hcm91cChpLmdyb3VwSWQpIHx8IGkudHlwZSA9PT0gS2UuU1VCVElUTEVfVFJBQ0sgJiYgbC5oYXNTdWJ0aXRsZUdyb3VwKGkuZ3JvdXBJZCkpKSB7XG4gICAgICAgICAgICB0LmVycm9yQWN0aW9uID0gdGhpcy5nZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24odCwgbi5sb2FkTGV2ZWwpLCB0LmVycm9yQWN0aW9uLmFjdGlvbiA9IFp0LlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3gsIHQuZXJyb3JBY3Rpb24uZmxhZ3MgPSB2ci5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBKLktFWV9TWVNURU1fU1RBVFVTX09VVFBVVF9SRVNUUklDVEVEOlxuICAgICAgICB0LmVycm9yQWN0aW9uID0ge1xuICAgICAgICAgIGFjdGlvbjogWnQuU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCxcbiAgICAgICAgICBmbGFnczogdnIuTW92ZUFsbEFsdGVybmF0ZXNNYXRjaGluZ0hEQ1BcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBKLktFWV9TWVNURU1fU0VTU0lPTl9VUERBVEVfRkFJTEVEOlxuICAgICAgY2FzZSBKLktFWV9TWVNURU1fU1RBVFVTX0lOVEVSTkFMX0VSUk9SOlxuICAgICAgY2FzZSBKLktFWV9TWVNURU1fTk9fU0VTU0lPTjpcbiAgICAgICAgdC5lcnJvckFjdGlvbiA9IHtcbiAgICAgICAgICBhY3Rpb246IFp0LlNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3gsXG4gICAgICAgICAgZmxhZ3M6IHZyLk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdLZXlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBKLkJVRkZFUl9BRERfQ09ERUNfRVJST1I6XG4gICAgICBjYXNlIEouUkVNVVhfQUxMT0NfRVJST1I6XG4gICAgICBjYXNlIEouQlVGRkVSX0FQUEVORF9FUlJPUjpcbiAgICAgICAgaWYgKCF0LmVycm9yQWN0aW9uKSB7XG4gICAgICAgICAgdmFyIGE7XG4gICAgICAgICAgdC5lcnJvckFjdGlvbiA9IHRoaXMuZ2V0TGV2ZWxTd2l0Y2hBY3Rpb24odCwgKGEgPSB0LmxldmVsKSAhPSBudWxsID8gYSA6IG4ubG9hZExldmVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEouSU5URVJOQUxfRVhDRVBUSU9OOlxuICAgICAgY2FzZSBKLkJVRkZFUl9BUFBFTkRJTkdfRVJST1I6XG4gICAgICBjYXNlIEouQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICBjYXNlIEouTEVWRUxfU1dJVENIX0VSUk9SOlxuICAgICAgY2FzZSBKLkJVRkZFUl9TVEFMTEVEX0VSUk9SOlxuICAgICAgY2FzZSBKLkJVRkZFUl9TRUVLX09WRVJfSE9MRTpcbiAgICAgIGNhc2UgSi5CVUZGRVJfTlVER0VfT05fU1RBTEw6XG4gICAgICAgIHQuZXJyb3JBY3Rpb24gPSBBbigpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHQudHlwZSA9PT0gdmUuS0VZX1NZU1RFTV9FUlJPUiAmJiAodC5sZXZlbFJldHJ5ID0gITEsIHQuZXJyb3JBY3Rpb24gPSBBbigpKTtcbiAgfVxuICBnZXRQbGF5bGlzdFJldHJ5T3JTd2l0Y2hBY3Rpb24oZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLmhscywgbiA9IGhoKHIuY29uZmlnLnBsYXlsaXN0TG9hZFBvbGljeSwgZSksIGkgPSB0aGlzLnBsYXlsaXN0RXJyb3IrKztcbiAgICBpZiAodGEobiwgaSwgZWEoZSksIGUucmVzcG9uc2UpKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWN0aW9uOiBadC5SZXRyeVJlcXVlc3QsXG4gICAgICAgIGZsYWdzOiB2ci5Ob25lLFxuICAgICAgICByZXRyeUNvbmZpZzogbixcbiAgICAgICAgcmV0cnlDb3VudDogaVxuICAgICAgfTtcbiAgICBjb25zdCBhID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihlLCB0KTtcbiAgICByZXR1cm4gbiAmJiAoYS5yZXRyeUNvbmZpZyA9IG4sIGEucmV0cnlDb3VudCA9IGkpLCBhO1xuICB9XG4gIGdldEZyYWdSZXRyeU9yU3dpdGNoQWN0aW9uKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5obHMsIHIgPSB0aGlzLmdldFZhcmlhbnRMZXZlbEluZGV4KGUuZnJhZyksIG4gPSB0LmxldmVsc1tyXSwge1xuICAgICAgZnJhZ0xvYWRQb2xpY3k6IGksXG4gICAgICBrZXlMb2FkUG9saWN5OiBvXG4gICAgfSA9IHQuY29uZmlnLCBhID0gaGgoamcoZSkgPyBvIDogaSwgZSksIGwgPSB0LmxldmVscy5yZWR1Y2UoKHUsIGQpID0+IHUgKyBkLmZyYWdtZW50RXJyb3IsIDApO1xuICAgIGlmIChuICYmIChlLmRldGFpbHMgIT09IEouRlJBR19HQVAgJiYgbi5mcmFnbWVudEVycm9yKyssICFLZyhlKSAmJiB0YShhLCBsLCBlYShlKSwgZS5yZXNwb25zZSkpKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWN0aW9uOiBadC5SZXRyeVJlcXVlc3QsXG4gICAgICAgIGZsYWdzOiB2ci5Ob25lLFxuICAgICAgICByZXRyeUNvbmZpZzogYSxcbiAgICAgICAgcmV0cnlDb3VudDogbFxuICAgICAgfTtcbiAgICBjb25zdCBjID0gdGhpcy5nZXRMZXZlbFN3aXRjaEFjdGlvbihlLCByKTtcbiAgICByZXR1cm4gYSAmJiAoYy5yZXRyeUNvbmZpZyA9IGEsIGMucmV0cnlDb3VudCA9IGwpLCBjO1xuICB9XG4gIGdldExldmVsU3dpdGNoQWN0aW9uKGUsIHQpIHtcbiAgICBjb25zdCByID0gdGhpcy5obHM7XG4gICAgdCA9PSBudWxsICYmICh0ID0gci5sb2FkTGV2ZWwpO1xuICAgIGNvbnN0IG4gPSB0aGlzLmhscy5sZXZlbHNbdF07XG4gICAgaWYgKG4pIHtcbiAgICAgIHZhciBpLCBvO1xuICAgICAgY29uc3QgYyA9IGUuZGV0YWlscztcbiAgICAgIG4ubG9hZEVycm9yKyssIGMgPT09IEouQlVGRkVSX0FQUEVORF9FUlJPUiAmJiBuLmZyYWdtZW50RXJyb3IrKztcbiAgICAgIGxldCB1ID0gLTE7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxldmVsczogZCxcbiAgICAgICAgbG9hZExldmVsOiBoLFxuICAgICAgICBtaW5BdXRvTGV2ZWw6IGYsXG4gICAgICAgIG1heEF1dG9MZXZlbDogcFxuICAgICAgfSA9IHI7XG4gICAgICAhci5hdXRvTGV2ZWxFbmFibGVkICYmICFyLmNvbmZpZy5wcmVzZXJ2ZU1hbnVhbExldmVsT25FcnJvciAmJiAoci5sb2FkTGV2ZWwgPSAtMSk7XG4gICAgICBjb25zdCB5ID0gKGkgPSBlLmZyYWcpID09IG51bGwgPyB2b2lkIDAgOiBpLnR5cGUsIGIgPSAoeSA9PT0gcGUuQVVESU8gJiYgYyA9PT0gSi5GUkFHX1BBUlNJTkdfRVJST1IgfHwgZS5zb3VyY2VCdWZmZXJOYW1lID09PSBcImF1ZGlvXCIgJiYgKGMgPT09IEouQlVGRkVSX0FERF9DT0RFQ19FUlJPUiB8fCBjID09PSBKLkJVRkZFUl9BUFBFTkRfRVJST1IpKSAmJiBkLnNvbWUoKHtcbiAgICAgICAgYXVkaW9Db2RlYzogSFxuICAgICAgfSkgPT4gbi5hdWRpb0NvZGVjICE9PSBIKSwgQSA9IGUuc291cmNlQnVmZmVyTmFtZSA9PT0gXCJ2aWRlb1wiICYmIChjID09PSBKLkJVRkZFUl9BRERfQ09ERUNfRVJST1IgfHwgYyA9PT0gSi5CVUZGRVJfQVBQRU5EX0VSUk9SKSAmJiBkLnNvbWUoKHtcbiAgICAgICAgY29kZWNTZXQ6IEgsXG4gICAgICAgIGF1ZGlvQ29kZWM6IEtcbiAgICAgIH0pID0+IG4uY29kZWNTZXQgIT09IEggJiYgbi5hdWRpb0NvZGVjID09PSBLKSwge1xuICAgICAgICB0eXBlOiBGLFxuICAgICAgICBncm91cElkOiBNXG4gICAgICB9ID0gKG8gPSBlLmNvbnRleHQpICE9IG51bGwgPyBvIDoge307XG4gICAgICBmb3IgKGxldCBIID0gZC5sZW5ndGg7IEgtLTsgKSB7XG4gICAgICAgIGNvbnN0IEsgPSAoSCArIGgpICUgZC5sZW5ndGg7XG4gICAgICAgIGlmIChLICE9PSBoICYmIEsgPj0gZiAmJiBLIDw9IHAgJiYgZFtLXS5sb2FkRXJyb3IgPT09IDApIHtcbiAgICAgICAgICB2YXIgYSwgbDtcbiAgICAgICAgICBjb25zdCBqID0gZFtLXTtcbiAgICAgICAgICBpZiAoYyA9PT0gSi5GUkFHX0dBUCAmJiB5ID09PSBwZS5NQUlOICYmIGUuZnJhZykge1xuICAgICAgICAgICAgY29uc3QgQyA9IGRbS10uZGV0YWlscztcbiAgICAgICAgICAgIGlmIChDKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGsgPSBKcyhlLmZyYWcsIEMuZnJhZ21lbnRzLCBlLmZyYWcuc3RhcnQpO1xuICAgICAgICAgICAgICBpZiAoayAhPSBudWxsICYmIGsuZ2FwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoRiA9PT0gS2UuQVVESU9fVFJBQ0sgJiYgai5oYXNBdWRpb0dyb3VwKE0pIHx8IEYgPT09IEtlLlNVQlRJVExFX1RSQUNLICYmIGouaGFzU3VidGl0bGVHcm91cChNKSlcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoeSA9PT0gcGUuQVVESU8gJiYgKGEgPSBuLmF1ZGlvR3JvdXBzKSAhPSBudWxsICYmIGEuc29tZSgoQykgPT4gai5oYXNBdWRpb0dyb3VwKEMpKSB8fCB5ID09PSBwZS5TVUJUSVRMRSAmJiAobCA9IG4uc3VidGl0bGVHcm91cHMpICE9IG51bGwgJiYgbC5zb21lKChDKSA9PiBqLmhhc1N1YnRpdGxlR3JvdXAoQykpIHx8IGIgJiYgbi5hdWRpb0NvZGVjID09PSBqLmF1ZGlvQ29kZWMgfHwgQSAmJiBuLmNvZGVjU2V0ID09PSBqLmNvZGVjU2V0IHx8ICFiICYmIG4uY29kZWNTZXQgIT09IGouY29kZWNTZXQpXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1ID0gSztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHUgPiAtMSAmJiByLmxvYWRMZXZlbCAhPT0gdSlcbiAgICAgICAgcmV0dXJuIGUubGV2ZWxSZXRyeSA9ICEwLCB0aGlzLnBsYXlsaXN0RXJyb3IgPSAwLCB7XG4gICAgICAgICAgYWN0aW9uOiBadC5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94LFxuICAgICAgICAgIGZsYWdzOiB2ci5Ob25lLFxuICAgICAgICAgIG5leHRBdXRvTGV2ZWw6IHVcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGFjdGlvbjogWnQuU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCxcbiAgICAgIGZsYWdzOiB2ci5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdFxuICAgIH07XG4gIH1cbiAgb25FcnJvck91dChlLCB0KSB7XG4gICAgdmFyIHI7XG4gICAgc3dpdGNoICgociA9IHQuZXJyb3JBY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiByLmFjdGlvbikge1xuICAgICAgY2FzZSBadC5Eb05vdGhpbmc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBadC5TZW5kQWx0ZXJuYXRlVG9QZW5hbHR5Qm94OlxuICAgICAgICB0aGlzLnNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3godCksICF0LmVycm9yQWN0aW9uLnJlc29sdmVkICYmIHQuZGV0YWlscyAhPT0gSi5GUkFHX0dBUCA/IHQuZmF0YWwgPSAhMCA6IC9NZWRpYVNvdXJjZSByZWFkeVN0YXRlOiBlbmRlZC8udGVzdCh0LmVycm9yLm1lc3NhZ2UpICYmICh0aGlzLndhcm4oYE1lZGlhU291cmNlIGVuZGVkIGFmdGVyIFwiJHt0LnNvdXJjZUJ1ZmZlck5hbWV9XCIgc291cmNlQnVmZmVyIGFwcGVuZCBlcnJvci4gQXR0ZW1wdGluZyB0byByZWNvdmVyIGZyb20gbWVkaWEgZXJyb3IuYCksIHRoaXMuaGxzLnJlY292ZXJNZWRpYUVycm9yKCkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKHQuZmF0YWwpIHtcbiAgICAgIHRoaXMuaGxzLnN0b3BMb2FkKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHNlbmRBbHRlcm5hdGVUb1BlbmFsdHlCb3goZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmhscywgciA9IGUuZXJyb3JBY3Rpb247XG4gICAgaWYgKCFyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGZsYWdzOiBuXG4gICAgfSA9IHIsIGkgPSByLm5leHRBdXRvTGV2ZWw7XG4gICAgc3dpdGNoIChuKSB7XG4gICAgICBjYXNlIHZyLk5vbmU6XG4gICAgICAgIHRoaXMuc3dpdGNoTGV2ZWwoZSwgaSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB2ci5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSERDUDoge1xuICAgICAgICBjb25zdCBsID0gdGhpcy5nZXRWYXJpYW50TGV2ZWxJbmRleChlLmZyYWcpLCBjID0gdC5sZXZlbHNbbF0sIHUgPSBjID09IG51bGwgPyB2b2lkIDAgOiBjLmF0dHJzW1wiSERDUC1MRVZFTFwiXTtcbiAgICAgICAgaWYgKHIuaGRjcExldmVsID0gdSwgdSA9PT0gXCJOT05FXCIpXG4gICAgICAgICAgdGhpcy53YXJuKFwiSERDUCBwb2xpY3kgcmVzdGljdGVkIG91dHB1dCB3aXRoIEhEQ1AtTEVWRUw9Tk9ORVwiKTtcbiAgICAgICAgZWxzZSBpZiAodSkge1xuICAgICAgICAgIHQubWF4SGRjcExldmVsID0gY2NbY2MuaW5kZXhPZih1KSAtIDFdLCByLnJlc29sdmVkID0gITAsIHRoaXMud2FybihgUmVzdHJpY3RpbmcgcGxheWJhY2sgdG8gSERDUC1MRVZFTCBvZiBcIiR7dC5tYXhIZGNwTGV2ZWx9XCIgb3IgbG93ZXJgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICBjYXNlIHZyLk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdLZXk6IHtcbiAgICAgICAgY29uc3QgbCA9IGUuZGVjcnlwdGRhdGE7XG4gICAgICAgIGlmIChsKSB7XG4gICAgICAgICAgY29uc3QgYyA9IHRoaXMuaGxzLmxldmVscywgdSA9IGMubGVuZ3RoO1xuICAgICAgICAgIGZvciAobGV0IGggPSB1OyBoLS07IClcbiAgICAgICAgICAgIGlmICh0aGlzLnZhcmlhbnRIYXNLZXkoY1toXSwgbCkpIHtcbiAgICAgICAgICAgICAgdmFyIG8sIGE7XG4gICAgICAgICAgICAgIHRoaXMubG9nKGBCYW5uZWQga2V5IGZvdW5kIGluIGxldmVsICR7aH0gKCR7Y1toXS5iaXRyYXRlfWJwcykgb3IgYXVkaW8gZ3JvdXAgXCIkeyhvID0gY1toXS5hdWRpb0dyb3VwcykgPT0gbnVsbCA/IHZvaWQgMCA6IG8uam9pbihcIixcIil9XCIgKCR7KGEgPSBlLmZyYWcpID09IG51bGwgPyB2b2lkIDAgOiBhLnR5cGV9IGZyYWdtZW50KSAke2ZyKGwua2V5SWQgfHwgW10pfWApLCBjW2hdLmZyYWdtZW50RXJyb3IrKywgY1toXS5sb2FkRXJyb3IrKywgdGhpcy5sb2coYFJlbW92aW5nIGxldmVsICR7aH0gd2l0aCBrZXkgZXJyb3IgKCR7ZS5lcnJvcn0pYCksIHRoaXMuaGxzLnJlbW92ZUxldmVsKGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGQgPSBlLmZyYWc7XG4gICAgICAgICAgaWYgKHRoaXMuaGxzLmxldmVscy5sZW5ndGggPCB1KVxuICAgICAgICAgICAgci5yZXNvbHZlZCA9ICEwO1xuICAgICAgICAgIGVsc2UgaWYgKGQgJiYgZC50eXBlICE9PSBwZS5NQUlOKSB7XG4gICAgICAgICAgICBjb25zdCBoID0gZC5kZWNyeXB0ZGF0YTtcbiAgICAgICAgICAgIGggJiYgIWwubWF0Y2hlcyhoKSAmJiAoci5yZXNvbHZlZCA9ICEwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHIucmVzb2x2ZWQgfHwgdGhpcy5zd2l0Y2hMZXZlbChlLCBpKTtcbiAgfVxuICBzd2l0Y2hMZXZlbChlLCB0KSB7XG4gICAgaWYgKHQgIT09IHZvaWQgMCAmJiBlLmVycm9yQWN0aW9uICYmICh0aGlzLndhcm4oYHN3aXRjaGluZyB0byBsZXZlbCAke3R9IGFmdGVyICR7ZS5kZXRhaWxzfWApLCB0aGlzLmhscy5uZXh0QXV0b0xldmVsID0gdCwgZS5lcnJvckFjdGlvbi5yZXNvbHZlZCA9ICEwLCB0aGlzLmhscy5uZXh0TG9hZExldmVsID0gdGhpcy5obHMubmV4dEF1dG9MZXZlbCwgZS5kZXRhaWxzID09PSBKLkJVRkZFUl9BRERfQ09ERUNfRVJST1IgJiYgZS5taW1lVHlwZSAmJiBlLnNvdXJjZUJ1ZmZlck5hbWUgIT09IFwiYXVkaW92aWRlb1wiKSkge1xuICAgICAgY29uc3QgciA9IGxjKGUubWltZVR5cGUpLCBuID0gdGhpcy5obHMubGV2ZWxzO1xuICAgICAgZm9yIChsZXQgaSA9IG4ubGVuZ3RoOyBpLS07IClcbiAgICAgICAgbltpXVtgJHtlLnNvdXJjZUJ1ZmZlck5hbWV9Q29kZWNgXSA9PT0gciAmJiAodGhpcy5sb2coYFJlbW92aW5nIGxldmVsICR7aX0gZm9yICR7ZS5kZXRhaWxzfSAoXCIke3J9XCIgbm90IHN1cHBvcnRlZClgKSwgdGhpcy5obHMucmVtb3ZlTGV2ZWwoaSkpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gQW4ocykge1xuICBjb25zdCBlID0ge1xuICAgIGFjdGlvbjogWnQuRG9Ob3RoaW5nLFxuICAgIGZsYWdzOiB2ci5Ob25lXG4gIH07XG4gIHJldHVybiBzICYmIChlLnJlc29sdmVkID0gITApLCBlO1xufVxudmFyIEh0ID0ge1xuICBOT1RfTE9BREVEOiBcIk5PVF9MT0FERURcIixcbiAgQVBQRU5ESU5HOiBcIkFQUEVORElOR1wiLFxuICBQQVJUSUFMOiBcIlBBUlRJQUxcIixcbiAgT0s6IFwiT0tcIlxufTtcbmNsYXNzIFRiIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuYWN0aXZlUGFydExpc3RzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHRoaXMuZW5kTGlzdEZyYWdtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB0aGlzLmZyYWdtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB0aGlzLnRpbWVSYW5nZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdGhpcy5idWZmZXJQYWRkaW5nID0gMC4yLCB0aGlzLmhscyA9IHZvaWQgMCwgdGhpcy5oYXNHYXBzID0gITEsIHRoaXMuaGxzID0gZSwgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzOiBlXG4gICAgfSA9IHRoaXM7XG4gICAgZSAmJiAoZS5vbihJLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpLCBlLm9uKEkuQlVGRkVSX0FQUEVOREVELCB0aGlzLm9uQnVmZmVyQXBwZW5kZWQsIHRoaXMpLCBlLm9uKEkuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyksIGUub24oSS5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpKTtcbiAgfVxuICBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHM6IGVcbiAgICB9ID0gdGhpcztcbiAgICBlICYmIChlLm9mZihJLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpLCBlLm9mZihJLkJVRkZFUl9BUFBFTkRFRCwgdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLCB0aGlzKSwgZS5vZmYoSS5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKSwgZS5vZmYoSS5GUkFHX0xPQURFRCwgdGhpcy5vbkZyYWdMb2FkZWQsIHRoaXMpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSwgdGhpcy5obHMgPSAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5mcmFnbWVudHMgPSAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHMgPSAvLyBAdHMtaWdub3JlXG4gICAgdGhpcy5lbmRMaXN0RnJhZ21lbnRzID0gdGhpcy50aW1lUmFuZ2VzID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgRnJhZ21lbnQgb3IgUGFydCB3aXRoIGFuIGFwcGVuZGVkIHJhbmdlIHRoYXQgbWF0Y2hlcyB0aGUgcG9zaXRpb24gYW5kIGxldmVsVHlwZVxuICAgKiBPdGhlcndpc2UsIHJldHVybiBudWxsXG4gICAqL1xuICBnZXRBcHBlbmRlZEZyYWcoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLmFjdGl2ZVBhcnRMaXN0c1t0XTtcbiAgICBpZiAocilcbiAgICAgIGZvciAobGV0IG4gPSByLmxlbmd0aDsgbi0tOyApIHtcbiAgICAgICAgY29uc3QgaSA9IHJbbl07XG4gICAgICAgIGlmICghaSlcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKGkuc3RhcnQgPD0gZSAmJiBlIDw9IGkuZW5kICYmIGkubG9hZGVkKVxuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhlLCB0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGEgYnVmZmVyZWQgRnJhZ21lbnQgdGhhdCBtYXRjaGVzIHRoZSBwb3NpdGlvbiBhbmQgbGV2ZWxUeXBlLlxuICAgKiBBIGJ1ZmZlcmVkIEZyYWdtZW50IGlzIG9uZSB3aG9zZSBsb2FkaW5nLCBwYXJzaW5nIGFuZCBhcHBlbmRpbmcgaXMgZG9uZSAoY29tcGxldGVkIG9yIFwicGFydGlhbFwiIG1lYW5pbmcgYWJvcnRlZCkuXG4gICAqIElmIG5vdCBmb3VuZCBhbnkgRnJhZ21lbnQsIHJldHVybiBudWxsXG4gICAqL1xuICBnZXRCdWZmZXJlZEZyYWcoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLmdldEZyYWdBdFBvcyhlLCB0LCAhMCk7XG4gIH1cbiAgZ2V0RnJhZ0F0UG9zKGUsIHQsIHIpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnbWVudHM6IG5cbiAgICB9ID0gdGhpcywgaSA9IE9iamVjdC5rZXlzKG4pO1xuICAgIGZvciAobGV0IG8gPSBpLmxlbmd0aDsgby0tOyApIHtcbiAgICAgIGNvbnN0IGEgPSBuW2lbb11dO1xuICAgICAgaWYgKChhID09IG51bGwgPyB2b2lkIDAgOiBhLmJvZHkudHlwZSkgPT09IHQgJiYgKCFyIHx8IGEuYnVmZmVyZWQpKSB7XG4gICAgICAgIGNvbnN0IGwgPSBhLmJvZHk7XG4gICAgICAgIGlmIChsLnN0YXJ0IDw9IGUgJiYgZSA8PSBsLmVuZClcbiAgICAgICAgICByZXR1cm4gbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnRpYWwgZnJhZ21lbnRzIGVmZmVjdGVkIGJ5IGNvZGVkIGZyYW1lIGV2aWN0aW9uIHdpbGwgYmUgcmVtb3ZlZFxuICAgKiBUaGUgYnJvd3NlciB3aWxsIHVubG9hZCBwYXJ0cyBvZiB0aGUgYnVmZmVyIHRvIGZyZWUgdXAgbWVtb3J5IGZvciBuZXcgYnVmZmVyIGRhdGFcbiAgICogRnJhZ21lbnRzIHdpbGwgbmVlZCB0byBiZSByZWxvYWRlZCB3aGVuIHRoZSBidWZmZXIgaXMgZnJlZWQgdXAsIHJlbW92aW5nIHBhcnRpYWwgZnJhZ21lbnRzIHdpbGwgYWxsb3cgdGhlbSB0byByZWxvYWQoc2luY2UgdGhlcmUgbWlnaHQgYmUgcGFydHMgdGhhdCBhcmUgc3RpbGwgcGxheWFibGUpXG4gICAqL1xuICBkZXRlY3RFdmljdGVkRnJhZ21lbnRzKGUsIHQsIHIsIG4sIGkpIHtcbiAgICB0aGlzLnRpbWVSYW5nZXMgJiYgKHRoaXMudGltZVJhbmdlc1tlXSA9IHQpO1xuICAgIGNvbnN0IG8gPSAobiA9PSBudWxsID8gdm9pZCAwIDogbi5mcmFnbWVudC5zbikgfHwgLTE7XG4gICAgT2JqZWN0LmtleXModGhpcy5mcmFnbWVudHMpLmZvckVhY2goKGEpID0+IHtcbiAgICAgIGNvbnN0IGwgPSB0aGlzLmZyYWdtZW50c1thXTtcbiAgICAgIGlmICghbCB8fCBvID49IGwuYm9keS5zbilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKCFsLmJ1ZmZlcmVkICYmICghbC5sb2FkZWQgfHwgaSkpIHtcbiAgICAgICAgbC5ib2R5LnR5cGUgPT09IHIgJiYgdGhpcy5yZW1vdmVGcmFnbWVudChsLmJvZHkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjID0gbC5yYW5nZVtlXTtcbiAgICAgIGlmIChjKSB7XG4gICAgICAgIGlmIChjLnRpbWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVGcmFnbWVudChsLmJvZHkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjLnRpbWUuc29tZSgodSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGQgPSAhdGhpcy5pc1RpbWVCdWZmZXJlZCh1LnN0YXJ0UFRTLCB1LmVuZFBUUywgdCk7XG4gICAgICAgICAgcmV0dXJuIGQgJiYgdGhpcy5yZW1vdmVGcmFnbWVudChsLmJvZHkpLCBkO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBmcmFnbWVudCBwYXNzZWQgaW4gaXMgbG9hZGVkIGluIHRoZSBidWZmZXIgcHJvcGVybHlcbiAgICogUGFydGlhbGx5IGxvYWRlZCBmcmFnbWVudHMgd2lsbCBiZSByZWdpc3RlcmVkIGFzIGEgcGFydGlhbCBmcmFnbWVudFxuICAgKi9cbiAgZGV0ZWN0UGFydGlhbEZyYWdtZW50cyhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMudGltZVJhbmdlcztcbiAgICBpZiAoIXQgfHwgZS5mcmFnLnNuID09PSBcImluaXRTZWdtZW50XCIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IGUuZnJhZywgbiA9IGZuKHIpLCBpID0gdGhpcy5mcmFnbWVudHNbbl07XG4gICAgaWYgKCFpIHx8IGkuYnVmZmVyZWQgJiYgci5nYXApXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbyA9ICFyLnJlbHVybDtcbiAgICBPYmplY3Qua2V5cyh0KS5mb3JFYWNoKChhKSA9PiB7XG4gICAgICBjb25zdCBsID0gci5lbGVtZW50YXJ5U3RyZWFtc1thXTtcbiAgICAgIGlmICghbClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgYyA9IHRbYV0sIHUgPSBvIHx8IGwucGFydGlhbCA9PT0gITA7XG4gICAgICBpLnJhbmdlW2FdID0gdGhpcy5nZXRCdWZmZXJlZFRpbWVzKHIsIGUucGFydCwgdSwgYyk7XG4gICAgfSksIGkubG9hZGVkID0gbnVsbCwgT2JqZWN0LmtleXMoaS5yYW5nZSkubGVuZ3RoID8gKGkuYnVmZmVyZWQgPSAhMCwgKGkuYm9keS5lbmRMaXN0ID0gci5lbmRMaXN0IHx8IGkuYm9keS5lbmRMaXN0KSAmJiAodGhpcy5lbmRMaXN0RnJhZ21lbnRzW2kuYm9keS50eXBlXSA9IGkpLCBIaShpKSB8fCB0aGlzLnJlbW92ZVBhcnRzKHIuc24gLSAxLCByLnR5cGUpKSA6IHRoaXMucmVtb3ZlRnJhZ21lbnQoaS5ib2R5KTtcbiAgfVxuICByZW1vdmVQYXJ0cyhlLCB0KSB7XG4gICAgY29uc3QgciA9IHRoaXMuYWN0aXZlUGFydExpc3RzW3RdO1xuICAgIHIgJiYgKHRoaXMuYWN0aXZlUGFydExpc3RzW3RdID0gZ2gociwgKG4pID0+IG4uZnJhZ21lbnQuc24gPj0gZSkpO1xuICB9XG4gIGZyYWdCdWZmZXJlZChlLCB0KSB7XG4gICAgY29uc3QgciA9IGZuKGUpO1xuICAgIGxldCBuID0gdGhpcy5mcmFnbWVudHNbcl07XG4gICAgIW4gJiYgdCAmJiAobiA9IHRoaXMuZnJhZ21lbnRzW3JdID0ge1xuICAgICAgYm9keTogZSxcbiAgICAgIGFwcGVuZGVkUFRTOiBudWxsLFxuICAgICAgbG9hZGVkOiBudWxsLFxuICAgICAgYnVmZmVyZWQ6ICExLFxuICAgICAgcmFuZ2U6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfSwgZS5nYXAgJiYgKHRoaXMuaGFzR2FwcyA9ICEwKSksIG4gJiYgKG4ubG9hZGVkID0gbnVsbCwgbi5idWZmZXJlZCA9ICEwKTtcbiAgfVxuICBnZXRCdWZmZXJlZFRpbWVzKGUsIHQsIHIsIG4pIHtcbiAgICBjb25zdCBpID0ge1xuICAgICAgdGltZTogW10sXG4gICAgICBwYXJ0aWFsOiByXG4gICAgfSwgbyA9IGUuc3RhcnQsIGEgPSBlLmVuZCwgbCA9IGUubWluRW5kUFRTIHx8IGEsIGMgPSBlLm1heFN0YXJ0UFRTIHx8IG87XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCBuLmxlbmd0aDsgdSsrKSB7XG4gICAgICBjb25zdCBkID0gbi5zdGFydCh1KSAtIHRoaXMuYnVmZmVyUGFkZGluZywgaCA9IG4uZW5kKHUpICsgdGhpcy5idWZmZXJQYWRkaW5nO1xuICAgICAgaWYgKGMgPj0gZCAmJiBsIDw9IGgpIHtcbiAgICAgICAgaS50aW1lLnB1c2goe1xuICAgICAgICAgIHN0YXJ0UFRTOiBNYXRoLm1heChvLCBuLnN0YXJ0KHUpKSxcbiAgICAgICAgICBlbmRQVFM6IE1hdGgubWluKGEsIG4uZW5kKHUpKVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKG8gPCBoICYmIGEgPiBkKSB7XG4gICAgICAgIGNvbnN0IGYgPSBNYXRoLm1heChvLCBuLnN0YXJ0KHUpKSwgcCA9IE1hdGgubWluKGEsIG4uZW5kKHUpKTtcbiAgICAgICAgcCA+IGYgJiYgKGkucGFydGlhbCA9ICEwLCBpLnRpbWUucHVzaCh7XG4gICAgICAgICAgc3RhcnRQVFM6IGYsXG4gICAgICAgICAgZW5kUFRTOiBwXG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAoYSA8PSBkKVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHBhcnRpYWwgZnJhZ21lbnQgZm9yIGEgY2VydGFpbiB0aW1lXG4gICAqL1xuICBnZXRQYXJ0aWFsRnJhZ21lbnQoZSkge1xuICAgIGxldCB0ID0gbnVsbCwgciwgbiwgaSwgbyA9IDA7XG4gICAgY29uc3Qge1xuICAgICAgYnVmZmVyUGFkZGluZzogYSxcbiAgICAgIGZyYWdtZW50czogbFxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhsKS5mb3JFYWNoKChjKSA9PiB7XG4gICAgICBjb25zdCB1ID0gbFtjXTtcbiAgICAgIHUgJiYgSGkodSkgJiYgKG4gPSB1LmJvZHkuc3RhcnQgLSBhLCBpID0gdS5ib2R5LmVuZCArIGEsIGUgPj0gbiAmJiBlIDw9IGkgJiYgKHIgPSBNYXRoLm1pbihlIC0gbiwgaSAtIGUpLCBvIDw9IHIgJiYgKHQgPSB1LmJvZHksIG8gPSByKSkpO1xuICAgIH0pLCB0O1xuICB9XG4gIGlzRW5kTGlzdEFwcGVuZGVkKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5lbmRMaXN0RnJhZ21lbnRzW2VdO1xuICAgIHJldHVybiB0ICE9PSB2b2lkIDAgJiYgKHQuYnVmZmVyZWQgfHwgSGkodCkpO1xuICB9XG4gIGdldFN0YXRlKGUpIHtcbiAgICBjb25zdCB0ID0gZm4oZSksIHIgPSB0aGlzLmZyYWdtZW50c1t0XTtcbiAgICByZXR1cm4gciA/IHIuYnVmZmVyZWQgPyBIaShyKSA/IEh0LlBBUlRJQUwgOiBIdC5PSyA6IEh0LkFQUEVORElORyA6IEh0Lk5PVF9MT0FERUQ7XG4gIH1cbiAgaXNUaW1lQnVmZmVyZWQoZSwgdCwgcikge1xuICAgIGxldCBuLCBpO1xuICAgIGZvciAobGV0IG8gPSAwOyBvIDwgci5sZW5ndGg7IG8rKykge1xuICAgICAgaWYgKG4gPSByLnN0YXJ0KG8pIC0gdGhpcy5idWZmZXJQYWRkaW5nLCBpID0gci5lbmQobykgKyB0aGlzLmJ1ZmZlclBhZGRpbmcsIGUgPj0gbiAmJiB0IDw9IGkpXG4gICAgICAgIHJldHVybiAhMDtcbiAgICAgIGlmICh0IDw9IG4pXG4gICAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMucmVtb3ZlQWxsRnJhZ21lbnRzKCk7XG4gIH1cbiAgb25GcmFnTG9hZGVkKGUsIHQpIHtcbiAgICBpZiAodC5mcmFnLnNuID09PSBcImluaXRTZWdtZW50XCIgfHwgdC5mcmFnLmJpdHJhdGVUZXN0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSB0LmZyYWcsIG4gPSB0LnBhcnQgPyBudWxsIDogdCwgaSA9IGZuKHIpO1xuICAgIHRoaXMuZnJhZ21lbnRzW2ldID0ge1xuICAgICAgYm9keTogcixcbiAgICAgIGFwcGVuZGVkUFRTOiBudWxsLFxuICAgICAgbG9hZGVkOiBuLFxuICAgICAgYnVmZmVyZWQ6ICExLFxuICAgICAgcmFuZ2U6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpXG4gICAgfTtcbiAgfVxuICBvbkJ1ZmZlckFwcGVuZGVkKGUsIHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnOiByLFxuICAgICAgcGFydDogbixcbiAgICAgIHRpbWVSYW5nZXM6IGksXG4gICAgICB0eXBlOiBvXG4gICAgfSA9IHQ7XG4gICAgaWYgKHIuc24gPT09IFwiaW5pdFNlZ21lbnRcIilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhID0gci50eXBlO1xuICAgIGlmIChuKSB7XG4gICAgICBsZXQgYyA9IHRoaXMuYWN0aXZlUGFydExpc3RzW2FdO1xuICAgICAgYyB8fCAodGhpcy5hY3RpdmVQYXJ0TGlzdHNbYV0gPSBjID0gW10pLCBjLnB1c2gobik7XG4gICAgfVxuICAgIHRoaXMudGltZVJhbmdlcyA9IGk7XG4gICAgY29uc3QgbCA9IGlbb107XG4gICAgdGhpcy5kZXRlY3RFdmljdGVkRnJhZ21lbnRzKG8sIGwsIGEsIG4pO1xuICB9XG4gIG9uRnJhZ0J1ZmZlcmVkKGUsIHQpIHtcbiAgICB0aGlzLmRldGVjdFBhcnRpYWxGcmFnbWVudHModCk7XG4gIH1cbiAgaGFzRnJhZ21lbnQoZSkge1xuICAgIGNvbnN0IHQgPSBmbihlKTtcbiAgICByZXR1cm4gISF0aGlzLmZyYWdtZW50c1t0XTtcbiAgfVxuICBoYXNGcmFnbWVudHMoZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWdtZW50czogdFxuICAgIH0gPSB0aGlzLCByID0gT2JqZWN0LmtleXModCk7XG4gICAgaWYgKCFlKVxuICAgICAgcmV0dXJuIHIubGVuZ3RoID4gMDtcbiAgICBmb3IgKGxldCBuID0gci5sZW5ndGg7IG4tLTsgKSB7XG4gICAgICBjb25zdCBpID0gdFtyW25dXTtcbiAgICAgIGlmICgoaSA9PSBudWxsID8gdm9pZCAwIDogaS5ib2R5LnR5cGUpID09PSBlKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBoYXNQYXJ0cyhlKSB7XG4gICAgdmFyIHQ7XG4gICAgcmV0dXJuICEhKCh0ID0gdGhpcy5hY3RpdmVQYXJ0TGlzdHNbZV0pICE9IG51bGwgJiYgdC5sZW5ndGgpO1xuICB9XG4gIHJlbW92ZUZyYWdtZW50c0luUmFuZ2UoZSwgdCwgciwgbiwgaSkge1xuICAgIG4gJiYgIXRoaXMuaGFzR2FwcyB8fCBPYmplY3Qua2V5cyh0aGlzLmZyYWdtZW50cykuZm9yRWFjaCgobykgPT4ge1xuICAgICAgY29uc3QgYSA9IHRoaXMuZnJhZ21lbnRzW29dO1xuICAgICAgaWYgKCFhKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBsID0gYS5ib2R5O1xuICAgICAgbC50eXBlICE9PSByIHx8IG4gJiYgIWwuZ2FwIHx8IGwuc3RhcnQgPCB0ICYmIGwuZW5kID4gZSAmJiAoYS5idWZmZXJlZCB8fCBpKSAmJiB0aGlzLnJlbW92ZUZyYWdtZW50KGwpO1xuICAgIH0pO1xuICB9XG4gIHJlbW92ZUZyYWdtZW50KGUpIHtcbiAgICBjb25zdCB0ID0gZm4oZSk7XG4gICAgZS5jbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvKCk7XG4gICAgY29uc3QgciA9IHRoaXMuYWN0aXZlUGFydExpc3RzW2UudHlwZV07XG4gICAgaWYgKHIpIHtcbiAgICAgIGNvbnN0IG4gPSBlLnNuO1xuICAgICAgdGhpcy5hY3RpdmVQYXJ0TGlzdHNbZS50eXBlXSA9IGdoKHIsIChpKSA9PiBpLmZyYWdtZW50LnNuICE9PSBuKTtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuZnJhZ21lbnRzW3RdLCBlLmVuZExpc3QgJiYgZGVsZXRlIHRoaXMuZW5kTGlzdEZyYWdtZW50c1tlLnR5cGVdO1xuICB9XG4gIHJlbW92ZUFsbEZyYWdtZW50cygpIHtcbiAgICB2YXIgZTtcbiAgICB0aGlzLmZyYWdtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLCB0aGlzLmVuZExpc3RGcmFnbWVudHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdGhpcy5hY3RpdmVQYXJ0TGlzdHMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdGhpcy5oYXNHYXBzID0gITE7XG4gICAgY29uc3QgdCA9IChlID0gdGhpcy5obHMpID09IG51bGwgfHwgKGUgPSBlLmxhdGVzdExldmVsRGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IGUucGFydExpc3Q7XG4gICAgdCAmJiB0LmZvckVhY2goKHIpID0+IHIuY2xlYXJFbGVtZW50YXJ5U3RyZWFtSW5mbygpKTtcbiAgfVxufVxuZnVuY3Rpb24gSGkocykge1xuICB2YXIgZSwgdCwgcjtcbiAgcmV0dXJuIHMuYnVmZmVyZWQgJiYgISEocy5ib2R5LmdhcCB8fCAoZSA9IHMucmFuZ2UudmlkZW8pICE9IG51bGwgJiYgZS5wYXJ0aWFsIHx8ICh0ID0gcy5yYW5nZS5hdWRpbykgIT0gbnVsbCAmJiB0LnBhcnRpYWwgfHwgKHIgPSBzLnJhbmdlLmF1ZGlvdmlkZW8pICE9IG51bGwgJiYgci5wYXJ0aWFsKTtcbn1cbmZ1bmN0aW9uIGZuKHMpIHtcbiAgcmV0dXJuIGAke3MudHlwZX1fJHtzLmxldmVsfV8ke3Muc259YDtcbn1cbmZ1bmN0aW9uIGdoKHMsIGUpIHtcbiAgcmV0dXJuIHMuZmlsdGVyKCh0KSA9PiB7XG4gICAgY29uc3QgciA9IGUodCk7XG4gICAgcmV0dXJuIHIgfHwgdC5jbGVhckVsZW1lbnRhcnlTdHJlYW1JbmZvKCksIHI7XG4gIH0pO1xufVxudmFyIE9zID0ge1xuICBjYmM6IDAsXG4gIGN0cjogMVxufTtcbmNsYXNzIHdiIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcikge1xuICAgIHRoaXMuc3VidGxlID0gdm9pZCAwLCB0aGlzLmFlc0lWID0gdm9pZCAwLCB0aGlzLmFlc01vZGUgPSB2b2lkIDAsIHRoaXMuc3VidGxlID0gZSwgdGhpcy5hZXNJViA9IHQsIHRoaXMuYWVzTW9kZSA9IHI7XG4gIH1cbiAgZGVjcnlwdChlLCB0KSB7XG4gICAgc3dpdGNoICh0aGlzLmFlc01vZGUpIHtcbiAgICAgIGNhc2UgT3MuY2JjOlxuICAgICAgICByZXR1cm4gdGhpcy5zdWJ0bGUuZGVjcnlwdCh7XG4gICAgICAgICAgbmFtZTogXCJBRVMtQ0JDXCIsXG4gICAgICAgICAgaXY6IHRoaXMuYWVzSVZcbiAgICAgICAgfSwgdCwgZSk7XG4gICAgICBjYXNlIE9zLmN0cjpcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VidGxlLmRlY3J5cHQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJBRVMtQ1RSXCIsXG4gICAgICAgICAgICBjb3VudGVyOiB0aGlzLmFlc0lWLFxuICAgICAgICAgICAgbGVuZ3RoOiA2NFxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy82NCA6IE5JU1QgU1A4MDAtMzhBIHN0YW5kYXJkIHN1Z2dlc3RzIHRoYXQgdGhlIGNvdW50ZXIgc2hvdWxkIG9jY3VweSBoYWxmIG9mIHRoZSBjb3VudGVyIGJsb2NrXG4gICAgICAgICAgdCxcbiAgICAgICAgICBlXG4gICAgICAgICk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFtBRVNDcnlwdG9dIGludmFsaWQgYWVzIG1vZGUgJHt0aGlzLmFlc01vZGV9YCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBBYihzKSB7XG4gIGNvbnN0IGUgPSBzLmJ5dGVMZW5ndGgsIHQgPSBlICYmIG5ldyBEYXRhVmlldyhzLmJ1ZmZlcikuZ2V0VWludDgoZSAtIDEpO1xuICByZXR1cm4gdCA/IHMuc2xpY2UoMCwgZSAtIHQpIDogcztcbn1cbmNsYXNzIEliIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5yY29uID0gWzAsIDEsIDIsIDQsIDgsIDE2LCAzMiwgNjQsIDEyOCwgMjcsIDU0XSwgdGhpcy5zdWJNaXggPSBbbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NildLCB0aGlzLmludlN1Yk1peCA9IFtuZXcgVWludDMyQXJyYXkoMjU2KSwgbmV3IFVpbnQzMkFycmF5KDI1NiksIG5ldyBVaW50MzJBcnJheSgyNTYpLCBuZXcgVWludDMyQXJyYXkoMjU2KV0sIHRoaXMuc0JveCA9IG5ldyBVaW50MzJBcnJheSgyNTYpLCB0aGlzLmludlNCb3ggPSBuZXcgVWludDMyQXJyYXkoMjU2KSwgdGhpcy5rZXkgPSBuZXcgVWludDMyQXJyYXkoMCksIHRoaXMua3NSb3dzID0gMCwgdGhpcy5rZXlTaXplID0gMCwgdGhpcy5rZXlTY2hlZHVsZSA9IHZvaWQgMCwgdGhpcy5pbnZLZXlTY2hlZHVsZSA9IHZvaWQgMCwgdGhpcy5pbml0VGFibGUoKTtcbiAgfVxuICAvLyBVc2luZyB2aWV3LmdldFVpbnQzMigpIGFsc28gc3dhcHMgdGhlIGJ5dGUgb3JkZXIuXG4gIHVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhlKSB7XG4gICAgY29uc3QgdCA9IG5ldyBEYXRhVmlldyhlKSwgciA9IG5ldyBVaW50MzJBcnJheSg0KTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IDQ7IG4rKylcbiAgICAgIHJbbl0gPSB0LmdldFVpbnQzMihuICogNCk7XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgaW5pdFRhYmxlKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnNCb3gsIHQgPSB0aGlzLmludlNCb3gsIHIgPSB0aGlzLnN1Yk1peCwgbiA9IHJbMF0sIGkgPSByWzFdLCBvID0gclsyXSwgYSA9IHJbM10sIGwgPSB0aGlzLmludlN1Yk1peCwgYyA9IGxbMF0sIHUgPSBsWzFdLCBkID0gbFsyXSwgaCA9IGxbM10sIGYgPSBuZXcgVWludDMyQXJyYXkoMjU2KTtcbiAgICBsZXQgcCA9IDAsIHkgPSAwLCBFID0gMDtcbiAgICBmb3IgKEUgPSAwOyBFIDwgMjU2OyBFKyspXG4gICAgICBFIDwgMTI4ID8gZltFXSA9IEUgPDwgMSA6IGZbRV0gPSBFIDw8IDEgXiAyODM7XG4gICAgZm9yIChFID0gMDsgRSA8IDI1NjsgRSsrKSB7XG4gICAgICBsZXQgYiA9IHkgXiB5IDw8IDEgXiB5IDw8IDIgXiB5IDw8IDMgXiB5IDw8IDQ7XG4gICAgICBiID0gYiA+Pj4gOCBeIGIgJiAyNTUgXiA5OSwgZVtwXSA9IGIsIHRbYl0gPSBwO1xuICAgICAgY29uc3QgUiA9IGZbcF0sIEEgPSBmW1JdLCBGID0gZltBXTtcbiAgICAgIGxldCBNID0gZltiXSAqIDI1NyBeIGIgKiAxNjg0MzAwODtcbiAgICAgIG5bcF0gPSBNIDw8IDI0IHwgTSA+Pj4gOCwgaVtwXSA9IE0gPDwgMTYgfCBNID4+PiAxNiwgb1twXSA9IE0gPDwgOCB8IE0gPj4+IDI0LCBhW3BdID0gTSwgTSA9IEYgKiAxNjg0MzAwOSBeIEEgKiA2NTUzNyBeIFIgKiAyNTcgXiBwICogMTY4NDMwMDgsIGNbYl0gPSBNIDw8IDI0IHwgTSA+Pj4gOCwgdVtiXSA9IE0gPDwgMTYgfCBNID4+PiAxNiwgZFtiXSA9IE0gPDwgOCB8IE0gPj4+IDI0LCBoW2JdID0gTSwgcCA/IChwID0gUiBeIGZbZltmW0YgXiBSXV1dLCB5IF49IGZbZlt5XV0pIDogcCA9IHkgPSAxO1xuICAgIH1cbiAgfVxuICBleHBhbmRLZXkoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnVpbnQ4QXJyYXlUb1VpbnQzMkFycmF5XyhlKTtcbiAgICBsZXQgciA9ICEwLCBuID0gMDtcbiAgICBmb3IgKDsgbiA8IHQubGVuZ3RoICYmIHI7IClcbiAgICAgIHIgPSB0W25dID09PSB0aGlzLmtleVtuXSwgbisrO1xuICAgIGlmIChyKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMua2V5ID0gdDtcbiAgICBjb25zdCBpID0gdGhpcy5rZXlTaXplID0gdC5sZW5ndGg7XG4gICAgaWYgKGkgIT09IDQgJiYgaSAhPT0gNiAmJiBpICE9PSA4KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhZXMga2V5IHNpemU9XCIgKyBpKTtcbiAgICBjb25zdCBvID0gdGhpcy5rc1Jvd3MgPSAoaSArIDYgKyAxKSAqIDQ7XG4gICAgbGV0IGEsIGw7XG4gICAgY29uc3QgYyA9IHRoaXMua2V5U2NoZWR1bGUgPSBuZXcgVWludDMyQXJyYXkobyksIHUgPSB0aGlzLmludktleVNjaGVkdWxlID0gbmV3IFVpbnQzMkFycmF5KG8pLCBkID0gdGhpcy5zQm94LCBoID0gdGhpcy5yY29uLCBmID0gdGhpcy5pbnZTdWJNaXgsIHAgPSBmWzBdLCB5ID0gZlsxXSwgRSA9IGZbMl0sIGIgPSBmWzNdO1xuICAgIGxldCBSLCBBO1xuICAgIGZvciAoYSA9IDA7IGEgPCBvOyBhKyspIHtcbiAgICAgIGlmIChhIDwgaSkge1xuICAgICAgICBSID0gY1thXSA9IHRbYV07XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgQSA9IFIsIGEgJSBpID09PSAwID8gKEEgPSBBIDw8IDggfCBBID4+PiAyNCwgQSA9IGRbQSA+Pj4gMjRdIDw8IDI0IHwgZFtBID4+PiAxNiAmIDI1NV0gPDwgMTYgfCBkW0EgPj4+IDggJiAyNTVdIDw8IDggfCBkW0EgJiAyNTVdLCBBIF49IGhbYSAvIGkgfCAwXSA8PCAyNCkgOiBpID4gNiAmJiBhICUgaSA9PT0gNCAmJiAoQSA9IGRbQSA+Pj4gMjRdIDw8IDI0IHwgZFtBID4+PiAxNiAmIDI1NV0gPDwgMTYgfCBkW0EgPj4+IDggJiAyNTVdIDw8IDggfCBkW0EgJiAyNTVdKSwgY1thXSA9IFIgPSAoY1thIC0gaV0gXiBBKSA+Pj4gMDtcbiAgICB9XG4gICAgZm9yIChsID0gMDsgbCA8IG87IGwrKylcbiAgICAgIGEgPSBvIC0gbCwgbCAmIDMgPyBBID0gY1thXSA6IEEgPSBjW2EgLSA0XSwgbCA8IDQgfHwgYSA8PSA0ID8gdVtsXSA9IEEgOiB1W2xdID0gcFtkW0EgPj4+IDI0XV0gXiB5W2RbQSA+Pj4gMTYgJiAyNTVdXSBeIEVbZFtBID4+PiA4ICYgMjU1XV0gXiBiW2RbQSAmIDI1NV1dLCB1W2xdID0gdVtsXSA+Pj4gMDtcbiAgfVxuICAvLyBBZGRpbmcgdGhpcyBhcyBhIG1ldGhvZCBncmVhdGx5IGltcHJvdmVzIHBlcmZvcm1hbmNlLlxuICBuZXR3b3JrVG9Ib3N0T3JkZXJTd2FwKGUpIHtcbiAgICByZXR1cm4gZSA8PCAyNCB8IChlICYgNjUyODApIDw8IDggfCAoZSAmIDE2NzExNjgwKSA+PiA4IHwgZSA+Pj4gMjQ7XG4gIH1cbiAgZGVjcnlwdChlLCB0LCByKSB7XG4gICAgY29uc3QgbiA9IHRoaXMua2V5U2l6ZSArIDYsIGkgPSB0aGlzLmludktleVNjaGVkdWxlLCBvID0gdGhpcy5pbnZTQm94LCBhID0gdGhpcy5pbnZTdWJNaXgsIGwgPSBhWzBdLCBjID0gYVsxXSwgdSA9IGFbMl0sIGQgPSBhWzNdLCBoID0gdGhpcy51aW50OEFycmF5VG9VaW50MzJBcnJheV8ocik7XG4gICAgbGV0IGYgPSBoWzBdLCBwID0gaFsxXSwgeSA9IGhbMl0sIEUgPSBoWzNdO1xuICAgIGNvbnN0IGIgPSBuZXcgSW50MzJBcnJheShlKSwgUiA9IG5ldyBJbnQzMkFycmF5KGIubGVuZ3RoKTtcbiAgICBsZXQgQSwgRiwgTSwgSCwgSywgaiwgQywgaywgJCwgVywgXywgZywgeCwgdztcbiAgICBjb25zdCBEID0gdGhpcy5uZXR3b3JrVG9Ib3N0T3JkZXJTd2FwO1xuICAgIGZvciAoOyB0IDwgYi5sZW5ndGg7ICkge1xuICAgICAgZm9yICgkID0gRChiW3RdKSwgVyA9IEQoYlt0ICsgMV0pLCBfID0gRChiW3QgKyAyXSksIGcgPSBEKGJbdCArIDNdKSwgSyA9ICQgXiBpWzBdLCBqID0gZyBeIGlbMV0sIEMgPSBfIF4gaVsyXSwgayA9IFcgXiBpWzNdLCB4ID0gNCwgdyA9IDE7IHcgPCBuOyB3KyspXG4gICAgICAgIEEgPSBsW0sgPj4+IDI0XSBeIGNbaiA+PiAxNiAmIDI1NV0gXiB1W0MgPj4gOCAmIDI1NV0gXiBkW2sgJiAyNTVdIF4gaVt4XSwgRiA9IGxbaiA+Pj4gMjRdIF4gY1tDID4+IDE2ICYgMjU1XSBeIHVbayA+PiA4ICYgMjU1XSBeIGRbSyAmIDI1NV0gXiBpW3ggKyAxXSwgTSA9IGxbQyA+Pj4gMjRdIF4gY1trID4+IDE2ICYgMjU1XSBeIHVbSyA+PiA4ICYgMjU1XSBeIGRbaiAmIDI1NV0gXiBpW3ggKyAyXSwgSCA9IGxbayA+Pj4gMjRdIF4gY1tLID4+IDE2ICYgMjU1XSBeIHVbaiA+PiA4ICYgMjU1XSBeIGRbQyAmIDI1NV0gXiBpW3ggKyAzXSwgSyA9IEEsIGogPSBGLCBDID0gTSwgayA9IEgsIHggPSB4ICsgNDtcbiAgICAgIEEgPSBvW0sgPj4+IDI0XSA8PCAyNCBeIG9baiA+PiAxNiAmIDI1NV0gPDwgMTYgXiBvW0MgPj4gOCAmIDI1NV0gPDwgOCBeIG9bayAmIDI1NV0gXiBpW3hdLCBGID0gb1tqID4+PiAyNF0gPDwgMjQgXiBvW0MgPj4gMTYgJiAyNTVdIDw8IDE2IF4gb1trID4+IDggJiAyNTVdIDw8IDggXiBvW0sgJiAyNTVdIF4gaVt4ICsgMV0sIE0gPSBvW0MgPj4+IDI0XSA8PCAyNCBeIG9bayA+PiAxNiAmIDI1NV0gPDwgMTYgXiBvW0sgPj4gOCAmIDI1NV0gPDwgOCBeIG9baiAmIDI1NV0gXiBpW3ggKyAyXSwgSCA9IG9bayA+Pj4gMjRdIDw8IDI0IF4gb1tLID4+IDE2ICYgMjU1XSA8PCAxNiBeIG9baiA+PiA4ICYgMjU1XSA8PCA4IF4gb1tDICYgMjU1XSBeIGlbeCArIDNdLCBSW3RdID0gRChBIF4gZiksIFJbdCArIDFdID0gRChIIF4gcCksIFJbdCArIDJdID0gRChNIF4geSksIFJbdCArIDNdID0gRChGIF4gRSksIGYgPSAkLCBwID0gVywgeSA9IF8sIEUgPSBnLCB0ID0gdCArIDQ7XG4gICAgfVxuICAgIHJldHVybiBSLmJ1ZmZlcjtcbiAgfVxufVxuY2xhc3MgX2Ige1xuICBjb25zdHJ1Y3RvcihlLCB0LCByKSB7XG4gICAgdGhpcy5zdWJ0bGUgPSB2b2lkIDAsIHRoaXMua2V5ID0gdm9pZCAwLCB0aGlzLmFlc01vZGUgPSB2b2lkIDAsIHRoaXMuc3VidGxlID0gZSwgdGhpcy5rZXkgPSB0LCB0aGlzLmFlc01vZGUgPSByO1xuICB9XG4gIGV4cGFuZEtleSgpIHtcbiAgICBjb25zdCBlID0gUmIodGhpcy5hZXNNb2RlKTtcbiAgICByZXR1cm4gdGhpcy5zdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIHRoaXMua2V5LCB7XG4gICAgICBuYW1lOiBlXG4gICAgfSwgITEsIFtcImVuY3J5cHRcIiwgXCJkZWNyeXB0XCJdKTtcbiAgfVxufVxuZnVuY3Rpb24gUmIocykge1xuICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlIE9zLmNiYzpcbiAgICAgIHJldHVybiBcIkFFUy1DQkNcIjtcbiAgICBjYXNlIE9zLmN0cjpcbiAgICAgIHJldHVybiBcIkFFUy1DVFJcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBbRmFzdEFFU0tleV0gaW52YWxpZCBhZXMgbW9kZSAke3N9YCk7XG4gIH1cbn1cbmNvbnN0IExiID0gMTY7XG5jbGFzcyB2dSB7XG4gIGNvbnN0cnVjdG9yKGUsIHtcbiAgICByZW1vdmVQS0NTN1BhZGRpbmc6IHQgPSAhMFxuICB9ID0ge30pIHtcbiAgICBpZiAodGhpcy5sb2dFbmFibGVkID0gITAsIHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nID0gdm9pZCAwLCB0aGlzLnN1YnRsZSA9IG51bGwsIHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBudWxsLCB0aGlzLmtleSA9IG51bGwsIHRoaXMuZmFzdEFlc0tleSA9IG51bGwsIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGwsIHRoaXMuY3VycmVudElWID0gbnVsbCwgdGhpcy5jdXJyZW50UmVzdWx0ID0gbnVsbCwgdGhpcy51c2VTb2Z0d2FyZSA9IHZvaWQgMCwgdGhpcy5lbmFibGVTb2Z0d2FyZUFFUyA9IHZvaWQgMCwgdGhpcy5lbmFibGVTb2Z0d2FyZUFFUyA9IGUuZW5hYmxlU29mdHdhcmVBRVMsIHRoaXMucmVtb3ZlUEtDUzdQYWRkaW5nID0gdCwgdClcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHIgPSBzZWxmLmNyeXB0bztcbiAgICAgICAgciAmJiAodGhpcy5zdWJ0bGUgPSByLnN1YnRsZSB8fCByLndlYmtpdFN1YnRsZSk7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgIH1cbiAgICB0aGlzLnVzZVNvZnR3YXJlID0gIXRoaXMuc3VidGxlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJ0bGUgPSBudWxsLCB0aGlzLnNvZnR3YXJlRGVjcnlwdGVyID0gbnVsbCwgdGhpcy5rZXkgPSBudWxsLCB0aGlzLmZhc3RBZXNLZXkgPSBudWxsLCB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsLCB0aGlzLmN1cnJlbnRJViA9IG51bGwsIHRoaXMuY3VycmVudFJlc3VsdCA9IG51bGw7XG4gIH1cbiAgaXNTeW5jKCkge1xuICAgIHJldHVybiB0aGlzLnVzZVNvZnR3YXJlO1xuICB9XG4gIGZsdXNoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRSZXN1bHQ6IGUsXG4gICAgICByZW1haW5kZXJEYXRhOiB0XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFlIHx8IHQpXG4gICAgICByZXR1cm4gdGhpcy5yZXNldCgpLCBudWxsO1xuICAgIGNvbnN0IHIgPSBuZXcgVWludDhBcnJheShlKTtcbiAgICByZXR1cm4gdGhpcy5yZXNldCgpLCB0aGlzLnJlbW92ZVBLQ1M3UGFkZGluZyA/IEFiKHIpIDogcjtcbiAgfVxuICByZXNldCgpIHtcbiAgICB0aGlzLmN1cnJlbnRSZXN1bHQgPSBudWxsLCB0aGlzLmN1cnJlbnRJViA9IG51bGwsIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGwsIHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgJiYgKHRoaXMuc29mdHdhcmVEZWNyeXB0ZXIgPSBudWxsKTtcbiAgfVxuICBkZWNyeXB0KGUsIHQsIHIsIG4pIHtcbiAgICByZXR1cm4gdGhpcy51c2VTb2Z0d2FyZSA/IG5ldyBQcm9taXNlKChpLCBvKSA9PiB7XG4gICAgICBjb25zdCBhID0gQXJyYXlCdWZmZXIuaXNWaWV3KGUpID8gZSA6IG5ldyBVaW50OEFycmF5KGUpO1xuICAgICAgdGhpcy5zb2Z0d2FyZURlY3J5cHQoYSwgdCwgciwgbik7XG4gICAgICBjb25zdCBsID0gdGhpcy5mbHVzaCgpO1xuICAgICAgbCA/IGkobC5idWZmZXIpIDogbyhuZXcgRXJyb3IoXCJbc29mdHdhcmVEZWNyeXB0XSBGYWlsZWQgdG8gZGVjcnlwdCBkYXRhXCIpKTtcbiAgICB9KSA6IHRoaXMud2ViQ3J5cHRvRGVjcnlwdChuZXcgVWludDhBcnJheShlKSwgdCwgciwgbik7XG4gIH1cbiAgLy8gU29mdHdhcmUgZGVjcnlwdGlvbiBpcyBwcm9ncmVzc2l2ZS4gUHJvZ3Jlc3NpdmUgZGVjcnlwdGlvbiBtYXkgbm90IHJldHVybiBhIHJlc3VsdCBvbiBlYWNoIGNhbGwuIEFueSBjYWNoZWRcbiAgLy8gZGF0YSBpcyBoYW5kbGVkIGluIHRoZSBmbHVzaCgpIGNhbGxcbiAgc29mdHdhcmVEZWNyeXB0KGUsIHQsIHIsIG4pIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50SVY6IGksXG4gICAgICBjdXJyZW50UmVzdWx0OiBvLFxuICAgICAgcmVtYWluZGVyRGF0YTogYVxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChuICE9PSBPcy5jYmMgfHwgdC5ieXRlTGVuZ3RoICE9PSAxNilcbiAgICAgIHJldHVybiBydC53YXJuKFwiU29mdHdhcmVEZWNyeXB0OiBjYW4gb25seSBoYW5kbGUgQUVTLTEyOC1DQkNcIiksIG51bGw7XG4gICAgdGhpcy5sb2dPbmNlKFwiSlMgQUVTIGRlY3J5cHRcIiksIGEgJiYgKGUgPSBfcihhLCBlKSwgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbCk7XG4gICAgY29uc3QgbCA9IHRoaXMuZ2V0VmFsaWRDaHVuayhlKTtcbiAgICBpZiAoIWwubGVuZ3RoKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgaSAmJiAociA9IGkpO1xuICAgIGxldCBjID0gdGhpcy5zb2Z0d2FyZURlY3J5cHRlcjtcbiAgICBjIHx8IChjID0gdGhpcy5zb2Z0d2FyZURlY3J5cHRlciA9IG5ldyBJYigpKSwgYy5leHBhbmRLZXkodCk7XG4gICAgY29uc3QgdSA9IG87XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFJlc3VsdCA9IGMuZGVjcnlwdChsLmJ1ZmZlciwgMCwgciksIHRoaXMuY3VycmVudElWID0gbC5zbGljZSgtMTYpLmJ1ZmZlciwgdSB8fCBudWxsO1xuICB9XG4gIHdlYkNyeXB0b0RlY3J5cHQoZSwgdCwgciwgbikge1xuICAgIGlmICh0aGlzLmtleSAhPT0gdCB8fCAhdGhpcy5mYXN0QWVzS2V5KSB7XG4gICAgICBpZiAoIXRoaXMuc3VidGxlKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMub25XZWJDcnlwdG9FcnJvcihlLCB0LCByLCBuKSk7XG4gICAgICB0aGlzLmtleSA9IHQsIHRoaXMuZmFzdEFlc0tleSA9IG5ldyBfYih0aGlzLnN1YnRsZSwgdCwgbik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZhc3RBZXNLZXkuZXhwYW5kS2V5KCkudGhlbigoaSkgPT4gdGhpcy5zdWJ0bGUgPyAodGhpcy5sb2dPbmNlKFwiV2ViQ3J5cHRvIEFFUyBkZWNyeXB0XCIpLCBuZXcgd2IodGhpcy5zdWJ0bGUsIG5ldyBVaW50OEFycmF5KHIpLCBuKS5kZWNyeXB0KGUuYnVmZmVyLCBpKSkgOiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJ3ZWIgY3J5cHRvIG5vdCBpbml0aWFsaXplZFwiKSkpLmNhdGNoKChpKSA9PiAocnQud2FybihgW2RlY3J5cHRlcl06IFdlYkNyeXB0byBFcnJvciwgZGlzYWJsZSBXZWJDcnlwdG8gQVBJLCAke2kubmFtZX06ICR7aS5tZXNzYWdlfWApLCB0aGlzLm9uV2ViQ3J5cHRvRXJyb3IoZSwgdCwgciwgbikpKTtcbiAgfVxuICBvbldlYkNyeXB0b0Vycm9yKGUsIHQsIHIsIG4pIHtcbiAgICBjb25zdCBpID0gdGhpcy5lbmFibGVTb2Z0d2FyZUFFUztcbiAgICBpZiAoaSkge1xuICAgICAgdGhpcy51c2VTb2Z0d2FyZSA9ICEwLCB0aGlzLmxvZ0VuYWJsZWQgPSAhMCwgdGhpcy5zb2Z0d2FyZURlY3J5cHQoZSwgdCwgciwgbik7XG4gICAgICBjb25zdCBvID0gdGhpcy5mbHVzaCgpO1xuICAgICAgaWYgKG8pXG4gICAgICAgIHJldHVybiBvLmJ1ZmZlcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViQ3J5cHRvXCIgKyAoaSA/IFwiIGFuZCBzb2Z0d2FyZURlY3J5cHRcIiA6IFwiXCIpICsgXCI6IGZhaWxlZCB0byBkZWNyeXB0IGRhdGFcIik7XG4gIH1cbiAgZ2V0VmFsaWRDaHVuayhlKSB7XG4gICAgbGV0IHQgPSBlO1xuICAgIGNvbnN0IHIgPSBlLmxlbmd0aCAtIGUubGVuZ3RoICUgTGI7XG4gICAgcmV0dXJuIHIgIT09IGUubGVuZ3RoICYmICh0ID0gZS5zbGljZSgwLCByKSwgdGhpcy5yZW1haW5kZXJEYXRhID0gZS5zbGljZShyKSksIHQ7XG4gIH1cbiAgbG9nT25jZShlKSB7XG4gICAgdGhpcy5sb2dFbmFibGVkICYmIChydC5sb2coYFtkZWNyeXB0ZXJdOiAke2V9YCksIHRoaXMubG9nRW5hYmxlZCA9ICExKTtcbiAgfVxufVxuY29uc3QgcGggPSBNYXRoLnBvdygyLCAxNyk7XG5jbGFzcyBDYiB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLmNvbmZpZyA9IHZvaWQgMCwgdGhpcy5sb2FkZXIgPSBudWxsLCB0aGlzLnBhcnRMb2FkVGltZW91dCA9IC0xLCB0aGlzLmNvbmZpZyA9IGU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmxvYWRlciAmJiAodGhpcy5sb2FkZXIuZGVzdHJveSgpLCB0aGlzLmxvYWRlciA9IG51bGwpO1xuICB9XG4gIGFib3J0KCkge1xuICAgIHRoaXMubG9hZGVyICYmIHRoaXMubG9hZGVyLmFib3J0KCk7XG4gIH1cbiAgbG9hZChlLCB0KSB7XG4gICAgY29uc3QgciA9IGUudXJsO1xuICAgIGlmICghcilcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgYXMoe1xuICAgICAgICB0eXBlOiB2ZS5ORVRXT1JLX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBKLkZSQUdfTE9BRF9FUlJPUixcbiAgICAgICAgZmF0YWw6ICExLFxuICAgICAgICBmcmFnOiBlLFxuICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBGcmFnbWVudCBkb2VzIG5vdCBoYXZlIGEgJHtyID8gXCJwYXJ0IGxpc3RcIiA6IFwidXJsXCJ9YCksXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzOiBudWxsXG4gICAgICB9KSk7XG4gICAgdGhpcy5hYm9ydCgpO1xuICAgIGNvbnN0IG4gPSB0aGlzLmNvbmZpZywgaSA9IG4uZkxvYWRlciwgbyA9IG4ubG9hZGVyO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoYSwgbCkgPT4ge1xuICAgICAgaWYgKHRoaXMubG9hZGVyICYmIHRoaXMubG9hZGVyLmRlc3Ryb3koKSwgZS5nYXApXG4gICAgICAgIGlmIChlLnRhZ0xpc3Quc29tZSgocCkgPT4gcFswXSA9PT0gXCJHQVBcIikpIHtcbiAgICAgICAgICBsKHloKGUpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIGUuZ2FwID0gITE7XG4gICAgICBjb25zdCBjID0gdGhpcy5sb2FkZXIgPSBpID8gbmV3IGkobikgOiBuZXcgbyhuKSwgdSA9IG1oKGUpO1xuICAgICAgZS5sb2FkZXIgPSBjO1xuICAgICAgY29uc3QgZCA9IGZoKG4uZnJhZ0xvYWRQb2xpY3kuZGVmYXVsdCksIGggPSB7XG4gICAgICAgIGxvYWRQb2xpY3k6IGQsXG4gICAgICAgIHRpbWVvdXQ6IGQubWF4TG9hZFRpbWVNcyxcbiAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IDAsXG4gICAgICAgIGhpZ2hXYXRlck1hcms6IGUuc24gPT09IFwiaW5pdFNlZ21lbnRcIiA/IDEgLyAwIDogcGhcbiAgICAgIH07XG4gICAgICBlLnN0YXRzID0gYy5zdGF0cztcbiAgICAgIGNvbnN0IGYgPSB7XG4gICAgICAgIG9uU3VjY2VzczogKHAsIHksIEUsIGIpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGUsIGMpO1xuICAgICAgICAgIGxldCBSID0gcC5kYXRhO1xuICAgICAgICAgIEUucmVzZXRJViAmJiBlLmRlY3J5cHRkYXRhICYmIChlLmRlY3J5cHRkYXRhLml2ID0gbmV3IFVpbnQ4QXJyYXkoUi5zbGljZSgwLCAxNikpLCBSID0gUi5zbGljZSgxNikpLCBhKHtcbiAgICAgICAgICAgIGZyYWc6IGUsXG4gICAgICAgICAgICBwYXJ0OiBudWxsLFxuICAgICAgICAgICAgcGF5bG9hZDogUixcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBiXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChwLCB5LCBFLCBiKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihlLCBjKSwgbChuZXcgYXMoe1xuICAgICAgICAgICAgdHlwZTogdmUuTkVUV09SS19FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEouRlJBR19MT0FEX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6ICExLFxuICAgICAgICAgICAgZnJhZzogZSxcbiAgICAgICAgICAgIHJlc3BvbnNlOiB0dCh7XG4gICAgICAgICAgICAgIHVybDogcixcbiAgICAgICAgICAgICAgZGF0YTogdm9pZCAwXG4gICAgICAgICAgICB9LCBwKSxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYEhUVFAgRXJyb3IgJHtwLmNvZGV9ICR7cC50ZXh0fWApLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IEUsXG4gICAgICAgICAgICBzdGF0czogYlxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25BYm9ydDogKHAsIHksIEUpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGUsIGMpLCBsKG5ldyBhcyh7XG4gICAgICAgICAgICB0eXBlOiB2ZS5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogSi5JTlRFUk5BTF9BQk9SVEVELFxuICAgICAgICAgICAgZmF0YWw6ICExLFxuICAgICAgICAgICAgZnJhZzogZSxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoXCJBYm9ydGVkXCIpLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IEUsXG4gICAgICAgICAgICBzdGF0czogcFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UaW1lb3V0OiAocCwgeSwgRSkgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZSwgYyksIGwobmV3IGFzKHtcbiAgICAgICAgICAgIHR5cGU6IHZlLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBKLkZSQUdfTE9BRF9USU1FT1VULFxuICAgICAgICAgICAgZmF0YWw6ICExLFxuICAgICAgICAgICAgZnJhZzogZSxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYFRpbWVvdXQgYWZ0ZXIgJHtoLnRpbWVvdXR9bXNgKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBFLFxuICAgICAgICAgICAgc3RhdHM6IHBcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0ICYmIChmLm9uUHJvZ3Jlc3MgPSAocCwgeSwgRSwgYikgPT4gdCh7XG4gICAgICAgIGZyYWc6IGUsXG4gICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgIHBheWxvYWQ6IEUsXG4gICAgICAgIG5ldHdvcmtEZXRhaWxzOiBiXG4gICAgICB9KSksIGMubG9hZCh1LCBoLCBmKTtcbiAgICB9KTtcbiAgfVxuICBsb2FkUGFydChlLCB0LCByKSB7XG4gICAgdGhpcy5hYm9ydCgpO1xuICAgIGNvbnN0IG4gPSB0aGlzLmNvbmZpZywgaSA9IG4uZkxvYWRlciwgbyA9IG4ubG9hZGVyO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgoYSwgbCkgPT4ge1xuICAgICAgaWYgKHRoaXMubG9hZGVyICYmIHRoaXMubG9hZGVyLmRlc3Ryb3koKSwgZS5nYXAgfHwgdC5nYXApIHtcbiAgICAgICAgbCh5aChlLCB0KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGMgPSB0aGlzLmxvYWRlciA9IGkgPyBuZXcgaShuKSA6IG5ldyBvKG4pLCB1ID0gbWgoZSwgdCk7XG4gICAgICBlLmxvYWRlciA9IGM7XG4gICAgICBjb25zdCBkID0gZmgobi5mcmFnTG9hZFBvbGljeS5kZWZhdWx0KSwgaCA9IHtcbiAgICAgICAgbG9hZFBvbGljeTogZCxcbiAgICAgICAgdGltZW91dDogZC5tYXhMb2FkVGltZU1zLFxuICAgICAgICBtYXhSZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheTogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheTogMCxcbiAgICAgICAgaGlnaFdhdGVyTWFyazogcGhcbiAgICAgIH07XG4gICAgICB0LnN0YXRzID0gYy5zdGF0cywgYy5sb2FkKHUsIGgsIHtcbiAgICAgICAgb25TdWNjZXNzOiAoZiwgcCwgeSwgRSkgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZSwgYyksIHRoaXMudXBkYXRlU3RhdHNGcm9tUGFydChlLCB0KTtcbiAgICAgICAgICBjb25zdCBiID0ge1xuICAgICAgICAgICAgZnJhZzogZSxcbiAgICAgICAgICAgIHBhcnQ6IHQsXG4gICAgICAgICAgICBwYXlsb2FkOiBmLmRhdGEsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogRVxuICAgICAgICAgIH07XG4gICAgICAgICAgcihiKSwgYShiKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogKGYsIHAsIHksIEUpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGUsIGMpLCBsKG5ldyBhcyh7XG4gICAgICAgICAgICB0eXBlOiB2ZS5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogSi5GUkFHX0xPQURfRVJST1IsXG4gICAgICAgICAgICBmYXRhbDogITEsXG4gICAgICAgICAgICBmcmFnOiBlLFxuICAgICAgICAgICAgcGFydDogdCxcbiAgICAgICAgICAgIHJlc3BvbnNlOiB0dCh7XG4gICAgICAgICAgICAgIHVybDogdS51cmwsXG4gICAgICAgICAgICAgIGRhdGE6IHZvaWQgMFxuICAgICAgICAgICAgfSwgZiksXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBIVFRQIEVycm9yICR7Zi5jb2RlfSAke2YudGV4dH1gKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiB5LFxuICAgICAgICAgICAgc3RhdHM6IEVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQWJvcnQ6IChmLCBwLCB5KSA9PiB7XG4gICAgICAgICAgZS5zdGF0cy5hYm9ydGVkID0gdC5zdGF0cy5hYm9ydGVkLCB0aGlzLnJlc2V0TG9hZGVyKGUsIGMpLCBsKG5ldyBhcyh7XG4gICAgICAgICAgICB0eXBlOiB2ZS5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogSi5JTlRFUk5BTF9BQk9SVEVELFxuICAgICAgICAgICAgZmF0YWw6ICExLFxuICAgICAgICAgICAgZnJhZzogZSxcbiAgICAgICAgICAgIHBhcnQ6IHQsXG4gICAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKFwiQWJvcnRlZFwiKSxcbiAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiB5LFxuICAgICAgICAgICAgc3RhdHM6IGZcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVGltZW91dDogKGYsIHAsIHkpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGUsIGMpLCBsKG5ldyBhcyh7XG4gICAgICAgICAgICB0eXBlOiB2ZS5ORVRXT1JLX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogSi5GUkFHX0xPQURfVElNRU9VVCxcbiAgICAgICAgICAgIGZhdGFsOiAhMSxcbiAgICAgICAgICAgIGZyYWc6IGUsXG4gICAgICAgICAgICBwYXJ0OiB0LFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgVGltZW91dCBhZnRlciAke2gudGltZW91dH1tc2ApLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IHksXG4gICAgICAgICAgICBzdGF0czogZlxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlU3RhdHNGcm9tUGFydChlLCB0KSB7XG4gICAgY29uc3QgciA9IGUuc3RhdHMsIG4gPSB0LnN0YXRzLCBpID0gbi50b3RhbDtcbiAgICBpZiAoci5sb2FkZWQgKz0gbi5sb2FkZWQsIGkpIHtcbiAgICAgIGNvbnN0IGwgPSBNYXRoLnJvdW5kKGUuZHVyYXRpb24gLyB0LmR1cmF0aW9uKSwgYyA9IE1hdGgubWluKE1hdGgucm91bmQoci5sb2FkZWQgLyBpKSwgbCksIGQgPSAobCAtIGMpICogTWF0aC5yb3VuZChyLmxvYWRlZCAvIGMpO1xuICAgICAgci50b3RhbCA9IHIubG9hZGVkICsgZDtcbiAgICB9IGVsc2VcbiAgICAgIHIudG90YWwgPSBNYXRoLm1heChyLmxvYWRlZCwgci50b3RhbCk7XG4gICAgY29uc3QgbyA9IHIubG9hZGluZywgYSA9IG4ubG9hZGluZztcbiAgICBvLnN0YXJ0ID8gby5maXJzdCArPSBhLmZpcnN0IC0gYS5zdGFydCA6IChvLnN0YXJ0ID0gYS5zdGFydCwgby5maXJzdCA9IGEuZmlyc3QpLCBvLmVuZCA9IGEuZW5kO1xuICB9XG4gIHJlc2V0TG9hZGVyKGUsIHQpIHtcbiAgICBlLmxvYWRlciA9IG51bGwsIHRoaXMubG9hZGVyID09PSB0ICYmIChzZWxmLmNsZWFyVGltZW91dCh0aGlzLnBhcnRMb2FkVGltZW91dCksIHRoaXMubG9hZGVyID0gbnVsbCksIHQuZGVzdHJveSgpO1xuICB9XG59XG5mdW5jdGlvbiBtaChzLCBlID0gbnVsbCkge1xuICBjb25zdCB0ID0gZSB8fCBzLCByID0ge1xuICAgIGZyYWc6IHMsXG4gICAgcGFydDogZSxcbiAgICByZXNwb25zZVR5cGU6IFwiYXJyYXlidWZmZXJcIixcbiAgICB1cmw6IHQudXJsLFxuICAgIGhlYWRlcnM6IHt9LFxuICAgIHJhbmdlU3RhcnQ6IDAsXG4gICAgcmFuZ2VFbmQ6IDBcbiAgfSwgbiA9IHQuYnl0ZVJhbmdlU3RhcnRPZmZzZXQsIGkgPSB0LmJ5dGVSYW5nZUVuZE9mZnNldDtcbiAgaWYgKHVlKG4pICYmIHVlKGkpKSB7XG4gICAgdmFyIG87XG4gICAgbGV0IGEgPSBuLCBsID0gaTtcbiAgICBpZiAocy5zbiA9PT0gXCJpbml0U2VnbWVudFwiICYmIGtiKChvID0gcy5kZWNyeXB0ZGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8ubWV0aG9kKSkge1xuICAgICAgY29uc3QgYyA9IGkgLSBuO1xuICAgICAgYyAlIDE2ICYmIChsID0gaSArICgxNiAtIGMgJSAxNikpLCBuICE9PSAwICYmIChyLnJlc2V0SVYgPSAhMCwgYSA9IG4gLSAxNik7XG4gICAgfVxuICAgIHIucmFuZ2VTdGFydCA9IGEsIHIucmFuZ2VFbmQgPSBsO1xuICB9XG4gIHJldHVybiByO1xufVxuZnVuY3Rpb24geWgocywgZSkge1xuICBjb25zdCB0ID0gbmV3IEVycm9yKGBHQVAgJHtzLmdhcCA/IFwidGFnXCIgOiBcImF0dHJpYnV0ZVwifSBmb3VuZGApLCByID0ge1xuICAgIHR5cGU6IHZlLk1FRElBX0VSUk9SLFxuICAgIGRldGFpbHM6IEouRlJBR19HQVAsXG4gICAgZmF0YWw6ICExLFxuICAgIGZyYWc6IHMsXG4gICAgZXJyb3I6IHQsXG4gICAgbmV0d29ya0RldGFpbHM6IG51bGxcbiAgfTtcbiAgcmV0dXJuIGUgJiYgKHIucGFydCA9IGUpLCAoZSB8fCBzKS5zdGF0cy5hYm9ydGVkID0gITAsIG5ldyBhcyhyKTtcbn1cbmZ1bmN0aW9uIGtiKHMpIHtcbiAgcmV0dXJuIHMgPT09IFwiQUVTLTEyOFwiIHx8IHMgPT09IFwiQUVTLTI1NlwiO1xufVxuY2xhc3MgYXMgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlLmVycm9yLm1lc3NhZ2UpLCB0aGlzLmRhdGEgPSB2b2lkIDAsIHRoaXMuZGF0YSA9IGU7XG4gIH1cbn1cbmNsYXNzIEhnIGV4dGVuZHMgTHIge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgdCksIHRoaXMuX2JvdW5kVGljayA9IHZvaWQgMCwgdGhpcy5fdGlja1RpbWVyID0gbnVsbCwgdGhpcy5fdGlja0ludGVydmFsID0gbnVsbCwgdGhpcy5fdGlja0NhbGxDb3VudCA9IDAsIHRoaXMuX2JvdW5kVGljayA9IHRoaXMudGljay5iaW5kKHRoaXMpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5vbkhhbmRsZXJEZXN0cm95aW5nKCksIHRoaXMub25IYW5kbGVyRGVzdHJveWVkKCk7XG4gIH1cbiAgb25IYW5kbGVyRGVzdHJveWluZygpIHtcbiAgICB0aGlzLmNsZWFyTmV4dFRpY2soKSwgdGhpcy5jbGVhckludGVydmFsKCk7XG4gIH1cbiAgb25IYW5kbGVyRGVzdHJveWVkKCkge1xuICB9XG4gIGhhc0ludGVydmFsKCkge1xuICAgIHJldHVybiAhIXRoaXMuX3RpY2tJbnRlcnZhbDtcbiAgfVxuICBoYXNOZXh0VGljaygpIHtcbiAgICByZXR1cm4gISF0aGlzLl90aWNrVGltZXI7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSBtaWxsaXMgLSBJbnRlcnZhbCB0aW1lIChtcylcbiAgICogQGV0dXJucyBUcnVlIHdoZW4gaW50ZXJ2YWwgaGFzIGJlZW4gc2NoZWR1bGVkLCBmYWxzZSB3aGVuIGFscmVhZHkgc2NoZWR1bGVkIChubyBlZmZlY3QpXG4gICAqL1xuICBzZXRJbnRlcnZhbChlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpY2tJbnRlcnZhbCA/ICExIDogKHRoaXMuX3RpY2tDYWxsQ291bnQgPSAwLCB0aGlzLl90aWNrSW50ZXJ2YWwgPSBzZWxmLnNldEludGVydmFsKHRoaXMuX2JvdW5kVGljaywgZSksICEwKTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgVHJ1ZSB3aGVuIGludGVydmFsIHdhcyBjbGVhcmVkLCBmYWxzZSB3aGVuIG5vbmUgd2FzIHNldCAobm8gZWZmZWN0KVxuICAgKi9cbiAgY2xlYXJJbnRlcnZhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGlja0ludGVydmFsID8gKHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLl90aWNrSW50ZXJ2YWwpLCB0aGlzLl90aWNrSW50ZXJ2YWwgPSBudWxsLCAhMCkgOiAhMTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgVHJ1ZSB3aGVuIHRpbWVvdXQgd2FzIGNsZWFyZWQsIGZhbHNlIHdoZW4gbm9uZSB3YXMgc2V0IChubyBlZmZlY3QpXG4gICAqL1xuICBjbGVhck5leHRUaWNrKCkge1xuICAgIHJldHVybiB0aGlzLl90aWNrVGltZXIgPyAoc2VsZi5jbGVhclRpbWVvdXQodGhpcy5fdGlja1RpbWVyKSwgdGhpcy5fdGlja1RpbWVyID0gbnVsbCwgITApIDogITE7XG4gIH1cbiAgLyoqXG4gICAqIFdpbGwgY2FsbCB0aGUgc3ViY2xhc3MgZG9UaWNrIGltcGxlbWVudGF0aW9uIGluIHRoaXMgbWFpbiBsb29wIHRpY2tcbiAgICogb3IgaW4gdGhlIG5leHQgb25lICh2aWEgc2V0VGltZW91dCgsMCkpIGluIGNhc2UgaXQgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWRcbiAgICogaW4gdGhpcyB0aWNrIChpbiBjYXNlIHRoaXMgaXMgYSByZS1lbnRyYW50IGNhbGwpLlxuICAgKi9cbiAgdGljaygpIHtcbiAgICB0aGlzLl90aWNrQ2FsbENvdW50KyssIHRoaXMuX3RpY2tDYWxsQ291bnQgPT09IDEgJiYgKHRoaXMuZG9UaWNrKCksIHRoaXMuX3RpY2tDYWxsQ291bnQgPiAxICYmIHRoaXMudGlja0ltbWVkaWF0ZSgpLCB0aGlzLl90aWNrQ2FsbENvdW50ID0gMCk7XG4gIH1cbiAgdGlja0ltbWVkaWF0ZSgpIHtcbiAgICB0aGlzLmNsZWFyTmV4dFRpY2soKSwgdGhpcy5fdGlja1RpbWVyID0gc2VsZi5zZXRUaW1lb3V0KHRoaXMuX2JvdW5kVGljaywgMCk7XG4gIH1cbiAgLyoqXG4gICAqIEZvciBzdWJjbGFzcyB0byBpbXBsZW1lbnQgdGFzayBsb2dpY1xuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGRvVGljaygpIHtcbiAgfVxufVxuY2xhc3MgRXUge1xuICBjb25zdHJ1Y3RvcihlLCB0LCByLCBuID0gMCwgaSA9IC0xLCBvID0gITEpIHtcbiAgICB0aGlzLmxldmVsID0gdm9pZCAwLCB0aGlzLnNuID0gdm9pZCAwLCB0aGlzLnBhcnQgPSB2b2lkIDAsIHRoaXMuaWQgPSB2b2lkIDAsIHRoaXMuc2l6ZSA9IHZvaWQgMCwgdGhpcy5wYXJ0aWFsID0gdm9pZCAwLCB0aGlzLnRyYW5zbXV4aW5nID0gcWkoKSwgdGhpcy5idWZmZXJpbmcgPSB7XG4gICAgICBhdWRpbzogcWkoKSxcbiAgICAgIHZpZGVvOiBxaSgpLFxuICAgICAgYXVkaW92aWRlbzogcWkoKVxuICAgIH0sIHRoaXMubGV2ZWwgPSBlLCB0aGlzLnNuID0gdCwgdGhpcy5pZCA9IHIsIHRoaXMuc2l6ZSA9IG4sIHRoaXMucGFydCA9IGksIHRoaXMucGFydGlhbCA9IG87XG4gIH1cbn1cbmZ1bmN0aW9uIHFpKCkge1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiAwLFxuICAgIGV4ZWN1dGVTdGFydDogMCxcbiAgICBleGVjdXRlRW5kOiAwLFxuICAgIGVuZDogMFxuICB9O1xufVxuY29uc3QgdmggPSB7XG4gIGxlbmd0aDogMCxcbiAgc3RhcnQ6ICgpID0+IDAsXG4gIGVuZDogKCkgPT4gMFxufTtcbmNsYXNzIENlIHtcbiAgLyoqXG4gICAqIFJldHVybiB0cnVlIGlmIGBtZWRpYWAncyBidWZmZXJlZCBpbmNsdWRlIGBwb3NpdGlvbmBcbiAgICovXG4gIHN0YXRpYyBpc0J1ZmZlcmVkKGUsIHQpIHtcbiAgICBpZiAoZSkge1xuICAgICAgY29uc3QgciA9IENlLmdldEJ1ZmZlcmVkKGUpO1xuICAgICAgZm9yIChsZXQgbiA9IHIubGVuZ3RoOyBuLS07IClcbiAgICAgICAgaWYgKHQgPj0gci5zdGFydChuKSAmJiB0IDw9IHIuZW5kKG4pKVxuICAgICAgICAgIHJldHVybiAhMDtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHN0YXRpYyBidWZmZXJlZFJhbmdlcyhlKSB7XG4gICAgaWYgKGUpIHtcbiAgICAgIGNvbnN0IHQgPSBDZS5nZXRCdWZmZXJlZChlKTtcbiAgICAgIHJldHVybiBDZS50aW1lUmFuZ2VzVG9BcnJheSh0KTtcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHN0YXRpYyB0aW1lUmFuZ2VzVG9BcnJheShlKSB7XG4gICAgY29uc3QgdCA9IFtdO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgZS5sZW5ndGg7IHIrKylcbiAgICAgIHQucHVzaCh7XG4gICAgICAgIHN0YXJ0OiBlLnN0YXJ0KHIpLFxuICAgICAgICBlbmQ6IGUuZW5kKHIpXG4gICAgICB9KTtcbiAgICByZXR1cm4gdDtcbiAgfVxuICBzdGF0aWMgYnVmZmVySW5mbyhlLCB0LCByKSB7XG4gICAgaWYgKGUpIHtcbiAgICAgIGNvbnN0IG4gPSBDZS5idWZmZXJlZFJhbmdlcyhlKTtcbiAgICAgIGlmIChuLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIENlLmJ1ZmZlcmVkSW5mbyhuLCB0LCByKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxlbjogMCxcbiAgICAgIHN0YXJ0OiB0LFxuICAgICAgZW5kOiB0LFxuICAgICAgYnVmZmVyZWRJbmRleDogLTFcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBidWZmZXJlZEluZm8oZSwgdCwgcikge1xuICAgIHQgPSBNYXRoLm1heCgwLCB0KSwgZS5sZW5ndGggPiAxICYmIGUuc29ydCgodSwgZCkgPT4gdS5zdGFydCAtIGQuc3RhcnQgfHwgZC5lbmQgLSB1LmVuZCk7XG4gICAgbGV0IG4gPSAtMSwgaSA9IFtdO1xuICAgIGlmIChyKVxuICAgICAgZm9yIChsZXQgdSA9IDA7IHUgPCBlLmxlbmd0aDsgdSsrKSB7XG4gICAgICAgIHQgPj0gZVt1XS5zdGFydCAmJiB0IDw9IGVbdV0uZW5kICYmIChuID0gdSk7XG4gICAgICAgIGNvbnN0IGQgPSBpLmxlbmd0aDtcbiAgICAgICAgaWYgKGQpIHtcbiAgICAgICAgICBjb25zdCBoID0gaVtkIC0gMV0uZW5kO1xuICAgICAgICAgIGVbdV0uc3RhcnQgLSBoIDwgciA/IGVbdV0uZW5kID4gaCAmJiAoaVtkIC0gMV0uZW5kID0gZVt1XS5lbmQpIDogaS5wdXNoKGVbdV0pO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBpLnB1c2goZVt1XSk7XG4gICAgICB9XG4gICAgZWxzZVxuICAgICAgaSA9IGU7XG4gICAgbGV0IG8gPSAwLCBhLCBsID0gdCwgYyA9IHQ7XG4gICAgZm9yIChsZXQgdSA9IDA7IHUgPCBpLmxlbmd0aDsgdSsrKSB7XG4gICAgICBjb25zdCBkID0gaVt1XS5zdGFydCwgaCA9IGlbdV0uZW5kO1xuICAgICAgaWYgKG4gPT09IC0xICYmIHQgPj0gZCAmJiB0IDw9IGggJiYgKG4gPSB1KSwgdCArIHIgPj0gZCAmJiB0IDwgaClcbiAgICAgICAgbCA9IGQsIGMgPSBoLCBvID0gYyAtIHQ7XG4gICAgICBlbHNlIGlmICh0ICsgciA8IGQpIHtcbiAgICAgICAgYSA9IGQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbGVuOiBvLFxuICAgICAgc3RhcnQ6IGwgfHwgMCxcbiAgICAgIGVuZDogYyB8fCAwLFxuICAgICAgbmV4dFN0YXJ0OiBhLFxuICAgICAgYnVmZmVyZWQ6IGUsXG4gICAgICBidWZmZXJlZEluZGV4OiBuXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogU2FmZSBtZXRob2QgdG8gZ2V0IGJ1ZmZlcmVkIHByb3BlcnR5LlxuICAgKiBTb3VyY2VCdWZmZXIuYnVmZmVyZWQgbWF5IHRocm93IGlmIFNvdXJjZUJ1ZmZlciBpcyByZW1vdmVkIGZyb20gaXQncyBNZWRpYVNvdXJjZVxuICAgKi9cbiAgc3RhdGljIGdldEJ1ZmZlcmVkKGUpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGUuYnVmZmVyZWQgfHwgdmg7XG4gICAgfSBjYXRjaCAodCkge1xuICAgICAgcmV0dXJuIHJ0LmxvZyhcImZhaWxlZCB0byBnZXQgbWVkaWEuYnVmZmVyZWRcIiwgdCksIHZoO1xuICAgIH1cbiAgfVxufVxuY29uc3QgcWcgPSAvXFx7XFwkKFthLXpBLVowLTktX10rKVxcfS9nO1xuZnVuY3Rpb24gRWgocykge1xuICByZXR1cm4gcWcudGVzdChzKTtcbn1cbmZ1bmN0aW9uIGRjKHMsIGUpIHtcbiAgaWYgKHMudmFyaWFibGVMaXN0ICE9PSBudWxsIHx8IHMuaGFzVmFyaWFibGVSZWZzKSB7XG4gICAgY29uc3QgdCA9IHMudmFyaWFibGVMaXN0O1xuICAgIHJldHVybiBlLnJlcGxhY2UocWcsIChyKSA9PiB7XG4gICAgICBjb25zdCBuID0gci5zdWJzdHJpbmcoMiwgci5sZW5ndGggLSAxKSwgaSA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHRbbl07XG4gICAgICByZXR1cm4gaSA9PT0gdm9pZCAwID8gKHMucGxheWxpc3RQYXJzaW5nRXJyb3IgfHwgKHMucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoYE1pc3NpbmcgcHJlY2VkaW5nIEVYVC1YLURFRklORSB0YWcgZm9yIFZhcmlhYmxlIFJlZmVyZW5jZTogXCIke259XCJgKSksIHIpIDogaTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHhoKHMsIGUsIHQpIHtcbiAgbGV0IHIgPSBzLnZhcmlhYmxlTGlzdDtcbiAgciB8fCAocy52YXJpYWJsZUxpc3QgPSByID0ge30pO1xuICBsZXQgbiwgaTtcbiAgaWYgKFwiUVVFUllQQVJBTVwiIGluIGUpIHtcbiAgICBuID0gZS5RVUVSWVBBUkFNO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBvID0gbmV3IHNlbGYuVVJMKHQpLnNlYXJjaFBhcmFtcztcbiAgICAgIGlmIChvLmhhcyhuKSlcbiAgICAgICAgaSA9IG8uZ2V0KG4pO1xuICAgICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtufVwiIGRvZXMgbm90IG1hdGNoIGFueSBxdWVyeSBwYXJhbWV0ZXIgaW4gVVJJOiBcIiR7dH1cImApO1xuICAgIH0gY2F0Y2ggKG8pIHtcbiAgICAgIHMucGxheWxpc3RQYXJzaW5nRXJyb3IgfHwgKHMucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoYEVYVC1YLURFRklORSBRVUVSWVBBUkFNOiAke28ubWVzc2FnZX1gKSk7XG4gICAgfVxuICB9IGVsc2VcbiAgICBuID0gZS5OQU1FLCBpID0gZS5WQUxVRTtcbiAgbiBpbiByID8gcy5wbGF5bGlzdFBhcnNpbmdFcnJvciB8fCAocy5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgRVhULVgtREVGSU5FIGR1cGxpY2F0ZSBWYXJpYWJsZSBOYW1lIGRlY2xhcmF0aW9uczogXCIke259XCJgKSkgOiByW25dID0gaSB8fCBcIlwiO1xufVxuZnVuY3Rpb24gRGIocywgZSwgdCkge1xuICBjb25zdCByID0gZS5JTVBPUlQ7XG4gIGlmICh0ICYmIHIgaW4gdCkge1xuICAgIGxldCBuID0gcy52YXJpYWJsZUxpc3Q7XG4gICAgbiB8fCAocy52YXJpYWJsZUxpc3QgPSBuID0ge30pLCBuW3JdID0gdFtyXTtcbiAgfSBlbHNlXG4gICAgcy5wbGF5bGlzdFBhcnNpbmdFcnJvciB8fCAocy5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgRVhULVgtREVGSU5FIElNUE9SVCBhdHRyaWJ1dGUgbm90IGZvdW5kIGluIE11bHRpdmFyaWFudCBQbGF5bGlzdDogXCIke3J9XCJgKSk7XG59XG5jb25zdCBQYiA9IC9eKFxcZCspeChcXGQrKSQvLCBTaCA9IC8oLis/KT0oXCIuKj9cInwuKj8pKD86LHwkKS9nO1xuY2xhc3MgZ3Qge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgdHlwZW9mIGUgPT0gXCJzdHJpbmdcIiAmJiAoZSA9IGd0LnBhcnNlQXR0ckxpc3QoZSwgdCkpLCBudCh0aGlzLCBlKTtcbiAgfVxuICBnZXQgY2xpZW50QXR0cnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMpLmZpbHRlcigoZSkgPT4gZS5zdWJzdHJpbmcoMCwgMikgPT09IFwiWC1cIik7XG4gIH1cbiAgZGVjaW1hbEludGVnZXIoZSkge1xuICAgIGNvbnN0IHQgPSBwYXJzZUludCh0aGlzW2VdLCAxMCk7XG4gICAgcmV0dXJuIHQgPiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA/IDEgLyAwIDogdDtcbiAgfVxuICBoZXhhZGVjaW1hbEludGVnZXIoZSkge1xuICAgIGlmICh0aGlzW2VdKSB7XG4gICAgICBsZXQgdCA9ICh0aGlzW2VdIHx8IFwiMHhcIikuc2xpY2UoMik7XG4gICAgICB0ID0gKHQubGVuZ3RoICYgMSA/IFwiMFwiIDogXCJcIikgKyB0O1xuICAgICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KHQubGVuZ3RoIC8gMik7XG4gICAgICBmb3IgKGxldCBuID0gMDsgbiA8IHQubGVuZ3RoIC8gMjsgbisrKVxuICAgICAgICByW25dID0gcGFyc2VJbnQodC5zbGljZShuICogMiwgbiAqIDIgKyAyKSwgMTYpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGhleGFkZWNpbWFsSW50ZWdlckFzTnVtYmVyKGUpIHtcbiAgICBjb25zdCB0ID0gcGFyc2VJbnQodGhpc1tlXSwgMTYpO1xuICAgIHJldHVybiB0ID4gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgPyAxIC8gMCA6IHQ7XG4gIH1cbiAgZGVjaW1hbEZsb2F0aW5nUG9pbnQoZSkge1xuICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXNbZV0pO1xuICB9XG4gIG9wdGlvbmFsRmxvYXQoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0aGlzW2VdO1xuICAgIHJldHVybiByID8gcGFyc2VGbG9hdChyKSA6IHQ7XG4gIH1cbiAgZW51bWVyYXRlZFN0cmluZyhlKSB7XG4gICAgcmV0dXJuIHRoaXNbZV07XG4gIH1cbiAgZW51bWVyYXRlZFN0cmluZ0xpc3QoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0aGlzW2VdO1xuICAgIHJldHVybiAociA/IHIuc3BsaXQoL1sgLF0rLykgOiBbXSkucmVkdWNlKChuLCBpKSA9PiAobltpLnRvTG93ZXJDYXNlKCldID0gITAsIG4pLCB0KTtcbiAgfVxuICBib29sKGUpIHtcbiAgICByZXR1cm4gdGhpc1tlXSA9PT0gXCJZRVNcIjtcbiAgfVxuICBkZWNpbWFsUmVzb2x1dGlvbihlKSB7XG4gICAgY29uc3QgdCA9IFBiLmV4ZWModGhpc1tlXSk7XG4gICAgaWYgKHQgIT09IG51bGwpXG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogcGFyc2VJbnQodFsxXSwgMTApLFxuICAgICAgICBoZWlnaHQ6IHBhcnNlSW50KHRbMl0sIDEwKVxuICAgICAgfTtcbiAgfVxuICBzdGF0aWMgcGFyc2VBdHRyTGlzdChlLCB0KSB7XG4gICAgbGV0IHI7XG4gICAgY29uc3QgbiA9IHt9O1xuICAgIGZvciAoU2gubGFzdEluZGV4ID0gMDsgKHIgPSBTaC5leGVjKGUpKSAhPT0gbnVsbDsgKSB7XG4gICAgICBjb25zdCBvID0gclsxXS50cmltKCk7XG4gICAgICBsZXQgYSA9IHJbMl07XG4gICAgICBjb25zdCBsID0gYS5pbmRleE9mKCdcIicpID09PSAwICYmIGEubGFzdEluZGV4T2YoJ1wiJykgPT09IGEubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBjID0gITE7XG4gICAgICBpZiAobClcbiAgICAgICAgYSA9IGEuc2xpY2UoMSwgLTEpO1xuICAgICAgZWxzZVxuICAgICAgICBzd2l0Y2ggKG8pIHtcbiAgICAgICAgICBjYXNlIFwiSVZcIjpcbiAgICAgICAgICBjYXNlIFwiU0NURTM1LUNNRFwiOlxuICAgICAgICAgIGNhc2UgXCJTQ1RFMzUtSU5cIjpcbiAgICAgICAgICBjYXNlIFwiU0NURTM1LU9VVFwiOlxuICAgICAgICAgICAgYyA9ICEwO1xuICAgICAgICB9XG4gICAgICBpZiAodCAmJiAobCB8fCBjKSlcbiAgICAgICAgYSA9IGRjKHQsIGEpO1xuICAgICAgZWxzZSBpZiAoIWMgJiYgIWwpXG4gICAgICAgIHN3aXRjaCAobykge1xuICAgICAgICAgIGNhc2UgXCJDTE9TRUQtQ0FQVElPTlNcIjpcbiAgICAgICAgICAgIGlmIChhID09PSBcIk5PTkVcIilcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgICAgIGNhc2UgXCJBTExPV0VELUNQQ1wiOlxuICAgICAgICAgIGNhc2UgXCJDTEFTU1wiOlxuICAgICAgICAgIGNhc2UgXCJBU1NPQy1MQU5HVUFHRVwiOlxuICAgICAgICAgIGNhc2UgXCJBVURJT1wiOlxuICAgICAgICAgIGNhc2UgXCJCWVRFUkFOR0VcIjpcbiAgICAgICAgICBjYXNlIFwiQ0hBTk5FTFNcIjpcbiAgICAgICAgICBjYXNlIFwiQ0hBUkFDVEVSSVNUSUNTXCI6XG4gICAgICAgICAgY2FzZSBcIkNPREVDU1wiOlxuICAgICAgICAgIGNhc2UgXCJEQVRBLUlEXCI6XG4gICAgICAgICAgY2FzZSBcIkVORC1EQVRFXCI6XG4gICAgICAgICAgY2FzZSBcIkdST1VQLUlEXCI6XG4gICAgICAgICAgY2FzZSBcIklEXCI6XG4gICAgICAgICAgY2FzZSBcIklNUE9SVFwiOlxuICAgICAgICAgIGNhc2UgXCJJTlNUUkVBTS1JRFwiOlxuICAgICAgICAgIGNhc2UgXCJLRVlGT1JNQVRcIjpcbiAgICAgICAgICBjYXNlIFwiS0VZRk9STUFUVkVSU0lPTlNcIjpcbiAgICAgICAgICBjYXNlIFwiTEFOR1VBR0VcIjpcbiAgICAgICAgICBjYXNlIFwiTkFNRVwiOlxuICAgICAgICAgIGNhc2UgXCJQQVRIV0FZLUlEXCI6XG4gICAgICAgICAgY2FzZSBcIlFVRVJZUEFSQU1cIjpcbiAgICAgICAgICBjYXNlIFwiUkVDRU5UTFktUkVNT1ZFRC1EQVRFUkFOR0VTXCI6XG4gICAgICAgICAgY2FzZSBcIlNFUlZFUi1VUklcIjpcbiAgICAgICAgICBjYXNlIFwiU1RBQkxFLVJFTkRJVElPTi1JRFwiOlxuICAgICAgICAgIGNhc2UgXCJTVEFCTEUtVkFSSUFOVC1JRFwiOlxuICAgICAgICAgIGNhc2UgXCJTVEFSVC1EQVRFXCI6XG4gICAgICAgICAgY2FzZSBcIlNVQlRJVExFU1wiOlxuICAgICAgICAgIGNhc2UgXCJTVVBQTEVNRU5UQUwtQ09ERUNTXCI6XG4gICAgICAgICAgY2FzZSBcIlVSSVwiOlxuICAgICAgICAgIGNhc2UgXCJWQUxVRVwiOlxuICAgICAgICAgIGNhc2UgXCJWSURFT1wiOlxuICAgICAgICAgIGNhc2UgXCJYLUFTU0VULUxJU1RcIjpcbiAgICAgICAgICBjYXNlIFwiWC1BU1NFVC1VUklcIjpcbiAgICAgICAgICAgIHJ0Lndhcm4oYCR7ZX06IGF0dHJpYnV0ZSAke299IGlzIG1pc3NpbmcgcXVvdGVzYCk7XG4gICAgICAgIH1cbiAgICAgIG5bb10gPSBhO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxufVxuY29uc3QgTWIgPSBcImNvbS5hcHBsZS5obHMuaW50ZXJzdGl0aWFsXCI7XG5mdW5jdGlvbiBPYihzKSB7XG4gIHJldHVybiBzICE9PSBcIklEXCIgJiYgcyAhPT0gXCJDTEFTU1wiICYmIHMgIT09IFwiQ1VFXCIgJiYgcyAhPT0gXCJTVEFSVC1EQVRFXCIgJiYgcyAhPT0gXCJEVVJBVElPTlwiICYmIHMgIT09IFwiRU5ELURBVEVcIiAmJiBzICE9PSBcIkVORC1PTi1ORVhUXCI7XG59XG5mdW5jdGlvbiBCYihzKSB7XG4gIHJldHVybiBzID09PSBcIlNDVEUzNS1PVVRcIiB8fCBzID09PSBcIlNDVEUzNS1JTlwiIHx8IHMgPT09IFwiU0NURTM1LUNNRFwiO1xufVxuY2xhc3MgV2cge1xuICBjb25zdHJ1Y3RvcihlLCB0LCByID0gMCkge1xuICAgIHZhciBuO1xuICAgIGlmICh0aGlzLmF0dHIgPSB2b2lkIDAsIHRoaXMudGFnQW5jaG9yID0gdm9pZCAwLCB0aGlzLnRhZ09yZGVyID0gdm9pZCAwLCB0aGlzLl9zdGFydERhdGUgPSB2b2lkIDAsIHRoaXMuX2VuZERhdGUgPSB2b2lkIDAsIHRoaXMuX2RhdGVBdEVuZCA9IHZvaWQgMCwgdGhpcy5fY3VlID0gdm9pZCAwLCB0aGlzLl9iYWRWYWx1ZUZvclNhbWVJZCA9IHZvaWQgMCwgdGhpcy50YWdBbmNob3IgPSAodCA9PSBudWxsID8gdm9pZCAwIDogdC50YWdBbmNob3IpIHx8IG51bGwsIHRoaXMudGFnT3JkZXIgPSAobiA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQudGFnT3JkZXIpICE9IG51bGwgPyBuIDogciwgdCkge1xuICAgICAgY29uc3QgaSA9IHQuYXR0cjtcbiAgICAgIGZvciAoY29uc3QgbyBpbiBpKVxuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIG8pICYmIGVbb10gIT09IGlbb10pIHtcbiAgICAgICAgICBydC53YXJuKGBEQVRFUkFOR0UgdGFnIGF0dHJpYnV0ZTogXCIke299XCIgZG9lcyBub3QgbWF0Y2ggZm9yIHRhZ3Mgd2l0aCBJRDogXCIke2UuSUR9XCJgKSwgdGhpcy5fYmFkVmFsdWVGb3JTYW1lSWQgPSBvO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBlID0gbnQobmV3IGd0KHt9KSwgaSwgZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmF0dHIgPSBlLCB0ID8gKHRoaXMuX3N0YXJ0RGF0ZSA9IHQuX3N0YXJ0RGF0ZSwgdGhpcy5fY3VlID0gdC5fY3VlLCB0aGlzLl9lbmREYXRlID0gdC5fZW5kRGF0ZSwgdGhpcy5fZGF0ZUF0RW5kID0gdC5fZGF0ZUF0RW5kKSA6IHRoaXMuX3N0YXJ0RGF0ZSA9IG5ldyBEYXRlKGVbXCJTVEFSVC1EQVRFXCJdKSwgXCJFTkQtREFURVwiIGluIHRoaXMuYXR0cikge1xuICAgICAgY29uc3QgaSA9ICh0ID09IG51bGwgPyB2b2lkIDAgOiB0LmVuZERhdGUpIHx8IG5ldyBEYXRlKHRoaXMuYXR0cltcIkVORC1EQVRFXCJdKTtcbiAgICAgIHVlKGkuZ2V0VGltZSgpKSAmJiAodGhpcy5fZW5kRGF0ZSA9IGkpO1xuICAgIH1cbiAgfVxuICBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0ci5JRDtcbiAgfVxuICBnZXQgY2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0ci5DTEFTUztcbiAgfVxuICBnZXQgY3VlKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLl9jdWU7XG4gICAgcmV0dXJuIGUgPT09IHZvaWQgMCA/IHRoaXMuX2N1ZSA9IHRoaXMuYXR0ci5lbnVtZXJhdGVkU3RyaW5nTGlzdCh0aGlzLmF0dHIuQ1VFID8gXCJDVUVcIiA6IFwiWC1DVUVcIiwge1xuICAgICAgcHJlOiAhMSxcbiAgICAgIHBvc3Q6ICExLFxuICAgICAgb25jZTogITFcbiAgICB9KSA6IGU7XG4gIH1cbiAgZ2V0IHN0YXJ0VGltZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICB0YWdBbmNob3I6IGVcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gZSA9PT0gbnVsbCB8fCBlLnByb2dyYW1EYXRlVGltZSA9PT0gbnVsbCA/IChydC53YXJuKGBFeHBlY3RlZCB0YWdBbmNob3IgRnJhZ21lbnQgd2l0aCBQRFQgc2V0IGZvciBEYXRlUmFuZ2UgXCIke3RoaXMuaWR9XCI6ICR7ZX1gKSwgTmFOKSA6IGUuc3RhcnQgKyAodGhpcy5zdGFydERhdGUuZ2V0VGltZSgpIC0gZS5wcm9ncmFtRGF0ZVRpbWUpIC8gMWUzO1xuICB9XG4gIGdldCBzdGFydERhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0RGF0ZTtcbiAgfVxuICBnZXQgZW5kRGF0ZSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5fZW5kRGF0ZSB8fCB0aGlzLl9kYXRlQXRFbmQ7XG4gICAgaWYgKGUpXG4gICAgICByZXR1cm4gZTtcbiAgICBjb25zdCB0ID0gdGhpcy5kdXJhdGlvbjtcbiAgICByZXR1cm4gdCAhPT0gbnVsbCA/IHRoaXMuX2RhdGVBdEVuZCA9IG5ldyBEYXRlKHRoaXMuX3N0YXJ0RGF0ZS5nZXRUaW1lKCkgKyB0ICogMWUzKSA6IG51bGw7XG4gIH1cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIGlmIChcIkRVUkFUSU9OXCIgaW4gdGhpcy5hdHRyKSB7XG4gICAgICBjb25zdCBlID0gdGhpcy5hdHRyLmRlY2ltYWxGbG9hdGluZ1BvaW50KFwiRFVSQVRJT05cIik7XG4gICAgICBpZiAodWUoZSkpXG4gICAgICAgIHJldHVybiBlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fZW5kRGF0ZSlcbiAgICAgIHJldHVybiAodGhpcy5fZW5kRGF0ZS5nZXRUaW1lKCkgLSB0aGlzLl9zdGFydERhdGUuZ2V0VGltZSgpKSAvIDFlMztcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBnZXQgcGxhbm5lZER1cmF0aW9uKCkge1xuICAgIHJldHVybiBcIlBMQU5ORUQtRFVSQVRJT05cIiBpbiB0aGlzLmF0dHIgPyB0aGlzLmF0dHIuZGVjaW1hbEZsb2F0aW5nUG9pbnQoXCJQTEFOTkVELURVUkFUSU9OXCIpIDogbnVsbDtcbiAgfVxuICBnZXQgZW5kT25OZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmF0dHIuYm9vbChcIkVORC1PTi1ORVhUXCIpO1xuICB9XG4gIGdldCBpc0ludGVyc3RpdGlhbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbGFzcyA9PT0gTWI7XG4gIH1cbiAgZ2V0IGlzVmFsaWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5pZCAmJiAhdGhpcy5fYmFkVmFsdWVGb3JTYW1lSWQgJiYgdWUodGhpcy5zdGFydERhdGUuZ2V0VGltZSgpKSAmJiAodGhpcy5kdXJhdGlvbiA9PT0gbnVsbCB8fCB0aGlzLmR1cmF0aW9uID49IDApICYmICghdGhpcy5lbmRPbk5leHQgfHwgISF0aGlzLmNsYXNzKSAmJiAoIXRoaXMuYXR0ci5DVUUgfHwgIXRoaXMuY3VlLnByZSAmJiAhdGhpcy5jdWUucG9zdCB8fCB0aGlzLmN1ZS5wcmUgIT09IHRoaXMuY3VlLnBvc3QpICYmICghdGhpcy5pc0ludGVyc3RpdGlhbCB8fCBcIlgtQVNTRVQtVVJJXCIgaW4gdGhpcy5hdHRyIHx8IFwiWC1BU1NFVC1MSVNUXCIgaW4gdGhpcy5hdHRyKTtcbiAgfVxufVxuY29uc3QgRmIgPSAxMDtcbmNsYXNzIE5iIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuUFRTS25vd24gPSAhMSwgdGhpcy5hbGlnbmVkU2xpZGluZyA9ICExLCB0aGlzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiA9IHZvaWQgMCwgdGhpcy5lbmRDQyA9IDAsIHRoaXMuZW5kU04gPSAwLCB0aGlzLmZyYWdtZW50cyA9IHZvaWQgMCwgdGhpcy5mcmFnbWVudEhpbnQgPSB2b2lkIDAsIHRoaXMucGFydExpc3QgPSBudWxsLCB0aGlzLmRhdGVSYW5nZXMgPSB2b2lkIDAsIHRoaXMuZGF0ZVJhbmdlVGFnQ291bnQgPSAwLCB0aGlzLmxpdmUgPSAhMCwgdGhpcy5yZXF1ZXN0U2NoZWR1bGVkID0gLTEsIHRoaXMuYWdlSGVhZGVyID0gMCwgdGhpcy5hZHZhbmNlZERhdGVUaW1lID0gdm9pZCAwLCB0aGlzLnVwZGF0ZWQgPSAhMCwgdGhpcy5hZHZhbmNlZCA9ICEwLCB0aGlzLm1pc3NlcyA9IDAsIHRoaXMuc3RhcnRDQyA9IDAsIHRoaXMuc3RhcnRTTiA9IDAsIHRoaXMuc3RhcnRUaW1lT2Zmc2V0ID0gbnVsbCwgdGhpcy50YXJnZXRkdXJhdGlvbiA9IDAsIHRoaXMudG90YWxkdXJhdGlvbiA9IDAsIHRoaXMudHlwZSA9IG51bGwsIHRoaXMudXJsID0gdm9pZCAwLCB0aGlzLm0zdTggPSBcIlwiLCB0aGlzLnZlcnNpb24gPSBudWxsLCB0aGlzLmNhbkJsb2NrUmVsb2FkID0gITEsIHRoaXMuY2FuU2tpcFVudGlsID0gMCwgdGhpcy5jYW5Ta2lwRGF0ZVJhbmdlcyA9ICExLCB0aGlzLnNraXBwZWRTZWdtZW50cyA9IDAsIHRoaXMucmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyA9IHZvaWQgMCwgdGhpcy5wYXJ0SG9sZEJhY2sgPSAwLCB0aGlzLmhvbGRCYWNrID0gMCwgdGhpcy5wYXJ0VGFyZ2V0ID0gMCwgdGhpcy5wcmVsb2FkSGludCA9IHZvaWQgMCwgdGhpcy5yZW5kaXRpb25SZXBvcnRzID0gdm9pZCAwLCB0aGlzLnR1bmVJbkdvYWwgPSAwLCB0aGlzLmRlbHRhVXBkYXRlRmFpbGVkID0gdm9pZCAwLCB0aGlzLmRyaWZ0U3RhcnRUaW1lID0gMCwgdGhpcy5kcmlmdEVuZFRpbWUgPSAwLCB0aGlzLmRyaWZ0U3RhcnQgPSAwLCB0aGlzLmRyaWZ0RW5kID0gMCwgdGhpcy5lbmNyeXB0ZWRGcmFnbWVudHMgPSB2b2lkIDAsIHRoaXMucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBudWxsLCB0aGlzLnZhcmlhYmxlTGlzdCA9IG51bGwsIHRoaXMuaGFzVmFyaWFibGVSZWZzID0gITEsIHRoaXMuYXBwbGllZFRpbWVsaW5lT2Zmc2V0ID0gdm9pZCAwLCB0aGlzLmZyYWdtZW50cyA9IFtdLCB0aGlzLmVuY3J5cHRlZEZyYWdtZW50cyA9IFtdLCB0aGlzLmRhdGVSYW5nZXMgPSB7fSwgdGhpcy51cmwgPSBlO1xuICB9XG4gIHJlbG9hZGVkKGUpIHtcbiAgICBpZiAoIWUpIHtcbiAgICAgIHRoaXMuYWR2YW5jZWQgPSAhMCwgdGhpcy51cGRhdGVkID0gITA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHQgPSB0aGlzLmxhc3RQYXJ0U24gLSBlLmxhc3RQYXJ0U24sIHIgPSB0aGlzLmxhc3RQYXJ0SW5kZXggLSBlLmxhc3RQYXJ0SW5kZXg7XG4gICAgdGhpcy51cGRhdGVkID0gdGhpcy5lbmRTTiAhPT0gZS5lbmRTTiB8fCAhIXIgfHwgISF0IHx8ICF0aGlzLmxpdmUsIHRoaXMuYWR2YW5jZWQgPSB0aGlzLmVuZFNOID4gZS5lbmRTTiB8fCB0ID4gMCB8fCB0ID09PSAwICYmIHIgPiAwLCB0aGlzLnVwZGF0ZWQgfHwgdGhpcy5hZHZhbmNlZCA/IHRoaXMubWlzc2VzID0gTWF0aC5mbG9vcihlLm1pc3NlcyAqIDAuNikgOiB0aGlzLm1pc3NlcyA9IGUubWlzc2VzICsgMTtcbiAgfVxuICBoYXNLZXkoZSkge1xuICAgIHJldHVybiB0aGlzLmVuY3J5cHRlZEZyYWdtZW50cy5zb21lKCh0KSA9PiB7XG4gICAgICBsZXQgciA9IHQuZGVjcnlwdGRhdGE7XG4gICAgICByZXR1cm4gciB8fCAodC5zZXRLZXlGb3JtYXQoZS5rZXlGb3JtYXQpLCByID0gdC5kZWNyeXB0ZGF0YSksICEhciAmJiBlLm1hdGNoZXMocik7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGhhc1Byb2dyYW1EYXRlVGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudHMubGVuZ3RoID8gdWUodGhpcy5mcmFnbWVudHNbdGhpcy5mcmFnbWVudHMubGVuZ3RoIC0gMV0ucHJvZ3JhbURhdGVUaW1lKSA6ICExO1xuICB9XG4gIGdldCBsZXZlbFRhcmdldER1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmF2ZXJhZ2V0YXJnZXRkdXJhdGlvbiB8fCB0aGlzLnRhcmdldGR1cmF0aW9uIHx8IEZiO1xuICB9XG4gIGdldCBkcmlmdCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5kcmlmdEVuZFRpbWUgLSB0aGlzLmRyaWZ0U3RhcnRUaW1lO1xuICAgIHJldHVybiBlID4gMCA/ICh0aGlzLmRyaWZ0RW5kIC0gdGhpcy5kcmlmdFN0YXJ0KSAqIDFlMyAvIGUgOiAxO1xuICB9XG4gIGdldCBlZGdlKCkge1xuICAgIHJldHVybiB0aGlzLnBhcnRFbmQgfHwgdGhpcy5mcmFnbWVudEVuZDtcbiAgfVxuICBnZXQgcGFydEVuZCgpIHtcbiAgICB2YXIgZTtcbiAgICByZXR1cm4gKGUgPSB0aGlzLnBhcnRMaXN0KSAhPSBudWxsICYmIGUubGVuZ3RoID8gdGhpcy5wYXJ0TGlzdFt0aGlzLnBhcnRMaXN0Lmxlbmd0aCAtIDFdLmVuZCA6IHRoaXMuZnJhZ21lbnRFbmQ7XG4gIH1cbiAgZ2V0IGZyYWdtZW50RW5kKCkge1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50cy5sZW5ndGggPyB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdtZW50cy5sZW5ndGggLSAxXS5lbmQgOiAwO1xuICB9XG4gIGdldCBmcmFnbWVudFN0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50cy5sZW5ndGggPyB0aGlzLmZyYWdtZW50c1swXS5zdGFydCA6IDA7XG4gIH1cbiAgZ2V0IGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hZHZhbmNlZERhdGVUaW1lID8gTWF0aC5tYXgoRGF0ZS5ub3coKSAtIHRoaXMuYWR2YW5jZWREYXRlVGltZSwgMCkgLyAxZTMgOiAwO1xuICB9XG4gIGdldCBsYXN0UGFydEluZGV4KCkge1xuICAgIHZhciBlO1xuICAgIHJldHVybiAoZSA9IHRoaXMucGFydExpc3QpICE9IG51bGwgJiYgZS5sZW5ndGggPyB0aGlzLnBhcnRMaXN0W3RoaXMucGFydExpc3QubGVuZ3RoIC0gMV0uaW5kZXggOiAtMTtcbiAgfVxuICBnZXQgbWF4UGFydEluZGV4KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnBhcnRMaXN0O1xuICAgIGlmIChlKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5sYXN0UGFydEluZGV4O1xuICAgICAgaWYgKHQgIT09IC0xKSB7XG4gICAgICAgIGZvciAobGV0IHIgPSBlLmxlbmd0aDsgci0tOyApXG4gICAgICAgICAgaWYgKGVbcl0uaW5kZXggPiB0KVxuICAgICAgICAgICAgcmV0dXJuIGVbcl0uaW5kZXg7XG4gICAgICAgIHJldHVybiB0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXQgbGFzdFBhcnRTbigpIHtcbiAgICB2YXIgZTtcbiAgICByZXR1cm4gKGUgPSB0aGlzLnBhcnRMaXN0KSAhPSBudWxsICYmIGUubGVuZ3RoID8gdGhpcy5wYXJ0TGlzdFt0aGlzLnBhcnRMaXN0Lmxlbmd0aCAtIDFdLmZyYWdtZW50LnNuIDogdGhpcy5lbmRTTjtcbiAgfVxuICBnZXQgZXhwaXJlZCgpIHtcbiAgICBpZiAodGhpcy5saXZlICYmIHRoaXMuYWdlICYmIHRoaXMubWlzc2VzIDwgMykge1xuICAgICAgY29uc3QgZSA9IHRoaXMucGFydEVuZCAtIHRoaXMuZnJhZ21lbnRTdGFydDtcbiAgICAgIHJldHVybiB0aGlzLmFnZSA+IE1hdGgubWF4KGUsIHRoaXMudG90YWxkdXJhdGlvbikgKyB0aGlzLmxldmVsVGFyZ2V0RHVyYXRpb247XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxufVxuZnVuY3Rpb24geHUocywgZSkge1xuICByZXR1cm4gcy5sZW5ndGggPT09IGUubGVuZ3RoID8gIXMuc29tZSgodCwgcikgPT4gdCAhPT0gZVtyXSkgOiAhMTtcbn1cbmZ1bmN0aW9uIGJoKHMsIGUpIHtcbiAgcmV0dXJuICFzICYmICFlID8gITAgOiAhcyB8fCAhZSA/ICExIDogeHUocywgZSk7XG59XG5mdW5jdGlvbiBJbihzKSB7XG4gIHJldHVybiBzID09PSBcIkFFUy0xMjhcIiB8fCBzID09PSBcIkFFUy0yNTZcIiB8fCBzID09PSBcIkFFUy0yNTYtQ1RSXCI7XG59XG5mdW5jdGlvbiBTdShzKSB7XG4gIHN3aXRjaCAocykge1xuICAgIGNhc2UgXCJBRVMtMTI4XCI6XG4gICAgY2FzZSBcIkFFUy0yNTZcIjpcbiAgICAgIHJldHVybiBPcy5jYmM7XG4gICAgY2FzZSBcIkFFUy0yNTYtQ1RSXCI6XG4gICAgICByZXR1cm4gT3MuY3RyO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgZnVsbCBzZWdtZW50IG1ldGhvZCAke3N9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJ1KHMpIHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhdG9iKHMpLCAoZSkgPT4gZS5jaGFyQ29kZUF0KDApKTtcbn1cbmZ1bmN0aW9uIGhjKHMpIHtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQocykpLCAoZSkgPT4gZS5jaGFyQ29kZUF0KDApKTtcbn1cbmZ1bmN0aW9uIFViKHMpIHtcbiAgY29uc3QgZSA9IGhjKHMpLnN1YmFycmF5KDAsIDE2KSwgdCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbiAgcmV0dXJuIHQuc2V0KGUsIDE2IC0gZS5sZW5ndGgpLCB0O1xufVxuZnVuY3Rpb24gemcocykge1xuICBjb25zdCBlID0gZnVuY3Rpb24ociwgbiwgaSkge1xuICAgIGNvbnN0IG8gPSByW25dO1xuICAgIHJbbl0gPSByW2ldLCByW2ldID0gbztcbiAgfTtcbiAgZShzLCAwLCAzKSwgZShzLCAxLCAyKSwgZShzLCA0LCA1KSwgZShzLCA2LCA3KTtcbn1cbmZ1bmN0aW9uICRiKHMpIHtcbiAgY29uc3QgZSA9IHMuc3BsaXQoXCI6XCIpO1xuICBsZXQgdCA9IG51bGw7XG4gIGlmIChlWzBdID09PSBcImRhdGFcIiAmJiBlLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IHIgPSBlWzFdLnNwbGl0KFwiO1wiKSwgbiA9IHJbci5sZW5ndGggLSAxXS5zcGxpdChcIixcIik7XG4gICAgaWYgKG4ubGVuZ3RoID09PSAyKSB7XG4gICAgICBjb25zdCBpID0gblswXSA9PT0gXCJiYXNlNjRcIiwgbyA9IG5bMV07XG4gICAgICBpID8gKHIuc3BsaWNlKC0xLCAxKSwgdCA9IGJ1KG8pKSA6IHQgPSBVYihvKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5jb25zdCByYSA9IHR5cGVvZiBzZWxmIDwgXCJ1XCIgPyBzZWxmIDogdm9pZCAwO1xudmFyIG10ID0ge1xuICBDTEVBUktFWTogXCJvcmcudzMuY2xlYXJrZXlcIixcbiAgRkFJUlBMQVk6IFwiY29tLmFwcGxlLmZwc1wiLFxuICBQTEFZUkVBRFk6IFwiY29tLm1pY3Jvc29mdC5wbGF5cmVhZHlcIixcbiAgV0lERVZJTkU6IFwiY29tLndpZGV2aW5lLmFscGhhXCJcbn0sIGxyID0ge1xuICBDTEVBUktFWTogXCJvcmcudzMuY2xlYXJrZXlcIixcbiAgRkFJUlBMQVk6IFwiY29tLmFwcGxlLnN0cmVhbWluZ2tleWRlbGl2ZXJ5XCIsXG4gIFBMQVlSRUFEWTogXCJjb20ubWljcm9zb2Z0LnBsYXlyZWFkeVwiLFxuICBXSURFVklORTogXCJ1cm46dXVpZDplZGVmOGJhOS03OWQ2LTRhY2UtYTNjOC0yN2RjZDUxZDIxZWRcIlxufTtcbmZ1bmN0aW9uIHBvKHMpIHtcbiAgc3dpdGNoIChzKSB7XG4gICAgY2FzZSBsci5GQUlSUExBWTpcbiAgICAgIHJldHVybiBtdC5GQUlSUExBWTtcbiAgICBjYXNlIGxyLlBMQVlSRUFEWTpcbiAgICAgIHJldHVybiBtdC5QTEFZUkVBRFk7XG4gICAgY2FzZSBsci5XSURFVklORTpcbiAgICAgIHJldHVybiBtdC5XSURFVklORTtcbiAgICBjYXNlIGxyLkNMRUFSS0VZOlxuICAgICAgcmV0dXJuIG10LkNMRUFSS0VZO1xuICB9XG59XG5mdW5jdGlvbiBmbChzKSB7XG4gIHN3aXRjaCAocykge1xuICAgIGNhc2UgbXQuRkFJUlBMQVk6XG4gICAgICByZXR1cm4gbHIuRkFJUlBMQVk7XG4gICAgY2FzZSBtdC5QTEFZUkVBRFk6XG4gICAgICByZXR1cm4gbHIuUExBWVJFQURZO1xuICAgIGNhc2UgbXQuV0lERVZJTkU6XG4gICAgICByZXR1cm4gbHIuV0lERVZJTkU7XG4gICAgY2FzZSBtdC5DTEVBUktFWTpcbiAgICAgIHJldHVybiBsci5DTEVBUktFWTtcbiAgfVxufVxuZnVuY3Rpb24gem4ocykge1xuICBjb25zdCB7XG4gICAgZHJtU3lzdGVtczogZSxcbiAgICB3aWRldmluZUxpY2Vuc2VVcmw6IHRcbiAgfSA9IHMsIHIgPSBlID8gW210LkZBSVJQTEFZLCBtdC5XSURFVklORSwgbXQuUExBWVJFQURZLCBtdC5DTEVBUktFWV0uZmlsdGVyKChuKSA9PiAhIWVbbl0pIDogW107XG4gIHJldHVybiAhclttdC5XSURFVklORV0gJiYgdCAmJiByLnB1c2gobXQuV0lERVZJTkUpLCByO1xufVxuY29uc3QgWWcgPSAoZnVuY3Rpb24ocykge1xuICByZXR1cm4gcmEgIT0gbnVsbCAmJiAocyA9IHJhLm5hdmlnYXRvcikgIT0gbnVsbCAmJiBzLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyA/IHNlbGYubmF2aWdhdG9yLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzcy5iaW5kKHNlbGYubmF2aWdhdG9yKSA6IG51bGw7XG59KSgpO1xuZnVuY3Rpb24gR2IocywgZSwgdCwgcikge1xuICBsZXQgbjtcbiAgc3dpdGNoIChzKSB7XG4gICAgY2FzZSBtdC5GQUlSUExBWTpcbiAgICAgIG4gPSBbXCJjZW5jXCIsIFwic2luZlwiXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgbXQuV0lERVZJTkU6XG4gICAgY2FzZSBtdC5QTEFZUkVBRFk6XG4gICAgICBuID0gW1wiY2VuY1wiXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgbXQuQ0xFQVJLRVk6XG4gICAgICBuID0gW1wiY2VuY1wiLCBcImtleWlkc1wiXTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24ga2V5LXN5c3RlbTogJHtzfWApO1xuICB9XG4gIHJldHVybiBWYihuLCBlLCB0LCByKTtcbn1cbmZ1bmN0aW9uIFZiKHMsIGUsIHQsIHIpIHtcbiAgcmV0dXJuIFt7XG4gICAgaW5pdERhdGFUeXBlczogcyxcbiAgICBwZXJzaXN0ZW50U3RhdGU6IHIucGVyc2lzdGVudFN0YXRlIHx8IFwib3B0aW9uYWxcIixcbiAgICBkaXN0aW5jdGl2ZUlkZW50aWZpZXI6IHIuZGlzdGluY3RpdmVJZGVudGlmaWVyIHx8IFwib3B0aW9uYWxcIixcbiAgICBzZXNzaW9uVHlwZXM6IHIuc2Vzc2lvblR5cGVzIHx8IFtyLnNlc3Npb25UeXBlIHx8IFwidGVtcG9yYXJ5XCJdLFxuICAgIGF1ZGlvQ2FwYWJpbGl0aWVzOiBlLm1hcCgoaSkgPT4gKHtcbiAgICAgIGNvbnRlbnRUeXBlOiBgYXVkaW8vbXA0OyBjb2RlY3M9JHtpfWAsXG4gICAgICByb2J1c3RuZXNzOiByLmF1ZGlvUm9idXN0bmVzcyB8fCBcIlwiLFxuICAgICAgZW5jcnlwdGlvblNjaGVtZTogci5hdWRpb0VuY3J5cHRpb25TY2hlbWUgfHwgbnVsbFxuICAgIH0pKSxcbiAgICB2aWRlb0NhcGFiaWxpdGllczogdC5tYXAoKGkpID0+ICh7XG4gICAgICBjb250ZW50VHlwZTogYHZpZGVvL21wNDsgY29kZWNzPSR7aX1gLFxuICAgICAgcm9idXN0bmVzczogci52aWRlb1JvYnVzdG5lc3MgfHwgXCJcIixcbiAgICAgIGVuY3J5cHRpb25TY2hlbWU6IHIudmlkZW9FbmNyeXB0aW9uU2NoZW1lIHx8IG51bGxcbiAgICB9KSlcbiAgfV07XG59XG5mdW5jdGlvbiBqYihzKSB7XG4gIHZhciBlO1xuICByZXR1cm4gISFzICYmIChzLnNlc3Npb25UeXBlID09PSBcInBlcnNpc3RlbnQtbGljZW5zZVwiIHx8ICEhKChlID0gcy5zZXNzaW9uVHlwZXMpICE9IG51bGwgJiYgZS5zb21lKCh0KSA9PiB0ID09PSBcInBlcnNpc3RlbnQtbGljZW5zZVwiKSkpO1xufVxuZnVuY3Rpb24gS2Iocykge1xuICBjb25zdCBlID0gbmV3IFVpbnQxNkFycmF5KHMuYnVmZmVyLCBzLmJ5dGVPZmZzZXQsIHMuYnl0ZUxlbmd0aCAvIDIpLCB0ID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBBcnJheS5mcm9tKGUpKSwgciA9IHQuc3Vic3RyaW5nKHQuaW5kZXhPZihcIjxcIiksIHQubGVuZ3RoKSwgbyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcociwgXCJ0ZXh0L3htbFwiKS5nZXRFbGVtZW50c0J5VGFnTmFtZShcIktJRFwiKVswXTtcbiAgaWYgKG8pIHtcbiAgICBjb25zdCBhID0gby5jaGlsZE5vZGVzWzBdID8gby5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSA6IG8uZ2V0QXR0cmlidXRlKFwiVkFMVUVcIik7XG4gICAgaWYgKGEpIHtcbiAgICAgIGNvbnN0IGwgPSBidShhKS5zdWJhcnJheSgwLCAxNik7XG4gICAgICByZXR1cm4gemcobCksIGw7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxubGV0IFdpID0ge307XG5jbGFzcyB5aSB7XG4gIHN0YXRpYyBjbGVhcktleVVyaVRvS2V5SWRNYXAoKSB7XG4gICAgV2kgPSB7fTtcbiAgfVxuICBzdGF0aWMgc2V0S2V5SWRGb3JVcmkoZSwgdCkge1xuICAgIFdpW2VdID0gdDtcbiAgfVxuICBjb25zdHJ1Y3RvcihlLCB0LCByLCBuID0gWzFdLCBpID0gbnVsbCwgbykge1xuICAgIHRoaXMudXJpID0gdm9pZCAwLCB0aGlzLm1ldGhvZCA9IHZvaWQgMCwgdGhpcy5rZXlGb3JtYXQgPSB2b2lkIDAsIHRoaXMua2V5Rm9ybWF0VmVyc2lvbnMgPSB2b2lkIDAsIHRoaXMuZW5jcnlwdGVkID0gdm9pZCAwLCB0aGlzLmlzQ29tbW9uRW5jcnlwdGlvbiA9IHZvaWQgMCwgdGhpcy5pdiA9IG51bGwsIHRoaXMua2V5ID0gbnVsbCwgdGhpcy5rZXlJZCA9IG51bGwsIHRoaXMucHNzaCA9IG51bGwsIHRoaXMubWV0aG9kID0gZSwgdGhpcy51cmkgPSB0LCB0aGlzLmtleUZvcm1hdCA9IHIsIHRoaXMua2V5Rm9ybWF0VmVyc2lvbnMgPSBuLCB0aGlzLml2ID0gaSwgdGhpcy5lbmNyeXB0ZWQgPSBlID8gZSAhPT0gXCJOT05FXCIgOiAhMSwgdGhpcy5pc0NvbW1vbkVuY3J5cHRpb24gPSB0aGlzLmVuY3J5cHRlZCAmJiAhSW4oZSksIG8gIT0gbnVsbCAmJiBvLnN0YXJ0c1dpdGgoXCIweFwiKSAmJiAodGhpcy5rZXlJZCA9IG5ldyBVaW50OEFycmF5KElnKG8pKSk7XG4gIH1cbiAgbWF0Y2hlcyhlKSB7XG4gICAgcmV0dXJuIGUudXJpID09PSB0aGlzLnVyaSAmJiBlLm1ldGhvZCA9PT0gdGhpcy5tZXRob2QgJiYgZS5lbmNyeXB0ZWQgPT09IHRoaXMuZW5jcnlwdGVkICYmIGUua2V5Rm9ybWF0ID09PSB0aGlzLmtleUZvcm1hdCAmJiB4dShlLmtleUZvcm1hdFZlcnNpb25zLCB0aGlzLmtleUZvcm1hdFZlcnNpb25zKSAmJiBiaChlLml2LCB0aGlzLml2KSAmJiBiaChlLmtleUlkLCB0aGlzLmtleUlkKTtcbiAgfVxuICBpc1N1cHBvcnRlZCgpIHtcbiAgICBpZiAodGhpcy5tZXRob2QpIHtcbiAgICAgIGlmIChJbih0aGlzLm1ldGhvZCkgfHwgdGhpcy5tZXRob2QgPT09IFwiTk9ORVwiKVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICBpZiAodGhpcy5rZXlGb3JtYXQgPT09IFwiaWRlbnRpdHlcIilcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0aG9kID09PSBcIlNBTVBMRS1BRVNcIjtcbiAgICAgIHN3aXRjaCAodGhpcy5rZXlGb3JtYXQpIHtcbiAgICAgICAgY2FzZSBsci5GQUlSUExBWTpcbiAgICAgICAgY2FzZSBsci5XSURFVklORTpcbiAgICAgICAgY2FzZSBsci5QTEFZUkVBRFk6XG4gICAgICAgIGNhc2UgbHIuQ0xFQVJLRVk6XG4gICAgICAgICAgcmV0dXJuIFtcIlNBTVBMRS1BRVNcIiwgXCJTQU1QTEUtQUVTLUNFTkNcIiwgXCJTQU1QTEUtQUVTLUNUUlwiXS5pbmRleE9mKHRoaXMubWV0aG9kKSAhPT0gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBnZXREZWNyeXB0RGF0YShlKSB7XG4gICAgaWYgKCF0aGlzLmVuY3J5cHRlZCB8fCAhdGhpcy51cmkpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoSW4odGhpcy5tZXRob2QpKSB7XG4gICAgICBsZXQgbiA9IHRoaXMuaXY7XG4gICAgICByZXR1cm4gbiB8fCAodHlwZW9mIGUgIT0gXCJudW1iZXJcIiAmJiAocnQud2FybihgbWlzc2luZyBJViBmb3IgaW5pdGlhbGl6YXRpb24gc2VnbWVudCB3aXRoIG1ldGhvZD1cIiR7dGhpcy5tZXRob2R9XCIgLSBjb21wbGlhbmNlIGlzc3VlYCksIGUgPSAwKSwgbiA9IEhiKGUpKSwgbmV3IHlpKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgXCJpZGVudGl0eVwiLCB0aGlzLmtleUZvcm1hdFZlcnNpb25zLCBuKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucHNzaCAmJiB0aGlzLmtleUlkKVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgY29uc3QgdCA9ICRiKHRoaXMudXJpKTtcbiAgICBpZiAodClcbiAgICAgIHN3aXRjaCAodGhpcy5rZXlGb3JtYXQpIHtcbiAgICAgICAgY2FzZSBsci5XSURFVklORTpcbiAgICAgICAgICBpZiAodGhpcy5wc3NoID0gdCwgIXRoaXMua2V5SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBXUyh0LmJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAobi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgdmFyIHI7XG4gICAgICAgICAgICAgIGNvbnN0IGkgPSBuWzBdO1xuICAgICAgICAgICAgICB0aGlzLmtleUlkID0gKHIgPSBpLmtpZHMpICE9IG51bGwgJiYgci5sZW5ndGggPyBpLmtpZHNbMF0gOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMua2V5SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSB0Lmxlbmd0aCAtIDIyO1xuICAgICAgICAgICAgdGhpcy5rZXlJZCA9IHQuc3ViYXJyYXkobiwgbiArIDE2KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgbHIuUExBWVJFQURZOiB7XG4gICAgICAgICAgY29uc3QgbiA9IG5ldyBVaW50OEFycmF5KFsxNTQsIDQsIDI0MCwgMTIxLCAxNTIsIDY0LCA2NiwgMTM0LCAxNzEsIDE0NiwgMjMwLCA5MSwgMjI0LCAxMzYsIDk1LCAxNDldKTtcbiAgICAgICAgICB0aGlzLnBzc2ggPSBxUyhuLCBudWxsLCB0KSwgdGhpcy5rZXlJZCA9IEtiKHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBsZXQgbiA9IHQuc3ViYXJyYXkoMCwgMTYpO1xuICAgICAgICAgIGlmIChuLmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgICAgICBpLnNldChuLCAxNiAtIG4ubGVuZ3RoKSwgbiA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMua2V5SWQgPSBuO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgaWYgKCF0aGlzLmtleUlkIHx8IHRoaXMua2V5SWQuYnl0ZUxlbmd0aCAhPT0gMTYpIHtcbiAgICAgIGxldCBuID0gV2lbdGhpcy51cmldO1xuICAgICAgaWYgKCFuKSB7XG4gICAgICAgIGNvbnN0IGkgPSBPYmplY3Qua2V5cyhXaSkubGVuZ3RoICUgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICAgIG4gPSBuZXcgVWludDhBcnJheSgxNiksIG5ldyBEYXRhVmlldyhuLmJ1ZmZlciwgMTIsIDQpLnNldFVpbnQzMigwLCBpKSwgeWkuc2V0S2V5SWRGb3JVcmkodGhpcy51cmksIG4pO1xuICAgICAgfVxuICAgICAgdGhpcy5rZXlJZCA9IG47XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG5mdW5jdGlvbiBIYihzKSB7XG4gIGNvbnN0IGUgPSBuZXcgVWludDhBcnJheSgxNik7XG4gIGZvciAobGV0IHQgPSAxMjsgdCA8IDE2OyB0KyspXG4gICAgZVt0XSA9IHMgPj4gOCAqICgxNSAtIHQpICYgMjU1O1xuICByZXR1cm4gZTtcbn1cbmNvbnN0IFRoID0gLyNFWFQtWC1TVFJFQU0tSU5GOihbXlxcclxcbl0qKSg/OltcXHJcXG5dKD86I1teXFxyXFxuXSopPykqKFteXFxyXFxuXSspfCNFWFQtWC0oU0VTU0lPTi1EQVRBfFNFU1NJT04tS0VZfERFRklORXxDT05URU5ULVNURUVSSU5HfFNUQVJUKTooW15cXHJcXG5dKilbXFxyXFxuXSsvZywgd2ggPSAvI0VYVC1YLU1FRElBOiguKikvZywgcWIgPSAvXiNFWFQoPzpJTkZ8LVgtVEFSR0VURFVSQVRJT04pOi9tLCBnbCA9IG5ldyBSZWdFeHAoW1xuICAvI0VYVElORjpcXHMqKFxcZCooPzpcXC5cXGQrKT8pKD86LCguKilcXHMrKT8vLnNvdXJjZSxcbiAgLy8gZHVyYXRpb24gKCNFWFRJTkY6PGR1cmF0aW9uPiw8dGl0bGU+KSwgZ3JvdXAgMSA9PiBkdXJhdGlvbiwgZ3JvdXAgMiA9PiB0aXRsZVxuICAvKD8hIykgKihcXFNbXlxcclxcbl0qKS8uc291cmNlLFxuICAvLyBzZWdtZW50IFVSSSwgZ3JvdXAgMyA9PiB0aGUgVVJJIChub3RlIG5ld2xpbmUgaXMgbm90IGVhdGVuKVxuICAvIy4qLy5zb3VyY2VcbiAgLy8gQWxsIG90aGVyIG5vbi1zZWdtZW50IG9yaWVudGVkIHRhZ3Mgd2lsbCBtYXRjaCB3aXRoIGFsbCBncm91cHMgZW1wdHlcbl0uam9pbihcInxcIiksIFwiZ1wiKSwgV2IgPSBuZXcgUmVnRXhwKFsvI0VYVC1YLShQUk9HUkFNLURBVEUtVElNRXxCWVRFUkFOR0V8REFURVJBTkdFfERFRklORXxLRVl8TUFQfFBBUlR8UEFSVC1JTkZ8UExBWUxJU1QtVFlQRXxQUkVMT0FELUhJTlR8UkVORElUSU9OLVJFUE9SVHxTRVJWRVItQ09OVFJPTHxTS0lQfFNUQVJUKTooLispLy5zb3VyY2UsIC8jRVhULVgtKEJJVFJBVEV8RElTQ09OVElOVUlUWS1TRVFVRU5DRXxNRURJQS1TRVFVRU5DRXxUQVJHRVREVVJBVElPTnxWRVJTSU9OKTogKihcXGQrKS8uc291cmNlLCAvI0VYVC1YLShESVNDT05USU5VSVRZfEVORExJU1R8R0FQfElOREVQRU5ERU5ULVNFR01FTlRTKS8uc291cmNlLCAvKCMpKFteOl0qKTooLiopLy5zb3VyY2UsIC8oIykoLiopKD86LiopXFxyP1xcbj8vLnNvdXJjZV0uam9pbihcInxcIikpO1xuY2xhc3MgenIge1xuICBzdGF0aWMgZmluZEdyb3VwKGUsIHQpIHtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IGUubGVuZ3RoOyByKyspIHtcbiAgICAgIGNvbnN0IG4gPSBlW3JdO1xuICAgICAgaWYgKG4uaWQgPT09IHQpXG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgcmVzb2x2ZShlLCB0KSB7XG4gICAgcmV0dXJuIGh1LmJ1aWxkQWJzb2x1dGVVUkwodCwgZSwge1xuICAgICAgYWx3YXlzTm9ybWFsaXplOiAhMFxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBpc01lZGlhUGxheWxpc3QoZSkge1xuICAgIHJldHVybiBxYi50ZXN0KGUpO1xuICB9XG4gIHN0YXRpYyBwYXJzZU1hc3RlclBsYXlsaXN0KGUsIHQpIHtcbiAgICBjb25zdCByID0gRWgoZSksIG4gPSB7XG4gICAgICBjb250ZW50U3RlZXJpbmc6IG51bGwsXG4gICAgICBsZXZlbHM6IFtdLFxuICAgICAgcGxheWxpc3RQYXJzaW5nRXJyb3I6IG51bGwsXG4gICAgICBzZXNzaW9uRGF0YTogbnVsbCxcbiAgICAgIHNlc3Npb25LZXlzOiBudWxsLFxuICAgICAgc3RhcnRUaW1lT2Zmc2V0OiBudWxsLFxuICAgICAgdmFyaWFibGVMaXN0OiBudWxsLFxuICAgICAgaGFzVmFyaWFibGVSZWZzOiByXG4gICAgfSwgaSA9IFtdO1xuICAgIGlmIChUaC5sYXN0SW5kZXggPSAwLCAhZS5zdGFydHNXaXRoKFwiI0VYVE0zVVwiKSlcbiAgICAgIHJldHVybiBuLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKFwibm8gRVhUTTNVIGRlbGltaXRlclwiKSwgbjtcbiAgICBsZXQgbztcbiAgICBmb3IgKDsgKG8gPSBUaC5leGVjKGUpKSAhPSBudWxsOyApXG4gICAgICBpZiAob1sxXSkge1xuICAgICAgICB2YXIgYTtcbiAgICAgICAgY29uc3QgYyA9IG5ldyBndChvWzFdLCBuKSwgdSA9IGRjKG4sIG9bMl0pLCBkID0ge1xuICAgICAgICAgIGF0dHJzOiBjLFxuICAgICAgICAgIGJpdHJhdGU6IGMuZGVjaW1hbEludGVnZXIoXCJCQU5EV0lEVEhcIikgfHwgYy5kZWNpbWFsSW50ZWdlcihcIkFWRVJBR0UtQkFORFdJRFRIXCIpLFxuICAgICAgICAgIG5hbWU6IGMuTkFNRSxcbiAgICAgICAgICB1cmw6IHpyLnJlc29sdmUodSwgdClcbiAgICAgICAgfSwgaCA9IGMuZGVjaW1hbFJlc29sdXRpb24oXCJSRVNPTFVUSU9OXCIpO1xuICAgICAgICBoICYmIChkLndpZHRoID0gaC53aWR0aCwgZC5oZWlnaHQgPSBoLmhlaWdodCksIF9oKGMuQ09ERUNTLCBkKTtcbiAgICAgICAgY29uc3QgZiA9IGNbXCJTVVBQTEVNRU5UQUwtQ09ERUNTXCJdO1xuICAgICAgICBmICYmIChkLnN1cHBsZW1lbnRhbCA9IHt9LCBfaChmLCBkLnN1cHBsZW1lbnRhbCkpLCAoYSA9IGQudW5rbm93bkNvZGVjcykgIT0gbnVsbCAmJiBhLmxlbmd0aCB8fCBpLnB1c2goZCksIG4ubGV2ZWxzLnB1c2goZCk7XG4gICAgICB9IGVsc2UgaWYgKG9bM10pIHtcbiAgICAgICAgY29uc3QgYyA9IG9bM10sIHUgPSBvWzRdO1xuICAgICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgICBjYXNlIFwiU0VTU0lPTi1EQVRBXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBuZXcgZ3QodSwgbiksIGggPSBkW1wiREFUQS1JRFwiXTtcbiAgICAgICAgICAgIGggJiYgKG4uc2Vzc2lvbkRhdGEgPT09IG51bGwgJiYgKG4uc2Vzc2lvbkRhdGEgPSB7fSksIG4uc2Vzc2lvbkRhdGFbaF0gPSBkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiU0VTU0lPTi1LRVlcIjoge1xuICAgICAgICAgICAgY29uc3QgZCA9IEFoKHUsIHQsIG4pO1xuICAgICAgICAgICAgZC5lbmNyeXB0ZWQgJiYgZC5pc1N1cHBvcnRlZCgpID8gKG4uc2Vzc2lvbktleXMgPT09IG51bGwgJiYgKG4uc2Vzc2lvbktleXMgPSBbXSksIG4uc2Vzc2lvbktleXMucHVzaChkKSkgOiBydC53YXJuKGBbS2V5c10gSWdub3JpbmcgaW52YWxpZCBFWFQtWC1TRVNTSU9OLUtFWSB0YWc6IFwiJHt1fVwiYCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIkRFRklORVwiOiB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGQgPSBuZXcgZ3QodSwgbik7XG4gICAgICAgICAgICAgIHhoKG4sIGQsIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJDT05URU5ULVNURUVSSU5HXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBuZXcgZ3QodSwgbik7XG4gICAgICAgICAgICBuLmNvbnRlbnRTdGVlcmluZyA9IHtcbiAgICAgICAgICAgICAgdXJpOiB6ci5yZXNvbHZlKGRbXCJTRVJWRVItVVJJXCJdLCB0KSxcbiAgICAgICAgICAgICAgcGF0aHdheUlkOiBkW1wiUEFUSFdBWS1JRFwiXSB8fCBcIi5cIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiU1RBUlRcIjoge1xuICAgICAgICAgICAgbi5zdGFydFRpbWVPZmZzZXQgPSBJaCh1KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIGNvbnN0IGwgPSBpLmxlbmd0aCA+IDAgJiYgaS5sZW5ndGggPCBuLmxldmVscy5sZW5ndGg7XG4gICAgcmV0dXJuIG4ubGV2ZWxzID0gbCA/IGkgOiBuLmxldmVscywgbi5sZXZlbHMubGVuZ3RoID09PSAwICYmIChuLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKFwibm8gbGV2ZWxzIGZvdW5kIGluIG1hbmlmZXN0XCIpKSwgbjtcbiAgfVxuICBzdGF0aWMgcGFyc2VNYXN0ZXJQbGF5bGlzdE1lZGlhKGUsIHQsIHIpIHtcbiAgICBsZXQgbjtcbiAgICBjb25zdCBpID0ge30sIG8gPSByLmxldmVscywgYSA9IHtcbiAgICAgIEFVRElPOiBvLm1hcCgoYykgPT4gKHtcbiAgICAgICAgaWQ6IGMuYXR0cnMuQVVESU8sXG4gICAgICAgIGF1ZGlvQ29kZWM6IGMuYXVkaW9Db2RlY1xuICAgICAgfSkpLFxuICAgICAgU1VCVElUTEVTOiBvLm1hcCgoYykgPT4gKHtcbiAgICAgICAgaWQ6IGMuYXR0cnMuU1VCVElUTEVTLFxuICAgICAgICB0ZXh0Q29kZWM6IGMudGV4dENvZGVjXG4gICAgICB9KSksXG4gICAgICBcIkNMT1NFRC1DQVBUSU9OU1wiOiBbXVxuICAgIH07XG4gICAgbGV0IGwgPSAwO1xuICAgIGZvciAod2gubGFzdEluZGV4ID0gMDsgKG4gPSB3aC5leGVjKGUpKSAhPT0gbnVsbDsgKSB7XG4gICAgICBjb25zdCBjID0gbmV3IGd0KG5bMV0sIHIpLCB1ID0gYy5UWVBFO1xuICAgICAgaWYgKHUpIHtcbiAgICAgICAgY29uc3QgZCA9IGFbdV0sIGggPSBpW3VdIHx8IFtdO1xuICAgICAgICBpW3VdID0gaDtcbiAgICAgICAgY29uc3QgZiA9IGMuTEFOR1VBR0UsIHAgPSBjW1wiQVNTT0MtTEFOR1VBR0VcIl0sIHkgPSBjLkNIQU5ORUxTLCBFID0gYy5DSEFSQUNURVJJU1RJQ1MsIGIgPSBjW1wiSU5TVFJFQU0tSURcIl0sIFIgPSB7XG4gICAgICAgICAgYXR0cnM6IGMsXG4gICAgICAgICAgYml0cmF0ZTogMCxcbiAgICAgICAgICBpZDogbCsrLFxuICAgICAgICAgIGdyb3VwSWQ6IGNbXCJHUk9VUC1JRFwiXSB8fCBcIlwiLFxuICAgICAgICAgIG5hbWU6IGMuTkFNRSB8fCBmIHx8IFwiXCIsXG4gICAgICAgICAgdHlwZTogdSxcbiAgICAgICAgICBkZWZhdWx0OiBjLmJvb2woXCJERUZBVUxUXCIpLFxuICAgICAgICAgIGF1dG9zZWxlY3Q6IGMuYm9vbChcIkFVVE9TRUxFQ1RcIiksXG4gICAgICAgICAgZm9yY2VkOiBjLmJvb2woXCJGT1JDRURcIiksXG4gICAgICAgICAgbGFuZzogZixcbiAgICAgICAgICB1cmw6IGMuVVJJID8genIucmVzb2x2ZShjLlVSSSwgdCkgOiBcIlwiXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwICYmIChSLmFzc29jTGFuZyA9IHApLCB5ICYmIChSLmNoYW5uZWxzID0geSksIEUgJiYgKFIuY2hhcmFjdGVyaXN0aWNzID0gRSksIGIgJiYgKFIuaW5zdHJlYW1JZCA9IGIpLCBkICE9IG51bGwgJiYgZC5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCBBID0genIuZmluZEdyb3VwKGQsIFIuZ3JvdXBJZCkgfHwgZFswXTtcbiAgICAgICAgICBSaChSLCBBLCBcImF1ZGlvQ29kZWNcIiksIFJoKFIsIEEsIFwidGV4dENvZGVjXCIpO1xuICAgICAgICB9XG4gICAgICAgIGgucHVzaChSKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgc3RhdGljIHBhcnNlTGV2ZWxQbGF5bGlzdChlLCB0LCByLCBuLCBpLCBvKSB7XG4gICAgdmFyIGE7XG4gICAgY29uc3QgbCA9IHtcbiAgICAgIHVybDogdFxuICAgIH0sIGMgPSBuZXcgTmIodCksIHUgPSBjLmZyYWdtZW50cywgZCA9IFtdO1xuICAgIGxldCBoID0gbnVsbCwgZiA9IDAsIHAgPSAwLCB5ID0gMCwgRSA9IDAsIGIgPSAwLCBSID0gbnVsbCwgQSA9IG5ldyB1bChuLCBsKSwgRiwgTSwgSCwgSyA9IC0xLCBqID0gITEsIEMgPSBudWxsLCBrO1xuICAgIGlmIChnbC5sYXN0SW5kZXggPSAwLCBjLm0zdTggPSBlLCBjLmhhc1ZhcmlhYmxlUmVmcyA9IEVoKGUpLCAoKGEgPSBnbC5leGVjKGUpKSA9PSBudWxsID8gdm9pZCAwIDogYVswXSkgIT09IFwiI0VYVE0zVVwiKVxuICAgICAgcmV0dXJuIGMucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoXCJNaXNzaW5nIGZvcm1hdCBpZGVudGlmaWVyICNFWFRNM1VcIiksIGM7XG4gICAgZm9yICg7IChGID0gZ2wuZXhlYyhlKSkgIT09IG51bGw7ICkge1xuICAgICAgaiAmJiAoaiA9ICExLCBBID0gbmV3IHVsKG4sIGwpLCBBLnBsYXlsaXN0T2Zmc2V0ID0geSwgQS5zZXRTdGFydCh5KSwgQS5zbiA9IGYsIEEuY2MgPSBFLCBiICYmIChBLmJpdHJhdGUgPSBiKSwgQS5sZXZlbCA9IHIsIGggJiYgKEEuaW5pdFNlZ21lbnQgPSBoLCBoLnJhd1Byb2dyYW1EYXRlVGltZSAmJiAoQS5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBoLnJhd1Byb2dyYW1EYXRlVGltZSwgaC5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBudWxsKSwgQyAmJiAoQS5zZXRCeXRlUmFuZ2UoQyksIEMgPSBudWxsKSkpO1xuICAgICAgY29uc3QgZyA9IEZbMV07XG4gICAgICBpZiAoZykge1xuICAgICAgICBBLmR1cmF0aW9uID0gcGFyc2VGbG9hdChnKTtcbiAgICAgICAgY29uc3QgeCA9IChcIiBcIiArIEZbMl0pLnNsaWNlKDEpO1xuICAgICAgICBBLnRpdGxlID0geCB8fCBudWxsLCBBLnRhZ0xpc3QucHVzaCh4ID8gW1wiSU5GXCIsIGcsIHhdIDogW1wiSU5GXCIsIGddKTtcbiAgICAgIH0gZWxzZSBpZiAoRlszXSkge1xuICAgICAgICBpZiAodWUoQS5kdXJhdGlvbikpIHtcbiAgICAgICAgICBBLnBsYXlsaXN0T2Zmc2V0ID0geSwgQS5zZXRTdGFydCh5KSwgSCAmJiBDaChBLCBILCBjKSwgQS5zbiA9IGYsIEEubGV2ZWwgPSByLCBBLmNjID0gRSwgdS5wdXNoKEEpO1xuICAgICAgICAgIGNvbnN0IHggPSAoXCIgXCIgKyBGWzNdKS5zbGljZSgxKTtcbiAgICAgICAgICBBLnJlbHVybCA9IGRjKGMsIHgpLCBmYyhBLCBSLCBkKSwgUiA9IEEsIHkgKz0gQS5kdXJhdGlvbiwgZisrLCBwID0gMCwgaiA9ICEwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoRiA9IEZbMF0ubWF0Y2goV2IpLCAhRikge1xuICAgICAgICAgIHJ0Lndhcm4oXCJObyBtYXRjaGVzIG9uIHNsb3cgcmVnZXggbWF0Y2ggZm9yIGxldmVsIHBsYXlsaXN0IVwiKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKE0gPSAxOyBNIDwgRi5sZW5ndGggJiYgRltNXSA9PT0gdm9pZCAwOyBNKyspXG4gICAgICAgICAgO1xuICAgICAgICBjb25zdCB4ID0gKFwiIFwiICsgRltNXSkuc2xpY2UoMSksIHcgPSAoXCIgXCIgKyBGW00gKyAxXSkuc2xpY2UoMSksIEQgPSBGW00gKyAyXSA/IChcIiBcIiArIEZbTSArIDJdKS5zbGljZSgxKSA6IG51bGw7XG4gICAgICAgIHN3aXRjaCAoeCkge1xuICAgICAgICAgIGNhc2UgXCJCWVRFUkFOR0VcIjpcbiAgICAgICAgICAgIFIgPyBBLnNldEJ5dGVSYW5nZSh3LCBSKSA6IEEuc2V0Qnl0ZVJhbmdlKHcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIlBST0dSQU0tREFURS1USU1FXCI6XG4gICAgICAgICAgICBBLnJhd1Byb2dyYW1EYXRlVGltZSA9IHcsIEEudGFnTGlzdC5wdXNoKFtcIlBST0dSQU0tREFURS1USU1FXCIsIHddKSwgSyA9PT0gLTEgJiYgKEsgPSB1Lmxlbmd0aCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiUExBWUxJU1QtVFlQRVwiOlxuICAgICAgICAgICAgYy50eXBlICYmIG5zKGMsIHgsIEYpLCBjLnR5cGUgPSB3LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiTUVESUEtU0VRVUVOQ0VcIjpcbiAgICAgICAgICAgIGMuc3RhcnRTTiAhPT0gMCA/IG5zKGMsIHgsIEYpIDogdS5sZW5ndGggPiAwICYmIGtoKGMsIHgsIEYpLCBmID0gYy5zdGFydFNOID0gcGFyc2VJbnQodyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiU0tJUFwiOiB7XG4gICAgICAgICAgICBjLnNraXBwZWRTZWdtZW50cyAmJiBucyhjLCB4LCBGKTtcbiAgICAgICAgICAgIGNvbnN0IE8gPSBuZXcgZ3QodywgYyksIFUgPSBPLmRlY2ltYWxJbnRlZ2VyKFwiU0tJUFBFRC1TRUdNRU5UU1wiKTtcbiAgICAgICAgICAgIGlmICh1ZShVKSkge1xuICAgICAgICAgICAgICBjLnNraXBwZWRTZWdtZW50cyArPSBVO1xuICAgICAgICAgICAgICBmb3IgKGxldCBMID0gVTsgTC0tOyApXG4gICAgICAgICAgICAgICAgdS5wdXNoKG51bGwpO1xuICAgICAgICAgICAgICBmICs9IFU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBWID0gTy5lbnVtZXJhdGVkU3RyaW5nKFwiUkVDRU5UTFktUkVNT1ZFRC1EQVRFUkFOR0VTXCIpO1xuICAgICAgICAgICAgViAmJiAoYy5yZWNlbnRseVJlbW92ZWREYXRlcmFuZ2VzID0gKGMucmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlcyB8fCBbXSkuY29uY2F0KFYuc3BsaXQoXCJcdFwiKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJUQVJHRVREVVJBVElPTlwiOlxuICAgICAgICAgICAgYy50YXJnZXRkdXJhdGlvbiAhPT0gMCAmJiBucyhjLCB4LCBGKSwgYy50YXJnZXRkdXJhdGlvbiA9IE1hdGgubWF4KHBhcnNlSW50KHcpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJWRVJTSU9OXCI6XG4gICAgICAgICAgICBjLnZlcnNpb24gIT09IG51bGwgJiYgbnMoYywgeCwgRiksIGMudmVyc2lvbiA9IHBhcnNlSW50KHcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIklOREVQRU5ERU5ULVNFR01FTlRTXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiRU5ETElTVFwiOlxuICAgICAgICAgICAgYy5saXZlIHx8IG5zKGMsIHgsIEYpLCBjLmxpdmUgPSAhMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCIjXCI6XG4gICAgICAgICAgICAodyB8fCBEKSAmJiBBLnRhZ0xpc3QucHVzaChEID8gW3csIERdIDogW3ddKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJESVNDT05USU5VSVRZXCI6XG4gICAgICAgICAgICBFKyssIEEudGFnTGlzdC5wdXNoKFtcIkRJU1wiXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiR0FQXCI6XG4gICAgICAgICAgICBBLmdhcCA9ICEwLCBBLnRhZ0xpc3QucHVzaChbeF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIkJJVFJBVEVcIjpcbiAgICAgICAgICAgIEEudGFnTGlzdC5wdXNoKFt4LCB3XSksIGIgPSBwYXJzZUludCh3KSAqIDFlMywgdWUoYikgPyBBLmJpdHJhdGUgPSBiIDogYiA9IDA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiREFURVJBTkdFXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IE8gPSBuZXcgZ3QodywgYyksIFUgPSBuZXcgV2coTywgYy5kYXRlUmFuZ2VzW08uSURdLCBjLmRhdGVSYW5nZVRhZ0NvdW50KTtcbiAgICAgICAgICAgIGMuZGF0ZVJhbmdlVGFnQ291bnQrKywgVS5pc1ZhbGlkIHx8IGMuc2tpcHBlZFNlZ21lbnRzID8gYy5kYXRlUmFuZ2VzW1UuaWRdID0gVSA6IHJ0Lndhcm4oYElnbm9yaW5nIGludmFsaWQgREFURVJBTkdFIHRhZzogXCIke3d9XCJgKSwgQS50YWdMaXN0LnB1c2goW1wiRVhULVgtREFURVJBTkdFXCIsIHddKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiREVGSU5FXCI6IHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgTyA9IG5ldyBndCh3LCBjKTtcbiAgICAgICAgICAgICAgXCJJTVBPUlRcIiBpbiBPID8gRGIoYywgTywgbykgOiB4aChjLCBPLCB0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiRElTQ09OVElOVUlUWS1TRVFVRU5DRVwiOlxuICAgICAgICAgICAgYy5zdGFydENDICE9PSAwID8gbnMoYywgeCwgRikgOiB1Lmxlbmd0aCA+IDAgJiYga2goYywgeCwgRiksIGMuc3RhcnRDQyA9IEUgPSBwYXJzZUludCh3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJLRVlcIjoge1xuICAgICAgICAgICAgY29uc3QgTyA9IEFoKHcsIHQsIGMpO1xuICAgICAgICAgICAgaWYgKE8uaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICAgICAgICBpZiAoTy5tZXRob2QgPT09IFwiTk9ORVwiKSB7XG4gICAgICAgICAgICAgICAgSCA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBIIHx8IChIID0ge30pO1xuICAgICAgICAgICAgICBjb25zdCBVID0gSFtPLmtleUZvcm1hdF07XG4gICAgICAgICAgICAgIFUgIT0gbnVsbCAmJiBVLm1hdGNoZXMoTykgfHwgKFUgJiYgKEggPSBudCh7fSwgSCkpLCBIW08ua2V5Rm9ybWF0XSA9IE8pO1xuICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgIHJ0Lndhcm4oYFtLZXlzXSBJZ25vcmluZyB1bnN1cHBvcnRlZCBFWFQtWC1LRVkgdGFnOiBcIiR7d31cImApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJTVEFSVFwiOlxuICAgICAgICAgICAgYy5zdGFydFRpbWVPZmZzZXQgPSBJaCh3KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJNQVBcIjoge1xuICAgICAgICAgICAgY29uc3QgTyA9IG5ldyBndCh3LCBjKTtcbiAgICAgICAgICAgIGlmIChBLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgIGNvbnN0IFUgPSBuZXcgdWwobiwgbCk7XG4gICAgICAgICAgICAgIExoKFUsIE8sIHIsIEgpLCBoID0gVSwgQS5pbml0U2VnbWVudCA9IGgsIGgucmF3UHJvZ3JhbURhdGVUaW1lICYmICFBLnJhd1Byb2dyYW1EYXRlVGltZSAmJiAoQS5yYXdQcm9ncmFtRGF0ZVRpbWUgPSBoLnJhd1Byb2dyYW1EYXRlVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCBVID0gQS5ieXRlUmFuZ2VFbmRPZmZzZXQ7XG4gICAgICAgICAgICAgIGlmIChVKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgViA9IEEuYnl0ZVJhbmdlU3RhcnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgQyA9IGAke1UgLSBWfUAke1Z9YDtcbiAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgQyA9IG51bGw7XG4gICAgICAgICAgICAgIExoKEEsIE8sIHIsIEgpLCBoID0gQSwgaiA9ICEwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaC5jYyA9IEU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIlNFUlZFUi1DT05UUk9MXCI6IHtcbiAgICAgICAgICAgIGsgJiYgbnMoYywgeCwgRiksIGsgPSBuZXcgZ3QodyksIGMuY2FuQmxvY2tSZWxvYWQgPSBrLmJvb2woXCJDQU4tQkxPQ0stUkVMT0FEXCIpLCBjLmNhblNraXBVbnRpbCA9IGsub3B0aW9uYWxGbG9hdChcIkNBTi1TS0lQLVVOVElMXCIsIDApLCBjLmNhblNraXBEYXRlUmFuZ2VzID0gYy5jYW5Ta2lwVW50aWwgPiAwICYmIGsuYm9vbChcIkNBTi1TS0lQLURBVEVSQU5HRVNcIiksIGMucGFydEhvbGRCYWNrID0gay5vcHRpb25hbEZsb2F0KFwiUEFSVC1IT0xELUJBQ0tcIiwgMCksIGMuaG9sZEJhY2sgPSBrLm9wdGlvbmFsRmxvYXQoXCJIT0xELUJBQ0tcIiwgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIlBBUlQtSU5GXCI6IHtcbiAgICAgICAgICAgIGMucGFydFRhcmdldCAmJiBucyhjLCB4LCBGKTtcbiAgICAgICAgICAgIGNvbnN0IE8gPSBuZXcgZ3Qodyk7XG4gICAgICAgICAgICBjLnBhcnRUYXJnZXQgPSBPLmRlY2ltYWxGbG9hdGluZ1BvaW50KFwiUEFSVC1UQVJHRVRcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIlBBUlRcIjoge1xuICAgICAgICAgICAgbGV0IE8gPSBjLnBhcnRMaXN0O1xuICAgICAgICAgICAgTyB8fCAoTyA9IGMucGFydExpc3QgPSBbXSk7XG4gICAgICAgICAgICBjb25zdCBVID0gcCA+IDAgPyBPW08ubGVuZ3RoIC0gMV0gOiB2b2lkIDAsIFYgPSBwKyssIEwgPSBuZXcgZ3QodywgYyksIG0gPSBuZXcgUFMoTCwgQSwgbCwgViwgVSk7XG4gICAgICAgICAgICBPLnB1c2gobSksIEEuZHVyYXRpb24gKz0gbS5kdXJhdGlvbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiUFJFTE9BRC1ISU5UXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IE8gPSBuZXcgZ3QodywgYyk7XG4gICAgICAgICAgICBjLnByZWxvYWRIaW50ID0gTztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiUkVORElUSU9OLVJFUE9SVFwiOiB7XG4gICAgICAgICAgICBjb25zdCBPID0gbmV3IGd0KHcsIGMpO1xuICAgICAgICAgICAgYy5yZW5kaXRpb25SZXBvcnRzID0gYy5yZW5kaXRpb25SZXBvcnRzIHx8IFtdLCBjLnJlbmRpdGlvblJlcG9ydHMucHVzaChPKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcnQud2FybihgbGluZSBwYXJzZWQgYnV0IG5vdCBoYW5kbGVkOiAke0Z9YCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBSICYmICFSLnJlbHVybCA/ICh1LnBvcCgpLCB5IC09IFIuZHVyYXRpb24sIGMucGFydExpc3QgJiYgKGMuZnJhZ21lbnRIaW50ID0gUikpIDogYy5wYXJ0TGlzdCAmJiAoZmMoQSwgUiwgZCksIEEuY2MgPSBFLCBjLmZyYWdtZW50SGludCA9IEEsIEggJiYgQ2goQSwgSCwgYykpLCBjLnRhcmdldGR1cmF0aW9uIHx8IChjLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKFwiTWlzc2luZyBUYXJnZXQgRHVyYXRpb25cIikpO1xuICAgIGNvbnN0ICQgPSB1Lmxlbmd0aCwgVyA9IHVbMF0sIF8gPSB1WyQgLSAxXTtcbiAgICBpZiAoeSArPSBjLnNraXBwZWRTZWdtZW50cyAqIGMudGFyZ2V0ZHVyYXRpb24sIHkgPiAwICYmICQgJiYgXykge1xuICAgICAgYy5hdmVyYWdldGFyZ2V0ZHVyYXRpb24gPSB5IC8gJDtcbiAgICAgIGNvbnN0IGcgPSBfLnNuO1xuICAgICAgYy5lbmRTTiA9IGcgIT09IFwiaW5pdFNlZ21lbnRcIiA/IGcgOiAwLCBjLmxpdmUgfHwgKF8uZW5kTGlzdCA9ICEwKSwgSyA+IDAgJiYgKFliKHUsIEspLCBXICYmIGQudW5zaGlmdChXKSk7XG4gICAgfVxuICAgIHJldHVybiBjLmZyYWdtZW50SGludCAmJiAoeSArPSBjLmZyYWdtZW50SGludC5kdXJhdGlvbiksIGMudG90YWxkdXJhdGlvbiA9IHksIGQubGVuZ3RoICYmIGMuZGF0ZVJhbmdlVGFnQ291bnQgJiYgVyAmJiBaZyhkLCBjKSwgYy5lbmRDQyA9IEUsIGM7XG4gIH1cbn1cbmZ1bmN0aW9uIFpnKHMsIGUpIHtcbiAgbGV0IHQgPSBzLmxlbmd0aDtcbiAgaWYgKCF0KVxuICAgIGlmIChlLmhhc1Byb2dyYW1EYXRlVGltZSkge1xuICAgICAgY29uc3QgYSA9IGUuZnJhZ21lbnRzW2UuZnJhZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgICAgcy5wdXNoKGEpLCB0Kys7XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm47XG4gIGNvbnN0IHIgPSBzW3QgLSAxXSwgbiA9IGUubGl2ZSA/IDEgLyAwIDogZS50b3RhbGR1cmF0aW9uLCBpID0gT2JqZWN0LmtleXMoZS5kYXRlUmFuZ2VzKTtcbiAgZm9yIChsZXQgYSA9IGkubGVuZ3RoOyBhLS07ICkge1xuICAgIGNvbnN0IGwgPSBlLmRhdGVSYW5nZXNbaVthXV0sIGMgPSBsLnN0YXJ0RGF0ZS5nZXRUaW1lKCk7XG4gICAgbC50YWdBbmNob3IgPSByLnJlZjtcbiAgICBmb3IgKGxldCB1ID0gdDsgdS0tOyApIHtcbiAgICAgIHZhciBvO1xuICAgICAgaWYgKCgobyA9IHNbdV0pID09IG51bGwgPyB2b2lkIDAgOiBvLnNuKSA8IGUuc3RhcnRTTilcbiAgICAgICAgYnJlYWs7XG4gICAgICBjb25zdCBkID0gemIoZSwgYywgcywgdSwgbik7XG4gICAgICBpZiAoZCAhPT0gLTEpIHtcbiAgICAgICAgbC50YWdBbmNob3IgPSBlLmZyYWdtZW50c1tkXS5yZWY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gemIocywgZSwgdCwgciwgbikge1xuICBjb25zdCBpID0gdFtyXTtcbiAgaWYgKGkpIHtcbiAgICBjb25zdCBhID0gaS5wcm9ncmFtRGF0ZVRpbWU7XG4gICAgaWYgKGUgPj0gYSB8fCByID09PSAwKSB7XG4gICAgICB2YXIgbztcbiAgICAgIGNvbnN0IGwgPSAoKChvID0gdFtyICsgMV0pID09IG51bGwgPyB2b2lkIDAgOiBvLnN0YXJ0KSB8fCBuKSAtIGkuc3RhcnQ7XG4gICAgICBpZiAoZSA8PSBhICsgbCAqIDFlMykge1xuICAgICAgICBjb25zdCBjID0gdFtyXS5zbiAtIHMuc3RhcnRTTjtcbiAgICAgICAgaWYgKGMgPCAwKVxuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgY29uc3QgdSA9IHMuZnJhZ21lbnRzO1xuICAgICAgICBpZiAodS5sZW5ndGggPiB0Lmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGggPSAodFtyICsgMV0gfHwgdVt1Lmxlbmd0aCAtIDFdKS5zbiAtIHMuc3RhcnRTTjtcbiAgICAgICAgICBmb3IgKGxldCBmID0gaDsgZiA+IGM7IGYtLSkge1xuICAgICAgICAgICAgY29uc3QgcCA9IHVbZl0ucHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICAgICAgaWYgKGUgPj0gcCAmJiBlIDwgcCArIHVbZl0uZHVyYXRpb24gKiAxZTMpXG4gICAgICAgICAgICAgIHJldHVybiBmO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gQWgocywgZSwgdCkge1xuICB2YXIgciwgbjtcbiAgY29uc3QgaSA9IG5ldyBndChzLCB0KSwgbyA9IChyID0gaS5NRVRIT0QpICE9IG51bGwgPyByIDogXCJcIiwgYSA9IGkuVVJJLCBsID0gaS5oZXhhZGVjaW1hbEludGVnZXIoXCJJVlwiKSwgYyA9IGkuS0VZRk9STUFUVkVSU0lPTlMsIHUgPSAobiA9IGkuS0VZRk9STUFUKSAhPSBudWxsID8gbiA6IFwiaWRlbnRpdHlcIjtcbiAgYSAmJiBpLklWICYmICFsICYmIHJ0LmVycm9yKGBJbnZhbGlkIElWOiAke2kuSVZ9YCk7XG4gIGNvbnN0IGQgPSBhID8genIucmVzb2x2ZShhLCBlKSA6IFwiXCIsIGggPSAoYyB8fCBcIjFcIikuc3BsaXQoXCIvXCIpLm1hcChOdW1iZXIpLmZpbHRlcihOdW1iZXIuaXNGaW5pdGUpO1xuICByZXR1cm4gbmV3IHlpKG8sIGQsIHUsIGgsIGwsIGkuS0VZSUQpO1xufVxuZnVuY3Rpb24gSWgocykge1xuICBjb25zdCB0ID0gbmV3IGd0KHMpLmRlY2ltYWxGbG9hdGluZ1BvaW50KFwiVElNRS1PRkZTRVRcIik7XG4gIHJldHVybiB1ZSh0KSA/IHQgOiBudWxsO1xufVxuZnVuY3Rpb24gX2gocywgZSkge1xuICBsZXQgdCA9IChzIHx8IFwiXCIpLnNwbGl0KC9bICxdKy8pLmZpbHRlcigocikgPT4gcik7XG4gIFtcInZpZGVvXCIsIFwiYXVkaW9cIiwgXCJ0ZXh0XCJdLmZvckVhY2goKHIpID0+IHtcbiAgICBjb25zdCBuID0gdC5maWx0ZXIoKGkpID0+IHB1KGksIHIpKTtcbiAgICBuLmxlbmd0aCAmJiAoZVtgJHtyfUNvZGVjYF0gPSBuLm1hcCgoaSkgPT4gaS5zcGxpdChcIi9cIilbMF0pLmpvaW4oXCIsXCIpLCB0ID0gdC5maWx0ZXIoKGkpID0+IG4uaW5kZXhPZihpKSA9PT0gLTEpKTtcbiAgfSksIGUudW5rbm93bkNvZGVjcyA9IHQ7XG59XG5mdW5jdGlvbiBSaChzLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSBlW3RdO1xuICByICYmIChzW3RdID0gcik7XG59XG5mdW5jdGlvbiBZYihzLCBlKSB7XG4gIGxldCB0ID0gc1tlXTtcbiAgZm9yIChsZXQgciA9IGU7IHItLTsgKSB7XG4gICAgY29uc3QgbiA9IHNbcl07XG4gICAgaWYgKCFuKVxuICAgICAgcmV0dXJuO1xuICAgIG4ucHJvZ3JhbURhdGVUaW1lID0gdC5wcm9ncmFtRGF0ZVRpbWUgLSBuLmR1cmF0aW9uICogMWUzLCB0ID0gbjtcbiAgfVxufVxuZnVuY3Rpb24gZmMocywgZSwgdCkge1xuICBzLnJhd1Byb2dyYW1EYXRlVGltZSA/IHQucHVzaChzKSA6IGUgIT0gbnVsbCAmJiBlLnByb2dyYW1EYXRlVGltZSAmJiAocy5wcm9ncmFtRGF0ZVRpbWUgPSBlLmVuZFByb2dyYW1EYXRlVGltZSk7XG59XG5mdW5jdGlvbiBMaChzLCBlLCB0LCByKSB7XG4gIHMucmVsdXJsID0gZS5VUkksIGUuQllURVJBTkdFICYmIHMuc2V0Qnl0ZVJhbmdlKGUuQllURVJBTkdFKSwgcy5sZXZlbCA9IHQsIHMuc24gPSBcImluaXRTZWdtZW50XCIsIHIgJiYgKHMubGV2ZWxrZXlzID0gciksIHMuaW5pdFNlZ21lbnQgPSBudWxsO1xufVxuZnVuY3Rpb24gQ2gocywgZSwgdCkge1xuICBzLmxldmVsa2V5cyA9IGU7XG4gIGNvbnN0IHtcbiAgICBlbmNyeXB0ZWRGcmFnbWVudHM6IHJcbiAgfSA9IHQ7XG4gICghci5sZW5ndGggfHwgcltyLmxlbmd0aCAtIDFdLmxldmVsa2V5cyAhPT0gZSkgJiYgT2JqZWN0LmtleXMoZSkuc29tZSgobikgPT4gZVtuXS5pc0NvbW1vbkVuY3J5cHRpb24pICYmIHIucHVzaChzKTtcbn1cbmZ1bmN0aW9uIG5zKHMsIGUsIHQpIHtcbiAgcy5wbGF5bGlzdFBhcnNpbmdFcnJvciA9IG5ldyBFcnJvcihgI0VYVC1YLSR7ZX0gbXVzdCBub3QgYXBwZWFyIG1vcmUgdGhhbiBvbmNlICgke3RbMF19KWApO1xufVxuZnVuY3Rpb24ga2gocywgZSwgdCkge1xuICBzLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbmV3IEVycm9yKGAjRVhULVgtJHtlfSBtdXN0IGFwcGVhciBiZWZvcmUgdGhlIGZpcnN0IE1lZGlhIFNlZ21lbnQgKCR7dFswXX0pYCk7XG59XG5mdW5jdGlvbiBwbChzLCBlKSB7XG4gIGNvbnN0IHQgPSBlLnN0YXJ0UFRTO1xuICBpZiAodWUodCkpIHtcbiAgICBsZXQgciA9IDAsIG47XG4gICAgZS5zbiA+IHMuc24gPyAociA9IHQgLSBzLnN0YXJ0LCBuID0gcykgOiAociA9IHMuc3RhcnQgLSB0LCBuID0gZSksIG4uZHVyYXRpb24gIT09IHIgJiYgbi5zZXREdXJhdGlvbihyKTtcbiAgfSBlbHNlIGUuc24gPiBzLnNuID8gcy5jYyA9PT0gZS5jYyAmJiBzLm1pbkVuZFBUUyA/IGUuc2V0U3RhcnQocy5zdGFydCArIChzLm1pbkVuZFBUUyAtIHMuc3RhcnQpKSA6IGUuc2V0U3RhcnQocy5zdGFydCArIHMuZHVyYXRpb24pIDogZS5zZXRTdGFydChNYXRoLm1heChzLnN0YXJ0IC0gZS5kdXJhdGlvbiwgMCkpO1xufVxuZnVuY3Rpb24gWGcocywgZSwgdCwgciwgbiwgaSwgbykge1xuICByIC0gdCA8PSAwICYmIChvLndhcm4oXCJGcmFnbWVudCBzaG91bGQgaGF2ZSBhIHBvc2l0aXZlIGR1cmF0aW9uXCIsIGUpLCByID0gdCArIGUuZHVyYXRpb24sIGkgPSBuICsgZS5kdXJhdGlvbik7XG4gIGxldCBsID0gdCwgYyA9IHI7XG4gIGNvbnN0IHUgPSBlLnN0YXJ0UFRTLCBkID0gZS5lbmRQVFM7XG4gIGlmICh1ZSh1KSkge1xuICAgIGNvbnN0IGIgPSBNYXRoLmFicyh1IC0gdCk7XG4gICAgcyAmJiBiID4gcy50b3RhbGR1cmF0aW9uID8gby53YXJuKGBtZWRpYSB0aW1lc3RhbXBzIGFuZCBwbGF5bGlzdCB0aW1lcyBkaWZmZXIgYnkgJHtifXMgZm9yIGxldmVsICR7ZS5sZXZlbH0gJHtzLnVybH1gKSA6IHVlKGUuZGVsdGFQVFMpID8gZS5kZWx0YVBUUyA9IE1hdGgubWF4KGIsIGUuZGVsdGFQVFMpIDogZS5kZWx0YVBUUyA9IGIsIGwgPSBNYXRoLm1heCh0LCB1KSwgdCA9IE1hdGgubWluKHQsIHUpLCBuID0gZS5zdGFydERUUyAhPT0gdm9pZCAwID8gTWF0aC5taW4obiwgZS5zdGFydERUUykgOiBuLCBjID0gTWF0aC5taW4ociwgZCksIHIgPSBNYXRoLm1heChyLCBkKSwgaSA9IGUuZW5kRFRTICE9PSB2b2lkIDAgPyBNYXRoLm1heChpLCBlLmVuZERUUykgOiBpO1xuICB9XG4gIGNvbnN0IGggPSB0IC0gZS5zdGFydDtcbiAgZS5zdGFydCAhPT0gMCAmJiBlLnNldFN0YXJ0KHQpLCBlLnNldER1cmF0aW9uKHIgLSBlLnN0YXJ0KSwgZS5zdGFydFBUUyA9IHQsIGUubWF4U3RhcnRQVFMgPSBsLCBlLnN0YXJ0RFRTID0gbiwgZS5lbmRQVFMgPSByLCBlLm1pbkVuZFBUUyA9IGMsIGUuZW5kRFRTID0gaTtcbiAgY29uc3QgZiA9IGUuc247XG4gIGlmICghcyB8fCBmIDwgcy5zdGFydFNOIHx8IGYgPiBzLmVuZFNOKVxuICAgIHJldHVybiAwO1xuICBsZXQgcDtcbiAgY29uc3QgeSA9IGYgLSBzLnN0YXJ0U04sIEUgPSBzLmZyYWdtZW50cztcbiAgZm9yIChFW3ldID0gZSwgcCA9IHk7IHAgPiAwOyBwLS0pXG4gICAgcGwoRVtwXSwgRVtwIC0gMV0pO1xuICBmb3IgKHAgPSB5OyBwIDwgRS5sZW5ndGggLSAxOyBwKyspXG4gICAgcGwoRVtwXSwgRVtwICsgMV0pO1xuICByZXR1cm4gcy5mcmFnbWVudEhpbnQgJiYgcGwoRVtFLmxlbmd0aCAtIDFdLCBzLmZyYWdtZW50SGludCksIHMuUFRTS25vd24gPSBzLmFsaWduZWRTbGlkaW5nID0gITAsIGg7XG59XG5mdW5jdGlvbiBaYihzLCBlLCB0KSB7XG4gIGlmIChzID09PSBlKVxuICAgIHJldHVybjtcbiAgbGV0IHIgPSBudWxsO1xuICBjb25zdCBuID0gcy5mcmFnbWVudHM7XG4gIGZvciAobGV0IHUgPSBuLmxlbmd0aCAtIDE7IHUgPj0gMDsgdS0tKSB7XG4gICAgY29uc3QgZCA9IG5bdV0uaW5pdFNlZ21lbnQ7XG4gICAgaWYgKGQpIHtcbiAgICAgIHIgPSBkO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHMuZnJhZ21lbnRIaW50ICYmIGRlbGV0ZSBzLmZyYWdtZW50SGludC5lbmRQVFM7XG4gIGxldCBpO1xuICBRYihzLCBlLCAodSwgZCwgaCwgZikgPT4ge1xuICAgIGlmICgoIWUuc3RhcnRDQyB8fCBlLnNraXBwZWRTZWdtZW50cykgJiYgZC5jYyAhPT0gdS5jYykge1xuICAgICAgY29uc3QgcCA9IHUuY2MgLSBkLmNjO1xuICAgICAgZm9yIChsZXQgeSA9IGg7IHkgPCBmLmxlbmd0aDsgeSsrKVxuICAgICAgICBmW3ldLmNjICs9IHA7XG4gICAgICBlLmVuZENDID0gZltmLmxlbmd0aCAtIDFdLmNjO1xuICAgIH1cbiAgICB1ZSh1LnN0YXJ0UFRTKSAmJiB1ZSh1LmVuZFBUUykgJiYgKGQuc2V0U3RhcnQoZC5zdGFydFBUUyA9IHUuc3RhcnRQVFMpLCBkLnN0YXJ0RFRTID0gdS5zdGFydERUUywgZC5tYXhTdGFydFBUUyA9IHUubWF4U3RhcnRQVFMsIGQuZW5kUFRTID0gdS5lbmRQVFMsIGQuZW5kRFRTID0gdS5lbmREVFMsIGQubWluRW5kUFRTID0gdS5taW5FbmRQVFMsIGQuc2V0RHVyYXRpb24odS5lbmRQVFMgLSB1LnN0YXJ0UFRTKSwgZC5kdXJhdGlvbiAmJiAoaSA9IGQpLCBlLlBUU0tub3duID0gZS5hbGlnbmVkU2xpZGluZyA9ICEwKSwgdS5oYXNTdHJlYW1zICYmIChkLmVsZW1lbnRhcnlTdHJlYW1zID0gdS5lbGVtZW50YXJ5U3RyZWFtcyksIGQubG9hZGVyID0gdS5sb2FkZXIsIHUuaGFzU3RhdHMgJiYgKGQuc3RhdHMgPSB1LnN0YXRzKSwgdS5pbml0U2VnbWVudCAmJiAoZC5pbml0U2VnbWVudCA9IHUuaW5pdFNlZ21lbnQsIHIgPSB1LmluaXRTZWdtZW50KTtcbiAgfSk7XG4gIGNvbnN0IG8gPSBlLmZyYWdtZW50cywgYSA9IGUuZnJhZ21lbnRIaW50ID8gby5jb25jYXQoZS5mcmFnbWVudEhpbnQpIDogbztcbiAgaWYgKHIgJiYgYS5mb3JFYWNoKCh1KSA9PiB7XG4gICAgdmFyIGQ7XG4gICAgdSAmJiAoIXUuaW5pdFNlZ21lbnQgfHwgdS5pbml0U2VnbWVudC5yZWx1cmwgPT09ICgoZCA9IHIpID09IG51bGwgPyB2b2lkIDAgOiBkLnJlbHVybCkpICYmICh1LmluaXRTZWdtZW50ID0gcik7XG4gIH0pLCBlLnNraXBwZWRTZWdtZW50cykge1xuICAgIGlmIChlLmRlbHRhVXBkYXRlRmFpbGVkID0gby5zb21lKCh1KSA9PiAhdSksIGUuZGVsdGFVcGRhdGVGYWlsZWQpIHtcbiAgICAgIHQud2FybihcIltsZXZlbC1oZWxwZXJdIFByZXZpb3VzIHBsYXlsaXN0IG1pc3Npbmcgc2VnbWVudHMgc2tpcHBlZCBpbiBkZWx0YSBwbGF5bGlzdFwiKTtcbiAgICAgIGZvciAobGV0IHUgPSBlLnNraXBwZWRTZWdtZW50czsgdS0tOyApXG4gICAgICAgIG8uc2hpZnQoKTtcbiAgICAgIGUuc3RhcnRTTiA9IG9bMF0uc247XG4gICAgfSBlbHNlIHtcbiAgICAgIGUuY2FuU2tpcERhdGVSYW5nZXMgJiYgKGUuZGF0ZVJhbmdlcyA9IFhiKHMuZGF0ZVJhbmdlcywgZSwgdCkpO1xuICAgICAgY29uc3QgdSA9IHMuZnJhZ21lbnRzLmZpbHRlcigoZCkgPT4gZC5yYXdQcm9ncmFtRGF0ZVRpbWUpO1xuICAgICAgaWYgKHMuaGFzUHJvZ3JhbURhdGVUaW1lICYmICFlLmhhc1Byb2dyYW1EYXRlVGltZSlcbiAgICAgICAgZm9yIChsZXQgZCA9IDE7IGQgPCBhLmxlbmd0aDsgZCsrKVxuICAgICAgICAgIGFbZF0ucHJvZ3JhbURhdGVUaW1lID09PSBudWxsICYmIGZjKGFbZF0sIGFbZCAtIDFdLCB1KTtcbiAgICAgIFpnKHUsIGUpO1xuICAgIH1cbiAgICBlLmVuZENDID0gb1tvLmxlbmd0aCAtIDFdLmNjO1xuICB9XG4gIGlmICghZS5zdGFydENDKSB7XG4gICAgdmFyIGw7XG4gICAgY29uc3QgdSA9IGVwKHMsIGUuc3RhcnRTTiAtIDEpO1xuICAgIGUuc3RhcnRDQyA9IChsID0gdSA9PSBudWxsID8gdm9pZCAwIDogdS5jYykgIT0gbnVsbCA/IGwgOiBvWzBdLmNjO1xuICB9XG4gIEpiKHMucGFydExpc3QsIGUucGFydExpc3QsICh1LCBkKSA9PiB7XG4gICAgZC5lbGVtZW50YXJ5U3RyZWFtcyA9IHUuZWxlbWVudGFyeVN0cmVhbXMsIGQuc3RhdHMgPSB1LnN0YXRzO1xuICB9KSwgaSA/IFhnKGUsIGksIGkuc3RhcnRQVFMsIGkuZW5kUFRTLCBpLnN0YXJ0RFRTLCBpLmVuZERUUywgdCkgOiBKZyhzLCBlKSwgby5sZW5ndGggJiYgKGUudG90YWxkdXJhdGlvbiA9IGUuZWRnZSAtIG9bMF0uc3RhcnQpLCBlLmRyaWZ0U3RhcnRUaW1lID0gcy5kcmlmdFN0YXJ0VGltZSwgZS5kcmlmdFN0YXJ0ID0gcy5kcmlmdFN0YXJ0O1xuICBjb25zdCBjID0gZS5hZHZhbmNlZERhdGVUaW1lO1xuICBpZiAoZS5hZHZhbmNlZCAmJiBjKSB7XG4gICAgY29uc3QgdSA9IGUuZWRnZTtcbiAgICBlLmRyaWZ0U3RhcnQgfHwgKGUuZHJpZnRTdGFydFRpbWUgPSBjLCBlLmRyaWZ0U3RhcnQgPSB1KSwgZS5kcmlmdEVuZFRpbWUgPSBjLCBlLmRyaWZ0RW5kID0gdTtcbiAgfSBlbHNlXG4gICAgZS5kcmlmdEVuZFRpbWUgPSBzLmRyaWZ0RW5kVGltZSwgZS5kcmlmdEVuZCA9IHMuZHJpZnRFbmQsIGUuYWR2YW5jZWREYXRlVGltZSA9IHMuYWR2YW5jZWREYXRlVGltZTtcbiAgZS5yZXF1ZXN0U2NoZWR1bGVkID09PSAtMSAmJiAoZS5yZXF1ZXN0U2NoZWR1bGVkID0gcy5yZXF1ZXN0U2NoZWR1bGVkKTtcbn1cbmZ1bmN0aW9uIFhiKHMsIGUsIHQpIHtcbiAgY29uc3Qge1xuICAgIGRhdGVSYW5nZXM6IHIsXG4gICAgcmVjZW50bHlSZW1vdmVkRGF0ZXJhbmdlczogblxuICB9ID0gZSwgaSA9IG50KHt9LCBzKTtcbiAgbiAmJiBuLmZvckVhY2goKGwpID0+IHtcbiAgICBkZWxldGUgaVtsXTtcbiAgfSk7XG4gIGNvbnN0IGEgPSBPYmplY3Qua2V5cyhpKS5sZW5ndGg7XG4gIHJldHVybiBhID8gKE9iamVjdC5rZXlzKHIpLmZvckVhY2goKGwpID0+IHtcbiAgICBjb25zdCBjID0gaVtsXSwgdSA9IG5ldyBXZyhyW2xdLmF0dHIsIGMpO1xuICAgIHUuaXNWYWxpZCA/IChpW2xdID0gdSwgYyB8fCAodS50YWdPcmRlciArPSBhKSkgOiB0Lndhcm4oYElnbm9yaW5nIGludmFsaWQgUGxheWxpc3QgRGVsdGEgVXBkYXRlIERBVEVSQU5HRSB0YWc6IFwiJHthdChyW2xdLmF0dHIpfVwiYCk7XG4gIH0pLCBpKSA6IHI7XG59XG5mdW5jdGlvbiBKYihzLCBlLCB0KSB7XG4gIGlmIChzICYmIGUpIHtcbiAgICBsZXQgciA9IDA7XG4gICAgZm9yIChsZXQgbiA9IDAsIGkgPSBzLmxlbmd0aDsgbiA8PSBpOyBuKyspIHtcbiAgICAgIGNvbnN0IG8gPSBzW25dLCBhID0gZVtuICsgcl07XG4gICAgICBvICYmIGEgJiYgby5pbmRleCA9PT0gYS5pbmRleCAmJiBvLmZyYWdtZW50LnNuID09PSBhLmZyYWdtZW50LnNuID8gdChvLCBhKSA6IHItLTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIFFiKHMsIGUsIHQpIHtcbiAgY29uc3QgciA9IGUuc2tpcHBlZFNlZ21lbnRzLCBuID0gTWF0aC5tYXgocy5zdGFydFNOLCBlLnN0YXJ0U04pIC0gZS5zdGFydFNOLCBpID0gKHMuZnJhZ21lbnRIaW50ID8gMSA6IDApICsgKHIgPyBlLmVuZFNOIDogTWF0aC5taW4ocy5lbmRTTiwgZS5lbmRTTikpIC0gZS5zdGFydFNOLCBvID0gZS5zdGFydFNOIC0gcy5zdGFydFNOLCBhID0gZS5mcmFnbWVudEhpbnQgPyBlLmZyYWdtZW50cy5jb25jYXQoZS5mcmFnbWVudEhpbnQpIDogZS5mcmFnbWVudHMsIGwgPSBzLmZyYWdtZW50SGludCA/IHMuZnJhZ21lbnRzLmNvbmNhdChzLmZyYWdtZW50SGludCkgOiBzLmZyYWdtZW50cztcbiAgZm9yIChsZXQgYyA9IG47IGMgPD0gaTsgYysrKSB7XG4gICAgY29uc3QgdSA9IGxbbyArIGNdO1xuICAgIGxldCBkID0gYVtjXTtcbiAgICBpZiAociAmJiAhZCAmJiB1ICYmIChkID0gZS5mcmFnbWVudHNbY10gPSB1KSwgdSAmJiBkKSB7XG4gICAgICB0KHUsIGQsIGMsIGEpO1xuICAgICAgY29uc3QgaCA9IHUucmVsdXJsLCBmID0gZC5yZWx1cmw7XG4gICAgICBpZiAoaCAmJiBlVChoLCBmKSkge1xuICAgICAgICBlLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gRGgoYG1lZGlhIHNlcXVlbmNlIG1pc21hdGNoICR7ZC5zbn06YCwgcywgZSwgdSwgZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAodS5jYyAhPT0gZC5jYykge1xuICAgICAgICBlLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gRGgoYGRpc2NvbnRpbnVpdHkgc2VxdWVuY2UgbWlzbWF0Y2ggKCR7dS5jY30hPSR7ZC5jY30pYCwgcywgZSwgdSwgZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIERoKHMsIGUsIHQsIHIsIG4pIHtcbiAgcmV0dXJuIG5ldyBFcnJvcihgJHtzfSAke24udXJsfVxuUGxheWxpc3Qgc3RhcnRpbmcgQCR7ZS5zdGFydFNOfVxuJHtlLm0zdTh9XG5cblBsYXlsaXN0IHN0YXJ0aW5nIEAke3Quc3RhcnRTTn1cbiR7dC5tM3U4fWApO1xufVxuZnVuY3Rpb24gSmcocywgZSwgdCA9ICEwKSB7XG4gIGNvbnN0IHIgPSBlLnN0YXJ0U04gKyBlLnNraXBwZWRTZWdtZW50cyAtIHMuc3RhcnRTTiwgbiA9IHMuZnJhZ21lbnRzLCBpID0gciA+PSAwO1xuICBsZXQgbyA9IDA7XG4gIGlmIChpICYmIHIgPCBuLmxlbmd0aClcbiAgICBvID0gbltyXS5zdGFydDtcbiAgZWxzZSBpZiAoaSAmJiBlLnN0YXJ0U04gPT09IHMuZW5kU04gKyAxKVxuICAgIG8gPSBzLmZyYWdtZW50RW5kO1xuICBlbHNlIGlmIChpICYmIHQpXG4gICAgbyA9IHMuZnJhZ21lbnRTdGFydCArIHIgKiBlLmxldmVsVGFyZ2V0RHVyYXRpb247XG4gIGVsc2UgaWYgKCFlLnNraXBwZWRTZWdtZW50cyAmJiBlLmZyYWdtZW50U3RhcnQgPT09IDApXG4gICAgbyA9IHMuZnJhZ21lbnRTdGFydDtcbiAgZWxzZVxuICAgIHJldHVybjtcbiAgZ2MoZSwgbyk7XG59XG5mdW5jdGlvbiBnYyhzLCBlKSB7XG4gIGlmIChlKSB7XG4gICAgY29uc3QgdCA9IHMuZnJhZ21lbnRzO1xuICAgIGZvciAobGV0IHIgPSBzLnNraXBwZWRTZWdtZW50czsgciA8IHQubGVuZ3RoOyByKyspXG4gICAgICB0W3JdLmFkZFN0YXJ0KGUpO1xuICAgIHMuZnJhZ21lbnRIaW50ICYmIHMuZnJhZ21lbnRIaW50LmFkZFN0YXJ0KGUpO1xuICB9XG59XG5mdW5jdGlvbiBRZyhzLCBlID0gMSAvIDApIHtcbiAgbGV0IHQgPSAxZTMgKiBzLnRhcmdldGR1cmF0aW9uO1xuICBpZiAocy51cGRhdGVkKSB7XG4gICAgY29uc3QgciA9IHMuZnJhZ21lbnRzO1xuICAgIGlmIChyLmxlbmd0aCAmJiB0ICogNCA+IGUpIHtcbiAgICAgIGNvbnN0IGkgPSByW3IubGVuZ3RoIC0gMV0uZHVyYXRpb24gKiAxZTM7XG4gICAgICBpIDwgdCAmJiAodCA9IGkpO1xuICAgIH1cbiAgfSBlbHNlXG4gICAgdCAvPSAyO1xuICByZXR1cm4gTWF0aC5yb3VuZCh0KTtcbn1cbmZ1bmN0aW9uIGVwKHMsIGUsIHQpIHtcbiAgaWYgKCFzKVxuICAgIHJldHVybiBudWxsO1xuICBsZXQgciA9IHMuZnJhZ21lbnRzW2UgLSBzLnN0YXJ0U05dO1xuICByZXR1cm4gciB8fCAociA9IHMuZnJhZ21lbnRIaW50LCByICYmIHIuc24gPT09IGUpID8gciA6IGUgPCBzLnN0YXJ0U04gJiYgdCAmJiB0LnNuID09PSBlID8gdCA6IG51bGw7XG59XG5mdW5jdGlvbiBQaChzLCBlLCB0KSB7XG4gIHJldHVybiBzID8gdHAocy5wYXJ0TGlzdCwgZSwgdCkgOiBudWxsO1xufVxuZnVuY3Rpb24gdHAocywgZSwgdCkge1xuICBpZiAocylcbiAgICBmb3IgKGxldCByID0gcy5sZW5ndGg7IHItLTsgKSB7XG4gICAgICBjb25zdCBuID0gc1tyXTtcbiAgICAgIGlmIChuLmluZGV4ID09PSB0ICYmIG4uZnJhZ21lbnQuc24gPT09IGUpXG4gICAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBycChzKSB7XG4gIHMuZm9yRWFjaCgoZSwgdCkgPT4ge1xuICAgIHZhciByO1xuICAgIChyID0gZS5kZXRhaWxzKSA9PSBudWxsIHx8IHIuZnJhZ21lbnRzLmZvckVhY2goKG4pID0+IHtcbiAgICAgIG4ubGV2ZWwgPSB0LCBuLmluaXRTZWdtZW50ICYmIChuLmluaXRTZWdtZW50LmxldmVsID0gdCk7XG4gICAgfSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZVQocywgZSkge1xuICByZXR1cm4gcyAhPT0gZSAmJiBlID8gTWgocykgIT09IE1oKGUpIDogITE7XG59XG5mdW5jdGlvbiBNaChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1xcP1teP10qJC8sIFwiXCIpO1xufVxuZnVuY3Rpb24gWW4ocywgZSkge1xuICBmb3IgKGxldCByID0gMCwgbiA9IHMubGVuZ3RoOyByIDwgbjsgcisrKSB7XG4gICAgdmFyIHQ7XG4gICAgaWYgKCgodCA9IHNbcl0pID09IG51bGwgPyB2b2lkIDAgOiB0LmNjKSA9PT0gZSlcbiAgICAgIHJldHVybiBzW3JdO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gdFQocywgZSkge1xuICByZXR1cm4gISEocyAmJiBlLnN0YXJ0Q0MgPCBzLmVuZENDICYmIGUuZW5kQ0MgPiBzLnN0YXJ0Q0MpO1xufVxuZnVuY3Rpb24gT2gocywgZSkge1xuICBjb25zdCB0ID0gcy5zdGFydCArIGU7XG4gIHMuc3RhcnRQVFMgPSB0LCBzLnNldFN0YXJ0KHQpLCBzLmVuZFBUUyA9IHQgKyBzLmR1cmF0aW9uO1xufVxuZnVuY3Rpb24gc3AocywgZSkge1xuICBjb25zdCB0ID0gZS5mcmFnbWVudHM7XG4gIGZvciAobGV0IHIgPSAwLCBuID0gdC5sZW5ndGg7IHIgPCBuOyByKyspXG4gICAgT2godFtyXSwgcyk7XG4gIGUuZnJhZ21lbnRIaW50ICYmIE9oKGUuZnJhZ21lbnRIaW50LCBzKSwgZS5hbGlnbmVkU2xpZGluZyA9ICEwO1xufVxuZnVuY3Rpb24gclQocywgZSkge1xuICBzICYmIChucChlLCBzKSwgZS5hbGlnbmVkU2xpZGluZyB8fCBzYShlLCBzKSwgIWUuYWxpZ25lZFNsaWRpbmcgJiYgIWUuc2tpcHBlZFNlZ21lbnRzICYmIEpnKHMsIGUsICExKSk7XG59XG5mdW5jdGlvbiBucChzLCBlKSB7XG4gIGlmICghdFQoZSwgcykpXG4gICAgcmV0dXJuO1xuICBjb25zdCB0ID0gTWF0aC5taW4oZS5lbmRDQywgcy5lbmRDQyksIHIgPSBZbihlLmZyYWdtZW50cywgdCksIG4gPSBZbihzLmZyYWdtZW50cywgdCk7XG4gIGlmICghciB8fCAhbilcbiAgICByZXR1cm47XG4gIHJ0LmxvZyhgQWxpZ25pbmcgcGxheWxpc3QgYXQgc3RhcnQgb2YgZGljb250aW51aXR5IHNlcXVlbmNlICR7dH1gKTtcbiAgY29uc3QgaSA9IHIuc3RhcnQgLSBuLnN0YXJ0O1xuICBzcChpLCBzKTtcbn1cbmZ1bmN0aW9uIHNhKHMsIGUpIHtcbiAgaWYgKCFzLmhhc1Byb2dyYW1EYXRlVGltZSB8fCAhZS5oYXNQcm9ncmFtRGF0ZVRpbWUpXG4gICAgcmV0dXJuO1xuICBjb25zdCB0ID0gcy5mcmFnbWVudHMsIHIgPSBlLmZyYWdtZW50cztcbiAgaWYgKCF0Lmxlbmd0aCB8fCAhci5sZW5ndGgpXG4gICAgcmV0dXJuO1xuICBsZXQgbiwgaTtcbiAgY29uc3QgbyA9IE1hdGgubWluKGUuZW5kQ0MsIHMuZW5kQ0MpO1xuICBlLnN0YXJ0Q0MgPCBvICYmIHMuc3RhcnRDQyA8IG8gJiYgKG4gPSBZbihyLCBvKSwgaSA9IFluKHQsIG8pKSwgKCFuIHx8ICFpKSAmJiAobiA9IHJbTWF0aC5mbG9vcihyLmxlbmd0aCAvIDIpXSwgaSA9IFluKHQsIG4uY2MpIHx8IHRbTWF0aC5mbG9vcih0Lmxlbmd0aCAvIDIpXSk7XG4gIGNvbnN0IGEgPSBuLnByb2dyYW1EYXRlVGltZSwgbCA9IGkucHJvZ3JhbURhdGVUaW1lO1xuICBpZiAoIWEgfHwgIWwpXG4gICAgcmV0dXJuO1xuICBjb25zdCBjID0gKGwgLSBhKSAvIDFlMyAtIChpLnN0YXJ0IC0gbi5zdGFydCk7XG4gIHNwKGMsIHMpO1xufVxuZnVuY3Rpb24gY3IocywgZSwgdCkge1xuICBwcihzLCBlLCB0KSwgcy5hZGRFdmVudExpc3RlbmVyKGUsIHQpO1xufVxuZnVuY3Rpb24gcHIocywgZSwgdCkge1xuICBzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZSwgdCk7XG59XG5jb25zdCBzVCA9IHtcbiAgdG9TdHJpbmc6IGZ1bmN0aW9uKHMpIHtcbiAgICBsZXQgZSA9IFwiXCI7XG4gICAgY29uc3QgdCA9IHMubGVuZ3RoO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgdDsgcisrKVxuICAgICAgZSArPSBgWyR7cy5zdGFydChyKS50b0ZpeGVkKDMpfS0ke3MuZW5kKHIpLnRvRml4ZWQoMyl9XWA7XG4gICAgcmV0dXJuIGU7XG4gIH1cbn0sIG5lID0ge1xuICBTVE9QUEVEOiBcIlNUT1BQRURcIixcbiAgSURMRTogXCJJRExFXCIsXG4gIEtFWV9MT0FESU5HOiBcIktFWV9MT0FESU5HXCIsXG4gIEZSQUdfTE9BRElORzogXCJGUkFHX0xPQURJTkdcIixcbiAgRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6IFwiRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUllcIixcbiAgV0FJVElOR19UUkFDSzogXCJXQUlUSU5HX1RSQUNLXCIsXG4gIFBBUlNJTkc6IFwiUEFSU0lOR1wiLFxuICBQQVJTRUQ6IFwiUEFSU0VEXCIsXG4gIEVOREVEOiBcIkVOREVEXCIsXG4gIEVSUk9SOiBcIkVSUk9SXCIsXG4gIFdBSVRJTkdfSU5JVF9QVFM6IFwiV0FJVElOR19JTklUX1BUU1wiLFxuICBXQUlUSU5HX0xFVkVMOiBcIldBSVRJTkdfTEVWRUxcIlxufTtcbmNsYXNzIFR1IGV4dGVuZHMgSGcge1xuICBjb25zdHJ1Y3RvcihlLCB0LCByLCBuLCBpKSB7XG4gICAgc3VwZXIobiwgZS5sb2dnZXIpLCB0aGlzLmhscyA9IHZvaWQgMCwgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsLCB0aGlzLmZyYWdDdXJyZW50ID0gbnVsbCwgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSB2b2lkIDAsIHRoaXMudHJhbnNtdXhlciA9IG51bGwsIHRoaXMuX3N0YXRlID0gbmUuU1RPUFBFRCwgdGhpcy5wbGF5bGlzdFR5cGUgPSB2b2lkIDAsIHRoaXMubWVkaWEgPSBudWxsLCB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbCwgdGhpcy5jb25maWcgPSB2b2lkIDAsIHRoaXMuYml0cmF0ZVRlc3QgPSAhMSwgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwLCB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSAwLCB0aGlzLnN0YXJ0UG9zaXRpb24gPSAwLCB0aGlzLnN0YXJ0VGltZU9mZnNldCA9IG51bGwsIHRoaXMucmV0cnlEYXRlID0gMCwgdGhpcy5sZXZlbHMgPSBudWxsLCB0aGlzLmZyYWdtZW50TG9hZGVyID0gdm9pZCAwLCB0aGlzLmtleUxvYWRlciA9IHZvaWQgMCwgdGhpcy5sZXZlbExhc3RMb2FkZWQgPSBudWxsLCB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9ICExLCB0aGlzLmRlY3J5cHRlciA9IHZvaWQgMCwgdGhpcy5pbml0UFRTID0gW10sIHRoaXMuYnVmZmVyaW5nID0gITAsIHRoaXMubG9hZGluZ1BhcnRzID0gITEsIHRoaXMubG9vcFNuID0gdm9pZCAwLCB0aGlzLm9uTWVkaWFTZWVraW5nID0gKCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb25maWc6IG8sXG4gICAgICAgIGZyYWdDdXJyZW50OiBhLFxuICAgICAgICBtZWRpYTogbCxcbiAgICAgICAgbWVkaWFCdWZmZXI6IGMsXG4gICAgICAgIHN0YXRlOiB1XG4gICAgICB9ID0gdGhpcywgZCA9IGwgPyBsLmN1cnJlbnRUaW1lIDogMCwgaCA9IENlLmJ1ZmZlckluZm8oYyB8fCBsLCBkLCBvLm1heEJ1ZmZlckhvbGUpLCBmID0gIWgubGVuO1xuICAgICAgaWYgKHRoaXMubG9nKGBNZWRpYSBzZWVraW5nIHRvICR7dWUoZCkgPyBkLnRvRml4ZWQoMykgOiBkfSwgc3RhdGU6ICR7dX0sICR7ZiA/IFwib3V0IG9mXCIgOiBcImluXCJ9IGJ1ZmZlcmApLCB0aGlzLnN0YXRlID09PSBuZS5FTkRFRClcbiAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICAgICAgZWxzZSBpZiAoYSkge1xuICAgICAgICBjb25zdCBwID0gby5tYXhGcmFnTG9va1VwVG9sZXJhbmNlLCB5ID0gYS5zdGFydCAtIHAsIEUgPSBhLnN0YXJ0ICsgYS5kdXJhdGlvbiArIHA7XG4gICAgICAgIGlmIChmIHx8IEUgPCBoLnN0YXJ0IHx8IHkgPiBoLmVuZCkge1xuICAgICAgICAgIGNvbnN0IGIgPSBkID4gRTtcbiAgICAgICAgICAoZCA8IHkgfHwgYikgJiYgKGIgJiYgYS5sb2FkZXIgJiYgKHRoaXMubG9nKGBDYW5jZWxsaW5nIGZyYWdtZW50IGxvYWQgZm9yIHNlZWsgKHNuOiAke2Euc259KWApLCBhLmFib3J0UmVxdWVzdHMoKSwgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpKSwgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGwpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnRzSW5SYW5nZShkLCAxIC8gMCwgdGhpcy5wbGF5bGlzdFR5cGUsICEwKTtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMubGFzdEN1cnJlbnRUaW1lO1xuICAgICAgICBpZiAoZCA+IHAgJiYgKHRoaXMubGFzdEN1cnJlbnRUaW1lID0gZCksICF0aGlzLmxvYWRpbmdQYXJ0cykge1xuICAgICAgICAgIGNvbnN0IHkgPSBNYXRoLm1heChoLmVuZCwgZCksIEUgPSB0aGlzLnNob3VsZExvYWRQYXJ0cyh0aGlzLmdldExldmVsRGV0YWlscygpLCB5KTtcbiAgICAgICAgICBFICYmICh0aGlzLmxvZyhgTEwtUGFydCBsb2FkaW5nIE9OIGFmdGVyIHNlZWtpbmcgdG8gJHtkLnRvRml4ZWQoMil9IHdpdGggYnVmZmVyIEAke3kudG9GaXhlZCgyKX1gKSwgdGhpcy5sb2FkaW5nUGFydHMgPSBFKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5obHMuaGFzRW5vdWdoVG9TdGFydCB8fCAodGhpcy5sb2coYFNldHRpbmcgJHtmID8gXCJzdGFydFBvc2l0aW9uXCIgOiBcIm5leHRMb2FkUG9zaXRpb25cIn0gdG8gJHtkfSBmb3Igc2VlayB3aXRob3V0IGVub3VnaCB0byBzdGFydGApLCB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBkLCBmICYmICh0aGlzLnN0YXJ0UG9zaXRpb24gPSBkKSksIGYgJiYgdGhpcy5zdGF0ZSA9PT0gbmUuSURMRSAmJiB0aGlzLnRpY2tJbW1lZGlhdGUoKTtcbiAgICB9LCB0aGlzLm9uTWVkaWFFbmRlZCA9ICgpID0+IHtcbiAgICAgIHRoaXMubG9nKFwic2V0dGluZyBzdGFydFBvc2l0aW9uIHRvIDAgYmVjYXVzZSBtZWRpYSBlbmRlZFwiKSwgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwO1xuICAgIH0sIHRoaXMucGxheWxpc3RUeXBlID0gaSwgdGhpcy5obHMgPSBlLCB0aGlzLmZyYWdtZW50TG9hZGVyID0gbmV3IENiKGUuY29uZmlnKSwgdGhpcy5rZXlMb2FkZXIgPSByLCB0aGlzLmZyYWdtZW50VHJhY2tlciA9IHQsIHRoaXMuY29uZmlnID0gZS5jb25maWcsIHRoaXMuZGVjcnlwdGVyID0gbmV3IHZ1KGUuY29uZmlnKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHM6IGVcbiAgICB9ID0gdGhpcztcbiAgICBlLm9uKEkuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKSwgZS5vbihJLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKSwgZS5vbihJLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpLCBlLm9uKEkuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpLCBlLm9uKEkuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHM6IGVcbiAgICB9ID0gdGhpcztcbiAgICBlLm9mZihJLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyksIGUub2ZmKEkuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpLCBlLm9mZihJLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpLCBlLm9mZihJLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKSwgZS5vZmYoSS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICBkb1RpY2soKSB7XG4gICAgdGhpcy5vblRpY2tFbmQoKTtcbiAgfVxuICBvblRpY2tFbmQoKSB7XG4gIH1cbiAgc3RhcnRMb2FkKGUpIHtcbiAgfVxuICBzdG9wTG9hZCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gbmUuU1RPUFBFRClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmZyYWdtZW50TG9hZGVyLmFib3J0KCksIHRoaXMua2V5TG9hZGVyLmFib3J0KHRoaXMucGxheWxpc3RUeXBlKTtcbiAgICBjb25zdCBlID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBlICE9IG51bGwgJiYgZS5sb2FkZXIgJiYgKGUuYWJvcnRSZXF1ZXN0cygpLCB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChlKSksIHRoaXMucmVzZXRUcmFuc211eGVyKCksIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsLCB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGwsIHRoaXMuY2xlYXJJbnRlcnZhbCgpLCB0aGlzLmNsZWFyTmV4dFRpY2soKSwgdGhpcy5zdGF0ZSA9IG5lLlNUT1BQRUQ7XG4gIH1cbiAgZ2V0IHN0YXJ0UG9zaXRpb25WYWx1ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBuZXh0TG9hZFBvc2l0aW9uOiBlLFxuICAgICAgc3RhcnRQb3NpdGlvbjogdFxuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiB0ID09PSAtMSAmJiBlID8gZSA6IHQ7XG4gIH1cbiAgZ2V0IGJ1ZmZlcmluZ0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyaW5nO1xuICB9XG4gIHBhdXNlQnVmZmVyaW5nKCkge1xuICAgIHRoaXMuYnVmZmVyaW5nID0gITE7XG4gIH1cbiAgcmVzdW1lQnVmZmVyaW5nKCkge1xuICAgIHRoaXMuYnVmZmVyaW5nID0gITA7XG4gIH1cbiAgZ2V0IGluRmxpZ2h0RnJhZygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZnJhZzogdGhpcy5mcmFnQ3VycmVudCxcbiAgICAgIHN0YXRlOiB0aGlzLnN0YXRlXG4gICAgfTtcbiAgfVxuICBfc3RyZWFtRW5kZWQoZSwgdCkge1xuICAgIGlmICh0LmxpdmUgfHwgIXRoaXMubWVkaWEpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgciA9IGUuZW5kIHx8IDAsIG4gPSB0aGlzLmNvbmZpZy50aW1lbGluZU9mZnNldCB8fCAwO1xuICAgIGlmIChyIDw9IG4pXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgaSA9IGUuYnVmZmVyZWQ7XG4gICAgdGhpcy5jb25maWcubWF4QnVmZmVySG9sZSAmJiBpICYmIGkubGVuZ3RoID4gMSAmJiAoZSA9IENlLmJ1ZmZlcmVkSW5mbyhpLCBlLnN0YXJ0LCAwKSk7XG4gICAgY29uc3QgbyA9IGUubmV4dFN0YXJ0O1xuICAgIGlmIChvICYmIG8gPiBuICYmIG8gPCB0LmVkZ2UgfHwgdGhpcy5tZWRpYS5jdXJyZW50VGltZSA8IGUuc3RhcnQpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgbCA9IHQucGFydExpc3Q7XG4gICAgaWYgKGwgIT0gbnVsbCAmJiBsLmxlbmd0aCkge1xuICAgICAgY29uc3QgdSA9IGxbbC5sZW5ndGggLSAxXTtcbiAgICAgIHJldHVybiBDZS5pc0J1ZmZlcmVkKHRoaXMubWVkaWEsIHUuc3RhcnQgKyB1LmR1cmF0aW9uIC8gMik7XG4gICAgfVxuICAgIGNvbnN0IGMgPSB0LmZyYWdtZW50c1t0LmZyYWdtZW50cy5sZW5ndGggLSAxXS50eXBlO1xuICAgIHJldHVybiB0aGlzLmZyYWdtZW50VHJhY2tlci5pc0VuZExpc3RBcHBlbmRlZChjKTtcbiAgfVxuICBnZXRMZXZlbERldGFpbHMoKSB7XG4gICAgaWYgKHRoaXMubGV2ZWxzICYmIHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBudWxsKVxuICAgICAgcmV0dXJuIHRoaXMubGV2ZWxMYXN0TG9hZGVkLmRldGFpbHM7XG4gIH1cbiAgZ2V0IHRpbWVsaW5lT2Zmc2V0KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmNvbmZpZy50aW1lbGluZU9mZnNldDtcbiAgICBpZiAoZSkge1xuICAgICAgdmFyIHQ7XG4gICAgICByZXR1cm4gKCh0ID0gdGhpcy5nZXRMZXZlbERldGFpbHMoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IHQuYXBwbGllZFRpbWVsaW5lT2Zmc2V0KSB8fCBlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBvbk1lZGlhQXR0YWNoZWQoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLm1lZGlhID0gdGhpcy5tZWRpYUJ1ZmZlciA9IHQubWVkaWE7XG4gICAgY3IociwgXCJzZWVraW5nXCIsIHRoaXMub25NZWRpYVNlZWtpbmcpLCBjcihyLCBcImVuZGVkXCIsIHRoaXMub25NZWRpYUVuZGVkKTtcbiAgICBjb25zdCBuID0gdGhpcy5jb25maWc7XG4gICAgdGhpcy5sZXZlbHMgJiYgbi5hdXRvU3RhcnRMb2FkICYmIHRoaXMuc3RhdGUgPT09IG5lLlNUT1BQRUQgJiYgdGhpcy5zdGFydExvYWQobi5zdGFydFBvc2l0aW9uKTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKGUsIHQpIHtcbiAgICBjb25zdCByID0gISF0LnRyYW5zZmVyTWVkaWEsIG4gPSB0aGlzLm1lZGlhO1xuICAgIGlmIChuICE9PSBudWxsKSB7XG4gICAgICBpZiAobi5lbmRlZCAmJiAodGhpcy5sb2coXCJNU0UgZGV0YWNoaW5nIGFuZCB2aWRlbyBlbmRlZCwgcmVzZXQgc3RhcnRQb3NpdGlvblwiKSwgdGhpcy5zdGFydFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwKSwgcHIobiwgXCJzZWVraW5nXCIsIHRoaXMub25NZWRpYVNlZWtpbmcpLCBwcihuLCBcImVuZGVkXCIsIHRoaXMub25NZWRpYUVuZGVkKSwgdGhpcy5rZXlMb2FkZXIgJiYgIXIgJiYgdGhpcy5rZXlMb2FkZXIuZGV0YWNoKCksIHRoaXMubWVkaWEgPSB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbCwgdGhpcy5sb29wU24gPSB2b2lkIDAsIHIpIHtcbiAgICAgICAgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpLCB0aGlzLnJlc2V0VHJhbnNtdXhlcigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRpbmdQYXJ0cyA9ICExLCB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVBbGxGcmFnbWVudHMoKSwgdGhpcy5zdG9wTG9hZCgpO1xuICAgIH1cbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICB0aGlzLmluaXRQVFMgPSBbXSwgdGhpcy5sZXZlbHMgPSB0aGlzLmxldmVsTGFzdExvYWRlZCA9IHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsLCB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHRoaXMuc3RhcnRQb3NpdGlvbiA9IDAsIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gITE7XG4gIH1cbiAgb25FcnJvcihlLCB0KSB7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRlZChlLCB0KSB7XG4gICAgdGhpcy5zdGFydFRpbWVPZmZzZXQgPSB0LnN0YXJ0VGltZU9mZnNldDtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMuc3RvcExvYWQoKSwgdGhpcy50cmFuc211eGVyICYmICh0aGlzLnRyYW5zbXV4ZXIuZGVzdHJveSgpLCB0aGlzLnRyYW5zbXV4ZXIgPSBudWxsKSwgc3VwZXIub25IYW5kbGVyRGVzdHJveWluZygpLCB0aGlzLmhscyA9IHRoaXMub25NZWRpYVNlZWtpbmcgPSB0aGlzLm9uTWVkaWFFbmRlZCA9IG51bGw7XG4gIH1cbiAgb25IYW5kbGVyRGVzdHJveWVkKCkge1xuICAgIHRoaXMuc3RhdGUgPSBuZS5TVE9QUEVELCB0aGlzLmZyYWdtZW50TG9hZGVyICYmIHRoaXMuZnJhZ21lbnRMb2FkZXIuZGVzdHJveSgpLCB0aGlzLmtleUxvYWRlciAmJiB0aGlzLmtleUxvYWRlci5kZXN0cm95KCksIHRoaXMuZGVjcnlwdGVyICYmIHRoaXMuZGVjcnlwdGVyLmRlc3Ryb3koKSwgdGhpcy5obHMgPSB0aGlzLmxvZyA9IHRoaXMud2FybiA9IHRoaXMuZGVjcnlwdGVyID0gdGhpcy5rZXlMb2FkZXIgPSB0aGlzLmZyYWdtZW50TG9hZGVyID0gdGhpcy5mcmFnbWVudFRyYWNrZXIgPSBudWxsLCBzdXBlci5vbkhhbmRsZXJEZXN0cm95ZWQoKTtcbiAgfVxuICBsb2FkRnJhZ21lbnQoZSwgdCwgcikge1xuICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gITAsIHRoaXMuX2xvYWRGcmFnRm9yUGxheWJhY2soZSwgdCwgcik7XG4gIH1cbiAgX2xvYWRGcmFnRm9yUGxheWJhY2soZSwgdCwgcikge1xuICAgIGNvbnN0IG4gPSAoaSkgPT4ge1xuICAgICAgY29uc3QgbyA9IGkuZnJhZztcbiAgICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChvKSkge1xuICAgICAgICB0aGlzLndhcm4oYCR7by50eXBlfSBzbjogJHtvLnNufSR7aS5wYXJ0ID8gXCIgcGFydDogXCIgKyBpLnBhcnQuaW5kZXggOiBcIlwifSBvZiAke3RoaXMuZnJhZ0luZm8obywgITEsIGkucGFydCl9KSB3YXMgZHJvcHBlZCBkdXJpbmcgZG93bmxvYWQuYCksIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KG8pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBvLnN0YXRzLmNodW5rQ291bnQrKywgdGhpcy5faGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoaSk7XG4gICAgfTtcbiAgICB0aGlzLl9kb0ZyYWdMb2FkKGUsIHQsIHIsIG4pLnRoZW4oKGkpID0+IHtcbiAgICAgIGlmICghaSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbyA9IHRoaXMuc3RhdGUsIGEgPSBpLmZyYWc7XG4gICAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQoYSkpIHtcbiAgICAgICAgKG8gPT09IG5lLkZSQUdfTE9BRElORyB8fCAhdGhpcy5mcmFnQ3VycmVudCAmJiBvID09PSBuZS5QQVJTSU5HKSAmJiAodGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoYSksIHRoaXMuc3RhdGUgPSBuZS5JRExFKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXCJwYXlsb2FkXCIgaW4gaSAmJiAodGhpcy5sb2coYExvYWRlZCAke2EudHlwZX0gc246ICR7YS5zbn0gb2YgJHt0aGlzLnBsYXlsaXN0TGFiZWwoKX0gJHthLmxldmVsfWApLCB0aGlzLmhscy50cmlnZ2VyKEkuRlJBR19MT0FERUQsIGkpKSwgdGhpcy5faGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoaSk7XG4gICAgfSkuY2F0Y2goKGkpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUgPT09IG5lLlNUT1BQRUQgfHwgdGhpcy5zdGF0ZSA9PT0gbmUuRVJST1IgfHwgKHRoaXMud2FybihgRnJhZyBlcnJvcjogJHsoaSA9PSBudWxsID8gdm9pZCAwIDogaS5tZXNzYWdlKSB8fCBpfWApLCB0aGlzLnJlc2V0RnJhZ21lbnRMb2FkaW5nKGUpKTtcbiAgICB9KTtcbiAgfVxuICBjbGVhclRyYWNrZXJJZk5lZWRlZChlKSB7XG4gICAgdmFyIHQ7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ21lbnRUcmFja2VyOiByXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHIuZ2V0U3RhdGUoZSkgPT09IEh0LkFQUEVORElORykge1xuICAgICAgY29uc3QgaSA9IGUudHlwZSwgbyA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyLCBpKSwgYSA9IE1hdGgubWF4KGUuZHVyYXRpb24sIG8gPyBvLmxlbiA6IHRoaXMuY29uZmlnLm1heEJ1ZmZlckxlbmd0aCksIGwgPSB0aGlzLmJhY2t0cmFja0ZyYWdtZW50O1xuICAgICAgKChsID8gZS5zbiAtIGwuc24gOiAwKSA9PT0gMSB8fCB0aGlzLnJlZHVjZU1heEJ1ZmZlckxlbmd0aChhLCBlLmR1cmF0aW9uKSkgJiYgci5yZW1vdmVGcmFnbWVudChlKTtcbiAgICB9IGVsc2UgKCh0ID0gdGhpcy5tZWRpYUJ1ZmZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IHQuYnVmZmVyZWQubGVuZ3RoKSA9PT0gMCA/IHIucmVtb3ZlQWxsRnJhZ21lbnRzKCkgOiByLmhhc1BhcnRzKGUudHlwZSkgJiYgKHIuZGV0ZWN0UGFydGlhbEZyYWdtZW50cyh7XG4gICAgICBmcmFnOiBlLFxuICAgICAgcGFydDogbnVsbCxcbiAgICAgIHN0YXRzOiBlLnN0YXRzLFxuICAgICAgaWQ6IGUudHlwZVxuICAgIH0pLCByLmdldFN0YXRlKGUpID09PSBIdC5QQVJUSUFMICYmIHIucmVtb3ZlRnJhZ21lbnQoZSkpO1xuICB9XG4gIGNoZWNrTGl2ZVVwZGF0ZShlKSB7XG4gICAgaWYgKGUudXBkYXRlZCAmJiAhZS5saXZlKSB7XG4gICAgICBjb25zdCB0ID0gZS5mcmFnbWVudHNbZS5mcmFnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgICB0aGlzLmZyYWdtZW50VHJhY2tlci5kZXRlY3RQYXJ0aWFsRnJhZ21lbnRzKHtcbiAgICAgICAgZnJhZzogdCxcbiAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgc3RhdHM6IHQuc3RhdHMsXG4gICAgICAgIGlkOiB0LnR5cGVcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlLmZyYWdtZW50c1swXSB8fCAoZS5kZWx0YVVwZGF0ZUZhaWxlZCA9ICEwKTtcbiAgfVxuICB3YWl0Rm9yTGl2ZShlKSB7XG4gICAgY29uc3QgdCA9IGUuZGV0YWlscztcbiAgICByZXR1cm4gKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQubGl2ZSkgJiYgdC50eXBlICE9PSBcIkVWRU5UXCIgJiYgKHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBlIHx8IHQuZXhwaXJlZCk7XG4gIH1cbiAgZmx1c2hNYWluQnVmZmVyKGUsIHQsIHIgPSBudWxsKSB7XG4gICAgaWYgKCEoZSAtIHQpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG4gPSB7XG4gICAgICBzdGFydE9mZnNldDogZSxcbiAgICAgIGVuZE9mZnNldDogdCxcbiAgICAgIHR5cGU6IHJcbiAgICB9O1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoSS5CVUZGRVJfRkxVU0hJTkcsIG4pO1xuICB9XG4gIF9sb2FkSW5pdFNlZ21lbnQoZSwgdCkge1xuICAgIHRoaXMuX2RvRnJhZ0xvYWQoZSwgdCkudGhlbigocikgPT4ge1xuICAgICAgY29uc3QgbiA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuZnJhZztcbiAgICAgIGlmICghbiB8fCB0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChuKSB8fCAhdGhpcy5sZXZlbHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImluaXQgbG9hZCBhYm9ydGVkXCIpO1xuICAgICAgcmV0dXJuIHI7XG4gICAgfSkudGhlbigocikgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBobHM6IG5cbiAgICAgIH0gPSB0aGlzLCB7XG4gICAgICAgIGZyYWc6IGksXG4gICAgICAgIHBheWxvYWQ6IG9cbiAgICAgIH0gPSByLCBhID0gaS5kZWNyeXB0ZGF0YTtcbiAgICAgIGlmIChvICYmIG8uYnl0ZUxlbmd0aCA+IDAgJiYgYSAhPSBudWxsICYmIGEua2V5ICYmIGEuaXYgJiYgSW4oYS5tZXRob2QpKSB7XG4gICAgICAgIGNvbnN0IGwgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWNyeXB0ZXIuZGVjcnlwdChuZXcgVWludDhBcnJheShvKSwgYS5rZXkuYnVmZmVyLCBhLml2LmJ1ZmZlciwgU3UoYS5tZXRob2QpKS5jYXRjaCgoYykgPT4ge1xuICAgICAgICAgIHRocm93IG4udHJpZ2dlcihJLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiB2ZS5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEouRlJBR19ERUNSWVBUX0VSUk9SLFxuICAgICAgICAgICAgZmF0YWw6ICExLFxuICAgICAgICAgICAgZXJyb3I6IGMsXG4gICAgICAgICAgICByZWFzb246IGMubWVzc2FnZSxcbiAgICAgICAgICAgIGZyYWc6IGlcbiAgICAgICAgICB9KSwgYztcbiAgICAgICAgfSkudGhlbigoYykgPT4ge1xuICAgICAgICAgIGNvbnN0IHUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgIHJldHVybiBuLnRyaWdnZXIoSS5GUkFHX0RFQ1JZUFRFRCwge1xuICAgICAgICAgICAgZnJhZzogaSxcbiAgICAgICAgICAgIHBheWxvYWQ6IGMsXG4gICAgICAgICAgICBzdGF0czoge1xuICAgICAgICAgICAgICB0c3RhcnQ6IGwsXG4gICAgICAgICAgICAgIHRkZWNyeXB0OiB1XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIHIucGF5bG9hZCA9IGMsIHRoaXMuY29tcGxldGVJbml0U2VnbWVudExvYWQocik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGVJbml0U2VnbWVudExvYWQocik7XG4gICAgfSkuY2F0Y2goKHIpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUgPT09IG5lLlNUT1BQRUQgfHwgdGhpcy5zdGF0ZSA9PT0gbmUuRVJST1IgfHwgKHRoaXMud2FybihyKSwgdGhpcy5yZXNldEZyYWdtZW50TG9hZGluZyhlKSk7XG4gICAgfSk7XG4gIH1cbiAgY29tcGxldGVJbml0U2VnbWVudExvYWQoZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxldmVsczogdFxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghdClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImluaXQgbG9hZCBhYm9ydGVkLCBtaXNzaW5nIGxldmVsc1wiKTtcbiAgICBjb25zdCByID0gZS5mcmFnLnN0YXRzO1xuICAgIHRoaXMuc3RhdGUgIT09IG5lLlNUT1BQRUQgJiYgKHRoaXMuc3RhdGUgPSBuZS5JRExFKSwgZS5mcmFnLmRhdGEgPSBuZXcgVWludDhBcnJheShlLnBheWxvYWQpLCByLnBhcnNpbmcuc3RhcnQgPSByLmJ1ZmZlcmluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHIucGFyc2luZy5lbmQgPSByLmJ1ZmZlcmluZy5lbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCB0aGlzLnRpY2soKTtcbiAgfVxuICB1bmhhbmRsZWRFbmNyeXB0aW9uRXJyb3IoZSwgdCkge1xuICAgIHZhciByLCBuO1xuICAgIGNvbnN0IGkgPSBlLnRyYWNrcztcbiAgICBpZiAoaSAmJiAhdC5lbmNyeXB0ZWQgJiYgKChyID0gaS5hdWRpbykgIT0gbnVsbCAmJiByLmVuY3J5cHRlZCB8fCAobiA9IGkudmlkZW8pICE9IG51bGwgJiYgbi5lbmNyeXB0ZWQpICYmICghdGhpcy5jb25maWcuZW1lRW5hYmxlZCB8fCAhdGhpcy5rZXlMb2FkZXIuZW1lQ29udHJvbGxlcikpIHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLm1lZGlhLCBhID0gbmV3IEVycm9yKGBFbmNyeXB0ZWQgdHJhY2sgd2l0aCBubyBrZXkgaW4gJHt0aGlzLmZyYWdJbmZvKHQpfSAobWVkaWEgJHtvID8gXCJhdHRhY2hlZCBtZWRpYUtleXM6IFwiICsgby5tZWRpYUtleXMgOiBcImRldGFjaGVkXCJ9KWApO1xuICAgICAgcmV0dXJuIHRoaXMud2FybihhLm1lc3NhZ2UpLCAhbyB8fCBvLm1lZGlhS2V5cyA/ICExIDogKHRoaXMuaGxzLnRyaWdnZXIoSS5FUlJPUiwge1xuICAgICAgICB0eXBlOiB2ZS5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBKLktFWV9TWVNURU1fTk9fS0VZUyxcbiAgICAgICAgZmF0YWw6ICExLFxuICAgICAgICBlcnJvcjogYSxcbiAgICAgICAgZnJhZzogdFxuICAgICAgfSksIHRoaXMucmVzZXRUcmFuc211eGVyKCksICEwKTtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGZyYWdDb250ZXh0Q2hhbmdlZChlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ0N1cnJlbnQ6IHRcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gIWUgfHwgIXQgfHwgZS5zbiAhPT0gdC5zbiB8fCBlLmxldmVsICE9PSB0LmxldmVsO1xuICB9XG4gIGZyYWdCdWZmZXJlZENvbXBsZXRlKGUsIHQpIHtcbiAgICBjb25zdCByID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgIGlmICh0aGlzLmxvZyhgQnVmZmVyZWQgJHtlLnR5cGV9IHNuOiAke2Uuc259JHt0ID8gXCIgcGFydDogXCIgKyB0LmluZGV4IDogXCJcIn0gb2YgJHt0aGlzLmZyYWdJbmZvKGUsICExLCB0KX0gPiBidWZmZXI6JHtyID8gc1QudG9TdHJpbmcoQ2UuZ2V0QnVmZmVyZWQocikpIDogXCIoZGV0YWNoZWQpXCJ9KWApLCBWdChlKSkge1xuICAgICAgdmFyIG47XG4gICAgICBpZiAoZS50eXBlICE9PSBwZS5TVUJUSVRMRSkge1xuICAgICAgICBjb25zdCBvID0gZS5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICAgICAgaWYgKCFPYmplY3Qua2V5cyhvKS5zb21lKChhKSA9PiAhIW9bYV0pKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IG5lLklETEU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBpID0gKG4gPSB0aGlzLmxldmVscykgPT0gbnVsbCA/IHZvaWQgMCA6IG5bZS5sZXZlbF07XG4gICAgICBpICE9IG51bGwgJiYgaS5mcmFnbWVudEVycm9yICYmICh0aGlzLmxvZyhgUmVzZXR0aW5nIGxldmVsIGZyYWdtZW50IGVycm9yIGNvdW50IG9mICR7aS5mcmFnbWVudEVycm9yfSBvbiBmcmFnIGJ1ZmZlcmVkYCksIGkuZnJhZ21lbnRFcnJvciA9IDApO1xuICAgIH1cbiAgICB0aGlzLnN0YXRlID0gbmUuSURMRTtcbiAgfVxuICBfaGFuZGxlRnJhZ21lbnRMb2FkQ29tcGxldGUoZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRyYW5zbXV4ZXI6IHRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgZnJhZzogcixcbiAgICAgIHBhcnQ6IG4sXG4gICAgICBwYXJ0c0xvYWRlZDogaVxuICAgIH0gPSBlLCBvID0gIWkgfHwgaS5sZW5ndGggPT09IDAgfHwgaS5zb21lKChsKSA9PiAhbCksIGEgPSBuZXcgRXUoci5sZXZlbCwgci5zbiwgci5zdGF0cy5jaHVua0NvdW50ICsgMSwgMCwgbiA/IG4uaW5kZXggOiAtMSwgIW8pO1xuICAgIHQuZmx1c2goYSk7XG4gIH1cbiAgX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGUpIHtcbiAgfVxuICBfZG9GcmFnTG9hZChlLCB0LCByID0gbnVsbCwgbikge1xuICAgIHZhciBpO1xuICAgIHRoaXMuZnJhZ0N1cnJlbnQgPSBlO1xuICAgIGNvbnN0IG8gPSB0LmRldGFpbHM7XG4gICAgaWYgKCF0aGlzLmxldmVscyB8fCAhbylcbiAgICAgIHRocm93IG5ldyBFcnJvcihgZnJhZyBsb2FkIGFib3J0ZWQsIG1pc3NpbmcgbGV2ZWwke28gPyBcIlwiIDogXCIgZGV0YWlsXCJ9c2ApO1xuICAgIGxldCBhID0gbnVsbDtcbiAgICBpZiAoZS5lbmNyeXB0ZWQgJiYgISgoaSA9IGUuZGVjcnlwdGRhdGEpICE9IG51bGwgJiYgaS5rZXkpKSB7XG4gICAgICBpZiAodGhpcy5sb2coYExvYWRpbmcga2V5IGZvciAke2Uuc259IG9mIFske28uc3RhcnRTTn0tJHtvLmVuZFNOfV0sICR7dGhpcy5wbGF5bGlzdExhYmVsKCl9ICR7ZS5sZXZlbH1gKSwgdGhpcy5zdGF0ZSA9IG5lLktFWV9MT0FESU5HLCB0aGlzLmZyYWdDdXJyZW50ID0gZSwgYSA9IHRoaXMua2V5TG9hZGVyLmxvYWQoZSkudGhlbigoaCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGguZnJhZykpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGxzLnRyaWdnZXIoSS5LRVlfTE9BREVELCBoKSwgdGhpcy5zdGF0ZSA9PT0gbmUuS0VZX0xPQURJTkcgJiYgKHRoaXMuc3RhdGUgPSBuZS5JRExFKSwgaDtcbiAgICAgIH0pLCB0aGlzLmhscy50cmlnZ2VyKEkuS0VZX0xPQURJTkcsIHtcbiAgICAgICAgZnJhZzogZVxuICAgICAgfSksIHRoaXMuZnJhZ0N1cnJlbnQgPT09IG51bGwpXG4gICAgICAgIHJldHVybiB0aGlzLmxvZyhcImNvbnRleHQgY2hhbmdlZCBpbiBLRVlfTE9BRElOR1wiKSwgUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuICAgIH0gZWxzZSBlLmVuY3J5cHRlZCB8fCAoYSA9IHRoaXMua2V5TG9hZGVyLmxvYWRDbGVhcihlLCBvLmVuY3J5cHRlZEZyYWdtZW50cywgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQpLCBhICYmIHRoaXMubG9nKFwiW2VtZV0gYmxvY2tpbmcgZnJhZyBsb2FkIHVudGlsIG1lZGlhLWtleXMgYWNxdWlyZWRcIikpO1xuICAgIGNvbnN0IGwgPSB0aGlzLmZyYWdQcmV2aW91cztcbiAgICBpZiAoVnQoZSkgJiYgKCFsIHx8IGUuc24gIT09IGwuc24pKSB7XG4gICAgICBjb25zdCBoID0gdGhpcy5zaG91bGRMb2FkUGFydHModC5kZXRhaWxzLCBlLmVuZCk7XG4gICAgICBoICE9PSB0aGlzLmxvYWRpbmdQYXJ0cyAmJiAodGhpcy5sb2coYExMLVBhcnQgbG9hZGluZyAke2ggPyBcIk9OXCIgOiBcIk9GRlwifSBsb2FkaW5nIHNuICR7bCA9PSBudWxsID8gdm9pZCAwIDogbC5zbn0tPiR7ZS5zbn1gKSwgdGhpcy5sb2FkaW5nUGFydHMgPSBoKTtcbiAgICB9XG4gICAgaWYgKHIgPSBNYXRoLm1heChlLnN0YXJ0LCByIHx8IDApLCB0aGlzLmxvYWRpbmdQYXJ0cyAmJiBWdChlKSkge1xuICAgICAgY29uc3QgaCA9IG8ucGFydExpc3Q7XG4gICAgICBpZiAoaCAmJiBuKSB7XG4gICAgICAgIHIgPiBvLmZyYWdtZW50RW5kICYmIG8uZnJhZ21lbnRIaW50ICYmIChlID0gby5mcmFnbWVudEhpbnQpO1xuICAgICAgICBjb25zdCBmID0gdGhpcy5nZXROZXh0UGFydChoLCBlLCByKTtcbiAgICAgICAgaWYgKGYgPiAtMSkge1xuICAgICAgICAgIGNvbnN0IHAgPSBoW2ZdO1xuICAgICAgICAgIGUgPSB0aGlzLmZyYWdDdXJyZW50ID0gcC5mcmFnbWVudCwgdGhpcy5sb2coYExvYWRpbmcgJHtlLnR5cGV9IHNuOiAke2Uuc259IHBhcnQ6ICR7cC5pbmRleH0gKCR7Zn0vJHtoLmxlbmd0aCAtIDF9KSBvZiAke3RoaXMuZnJhZ0luZm8oZSwgITEsIHApfSkgY2M6ICR7ZS5jY30gWyR7by5zdGFydFNOfS0ke28uZW5kU059XSwgdGFyZ2V0OiAke3BhcnNlRmxvYXQoci50b0ZpeGVkKDMpKX1gKSwgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gcC5zdGFydCArIHAuZHVyYXRpb24sIHRoaXMuc3RhdGUgPSBuZS5GUkFHX0xPQURJTkc7XG4gICAgICAgICAgbGV0IHk7XG4gICAgICAgICAgcmV0dXJuIGEgPyB5ID0gYS50aGVuKChFKSA9PiAhRSB8fCB0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChFLmZyYWcpID8gbnVsbCA6IHRoaXMuZG9GcmFnUGFydHNMb2FkKGUsIHAsIHQsIG4pKS5jYXRjaCgoRSkgPT4gdGhpcy5oYW5kbGVGcmFnTG9hZEVycm9yKEUpKSA6IHkgPSB0aGlzLmRvRnJhZ1BhcnRzTG9hZChlLCBwLCB0LCBuKS5jYXRjaCgoRSkgPT4gdGhpcy5oYW5kbGVGcmFnTG9hZEVycm9yKEUpKSwgdGhpcy5obHMudHJpZ2dlcihJLkZSQUdfTE9BRElORywge1xuICAgICAgICAgICAgZnJhZzogZSxcbiAgICAgICAgICAgIHBhcnQ6IHAsXG4gICAgICAgICAgICB0YXJnZXRCdWZmZXJUaW1lOiByXG4gICAgICAgICAgfSksIHRoaXMuZnJhZ0N1cnJlbnQgPT09IG51bGwgPyBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJmcmFnIGxvYWQgYWJvcnRlZCwgY29udGV4dCBjaGFuZ2VkIGluIEZSQUdfTE9BRElORyBwYXJ0c1wiKSkgOiB5O1xuICAgICAgICB9IGVsc2UgaWYgKCFlLnVybCB8fCB0aGlzLmxvYWRlZEVuZE9mUGFydHMoaCwgcikpXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKFZ0KGUpICYmIHRoaXMubG9hZGluZ1BhcnRzKSB7XG4gICAgICB2YXIgYztcbiAgICAgIHRoaXMubG9nKGBMTC1QYXJ0IGxvYWRpbmcgT0ZGIGFmdGVyIG5leHQgcGFydCBtaXNzIEAke3IudG9GaXhlZCgyKX0gQ2hlY2sgYnVmZmVyIGF0IHNuOiAke2Uuc259IGxvYWRlZCBwYXJ0czogJHsoYyA9IG8ucGFydExpc3QpID09IG51bGwgPyB2b2lkIDAgOiBjLmZpbHRlcigoaCkgPT4gaC5sb2FkZWQpLm1hcCgoaCkgPT4gYFske2guc3RhcnR9LSR7aC5lbmR9XWApfWApLCB0aGlzLmxvYWRpbmdQYXJ0cyA9ICExO1xuICAgIH0gZWxzZSBpZiAoIWUudXJsKVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB0aGlzLmxvZyhgTG9hZGluZyAke2UudHlwZX0gc246ICR7ZS5zbn0gb2YgJHt0aGlzLmZyYWdJbmZvKGUsICExKX0pIGNjOiAke2UuY2N9ICR7XCJbXCIgKyBvLnN0YXJ0U04gKyBcIi1cIiArIG8uZW5kU04gKyBcIl1cIn0sIHRhcmdldDogJHtwYXJzZUZsb2F0KHIudG9GaXhlZCgzKSl9YCksIHVlKGUuc24pICYmICF0aGlzLmJpdHJhdGVUZXN0ICYmICh0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBlLnN0YXJ0ICsgZS5kdXJhdGlvbiksIHRoaXMuc3RhdGUgPSBuZS5GUkFHX0xPQURJTkc7XG4gICAgY29uc3QgdSA9IHRoaXMuY29uZmlnLnByb2dyZXNzaXZlO1xuICAgIGxldCBkO1xuICAgIHJldHVybiB1ICYmIGEgPyBkID0gYS50aGVuKChoKSA9PiAhaCB8fCB0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChoLmZyYWcpID8gbnVsbCA6IHRoaXMuZnJhZ21lbnRMb2FkZXIubG9hZChlLCBuKSkuY2F0Y2goKGgpID0+IHRoaXMuaGFuZGxlRnJhZ0xvYWRFcnJvcihoKSkgOiBkID0gUHJvbWlzZS5hbGwoW3RoaXMuZnJhZ21lbnRMb2FkZXIubG9hZChlLCB1ID8gbiA6IHZvaWQgMCksIGFdKS50aGVuKChbaF0pID0+ICghdSAmJiBuICYmIG4oaCksIGgpKS5jYXRjaCgoaCkgPT4gdGhpcy5oYW5kbGVGcmFnTG9hZEVycm9yKGgpKSwgdGhpcy5obHMudHJpZ2dlcihJLkZSQUdfTE9BRElORywge1xuICAgICAgZnJhZzogZSxcbiAgICAgIHRhcmdldEJ1ZmZlclRpbWU6IHJcbiAgICB9KSwgdGhpcy5mcmFnQ3VycmVudCA9PT0gbnVsbCA/IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcImZyYWcgbG9hZCBhYm9ydGVkLCBjb250ZXh0IGNoYW5nZWQgaW4gRlJBR19MT0FESU5HXCIpKSA6IGQ7XG4gIH1cbiAgZG9GcmFnUGFydHNMb2FkKGUsIHQsIHIsIG4pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKGksIG8pID0+IHtcbiAgICAgIHZhciBhO1xuICAgICAgY29uc3QgbCA9IFtdLCBjID0gKGEgPSByLmRldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiBhLnBhcnRMaXN0LCB1ID0gKGQpID0+IHtcbiAgICAgICAgdGhpcy5mcmFnbWVudExvYWRlci5sb2FkUGFydChlLCBkLCBuKS50aGVuKChoKSA9PiB7XG4gICAgICAgICAgbFtkLmluZGV4XSA9IGg7XG4gICAgICAgICAgY29uc3QgZiA9IGgucGFydDtcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEkuRlJBR19MT0FERUQsIGgpO1xuICAgICAgICAgIGNvbnN0IHAgPSBQaChyLmRldGFpbHMsIGUuc24sIGQuaW5kZXggKyAxKSB8fCB0cChjLCBlLnNuLCBkLmluZGV4ICsgMSk7XG4gICAgICAgICAgaWYgKHApXG4gICAgICAgICAgICB1KHApO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBpKHtcbiAgICAgICAgICAgICAgZnJhZzogZSxcbiAgICAgICAgICAgICAgcGFydDogZixcbiAgICAgICAgICAgICAgcGFydHNMb2FkZWQ6IGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS5jYXRjaChvKTtcbiAgICAgIH07XG4gICAgICB1KHQpO1xuICAgIH0pO1xuICB9XG4gIGhhbmRsZUZyYWdMb2FkRXJyb3IoZSkge1xuICAgIGlmIChcImRhdGFcIiBpbiBlKSB7XG4gICAgICBjb25zdCB0ID0gZS5kYXRhO1xuICAgICAgdC5mcmFnICYmIHQuZGV0YWlscyA9PT0gSi5JTlRFUk5BTF9BQk9SVEVEID8gdGhpcy5oYW5kbGVGcmFnTG9hZEFib3J0ZWQodC5mcmFnLCB0LnBhcnQpIDogdC5mcmFnICYmIHQudHlwZSA9PT0gdmUuS0VZX1NZU1RFTV9FUlJPUiA/ICh0LmZyYWcuYWJvcnRSZXF1ZXN0cygpLCB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKCksIHRoaXMucmVzZXRGcmFnbWVudExvYWRpbmcodC5mcmFnKSkgOiB0aGlzLmhscy50cmlnZ2VyKEkuRVJST1IsIHQpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5obHMudHJpZ2dlcihJLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IHZlLk9USEVSX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBKLklOVEVSTkFMX0VYQ0VQVElPTixcbiAgICAgICAgZXJyOiBlLFxuICAgICAgICBlcnJvcjogZSxcbiAgICAgICAgZmF0YWw6ICEwXG4gICAgICB9KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBfaGFuZGxlVHJhbnNtdXhlckZsdXNoKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRDdXJyZW50Q29udGV4dChlKTtcbiAgICBpZiAoIXQgfHwgdGhpcy5zdGF0ZSAhPT0gbmUuUEFSU0lORykge1xuICAgICAgIXRoaXMuZnJhZ0N1cnJlbnQgJiYgdGhpcy5zdGF0ZSAhPT0gbmUuU1RPUFBFRCAmJiB0aGlzLnN0YXRlICE9PSBuZS5FUlJPUiAmJiAodGhpcy5zdGF0ZSA9IG5lLklETEUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBmcmFnOiByLFxuICAgICAgcGFydDogbixcbiAgICAgIGxldmVsOiBpXG4gICAgfSA9IHQsIG8gPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHIuc3RhdHMucGFyc2luZy5lbmQgPSBvLCBuICYmIChuLnN0YXRzLnBhcnNpbmcuZW5kID0gbyk7XG4gICAgY29uc3QgYSA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCksIGMgPSBhICYmIHIuc24gPiBhLmVuZFNOIHx8IHRoaXMuc2hvdWxkTG9hZFBhcnRzKGEsIHIuZW5kKTtcbiAgICBjICE9PSB0aGlzLmxvYWRpbmdQYXJ0cyAmJiAodGhpcy5sb2coYExMLVBhcnQgbG9hZGluZyAke2MgPyBcIk9OXCIgOiBcIk9GRlwifSBhZnRlciBwYXJzaW5nIHNlZ21lbnQgZW5kaW5nIEAke3IuZW5kLnRvRml4ZWQoMil9YCksIHRoaXMubG9hZGluZ1BhcnRzID0gYyksIHRoaXMudXBkYXRlTGV2ZWxUaW1pbmcociwgbiwgaSwgZS5wYXJ0aWFsKTtcbiAgfVxuICBzaG91bGRMb2FkUGFydHMoZSwgdCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSkge1xuICAgICAgaWYgKCFlKVxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkaW5nUGFydHM7XG4gICAgICBpZiAoZS5wYXJ0TGlzdCkge1xuICAgICAgICB2YXIgcjtcbiAgICAgICAgY29uc3QgaSA9IGUucGFydExpc3RbMF07XG4gICAgICAgIGlmIChpLmZyYWdtZW50LnR5cGUgPT09IHBlLlNVQlRJVExFKVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgY29uc3QgbyA9IGkuZW5kICsgKCgociA9IGUuZnJhZ21lbnRIaW50KSA9PSBudWxsID8gdm9pZCAwIDogci5kdXJhdGlvbikgfHwgMCk7XG4gICAgICAgIGlmICh0ID49IG8pIHtcbiAgICAgICAgICB2YXIgbjtcbiAgICAgICAgICBpZiAoKHRoaXMuaGxzLmhhc0Vub3VnaFRvU3RhcnQgPyAoKG4gPSB0aGlzLm1lZGlhKSA9PSBudWxsID8gdm9pZCAwIDogbi5jdXJyZW50VGltZSkgfHwgdGhpcy5sYXN0Q3VycmVudFRpbWUgOiB0aGlzLmdldExvYWRQb3NpdGlvbigpKSA+IGkuc3RhcnQgLSBpLmZyYWdtZW50LmR1cmF0aW9uKVxuICAgICAgICAgICAgcmV0dXJuICEwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBnZXRDdXJyZW50Q29udGV4dChlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzOiB0LFxuICAgICAgZnJhZ0N1cnJlbnQ6IHJcbiAgICB9ID0gdGhpcywge1xuICAgICAgbGV2ZWw6IG4sXG4gICAgICBzbjogaSxcbiAgICAgIHBhcnQ6IG9cbiAgICB9ID0gZTtcbiAgICBpZiAoISh0ICE9IG51bGwgJiYgdFtuXSkpXG4gICAgICByZXR1cm4gdGhpcy53YXJuKGBMZXZlbHMgb2JqZWN0IHdhcyB1bnNldCB3aGlsZSBidWZmZXJpbmcgZnJhZ21lbnQgJHtpfSBvZiAke3RoaXMucGxheWxpc3RMYWJlbCgpfSAke259LiBUaGUgY3VycmVudCBjaHVuayB3aWxsIG5vdCBiZSBidWZmZXJlZC5gKSwgbnVsbDtcbiAgICBjb25zdCBhID0gdFtuXSwgbCA9IGEuZGV0YWlscywgYyA9IG8gPiAtMSA/IFBoKGwsIGksIG8pIDogbnVsbCwgdSA9IGMgPyBjLmZyYWdtZW50IDogZXAobCwgaSwgcik7XG4gICAgcmV0dXJuIHUgPyAociAmJiByICE9PSB1ICYmICh1LnN0YXRzID0gci5zdGF0cyksIHtcbiAgICAgIGZyYWc6IHUsXG4gICAgICBwYXJ0OiBjLFxuICAgICAgbGV2ZWw6IGFcbiAgICB9KSA6IG51bGw7XG4gIH1cbiAgYnVmZmVyRnJhZ21lbnREYXRhKGUsIHQsIHIsIG4sIGkpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSAhPT0gbmUuUEFSU0lORylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBkYXRhMTogbyxcbiAgICAgIGRhdGEyOiBhXG4gICAgfSA9IGU7XG4gICAgbGV0IGwgPSBvO1xuICAgIGlmIChhICYmIChsID0gX3IobywgYSkpLCAhbC5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYyA9IHRoaXMuaW5pdFBUU1t0LmNjXSwgdSA9IGMgPyAtYy5iYXNlVGltZSAvIGMudGltZXNjYWxlIDogdm9pZCAwLCBkID0ge1xuICAgICAgdHlwZTogZS50eXBlLFxuICAgICAgZnJhZzogdCxcbiAgICAgIHBhcnQ6IHIsXG4gICAgICBjaHVua01ldGE6IG4sXG4gICAgICBvZmZzZXQ6IHUsXG4gICAgICBwYXJlbnQ6IHQudHlwZSxcbiAgICAgIGRhdGE6IGxcbiAgICB9O1xuICAgIGlmICh0aGlzLmhscy50cmlnZ2VyKEkuQlVGRkVSX0FQUEVORElORywgZCksIGUuZHJvcHBlZCAmJiBlLmluZGVwZW5kZW50ICYmICFyKSB7XG4gICAgICBpZiAoaSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5mbHVzaEJ1ZmZlckdhcCh0KTtcbiAgICB9XG4gIH1cbiAgZmx1c2hCdWZmZXJHYXAoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLm1lZGlhO1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICBpZiAoIUNlLmlzQnVmZmVyZWQodCwgdC5jdXJyZW50VGltZSkpIHtcbiAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIGUuc3RhcnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByID0gdC5jdXJyZW50VGltZSwgbiA9IENlLmJ1ZmZlckluZm8odCwgciwgMCksIGkgPSBlLmR1cmF0aW9uLCBvID0gTWF0aC5taW4odGhpcy5jb25maWcubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAqIDIsIGkgKiAwLjI1KSwgYSA9IE1hdGgubWF4KE1hdGgubWluKGUuc3RhcnQgLSBvLCBuLmVuZCAtIG8pLCByICsgbyk7XG4gICAgZS5zdGFydCAtIGEgPiBvICYmIHRoaXMuZmx1c2hNYWluQnVmZmVyKGEsIGUuc3RhcnQpO1xuICB9XG4gIGdldEZ3ZEJ1ZmZlckluZm8oZSwgdCkge1xuICAgIHZhciByO1xuICAgIGNvbnN0IG4gPSB0aGlzLmdldExvYWRQb3NpdGlvbigpO1xuICAgIGlmICghdWUobikpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBvID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPiBuIHx8IChyID0gdGhpcy5tZWRpYSkgIT0gbnVsbCAmJiByLnBhdXNlZCA/IDAgOiB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlO1xuICAgIHJldHVybiB0aGlzLmdldEZ3ZEJ1ZmZlckluZm9BdFBvcyhlLCBuLCB0LCBvKTtcbiAgfVxuICBnZXRGd2RCdWZmZXJJbmZvQXRQb3MoZSwgdCwgciwgbikge1xuICAgIGNvbnN0IGkgPSBDZS5idWZmZXJJbmZvKGUsIHQsIG4pO1xuICAgIGlmIChpLmxlbiA9PT0gMCAmJiBpLm5leHRTdGFydCAhPT0gdm9pZCAwKSB7XG4gICAgICBjb25zdCBvID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QnVmZmVyZWRGcmFnKHQsIHIpO1xuICAgICAgaWYgKG8gJiYgKGkubmV4dFN0YXJ0IDw9IG8uZW5kIHx8IG8uZ2FwKSkge1xuICAgICAgICBjb25zdCBhID0gTWF0aC5tYXgoTWF0aC5taW4oaS5uZXh0U3RhcnQsIG8uZW5kKSAtIHQsIG4pO1xuICAgICAgICByZXR1cm4gQ2UuYnVmZmVySW5mbyhlLCB0LCBhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgZ2V0TWF4QnVmZmVyTGVuZ3RoKGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWc6IHRcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgcjtcbiAgICByZXR1cm4gZSA/IHIgPSBNYXRoLm1heCg4ICogdC5tYXhCdWZmZXJTaXplIC8gZSwgdC5tYXhCdWZmZXJMZW5ndGgpIDogciA9IHQubWF4QnVmZmVyTGVuZ3RoLCBNYXRoLm1pbihyLCB0Lm1heE1heEJ1ZmZlckxlbmd0aCk7XG4gIH1cbiAgcmVkdWNlTWF4QnVmZmVyTGVuZ3RoKGUsIHQpIHtcbiAgICBjb25zdCByID0gdGhpcy5jb25maWcsIG4gPSBNYXRoLm1heChNYXRoLm1pbihlIC0gdCwgci5tYXhCdWZmZXJMZW5ndGgpLCB0KSwgaSA9IE1hdGgubWF4KGUgLSB0ICogMywgci5tYXhNYXhCdWZmZXJMZW5ndGggLyAyLCBuKTtcbiAgICByZXR1cm4gaSA+PSBuID8gKHIubWF4TWF4QnVmZmVyTGVuZ3RoID0gaSwgdGhpcy53YXJuKGBSZWR1Y2UgbWF4IGJ1ZmZlciBsZW5ndGggdG8gJHtpfXNgKSwgITApIDogITE7XG4gIH1cbiAgZ2V0QXBwZW5kZWRGcmFnKGUsIHQgPSBwZS5NQUlOKSB7XG4gICAgY29uc3QgciA9IHRoaXMuZnJhZ21lbnRUcmFja2VyID8gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKGUsIHQpIDogbnVsbDtcbiAgICByZXR1cm4gciAmJiBcImZyYWdtZW50XCIgaW4gciA/IHIuZnJhZ21lbnQgOiByO1xuICB9XG4gIGdldE5leHRGcmFnbWVudChlLCB0KSB7XG4gICAgY29uc3QgciA9IHQuZnJhZ21lbnRzLCBuID0gci5sZW5ndGg7XG4gICAgaWYgKCFuKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnOiBpXG4gICAgfSA9IHRoaXMsIG8gPSByWzBdLnN0YXJ0LCBhID0gaS5sb3dMYXRlbmN5TW9kZSAmJiAhIXQucGFydExpc3Q7XG4gICAgbGV0IGwgPSBudWxsO1xuICAgIGlmICh0LmxpdmUpIHtcbiAgICAgIGNvbnN0IGQgPSBpLmluaXRpYWxMaXZlTWFuaWZlc3RTaXplO1xuICAgICAgaWYgKG4gPCBkKVxuICAgICAgICByZXR1cm4gdGhpcy53YXJuKGBOb3QgZW5vdWdoIGZyYWdtZW50cyB0byBzdGFydCBwbGF5YmFjayAoaGF2ZTogJHtufSwgbmVlZDogJHtkfSlgKSwgbnVsbDtcbiAgICAgIGlmICghdC5QVFNLbm93biAmJiAhdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgdGhpcy5zdGFydFBvc2l0aW9uID09PSAtMSB8fCBlIDwgbykge1xuICAgICAgICB2YXIgYztcbiAgICAgICAgYSAmJiAhdGhpcy5sb2FkaW5nUGFydHMgJiYgKHRoaXMubG9nKFwiTEwtUGFydCBsb2FkaW5nIE9OIGZvciBpbml0aWFsIGxpdmUgZnJhZ21lbnRcIiksIHRoaXMubG9hZGluZ1BhcnRzID0gITApLCBsID0gdGhpcy5nZXRJbml0aWFsTGl2ZUZyYWdtZW50KHQpO1xuICAgICAgICBjb25zdCBoID0gdGhpcy5obHMuc3RhcnRQb3NpdGlvbiwgZiA9IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb24sIHAgPSBsID8gKGggIT09IC0xICYmIGggPj0gbyA/IGggOiBmKSB8fCBsLnN0YXJ0IDogZTtcbiAgICAgICAgdGhpcy5sb2coYFNldHRpbmcgc3RhcnRQb3NpdGlvbiB0byAke3B9IHRvIG1hdGNoIHN0YXJ0IGZyYWcgYXQgbGl2ZSBlZGdlLiBtYWluU3RhcnQ6ICR7aH0gbGl2ZVN5bmNQb3NpdGlvbjogJHtmfSBmcmFnLnN0YXJ0OiAkeyhjID0gbCkgPT0gbnVsbCA/IHZvaWQgMCA6IGMuc3RhcnR9YCksIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHA7XG4gICAgICB9XG4gICAgfSBlbHNlIGUgPD0gbyAmJiAobCA9IHJbMF0pO1xuICAgIGlmICghbCkge1xuICAgICAgY29uc3QgZCA9IHRoaXMubG9hZGluZ1BhcnRzID8gdC5wYXJ0RW5kIDogdC5mcmFnbWVudEVuZDtcbiAgICAgIGwgPSB0aGlzLmdldEZyYWdtZW50QXRQb3NpdGlvbihlLCBkLCB0KTtcbiAgICB9XG4gICAgbGV0IHUgPSB0aGlzLmZpbHRlclJlcGxhY2VkUHJpbWFyeShsLCB0KTtcbiAgICBpZiAoIXUgJiYgbCkge1xuICAgICAgY29uc3QgZCA9IGwuc24gLSB0LnN0YXJ0U047XG4gICAgICB1ID0gdGhpcy5maWx0ZXJSZXBsYWNlZFByaW1hcnkocltkICsgMV0gfHwgbnVsbCwgdCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1hcFRvSW5pdEZyYWdXaGVuUmVxdWlyZWQodSk7XG4gIH1cbiAgaXNMb29wTG9hZGluZyhlLCB0KSB7XG4gICAgY29uc3QgciA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGUpO1xuICAgIHJldHVybiAociA9PT0gSHQuT0sgfHwgciA9PT0gSHQuUEFSVElBTCAmJiAhIWUuZ2FwKSAmJiB0aGlzLm5leHRMb2FkUG9zaXRpb24gPiB0O1xuICB9XG4gIGdldE5leHRGcmFnbWVudExvb3BMb2FkaW5nKGUsIHQsIHIsIG4sIGkpIHtcbiAgICBsZXQgbyA9IG51bGw7XG4gICAgaWYgKGUuZ2FwICYmIChvID0gdGhpcy5nZXROZXh0RnJhZ21lbnQodGhpcy5uZXh0TG9hZFBvc2l0aW9uLCB0KSwgbyAmJiAhby5nYXAgJiYgci5uZXh0U3RhcnQpKSB7XG4gICAgICBjb25zdCBhID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvQXRQb3ModGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhLCByLm5leHRTdGFydCwgbiwgMCk7XG4gICAgICBpZiAoYSAhPT0gbnVsbCAmJiByLmxlbiArIGEubGVuID49IGkpIHtcbiAgICAgICAgY29uc3QgbCA9IG8uc247XG4gICAgICAgIHJldHVybiB0aGlzLmxvb3BTbiAhPT0gbCAmJiAodGhpcy5sb2coYGJ1ZmZlciBmdWxsIGFmdGVyIGdhcHMgaW4gXCIke259XCIgcGxheWxpc3Qgc3RhcnRpbmcgYXQgc246ICR7bH1gKSwgdGhpcy5sb29wU24gPSBsKSwgbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubG9vcFNuID0gdm9pZCAwLCBvO1xuICB9XG4gIGdldCBwcmltYXJ5UHJlZmV0Y2goKSB7XG4gICAgaWYgKEJoKHRoaXMuY29uZmlnKSkge1xuICAgICAgdmFyIGU7XG4gICAgICBpZiAoKGUgPSB0aGlzLmhscy5pbnRlcnN0aXRpYWxzTWFuYWdlcikgPT0gbnVsbCB8fCAoZSA9IGUucGxheWluZ0l0ZW0pID09IG51bGwgPyB2b2lkIDAgOiBlLmV2ZW50KVxuICAgICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBmaWx0ZXJSZXBsYWNlZFByaW1hcnkoZSwgdCkge1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybiBlO1xuICAgIGlmIChCaCh0aGlzLmNvbmZpZykgJiYgZS50eXBlICE9PSBwZS5TVUJUSVRMRSkge1xuICAgICAgY29uc3QgciA9IHRoaXMuaGxzLmludGVyc3RpdGlhbHNNYW5hZ2VyLCBuID0gciA9PSBudWxsID8gdm9pZCAwIDogci5idWZmZXJpbmdJdGVtO1xuICAgICAgaWYgKG4pIHtcbiAgICAgICAgY29uc3QgbyA9IG4uZXZlbnQ7XG4gICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgaWYgKG8uYXBwZW5kSW5QbGFjZSB8fCBNYXRoLmFicyhlLnN0YXJ0IC0gbi5zdGFydCkgPiAxIHx8IG4uc3RhcnQgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIGlmIChlLmVuZCA8PSBuLnN0YXJ0ICYmICh0ID09IG51bGwgPyB2b2lkIDAgOiB0LmxpdmUpID09PSAhMSB8fCBlLnN0YXJ0ID4gbi5lbmQgJiYgbi5uZXh0RXZlbnQgJiYgKG4ubmV4dEV2ZW50LmFwcGVuZEluUGxhY2UgfHwgZS5zdGFydCAtIG4uZW5kID4gMSkpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCBpID0gciA9PSBudWxsID8gdm9pZCAwIDogci5wbGF5ZXJRdWV1ZTtcbiAgICAgIGlmIChpKVxuICAgICAgICBmb3IgKGxldCBvID0gaS5sZW5ndGg7IG8tLTsgKSB7XG4gICAgICAgICAgY29uc3QgYSA9IGlbb10uaW50ZXJzdGl0aWFsO1xuICAgICAgICAgIGlmIChhLmFwcGVuZEluUGxhY2UgJiYgZS5zdGFydCA+PSBhLnN0YXJ0VGltZSAmJiBlLmVuZCA8PSBhLnJlc3VtZVRpbWUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICBtYXBUb0luaXRGcmFnV2hlblJlcXVpcmVkKGUpIHtcbiAgICByZXR1cm4gZSAhPSBudWxsICYmIGUuaW5pdFNlZ21lbnQgJiYgIWUuaW5pdFNlZ21lbnQuZGF0YSAmJiAhdGhpcy5iaXRyYXRlVGVzdCA/IGUuaW5pdFNlZ21lbnQgOiBlO1xuICB9XG4gIGdldE5leHRQYXJ0KGUsIHQsIHIpIHtcbiAgICBsZXQgbiA9IC0xLCBpID0gITEsIG8gPSAhMDtcbiAgICBmb3IgKGxldCBhID0gMCwgbCA9IGUubGVuZ3RoOyBhIDwgbDsgYSsrKSB7XG4gICAgICBjb25zdCBjID0gZVthXTtcbiAgICAgIGlmIChvID0gbyAmJiAhYy5pbmRlcGVuZGVudCwgbiA+IC0xICYmIHIgPCBjLnN0YXJ0KVxuICAgICAgICBicmVhaztcbiAgICAgIGNvbnN0IHUgPSBjLmxvYWRlZDtcbiAgICAgIHUgPyBuID0gLTEgOiAoaSB8fCAoYy5pbmRlcGVuZGVudCB8fCBvKSAmJiBjLmZyYWdtZW50ID09PSB0KSAmJiAoYy5mcmFnbWVudCAhPT0gdCAmJiB0aGlzLndhcm4oYE5lZWQgYnVmZmVyIGF0ICR7cn0gYnV0IG5leHQgdW5sb2FkZWQgcGFydCBzdGFydHMgYXQgJHtjLnN0YXJ0fWApLCBuID0gYSksIGkgPSB1O1xuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICBsb2FkZWRFbmRPZlBhcnRzKGUsIHQpIHtcbiAgICBsZXQgcjtcbiAgICBmb3IgKGxldCBuID0gZS5sZW5ndGg7IG4tLTsgKSB7XG4gICAgICBpZiAociA9IGVbbl0sICFyLmxvYWRlZClcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgaWYgKHQgPiByLnN0YXJ0KVxuICAgICAgICByZXR1cm4gITA7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICAvKlxuICAgVGhpcyBtZXRob2QgaXMgdXNlZCBmaW5kIHRoZSBiZXN0IG1hdGNoaW5nIGZpcnN0IGZyYWdtZW50IGZvciBhIGxpdmUgcGxheWxpc3QuIFRoaXMgZnJhZ21lbnQgaXMgdXNlZCB0byBjYWxjdWxhdGUgdGhlXG4gICBcInNsaWRpbmdcIiBvZiB0aGUgcGxheWxpc3QsIHdoaWNoIGlzIGl0cyBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgcGxheWJhY2suIEFmdGVyIHNsaWRpbmcgd2UgY2FuIGNvbXB1dGUgdGhlIHJlYWxcbiAgIHN0YXJ0IGFuZCBlbmQgdGltZXMgZm9yIGVhY2ggZnJhZ21lbnQgaW4gdGhlIHBsYXlsaXN0IChhZnRlciB3aGljaCB0aGlzIG1ldGhvZCB3aWxsIG5vdCBuZWVkIHRvIGJlIGNhbGxlZCkuXG4gICovXG4gIGdldEluaXRpYWxMaXZlRnJhZ21lbnQoZSkge1xuICAgIGNvbnN0IHQgPSBlLmZyYWdtZW50cywgciA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuICAgIGxldCBuID0gbnVsbDtcbiAgICBpZiAocikge1xuICAgICAgaWYgKGUuaGFzUHJvZ3JhbURhdGVUaW1lICYmICh0aGlzLmxvZyhgTGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBzYW1lIFBEVDogJHtyLnByb2dyYW1EYXRlVGltZX1gKSwgbiA9IHZiKHQsIHIuZW5kUHJvZ3JhbURhdGVUaW1lLCB0aGlzLmNvbmZpZy5tYXhGcmFnTG9va1VwVG9sZXJhbmNlKSksICFuKSB7XG4gICAgICAgIGNvbnN0IGkgPSByLnNuICsgMTtcbiAgICAgICAgaWYgKGkgPj0gZS5zdGFydFNOICYmIGkgPD0gZS5lbmRTTikge1xuICAgICAgICAgIGNvbnN0IG8gPSB0W2kgLSBlLnN0YXJ0U05dO1xuICAgICAgICAgIHIuY2MgPT09IG8uY2MgJiYgKG4gPSBvLCB0aGlzLmxvZyhgTGl2ZSBwbGF5bGlzdCwgc3dpdGNoaW5nIHBsYXlsaXN0LCBsb2FkIGZyYWcgd2l0aCBuZXh0IFNOOiAke24uc259YCkpO1xuICAgICAgICB9XG4gICAgICAgIG4gfHwgKG4gPSBWZyhlLCByLmNjLCByLmVuZCksIG4gJiYgdGhpcy5sb2coYExpdmUgcGxheWxpc3QsIHN3aXRjaGluZyBwbGF5bGlzdCwgbG9hZCBmcmFnIHdpdGggc2FtZSBDQzogJHtuLnNufWApKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaSA9IHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb247XG4gICAgICBpICE9PSBudWxsICYmIChuID0gdGhpcy5nZXRGcmFnbWVudEF0UG9zaXRpb24oaSwgdGhpcy5iaXRyYXRlVGVzdCA/IGUuZnJhZ21lbnRFbmQgOiBlLmVkZ2UsIGUpKTtcbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgLypcbiAgVGhpcyBtZXRob2QgZmluZHMgdGhlIGJlc3QgbWF0Y2hpbmcgZnJhZ21lbnQgZ2l2ZW4gdGhlIHByb3ZpZGVkIHBvc2l0aW9uLlxuICAgKi9cbiAgZ2V0RnJhZ21lbnRBdFBvc2l0aW9uKGUsIHQsIHIpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb25maWc6IG5cbiAgICB9ID0gdGhpcztcbiAgICBsZXQge1xuICAgICAgZnJhZ1ByZXZpb3VzOiBpXG4gICAgfSA9IHRoaXMsIHtcbiAgICAgIGZyYWdtZW50czogbyxcbiAgICAgIGVuZFNOOiBhXG4gICAgfSA9IHI7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ21lbnRIaW50OiBsXG4gICAgfSA9IHIsIHtcbiAgICAgIG1heEZyYWdMb29rVXBUb2xlcmFuY2U6IGNcbiAgICB9ID0gbiwgdSA9IHIucGFydExpc3QsIGQgPSAhISh0aGlzLmxvYWRpbmdQYXJ0cyAmJiB1ICE9IG51bGwgJiYgdS5sZW5ndGggJiYgbCk7XG4gICAgZCAmJiAhdGhpcy5iaXRyYXRlVGVzdCAmJiB1W3UubGVuZ3RoIC0gMV0uZnJhZ21lbnQuc24gPT09IGwuc24gJiYgKG8gPSBvLmNvbmNhdChsKSwgYSA9IGwuc24pO1xuICAgIGxldCBoO1xuICAgIGlmIChlIDwgdCkge1xuICAgICAgdmFyIGY7XG4gICAgICBjb25zdCB5ID0gZSA8IHRoaXMubGFzdEN1cnJlbnRUaW1lIHx8IGUgPiB0IC0gYyB8fCAoZiA9IHRoaXMubWVkaWEpICE9IG51bGwgJiYgZi5wYXVzZWQgfHwgIXRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID8gMCA6IGM7XG4gICAgICBoID0gSnMoaSwgbywgZSwgeSk7XG4gICAgfSBlbHNlXG4gICAgICBoID0gb1tvLmxlbmd0aCAtIDFdO1xuICAgIGlmIChoKSB7XG4gICAgICBjb25zdCBwID0gaC5zbiAtIHIuc3RhcnRTTiwgeSA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGgpO1xuICAgICAgaWYgKCh5ID09PSBIdC5PSyB8fCB5ID09PSBIdC5QQVJUSUFMICYmIGguZ2FwKSAmJiAoaSA9IGgpLCBpICYmIGguc24gPT09IGkuc24gJiYgKCFkIHx8IHVbMF0uZnJhZ21lbnQuc24gPiBoLnNuIHx8ICFyLmxpdmUpICYmIGgubGV2ZWwgPT09IGkubGV2ZWwpIHtcbiAgICAgICAgY29uc3QgYiA9IG9bcCArIDFdO1xuICAgICAgICBoLnNuIDwgYSAmJiB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRTdGF0ZShiKSAhPT0gSHQuT0sgPyBoID0gYiA6IGggPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaDtcbiAgfVxuICBhbGlnblBsYXlsaXN0cyhlLCB0LCByKSB7XG4gICAgY29uc3QgbiA9IGUuZnJhZ21lbnRzLmxlbmd0aDtcbiAgICBpZiAoIW4pXG4gICAgICByZXR1cm4gdGhpcy53YXJuKFwiTm8gZnJhZ21lbnRzIGluIGxpdmUgcGxheWxpc3RcIiksIDA7XG4gICAgY29uc3QgaSA9IGUuZnJhZ21lbnRTdGFydCwgbyA9ICF0LCBhID0gZS5hbGlnbmVkU2xpZGluZyAmJiB1ZShpKTtcbiAgICBpZiAobyB8fCAhYSAmJiAhaSkge1xuICAgICAgclQociwgZSk7XG4gICAgICBjb25zdCBsID0gZS5mcmFnbWVudFN0YXJ0O1xuICAgICAgcmV0dXJuIHRoaXMubG9nKGBMaXZlIHBsYXlsaXN0IHNsaWRpbmc6ICR7bC50b0ZpeGVkKDIpfSBzdGFydC1zbjogJHt0ID8gdC5zdGFydFNOIDogXCJuYVwifS0+JHtlLnN0YXJ0U059IGZyYWdtZW50czogJHtufWApLCBsO1xuICAgIH1cbiAgICByZXR1cm4gaTtcbiAgfVxuICB3YWl0Rm9yQ2RuVHVuZUluKGUpIHtcbiAgICByZXR1cm4gZS5saXZlICYmIGUuY2FuQmxvY2tSZWxvYWQgJiYgZS5wYXJ0VGFyZ2V0ICYmIGUudHVuZUluR29hbCA+IE1hdGgubWF4KGUucGFydEhvbGRCYWNrLCBlLnBhcnRUYXJnZXQgKiAzKTtcbiAgfVxuICBzZXRTdGFydFBvc2l0aW9uKGUsIHQpIHtcbiAgICBsZXQgciA9IHRoaXMuc3RhcnRQb3NpdGlvbjtcbiAgICByIDwgdCAmJiAociA9IC0xKTtcbiAgICBjb25zdCBuID0gdGhpcy50aW1lbGluZU9mZnNldDtcbiAgICBpZiAociA9PT0gLTEpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLnN0YXJ0VGltZU9mZnNldCAhPT0gbnVsbCwgbyA9IGkgPyB0aGlzLnN0YXJ0VGltZU9mZnNldCA6IGUuc3RhcnRUaW1lT2Zmc2V0O1xuICAgICAgbyAhPT0gbnVsbCAmJiB1ZShvKSA/IChyID0gdCArIG8sIG8gPCAwICYmIChyICs9IGUuZWRnZSksIHIgPSBNYXRoLm1pbihNYXRoLm1heCh0LCByKSwgdCArIGUudG90YWxkdXJhdGlvbiksIHRoaXMubG9nKGBTZXR0aW5nIHN0YXJ0UG9zaXRpb24gdG8gJHtyfSBmb3Igc3RhcnQgdGltZSBvZmZzZXQgJHtvfSBmb3VuZCBpbiAke2kgPyBcIm11bHRpdmFyaWFudFwiIDogXCJtZWRpYVwifSBwbGF5bGlzdGApLCB0aGlzLnN0YXJ0UG9zaXRpb24gPSByKSA6IGUubGl2ZSA/IChyID0gdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbiB8fCB0LCB0aGlzLmxvZyhgU2V0dGluZyBzdGFydFBvc2l0aW9uIHRvIC0xIHRvIHN0YXJ0IGF0IGxpdmUgZWRnZSAke3J9YCksIHRoaXMuc3RhcnRQb3NpdGlvbiA9IC0xKSA6ICh0aGlzLmxvZyhcInNldHRpbmcgc3RhcnRQb3NpdGlvbiB0byAwIGJ5IGRlZmF1bHRcIiksIHRoaXMuc3RhcnRQb3NpdGlvbiA9IHIgPSAwKSwgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSByICsgbjtcbiAgICB9XG4gICAgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gciArIG47XG4gIH1cbiAgZ2V0TG9hZFBvc2l0aW9uKCkge1xuICAgIHZhciBlO1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhOiB0XG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IHIgPSAwO1xuICAgIHJldHVybiAoZSA9IHRoaXMuaGxzKSAhPSBudWxsICYmIGUuaGFzRW5vdWdoVG9TdGFydCAmJiB0ID8gciA9IHQuY3VycmVudFRpbWUgOiB0aGlzLm5leHRMb2FkUG9zaXRpb24gPj0gMCAmJiAociA9IHRoaXMubmV4dExvYWRQb3NpdGlvbiksIHI7XG4gIH1cbiAgaGFuZGxlRnJhZ0xvYWRBYm9ydGVkKGUsIHQpIHtcbiAgICB0aGlzLnRyYW5zbXV4ZXIgJiYgZS50eXBlID09PSB0aGlzLnBsYXlsaXN0VHlwZSAmJiBWdChlKSAmJiBlLnN0YXRzLmFib3J0ZWQgJiYgKHRoaXMubG9nKGBGcmFnbWVudCAke2Uuc259JHt0ID8gXCIgcGFydCBcIiArIHQuaW5kZXggOiBcIlwifSBvZiAke3RoaXMucGxheWxpc3RMYWJlbCgpfSAke2UubGV2ZWx9IHdhcyBhYm9ydGVkYCksIHRoaXMucmVzZXRGcmFnbWVudExvYWRpbmcoZSkpO1xuICB9XG4gIHJlc2V0RnJhZ21lbnRMb2FkaW5nKGUpIHtcbiAgICAoIXRoaXMuZnJhZ0N1cnJlbnQgfHwgIXRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGUpICYmIHRoaXMuc3RhdGUgIT09IG5lLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZKSAmJiAodGhpcy5zdGF0ZSA9IG5lLklETEUpO1xuICB9XG4gIG9uRnJhZ21lbnRPcktleUxvYWRFcnJvcihlLCB0KSB7XG4gICAgdmFyIHI7XG4gICAgaWYgKHQuY2h1bmtNZXRhICYmICF0LmZyYWcpIHtcbiAgICAgIGNvbnN0IGIgPSB0aGlzLmdldEN1cnJlbnRDb250ZXh0KHQuY2h1bmtNZXRhKTtcbiAgICAgIGIgJiYgKHQuZnJhZyA9IGIuZnJhZyk7XG4gICAgfVxuICAgIGNvbnN0IG4gPSB0LmZyYWc7XG4gICAgaWYgKCFuIHx8IG4udHlwZSAhPT0gZSB8fCAhdGhpcy5sZXZlbHMpXG4gICAgICByZXR1cm47XG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKG4pKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHRoaXMud2FybihgRnJhZyBsb2FkIGVycm9yIG11c3QgbWF0Y2ggY3VycmVudCBmcmFnIHRvIHJldHJ5ICR7bi51cmx9ID4gJHsoaSA9IHRoaXMuZnJhZ0N1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBpLnVybH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbyA9IHQuZGV0YWlscyA9PT0gSi5GUkFHX0dBUDtcbiAgICBvICYmIHRoaXMuZnJhZ21lbnRUcmFja2VyLmZyYWdCdWZmZXJlZChuLCAhMCk7XG4gICAgY29uc3QgYSA9IHQuZXJyb3JBY3Rpb247XG4gICAgaWYgKCFhKSB7XG4gICAgICB0aGlzLnN0YXRlID0gbmUuRVJST1I7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFjdGlvbjogbCxcbiAgICAgIGZsYWdzOiBjLFxuICAgICAgcmV0cnlDb3VudDogdSA9IDAsXG4gICAgICByZXRyeUNvbmZpZzogZFxuICAgIH0gPSBhLCBoID0gISFkLCBmID0gaCAmJiBsID09PSBadC5SZXRyeVJlcXVlc3QsIHAgPSBoICYmICFhLnJlc29sdmVkICYmIGMgPT09IHZyLk1vdmVBbGxBbHRlcm5hdGVzTWF0Y2hpbmdIb3N0LCB5ID0gKHIgPSB0aGlzLmhscy5sYXRlc3RMZXZlbERldGFpbHMpID09IG51bGwgPyB2b2lkIDAgOiByLmxpdmU7XG4gICAgaWYgKCFmICYmIHAgJiYgVnQobikgJiYgIW4uZW5kTGlzdCAmJiB5ICYmICFLZyh0KSlcbiAgICAgIHRoaXMucmVzZXRGcmFnbWVudEVycm9ycyhlKSwgdGhpcy50cmVhdEFzR2FwKG4pLCBhLnJlc29sdmVkID0gITA7XG4gICAgZWxzZSBpZiAoKGYgfHwgcCkgJiYgdSA8IGQubWF4TnVtUmV0cnkpIHtcbiAgICAgIHZhciBFO1xuICAgICAgY29uc3QgYiA9IHVjKChFID0gdC5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IEUuY29kZSksIFIgPSB5dShkLCB1KTtcbiAgICAgIGlmICh0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKCksIHRoaXMucmV0cnlEYXRlID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKSArIFIsIHRoaXMuc3RhdGUgPSBuZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWSwgYS5yZXNvbHZlZCA9ICEwLCBiKSB7XG4gICAgICAgIHRoaXMubG9nKFwiV2FpdGluZyBmb3IgY29ubmVjdGlvbiAob2ZmbGluZSlcIiksIHRoaXMucmV0cnlEYXRlID0gMSAvIDAsIHQucmVhc29uID0gXCJvZmZsaW5lXCI7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMud2FybihgRnJhZ21lbnQgJHtuLnNufSBvZiAke2V9ICR7bi5sZXZlbH0gZXJyb3JlZCB3aXRoICR7dC5kZXRhaWxzfSwgcmV0cnlpbmcgbG9hZGluZyAke3UgKyAxfS8ke2QubWF4TnVtUmV0cnl9IGluICR7Un1tc2ApO1xuICAgIH0gZWxzZSBpZiAoZClcbiAgICAgIGlmICh0aGlzLnJlc2V0RnJhZ21lbnRFcnJvcnMoZSksIHUgPCBkLm1heE51bVJldHJ5KVxuICAgICAgICAhbyAmJiBsICE9PSBadC5SZW1vdmVBbHRlcm5hdGVQZXJtYW5lbnRseSAmJiAoYS5yZXNvbHZlZCA9ICEwKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLndhcm4oYCR7dC5kZXRhaWxzfSByZWFjaGVkIG9yIGV4Y2VlZGVkIG1heCByZXRyeSAoJHt1fSlgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIGVsc2UgbCA9PT0gWnQuU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCA/IHRoaXMuc3RhdGUgPSBuZS5XQUlUSU5HX0xFVkVMIDogdGhpcy5zdGF0ZSA9IG5lLkVSUk9SO1xuICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICB9XG4gIGNoZWNrUmV0cnlEYXRlKCkge1xuICAgIGNvbnN0IGUgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCB0ID0gdGhpcy5yZXRyeURhdGUsIHIgPSB0ID09PSAxIC8gMDtcbiAgICAoIXQgfHwgZSA+PSB0IHx8IHIgJiYgIXVjKDApKSAmJiAociAmJiB0aGlzLmxvZyhcIkNvbm5lY3Rpb24gcmVzdG9yZWQgKG9ubGluZSlcIiksIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQoKSwgdGhpcy5zdGF0ZSA9IG5lLklETEUpO1xuICB9XG4gIHJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyKGUpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gbmUuUEFSU0lORyB8fCB0aGlzLnN0YXRlID09PSBuZS5QQVJTRUQpIHtcbiAgICAgIGNvbnN0IHQgPSBlLmZyYWcsIHIgPSBlLnBhcmVudCwgbiA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyh0aGlzLm1lZGlhQnVmZmVyLCByKSwgaSA9IG4gJiYgbi5sZW4gPiAwLjU7XG4gICAgICBpICYmIHRoaXMucmVkdWNlTWF4QnVmZmVyTGVuZ3RoKG4ubGVuLCAodCA9PSBudWxsID8gdm9pZCAwIDogdC5kdXJhdGlvbikgfHwgMTApO1xuICAgICAgY29uc3QgbyA9ICFpO1xuICAgICAgcmV0dXJuIG8gJiYgdGhpcy53YXJuKGBCdWZmZXIgZnVsbCBlcnJvciB3aGlsZSBtZWRpYS5jdXJyZW50VGltZSAoJHt0aGlzLmdldExvYWRQb3NpdGlvbigpfSkgaXMgbm90IGJ1ZmZlcmVkLCBmbHVzaCAke3J9IGJ1ZmZlcmApLCB0ICYmICh0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudCh0KSwgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdC5zdGFydCksIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKSwgbztcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHJlc2V0RnJhZ21lbnRFcnJvcnMoZSkge1xuICAgIGUgPT09IHBlLkFVRElPICYmICh0aGlzLmZyYWdDdXJyZW50ID0gbnVsbCksIHRoaXMuaGxzLmhhc0Vub3VnaFRvU3RhcnQgfHwgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gITEpLCB0aGlzLnN0YXRlICE9PSBuZS5TVE9QUEVEICYmICh0aGlzLnN0YXRlID0gbmUuSURMRSk7XG4gIH1cbiAgYWZ0ZXJCdWZmZXJGbHVzaGVkKGUsIHQsIHIpIHtcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbiA9IENlLmdldEJ1ZmZlcmVkKGUpO1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLmRldGVjdEV2aWN0ZWRGcmFnbWVudHModCwgbiwgciksIHRoaXMuc3RhdGUgPT09IG5lLkVOREVEICYmIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgfVxuICByZXNldExvYWRpbmdTdGF0ZSgpIHtcbiAgICB0aGlzLmxvZyhcIlJlc2V0IGxvYWRpbmcgc3RhdGVcIiksIHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsLCB0aGlzLmZyYWdQcmV2aW91cyA9IG51bGwsIHRoaXMuc3RhdGUgIT09IG5lLlNUT1BQRUQgJiYgKHRoaXMuc3RhdGUgPSBuZS5JRExFKTtcbiAgfVxuICByZXNldFN0YXJ0V2hlbk5vdExvYWRlZCgpIHtcbiAgICBpZiAoIXRoaXMuaGxzLmhhc0Vub3VnaFRvU3RhcnQpIHtcbiAgICAgIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gITE7XG4gICAgICBjb25zdCBlID0gdGhpcy5sZXZlbExhc3RMb2FkZWQsIHQgPSBlID8gZS5kZXRhaWxzIDogbnVsbDtcbiAgICAgIHQgIT0gbnVsbCAmJiB0LmxpdmUgPyAodGhpcy5sb2coXCJyZXNldHRpbmcgc3RhcnRQb3NpdGlvbiBmb3IgbGl2ZSBzdGFydFwiKSwgdGhpcy5zdGFydFBvc2l0aW9uID0gLTEsIHRoaXMuc2V0U3RhcnRQb3NpdGlvbih0LCB0LmZyYWdtZW50U3RhcnQpLCB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCkpIDogdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIH1cbiAgfVxuICByZXNldFdoZW5NaXNzaW5nQ29udGV4dChlKSB7XG4gICAgdGhpcy5sb2coYExvYWRpbmcgY29udGV4dCBjaGFuZ2VkIHdoaWxlIGJ1ZmZlcmluZyBzbiAke2Uuc259IG9mICR7dGhpcy5wbGF5bGlzdExhYmVsKCl9ICR7ZS5sZXZlbCA9PT0gLTEgPyBcIjxyZW1vdmVkPlwiIDogZS5sZXZlbH0uIFRoaXMgY2h1bmsgd2lsbCBub3QgYmUgYnVmZmVyZWQuYCksIHRoaXMucmVtb3ZlVW5idWZmZXJlZEZyYWdzKCksIHRoaXMucmVzZXRTdGFydFdoZW5Ob3RMb2FkZWQoKSwgdGhpcy5yZXNldExvYWRpbmdTdGF0ZSgpO1xuICB9XG4gIHJlbW92ZVVuYnVmZmVyZWRGcmFncyhlID0gMCkge1xuICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2UoZSwgMSAvIDAsIHRoaXMucGxheWxpc3RUeXBlLCAhMSwgITApO1xuICB9XG4gIHVwZGF0ZUxldmVsVGltaW5nKGUsIHQsIHIsIG4pIHtcbiAgICBjb25zdCBpID0gci5kZXRhaWxzO1xuICAgIGlmICghaSkge1xuICAgICAgdGhpcy53YXJuKFwibGV2ZWwuZGV0YWlscyB1bmRlZmluZWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghT2JqZWN0LmtleXMoZS5lbGVtZW50YXJ5U3RyZWFtcykucmVkdWNlKChsLCBjKSA9PiB7XG4gICAgICBjb25zdCB1ID0gZS5lbGVtZW50YXJ5U3RyZWFtc1tjXTtcbiAgICAgIGlmICh1KSB7XG4gICAgICAgIGNvbnN0IGQgPSB1LmVuZFBUUyAtIHUuc3RhcnRQVFM7XG4gICAgICAgIGlmIChkIDw9IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXMud2FybihgQ291bGQgbm90IHBhcnNlIGZyYWdtZW50ICR7ZS5zbn0gJHtjfSBkdXJhdGlvbiByZWxpYWJseSAoJHtkfSlgKSwgbCB8fCAhMTtcbiAgICAgICAgY29uc3QgaCA9IG4gPyAwIDogWGcoaSwgZSwgdS5zdGFydFBUUywgdS5lbmRQVFMsIHUuc3RhcnREVFMsIHUuZW5kRFRTLCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGxzLnRyaWdnZXIoSS5MRVZFTF9QVFNfVVBEQVRFRCwge1xuICAgICAgICAgIGRldGFpbHM6IGksXG4gICAgICAgICAgbGV2ZWw6IHIsXG4gICAgICAgICAgZHJpZnQ6IGgsXG4gICAgICAgICAgdHlwZTogYyxcbiAgICAgICAgICBmcmFnOiBlLFxuICAgICAgICAgIHN0YXJ0OiB1LnN0YXJ0UFRTLFxuICAgICAgICAgIGVuZDogdS5lbmRQVFNcbiAgICAgICAgfSksICEwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGw7XG4gICAgfSwgITEpKSB7XG4gICAgICB2YXIgYTtcbiAgICAgIGlmIChyLmZyYWdtZW50RXJyb3IgPT09IDAgJiYgdGhpcy50cmVhdEFzR2FwKGUsIHIpLCAoKGEgPSB0aGlzLnRyYW5zbXV4ZXIpID09IG51bGwgPyB2b2lkIDAgOiBhLmVycm9yKSA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBsID0gbmV3IEVycm9yKGBGb3VuZCBubyBtZWRpYSBpbiBmcmFnbWVudCAke2Uuc259IG9mICR7dGhpcy5wbGF5bGlzdExhYmVsKCl9ICR7ZS5sZXZlbH0gcmVzZXR0aW5nIHRyYW5zbXV4ZXIgdG8gZmFsbGJhY2sgdG8gcGxheWxpc3QgdGltaW5nYCk7XG4gICAgICAgIGlmICh0aGlzLndhcm4obC5tZXNzYWdlKSwgdGhpcy5obHMudHJpZ2dlcihJLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogdmUuTUVESUFfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogSi5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgICAgZmF0YWw6ICExLFxuICAgICAgICAgIGVycm9yOiBsLFxuICAgICAgICAgIGZyYWc6IGUsXG4gICAgICAgICAgcmVhc29uOiBgRm91bmQgbm8gbWVkaWEgaW4gbXNuICR7ZS5zbn0gb2YgJHt0aGlzLnBsYXlsaXN0TGFiZWwoKX0gXCIke3IudXJsfVwiYFxuICAgICAgICB9KSwgIXRoaXMuaGxzKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zdGF0ZSA9IG5lLlBBUlNFRCwgdGhpcy5sb2coYFBhcnNlZCAke2UudHlwZX0gc246ICR7ZS5zbn0ke3QgPyBcIiBwYXJ0OiBcIiArIHQuaW5kZXggOiBcIlwifSBvZiAke3RoaXMuZnJhZ0luZm8oZSwgITEsIHQpfSlgKSwgdGhpcy5obHMudHJpZ2dlcihJLkZSQUdfUEFSU0VELCB7XG4gICAgICBmcmFnOiBlLFxuICAgICAgcGFydDogdFxuICAgIH0pO1xuICB9XG4gIHBsYXlsaXN0TGFiZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMucGxheWxpc3RUeXBlID09PSBwZS5NQUlOID8gXCJsZXZlbFwiIDogXCJ0cmFja1wiO1xuICB9XG4gIGZyYWdJbmZvKGUsIHQgPSAhMCwgcikge1xuICAgIHZhciBuLCBpO1xuICAgIHJldHVybiBgJHt0aGlzLnBsYXlsaXN0TGFiZWwoKX0gJHtlLmxldmVsfSAoJHtyID8gXCJwYXJ0XCIgOiBcImZyYWdcIn06WyR7KChuID0gdCAmJiAhciA/IGUuc3RhcnRQVFMgOiAociB8fCBlKS5zdGFydCkgIT0gbnVsbCA/IG4gOiBOYU4pLnRvRml4ZWQoMyl9LSR7KChpID0gdCAmJiAhciA/IGUuZW5kUFRTIDogKHIgfHwgZSkuZW5kKSAhPSBudWxsID8gaSA6IE5hTikudG9GaXhlZCgzKX1dJHtyICYmIGUudHlwZSA9PT0gXCJtYWluXCIgPyBcIklOREVQRU5ERU5UPVwiICsgKHIuaW5kZXBlbmRlbnQgPyBcIllFU1wiIDogXCJOT1wiKSA6IFwiXCJ9YDtcbiAgfVxuICB0cmVhdEFzR2FwKGUsIHQpIHtcbiAgICB0ICYmIHQuZnJhZ21lbnRFcnJvcisrLCBlLmdhcCA9ICEwLCB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChlKSwgdGhpcy5mcmFnbWVudFRyYWNrZXIuZnJhZ0J1ZmZlcmVkKGUsICEwKTtcbiAgfVxuICByZXNldFRyYW5zbXV4ZXIoKSB7XG4gICAgdmFyIGU7XG4gICAgKGUgPSB0aGlzLnRyYW5zbXV4ZXIpID09IG51bGwgfHwgZS5yZXNldCgpO1xuICB9XG4gIHJlY292ZXJXb3JrZXJFcnJvcihlKSB7XG4gICAgZS5ldmVudCA9PT0gXCJkZW11eGVyV29ya2VyXCIgJiYgKHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpLCB0aGlzLnRyYW5zbXV4ZXIgJiYgKHRoaXMudHJhbnNtdXhlci5kZXN0cm95KCksIHRoaXMudHJhbnNtdXhlciA9IG51bGwpLCB0aGlzLnJlc2V0U3RhcnRXaGVuTm90TG9hZGVkKCksIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKSk7XG4gIH1cbiAgc2V0IHN0YXRlKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5fc3RhdGU7XG4gICAgdCAhPT0gZSAmJiAodGhpcy5fc3RhdGUgPSBlLCB0aGlzLmxvZyhgJHt0fS0+JHtlfWApKTtcbiAgfVxuICBnZXQgc3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICB9XG59XG5mdW5jdGlvbiBCaChzKSB7XG4gIHJldHVybiAhIXMuaW50ZXJzdGl0aWFsc0NvbnRyb2xsZXIgJiYgcy5lbmFibGVJbnRlcnN0aXRpYWxQbGF5YmFjayAhPT0gITE7XG59XG5jbGFzcyBpcCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuY2h1bmtzID0gW10sIHRoaXMuZGF0YUxlbmd0aCA9IDA7XG4gIH1cbiAgcHVzaChlKSB7XG4gICAgdGhpcy5jaHVua3MucHVzaChlKSwgdGhpcy5kYXRhTGVuZ3RoICs9IGUubGVuZ3RoO1xuICB9XG4gIGZsdXNoKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNodW5rczogZSxcbiAgICAgIGRhdGFMZW5ndGg6IHRcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgcjtcbiAgICBpZiAoZS5sZW5ndGgpXG4gICAgICBlLmxlbmd0aCA9PT0gMSA/IHIgPSBlWzBdIDogciA9IG5UKGUsIHQpO1xuICAgIGVsc2UgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgIHJldHVybiB0aGlzLnJlc2V0KCksIHI7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5jaHVua3MubGVuZ3RoID0gMCwgdGhpcy5kYXRhTGVuZ3RoID0gMDtcbiAgfVxufVxuZnVuY3Rpb24gblQocywgZSkge1xuICBjb25zdCB0ID0gbmV3IFVpbnQ4QXJyYXkoZSk7XG4gIGxldCByID0gMDtcbiAgZm9yIChsZXQgbiA9IDA7IG4gPCBzLmxlbmd0aDsgbisrKSB7XG4gICAgY29uc3QgaSA9IHNbbl07XG4gICAgdC5zZXQoaSwgciksIHIgKz0gaS5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG52YXIgbWwgPSB7IGV4cG9ydHM6IHt9IH0sIEZoO1xuZnVuY3Rpb24gaVQoKSB7XG4gIHJldHVybiBGaCB8fCAoRmggPSAxLCAoZnVuY3Rpb24ocykge1xuICAgIHZhciBlID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSwgdCA9IFwiflwiO1xuICAgIGZ1bmN0aW9uIHIoKSB7XG4gICAgfVxuICAgIE9iamVjdC5jcmVhdGUgJiYgKHIucHJvdG90eXBlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIG5ldyByKCkuX19wcm90b19fIHx8ICh0ID0gITEpKTtcbiAgICBmdW5jdGlvbiBuKGwsIGMsIHUpIHtcbiAgICAgIHRoaXMuZm4gPSBsLCB0aGlzLmNvbnRleHQgPSBjLCB0aGlzLm9uY2UgPSB1IHx8ICExO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpKGwsIGMsIHUsIGQsIGgpIHtcbiAgICAgIGlmICh0eXBlb2YgdSAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uXCIpO1xuICAgICAgdmFyIGYgPSBuZXcgbih1LCBkIHx8IGwsIGgpLCBwID0gdCA/IHQgKyBjIDogYztcbiAgICAgIHJldHVybiBsLl9ldmVudHNbcF0gPyBsLl9ldmVudHNbcF0uZm4gPyBsLl9ldmVudHNbcF0gPSBbbC5fZXZlbnRzW3BdLCBmXSA6IGwuX2V2ZW50c1twXS5wdXNoKGYpIDogKGwuX2V2ZW50c1twXSA9IGYsIGwuX2V2ZW50c0NvdW50KyspLCBsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvKGwsIGMpIHtcbiAgICAgIC0tbC5fZXZlbnRzQ291bnQgPT09IDAgPyBsLl9ldmVudHMgPSBuZXcgcigpIDogZGVsZXRlIGwuX2V2ZW50c1tjXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYSgpIHtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IG5ldyByKCksIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICB9XG4gICAgYS5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGMgPSBbXSwgdSwgZDtcbiAgICAgIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIGM7XG4gICAgICBmb3IgKGQgaW4gdSA9IHRoaXMuX2V2ZW50cylcbiAgICAgICAgZS5jYWxsKHUsIGQpICYmIGMucHVzaCh0ID8gZC5zbGljZSgxKSA6IGQpO1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBjLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHUpKSA6IGM7XG4gICAgfSwgYS5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oYykge1xuICAgICAgdmFyIHUgPSB0ID8gdCArIGMgOiBjLCBkID0gdGhpcy5fZXZlbnRzW3VdO1xuICAgICAgaWYgKCFkKSByZXR1cm4gW107XG4gICAgICBpZiAoZC5mbikgcmV0dXJuIFtkLmZuXTtcbiAgICAgIGZvciAodmFyIGggPSAwLCBmID0gZC5sZW5ndGgsIHAgPSBuZXcgQXJyYXkoZik7IGggPCBmOyBoKyspXG4gICAgICAgIHBbaF0gPSBkW2hdLmZuO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfSwgYS5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciB1ID0gdCA/IHQgKyBjIDogYywgZCA9IHRoaXMuX2V2ZW50c1t1XTtcbiAgICAgIHJldHVybiBkID8gZC5mbiA/IDEgOiBkLmxlbmd0aCA6IDA7XG4gICAgfSwgYS5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGMsIHUsIGQsIGgsIGYsIHApIHtcbiAgICAgIHZhciB5ID0gdCA/IHQgKyBjIDogYztcbiAgICAgIGlmICghdGhpcy5fZXZlbnRzW3ldKSByZXR1cm4gITE7XG4gICAgICB2YXIgRSA9IHRoaXMuX2V2ZW50c1t5XSwgYiA9IGFyZ3VtZW50cy5sZW5ndGgsIFIsIEE7XG4gICAgICBpZiAoRS5mbikge1xuICAgICAgICBzd2l0Y2ggKEUub25jZSAmJiB0aGlzLnJlbW92ZUxpc3RlbmVyKGMsIEUuZm4sIHZvaWQgMCwgITApLCBiKSB7XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIEUuZm4uY2FsbChFLmNvbnRleHQpLCAhMDtcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gRS5mbi5jYWxsKEUuY29udGV4dCwgdSksICEwO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBFLmZuLmNhbGwoRS5jb250ZXh0LCB1LCBkKSwgITA7XG4gICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIEUuZm4uY2FsbChFLmNvbnRleHQsIHUsIGQsIGgpLCAhMDtcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gRS5mbi5jYWxsKEUuY29udGV4dCwgdSwgZCwgaCwgZiksICEwO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIHJldHVybiBFLmZuLmNhbGwoRS5jb250ZXh0LCB1LCBkLCBoLCBmLCBwKSwgITA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChBID0gMSwgUiA9IG5ldyBBcnJheShiIC0gMSk7IEEgPCBiOyBBKyspXG4gICAgICAgICAgUltBIC0gMV0gPSBhcmd1bWVudHNbQV07XG4gICAgICAgIEUuZm4uYXBwbHkoRS5jb250ZXh0LCBSKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBGID0gRS5sZW5ndGgsIE07XG4gICAgICAgIGZvciAoQSA9IDA7IEEgPCBGOyBBKyspXG4gICAgICAgICAgc3dpdGNoIChFW0FdLm9uY2UgJiYgdGhpcy5yZW1vdmVMaXN0ZW5lcihjLCBFW0FdLmZuLCB2b2lkIDAsICEwKSwgYikge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBFW0FdLmZuLmNhbGwoRVtBXS5jb250ZXh0KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIEVbQV0uZm4uY2FsbChFW0FdLmNvbnRleHQsIHUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgRVtBXS5mbi5jYWxsKEVbQV0uY29udGV4dCwgdSwgZCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBFW0FdLmZuLmNhbGwoRVtBXS5jb250ZXh0LCB1LCBkLCBoKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICBpZiAoIVIpIGZvciAoTSA9IDEsIFIgPSBuZXcgQXJyYXkoYiAtIDEpOyBNIDwgYjsgTSsrKVxuICAgICAgICAgICAgICAgIFJbTSAtIDFdID0gYXJndW1lbnRzW01dO1xuICAgICAgICAgICAgICBFW0FdLmZuLmFwcGx5KEVbQV0uY29udGV4dCwgUik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH0sIGEucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oYywgdSwgZCkge1xuICAgICAgcmV0dXJuIGkodGhpcywgYywgdSwgZCwgITEpO1xuICAgIH0sIGEucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihjLCB1LCBkKSB7XG4gICAgICByZXR1cm4gaSh0aGlzLCBjLCB1LCBkLCAhMCk7XG4gICAgfSwgYS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbihjLCB1LCBkLCBoKSB7XG4gICAgICB2YXIgZiA9IHQgPyB0ICsgYyA6IGM7XG4gICAgICBpZiAoIXRoaXMuX2V2ZW50c1tmXSkgcmV0dXJuIHRoaXM7XG4gICAgICBpZiAoIXUpXG4gICAgICAgIHJldHVybiBvKHRoaXMsIGYpLCB0aGlzO1xuICAgICAgdmFyIHAgPSB0aGlzLl9ldmVudHNbZl07XG4gICAgICBpZiAocC5mbilcbiAgICAgICAgcC5mbiA9PT0gdSAmJiAoIWggfHwgcC5vbmNlKSAmJiAoIWQgfHwgcC5jb250ZXh0ID09PSBkKSAmJiBvKHRoaXMsIGYpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIHkgPSAwLCBFID0gW10sIGIgPSBwLmxlbmd0aDsgeSA8IGI7IHkrKylcbiAgICAgICAgICAocFt5XS5mbiAhPT0gdSB8fCBoICYmICFwW3ldLm9uY2UgfHwgZCAmJiBwW3ldLmNvbnRleHQgIT09IGQpICYmIEUucHVzaChwW3ldKTtcbiAgICAgICAgRS5sZW5ndGggPyB0aGlzLl9ldmVudHNbZl0gPSBFLmxlbmd0aCA9PT0gMSA/IEVbMF0gOiBFIDogbyh0aGlzLCBmKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sIGEucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciB1O1xuICAgICAgcmV0dXJuIGMgPyAodSA9IHQgPyB0ICsgYyA6IGMsIHRoaXMuX2V2ZW50c1t1XSAmJiBvKHRoaXMsIHUpKSA6ICh0aGlzLl9ldmVudHMgPSBuZXcgcigpLCB0aGlzLl9ldmVudHNDb3VudCA9IDApLCB0aGlzO1xuICAgIH0sIGEucHJvdG90eXBlLm9mZiA9IGEucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLCBhLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGEucHJvdG90eXBlLm9uLCBhLnByZWZpeGVkID0gdCwgYS5FdmVudEVtaXR0ZXIgPSBhLCBzLmV4cG9ydHMgPSBhO1xuICB9KShtbCkpLCBtbC5leHBvcnRzO1xufVxudmFyIG9UID0gaVQoKSwgd3UgPSAvKiBAX19QVVJFX18gKi8ga1Mob1QpO1xuY29uc3QgdmkgPSBcIjEuNi4xMlwiLCBObiA9IHt9O1xuZnVuY3Rpb24gYVQoKSB7XG4gIHJldHVybiB0eXBlb2YgX19ITFNfV09SS0VSX0JVTkRMRV9fID09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIGxUKCkge1xuICBjb25zdCBzID0gTm5bdmldO1xuICBpZiAocylcbiAgICByZXR1cm4gcy5jbGllbnRDb3VudCsrLCBzO1xuICBjb25zdCBlID0gbmV3IHNlbGYuQmxvYihbYHZhciBleHBvcnRzPXt9O3ZhciBtb2R1bGU9e2V4cG9ydHM6ZXhwb3J0c307ZnVuY3Rpb24gZGVmaW5lKGYpe2YoKX07ZGVmaW5lLmFtZD10cnVlOygke19fSExTX1dPUktFUl9CVU5ETEVfXy50b1N0cmluZygpfSkodHJ1ZSk7YF0sIHtcbiAgICB0eXBlOiBcInRleHQvamF2YXNjcmlwdFwiXG4gIH0pLCB0ID0gc2VsZi5VUkwuY3JlYXRlT2JqZWN0VVJMKGUpLCBuID0ge1xuICAgIHdvcmtlcjogbmV3IHNlbGYuV29ya2VyKHQpLFxuICAgIG9iamVjdFVSTDogdCxcbiAgICBjbGllbnRDb3VudDogMVxuICB9O1xuICByZXR1cm4gTm5bdmldID0gbiwgbjtcbn1cbmZ1bmN0aW9uIGNUKHMpIHtcbiAgY29uc3QgZSA9IE5uW3NdO1xuICBpZiAoZSlcbiAgICByZXR1cm4gZS5jbGllbnRDb3VudCsrLCBlO1xuICBjb25zdCB0ID0gbmV3IHNlbGYuVVJMKHMsIHNlbGYubG9jYXRpb24uaHJlZikuaHJlZiwgbiA9IHtcbiAgICB3b3JrZXI6IG5ldyBzZWxmLldvcmtlcih0KSxcbiAgICBzY3JpcHRVUkw6IHQsXG4gICAgY2xpZW50Q291bnQ6IDFcbiAgfTtcbiAgcmV0dXJuIE5uW3NdID0gbiwgbjtcbn1cbmZ1bmN0aW9uIHVUKHMpIHtcbiAgY29uc3QgZSA9IE5uW3MgfHwgdmldO1xuICBpZiAoZSAmJiBlLmNsaWVudENvdW50LS0gPT09IDEpIHtcbiAgICBjb25zdCB7XG4gICAgICB3b3JrZXI6IHIsXG4gICAgICBvYmplY3RVUkw6IG5cbiAgICB9ID0gZTtcbiAgICBkZWxldGUgTm5bcyB8fCB2aV0sIG4gJiYgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKG4pLCByLnRlcm1pbmF0ZSgpO1xuICB9XG59XG5mdW5jdGlvbiBvcChzLCBlKSB7XG4gIHJldHVybiBlICsgMTAgPD0gcy5sZW5ndGggJiYgc1tlXSA9PT0gNTEgJiYgc1tlICsgMV0gPT09IDY4ICYmIHNbZSArIDJdID09PSA3MyAmJiBzW2UgKyAzXSA8IDI1NSAmJiBzW2UgKyA0XSA8IDI1NSAmJiBzW2UgKyA2XSA8IDEyOCAmJiBzW2UgKyA3XSA8IDEyOCAmJiBzW2UgKyA4XSA8IDEyOCAmJiBzW2UgKyA5XSA8IDEyODtcbn1cbmZ1bmN0aW9uIEF1KHMsIGUpIHtcbiAgcmV0dXJuIGUgKyAxMCA8PSBzLmxlbmd0aCAmJiBzW2VdID09PSA3MyAmJiBzW2UgKyAxXSA9PT0gNjggJiYgc1tlICsgMl0gPT09IDUxICYmIHNbZSArIDNdIDwgMjU1ICYmIHNbZSArIDRdIDwgMjU1ICYmIHNbZSArIDZdIDwgMTI4ICYmIHNbZSArIDddIDwgMTI4ICYmIHNbZSArIDhdIDwgMTI4ICYmIHNbZSArIDldIDwgMTI4O1xufVxuZnVuY3Rpb24gdmEocywgZSkge1xuICBsZXQgdCA9IDA7XG4gIHJldHVybiB0ID0gKHNbZV0gJiAxMjcpIDw8IDIxLCB0IHw9IChzW2UgKyAxXSAmIDEyNykgPDwgMTQsIHQgfD0gKHNbZSArIDJdICYgMTI3KSA8PCA3LCB0IHw9IHNbZSArIDNdICYgMTI3LCB0O1xufVxuZnVuY3Rpb24gRWkocywgZSkge1xuICBjb25zdCB0ID0gZTtcbiAgbGV0IHIgPSAwO1xuICBmb3IgKDsgQXUocywgZSk7ICkge1xuICAgIHIgKz0gMTA7XG4gICAgY29uc3QgbiA9IHZhKHMsIGUgKyA2KTtcbiAgICByICs9IG4sIG9wKHMsIGUgKyAxMCkgJiYgKHIgKz0gMTApLCBlICs9IHI7XG4gIH1cbiAgaWYgKHIgPiAwKVxuICAgIHJldHVybiBzLnN1YmFycmF5KHQsIHQgKyByKTtcbn1cbmZ1bmN0aW9uIGRUKHMsIGUsIHQsIHIpIHtcbiAgY29uc3QgbiA9IFs5NmUzLCA4ODIwMCwgNjRlMywgNDhlMywgNDQxMDAsIDMyZTMsIDI0ZTMsIDIyMDUwLCAxNmUzLCAxMmUzLCAxMTAyNSwgOGUzLCA3MzUwXSwgaSA9IGVbdCArIDJdLCBvID0gaSA+PiAyICYgMTU7XG4gIGlmIChvID4gMTIpIHtcbiAgICBjb25zdCBmID0gbmV3IEVycm9yKGBpbnZhbGlkIEFEVFMgc2FtcGxpbmcgaW5kZXg6JHtvfWApO1xuICAgIHMuZW1pdChJLkVSUk9SLCBJLkVSUk9SLCB7XG4gICAgICB0eXBlOiB2ZS5NRURJQV9FUlJPUixcbiAgICAgIGRldGFpbHM6IEouRlJBR19QQVJTSU5HX0VSUk9SLFxuICAgICAgZmF0YWw6ICEwLFxuICAgICAgZXJyb3I6IGYsXG4gICAgICByZWFzb246IGYubWVzc2FnZVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBhID0gKGkgPj4gNiAmIDMpICsgMSwgbCA9IGVbdCArIDNdID4+IDYgJiAzIHwgKGkgJiAxKSA8PCAyLCBjID0gXCJtcDRhLjQwLlwiICsgYSwgdSA9IG5bb107XG4gIGxldCBkID0gbztcbiAgKGEgPT09IDUgfHwgYSA9PT0gMjkpICYmIChkIC09IDMpO1xuICBjb25zdCBoID0gW2EgPDwgMyB8IChkICYgMTQpID4+IDEsIChkICYgMSkgPDwgNyB8IGwgPDwgM107XG4gIHJldHVybiBydC5sb2coYG1hbmlmZXN0IGNvZGVjOiR7cn0sIHBhcnNlZCBjb2RlYzoke2N9LCBjaGFubmVsczoke2x9LCByYXRlOiR7dX0gKEFEVFMgb2JqZWN0IHR5cGU6JHthfSBzYW1wbGluZyBpbmRleDoke299KWApLCB7XG4gICAgY29uZmlnOiBoLFxuICAgIHNhbXBsZXJhdGU6IHUsXG4gICAgY2hhbm5lbENvdW50OiBsLFxuICAgIGNvZGVjOiBjLFxuICAgIHBhcnNlZENvZGVjOiBjLFxuICAgIG1hbmlmZXN0Q29kZWM6IHJcbiAgfTtcbn1cbmZ1bmN0aW9uIGFwKHMsIGUpIHtcbiAgcmV0dXJuIHNbZV0gPT09IDI1NSAmJiAoc1tlICsgMV0gJiAyNDYpID09PSAyNDA7XG59XG5mdW5jdGlvbiBscChzLCBlKSB7XG4gIHJldHVybiBzW2UgKyAxXSAmIDEgPyA3IDogOTtcbn1cbmZ1bmN0aW9uIEl1KHMsIGUpIHtcbiAgcmV0dXJuIChzW2UgKyAzXSAmIDMpIDw8IDExIHwgc1tlICsgNF0gPDwgMyB8IChzW2UgKyA1XSAmIDIyNCkgPj4+IDU7XG59XG5mdW5jdGlvbiBoVChzLCBlKSB7XG4gIHJldHVybiBlICsgNSA8IHMubGVuZ3RoO1xufVxuZnVuY3Rpb24gbmEocywgZSkge1xuICByZXR1cm4gZSArIDEgPCBzLmxlbmd0aCAmJiBhcChzLCBlKTtcbn1cbmZ1bmN0aW9uIGZUKHMsIGUpIHtcbiAgcmV0dXJuIGhUKHMsIGUpICYmIGFwKHMsIGUpICYmIEl1KHMsIGUpIDw9IHMubGVuZ3RoIC0gZTtcbn1cbmZ1bmN0aW9uIGdUKHMsIGUpIHtcbiAgaWYgKG5hKHMsIGUpKSB7XG4gICAgY29uc3QgdCA9IGxwKHMsIGUpO1xuICAgIGlmIChlICsgdCA+PSBzLmxlbmd0aClcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCByID0gSXUocywgZSk7XG4gICAgaWYgKHIgPD0gdClcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBuID0gZSArIHI7XG4gICAgcmV0dXJuIG4gPT09IHMubGVuZ3RoIHx8IG5hKHMsIG4pO1xuICB9XG4gIHJldHVybiAhMTtcbn1cbmZ1bmN0aW9uIGNwKHMsIGUsIHQsIHIsIG4pIHtcbiAgaWYgKCFzLnNhbXBsZXJhdGUpIHtcbiAgICBjb25zdCBpID0gZFQoZSwgdCwgciwgbik7XG4gICAgaWYgKCFpKVxuICAgICAgcmV0dXJuO1xuICAgIG50KHMsIGkpO1xuICB9XG59XG5mdW5jdGlvbiB1cChzKSB7XG4gIHJldHVybiAxMDI0ICogOWU0IC8gcztcbn1cbmZ1bmN0aW9uIHBUKHMsIGUpIHtcbiAgY29uc3QgdCA9IGxwKHMsIGUpO1xuICBpZiAoZSArIHQgPD0gcy5sZW5ndGgpIHtcbiAgICBjb25zdCByID0gSXUocywgZSkgLSB0O1xuICAgIGlmIChyID4gMClcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhlYWRlckxlbmd0aDogdCxcbiAgICAgICAgZnJhbWVMZW5ndGg6IHJcbiAgICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGRwKHMsIGUsIHQsIHIsIG4pIHtcbiAgY29uc3QgaSA9IHVwKHMuc2FtcGxlcmF0ZSksIG8gPSByICsgbiAqIGksIGEgPSBwVChlLCB0KTtcbiAgbGV0IGw7XG4gIGlmIChhKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhbWVMZW5ndGg6IGQsXG4gICAgICBoZWFkZXJMZW5ndGg6IGhcbiAgICB9ID0gYSwgZiA9IGggKyBkLCBwID0gTWF0aC5tYXgoMCwgdCArIGYgLSBlLmxlbmd0aCk7XG4gICAgcCA/IChsID0gbmV3IFVpbnQ4QXJyYXkoZiAtIGgpLCBsLnNldChlLnN1YmFycmF5KHQgKyBoLCBlLmxlbmd0aCksIDApKSA6IGwgPSBlLnN1YmFycmF5KHQgKyBoLCB0ICsgZik7XG4gICAgY29uc3QgeSA9IHtcbiAgICAgIHVuaXQ6IGwsXG4gICAgICBwdHM6IG9cbiAgICB9O1xuICAgIHJldHVybiBwIHx8IHMuc2FtcGxlcy5wdXNoKHkpLCB7XG4gICAgICBzYW1wbGU6IHksXG4gICAgICBsZW5ndGg6IGYsXG4gICAgICBtaXNzaW5nOiBwXG4gICAgfTtcbiAgfVxuICBjb25zdCBjID0gZS5sZW5ndGggLSB0O1xuICByZXR1cm4gbCA9IG5ldyBVaW50OEFycmF5KGMpLCBsLnNldChlLnN1YmFycmF5KHQsIGUubGVuZ3RoKSwgMCksIHtcbiAgICBzYW1wbGU6IHtcbiAgICAgIHVuaXQ6IGwsXG4gICAgICBwdHM6IG9cbiAgICB9LFxuICAgIGxlbmd0aDogYyxcbiAgICBtaXNzaW5nOiAtMVxuICB9O1xufVxuZnVuY3Rpb24gbVQocywgZSkge1xuICByZXR1cm4gQXUocywgZSkgJiYgdmEocywgZSArIDYpICsgMTAgPD0gcy5sZW5ndGggLSBlO1xufVxuZnVuY3Rpb24geVQocykge1xuICByZXR1cm4gcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gcyA6IHMuYnl0ZU9mZnNldCA9PSAwICYmIHMuYnl0ZUxlbmd0aCA9PSBzLmJ1ZmZlci5ieXRlTGVuZ3RoID8gcy5idWZmZXIgOiBuZXcgVWludDhBcnJheShzKS5idWZmZXI7XG59XG5mdW5jdGlvbiB5bChzLCBlID0gMCwgdCA9IDEgLyAwKSB7XG4gIHJldHVybiB2VChzLCBlLCB0LCBVaW50OEFycmF5KTtcbn1cbmZ1bmN0aW9uIHZUKHMsIGUsIHQsIHIpIHtcbiAgY29uc3QgbiA9IEVUKHMpO1xuICBsZXQgaSA9IDE7XG4gIFwiQllURVNfUEVSX0VMRU1FTlRcIiBpbiByICYmIChpID0gci5CWVRFU19QRVJfRUxFTUVOVCk7XG4gIGNvbnN0IG8gPSB4VChzKSA/IHMuYnl0ZU9mZnNldCA6IDAsIGEgPSAobyArIHMuYnl0ZUxlbmd0aCkgLyBpLCBsID0gKG8gKyBlKSAvIGksIGMgPSBNYXRoLmZsb29yKE1hdGgubWF4KDAsIE1hdGgubWluKGwsIGEpKSksIHUgPSBNYXRoLmZsb29yKE1hdGgubWluKGMgKyBNYXRoLm1heCh0LCAwKSwgYSkpO1xuICByZXR1cm4gbmV3IHIobiwgYywgdSAtIGMpO1xufVxuZnVuY3Rpb24gRVQocykge1xuICByZXR1cm4gcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gcyA6IHMuYnVmZmVyO1xufVxuZnVuY3Rpb24geFQocykge1xuICByZXR1cm4gcyAmJiBzLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyICYmIHMuYnl0ZUxlbmd0aCAhPT0gdm9pZCAwICYmIHMuYnl0ZU9mZnNldCAhPT0gdm9pZCAwO1xufVxuZnVuY3Rpb24gU1Qocykge1xuICBjb25zdCBlID0ge1xuICAgIGtleTogcy50eXBlLFxuICAgIGRlc2NyaXB0aW9uOiBcIlwiLFxuICAgIGRhdGE6IFwiXCIsXG4gICAgbWltZVR5cGU6IG51bGwsXG4gICAgcGljdHVyZVR5cGU6IG51bGxcbiAgfSwgdCA9IDM7XG4gIGlmIChzLnNpemUgPCAyKVxuICAgIHJldHVybjtcbiAgaWYgKHMuZGF0YVswXSAhPT0gdCkge1xuICAgIGNvbnNvbGUubG9nKFwiSWdub3JlIGZyYW1lIHdpdGggdW5yZWNvZ25pemVkIGNoYXJhY3RlciBlbmNvZGluZ1wiKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgciA9IHMuZGF0YS5zdWJhcnJheSgxKS5pbmRleE9mKDApO1xuICBpZiAociA9PT0gLTEpXG4gICAgcmV0dXJuO1xuICBjb25zdCBuID0gVHIoeWwocy5kYXRhLCAxLCByKSksIGkgPSBzLmRhdGFbMiArIHJdLCBvID0gcy5kYXRhLnN1YmFycmF5KDMgKyByKS5pbmRleE9mKDApO1xuICBpZiAobyA9PT0gLTEpXG4gICAgcmV0dXJuO1xuICBjb25zdCBhID0gVHIoeWwocy5kYXRhLCAzICsgciwgbykpO1xuICBsZXQgbDtcbiAgcmV0dXJuIG4gPT09IFwiLS0+XCIgPyBsID0gVHIoeWwocy5kYXRhLCA0ICsgciArIG8pKSA6IGwgPSB5VChzLmRhdGEuc3ViYXJyYXkoNCArIHIgKyBvKSksIGUubWltZVR5cGUgPSBuLCBlLnBpY3R1cmVUeXBlID0gaSwgZS5kZXNjcmlwdGlvbiA9IGEsIGUuZGF0YSA9IGwsIGU7XG59XG5mdW5jdGlvbiBiVChzKSB7XG4gIGlmIChzLnNpemUgPCAyKVxuICAgIHJldHVybjtcbiAgY29uc3QgZSA9IFRyKHMuZGF0YSwgITApLCB0ID0gbmV3IFVpbnQ4QXJyYXkocy5kYXRhLnN1YmFycmF5KGUubGVuZ3RoICsgMSkpO1xuICByZXR1cm4ge1xuICAgIGtleTogcy50eXBlLFxuICAgIGluZm86IGUsXG4gICAgZGF0YTogdC5idWZmZXJcbiAgfTtcbn1cbmZ1bmN0aW9uIFRUKHMpIHtcbiAgaWYgKHMuc2l6ZSA8IDIpXG4gICAgcmV0dXJuO1xuICBpZiAocy50eXBlID09PSBcIlRYWFhcIikge1xuICAgIGxldCB0ID0gMTtcbiAgICBjb25zdCByID0gVHIocy5kYXRhLnN1YmFycmF5KHQpLCAhMCk7XG4gICAgdCArPSByLmxlbmd0aCArIDE7XG4gICAgY29uc3QgbiA9IFRyKHMuZGF0YS5zdWJhcnJheSh0KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogcy50eXBlLFxuICAgICAgaW5mbzogcixcbiAgICAgIGRhdGE6IG5cbiAgICB9O1xuICB9XG4gIGNvbnN0IGUgPSBUcihzLmRhdGEuc3ViYXJyYXkoMSkpO1xuICByZXR1cm4ge1xuICAgIGtleTogcy50eXBlLFxuICAgIGluZm86IFwiXCIsXG4gICAgZGF0YTogZVxuICB9O1xufVxuZnVuY3Rpb24gd1Qocykge1xuICBpZiAocy50eXBlID09PSBcIldYWFhcIikge1xuICAgIGlmIChzLnNpemUgPCAyKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCB0ID0gMTtcbiAgICBjb25zdCByID0gVHIocy5kYXRhLnN1YmFycmF5KHQpLCAhMCk7XG4gICAgdCArPSByLmxlbmd0aCArIDE7XG4gICAgY29uc3QgbiA9IFRyKHMuZGF0YS5zdWJhcnJheSh0KSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogcy50eXBlLFxuICAgICAgaW5mbzogcixcbiAgICAgIGRhdGE6IG5cbiAgICB9O1xuICB9XG4gIGNvbnN0IGUgPSBUcihzLmRhdGEpO1xuICByZXR1cm4ge1xuICAgIGtleTogcy50eXBlLFxuICAgIGluZm86IFwiXCIsXG4gICAgZGF0YTogZVxuICB9O1xufVxuZnVuY3Rpb24gQVQocykge1xuICByZXR1cm4gcy50eXBlID09PSBcIlBSSVZcIiA/IGJUKHMpIDogcy50eXBlWzBdID09PSBcIldcIiA/IHdUKHMpIDogcy50eXBlID09PSBcIkFQSUNcIiA/IFNUKHMpIDogVFQocyk7XG59XG5mdW5jdGlvbiBJVChzKSB7XG4gIGNvbnN0IGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHNbMF0sIHNbMV0sIHNbMl0sIHNbM10pLCB0ID0gdmEocywgNCksIHIgPSAxMDtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBlLFxuICAgIHNpemU6IHQsXG4gICAgZGF0YTogcy5zdWJhcnJheShyLCByICsgdClcbiAgfTtcbn1cbmNvbnN0IHppID0gMTAsIF9UID0gMTA7XG5mdW5jdGlvbiBocChzKSB7XG4gIGxldCBlID0gMDtcbiAgY29uc3QgdCA9IFtdO1xuICBmb3IgKDsgQXUocywgZSk7ICkge1xuICAgIGNvbnN0IHIgPSB2YShzLCBlICsgNik7XG4gICAgc1tlICsgNV0gPj4gNiAmIDEgJiYgKGUgKz0gemkpLCBlICs9IHppO1xuICAgIGNvbnN0IG4gPSBlICsgcjtcbiAgICBmb3IgKDsgZSArIF9UIDwgbjsgKSB7XG4gICAgICBjb25zdCBpID0gSVQocy5zdWJhcnJheShlKSksIG8gPSBBVChpKTtcbiAgICAgIG8gJiYgdC5wdXNoKG8pLCBlICs9IGkuc2l6ZSArIHppO1xuICAgIH1cbiAgICBvcChzLCBlKSAmJiAoZSArPSB6aSk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBmcChzKSB7XG4gIHJldHVybiBzICYmIHMua2V5ID09PSBcIlBSSVZcIiAmJiBzLmluZm8gPT09IFwiY29tLmFwcGxlLnN0cmVhbWluZy50cmFuc3BvcnRTdHJlYW1UaW1lc3RhbXBcIjtcbn1cbmZ1bmN0aW9uIFJUKHMpIHtcbiAgaWYgKHMuZGF0YS5ieXRlTGVuZ3RoID09PSA4KSB7XG4gICAgY29uc3QgZSA9IG5ldyBVaW50OEFycmF5KHMuZGF0YSksIHQgPSBlWzNdICYgMTtcbiAgICBsZXQgciA9IChlWzRdIDw8IDIzKSArIChlWzVdIDw8IDE1KSArIChlWzZdIDw8IDcpICsgZVs3XTtcbiAgICByZXR1cm4gciAvPSA0NSwgdCAmJiAociArPSA0NzcyMTg1ODg0ZS0yKSwgTWF0aC5yb3VuZChyKTtcbiAgfVxufVxuZnVuY3Rpb24gX3Uocykge1xuICBjb25zdCBlID0gaHAocyk7XG4gIGZvciAobGV0IHQgPSAwOyB0IDwgZS5sZW5ndGg7IHQrKykge1xuICAgIGNvbnN0IHIgPSBlW3RdO1xuICAgIGlmIChmcChyKSlcbiAgICAgIHJldHVybiBSVChyKTtcbiAgfVxufVxubGV0IGJyID0gLyogQF9fUFVSRV9fICovIChmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzLmF1ZGlvSWQzID0gXCJvcmcuaWQzXCIsIHMuZGF0ZVJhbmdlID0gXCJjb20uYXBwbGUucXVpY2t0aW1lLkhMU1wiLCBzLmVtc2cgPSBcImh0dHBzOi8vYW9tZWRpYS5vcmcvZW1zZy9JRDNcIiwgcy5taXNia2x2ID0gXCJ1cm46bWlzYjpLTFY6YmluOjE5MTAuMVwiLCBzO1xufSkoe30pO1xuZnVuY3Rpb24ganIocyA9IFwiXCIsIGUgPSA5ZTQpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBzLFxuICAgIGlkOiAtMSxcbiAgICBwaWQ6IC0xLFxuICAgIGlucHV0VGltZVNjYWxlOiBlLFxuICAgIHNlcXVlbmNlTnVtYmVyOiAtMSxcbiAgICBzYW1wbGVzOiBbXSxcbiAgICBkcm9wcGVkOiAwXG4gIH07XG59XG5jbGFzcyBSdSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2F1ZGlvVHJhY2sgPSB2b2lkIDAsIHRoaXMuX2lkM1RyYWNrID0gdm9pZCAwLCB0aGlzLmZyYW1lSW5kZXggPSAwLCB0aGlzLmNhY2hlZERhdGEgPSBudWxsLCB0aGlzLmJhc2VQVFMgPSBudWxsLCB0aGlzLmluaXRQVFMgPSBudWxsLCB0aGlzLmxhc3RQVFMgPSBudWxsO1xuICB9XG4gIHJlc2V0SW5pdFNlZ21lbnQoZSwgdCwgciwgbikge1xuICAgIHRoaXMuX2lkM1RyYWNrID0ge1xuICAgICAgdHlwZTogXCJpZDNcIixcbiAgICAgIGlkOiAzLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5ZTQsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgZHJvcHBlZDogMFxuICAgIH07XG4gIH1cbiAgcmVzZXRUaW1lU3RhbXAoZSkge1xuICAgIHRoaXMuaW5pdFBUUyA9IGUsIHRoaXMucmVzZXRDb250aWd1aXR5KCk7XG4gIH1cbiAgcmVzZXRDb250aWd1aXR5KCkge1xuICAgIHRoaXMuYmFzZVBUUyA9IG51bGwsIHRoaXMubGFzdFBUUyA9IG51bGwsIHRoaXMuZnJhbWVJbmRleCA9IDA7XG4gIH1cbiAgY2FuUGFyc2UoZSwgdCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBhcHBlbmRGcmFtZShlLCB0LCByKSB7XG4gIH1cbiAgLy8gZmVlZCBpbmNvbWluZyBkYXRhIHRvIHRoZSBmcm9udCBvZiB0aGUgcGFyc2luZyBwaXBlbGluZVxuICBkZW11eChlLCB0KSB7XG4gICAgdGhpcy5jYWNoZWREYXRhICYmIChlID0gX3IodGhpcy5jYWNoZWREYXRhLCBlKSwgdGhpcy5jYWNoZWREYXRhID0gbnVsbCk7XG4gICAgbGV0IHIgPSBFaShlLCAwKSwgbiA9IHIgPyByLmxlbmd0aCA6IDAsIGk7XG4gICAgY29uc3QgbyA9IHRoaXMuX2F1ZGlvVHJhY2ssIGEgPSB0aGlzLl9pZDNUcmFjaywgbCA9IHIgPyBfdShyKSA6IHZvaWQgMCwgYyA9IGUubGVuZ3RoO1xuICAgIGZvciAoKHRoaXMuYmFzZVBUUyA9PT0gbnVsbCB8fCB0aGlzLmZyYW1lSW5kZXggPT09IDAgJiYgdWUobCkpICYmICh0aGlzLmJhc2VQVFMgPSBMVChsLCB0LCB0aGlzLmluaXRQVFMpLCB0aGlzLmxhc3RQVFMgPSB0aGlzLmJhc2VQVFMpLCB0aGlzLmxhc3RQVFMgPT09IG51bGwgJiYgKHRoaXMubGFzdFBUUyA9IHRoaXMuYmFzZVBUUyksIHIgJiYgci5sZW5ndGggPiAwICYmIGEuc2FtcGxlcy5wdXNoKHtcbiAgICAgIHB0czogdGhpcy5sYXN0UFRTLFxuICAgICAgZHRzOiB0aGlzLmxhc3RQVFMsXG4gICAgICBkYXRhOiByLFxuICAgICAgdHlwZTogYnIuYXVkaW9JZDMsXG4gICAgICBkdXJhdGlvbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgfSk7IG4gPCBjOyApIHtcbiAgICAgIGlmICh0aGlzLmNhblBhcnNlKGUsIG4pKSB7XG4gICAgICAgIGNvbnN0IHUgPSB0aGlzLmFwcGVuZEZyYW1lKG8sIGUsIG4pO1xuICAgICAgICB1ID8gKHRoaXMuZnJhbWVJbmRleCsrLCB0aGlzLmxhc3RQVFMgPSB1LnNhbXBsZS5wdHMsIG4gKz0gdS5sZW5ndGgsIGkgPSBuKSA6IG4gPSBjO1xuICAgICAgfSBlbHNlIG1UKGUsIG4pID8gKHIgPSBFaShlLCBuKSwgYS5zYW1wbGVzLnB1c2goe1xuICAgICAgICBwdHM6IHRoaXMubGFzdFBUUyxcbiAgICAgICAgZHRzOiB0aGlzLmxhc3RQVFMsXG4gICAgICAgIGRhdGE6IHIsXG4gICAgICAgIHR5cGU6IGJyLmF1ZGlvSWQzLFxuICAgICAgICBkdXJhdGlvbjogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXG4gICAgICB9KSwgbiArPSByLmxlbmd0aCwgaSA9IG4pIDogbisrO1xuICAgICAgaWYgKG4gPT09IGMgJiYgaSAhPT0gYykge1xuICAgICAgICBjb25zdCB1ID0gZS5zbGljZShpKTtcbiAgICAgICAgdGhpcy5jYWNoZWREYXRhID8gdGhpcy5jYWNoZWREYXRhID0gX3IodGhpcy5jYWNoZWREYXRhLCB1KSA6IHRoaXMuY2FjaGVkRGF0YSA9IHU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBhdWRpb1RyYWNrOiBvLFxuICAgICAgdmlkZW9UcmFjazoganIoKSxcbiAgICAgIGlkM1RyYWNrOiBhLFxuICAgICAgdGV4dFRyYWNrOiBqcigpXG4gICAgfTtcbiAgfVxuICBkZW11eFNhbXBsZUFlcyhlLCB0LCByKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihgWyR7dGhpc31dIFRoaXMgZGVtdXhlciBkb2VzIG5vdCBzdXBwb3J0IFNhbXBsZS1BRVMgZGVjcnlwdGlvbmApKTtcbiAgfVxuICBmbHVzaChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY2FjaGVkRGF0YTtcbiAgICByZXR1cm4gdCAmJiAodGhpcy5jYWNoZWREYXRhID0gbnVsbCwgdGhpcy5kZW11eCh0LCAwKSksIHtcbiAgICAgIGF1ZGlvVHJhY2s6IHRoaXMuX2F1ZGlvVHJhY2ssXG4gICAgICB2aWRlb1RyYWNrOiBqcigpLFxuICAgICAgaWQzVHJhY2s6IHRoaXMuX2lkM1RyYWNrLFxuICAgICAgdGV4dFRyYWNrOiBqcigpXG4gICAgfTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2FjaGVkRGF0YSA9IG51bGwsIHRoaXMuX2F1ZGlvVHJhY2sgPSB0aGlzLl9pZDNUcmFjayA9IHZvaWQgMDtcbiAgfVxufVxuY29uc3QgTFQgPSAocywgZSwgdCkgPT4ge1xuICBpZiAodWUocykpXG4gICAgcmV0dXJuIHMgKiA5MDtcbiAgY29uc3QgciA9IHQgPyB0LmJhc2VUaW1lICogOWU0IC8gdC50aW1lc2NhbGUgOiAwO1xuICByZXR1cm4gZSAqIDllNCArIHI7XG59O1xubGV0IFlpID0gbnVsbDtcbmNvbnN0IENUID0gWzMyLCA2NCwgOTYsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAyODgsIDMyMCwgMzUyLCAzODQsIDQxNiwgNDQ4LCAzMiwgNDgsIDU2LCA2NCwgODAsIDk2LCAxMTIsIDEyOCwgMTYwLCAxOTIsIDIyNCwgMjU2LCAzMjAsIDM4NCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNjAsIDE5MiwgMjI0LCAyNTYsIDMyMCwgMzIsIDQ4LCA1NiwgNjQsIDgwLCA5NiwgMTEyLCAxMjgsIDE0NCwgMTYwLCAxNzYsIDE5MiwgMjI0LCAyNTYsIDgsIDE2LCAyNCwgMzIsIDQwLCA0OCwgNTYsIDY0LCA4MCwgOTYsIDExMiwgMTI4LCAxNDQsIDE2MF0sIGtUID0gWzQ0MTAwLCA0OGUzLCAzMmUzLCAyMjA1MCwgMjRlMywgMTZlMywgMTEwMjUsIDEyZTMsIDhlM10sIERUID0gW1xuICAvLyBNUEVHIDIuNVxuICBbXG4gICAgMCxcbiAgICAvLyBSZXNlcnZlZFxuICAgIDcyLFxuICAgIC8vIExheWVyM1xuICAgIDE0NCxcbiAgICAvLyBMYXllcjJcbiAgICAxMlxuICAgIC8vIExheWVyMVxuICBdLFxuICAvLyBSZXNlcnZlZFxuICBbXG4gICAgMCxcbiAgICAvLyBSZXNlcnZlZFxuICAgIDAsXG4gICAgLy8gTGF5ZXIzXG4gICAgMCxcbiAgICAvLyBMYXllcjJcbiAgICAwXG4gICAgLy8gTGF5ZXIxXG4gIF0sXG4gIC8vIE1QRUcgMlxuICBbXG4gICAgMCxcbiAgICAvLyBSZXNlcnZlZFxuICAgIDcyLFxuICAgIC8vIExheWVyM1xuICAgIDE0NCxcbiAgICAvLyBMYXllcjJcbiAgICAxMlxuICAgIC8vIExheWVyMVxuICBdLFxuICAvLyBNUEVHIDFcbiAgW1xuICAgIDAsXG4gICAgLy8gUmVzZXJ2ZWRcbiAgICAxNDQsXG4gICAgLy8gTGF5ZXIzXG4gICAgMTQ0LFxuICAgIC8vIExheWVyMlxuICAgIDEyXG4gICAgLy8gTGF5ZXIxXG4gIF1cbl0sIFBUID0gW1xuICAwLFxuICAvLyBSZXNlcnZlZFxuICAxLFxuICAvLyBMYXllcjNcbiAgMSxcbiAgLy8gTGF5ZXIyXG4gIDRcbiAgLy8gTGF5ZXIxXG5dO1xuZnVuY3Rpb24gZ3AocywgZSwgdCwgciwgbikge1xuICBpZiAodCArIDI0ID4gZS5sZW5ndGgpXG4gICAgcmV0dXJuO1xuICBjb25zdCBpID0gcHAoZSwgdCk7XG4gIGlmIChpICYmIHQgKyBpLmZyYW1lTGVuZ3RoIDw9IGUubGVuZ3RoKSB7XG4gICAgY29uc3QgbyA9IGkuc2FtcGxlc1BlckZyYW1lICogOWU0IC8gaS5zYW1wbGVSYXRlLCBhID0gciArIG4gKiBvLCBsID0ge1xuICAgICAgdW5pdDogZS5zdWJhcnJheSh0LCB0ICsgaS5mcmFtZUxlbmd0aCksXG4gICAgICBwdHM6IGEsXG4gICAgICBkdHM6IGFcbiAgICB9O1xuICAgIHJldHVybiBzLmNvbmZpZyA9IFtdLCBzLmNoYW5uZWxDb3VudCA9IGkuY2hhbm5lbENvdW50LCBzLnNhbXBsZXJhdGUgPSBpLnNhbXBsZVJhdGUsIHMuc2FtcGxlcy5wdXNoKGwpLCB7XG4gICAgICBzYW1wbGU6IGwsXG4gICAgICBsZW5ndGg6IGkuZnJhbWVMZW5ndGgsXG4gICAgICBtaXNzaW5nOiAwXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gcHAocywgZSkge1xuICBjb25zdCB0ID0gc1tlICsgMV0gPj4gMyAmIDMsIHIgPSBzW2UgKyAxXSA+PiAxICYgMywgbiA9IHNbZSArIDJdID4+IDQgJiAxNSwgaSA9IHNbZSArIDJdID4+IDIgJiAzO1xuICBpZiAodCAhPT0gMSAmJiBuICE9PSAwICYmIG4gIT09IDE1ICYmIGkgIT09IDMpIHtcbiAgICBjb25zdCBvID0gc1tlICsgMl0gPj4gMSAmIDEsIGEgPSBzW2UgKyAzXSA+PiA2LCBsID0gdCA9PT0gMyA/IDMgLSByIDogciA9PT0gMyA/IDMgOiA0LCBjID0gQ1RbbCAqIDE0ICsgbiAtIDFdICogMWUzLCBkID0ga1RbKHQgPT09IDMgPyAwIDogdCA9PT0gMiA/IDEgOiAyKSAqIDMgKyBpXSwgaCA9IGEgPT09IDMgPyAxIDogMiwgZiA9IERUW3RdW3JdLCBwID0gUFRbcl0sIHkgPSBmICogOCAqIHAsIEUgPSBNYXRoLmZsb29yKGYgKiBjIC8gZCArIG8pICogcDtcbiAgICBpZiAoWWkgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IEEgPSAobmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBcIlwiKS5tYXRjaCgvQ2hyb21lXFwvKFxcZCspL2kpO1xuICAgICAgWWkgPSBBID8gcGFyc2VJbnQoQVsxXSkgOiAwO1xuICAgIH1cbiAgICByZXR1cm4gISFZaSAmJiBZaSA8PSA4NyAmJiByID09PSAyICYmIGMgPj0gMjI0ZTMgJiYgYSA9PT0gMCAmJiAoc1tlICsgM10gPSBzW2UgKyAzXSB8IDEyOCksIHtcbiAgICAgIHNhbXBsZVJhdGU6IGQsXG4gICAgICBjaGFubmVsQ291bnQ6IGgsXG4gICAgICBmcmFtZUxlbmd0aDogRSxcbiAgICAgIHNhbXBsZXNQZXJGcmFtZTogeVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIEx1KHMsIGUpIHtcbiAgcmV0dXJuIHNbZV0gPT09IDI1NSAmJiAoc1tlICsgMV0gJiAyMjQpID09PSAyMjQgJiYgKHNbZSArIDFdICYgNikgIT09IDA7XG59XG5mdW5jdGlvbiBtcChzLCBlKSB7XG4gIHJldHVybiBlICsgMSA8IHMubGVuZ3RoICYmIEx1KHMsIGUpO1xufVxuZnVuY3Rpb24gTVQocywgZSkge1xuICByZXR1cm4gTHUocywgZSkgJiYgNCA8PSBzLmxlbmd0aCAtIGU7XG59XG5mdW5jdGlvbiB5cChzLCBlKSB7XG4gIGlmIChlICsgMSA8IHMubGVuZ3RoICYmIEx1KHMsIGUpKSB7XG4gICAgY29uc3QgciA9IHBwKHMsIGUpO1xuICAgIGxldCBuID0gNDtcbiAgICByICE9IG51bGwgJiYgci5mcmFtZUxlbmd0aCAmJiAobiA9IHIuZnJhbWVMZW5ndGgpO1xuICAgIGNvbnN0IGkgPSBlICsgbjtcbiAgICByZXR1cm4gaSA9PT0gcy5sZW5ndGggfHwgbXAocywgaSk7XG4gIH1cbiAgcmV0dXJuICExO1xufVxuY2xhc3MgT1QgZXh0ZW5kcyBSdSB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcigpLCB0aGlzLm9ic2VydmVyID0gdm9pZCAwLCB0aGlzLmNvbmZpZyA9IHZvaWQgMCwgdGhpcy5vYnNlcnZlciA9IGUsIHRoaXMuY29uZmlnID0gdDtcbiAgfVxuICByZXNldEluaXRTZWdtZW50KGUsIHQsIHIsIG4pIHtcbiAgICBzdXBlci5yZXNldEluaXRTZWdtZW50KGUsIHQsIHIsIG4pLCB0aGlzLl9hdWRpb1RyYWNrID0ge1xuICAgICAgY29udGFpbmVyOiBcImF1ZGlvL2FkdHNcIixcbiAgICAgIHR5cGU6IFwiYXVkaW9cIixcbiAgICAgIGlkOiAyLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIHNlcXVlbmNlTnVtYmVyOiAwLFxuICAgICAgc2VnbWVudENvZGVjOiBcImFhY1wiLFxuICAgICAgc2FtcGxlczogW10sXG4gICAgICBtYW5pZmVzdENvZGVjOiB0LFxuICAgICAgZHVyYXRpb246IG4sXG4gICAgICBpbnB1dFRpbWVTY2FsZTogOWU0LFxuICAgICAgZHJvcHBlZDogMFxuICAgIH07XG4gIH1cbiAgLy8gU291cmNlIGZvciBwcm9iZSBpbmZvIC0gaHR0cHM6Ly93aWtpLm11bHRpbWVkaWEuY3gvaW5kZXgucGhwP3RpdGxlPUFEVFNcbiAgc3RhdGljIHByb2JlKGUsIHQpIHtcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgciA9IEVpKGUsIDApO1xuICAgIGxldCBuID0gKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIubGVuZ3RoKSB8fCAwO1xuICAgIGlmICh5cChlLCBuKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBmb3IgKGxldCBpID0gZS5sZW5ndGg7IG4gPCBpOyBuKyspXG4gICAgICBpZiAoZ1QoZSwgbikpXG4gICAgICAgIHJldHVybiB0LmxvZyhcIkFEVFMgc3luYyB3b3JkIGZvdW5kICFcIiksICEwO1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBjYW5QYXJzZShlLCB0KSB7XG4gICAgcmV0dXJuIGZUKGUsIHQpO1xuICB9XG4gIGFwcGVuZEZyYW1lKGUsIHQsIHIpIHtcbiAgICBjcChlLCB0aGlzLm9ic2VydmVyLCB0LCByLCBlLm1hbmlmZXN0Q29kZWMpO1xuICAgIGNvbnN0IG4gPSBkcChlLCB0LCByLCB0aGlzLmJhc2VQVFMsIHRoaXMuZnJhbWVJbmRleCk7XG4gICAgaWYgKG4gJiYgbi5taXNzaW5nID09PSAwKVxuICAgICAgcmV0dXJuIG47XG4gIH1cbn1cbmNvbnN0IHZwID0gKHMsIGUpID0+IHtcbiAgbGV0IHQgPSAwLCByID0gNTtcbiAgZSArPSByO1xuICBjb25zdCBuID0gbmV3IFVpbnQzMkFycmF5KDEpLCBpID0gbmV3IFVpbnQzMkFycmF5KDEpLCBvID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gIGZvciAoOyByID4gMDsgKSB7XG4gICAgb1swXSA9IHNbZV07XG4gICAgY29uc3QgYSA9IE1hdGgubWluKHIsIDgpLCBsID0gOCAtIGE7XG4gICAgaVswXSA9IDQyNzgxOTAwODAgPj4+IDI0ICsgbCA8PCBsLCBuWzBdID0gKG9bMF0gJiBpWzBdKSA+PiBsLCB0ID0gdCA/IHQgPDwgYSB8IG5bMF0gOiBuWzBdLCBlICs9IDEsIHIgLT0gYTtcbiAgfVxuICByZXR1cm4gdDtcbn07XG5jbGFzcyBCVCBleHRlbmRzIFJ1IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKCksIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDAsIHRoaXMub2JzZXJ2ZXIgPSBlO1xuICB9XG4gIHJlc2V0SW5pdFNlZ21lbnQoZSwgdCwgciwgbikge1xuICAgIHN1cGVyLnJlc2V0SW5pdFNlZ21lbnQoZSwgdCwgciwgbiksIHRoaXMuX2F1ZGlvVHJhY2sgPSB7XG4gICAgICBjb250YWluZXI6IFwiYXVkaW8vYWMtM1wiLFxuICAgICAgdHlwZTogXCJhdWRpb1wiLFxuICAgICAgaWQ6IDIsXG4gICAgICBwaWQ6IC0xLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBzZWdtZW50Q29kZWM6IFwiYWMzXCIsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIG1hbmlmZXN0Q29kZWM6IHQsXG4gICAgICBkdXJhdGlvbjogbixcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5ZTQsXG4gICAgICBkcm9wcGVkOiAwXG4gICAgfTtcbiAgfVxuICBjYW5QYXJzZShlLCB0KSB7XG4gICAgcmV0dXJuIHQgKyA2NCA8IGUubGVuZ3RoO1xuICB9XG4gIGFwcGVuZEZyYW1lKGUsIHQsIHIpIHtcbiAgICBjb25zdCBuID0gRXAoZSwgdCwgciwgdGhpcy5iYXNlUFRTLCB0aGlzLmZyYW1lSW5kZXgpO1xuICAgIGlmIChuICE9PSAtMSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNhbXBsZTogZS5zYW1wbGVzW2Uuc2FtcGxlcy5sZW5ndGggLSAxXSxcbiAgICAgICAgbGVuZ3RoOiBuLFxuICAgICAgICBtaXNzaW5nOiAwXG4gICAgICB9O1xuICB9XG4gIHN0YXRpYyBwcm9iZShlKSB7XG4gICAgaWYgKCFlKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IHQgPSBFaShlLCAwKTtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgciA9IHQubGVuZ3RoO1xuICAgIHJldHVybiBlW3JdID09PSAxMSAmJiBlW3IgKyAxXSA9PT0gMTE5ICYmIF91KHQpICE9PSB2b2lkIDAgJiYgLy8gY2hlY2sgdGhlIGJzaWQgdG8gY29uZmlybSBhYy0zXG4gICAgdnAoZSwgcikgPCAxNjtcbiAgfVxufVxuZnVuY3Rpb24gRXAocywgZSwgdCwgciwgbikge1xuICBpZiAodCArIDggPiBlLmxlbmd0aCB8fCBlW3RdICE9PSAxMSB8fCBlW3QgKyAxXSAhPT0gMTE5KVxuICAgIHJldHVybiAtMTtcbiAgY29uc3QgaSA9IGVbdCArIDRdID4+IDY7XG4gIGlmIChpID49IDMpXG4gICAgcmV0dXJuIC0xO1xuICBjb25zdCBhID0gWzQ4ZTMsIDQ0MTAwLCAzMmUzXVtpXSwgbCA9IGVbdCArIDRdICYgNjMsIHUgPSBbNjQsIDY5LCA5NiwgNjQsIDcwLCA5NiwgODAsIDg3LCAxMjAsIDgwLCA4OCwgMTIwLCA5NiwgMTA0LCAxNDQsIDk2LCAxMDUsIDE0NCwgMTEyLCAxMjEsIDE2OCwgMTEyLCAxMjIsIDE2OCwgMTI4LCAxMzksIDE5MiwgMTI4LCAxNDAsIDE5MiwgMTYwLCAxNzQsIDI0MCwgMTYwLCAxNzUsIDI0MCwgMTkyLCAyMDgsIDI4OCwgMTkyLCAyMDksIDI4OCwgMjI0LCAyNDMsIDMzNiwgMjI0LCAyNDQsIDMzNiwgMjU2LCAyNzgsIDM4NCwgMjU2LCAyNzksIDM4NCwgMzIwLCAzNDgsIDQ4MCwgMzIwLCAzNDksIDQ4MCwgMzg0LCA0MTcsIDU3NiwgMzg0LCA0MTgsIDU3NiwgNDQ4LCA0ODcsIDY3MiwgNDQ4LCA0ODgsIDY3MiwgNTEyLCA1NTcsIDc2OCwgNTEyLCA1NTgsIDc2OCwgNjQwLCA2OTYsIDk2MCwgNjQwLCA2OTcsIDk2MCwgNzY4LCA4MzUsIDExNTIsIDc2OCwgODM2LCAxMTUyLCA4OTYsIDk3NSwgMTM0NCwgODk2LCA5NzYsIDEzNDQsIDEwMjQsIDExMTQsIDE1MzYsIDEwMjQsIDExMTUsIDE1MzYsIDExNTIsIDEyNTMsIDE3MjgsIDExNTIsIDEyNTQsIDE3MjgsIDEyODAsIDEzOTMsIDE5MjAsIDEyODAsIDEzOTQsIDE5MjBdW2wgKiAzICsgaV0gKiAyO1xuICBpZiAodCArIHUgPiBlLmxlbmd0aClcbiAgICByZXR1cm4gLTE7XG4gIGNvbnN0IGQgPSBlW3QgKyA2XSA+PiA1O1xuICBsZXQgaCA9IDA7XG4gIGQgPT09IDIgPyBoICs9IDIgOiAoZCAmIDEgJiYgZCAhPT0gMSAmJiAoaCArPSAyKSwgZCAmIDQgJiYgKGggKz0gMikpO1xuICBjb25zdCBmID0gKGVbdCArIDZdIDw8IDggfCBlW3QgKyA3XSkgPj4gMTIgLSBoICYgMSwgeSA9IFsyLCAxLCAyLCAzLCAzLCA0LCA0LCA1XVtkXSArIGYsIEUgPSBlW3QgKyA1XSA+PiAzLCBiID0gZVt0ICsgNV0gJiA3LCBSID0gbmV3IFVpbnQ4QXJyYXkoW2kgPDwgNiB8IEUgPDwgMSB8IGIgPj4gMiwgKGIgJiAzKSA8PCA2IHwgZCA8PCAzIHwgZiA8PCAyIHwgbCA+PiA0LCBsIDw8IDQgJiAyMjRdKSwgQSA9IDE1MzYgLyBhICogOWU0LCBGID0gciArIG4gKiBBLCBNID0gZS5zdWJhcnJheSh0LCB0ICsgdSk7XG4gIHJldHVybiBzLmNvbmZpZyA9IFIsIHMuY2hhbm5lbENvdW50ID0geSwgcy5zYW1wbGVyYXRlID0gYSwgcy5zYW1wbGVzLnB1c2goe1xuICAgIHVuaXQ6IE0sXG4gICAgcHRzOiBGXG4gIH0pLCB1O1xufVxuY2xhc3MgRlQgZXh0ZW5kcyBSdSB7XG4gIHJlc2V0SW5pdFNlZ21lbnQoZSwgdCwgciwgbikge1xuICAgIHN1cGVyLnJlc2V0SW5pdFNlZ21lbnQoZSwgdCwgciwgbiksIHRoaXMuX2F1ZGlvVHJhY2sgPSB7XG4gICAgICBjb250YWluZXI6IFwiYXVkaW8vbXBlZ1wiLFxuICAgICAgdHlwZTogXCJhdWRpb1wiLFxuICAgICAgaWQ6IDIsXG4gICAgICBwaWQ6IC0xLFxuICAgICAgc2VxdWVuY2VOdW1iZXI6IDAsXG4gICAgICBzZWdtZW50Q29kZWM6IFwibXAzXCIsXG4gICAgICBzYW1wbGVzOiBbXSxcbiAgICAgIG1hbmlmZXN0Q29kZWM6IHQsXG4gICAgICBkdXJhdGlvbjogbixcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5ZTQsXG4gICAgICBkcm9wcGVkOiAwXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgcHJvYmUoZSkge1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCB0ID0gRWkoZSwgMCk7XG4gICAgbGV0IHIgPSAodCA9PSBudWxsID8gdm9pZCAwIDogdC5sZW5ndGgpIHx8IDA7XG4gICAgaWYgKHQgJiYgZVtyXSA9PT0gMTEgJiYgZVtyICsgMV0gPT09IDExOSAmJiBfdSh0KSAhPT0gdm9pZCAwICYmIC8vIGNoZWNrIHRoZSBic2lkIHRvIGNvbmZpcm0gYWMtMyBvciBlYy0zIChub3QgbXAzKVxuICAgIHZwKGUsIHIpIDw9IDE2KVxuICAgICAgcmV0dXJuICExO1xuICAgIGZvciAobGV0IG4gPSBlLmxlbmd0aDsgciA8IG47IHIrKylcbiAgICAgIGlmICh5cChlLCByKSlcbiAgICAgICAgcmV0dXJuIHJ0LmxvZyhcIk1QRUcgQXVkaW8gc3luYyB3b3JkIGZvdW5kICFcIiksICEwO1xuICAgIHJldHVybiAhMTtcbiAgfVxuICBjYW5QYXJzZShlLCB0KSB7XG4gICAgcmV0dXJuIE1UKGUsIHQpO1xuICB9XG4gIGFwcGVuZEZyYW1lKGUsIHQsIHIpIHtcbiAgICBpZiAodGhpcy5iYXNlUFRTICE9PSBudWxsKVxuICAgICAgcmV0dXJuIGdwKGUsIHQsIHIsIHRoaXMuYmFzZVBUUywgdGhpcy5mcmFtZUluZGV4KTtcbiAgfVxufVxuY29uc3QgTlQgPSAvXFwvZW1zZ1stL11JRDMvaTtcbmNsYXNzIFVUIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGwsIHRoaXMudGltZU9mZnNldCA9IDAsIHRoaXMuY29uZmlnID0gdm9pZCAwLCB0aGlzLnZpZGVvVHJhY2sgPSB2b2lkIDAsIHRoaXMuYXVkaW9UcmFjayA9IHZvaWQgMCwgdGhpcy5pZDNUcmFjayA9IHZvaWQgMCwgdGhpcy50eHRUcmFjayA9IHZvaWQgMCwgdGhpcy5jb25maWcgPSB0O1xuICB9XG4gIHJlc2V0VGltZVN0YW1wKCkge1xuICB9XG4gIHJlc2V0SW5pdFNlZ21lbnQoZSwgdCwgciwgbikge1xuICAgIGNvbnN0IGkgPSB0aGlzLnZpZGVvVHJhY2sgPSBqcihcInZpZGVvXCIsIDEpLCBvID0gdGhpcy5hdWRpb1RyYWNrID0ganIoXCJhdWRpb1wiLCAxKSwgYSA9IHRoaXMudHh0VHJhY2sgPSBqcihcInRleHRcIiwgMSk7XG4gICAgaWYgKHRoaXMuaWQzVHJhY2sgPSBqcihcImlkM1wiLCAxKSwgdGhpcy50aW1lT2Zmc2V0ID0gMCwgIShlICE9IG51bGwgJiYgZS5ieXRlTGVuZ3RoKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsID0gRGcoZSk7XG4gICAgaWYgKGwudmlkZW8pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWQ6IGMsXG4gICAgICAgIHRpbWVzY2FsZTogdSxcbiAgICAgICAgY29kZWM6IGQsXG4gICAgICAgIHN1cHBsZW1lbnRhbDogaFxuICAgICAgfSA9IGwudmlkZW87XG4gICAgICBpLmlkID0gYywgaS50aW1lc2NhbGUgPSBhLnRpbWVzY2FsZSA9IHUsIGkuY29kZWMgPSBkLCBpLnN1cHBsZW1lbnRhbCA9IGg7XG4gICAgfVxuICAgIGlmIChsLmF1ZGlvKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGlkOiBjLFxuICAgICAgICB0aW1lc2NhbGU6IHUsXG4gICAgICAgIGNvZGVjOiBkXG4gICAgICB9ID0gbC5hdWRpbztcbiAgICAgIG8uaWQgPSBjLCBvLnRpbWVzY2FsZSA9IHUsIG8uY29kZWMgPSBkO1xuICAgIH1cbiAgICBhLmlkID0gTGcudGV4dCwgaS5zYW1wbGVEdXJhdGlvbiA9IDAsIGkuZHVyYXRpb24gPSBvLmR1cmF0aW9uID0gbjtcbiAgfVxuICByZXNldENvbnRpZ3VpdHkoKSB7XG4gICAgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbDtcbiAgfVxuICBzdGF0aWMgcHJvYmUoZSkge1xuICAgIHJldHVybiBCUyhlKTtcbiAgfVxuICBkZW11eChlLCB0KSB7XG4gICAgdGhpcy50aW1lT2Zmc2V0ID0gdDtcbiAgICBsZXQgciA9IGU7XG4gICAgY29uc3QgbiA9IHRoaXMudmlkZW9UcmFjaywgaSA9IHRoaXMudHh0VHJhY2s7XG4gICAgaWYgKHRoaXMuY29uZmlnLnByb2dyZXNzaXZlKSB7XG4gICAgICB0aGlzLnJlbWFpbmRlckRhdGEgJiYgKHIgPSBfcih0aGlzLnJlbWFpbmRlckRhdGEsIGUpKTtcbiAgICAgIGNvbnN0IGEgPSBWUyhyKTtcbiAgICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IGEucmVtYWluZGVyLCBuLnNhbXBsZXMgPSBhLnZhbGlkIHx8IG5ldyBVaW50OEFycmF5KCk7XG4gICAgfSBlbHNlXG4gICAgICBuLnNhbXBsZXMgPSByO1xuICAgIGNvbnN0IG8gPSB0aGlzLmV4dHJhY3RJRDNUcmFjayhuLCB0KTtcbiAgICByZXR1cm4gaS5zYW1wbGVzID0gcmgodCwgbiksIHtcbiAgICAgIHZpZGVvVHJhY2s6IG4sXG4gICAgICBhdWRpb1RyYWNrOiB0aGlzLmF1ZGlvVHJhY2ssXG4gICAgICBpZDNUcmFjazogbyxcbiAgICAgIHRleHRUcmFjazogdGhpcy50eHRUcmFja1xuICAgIH07XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgY29uc3QgZSA9IHRoaXMudGltZU9mZnNldCwgdCA9IHRoaXMudmlkZW9UcmFjaywgciA9IHRoaXMudHh0VHJhY2s7XG4gICAgdC5zYW1wbGVzID0gdGhpcy5yZW1haW5kZXJEYXRhIHx8IG5ldyBVaW50OEFycmF5KCksIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgY29uc3QgbiA9IHRoaXMuZXh0cmFjdElEM1RyYWNrKHQsIHRoaXMudGltZU9mZnNldCk7XG4gICAgcmV0dXJuIHIuc2FtcGxlcyA9IHJoKGUsIHQpLCB7XG4gICAgICB2aWRlb1RyYWNrOiB0LFxuICAgICAgYXVkaW9UcmFjazoganIoKSxcbiAgICAgIGlkM1RyYWNrOiBuLFxuICAgICAgdGV4dFRyYWNrOiBqcigpXG4gICAgfTtcbiAgfVxuICBleHRyYWN0SUQzVHJhY2soZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLmlkM1RyYWNrO1xuICAgIGlmIChlLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBuID0gR2UoZS5zYW1wbGVzLCBbXCJlbXNnXCJdKTtcbiAgICAgIG4gJiYgbi5mb3JFYWNoKChpKSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSBLUyhpKTtcbiAgICAgICAgaWYgKE5ULnRlc3Qoby5zY2hlbWVJZFVyaSkpIHtcbiAgICAgICAgICBjb25zdCBhID0gTmgobywgdCk7XG4gICAgICAgICAgbGV0IGwgPSBvLmV2ZW50RHVyYXRpb24gPT09IDQyOTQ5NjcyOTUgPyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkgOiBvLmV2ZW50RHVyYXRpb24gLyBvLnRpbWVTY2FsZTtcbiAgICAgICAgICBsIDw9IDFlLTMgJiYgKGwgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICAgIGNvbnN0IGMgPSBvLnBheWxvYWQ7XG4gICAgICAgICAgci5zYW1wbGVzLnB1c2goe1xuICAgICAgICAgICAgZGF0YTogYyxcbiAgICAgICAgICAgIGxlbjogYy5ieXRlTGVuZ3RoLFxuICAgICAgICAgICAgZHRzOiBhLFxuICAgICAgICAgICAgcHRzOiBhLFxuICAgICAgICAgICAgdHlwZTogYnIuZW1zZyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiBsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb25maWcuZW5hYmxlRW1zZ0tMVk1ldGFkYXRhICYmIG8uc2NoZW1lSWRVcmkuc3RhcnRzV2l0aChcInVybjptaXNiOktMVjpiaW46MTkxMC4xXCIpKSB7XG4gICAgICAgICAgY29uc3QgYSA9IE5oKG8sIHQpO1xuICAgICAgICAgIHIuc2FtcGxlcy5wdXNoKHtcbiAgICAgICAgICAgIGRhdGE6IG8ucGF5bG9hZCxcbiAgICAgICAgICAgIGxlbjogby5wYXlsb2FkLmJ5dGVMZW5ndGgsXG4gICAgICAgICAgICBkdHM6IGEsXG4gICAgICAgICAgICBwdHM6IGEsXG4gICAgICAgICAgICB0eXBlOiBici5taXNia2x2LFxuICAgICAgICAgICAgZHVyYXRpb246IE51bWJlci5QT1NJVElWRV9JTkZJTklUWVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgZGVtdXhTYW1wbGVBZXMoZSwgdCwgcikge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJUaGUgTVA0IGRlbXV4ZXIgZG9lcyBub3Qgc3VwcG9ydCBTQU1QTEUtQUVTIGRlY3J5cHRpb25cIikpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jb25maWcgPSBudWxsLCB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsLCB0aGlzLnZpZGVvVHJhY2sgPSB0aGlzLmF1ZGlvVHJhY2sgPSB0aGlzLmlkM1RyYWNrID0gdGhpcy50eHRUcmFjayA9IHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gTmgocywgZSkge1xuICByZXR1cm4gdWUocy5wcmVzZW50YXRpb25UaW1lKSA/IHMucHJlc2VudGF0aW9uVGltZSAvIHMudGltZVNjYWxlIDogZSArIHMucHJlc2VudGF0aW9uVGltZURlbHRhIC8gcy50aW1lU2NhbGU7XG59XG5jbGFzcyAkVCB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHIpIHtcbiAgICB0aGlzLmtleURhdGEgPSB2b2lkIDAsIHRoaXMuZGVjcnlwdGVyID0gdm9pZCAwLCB0aGlzLmtleURhdGEgPSByLCB0aGlzLmRlY3J5cHRlciA9IG5ldyB2dSh0LCB7XG4gICAgICByZW1vdmVQS0NTN1BhZGRpbmc6ICExXG4gICAgfSk7XG4gIH1cbiAgZGVjcnlwdEJ1ZmZlcihlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQoZSwgdGhpcy5rZXlEYXRhLmtleS5idWZmZXIsIHRoaXMua2V5RGF0YS5pdi5idWZmZXIsIE9zLmNiYyk7XG4gIH1cbiAgLy8gQUFDIC0gZW5jcnlwdCBhbGwgZnVsbCAxNiBieXRlcyBibG9ja3Mgc3RhcnRpbmcgZnJvbSBvZmZzZXQgMTZcbiAgZGVjcnlwdEFhY1NhbXBsZShlLCB0LCByKSB7XG4gICAgY29uc3QgbiA9IGVbdF0udW5pdDtcbiAgICBpZiAobi5sZW5ndGggPD0gMTYpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IG4uc3ViYXJyYXkoMTYsIG4ubGVuZ3RoIC0gbi5sZW5ndGggJSAxNiksIG8gPSBpLmJ1ZmZlci5zbGljZShpLmJ5dGVPZmZzZXQsIGkuYnl0ZU9mZnNldCArIGkubGVuZ3RoKTtcbiAgICB0aGlzLmRlY3J5cHRCdWZmZXIobykudGhlbigoYSkgPT4ge1xuICAgICAgY29uc3QgbCA9IG5ldyBVaW50OEFycmF5KGEpO1xuICAgICAgbi5zZXQobCwgMTYpLCB0aGlzLmRlY3J5cHRlci5pc1N5bmMoKSB8fCB0aGlzLmRlY3J5cHRBYWNTYW1wbGVzKGUsIHQgKyAxLCByKTtcbiAgICB9KS5jYXRjaChyKTtcbiAgfVxuICBkZWNyeXB0QWFjU2FtcGxlcyhlLCB0LCByKSB7XG4gICAgZm9yICg7IDsgdCsrKSB7XG4gICAgICBpZiAodCA+PSBlLmxlbmd0aCkge1xuICAgICAgICByKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghKGVbdF0udW5pdC5sZW5ndGggPCAzMikgJiYgKHRoaXMuZGVjcnlwdEFhY1NhbXBsZShlLCB0LCByKSwgIXRoaXMuZGVjcnlwdGVyLmlzU3luYygpKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICAvLyBBVkMgLSBlbmNyeXB0IG9uZSAxNiBieXRlcyBibG9jayBvdXQgb2YgdGVuLCBzdGFydGluZyBmcm9tIG9mZnNldCAzMlxuICBnZXRBdmNFbmNyeXB0ZWREYXRhKGUpIHtcbiAgICBjb25zdCB0ID0gTWF0aC5mbG9vcigoZS5sZW5ndGggLSA0OCkgLyAxNjApICogMTYgKyAxNiwgciA9IG5ldyBJbnQ4QXJyYXkodCk7XG4gICAgbGV0IG4gPSAwO1xuICAgIGZvciAobGV0IGkgPSAzMjsgaSA8IGUubGVuZ3RoIC0gMTY7IGkgKz0gMTYwLCBuICs9IDE2KVxuICAgICAgci5zZXQoZS5zdWJhcnJheShpLCBpICsgMTYpLCBuKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuICBnZXRBdmNEZWNyeXB0ZWRVbml0KGUsIHQpIHtcbiAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkodCk7XG4gICAgbGV0IG4gPSAwO1xuICAgIGZvciAobGV0IGkgPSAzMjsgaSA8IGUubGVuZ3RoIC0gMTY7IGkgKz0gMTYwLCBuICs9IDE2KVxuICAgICAgZS5zZXQoci5zdWJhcnJheShuLCBuICsgMTYpLCBpKTtcbiAgICByZXR1cm4gZTtcbiAgfVxuICBkZWNyeXB0QXZjU2FtcGxlKGUsIHQsIHIsIG4sIGkpIHtcbiAgICBjb25zdCBvID0gTWcoaS5kYXRhKSwgYSA9IHRoaXMuZ2V0QXZjRW5jcnlwdGVkRGF0YShvKTtcbiAgICB0aGlzLmRlY3J5cHRCdWZmZXIoYS5idWZmZXIpLnRoZW4oKGwpID0+IHtcbiAgICAgIGkuZGF0YSA9IHRoaXMuZ2V0QXZjRGVjcnlwdGVkVW5pdChvLCBsKSwgdGhpcy5kZWNyeXB0ZXIuaXNTeW5jKCkgfHwgdGhpcy5kZWNyeXB0QXZjU2FtcGxlcyhlLCB0LCByICsgMSwgbik7XG4gICAgfSkuY2F0Y2gobik7XG4gIH1cbiAgZGVjcnlwdEF2Y1NhbXBsZXMoZSwgdCwgciwgbikge1xuICAgIGlmIChlIGluc3RhbmNlb2YgVWludDhBcnJheSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBkZWNyeXB0IHNhbXBsZXMgb2YgdHlwZSBVaW50OEFycmF5XCIpO1xuICAgIGZvciAoOyA7IHQrKywgciA9IDApIHtcbiAgICAgIGlmICh0ID49IGUubGVuZ3RoKSB7XG4gICAgICAgIG4oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaSA9IGVbdF0udW5pdHM7XG4gICAgICBmb3IgKDsgIShyID49IGkubGVuZ3RoKTsgcisrKSB7XG4gICAgICAgIGNvbnN0IG8gPSBpW3JdO1xuICAgICAgICBpZiAoIShvLmRhdGEubGVuZ3RoIDw9IDQ4IHx8IG8udHlwZSAhPT0gMSAmJiBvLnR5cGUgIT09IDUpICYmICh0aGlzLmRlY3J5cHRBdmNTYW1wbGUoZSwgdCwgciwgbiwgbyksICF0aGlzLmRlY3J5cHRlci5pc1N5bmMoKSkpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY2xhc3MgeHAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLlZpZGVvU2FtcGxlID0gbnVsbDtcbiAgfVxuICBjcmVhdGVWaWRlb1NhbXBsZShlLCB0LCByKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogZSxcbiAgICAgIGZyYW1lOiAhMSxcbiAgICAgIHB0czogdCxcbiAgICAgIGR0czogcixcbiAgICAgIHVuaXRzOiBbXSxcbiAgICAgIGxlbmd0aDogMFxuICAgIH07XG4gIH1cbiAgZ2V0TGFzdE5hbFVuaXQoZSkge1xuICAgIHZhciB0O1xuICAgIGxldCByID0gdGhpcy5WaWRlb1NhbXBsZSwgbjtcbiAgICBpZiAoKCFyIHx8IHIudW5pdHMubGVuZ3RoID09PSAwKSAmJiAociA9IGVbZS5sZW5ndGggLSAxXSksICh0ID0gcikgIT0gbnVsbCAmJiB0LnVuaXRzKSB7XG4gICAgICBjb25zdCBpID0gci51bml0cztcbiAgICAgIG4gPSBpW2kubGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIHB1c2hBY2Nlc3NVbml0KGUsIHQpIHtcbiAgICBpZiAoZS51bml0cy5sZW5ndGggJiYgZS5mcmFtZSkge1xuICAgICAgaWYgKGUucHRzID09PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgciA9IHQuc2FtcGxlcywgbiA9IHIubGVuZ3RoO1xuICAgICAgICBpZiAobikge1xuICAgICAgICAgIGNvbnN0IGkgPSByW24gLSAxXTtcbiAgICAgICAgICBlLnB0cyA9IGkucHRzLCBlLmR0cyA9IGkuZHRzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHQuZHJvcHBlZCsrO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdC5zYW1wbGVzLnB1c2goZSk7XG4gICAgfVxuICB9XG4gIHBhcnNlTkFMdShlLCB0LCByKSB7XG4gICAgY29uc3QgbiA9IHQuYnl0ZUxlbmd0aDtcbiAgICBsZXQgaSA9IGUubmFsdVN0YXRlIHx8IDA7XG4gICAgY29uc3QgbyA9IGksIGEgPSBbXTtcbiAgICBsZXQgbCA9IDAsIGMsIHUsIGQsIGggPSAtMSwgZiA9IDA7XG4gICAgZm9yIChpID09PSAtMSAmJiAoaCA9IDAsIGYgPSB0aGlzLmdldE5BTHVUeXBlKHQsIDApLCBpID0gMCwgbCA9IDEpOyBsIDwgbjsgKSB7XG4gICAgICBpZiAoYyA9IHRbbCsrXSwgIWkpIHtcbiAgICAgICAgaSA9IGMgPyAwIDogMTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICBpID0gYyA/IDAgOiAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghYylcbiAgICAgICAgaSA9IDM7XG4gICAgICBlbHNlIGlmIChjID09PSAxKSB7XG4gICAgICAgIGlmICh1ID0gbCAtIGkgLSAxLCBoID49IDApIHtcbiAgICAgICAgICBjb25zdCBwID0ge1xuICAgICAgICAgICAgZGF0YTogdC5zdWJhcnJheShoLCB1KSxcbiAgICAgICAgICAgIHR5cGU6IGZcbiAgICAgICAgICB9O1xuICAgICAgICAgIGEucHVzaChwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBwID0gdGhpcy5nZXRMYXN0TmFsVW5pdChlLnNhbXBsZXMpO1xuICAgICAgICAgIHAgJiYgKG8gJiYgbCA8PSA0IC0gbyAmJiBwLnN0YXRlICYmIChwLmRhdGEgPSBwLmRhdGEuc3ViYXJyYXkoMCwgcC5kYXRhLmJ5dGVMZW5ndGggLSBvKSksIHUgPiAwICYmIChwLmRhdGEgPSBfcihwLmRhdGEsIHQuc3ViYXJyYXkoMCwgdSkpLCBwLnN0YXRlID0gMCkpO1xuICAgICAgICB9XG4gICAgICAgIGwgPCBuID8gKGQgPSB0aGlzLmdldE5BTHVUeXBlKHQsIGwpLCBoID0gbCwgZiA9IGQsIGkgPSAwKSA6IGkgPSAtMTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBpID0gMDtcbiAgICB9XG4gICAgaWYgKGggPj0gMCAmJiBpID49IDApIHtcbiAgICAgIGNvbnN0IHAgPSB7XG4gICAgICAgIGRhdGE6IHQuc3ViYXJyYXkoaCwgbiksXG4gICAgICAgIHR5cGU6IGYsXG4gICAgICAgIHN0YXRlOiBpXG4gICAgICB9O1xuICAgICAgYS5wdXNoKHApO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IHAgPSB0aGlzLmdldExhc3ROYWxVbml0KGUuc2FtcGxlcyk7XG4gICAgICBwICYmIChwLmRhdGEgPSBfcihwLmRhdGEsIHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIGUubmFsdVN0YXRlID0gaSwgYTtcbiAgfVxufVxuY2xhc3MgWm4ge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5kYXRhID0gdm9pZCAwLCB0aGlzLmJ5dGVzQXZhaWxhYmxlID0gdm9pZCAwLCB0aGlzLndvcmQgPSB2b2lkIDAsIHRoaXMuYml0c0F2YWlsYWJsZSA9IHZvaWQgMCwgdGhpcy5kYXRhID0gZSwgdGhpcy5ieXRlc0F2YWlsYWJsZSA9IGUuYnl0ZUxlbmd0aCwgdGhpcy53b3JkID0gMCwgdGhpcy5iaXRzQXZhaWxhYmxlID0gMDtcbiAgfVxuICAvLyAoKTp2b2lkXG4gIGxvYWRXb3JkKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmRhdGEsIHQgPSB0aGlzLmJ5dGVzQXZhaWxhYmxlLCByID0gZS5ieXRlTGVuZ3RoIC0gdCwgbiA9IG5ldyBVaW50OEFycmF5KDQpLCBpID0gTWF0aC5taW4oNCwgdCk7XG4gICAgaWYgKGkgPT09IDApXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBieXRlcyBhdmFpbGFibGVcIik7XG4gICAgbi5zZXQoZS5zdWJhcnJheShyLCByICsgaSkpLCB0aGlzLndvcmQgPSBuZXcgRGF0YVZpZXcobi5idWZmZXIpLmdldFVpbnQzMigwKSwgdGhpcy5iaXRzQXZhaWxhYmxlID0gaSAqIDgsIHRoaXMuYnl0ZXNBdmFpbGFibGUgLT0gaTtcbiAgfVxuICAvLyAoY291bnQ6aW50KTp2b2lkXG4gIHNraXBCaXRzKGUpIHtcbiAgICBsZXQgdDtcbiAgICBlID0gTWF0aC5taW4oZSwgdGhpcy5ieXRlc0F2YWlsYWJsZSAqIDggKyB0aGlzLmJpdHNBdmFpbGFibGUpLCB0aGlzLmJpdHNBdmFpbGFibGUgPiBlID8gKHRoaXMud29yZCA8PD0gZSwgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGUpIDogKGUgLT0gdGhpcy5iaXRzQXZhaWxhYmxlLCB0ID0gZSA+PiAzLCBlIC09IHQgPDwgMywgdGhpcy5ieXRlc0F2YWlsYWJsZSAtPSB0LCB0aGlzLmxvYWRXb3JkKCksIHRoaXMud29yZCA8PD0gZSwgdGhpcy5iaXRzQXZhaWxhYmxlIC09IGUpO1xuICB9XG4gIC8vIChzaXplOmludCk6dWludFxuICByZWFkQml0cyhlKSB7XG4gICAgbGV0IHQgPSBNYXRoLm1pbih0aGlzLmJpdHNBdmFpbGFibGUsIGUpO1xuICAgIGNvbnN0IHIgPSB0aGlzLndvcmQgPj4+IDMyIC0gdDtcbiAgICBpZiAoZSA+IDMyICYmIHJ0LmVycm9yKFwiQ2Fubm90IHJlYWQgbW9yZSB0aGFuIDMyIGJpdHMgYXQgYSB0aW1lXCIpLCB0aGlzLmJpdHNBdmFpbGFibGUgLT0gdCwgdGhpcy5iaXRzQXZhaWxhYmxlID4gMClcbiAgICAgIHRoaXMud29yZCA8PD0gdDtcbiAgICBlbHNlIGlmICh0aGlzLmJ5dGVzQXZhaWxhYmxlID4gMClcbiAgICAgIHRoaXMubG9hZFdvcmQoKTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBiaXRzIGF2YWlsYWJsZVwiKTtcbiAgICByZXR1cm4gdCA9IGUgLSB0LCB0ID4gMCAmJiB0aGlzLmJpdHNBdmFpbGFibGUgPyByIDw8IHQgfCB0aGlzLnJlYWRCaXRzKHQpIDogcjtcbiAgfVxuICAvLyAoKTp1aW50XG4gIHNraXBMWigpIHtcbiAgICBsZXQgZTtcbiAgICBmb3IgKGUgPSAwOyBlIDwgdGhpcy5iaXRzQXZhaWxhYmxlOyArK2UpXG4gICAgICBpZiAoKHRoaXMud29yZCAmIDIxNDc0ODM2NDggPj4+IGUpICE9PSAwKVxuICAgICAgICByZXR1cm4gdGhpcy53b3JkIDw8PSBlLCB0aGlzLmJpdHNBdmFpbGFibGUgLT0gZSwgZTtcbiAgICByZXR1cm4gdGhpcy5sb2FkV29yZCgpLCBlICsgdGhpcy5za2lwTFooKTtcbiAgfVxuICAvLyAoKTp2b2lkXG4gIHNraXBVRUcoKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gIH1cbiAgLy8gKCk6dm9pZFxuICBza2lwRUcoKSB7XG4gICAgdGhpcy5za2lwQml0cygxICsgdGhpcy5za2lwTFooKSk7XG4gIH1cbiAgLy8gKCk6dWludFxuICByZWFkVUVHKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnNraXBMWigpO1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKGUgKyAxKSAtIDE7XG4gIH1cbiAgLy8gKCk6aW50XG4gIHJlYWRFRygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5yZWFkVUVHKCk7XG4gICAgcmV0dXJuIDEgJiBlID8gMSArIGUgPj4+IDEgOiAtMSAqIChlID4+PiAxKTtcbiAgfVxuICAvLyBTb21lIGNvbnZlbmllbmNlIGZ1bmN0aW9uc1xuICAvLyA6Qm9vbGVhblxuICByZWFkQm9vbGVhbigpIHtcbiAgICByZXR1cm4gdGhpcy5yZWFkQml0cygxKSA9PT0gMTtcbiAgfVxuICAvLyAoKTppbnRcbiAgcmVhZFVCeXRlKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDgpO1xuICB9XG4gIC8vICgpOmludFxuICByZWFkVVNob3J0KCkge1xuICAgIHJldHVybiB0aGlzLnJlYWRCaXRzKDE2KTtcbiAgfVxuICAvLyAoKTppbnRcbiAgcmVhZFVJbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhZEJpdHMoMzIpO1xuICB9XG59XG5jbGFzcyBHVCBleHRlbmRzIHhwIHtcbiAgcGFyc2VQRVMoZSwgdCwgciwgbikge1xuICAgIGNvbnN0IGkgPSB0aGlzLnBhcnNlTkFMdShlLCByLmRhdGEsIG4pO1xuICAgIGxldCBvID0gdGhpcy5WaWRlb1NhbXBsZSwgYSwgbCA9ICExO1xuICAgIHIuZGF0YSA9IG51bGwsIG8gJiYgaS5sZW5ndGggJiYgIWUuYXVkRm91bmQgJiYgKHRoaXMucHVzaEFjY2Vzc1VuaXQobywgZSksIG8gPSB0aGlzLlZpZGVvU2FtcGxlID0gdGhpcy5jcmVhdGVWaWRlb1NhbXBsZSghMSwgci5wdHMsIHIuZHRzKSksIGkuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgdmFyIHUsIGQ7XG4gICAgICBzd2l0Y2ggKGMudHlwZSkge1xuICAgICAgICAvLyBORFJcbiAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgbGV0IHkgPSAhMTtcbiAgICAgICAgICBhID0gITA7XG4gICAgICAgICAgY29uc3QgRSA9IGMuZGF0YTtcbiAgICAgICAgICBpZiAobCAmJiBFLmxlbmd0aCA+IDQpIHtcbiAgICAgICAgICAgIGNvbnN0IGIgPSB0aGlzLnJlYWRTbGljZVR5cGUoRSk7XG4gICAgICAgICAgICAoYiA9PT0gMiB8fCBiID09PSA0IHx8IGIgPT09IDcgfHwgYiA9PT0gOSkgJiYgKHkgPSAhMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh5KSB7XG4gICAgICAgICAgICB2YXIgaDtcbiAgICAgICAgICAgIChoID0gbykgIT0gbnVsbCAmJiBoLmZyYW1lICYmICFvLmtleSAmJiAodGhpcy5wdXNoQWNjZXNzVW5pdChvLCBlKSwgbyA9IHRoaXMuVmlkZW9TYW1wbGUgPSBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbyB8fCAobyA9IHRoaXMuVmlkZW9TYW1wbGUgPSB0aGlzLmNyZWF0ZVZpZGVvU2FtcGxlKCEwLCByLnB0cywgci5kdHMpKSwgby5mcmFtZSA9ICEwLCBvLmtleSA9IHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGEgPSAhMCwgKHUgPSBvKSAhPSBudWxsICYmIHUuZnJhbWUgJiYgIW8ua2V5ICYmICh0aGlzLnB1c2hBY2Nlc3NVbml0KG8sIGUpLCBvID0gdGhpcy5WaWRlb1NhbXBsZSA9IG51bGwpLCBvIHx8IChvID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUoITAsIHIucHRzLCByLmR0cykpLCBvLmtleSA9ICEwLCBvLmZyYW1lID0gITA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFNFSVxuICAgICAgICBjYXNlIDY6IHtcbiAgICAgICAgICBhID0gITAsIGd1KGMuZGF0YSwgMSwgci5wdHMsIHQuc2FtcGxlcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSA3OiB7XG4gICAgICAgICAgdmFyIGYsIHA7XG4gICAgICAgICAgYSA9ICEwLCBsID0gITA7XG4gICAgICAgICAgY29uc3QgeSA9IGMuZGF0YSwgRSA9IHRoaXMucmVhZFNQUyh5KTtcbiAgICAgICAgICBpZiAoIWUuc3BzIHx8IGUud2lkdGggIT09IEUud2lkdGggfHwgZS5oZWlnaHQgIT09IEUuaGVpZ2h0IHx8ICgoZiA9IGUucGl4ZWxSYXRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IGZbMF0pICE9PSBFLnBpeGVsUmF0aW9bMF0gfHwgKChwID0gZS5waXhlbFJhdGlvKSA9PSBudWxsID8gdm9pZCAwIDogcFsxXSkgIT09IEUucGl4ZWxSYXRpb1sxXSkge1xuICAgICAgICAgICAgZS53aWR0aCA9IEUud2lkdGgsIGUuaGVpZ2h0ID0gRS5oZWlnaHQsIGUucGl4ZWxSYXRpbyA9IEUucGl4ZWxSYXRpbywgZS5zcHMgPSBbeV07XG4gICAgICAgICAgICBjb25zdCBiID0geS5zdWJhcnJheSgxLCA0KTtcbiAgICAgICAgICAgIGxldCBSID0gXCJhdmMxLlwiO1xuICAgICAgICAgICAgZm9yIChsZXQgQSA9IDA7IEEgPCAzOyBBKyspIHtcbiAgICAgICAgICAgICAgbGV0IEYgPSBiW0FdLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgICAgRi5sZW5ndGggPCAyICYmIChGID0gXCIwXCIgKyBGKSwgUiArPSBGO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZS5jb2RlYyA9IFI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBQU1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgYSA9ICEwLCBlLnBwcyA9IFtjLmRhdGFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBBVURcbiAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIGEgPSAhMCwgZS5hdWRGb3VuZCA9ICEwLCAoZCA9IG8pICE9IG51bGwgJiYgZC5mcmFtZSAmJiAodGhpcy5wdXNoQWNjZXNzVW5pdChvLCBlKSwgbyA9IG51bGwpLCBvIHx8IChvID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUoITEsIHIucHRzLCByLmR0cykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBGaWxsZXIgRGF0YVxuICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIGEgPSAhMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBhID0gITE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvICYmIGEgJiYgby51bml0cy5wdXNoKGMpO1xuICAgIH0pLCBuICYmIG8gJiYgKHRoaXMucHVzaEFjY2Vzc1VuaXQobywgZSksIHRoaXMuVmlkZW9TYW1wbGUgPSBudWxsKTtcbiAgfVxuICBnZXROQUx1VHlwZShlLCB0KSB7XG4gICAgcmV0dXJuIGVbdF0gJiAzMTtcbiAgfVxuICByZWFkU2xpY2VUeXBlKGUpIHtcbiAgICBjb25zdCB0ID0gbmV3IFpuKGUpO1xuICAgIHJldHVybiB0LnJlYWRVQnl0ZSgpLCB0LnJlYWRVRUcoKSwgdC5yZWFkVUVHKCk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBzY2FsaW5nIGxpc3QgaXMgb3B0aW9uYWxseSB0cmFuc21pdHRlZCBhcyBwYXJ0IG9mIGEgc2VxdWVuY2UgcGFyYW1ldGVyXG4gICAqIHNldCBhbmQgaXMgbm90IHJlbGV2YW50IHRvIHRyYW5zbXV4aW5nLlxuICAgKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbnRyaWVzIGluIHRoaXMgc2NhbGluZyBsaXN0XG4gICAqIEBzZWUgUmVjb21tZW5kYXRpb24gSVRVLVQgSC4yNjQsIFNlY3Rpb24gNy4zLjIuMS4xLjFcbiAgICovXG4gIHNraXBTY2FsaW5nTGlzdChlLCB0KSB7XG4gICAgbGV0IHIgPSA4LCBuID0gOCwgaTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IGU7IG8rKylcbiAgICAgIG4gIT09IDAgJiYgKGkgPSB0LnJlYWRFRygpLCBuID0gKHIgKyBpICsgMjU2KSAlIDI1NiksIHIgPSBuID09PSAwID8gciA6IG47XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0IGFuZCByZXR1cm4gc29tZSBpbnRlcmVzdGluZyB2aWRlb1xuICAgKiBwcm9wZXJ0aWVzLiBBIHNlcXVlbmNlIHBhcmFtZXRlciBzZXQgaXMgdGhlIEgyNjQgbWV0YWRhdGEgdGhhdFxuICAgKiBkZXNjcmliZXMgdGhlIHByb3BlcnRpZXMgb2YgdXBjb21pbmcgdmlkZW8gZnJhbWVzLlxuICAgKiBAcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBjb25maWd1cmF0aW9uIHBhcnNlZCBmcm9tIHRoZVxuICAgKiBzZXF1ZW5jZSBwYXJhbWV0ZXIgc2V0LCBpbmNsdWRpbmcgdGhlIGRpbWVuc2lvbnMgb2YgdGhlXG4gICAqIGFzc29jaWF0ZWQgdmlkZW8gZnJhbWVzLlxuICAgKi9cbiAgcmVhZFNQUyhlKSB7XG4gICAgY29uc3QgdCA9IG5ldyBabihlKTtcbiAgICBsZXQgciA9IDAsIG4gPSAwLCBpID0gMCwgbyA9IDAsIGEsIGwsIGM7XG4gICAgY29uc3QgdSA9IHQucmVhZFVCeXRlLmJpbmQodCksIGQgPSB0LnJlYWRCaXRzLmJpbmQodCksIGggPSB0LnJlYWRVRUcuYmluZCh0KSwgZiA9IHQucmVhZEJvb2xlYW4uYmluZCh0KSwgcCA9IHQuc2tpcEJpdHMuYmluZCh0KSwgeSA9IHQuc2tpcEVHLmJpbmQodCksIEUgPSB0LnNraXBVRUcuYmluZCh0KSwgYiA9IHRoaXMuc2tpcFNjYWxpbmdMaXN0LmJpbmQodGhpcyk7XG4gICAgdSgpO1xuICAgIGNvbnN0IFIgPSB1KCk7XG4gICAgaWYgKGQoNSksIHAoMyksIHUoKSwgRSgpLCBSID09PSAxMDAgfHwgUiA9PT0gMTEwIHx8IFIgPT09IDEyMiB8fCBSID09PSAyNDQgfHwgUiA9PT0gNDQgfHwgUiA9PT0gODMgfHwgUiA9PT0gODYgfHwgUiA9PT0gMTE4IHx8IFIgPT09IDEyOCkge1xuICAgICAgY29uc3QgaiA9IGgoKTtcbiAgICAgIGlmIChqID09PSAzICYmIHAoMSksIEUoKSwgRSgpLCBwKDEpLCBmKCkpXG4gICAgICAgIGZvciAobCA9IGogIT09IDMgPyA4IDogMTIsIGMgPSAwOyBjIDwgbDsgYysrKVxuICAgICAgICAgIGYoKSAmJiAoYyA8IDYgPyBiKDE2LCB0KSA6IGIoNjQsIHQpKTtcbiAgICB9XG4gICAgRSgpO1xuICAgIGNvbnN0IEEgPSBoKCk7XG4gICAgaWYgKEEgPT09IDApXG4gICAgICBoKCk7XG4gICAgZWxzZSBpZiAoQSA9PT0gMSlcbiAgICAgIGZvciAocCgxKSwgeSgpLCB5KCksIGEgPSBoKCksIGMgPSAwOyBjIDwgYTsgYysrKVxuICAgICAgICB5KCk7XG4gICAgRSgpLCBwKDEpO1xuICAgIGNvbnN0IEYgPSBoKCksIE0gPSBoKCksIEggPSBkKDEpO1xuICAgIEggPT09IDAgJiYgcCgxKSwgcCgxKSwgZigpICYmIChyID0gaCgpLCBuID0gaCgpLCBpID0gaCgpLCBvID0gaCgpKTtcbiAgICBsZXQgSyA9IFsxLCAxXTtcbiAgICBpZiAoZigpICYmIGYoKSlcbiAgICAgIHN3aXRjaCAodSgpKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBLID0gWzEsIDFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgSyA9IFsxMiwgMTFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgSyA9IFsxMCwgMTFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgSyA9IFsxNiwgMTFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgSyA9IFs0MCwgMzNdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgSyA9IFsyNCwgMTFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgSyA9IFsyMCwgMTFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgSyA9IFszMiwgMTFdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgSyA9IFs4MCwgMzNdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIEsgPSBbMTgsIDExXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICBLID0gWzE1LCAxMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgSyA9IFs2NCwgMzNdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIEsgPSBbMTYwLCA5OV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgSyA9IFs0LCAzXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBLID0gWzMsIDJdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgIEsgPSBbMiwgMV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjU1OiB7XG4gICAgICAgICAgSyA9IFt1KCkgPDwgOCB8IHUoKSwgdSgpIDw8IDggfCB1KCldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiBNYXRoLmNlaWwoKEYgKyAxKSAqIDE2IC0gciAqIDIgLSBuICogMiksXG4gICAgICBoZWlnaHQ6ICgyIC0gSCkgKiAoTSArIDEpICogMTYgLSAoSCA/IDIgOiA0KSAqIChpICsgbyksXG4gICAgICBwaXhlbFJhdGlvOiBLXG4gICAgfTtcbiAgfVxufVxuY2xhc3MgVlQgZXh0ZW5kcyB4cCB7XG4gIGNvbnN0cnVjdG9yKC4uLmUpIHtcbiAgICBzdXBlciguLi5lKSwgdGhpcy5pbml0VlBTID0gbnVsbDtcbiAgfVxuICBwYXJzZVBFUyhlLCB0LCByLCBuKSB7XG4gICAgY29uc3QgaSA9IHRoaXMucGFyc2VOQUx1KGUsIHIuZGF0YSwgbik7XG4gICAgbGV0IG8gPSB0aGlzLlZpZGVvU2FtcGxlLCBhLCBsID0gITE7XG4gICAgci5kYXRhID0gbnVsbCwgbyAmJiBpLmxlbmd0aCAmJiAhZS5hdWRGb3VuZCAmJiAodGhpcy5wdXNoQWNjZXNzVW5pdChvLCBlKSwgbyA9IHRoaXMuVmlkZW9TYW1wbGUgPSB0aGlzLmNyZWF0ZVZpZGVvU2FtcGxlKCExLCByLnB0cywgci5kdHMpKSwgaS5mb3JFYWNoKChjKSA9PiB7XG4gICAgICB2YXIgdSwgZDtcbiAgICAgIHN3aXRjaCAoYy50eXBlKSB7XG4gICAgICAgIC8vIE5PTi1JRFIsIE5PTiBSQU5ET00gQUNDRVNTIFNMSUNFXG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICBjYXNlIDI6XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICBjYXNlIDU6XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgY2FzZSA3OlxuICAgICAgICBjYXNlIDg6XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBvIHx8IChvID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUoITEsIHIucHRzLCByLmR0cykpLCBvLmZyYW1lID0gITAsIGEgPSAhMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gQ1JBLCBCTEEgKHJhbmRvbSBhY2Nlc3MgcGljdHVyZSlcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgY2FzZSAxODpcbiAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICBpZiAoYSA9ICEwLCBsKSB7XG4gICAgICAgICAgICB2YXIgaDtcbiAgICAgICAgICAgIChoID0gbykgIT0gbnVsbCAmJiBoLmZyYW1lICYmICFvLmtleSAmJiAodGhpcy5wdXNoQWNjZXNzVW5pdChvLCBlKSwgbyA9IHRoaXMuVmlkZW9TYW1wbGUgPSBudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbyB8fCAobyA9IHRoaXMuVmlkZW9TYW1wbGUgPSB0aGlzLmNyZWF0ZVZpZGVvU2FtcGxlKCEwLCByLnB0cywgci5kdHMpKSwgby5rZXkgPSAhMCwgby5mcmFtZSA9ICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBJRFJcbiAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICBhID0gITAsICh1ID0gbykgIT0gbnVsbCAmJiB1LmZyYW1lICYmICFvLmtleSAmJiAodGhpcy5wdXNoQWNjZXNzVW5pdChvLCBlKSwgbyA9IHRoaXMuVmlkZW9TYW1wbGUgPSBudWxsKSwgbyB8fCAobyA9IHRoaXMuVmlkZW9TYW1wbGUgPSB0aGlzLmNyZWF0ZVZpZGVvU2FtcGxlKCEwLCByLnB0cywgci5kdHMpKSwgby5rZXkgPSAhMCwgby5mcmFtZSA9ICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBTRUlcbiAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICBhID0gITAsIGd1KFxuICAgICAgICAgICAgYy5kYXRhLFxuICAgICAgICAgICAgMixcbiAgICAgICAgICAgIC8vIE5BTHUgaGVhZGVyIHNpemVcbiAgICAgICAgICAgIHIucHRzLFxuICAgICAgICAgICAgdC5zYW1wbGVzXG4gICAgICAgICAgKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVlBTXG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgYSA9ICEwLCBlLnZwcyB8fCAodHlwZW9mIGUucGFyYW1zICE9IFwib2JqZWN0XCIgJiYgKGUucGFyYW1zID0ge30pLCBlLnBhcmFtcyA9IG50KGUucGFyYW1zLCB0aGlzLnJlYWRWUFMoYy5kYXRhKSksIHRoaXMuaW5pdFZQUyA9IGMuZGF0YSksIGUudnBzID0gW2MuZGF0YV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFNQU1xuICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgIGlmIChhID0gITAsIGwgPSAhMCwgZS52cHMgIT09IHZvaWQgMCAmJiBlLnZwc1swXSAhPT0gdGhpcy5pbml0VlBTICYmIGUuc3BzICE9PSB2b2lkIDAgJiYgIXRoaXMubWF0Y2hTUFMoZS5zcHNbMF0sIGMuZGF0YSkgJiYgKHRoaXMuaW5pdFZQUyA9IGUudnBzWzBdLCBlLnNwcyA9IGUucHBzID0gdm9pZCAwKSwgIWUuc3BzKSB7XG4gICAgICAgICAgICBjb25zdCBmID0gdGhpcy5yZWFkU1BTKGMuZGF0YSk7XG4gICAgICAgICAgICBlLndpZHRoID0gZi53aWR0aCwgZS5oZWlnaHQgPSBmLmhlaWdodCwgZS5waXhlbFJhdGlvID0gZi5waXhlbFJhdGlvLCBlLmNvZGVjID0gZi5jb2RlY1N0cmluZywgZS5zcHMgPSBbXSwgdHlwZW9mIGUucGFyYW1zICE9IFwib2JqZWN0XCIgJiYgKGUucGFyYW1zID0ge30pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwIGluIGYucGFyYW1zKVxuICAgICAgICAgICAgICBlLnBhcmFtc1twXSA9IGYucGFyYW1zW3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnB1c2hQYXJhbWV0ZXJTZXQoZS5zcHMsIGMuZGF0YSwgZS52cHMpLCBvIHx8IChvID0gdGhpcy5WaWRlb1NhbXBsZSA9IHRoaXMuY3JlYXRlVmlkZW9TYW1wbGUoITAsIHIucHRzLCByLmR0cykpLCBvLmtleSA9ICEwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBQUFNcbiAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICBpZiAoYSA9ICEwLCB0eXBlb2YgZS5wYXJhbXMgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgaWYgKCFlLnBwcykge1xuICAgICAgICAgICAgICBlLnBwcyA9IFtdO1xuICAgICAgICAgICAgICBjb25zdCBmID0gdGhpcy5yZWFkUFBTKGMuZGF0YSk7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcCBpbiBmKVxuICAgICAgICAgICAgICAgIGUucGFyYW1zW3BdID0gZltwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHVzaFBhcmFtZXRlclNldChlLnBwcywgYy5kYXRhLCBlLnZwcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBBQ0NFU1MgVU5JVCBERUxJTUlURVJcbiAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICBhID0gITAsIGUuYXVkRm91bmQgPSAhMCwgKGQgPSBvKSAhPSBudWxsICYmIGQuZnJhbWUgJiYgKHRoaXMucHVzaEFjY2Vzc1VuaXQobywgZSksIG8gPSBudWxsKSwgbyB8fCAobyA9IHRoaXMuVmlkZW9TYW1wbGUgPSB0aGlzLmNyZWF0ZVZpZGVvU2FtcGxlKCExLCByLnB0cywgci5kdHMpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBhID0gITE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBvICYmIGEgJiYgby51bml0cy5wdXNoKGMpO1xuICAgIH0pLCBuICYmIG8gJiYgKHRoaXMucHVzaEFjY2Vzc1VuaXQobywgZSksIHRoaXMuVmlkZW9TYW1wbGUgPSBudWxsKTtcbiAgfVxuICBwdXNoUGFyYW1ldGVyU2V0KGUsIHQsIHIpIHtcbiAgICAociAmJiByWzBdID09PSB0aGlzLmluaXRWUFMgfHwgIXIgJiYgIWUubGVuZ3RoKSAmJiBlLnB1c2godCk7XG4gIH1cbiAgZ2V0TkFMdVR5cGUoZSwgdCkge1xuICAgIHJldHVybiAoZVt0XSAmIDEyNikgPj4+IDE7XG4gIH1cbiAgZWJzcDJyYnNwKGUpIHtcbiAgICBjb25zdCB0ID0gbmV3IFVpbnQ4QXJyYXkoZS5ieXRlTGVuZ3RoKTtcbiAgICBsZXQgciA9IDA7XG4gICAgZm9yIChsZXQgbiA9IDA7IG4gPCBlLmJ5dGVMZW5ndGg7IG4rKylcbiAgICAgIG4gPj0gMiAmJiBlW25dID09PSAzICYmIGVbbiAtIDFdID09PSAwICYmIGVbbiAtIDJdID09PSAwIHx8ICh0W3JdID0gZVtuXSwgcisrKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodC5idWZmZXIsIDAsIHIpO1xuICB9XG4gIHB1c2hBY2Nlc3NVbml0KGUsIHQpIHtcbiAgICBzdXBlci5wdXNoQWNjZXNzVW5pdChlLCB0KSwgdGhpcy5pbml0VlBTICYmICh0aGlzLmluaXRWUFMgPSBudWxsKTtcbiAgfVxuICByZWFkVlBTKGUpIHtcbiAgICBjb25zdCB0ID0gbmV3IFpuKGUpO1xuICAgIHQucmVhZFVCeXRlKCksIHQucmVhZFVCeXRlKCksIHQucmVhZEJpdHMoNCksIHQuc2tpcEJpdHMoMiksIHQucmVhZEJpdHMoNik7XG4gICAgY29uc3QgciA9IHQucmVhZEJpdHMoMyksIG4gPSB0LnJlYWRCb29sZWFuKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG51bVRlbXBvcmFsTGF5ZXJzOiByICsgMSxcbiAgICAgIHRlbXBvcmFsSWROZXN0ZWQ6IG5cbiAgICB9O1xuICB9XG4gIHJlYWRTUFMoZSkge1xuICAgIGNvbnN0IHQgPSBuZXcgWm4odGhpcy5lYnNwMnJic3AoZSkpO1xuICAgIHQucmVhZFVCeXRlKCksIHQucmVhZFVCeXRlKCksIHQucmVhZEJpdHMoNCk7XG4gICAgY29uc3QgciA9IHQucmVhZEJpdHMoMyk7XG4gICAgdC5yZWFkQm9vbGVhbigpO1xuICAgIGNvbnN0IG4gPSB0LnJlYWRCaXRzKDIpLCBpID0gdC5yZWFkQm9vbGVhbigpLCBvID0gdC5yZWFkQml0cyg1KSwgYSA9IHQucmVhZFVCeXRlKCksIGwgPSB0LnJlYWRVQnl0ZSgpLCBjID0gdC5yZWFkVUJ5dGUoKSwgdSA9IHQucmVhZFVCeXRlKCksIGQgPSB0LnJlYWRVQnl0ZSgpLCBoID0gdC5yZWFkVUJ5dGUoKSwgZiA9IHQucmVhZFVCeXRlKCksIHAgPSB0LnJlYWRVQnl0ZSgpLCB5ID0gdC5yZWFkVUJ5dGUoKSwgRSA9IHQucmVhZFVCeXRlKCksIGIgPSB0LnJlYWRVQnl0ZSgpLCBSID0gW10sIEEgPSBbXTtcbiAgICBmb3IgKGxldCB5ZSA9IDA7IHllIDwgcjsgeWUrKylcbiAgICAgIFIucHVzaCh0LnJlYWRCb29sZWFuKCkpLCBBLnB1c2godC5yZWFkQm9vbGVhbigpKTtcbiAgICBpZiAociA+IDApXG4gICAgICBmb3IgKGxldCB5ZSA9IHI7IHllIDwgODsgeWUrKylcbiAgICAgICAgdC5yZWFkQml0cygyKTtcbiAgICBmb3IgKGxldCB5ZSA9IDA7IHllIDwgcjsgeWUrKylcbiAgICAgIFJbeWVdICYmICh0LnJlYWRVQnl0ZSgpLCB0LnJlYWRVQnl0ZSgpLCB0LnJlYWRVQnl0ZSgpLCB0LnJlYWRVQnl0ZSgpLCB0LnJlYWRVQnl0ZSgpLCB0LnJlYWRVQnl0ZSgpLCB0LnJlYWRVQnl0ZSgpLCB0LnJlYWRVQnl0ZSgpLCB0LnJlYWRVQnl0ZSgpLCB0LnJlYWRVQnl0ZSgpLCB0LnJlYWRVQnl0ZSgpKSwgQVt5ZV0gJiYgdC5yZWFkVUJ5dGUoKTtcbiAgICB0LnJlYWRVRUcoKTtcbiAgICBjb25zdCBGID0gdC5yZWFkVUVHKCk7XG4gICAgRiA9PSAzICYmIHQuc2tpcEJpdHMoMSk7XG4gICAgY29uc3QgTSA9IHQucmVhZFVFRygpLCBIID0gdC5yZWFkVUVHKCksIEsgPSB0LnJlYWRCb29sZWFuKCk7XG4gICAgbGV0IGogPSAwLCBDID0gMCwgayA9IDAsICQgPSAwO1xuICAgIEsgJiYgKGogKz0gdC5yZWFkVUVHKCksIEMgKz0gdC5yZWFkVUVHKCksIGsgKz0gdC5yZWFkVUVHKCksICQgKz0gdC5yZWFkVUVHKCkpO1xuICAgIGNvbnN0IFcgPSB0LnJlYWRVRUcoKSwgXyA9IHQucmVhZFVFRygpLCBnID0gdC5yZWFkVUVHKCksIHggPSB0LnJlYWRCb29sZWFuKCk7XG4gICAgZm9yIChsZXQgeWUgPSB4ID8gMCA6IHI7IHllIDw9IHI7IHllKyspXG4gICAgICB0LnNraXBVRUcoKSwgdC5za2lwVUVHKCksIHQuc2tpcFVFRygpO1xuICAgIGlmICh0LnNraXBVRUcoKSwgdC5za2lwVUVHKCksIHQuc2tpcFVFRygpLCB0LnNraXBVRUcoKSwgdC5za2lwVUVHKCksIHQuc2tpcFVFRygpLCB0LnJlYWRCb29sZWFuKCkgJiYgdC5yZWFkQm9vbGVhbigpKVxuICAgICAgZm9yIChsZXQgYmUgPSAwOyBiZSA8IDQ7IGJlKyspXG4gICAgICAgIGZvciAobGV0IEZlID0gMDsgRmUgPCAoYmUgPT09IDMgPyAyIDogNik7IEZlKyspXG4gICAgICAgICAgaWYgKCF0LnJlYWRCb29sZWFuKCkpXG4gICAgICAgICAgICB0LnJlYWRVRUcoKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHdlID0gTWF0aC5taW4oNjQsIDEgPDwgNCArIChiZSA8PCAxKSk7XG4gICAgICAgICAgICBiZSA+IDEgJiYgdC5yZWFkRUcoKTtcbiAgICAgICAgICAgIGZvciAobGV0IE5lID0gMDsgTmUgPCB3ZTsgTmUrKylcbiAgICAgICAgICAgICAgdC5yZWFkRUcoKTtcbiAgICAgICAgICB9XG4gICAgdC5yZWFkQm9vbGVhbigpLCB0LnJlYWRCb29sZWFuKCksIHQucmVhZEJvb2xlYW4oKSAmJiAodC5yZWFkVUJ5dGUoKSwgdC5za2lwVUVHKCksIHQuc2tpcFVFRygpLCB0LnJlYWRCb29sZWFuKCkpO1xuICAgIGNvbnN0IE8gPSB0LnJlYWRVRUcoKTtcbiAgICBsZXQgVSA9IDA7XG4gICAgZm9yIChsZXQgeWUgPSAwOyB5ZSA8IE87IHllKyspIHtcbiAgICAgIGxldCBiZSA9ICExO1xuICAgICAgaWYgKHllICE9PSAwICYmIChiZSA9IHQucmVhZEJvb2xlYW4oKSksIGJlKSB7XG4gICAgICAgIHllID09PSBPICYmIHQucmVhZFVFRygpLCB0LnJlYWRCb29sZWFuKCksIHQucmVhZFVFRygpO1xuICAgICAgICBsZXQgRmUgPSAwO1xuICAgICAgICBmb3IgKGxldCBYZSA9IDA7IFhlIDw9IFU7IFhlKyspIHtcbiAgICAgICAgICBjb25zdCB3ZSA9IHQucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgICBsZXQgTmUgPSAhMTtcbiAgICAgICAgICB3ZSB8fCAoTmUgPSB0LnJlYWRCb29sZWFuKCkpLCAod2UgfHwgTmUpICYmIEZlKys7XG4gICAgICAgIH1cbiAgICAgICAgVSA9IEZlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgRmUgPSB0LnJlYWRVRUcoKSwgWGUgPSB0LnJlYWRVRUcoKTtcbiAgICAgICAgVSA9IEZlICsgWGU7XG4gICAgICAgIGZvciAobGV0IHdlID0gMDsgd2UgPCBGZTsgd2UrKylcbiAgICAgICAgICB0LnJlYWRVRUcoKSwgdC5yZWFkQm9vbGVhbigpO1xuICAgICAgICBmb3IgKGxldCB3ZSA9IDA7IHdlIDwgWGU7IHdlKyspXG4gICAgICAgICAgdC5yZWFkVUVHKCksIHQucmVhZEJvb2xlYW4oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHQucmVhZEJvb2xlYW4oKSkge1xuICAgICAgY29uc3QgeWUgPSB0LnJlYWRVRUcoKTtcbiAgICAgIGZvciAobGV0IGJlID0gMDsgYmUgPCB5ZTsgYmUrKykge1xuICAgICAgICBmb3IgKGxldCBGZSA9IDA7IEZlIDwgZyArIDQ7IEZlKyspXG4gICAgICAgICAgdC5yZWFkQml0cygxKTtcbiAgICAgICAgdC5yZWFkQml0cygxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IEwgPSAwLCBtID0gMSwgdiA9IDEsIFAgPSAhMCwgTiA9IDEsIFkgPSAwO1xuICAgIHQucmVhZEJvb2xlYW4oKSwgdC5yZWFkQm9vbGVhbigpO1xuICAgIGxldCBlZSA9ICExO1xuICAgIGlmICh0LnJlYWRCb29sZWFuKCkpIHtcbiAgICAgIGlmICh0LnJlYWRCb29sZWFuKCkpIHtcbiAgICAgICAgY29uc3QgZHQgPSB0LnJlYWRVQnl0ZSgpLCBKZSA9IFsxLCAxMiwgMTAsIDE2LCA0MCwgMjQsIDIwLCAzMiwgODAsIDE4LCAxNSwgNjQsIDE2MCwgNCwgMywgMl0sIFFlID0gWzEsIDExLCAxMSwgMTEsIDMzLCAxMSwgMTEsIDExLCAzMywgMTEsIDExLCAzMywgOTksIDMsIDIsIDFdO1xuICAgICAgICBkdCA+IDAgJiYgZHQgPCAxNiA/IChtID0gSmVbZHQgLSAxXSwgdiA9IFFlW2R0IC0gMV0pIDogZHQgPT09IDI1NSAmJiAobSA9IHQucmVhZEJpdHMoMTYpLCB2ID0gdC5yZWFkQml0cygxNikpO1xuICAgICAgfVxuICAgICAgaWYgKHQucmVhZEJvb2xlYW4oKSAmJiB0LnJlYWRCb29sZWFuKCksIHQucmVhZEJvb2xlYW4oKSAmJiAodC5yZWFkQml0cygzKSwgdC5yZWFkQm9vbGVhbigpLCB0LnJlYWRCb29sZWFuKCkgJiYgKHQucmVhZFVCeXRlKCksIHQucmVhZFVCeXRlKCksIHQucmVhZFVCeXRlKCkpKSwgdC5yZWFkQm9vbGVhbigpICYmICh0LnJlYWRVRUcoKSwgdC5yZWFkVUVHKCkpLCB0LnJlYWRCb29sZWFuKCksIHQucmVhZEJvb2xlYW4oKSwgdC5yZWFkQm9vbGVhbigpLCBlZSA9IHQucmVhZEJvb2xlYW4oKSwgZWUgJiYgKHQuc2tpcFVFRygpLCB0LnNraXBVRUcoKSwgdC5za2lwVUVHKCksIHQuc2tpcFVFRygpKSwgdC5yZWFkQm9vbGVhbigpICYmIChOID0gdC5yZWFkQml0cygzMiksIFkgPSB0LnJlYWRCaXRzKDMyKSwgdC5yZWFkQm9vbGVhbigpICYmIHQucmVhZFVFRygpLCB0LnJlYWRCb29sZWFuKCkpKSB7XG4gICAgICAgIGNvbnN0IFFlID0gdC5yZWFkQm9vbGVhbigpLCBpdCA9IHQucmVhZEJvb2xlYW4oKTtcbiAgICAgICAgbGV0IGplID0gITE7XG4gICAgICAgIChRZSB8fCBpdCkgJiYgKGplID0gdC5yZWFkQm9vbGVhbigpLCBqZSAmJiAodC5yZWFkVUJ5dGUoKSwgdC5yZWFkQml0cyg1KSwgdC5yZWFkQm9vbGVhbigpLCB0LnJlYWRCaXRzKDUpKSwgdC5yZWFkQml0cyg0KSwgdC5yZWFkQml0cyg0KSwgamUgJiYgdC5yZWFkQml0cyg0KSwgdC5yZWFkQml0cyg1KSwgdC5yZWFkQml0cyg1KSwgdC5yZWFkQml0cyg1KSk7XG4gICAgICAgIGZvciAobGV0IEIgPSAwOyBCIDw9IHI7IEIrKykge1xuICAgICAgICAgIFAgPSB0LnJlYWRCb29sZWFuKCk7XG4gICAgICAgICAgY29uc3QgUyA9IFAgfHwgdC5yZWFkQm9vbGVhbigpO1xuICAgICAgICAgIGxldCBUID0gITE7XG4gICAgICAgICAgUyA/IHQucmVhZEVHKCkgOiBUID0gdC5yZWFkQm9vbGVhbigpO1xuICAgICAgICAgIGNvbnN0IEcgPSBUID8gMSA6IHQucmVhZFVFRygpICsgMTtcbiAgICAgICAgICBpZiAoUWUpXG4gICAgICAgICAgICBmb3IgKGxldCBaID0gMDsgWiA8IEc7IForKylcbiAgICAgICAgICAgICAgdC5yZWFkVUVHKCksIHQucmVhZFVFRygpLCBqZSAmJiAodC5yZWFkVUVHKCksIHQucmVhZFVFRygpKSwgdC5za2lwQml0cygxKTtcbiAgICAgICAgICBpZiAoaXQpXG4gICAgICAgICAgICBmb3IgKGxldCBaID0gMDsgWiA8IEc7IForKylcbiAgICAgICAgICAgICAgdC5yZWFkVUVHKCksIHQucmVhZFVFRygpLCBqZSAmJiAodC5yZWFkVUVHKCksIHQucmVhZFVFRygpKSwgdC5za2lwQml0cygxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdC5yZWFkQm9vbGVhbigpICYmICh0LnJlYWRCb29sZWFuKCksIHQucmVhZEJvb2xlYW4oKSwgdC5yZWFkQm9vbGVhbigpLCBMID0gdC5yZWFkVUVHKCkpO1xuICAgIH1cbiAgICBsZXQgbGUgPSBNLCBUZSA9IEg7XG4gICAgaWYgKEspIHtcbiAgICAgIGxldCB5ZSA9IDEsIGJlID0gMTtcbiAgICAgIEYgPT09IDEgPyB5ZSA9IGJlID0gMiA6IEYgPT0gMiAmJiAoeWUgPSAyKSwgbGUgPSBNIC0geWUgKiBDIC0geWUgKiBqLCBUZSA9IEggLSBiZSAqICQgLSBiZSAqIGs7XG4gICAgfVxuICAgIGNvbnN0IERlID0gbiA/IFtcIkFcIiwgXCJCXCIsIFwiQ1wiXVtuXSA6IFwiXCIsIHplID0gYSA8PCAyNCB8IGwgPDwgMTYgfCBjIDw8IDggfCB1O1xuICAgIGxldCBfZSA9IDA7XG4gICAgZm9yIChsZXQgeWUgPSAwOyB5ZSA8IDMyOyB5ZSsrKVxuICAgICAgX2UgPSAoX2UgfCAoemUgPj4geWUgJiAxKSA8PCAzMSAtIHllKSA+Pj4gMDtcbiAgICBsZXQgeGUgPSBfZS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIG8gPT09IDEgJiYgeGUgPT09IFwiMlwiICYmICh4ZSA9IFwiNlwiKSwge1xuICAgICAgY29kZWNTdHJpbmc6IGBodmMxLiR7RGV9JHtvfS4ke3hlfS4ke2kgPyBcIkhcIiA6IFwiTFwifSR7Yn0uQjBgLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGdlbmVyYWxfdGllcl9mbGFnOiBpLFxuICAgICAgICBnZW5lcmFsX3Byb2ZpbGVfaWRjOiBvLFxuICAgICAgICBnZW5lcmFsX3Byb2ZpbGVfc3BhY2U6IG4sXG4gICAgICAgIGdlbmVyYWxfcHJvZmlsZV9jb21wYXRpYmlsaXR5X2ZsYWdzOiBbYSwgbCwgYywgdV0sXG4gICAgICAgIGdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3M6IFtkLCBoLCBmLCBwLCB5LCBFXSxcbiAgICAgICAgZ2VuZXJhbF9sZXZlbF9pZGM6IGIsXG4gICAgICAgIGJpdF9kZXB0aDogVyArIDgsXG4gICAgICAgIGJpdF9kZXB0aF9sdW1hX21pbnVzODogVyxcbiAgICAgICAgYml0X2RlcHRoX2Nocm9tYV9taW51czg6IF8sXG4gICAgICAgIG1pbl9zcGF0aWFsX3NlZ21lbnRhdGlvbl9pZGM6IEwsXG4gICAgICAgIGNocm9tYV9mb3JtYXRfaWRjOiBGLFxuICAgICAgICBmcmFtZV9yYXRlOiB7XG4gICAgICAgICAgZml4ZWQ6IFAsXG4gICAgICAgICAgZnBzOiBZIC8gTlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgd2lkdGg6IGxlLFxuICAgICAgaGVpZ2h0OiBUZSxcbiAgICAgIHBpeGVsUmF0aW86IFttLCB2XVxuICAgIH07XG4gIH1cbiAgcmVhZFBQUyhlKSB7XG4gICAgY29uc3QgdCA9IG5ldyBabih0aGlzLmVic3AycmJzcChlKSk7XG4gICAgdC5yZWFkVUJ5dGUoKSwgdC5yZWFkVUJ5dGUoKSwgdC5za2lwVUVHKCksIHQuc2tpcFVFRygpLCB0LnNraXBCaXRzKDIpLCB0LnNraXBCaXRzKDMpLCB0LnNraXBCaXRzKDIpLCB0LnNraXBVRUcoKSwgdC5za2lwVUVHKCksIHQuc2tpcEVHKCksIHQuc2tpcEJpdHMoMiksIHQucmVhZEJvb2xlYW4oKSAmJiB0LnNraXBVRUcoKSwgdC5za2lwRUcoKSwgdC5za2lwRUcoKSwgdC5za2lwQml0cyg0KTtcbiAgICBjb25zdCBuID0gdC5yZWFkQm9vbGVhbigpLCBpID0gdC5yZWFkQm9vbGVhbigpO1xuICAgIGxldCBvID0gMTtcbiAgICByZXR1cm4gaSAmJiBuID8gbyA9IDAgOiBpID8gbyA9IDMgOiBuICYmIChvID0gMiksIHtcbiAgICAgIHBhcmFsbGVsaXNtVHlwZTogb1xuICAgIH07XG4gIH1cbiAgbWF0Y2hTUFMoZSwgdCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGUpLnN1YnN0cigzKSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCB0KS5zdWJzdHIoMyk7XG4gIH1cbn1cbmNvbnN0IFd0ID0gMTg4O1xuY2xhc3MgSXMge1xuICBjb25zdHJ1Y3RvcihlLCB0LCByLCBuKSB7XG4gICAgdGhpcy5sb2dnZXIgPSB2b2lkIDAsIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDAsIHRoaXMuY29uZmlnID0gdm9pZCAwLCB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB2b2lkIDAsIHRoaXMuc2FtcGxlQWVzID0gbnVsbCwgdGhpcy5wbXRQYXJzZWQgPSAhMSwgdGhpcy5hdWRpb0NvZGVjID0gdm9pZCAwLCB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDAsIHRoaXMuX3BtdElkID0gLTEsIHRoaXMuX3ZpZGVvVHJhY2sgPSB2b2lkIDAsIHRoaXMuX2F1ZGlvVHJhY2sgPSB2b2lkIDAsIHRoaXMuX2lkM1RyYWNrID0gdm9pZCAwLCB0aGlzLl90eHRUcmFjayA9IHZvaWQgMCwgdGhpcy5hYWNPdmVyRmxvdyA9IG51bGwsIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGwsIHRoaXMudmlkZW9QYXJzZXIgPSB2b2lkIDAsIHRoaXMub2JzZXJ2ZXIgPSBlLCB0aGlzLmNvbmZpZyA9IHQsIHRoaXMudHlwZVN1cHBvcnRlZCA9IHIsIHRoaXMubG9nZ2VyID0gbiwgdGhpcy52aWRlb1BhcnNlciA9IG51bGw7XG4gIH1cbiAgc3RhdGljIHByb2JlKGUsIHQpIHtcbiAgICBjb25zdCByID0gSXMuc3luY09mZnNldChlKTtcbiAgICByZXR1cm4gciA+IDAgJiYgdC53YXJuKGBNUEVHMi1UUyBkZXRlY3RlZCBidXQgZmlyc3Qgc3luYyB3b3JkIGZvdW5kIEAgb2Zmc2V0ICR7cn1gKSwgciAhPT0gLTE7XG4gIH1cbiAgc3RhdGljIHN5bmNPZmZzZXQoZSkge1xuICAgIGNvbnN0IHQgPSBlLmxlbmd0aDtcbiAgICBsZXQgciA9IE1hdGgubWluKFd0ICogNSwgdCAtIFd0KSArIDEsIG4gPSAwO1xuICAgIGZvciAoOyBuIDwgcjsgKSB7XG4gICAgICBsZXQgaSA9ICExLCBvID0gLTEsIGEgPSAwO1xuICAgICAgZm9yIChsZXQgbCA9IG47IGwgPCB0OyBsICs9IFd0KVxuICAgICAgICBpZiAoZVtsXSA9PT0gNzEgJiYgKHQgLSBsID09PSBXdCB8fCBlW2wgKyBXdF0gPT09IDcxKSkge1xuICAgICAgICAgIGlmIChhKyssIG8gPT09IC0xICYmIChvID0gbCwgbyAhPT0gMCAmJiAociA9IE1hdGgubWluKG8gKyBXdCAqIDk5LCBlLmxlbmd0aCAtIFd0KSArIDEpKSwgaSB8fCAoaSA9IHBjKGUsIGwpID09PSAwKSwgaSAmJiBhID4gMSAmJiAobyA9PT0gMCAmJiBhID4gMiB8fCBsICsgV3QgPiByKSlcbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChhKVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBuKys7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhIHRyYWNrIG1vZGVsIGludGVybmFsIHRvIGRlbXV4ZXIgdXNlZCB0byBkcml2ZSByZW11eGluZyBpbnB1dFxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZVRyYWNrKGUsIHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGFpbmVyOiBlID09PSBcInZpZGVvXCIgfHwgZSA9PT0gXCJhdWRpb1wiID8gXCJ2aWRlby9tcDJ0XCIgOiB2b2lkIDAsXG4gICAgICB0eXBlOiBlLFxuICAgICAgaWQ6IExnW2VdLFxuICAgICAgcGlkOiAtMSxcbiAgICAgIGlucHV0VGltZVNjYWxlOiA5ZTQsXG4gICAgICBzZXF1ZW5jZU51bWJlcjogMCxcbiAgICAgIHNhbXBsZXM6IFtdLFxuICAgICAgZHJvcHBlZDogMCxcbiAgICAgIGR1cmF0aW9uOiBlID09PSBcImF1ZGlvXCIgPyB0IDogdm9pZCAwXG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBuZXcgaW5pdCBzZWdtZW50IG9uIHRoZSBkZW11eGVyL3JlbXV4ZXIgaW50ZXJmYWNlLiBOZWVkZWQgZm9yIGRpc2NvbnRpbnVpdGllcy90cmFjay1zd2l0Y2hlcyAob3IgYXQgc3RyZWFtIHN0YXJ0KVxuICAgKiBSZXNldHMgYWxsIGludGVybmFsIHRyYWNrIGluc3RhbmNlcyBvZiB0aGUgZGVtdXhlci5cbiAgICovXG4gIHJlc2V0SW5pdFNlZ21lbnQoZSwgdCwgciwgbikge1xuICAgIHRoaXMucG10UGFyc2VkID0gITEsIHRoaXMuX3BtdElkID0gLTEsIHRoaXMuX3ZpZGVvVHJhY2sgPSBJcy5jcmVhdGVUcmFjayhcInZpZGVvXCIpLCB0aGlzLl92aWRlb1RyYWNrLmR1cmF0aW9uID0gbiwgdGhpcy5fYXVkaW9UcmFjayA9IElzLmNyZWF0ZVRyYWNrKFwiYXVkaW9cIiwgbiksIHRoaXMuX2lkM1RyYWNrID0gSXMuY3JlYXRlVHJhY2soXCJpZDNcIiksIHRoaXMuX3R4dFRyYWNrID0gSXMuY3JlYXRlVHJhY2soXCJ0ZXh0XCIpLCB0aGlzLl9hdWRpb1RyYWNrLnNlZ21lbnRDb2RlYyA9IFwiYWFjXCIsIHRoaXMudmlkZW9QYXJzZXIgPSBudWxsLCB0aGlzLmFhY092ZXJGbG93ID0gbnVsbCwgdGhpcy5yZW1haW5kZXJEYXRhID0gbnVsbCwgdGhpcy5hdWRpb0NvZGVjID0gdCwgdGhpcy52aWRlb0NvZGVjID0gcjtcbiAgfVxuICByZXNldFRpbWVTdGFtcCgpIHtcbiAgfVxuICByZXNldENvbnRpZ3VpdHkoKSB7XG4gICAgY29uc3Qge1xuICAgICAgX2F1ZGlvVHJhY2s6IGUsXG4gICAgICBfdmlkZW9UcmFjazogdCxcbiAgICAgIF9pZDNUcmFjazogclxuICAgIH0gPSB0aGlzO1xuICAgIGUgJiYgKGUucGVzRGF0YSA9IG51bGwpLCB0ICYmICh0LnBlc0RhdGEgPSBudWxsKSwgciAmJiAoci5wZXNEYXRhID0gbnVsbCksIHRoaXMuYWFjT3ZlckZsb3cgPSBudWxsLCB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsO1xuICB9XG4gIGRlbXV4KGUsIHQsIHIgPSAhMSwgbiA9ICExKSB7XG4gICAgciB8fCAodGhpcy5zYW1wbGVBZXMgPSBudWxsKTtcbiAgICBsZXQgaTtcbiAgICBjb25zdCBvID0gdGhpcy5fdmlkZW9UcmFjaywgYSA9IHRoaXMuX2F1ZGlvVHJhY2ssIGwgPSB0aGlzLl9pZDNUcmFjaywgYyA9IHRoaXMuX3R4dFRyYWNrO1xuICAgIGxldCB1ID0gby5waWQsIGQgPSBvLnBlc0RhdGEsIGggPSBhLnBpZCwgZiA9IGwucGlkLCBwID0gYS5wZXNEYXRhLCB5ID0gbC5wZXNEYXRhLCBFID0gbnVsbCwgYiA9IHRoaXMucG10UGFyc2VkLCBSID0gdGhpcy5fcG10SWQsIEEgPSBlLmxlbmd0aDtcbiAgICBpZiAodGhpcy5yZW1haW5kZXJEYXRhICYmIChlID0gX3IodGhpcy5yZW1haW5kZXJEYXRhLCBlKSwgQSA9IGUubGVuZ3RoLCB0aGlzLnJlbWFpbmRlckRhdGEgPSBudWxsKSwgQSA8IFd0ICYmICFuKVxuICAgICAgcmV0dXJuIHRoaXMucmVtYWluZGVyRGF0YSA9IGUsIHtcbiAgICAgICAgYXVkaW9UcmFjazogYSxcbiAgICAgICAgdmlkZW9UcmFjazogbyxcbiAgICAgICAgaWQzVHJhY2s6IGwsXG4gICAgICAgIHRleHRUcmFjazogY1xuICAgICAgfTtcbiAgICBjb25zdCBGID0gTWF0aC5tYXgoMCwgSXMuc3luY09mZnNldChlKSk7XG4gICAgQSAtPSAoQSAtIEYpICUgV3QsIEEgPCBlLmJ5dGVMZW5ndGggJiYgIW4gJiYgKHRoaXMucmVtYWluZGVyRGF0YSA9IG5ldyBVaW50OEFycmF5KGUuYnVmZmVyLCBBLCBlLmJ1ZmZlci5ieXRlTGVuZ3RoIC0gQSkpO1xuICAgIGxldCBNID0gMDtcbiAgICBmb3IgKGxldCBLID0gRjsgSyA8IEE7IEsgKz0gV3QpXG4gICAgICBpZiAoZVtLXSA9PT0gNzEpIHtcbiAgICAgICAgY29uc3QgaiA9ICEhKGVbSyArIDFdICYgNjQpLCBDID0gcGMoZSwgSyksIGsgPSAoZVtLICsgM10gJiA0OCkgPj4gNDtcbiAgICAgICAgbGV0ICQ7XG4gICAgICAgIGlmIChrID4gMSkge1xuICAgICAgICAgIGlmICgkID0gSyArIDUgKyBlW0sgKyA0XSwgJCA9PT0gSyArIFd0KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgICQgPSBLICsgNDtcbiAgICAgICAgc3dpdGNoIChDKSB7XG4gICAgICAgICAgY2FzZSB1OlxuICAgICAgICAgICAgaiAmJiAoZCAmJiAoaSA9IGduKGQsIHRoaXMubG9nZ2VyKSkgJiYgKHRoaXMucmVhZHlWaWRlb1BhcnNlcihvLnNlZ21lbnRDb2RlYyksIHRoaXMudmlkZW9QYXJzZXIgIT09IG51bGwgJiYgdGhpcy52aWRlb1BhcnNlci5wYXJzZVBFUyhvLCBjLCBpLCAhMSkpLCBkID0ge1xuICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgc2l6ZTogMFxuICAgICAgICAgICAgfSksIGQgJiYgKGQuZGF0YS5wdXNoKGUuc3ViYXJyYXkoJCwgSyArIFd0KSksIGQuc2l6ZSArPSBLICsgV3QgLSAkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgaDpcbiAgICAgICAgICAgIGlmIChqKSB7XG4gICAgICAgICAgICAgIGlmIChwICYmIChpID0gZ24ocCwgdGhpcy5sb2dnZXIpKSlcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGEuc2VnbWVudENvZGVjKSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiYWFjXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VBQUNQRVMoYSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgY2FzZSBcIm1wM1wiOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlTVBFR1BFUyhhLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICBjYXNlIFwiYWMzXCI6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VBQzNQRVMoYSwgaSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcCA9IHtcbiAgICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgICBzaXplOiAwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwICYmIChwLmRhdGEucHVzaChlLnN1YmFycmF5KCQsIEsgKyBXdCkpLCBwLnNpemUgKz0gSyArIFd0IC0gJCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGY6XG4gICAgICAgICAgICBqICYmICh5ICYmIChpID0gZ24oeSwgdGhpcy5sb2dnZXIpKSAmJiB0aGlzLnBhcnNlSUQzUEVTKGwsIGkpLCB5ID0ge1xuICAgICAgICAgICAgICBkYXRhOiBbXSxcbiAgICAgICAgICAgICAgc2l6ZTogMFxuICAgICAgICAgICAgfSksIHkgJiYgKHkuZGF0YS5wdXNoKGUuc3ViYXJyYXkoJCwgSyArIFd0KSksIHkuc2l6ZSArPSBLICsgV3QgLSAkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGogJiYgKCQgKz0gZVskXSArIDEpLCBSID0gdGhpcy5fcG10SWQgPSBqVChlLCAkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgUjoge1xuICAgICAgICAgICAgaiAmJiAoJCArPSBlWyRdICsgMSk7XG4gICAgICAgICAgICBjb25zdCBXID0gS1QoZSwgJCwgdGhpcy50eXBlU3VwcG9ydGVkLCByLCB0aGlzLm9ic2VydmVyLCB0aGlzLmxvZ2dlcik7XG4gICAgICAgICAgICB1ID0gVy52aWRlb1BpZCwgdSA+IDAgJiYgKG8ucGlkID0gdSwgby5zZWdtZW50Q29kZWMgPSBXLnNlZ21lbnRWaWRlb0NvZGVjKSwgaCA9IFcuYXVkaW9QaWQsIGggPiAwICYmIChhLnBpZCA9IGgsIGEuc2VnbWVudENvZGVjID0gVy5zZWdtZW50QXVkaW9Db2RlYyksIGYgPSBXLmlkM1BpZCwgZiA+IDAgJiYgKGwucGlkID0gZiksIEUgIT09IG51bGwgJiYgIWIgJiYgKHRoaXMubG9nZ2VyLndhcm4oYE1QRUctVFMgUE1UIGZvdW5kIGF0ICR7S30gYWZ0ZXIgdW5rbm93biBQSUQgJyR7RX0nLiBCYWNrdHJhY2tpbmcgdG8gc3luYyBieXRlIEAke0Z9IHRvIHBhcnNlIGFsbCBUUyBwYWNrZXRzLmApLCBFID0gbnVsbCwgSyA9IEYgLSAxODgpLCBiID0gdGhpcy5wbXRQYXJzZWQgPSAhMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgIGNhc2UgODE5MTpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBFID0gQztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgTSsrO1xuICAgIE0gPiAwICYmIG1jKHRoaXMub2JzZXJ2ZXIsIG5ldyBFcnJvcihgRm91bmQgJHtNfSBUUyBwYWNrZXQvcyB0aGF0IGRvIG5vdCBzdGFydCB3aXRoIDB4NDdgKSwgdm9pZCAwLCB0aGlzLmxvZ2dlciksIG8ucGVzRGF0YSA9IGQsIGEucGVzRGF0YSA9IHAsIGwucGVzRGF0YSA9IHk7XG4gICAgY29uc3QgSCA9IHtcbiAgICAgIGF1ZGlvVHJhY2s6IGEsXG4gICAgICB2aWRlb1RyYWNrOiBvLFxuICAgICAgaWQzVHJhY2s6IGwsXG4gICAgICB0ZXh0VHJhY2s6IGNcbiAgICB9O1xuICAgIHJldHVybiBuICYmIHRoaXMuZXh0cmFjdFJlbWFpbmluZ1NhbXBsZXMoSCksIEg7XG4gIH1cbiAgZmx1c2goKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVtYWluZGVyRGF0YTogZVxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMucmVtYWluZGVyRGF0YSA9IG51bGw7XG4gICAgbGV0IHQ7XG4gICAgcmV0dXJuIGUgPyB0ID0gdGhpcy5kZW11eChlLCAtMSwgITEsICEwKSA6IHQgPSB7XG4gICAgICB2aWRlb1RyYWNrOiB0aGlzLl92aWRlb1RyYWNrLFxuICAgICAgYXVkaW9UcmFjazogdGhpcy5fYXVkaW9UcmFjayxcbiAgICAgIGlkM1RyYWNrOiB0aGlzLl9pZDNUcmFjayxcbiAgICAgIHRleHRUcmFjazogdGhpcy5fdHh0VHJhY2tcbiAgICB9LCB0aGlzLmV4dHJhY3RSZW1haW5pbmdTYW1wbGVzKHQpLCB0aGlzLnNhbXBsZUFlcyA/IHRoaXMuZGVjcnlwdCh0LCB0aGlzLnNhbXBsZUFlcykgOiB0O1xuICB9XG4gIGV4dHJhY3RSZW1haW5pbmdTYW1wbGVzKGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpb1RyYWNrOiB0LFxuICAgICAgdmlkZW9UcmFjazogcixcbiAgICAgIGlkM1RyYWNrOiBuLFxuICAgICAgdGV4dFRyYWNrOiBpXG4gICAgfSA9IGUsIG8gPSByLnBlc0RhdGEsIGEgPSB0LnBlc0RhdGEsIGwgPSBuLnBlc0RhdGE7XG4gICAgbGV0IGM7XG4gICAgaWYgKG8gJiYgKGMgPSBnbihvLCB0aGlzLmxvZ2dlcikpID8gKHRoaXMucmVhZHlWaWRlb1BhcnNlcihyLnNlZ21lbnRDb2RlYyksIHRoaXMudmlkZW9QYXJzZXIgIT09IG51bGwgJiYgKHRoaXMudmlkZW9QYXJzZXIucGFyc2VQRVMociwgaSwgYywgITApLCByLnBlc0RhdGEgPSBudWxsKSkgOiByLnBlc0RhdGEgPSBvLCBhICYmIChjID0gZ24oYSwgdGhpcy5sb2dnZXIpKSkge1xuICAgICAgc3dpdGNoICh0LnNlZ21lbnRDb2RlYykge1xuICAgICAgICBjYXNlIFwiYWFjXCI6XG4gICAgICAgICAgdGhpcy5wYXJzZUFBQ1BFUyh0LCBjKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIm1wM1wiOlxuICAgICAgICAgIHRoaXMucGFyc2VNUEVHUEVTKHQsIGMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWMzXCI6XG4gICAgICAgICAgdGhpcy5wYXJzZUFDM1BFUyh0LCBjKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHQucGVzRGF0YSA9IG51bGw7XG4gICAgfSBlbHNlXG4gICAgICBhICE9IG51bGwgJiYgYS5zaXplICYmIHRoaXMubG9nZ2VyLmxvZyhcImxhc3QgQUFDIFBFUyBwYWNrZXQgdHJ1bmNhdGVkLG1pZ2h0IG92ZXJsYXAgYmV0d2VlbiBmcmFnbWVudHNcIiksIHQucGVzRGF0YSA9IGE7XG4gICAgbCAmJiAoYyA9IGduKGwsIHRoaXMubG9nZ2VyKSkgPyAodGhpcy5wYXJzZUlEM1BFUyhuLCBjKSwgbi5wZXNEYXRhID0gbnVsbCkgOiBuLnBlc0RhdGEgPSBsO1xuICB9XG4gIGRlbXV4U2FtcGxlQWVzKGUsIHQsIHIpIHtcbiAgICBjb25zdCBuID0gdGhpcy5kZW11eChlLCByLCAhMCwgIXRoaXMuY29uZmlnLnByb2dyZXNzaXZlKSwgaSA9IHRoaXMuc2FtcGxlQWVzID0gbmV3ICRUKHRoaXMub2JzZXJ2ZXIsIHRoaXMuY29uZmlnLCB0KTtcbiAgICByZXR1cm4gdGhpcy5kZWNyeXB0KG4sIGkpO1xuICB9XG4gIHJlYWR5VmlkZW9QYXJzZXIoZSkge1xuICAgIHRoaXMudmlkZW9QYXJzZXIgPT09IG51bGwgJiYgKGUgPT09IFwiYXZjXCIgPyB0aGlzLnZpZGVvUGFyc2VyID0gbmV3IEdUKCkgOiBlID09PSBcImhldmNcIiAmJiAodGhpcy52aWRlb1BhcnNlciA9IG5ldyBWVCgpKSk7XG4gIH1cbiAgZGVjcnlwdChlLCB0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGF1ZGlvVHJhY2s6IG4sXG4gICAgICAgIHZpZGVvVHJhY2s6IGlcbiAgICAgIH0gPSBlO1xuICAgICAgbi5zYW1wbGVzICYmIG4uc2VnbWVudENvZGVjID09PSBcImFhY1wiID8gdC5kZWNyeXB0QWFjU2FtcGxlcyhuLnNhbXBsZXMsIDAsICgpID0+IHtcbiAgICAgICAgaS5zYW1wbGVzID8gdC5kZWNyeXB0QXZjU2FtcGxlcyhpLnNhbXBsZXMsIDAsIDAsICgpID0+IHtcbiAgICAgICAgICByKGUpO1xuICAgICAgICB9KSA6IHIoZSk7XG4gICAgICB9KSA6IGkuc2FtcGxlcyAmJiB0LmRlY3J5cHRBdmNTYW1wbGVzKGkuc2FtcGxlcywgMCwgMCwgKCkgPT4ge1xuICAgICAgICByKGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm9ic2VydmVyICYmIHRoaXMub2JzZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCksIHRoaXMuY29uZmlnID0gdGhpcy5sb2dnZXIgPSB0aGlzLm9ic2VydmVyID0gbnVsbCwgdGhpcy5hYWNPdmVyRmxvdyA9IHRoaXMudmlkZW9QYXJzZXIgPSB0aGlzLnJlbWFpbmRlckRhdGEgPSB0aGlzLnNhbXBsZUFlcyA9IG51bGwsIHRoaXMuX3ZpZGVvVHJhY2sgPSB0aGlzLl9hdWRpb1RyYWNrID0gdGhpcy5faWQzVHJhY2sgPSB0aGlzLl90eHRUcmFjayA9IHZvaWQgMDtcbiAgfVxuICBwYXJzZUFBQ1BFUyhlLCB0KSB7XG4gICAgbGV0IHIgPSAwO1xuICAgIGNvbnN0IG4gPSB0aGlzLmFhY092ZXJGbG93O1xuICAgIGxldCBpID0gdC5kYXRhO1xuICAgIGlmIChuKSB7XG4gICAgICB0aGlzLmFhY092ZXJGbG93ID0gbnVsbDtcbiAgICAgIGNvbnN0IGQgPSBuLm1pc3NpbmcsIGggPSBuLnNhbXBsZS51bml0LmJ5dGVMZW5ndGg7XG4gICAgICBpZiAoZCA9PT0gLTEpXG4gICAgICAgIGkgPSBfcihuLnNhbXBsZS51bml0LCBpKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBmID0gaCAtIGQ7XG4gICAgICAgIG4uc2FtcGxlLnVuaXQuc2V0KGkuc3ViYXJyYXkoMCwgZCksIGYpLCBlLnNhbXBsZXMucHVzaChuLnNhbXBsZSksIHIgPSBuLm1pc3Npbmc7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBvLCBhO1xuICAgIGZvciAobyA9IHIsIGEgPSBpLmxlbmd0aDsgbyA8IGEgLSAxICYmICFuYShpLCBvKTsgbysrKVxuICAgICAgO1xuICAgIGlmIChvICE9PSByKSB7XG4gICAgICBsZXQgZDtcbiAgICAgIGNvbnN0IGggPSBvIDwgYSAtIDE7XG4gICAgICBpZiAoaCA/IGQgPSBgQUFDIFBFUyBkaWQgbm90IHN0YXJ0IHdpdGggQURUUyBoZWFkZXIsb2Zmc2V0OiR7b31gIDogZCA9IFwiTm8gQURUUyBoZWFkZXIgZm91bmQgaW4gQUFDIFBFU1wiLCBtYyh0aGlzLm9ic2VydmVyLCBuZXcgRXJyb3IoZCksIGgsIHRoaXMubG9nZ2VyKSwgIWgpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3AoZSwgdGhpcy5vYnNlcnZlciwgaSwgbywgdGhpcy5hdWRpb0NvZGVjKTtcbiAgICBsZXQgbDtcbiAgICBpZiAodC5wdHMgIT09IHZvaWQgMClcbiAgICAgIGwgPSB0LnB0cztcbiAgICBlbHNlIGlmIChuKSB7XG4gICAgICBjb25zdCBkID0gdXAoZS5zYW1wbGVyYXRlKTtcbiAgICAgIGwgPSBuLnNhbXBsZS5wdHMgKyBkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFwiW3RzZGVtdXhlcl06IEFBQyBQRVMgdW5rbm93biBQVFNcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBjID0gMCwgdTtcbiAgICBmb3IgKDsgbyA8IGE7IClcbiAgICAgIGlmICh1ID0gZHAoZSwgaSwgbywgbCwgYyksIG8gKz0gdS5sZW5ndGgsIHUubWlzc2luZykge1xuICAgICAgICB0aGlzLmFhY092ZXJGbG93ID0gdTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2VcbiAgICAgICAgZm9yIChjKys7IG8gPCBhIC0gMSAmJiAhbmEoaSwgbyk7IG8rKylcbiAgICAgICAgICA7XG4gIH1cbiAgcGFyc2VNUEVHUEVTKGUsIHQpIHtcbiAgICBjb25zdCByID0gdC5kYXRhLCBuID0gci5sZW5ndGg7XG4gICAgbGV0IGkgPSAwLCBvID0gMDtcbiAgICBjb25zdCBhID0gdC5wdHM7XG4gICAgaWYgKGEgPT09IHZvaWQgMCkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihcIlt0c2RlbXV4ZXJdOiBNUEVHIFBFUyB1bmtub3duIFBUU1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICg7IG8gPCBuOyApXG4gICAgICBpZiAobXAociwgbykpIHtcbiAgICAgICAgY29uc3QgbCA9IGdwKGUsIHIsIG8sIGEsIGkpO1xuICAgICAgICBpZiAobClcbiAgICAgICAgICBvICs9IGwubGVuZ3RoLCBpKys7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZVxuICAgICAgICBvKys7XG4gIH1cbiAgcGFyc2VBQzNQRVMoZSwgdCkge1xuICAgIHtcbiAgICAgIGNvbnN0IHIgPSB0LmRhdGEsIG4gPSB0LnB0cztcbiAgICAgIGlmIChuID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihcIlt0c2RlbXV4ZXJdOiBBQzMgUEVTIHVua25vd24gUFRTXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpID0gci5sZW5ndGg7XG4gICAgICBsZXQgbyA9IDAsIGEgPSAwLCBsO1xuICAgICAgZm9yICg7IGEgPCBpICYmIChsID0gRXAoZSwgciwgYSwgbiwgbysrKSkgPiAwOyApXG4gICAgICAgIGEgKz0gbDtcbiAgICB9XG4gIH1cbiAgcGFyc2VJRDNQRVMoZSwgdCkge1xuICAgIGlmICh0LnB0cyA9PT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFwiW3RzZGVtdXhlcl06IElEMyBQRVMgdW5rbm93biBQVFNcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHIgPSBudCh7fSwgdCwge1xuICAgICAgdHlwZTogdGhpcy5fdmlkZW9UcmFjayA/IGJyLmVtc2cgOiBici5hdWRpb0lkMyxcbiAgICAgIGR1cmF0aW9uOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICB9KTtcbiAgICBlLnNhbXBsZXMucHVzaChyKTtcbiAgfVxufVxuZnVuY3Rpb24gcGMocywgZSkge1xuICByZXR1cm4gKChzW2UgKyAxXSAmIDMxKSA8PCA4KSArIHNbZSArIDJdO1xufVxuZnVuY3Rpb24galQocywgZSkge1xuICByZXR1cm4gKHNbZSArIDEwXSAmIDMxKSA8PCA4IHwgc1tlICsgMTFdO1xufVxuZnVuY3Rpb24gS1QocywgZSwgdCwgciwgbiwgaSkge1xuICBjb25zdCBvID0ge1xuICAgIGF1ZGlvUGlkOiAtMSxcbiAgICB2aWRlb1BpZDogLTEsXG4gICAgaWQzUGlkOiAtMSxcbiAgICBzZWdtZW50VmlkZW9Db2RlYzogXCJhdmNcIixcbiAgICBzZWdtZW50QXVkaW9Db2RlYzogXCJhYWNcIlxuICB9LCBhID0gKHNbZSArIDFdICYgMTUpIDw8IDggfCBzW2UgKyAyXSwgbCA9IGUgKyAzICsgYSAtIDQsIGMgPSAoc1tlICsgMTBdICYgMTUpIDw8IDggfCBzW2UgKyAxMV07XG4gIGZvciAoZSArPSAxMiArIGM7IGUgPCBsOyApIHtcbiAgICBjb25zdCB1ID0gcGMocywgZSksIGQgPSAoc1tlICsgM10gJiAxNSkgPDwgOCB8IHNbZSArIDRdO1xuICAgIHN3aXRjaCAoc1tlXSkge1xuICAgICAgY2FzZSAyMDc6XG4gICAgICAgIGlmICghcikge1xuICAgICAgICAgIHZsKFwiQURUUyBBQUNcIiwgaSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgMTU6XG4gICAgICAgIG8uYXVkaW9QaWQgPT09IC0xICYmIChvLmF1ZGlvUGlkID0gdSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gUGFja2V0aXplZCBtZXRhZGF0YSAoSUQzKVxuICAgICAgY2FzZSAyMTpcbiAgICAgICAgby5pZDNQaWQgPT09IC0xICYmIChvLmlkM1BpZCA9IHUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjE5OlxuICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICB2bChcIkguMjY0XCIsIGkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIDI3OlxuICAgICAgICBvLnZpZGVvUGlkID09PSAtMSAmJiAoby52aWRlb1BpZCA9IHUpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIElTTy9JRUMgMTExNzItMyAoTVBFRy0xIGF1ZGlvKVxuICAgICAgLy8gb3IgSVNPL0lFQyAxMzgxOC0zIChNUEVHLTIgaGFsdmVkIHNhbXBsZSByYXRlIGF1ZGlvKVxuICAgICAgY2FzZSAzOlxuICAgICAgY2FzZSA0OlxuICAgICAgICAhdC5tcGVnICYmICF0Lm1wMyA/IGkubG9nKFwiTVBFRyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIikgOiBvLmF1ZGlvUGlkID09PSAtMSAmJiAoby5hdWRpb1BpZCA9IHUsIG8uc2VnbWVudEF1ZGlvQ29kZWMgPSBcIm1wM1wiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE5MzpcbiAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgdmwoXCJBQy0zXCIsIGkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIDEyOTpcbiAgICAgICAgdC5hYzMgPyBvLmF1ZGlvUGlkID09PSAtMSAmJiAoby5hdWRpb1BpZCA9IHUsIG8uc2VnbWVudEF1ZGlvQ29kZWMgPSBcImFjM1wiKSA6IGkubG9nKFwiQUMtMyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXJcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2OlxuICAgICAgICBpZiAoby5hdWRpb1BpZCA9PT0gLTEgJiYgZCA+IDApIHtcbiAgICAgICAgICBsZXQgaCA9IGUgKyA1LCBmID0gZDtcbiAgICAgICAgICBmb3IgKDsgZiA+IDI7ICkge1xuICAgICAgICAgICAgc3dpdGNoIChzW2hdKSB7XG4gICAgICAgICAgICAgIGNhc2UgMTA2OlxuICAgICAgICAgICAgICAgIHQuYWMzICE9PSAhMCA/IGkubG9nKFwiQUMtMyBhdWRpbyBmb3VuZCwgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIgZm9yIG5vd1wiKSA6IChvLmF1ZGlvUGlkID0gdSwgby5zZWdtZW50QXVkaW9Db2RlYyA9IFwiYWMzXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeSA9IHNbaCArIDFdICsgMjtcbiAgICAgICAgICAgIGggKz0geSwgZiAtPSB5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTk0OlxuICAgICAgLy8gU0FNUExFLUFFUyBFQzNcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgMTM1OlxuICAgICAgICByZXR1cm4gbWMobiwgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgRUMtMyBpbiBNMlRTIGZvdW5kXCIpLCB2b2lkIDAsIGkpLCBvO1xuICAgICAgY2FzZSAzNjpcbiAgICAgICAgby52aWRlb1BpZCA9PT0gLTEgJiYgKG8udmlkZW9QaWQgPSB1LCBvLnNlZ21lbnRWaWRlb0NvZGVjID0gXCJoZXZjXCIsIGkubG9nKFwiSEVWQyBpbiBNMlRTIGZvdW5kXCIpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGUgKz0gZCArIDU7XG4gIH1cbiAgcmV0dXJuIG87XG59XG5mdW5jdGlvbiBtYyhzLCBlLCB0LCByKSB7XG4gIHIud2FybihgcGFyc2luZyBlcnJvcjogJHtlLm1lc3NhZ2V9YCksIHMuZW1pdChJLkVSUk9SLCBJLkVSUk9SLCB7XG4gICAgdHlwZTogdmUuTUVESUFfRVJST1IsXG4gICAgZGV0YWlsczogSi5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgZmF0YWw6ICExLFxuICAgIGxldmVsUmV0cnk6IHQsXG4gICAgZXJyb3I6IGUsXG4gICAgcmVhc29uOiBlLm1lc3NhZ2VcbiAgfSk7XG59XG5mdW5jdGlvbiB2bChzLCBlKSB7XG4gIGUubG9nKGAke3N9IHdpdGggQUVTLTEyOC1DQkMgZW5jcnlwdGlvbiBmb3VuZCBpbiB1bmVuY3J5cHRlZCBzdHJlYW1gKTtcbn1cbmZ1bmN0aW9uIGduKHMsIGUpIHtcbiAgbGV0IHQgPSAwLCByLCBuLCBpLCBvLCBhO1xuICBjb25zdCBsID0gcy5kYXRhO1xuICBpZiAoIXMgfHwgcy5zaXplID09PSAwKVxuICAgIHJldHVybiBudWxsO1xuICBmb3IgKDsgbFswXS5sZW5ndGggPCAxOSAmJiBsLmxlbmd0aCA+IDE7IClcbiAgICBsWzBdID0gX3IobFswXSwgbFsxXSksIGwuc3BsaWNlKDEsIDEpO1xuICBpZiAociA9IGxbMF0sIChyWzBdIDw8IDE2KSArIChyWzFdIDw8IDgpICsgclsyXSA9PT0gMSkge1xuICAgIGlmIChuID0gKHJbNF0gPDwgOCkgKyByWzVdLCBuICYmIG4gPiBzLnNpemUgLSA2KVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgdSA9IHJbN107XG4gICAgdSAmIDE5MiAmJiAobyA9IChyWzldICYgMTQpICogNTM2ODcwOTEyICsgLy8gMSA8PCAyOVxuICAgIChyWzEwXSAmIDI1NSkgKiA0MTk0MzA0ICsgLy8gMSA8PCAyMlxuICAgIChyWzExXSAmIDI1NCkgKiAxNjM4NCArIC8vIDEgPDwgMTRcbiAgICAoclsxMl0gJiAyNTUpICogMTI4ICsgLy8gMSA8PCA3XG4gICAgKHJbMTNdICYgMjU0KSAvIDIsIHUgJiA2NCA/IChhID0gKHJbMTRdICYgMTQpICogNTM2ODcwOTEyICsgLy8gMSA8PCAyOVxuICAgIChyWzE1XSAmIDI1NSkgKiA0MTk0MzA0ICsgLy8gMSA8PCAyMlxuICAgIChyWzE2XSAmIDI1NCkgKiAxNjM4NCArIC8vIDEgPDwgMTRcbiAgICAoclsxN10gJiAyNTUpICogMTI4ICsgLy8gMSA8PCA3XG4gICAgKHJbMThdICYgMjU0KSAvIDIsIG8gLSBhID4gNjAgKiA5ZTQgJiYgKGUud2FybihgJHtNYXRoLnJvdW5kKChvIC0gYSkgLyA5ZTQpfXMgZGVsdGEgYmV0d2VlbiBQVFMgYW5kIERUUywgYWxpZ24gdGhlbWApLCBvID0gYSkpIDogYSA9IG8pLCBpID0gcls4XTtcbiAgICBsZXQgZCA9IGkgKyA5O1xuICAgIGlmIChzLnNpemUgPD0gZClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIHMuc2l6ZSAtPSBkO1xuICAgIGNvbnN0IGggPSBuZXcgVWludDhBcnJheShzLnNpemUpO1xuICAgIGZvciAobGV0IGYgPSAwLCBwID0gbC5sZW5ndGg7IGYgPCBwOyBmKyspIHtcbiAgICAgIHIgPSBsW2ZdO1xuICAgICAgbGV0IHkgPSByLmJ5dGVMZW5ndGg7XG4gICAgICBpZiAoZClcbiAgICAgICAgaWYgKGQgPiB5KSB7XG4gICAgICAgICAgZCAtPSB5O1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICByID0gci5zdWJhcnJheShkKSwgeSAtPSBkLCBkID0gMDtcbiAgICAgIGguc2V0KHIsIHQpLCB0ICs9IHk7XG4gICAgfVxuICAgIHJldHVybiBuICYmIChuIC09IGkgKyAzKSwge1xuICAgICAgZGF0YTogaCxcbiAgICAgIHB0czogbyxcbiAgICAgIGR0czogYSxcbiAgICAgIGxlbjogblxuICAgIH07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5jbGFzcyBIVCB7XG4gIHN0YXRpYyBnZXRTaWxlbnRGcmFtZShlLCB0KSB7XG4gICAgc3dpdGNoIChlKSB7XG4gICAgICBjYXNlIFwibXA0YS40MC4yXCI6XG4gICAgICAgIGlmICh0ID09PSAxKVxuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMCwgMjAwLCAwLCAxMjgsIDM1LCAxMjhdKTtcbiAgICAgICAgaWYgKHQgPT09IDIpXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFszMywgMCwgNzMsIDE0NCwgMiwgMjUsIDAsIDM1LCAxMjhdKTtcbiAgICAgICAgaWYgKHQgPT09IDMpXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFswLCAyMDAsIDAsIDEyOCwgMzIsIDEzMiwgMSwgMzgsIDY0LCA4LCAxMDAsIDAsIDE0Ml0pO1xuICAgICAgICBpZiAodCA9PT0gNClcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzAsIDIwMCwgMCwgMTI4LCAzMiwgMTMyLCAxLCAzOCwgNjQsIDgsIDEwMCwgMCwgMTI4LCA0NCwgMTI4LCA4LCAyLCA1Nl0pO1xuICAgICAgICBpZiAodCA9PT0gNSlcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzAsIDIwMCwgMCwgMTI4LCAzMiwgMTMyLCAxLCAzOCwgNjQsIDgsIDEwMCwgMCwgMTMwLCA0OCwgNCwgMTUzLCAwLCAzMywgMTQ0LCAyLCA1Nl0pO1xuICAgICAgICBpZiAodCA9PT0gNilcbiAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoWzAsIDIwMCwgMCwgMTI4LCAzMiwgMTMyLCAxLCAzOCwgNjQsIDgsIDEwMCwgMCwgMTMwLCA0OCwgNCwgMTUzLCAwLCAzMywgMTQ0LCAyLCAwLCAxNzgsIDAsIDMyLCA4LCAyMjRdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBoYW5kbGUgSEUtQUFDIGJlbG93IChtcDRhLjQwLjUgLyBtcDRhLjQwLjI5KVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHQgPT09IDEpXG4gICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFsxLCA2NCwgMzQsIDEyOCwgMTYzLCA3OCwgMjMwLCAxMjgsIDE4NiwgOCwgMCwgMCwgMCwgMjgsIDYsIDI0MSwgMTkzLCAxMCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDk0XSk7XG4gICAgICAgIGlmICh0ID09PSAyKVxuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMSwgNjQsIDM0LCAxMjgsIDE2MywgOTQsIDIzMCwgMTI4LCAxODYsIDgsIDAsIDAsIDAsIDAsIDE0OSwgMCwgNiwgMjQxLCAxNjEsIDEwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDk0XSk7XG4gICAgICAgIGlmICh0ID09PSAzKVxuICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShbMSwgNjQsIDM0LCAxMjgsIDE2MywgOTQsIDIzMCwgMTI4LCAxODYsIDgsIDAsIDAsIDAsIDAsIDE0OSwgMCwgNiwgMjQxLCAxNjEsIDEwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDkwLCA5MCwgOTAsIDk0XSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuY29uc3QgU3MgPSBNYXRoLnBvdygyLCAzMikgLSAxO1xuY2xhc3MgWCB7XG4gIHN0YXRpYyBpbml0KCkge1xuICAgIFgudHlwZXMgPSB7XG4gICAgICBhdmMxOiBbXSxcbiAgICAgIC8vIGNvZGluZ25hbWVcbiAgICAgIGF2Y0M6IFtdLFxuICAgICAgaHZjMTogW10sXG4gICAgICBodmNDOiBbXSxcbiAgICAgIGJ0cnQ6IFtdLFxuICAgICAgZGluZjogW10sXG4gICAgICBkcmVmOiBbXSxcbiAgICAgIGVzZHM6IFtdLFxuICAgICAgZnR5cDogW10sXG4gICAgICBoZGxyOiBbXSxcbiAgICAgIG1kYXQ6IFtdLFxuICAgICAgbWRoZDogW10sXG4gICAgICBtZGlhOiBbXSxcbiAgICAgIG1maGQ6IFtdLFxuICAgICAgbWluZjogW10sXG4gICAgICBtb29mOiBbXSxcbiAgICAgIG1vb3Y6IFtdLFxuICAgICAgbXA0YTogW10sXG4gICAgICBcIi5tcDNcIjogW10sXG4gICAgICBkYWMzOiBbXSxcbiAgICAgIFwiYWMtM1wiOiBbXSxcbiAgICAgIG12ZXg6IFtdLFxuICAgICAgbXZoZDogW10sXG4gICAgICBwYXNwOiBbXSxcbiAgICAgIHNkdHA6IFtdLFxuICAgICAgc3RibDogW10sXG4gICAgICBzdGNvOiBbXSxcbiAgICAgIHN0c2M6IFtdLFxuICAgICAgc3RzZDogW10sXG4gICAgICBzdHN6OiBbXSxcbiAgICAgIHN0dHM6IFtdLFxuICAgICAgdGZkdDogW10sXG4gICAgICB0ZmhkOiBbXSxcbiAgICAgIHRyYWY6IFtdLFxuICAgICAgdHJhazogW10sXG4gICAgICB0cnVuOiBbXSxcbiAgICAgIHRyZXg6IFtdLFxuICAgICAgdGtoZDogW10sXG4gICAgICB2bWhkOiBbXSxcbiAgICAgIHNtaGQ6IFtdXG4gICAgfTtcbiAgICBsZXQgZTtcbiAgICBmb3IgKGUgaW4gWC50eXBlcylcbiAgICAgIFgudHlwZXMuaGFzT3duUHJvcGVydHkoZSkgJiYgKFgudHlwZXNbZV0gPSBbZS5jaGFyQ29kZUF0KDApLCBlLmNoYXJDb2RlQXQoMSksIGUuY2hhckNvZGVBdCgyKSwgZS5jaGFyQ29kZUF0KDMpXSk7XG4gICAgY29uc3QgdCA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDAsXG4gICAgICAvLyB2ZXJzaW9uIDBcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC8vIGZsYWdzXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLy8gcHJlX2RlZmluZWRcbiAgICAgIDExOCxcbiAgICAgIDEwNSxcbiAgICAgIDEwMCxcbiAgICAgIDEwMSxcbiAgICAgIC8vIGhhbmRsZXJfdHlwZTogJ3ZpZGUnXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC8vIHJlc2VydmVkXG4gICAgICA4NixcbiAgICAgIDEwNSxcbiAgICAgIDEwMCxcbiAgICAgIDEwMSxcbiAgICAgIDExMSxcbiAgICAgIDcyLFxuICAgICAgOTcsXG4gICAgICAxMTAsXG4gICAgICAxMDAsXG4gICAgICAxMDgsXG4gICAgICAxMDEsXG4gICAgICAxMTQsXG4gICAgICAwXG4gICAgICAvLyBuYW1lOiAnVmlkZW9IYW5kbGVyJ1xuICAgIF0pLCByID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMCxcbiAgICAgIC8vIHZlcnNpb24gMFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLy8gZmxhZ3NcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAvLyBwcmVfZGVmaW5lZFxuICAgICAgMTE1LFxuICAgICAgMTExLFxuICAgICAgMTE3LFxuICAgICAgMTEwLFxuICAgICAgLy8gaGFuZGxlcl90eXBlOiAnc291bidcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC8vIHJlc2VydmVkXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDgzLFxuICAgICAgMTExLFxuICAgICAgMTE3LFxuICAgICAgMTEwLFxuICAgICAgMTAwLFxuICAgICAgNzIsXG4gICAgICA5NyxcbiAgICAgIDExMCxcbiAgICAgIDEwMCxcbiAgICAgIDEwOCxcbiAgICAgIDEwMSxcbiAgICAgIDExNCxcbiAgICAgIDBcbiAgICAgIC8vIG5hbWU6ICdTb3VuZEhhbmRsZXInXG4gICAgXSk7XG4gICAgWC5IRExSX1RZUEVTID0ge1xuICAgICAgdmlkZW86IHQsXG4gICAgICBhdWRpbzogclxuICAgIH07XG4gICAgY29uc3QgbiA9IG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDAsXG4gICAgICAvLyB2ZXJzaW9uIDBcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC8vIGZsYWdzXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgLy8gZW50cnlfY291bnRcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEyLFxuICAgICAgLy8gZW50cnlfc2l6ZVxuICAgICAgMTE3LFxuICAgICAgMTE0LFxuICAgICAgMTA4LFxuICAgICAgMzIsXG4gICAgICAvLyAndXJsJyB0eXBlXG4gICAgICAwLFxuICAgICAgLy8gdmVyc2lvbiAwXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDFcbiAgICAgIC8vIGVudHJ5X2ZsYWdzXG4gICAgXSksIGkgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAwLFxuICAgICAgLy8gdmVyc2lvblxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLy8gZmxhZ3NcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDBcbiAgICAgIC8vIGVudHJ5X2NvdW50XG4gICAgXSk7XG4gICAgWC5TVFRTID0gWC5TVFNDID0gWC5TVENPID0gaSwgWC5TVFNaID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMCxcbiAgICAgIC8vIHZlcnNpb25cbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC8vIGZsYWdzXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLy8gc2FtcGxlX3NpemVcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDBcbiAgICAgIC8vIHNhbXBsZV9jb3VudFxuICAgIF0pLCBYLlZNSEQgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAwLFxuICAgICAgLy8gdmVyc2lvblxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgLy8gZmxhZ3NcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLy8gZ3JhcGhpY3Ntb2RlXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDBcbiAgICAgIC8vIG9wY29sb3JcbiAgICBdKSwgWC5TTUhEID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMCxcbiAgICAgIC8vIHZlcnNpb25cbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC8vIGZsYWdzXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC8vIGJhbGFuY2VcbiAgICAgIDAsXG4gICAgICAwXG4gICAgICAvLyByZXNlcnZlZFxuICAgIF0pLCBYLlNUU0QgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAwLFxuICAgICAgLy8gdmVyc2lvbiAwXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAvLyBmbGFnc1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMVxuICAgIF0pO1xuICAgIGNvbnN0IG8gPSBuZXcgVWludDhBcnJheShbMTA1LCAxMTUsIDExMSwgMTA5XSksIGEgPSBuZXcgVWludDhBcnJheShbOTcsIDExOCwgOTksIDQ5XSksIGwgPSBuZXcgVWludDhBcnJheShbMCwgMCwgMCwgMV0pO1xuICAgIFguRlRZUCA9IFguYm94KFgudHlwZXMuZnR5cCwgbywgbCwgbywgYSksIFguRElORiA9IFguYm94KFgudHlwZXMuZGluZiwgWC5ib3goWC50eXBlcy5kcmVmLCBuKSk7XG4gIH1cbiAgc3RhdGljIGJveChlLCAuLi50KSB7XG4gICAgbGV0IHIgPSA4LCBuID0gdC5sZW5ndGg7XG4gICAgY29uc3QgaSA9IG47XG4gICAgZm9yICg7IG4tLTsgKVxuICAgICAgciArPSB0W25dLmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgbyA9IG5ldyBVaW50OEFycmF5KHIpO1xuICAgIGZvciAob1swXSA9IHIgPj4gMjQgJiAyNTUsIG9bMV0gPSByID4+IDE2ICYgMjU1LCBvWzJdID0gciA+PiA4ICYgMjU1LCBvWzNdID0gciAmIDI1NSwgby5zZXQoZSwgNCksIG4gPSAwLCByID0gODsgbiA8IGk7IG4rKylcbiAgICAgIG8uc2V0KHRbbl0sIHIpLCByICs9IHRbbl0uYnl0ZUxlbmd0aDtcbiAgICByZXR1cm4gbztcbiAgfVxuICBzdGF0aWMgaGRscihlKSB7XG4gICAgcmV0dXJuIFguYm94KFgudHlwZXMuaGRsciwgWC5IRExSX1RZUEVTW2VdKTtcbiAgfVxuICBzdGF0aWMgbWRhdChlKSB7XG4gICAgcmV0dXJuIFguYm94KFgudHlwZXMubWRhdCwgZSk7XG4gIH1cbiAgc3RhdGljIG1kaGQoZSwgdCkge1xuICAgIHQgKj0gZTtcbiAgICBjb25zdCByID0gTWF0aC5mbG9vcih0IC8gKFNzICsgMSkpLCBuID0gTWF0aC5mbG9vcih0ICUgKFNzICsgMSkpO1xuICAgIHJldHVybiBYLmJveChYLnR5cGVzLm1kaGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDEsXG4gICAgICAvLyB2ZXJzaW9uIDFcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC8vIGZsYWdzXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMixcbiAgICAgIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAzLFxuICAgICAgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgIGUgPj4gMjQgJiAyNTUsXG4gICAgICBlID4+IDE2ICYgMjU1LFxuICAgICAgZSA+PiA4ICYgMjU1LFxuICAgICAgZSAmIDI1NSxcbiAgICAgIC8vIHRpbWVzY2FsZVxuICAgICAgciA+PiAyNCxcbiAgICAgIHIgPj4gMTYgJiAyNTUsXG4gICAgICByID4+IDggJiAyNTUsXG4gICAgICByICYgMjU1LFxuICAgICAgbiA+PiAyNCxcbiAgICAgIG4gPj4gMTYgJiAyNTUsXG4gICAgICBuID4+IDggJiAyNTUsXG4gICAgICBuICYgMjU1LFxuICAgICAgODUsXG4gICAgICAxOTYsXG4gICAgICAvLyAndW5kJyBsYW5ndWFnZSAodW5kZXRlcm1pbmVkKVxuICAgICAgMCxcbiAgICAgIDBcbiAgICBdKSk7XG4gIH1cbiAgc3RhdGljIG1kaWEoZSkge1xuICAgIHJldHVybiBYLmJveChYLnR5cGVzLm1kaWEsIFgubWRoZChlLnRpbWVzY2FsZSB8fCAwLCBlLmR1cmF0aW9uIHx8IDApLCBYLmhkbHIoZS50eXBlKSwgWC5taW5mKGUpKTtcbiAgfVxuICBzdGF0aWMgbWZoZChlKSB7XG4gICAgcmV0dXJuIFguYm94KFgudHlwZXMubWZoZCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC8vIGZsYWdzXG4gICAgICBlID4+IDI0LFxuICAgICAgZSA+PiAxNiAmIDI1NSxcbiAgICAgIGUgPj4gOCAmIDI1NSxcbiAgICAgIGUgJiAyNTVcbiAgICAgIC8vIHNlcXVlbmNlX251bWJlclxuICAgIF0pKTtcbiAgfVxuICBzdGF0aWMgbWluZihlKSB7XG4gICAgcmV0dXJuIGUudHlwZSA9PT0gXCJhdWRpb1wiID8gWC5ib3goWC50eXBlcy5taW5mLCBYLmJveChYLnR5cGVzLnNtaGQsIFguU01IRCksIFguRElORiwgWC5zdGJsKGUpKSA6IFguYm94KFgudHlwZXMubWluZiwgWC5ib3goWC50eXBlcy52bWhkLCBYLlZNSEQpLCBYLkRJTkYsIFguc3RibChlKSk7XG4gIH1cbiAgc3RhdGljIG1vb2YoZSwgdCwgcikge1xuICAgIHJldHVybiBYLmJveChYLnR5cGVzLm1vb2YsIFgubWZoZChlKSwgWC50cmFmKHIsIHQpKTtcbiAgfVxuICBzdGF0aWMgbW9vdihlKSB7XG4gICAgbGV0IHQgPSBlLmxlbmd0aDtcbiAgICBjb25zdCByID0gW107XG4gICAgZm9yICg7IHQtLTsgKVxuICAgICAgclt0XSA9IFgudHJhayhlW3RdKTtcbiAgICByZXR1cm4gWC5ib3guYXBwbHkobnVsbCwgW1gudHlwZXMubW9vdiwgWC5tdmhkKGVbMF0udGltZXNjYWxlIHx8IDAsIGVbMF0uZHVyYXRpb24gfHwgMCldLmNvbmNhdChyKS5jb25jYXQoWC5tdmV4KGUpKSk7XG4gIH1cbiAgc3RhdGljIG12ZXgoZSkge1xuICAgIGxldCB0ID0gZS5sZW5ndGg7XG4gICAgY29uc3QgciA9IFtdO1xuICAgIGZvciAoOyB0LS07IClcbiAgICAgIHJbdF0gPSBYLnRyZXgoZVt0XSk7XG4gICAgcmV0dXJuIFguYm94LmFwcGx5KG51bGwsIFtYLnR5cGVzLm12ZXgsIC4uLnJdKTtcbiAgfVxuICBzdGF0aWMgbXZoZChlLCB0KSB7XG4gICAgdCAqPSBlO1xuICAgIGNvbnN0IHIgPSBNYXRoLmZsb29yKHQgLyAoU3MgKyAxKSksIG4gPSBNYXRoLmZsb29yKHQgJSAoU3MgKyAxKSksIGkgPSBuZXcgVWludDhBcnJheShbXG4gICAgICAxLFxuICAgICAgLy8gdmVyc2lvbiAxXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAvLyBmbGFnc1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDIsXG4gICAgICAvLyBjcmVhdGlvbl90aW1lXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMyxcbiAgICAgIC8vIG1vZGlmaWNhdGlvbl90aW1lXG4gICAgICBlID4+IDI0ICYgMjU1LFxuICAgICAgZSA+PiAxNiAmIDI1NSxcbiAgICAgIGUgPj4gOCAmIDI1NSxcbiAgICAgIGUgJiAyNTUsXG4gICAgICAvLyB0aW1lc2NhbGVcbiAgICAgIHIgPj4gMjQsXG4gICAgICByID4+IDE2ICYgMjU1LFxuICAgICAgciA+PiA4ICYgMjU1LFxuICAgICAgciAmIDI1NSxcbiAgICAgIG4gPj4gMjQsXG4gICAgICBuID4+IDE2ICYgMjU1LFxuICAgICAgbiA+PiA4ICYgMjU1LFxuICAgICAgbiAmIDI1NSxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAvLyAxLjAgcmF0ZVxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAvLyAxLjAgdm9sdW1lXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC8vIHJlc2VydmVkXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICA2NCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC8vIHRyYW5zZm9ybWF0aW9uOiB1bml0eSBtYXRyaXhcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC8vIHByZV9kZWZpbmVkXG4gICAgICAyNTUsXG4gICAgICAyNTUsXG4gICAgICAyNTUsXG4gICAgICAyNTVcbiAgICAgIC8vIG5leHRfdHJhY2tfSURcbiAgICBdKTtcbiAgICByZXR1cm4gWC5ib3goWC50eXBlcy5tdmhkLCBpKTtcbiAgfVxuICBzdGF0aWMgc2R0cChlKSB7XG4gICAgY29uc3QgdCA9IGUuc2FtcGxlcyB8fCBbXSwgciA9IG5ldyBVaW50OEFycmF5KDQgKyB0Lmxlbmd0aCk7XG4gICAgbGV0IG4sIGk7XG4gICAgZm9yIChuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspXG4gICAgICBpID0gdFtuXS5mbGFncywgcltuICsgNF0gPSBpLmRlcGVuZHNPbiA8PCA0IHwgaS5pc0RlcGVuZGVkT24gPDwgMiB8IGkuaGFzUmVkdW5kYW5jeTtcbiAgICByZXR1cm4gWC5ib3goWC50eXBlcy5zZHRwLCByKTtcbiAgfVxuICBzdGF0aWMgc3RibChlKSB7XG4gICAgcmV0dXJuIFguYm94KFgudHlwZXMuc3RibCwgWC5zdHNkKGUpLCBYLmJveChYLnR5cGVzLnN0dHMsIFguU1RUUyksIFguYm94KFgudHlwZXMuc3RzYywgWC5TVFNDKSwgWC5ib3goWC50eXBlcy5zdHN6LCBYLlNUU1opLCBYLmJveChYLnR5cGVzLnN0Y28sIFguU1RDTykpO1xuICB9XG4gIHN0YXRpYyBhdmMxKGUpIHtcbiAgICBsZXQgdCA9IFtdLCByID0gW10sIG4sIGksIG87XG4gICAgZm9yIChuID0gMDsgbiA8IGUuc3BzLmxlbmd0aDsgbisrKVxuICAgICAgaSA9IGUuc3BzW25dLCBvID0gaS5ieXRlTGVuZ3RoLCB0LnB1c2gobyA+Pj4gOCAmIDI1NSksIHQucHVzaChvICYgMjU1KSwgdCA9IHQuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGkpKTtcbiAgICBmb3IgKG4gPSAwOyBuIDwgZS5wcHMubGVuZ3RoOyBuKyspXG4gICAgICBpID0gZS5wcHNbbl0sIG8gPSBpLmJ5dGVMZW5ndGgsIHIucHVzaChvID4+PiA4ICYgMjU1KSwgci5wdXNoKG8gJiAyNTUpLCByID0gci5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoaSkpO1xuICAgIGNvbnN0IGEgPSBYLmJveChYLnR5cGVzLmF2Y0MsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDEsXG4gICAgICAvLyB2ZXJzaW9uXG4gICAgICB0WzNdLFxuICAgICAgLy8gcHJvZmlsZVxuICAgICAgdFs0XSxcbiAgICAgIC8vIHByb2ZpbGUgY29tcGF0XG4gICAgICB0WzVdLFxuICAgICAgLy8gbGV2ZWxcbiAgICAgIDI1NSxcbiAgICAgIC8vIGxlbmd0aFNpemVNaW51c09uZSwgaGFyZC1jb2RlZCB0byA0IGJ5dGVzXG4gICAgICAyMjQgfCBlLnNwcy5sZW5ndGhcbiAgICAgIC8vIDNiaXQgcmVzZXJ2ZWQgKDExMSkgKyBudW1PZlNlcXVlbmNlUGFyYW1ldGVyU2V0c1xuICAgIF0uY29uY2F0KHQpLmNvbmNhdChbXG4gICAgICBlLnBwcy5sZW5ndGhcbiAgICAgIC8vIG51bU9mUGljdHVyZVBhcmFtZXRlclNldHNcbiAgICBdKS5jb25jYXQocikpKSwgbCA9IGUud2lkdGgsIGMgPSBlLmhlaWdodCwgdSA9IGUucGl4ZWxSYXRpb1swXSwgZCA9IGUucGl4ZWxSYXRpb1sxXTtcbiAgICByZXR1cm4gWC5ib3goXG4gICAgICBYLnR5cGVzLmF2YzEsXG4gICAgICBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIC8vIHJlc2VydmVkXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIC8vIHJlc2VydmVkXG4gICAgICAgIDAsXG4gICAgICAgIDEsXG4gICAgICAgIC8vIGRhdGFfcmVmZXJlbmNlX2luZGV4XG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIC8vIHByZV9kZWZpbmVkXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIC8vIHJlc2VydmVkXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIC8vIHByZV9kZWZpbmVkXG4gICAgICAgIGwgPj4gOCAmIDI1NSxcbiAgICAgICAgbCAmIDI1NSxcbiAgICAgICAgLy8gd2lkdGhcbiAgICAgICAgYyA+PiA4ICYgMjU1LFxuICAgICAgICBjICYgMjU1LFxuICAgICAgICAvLyBoZWlnaHRcbiAgICAgICAgMCxcbiAgICAgICAgNzIsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIC8vIGhvcml6cmVzb2x1dGlvblxuICAgICAgICAwLFxuICAgICAgICA3MixcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgLy8gdmVydHJlc29sdXRpb25cbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMCxcbiAgICAgICAgMSxcbiAgICAgICAgLy8gZnJhbWVfY291bnRcbiAgICAgICAgMTgsXG4gICAgICAgIDEwMCxcbiAgICAgICAgOTcsXG4gICAgICAgIDEwNSxcbiAgICAgICAgMTA4LFxuICAgICAgICAvLyBkYWlseW1vdGlvbi9obHMuanNcbiAgICAgICAgMTIxLFxuICAgICAgICAxMDksXG4gICAgICAgIDExMSxcbiAgICAgICAgMTE2LFxuICAgICAgICAxMDUsXG4gICAgICAgIDExMSxcbiAgICAgICAgMTEwLFxuICAgICAgICA0NyxcbiAgICAgICAgMTA0LFxuICAgICAgICAxMDgsXG4gICAgICAgIDExNSxcbiAgICAgICAgNDYsXG4gICAgICAgIDEwNixcbiAgICAgICAgMTE1LFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAvLyBjb21wcmVzc29ybmFtZVxuICAgICAgICAwLFxuICAgICAgICAyNCxcbiAgICAgICAgLy8gZGVwdGggPSAyNFxuICAgICAgICAxNyxcbiAgICAgICAgMTdcbiAgICAgIF0pLFxuICAgICAgLy8gcHJlX2RlZmluZWQgPSAtMVxuICAgICAgYSxcbiAgICAgIFguYm94KFgudHlwZXMuYnRydCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAwLFxuICAgICAgICAyOCxcbiAgICAgICAgMTU2LFxuICAgICAgICAxMjgsXG4gICAgICAgIC8vIGJ1ZmZlclNpemVEQlxuICAgICAgICAwLFxuICAgICAgICA0NSxcbiAgICAgICAgMTk4LFxuICAgICAgICAxOTIsXG4gICAgICAgIC8vIG1heEJpdHJhdGVcbiAgICAgICAgMCxcbiAgICAgICAgNDUsXG4gICAgICAgIDE5OCxcbiAgICAgICAgMTkyXG4gICAgICBdKSksXG4gICAgICAvLyBhdmdCaXRyYXRlXG4gICAgICBYLmJveChYLnR5cGVzLnBhc3AsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgdSA+PiAyNCxcbiAgICAgICAgLy8gaFNwYWNpbmdcbiAgICAgICAgdSA+PiAxNiAmIDI1NSxcbiAgICAgICAgdSA+PiA4ICYgMjU1LFxuICAgICAgICB1ICYgMjU1LFxuICAgICAgICBkID4+IDI0LFxuICAgICAgICAvLyB2U3BhY2luZ1xuICAgICAgICBkID4+IDE2ICYgMjU1LFxuICAgICAgICBkID4+IDggJiAyNTUsXG4gICAgICAgIGQgJiAyNTVcbiAgICAgIF0pKVxuICAgICk7XG4gIH1cbiAgc3RhdGljIGVzZHMoZSkge1xuICAgIGNvbnN0IHQgPSBlLmNvbmZpZztcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgMCxcbiAgICAgIC8vIHZlcnNpb24gMFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLy8gZmxhZ3NcbiAgICAgIDMsXG4gICAgICAvLyBkZXNjcmlwdG9yX3R5cGVcbiAgICAgIDI1LFxuICAgICAgLy8gbGVuZ3RoXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIC8vIGVzX2lkXG4gICAgICAwLFxuICAgICAgLy8gc3RyZWFtX3ByaW9yaXR5XG4gICAgICA0LFxuICAgICAgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgICAxNyxcbiAgICAgIC8vIGxlbmd0aFxuICAgICAgNjQsXG4gICAgICAvLyBjb2RlYyA6IG1wZWc0X2F1ZGlvXG4gICAgICAyMSxcbiAgICAgIC8vIHN0cmVhbV90eXBlXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAvLyBidWZmZXJfc2l6ZVxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC8vIG1heEJpdHJhdGVcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAvLyBhdmdCaXRyYXRlXG4gICAgICA1LFxuICAgICAgLy8gZGVzY3JpcHRvcl90eXBlXG4gICAgICAyLFxuICAgICAgLy8gbGVuZ3RoXG4gICAgICAuLi50LFxuICAgICAgNixcbiAgICAgIDEsXG4gICAgICAyXG4gICAgICAvLyBHQVNwZWNpZmljQ29uZmlnKSk7IC8vIGxlbmd0aCArIGF1ZGlvIGNvbmZpZyBkZXNjcmlwdG9yXG4gICAgXSk7XG4gIH1cbiAgc3RhdGljIGF1ZGlvU3RzZChlKSB7XG4gICAgY29uc3QgdCA9IGUuc2FtcGxlcmF0ZSB8fCAwO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShbXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAvLyByZXNlcnZlZFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDAsXG4gICAgICBlLmNoYW5uZWxDb3VudCB8fCAwLFxuICAgICAgLy8gY2hhbm5lbGNvdW50XG4gICAgICAwLFxuICAgICAgMTYsXG4gICAgICAvLyBzYW1wbGVTaXplOjE2Yml0c1xuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC8vIHJlc2VydmVkMlxuICAgICAgdCA+PiA4ICYgMjU1LFxuICAgICAgdCAmIDI1NSxcbiAgICAgIC8vXG4gICAgICAwLFxuICAgICAgMFxuICAgIF0pO1xuICB9XG4gIHN0YXRpYyBtcDRhKGUpIHtcbiAgICByZXR1cm4gWC5ib3goWC50eXBlcy5tcDRhLCBYLmF1ZGlvU3RzZChlKSwgWC5ib3goWC50eXBlcy5lc2RzLCBYLmVzZHMoZSkpKTtcbiAgfVxuICBzdGF0aWMgbXAzKGUpIHtcbiAgICByZXR1cm4gWC5ib3goWC50eXBlc1tcIi5tcDNcIl0sIFguYXVkaW9TdHNkKGUpKTtcbiAgfVxuICBzdGF0aWMgYWMzKGUpIHtcbiAgICByZXR1cm4gWC5ib3goWC50eXBlc1tcImFjLTNcIl0sIFguYXVkaW9TdHNkKGUpLCBYLmJveChYLnR5cGVzLmRhYzMsIGUuY29uZmlnKSk7XG4gIH1cbiAgc3RhdGljIHN0c2QoZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNlZ21lbnRDb2RlYzogdFxuICAgIH0gPSBlO1xuICAgIGlmIChlLnR5cGUgPT09IFwiYXVkaW9cIikge1xuICAgICAgaWYgKHQgPT09IFwiYWFjXCIpXG4gICAgICAgIHJldHVybiBYLmJveChYLnR5cGVzLnN0c2QsIFguU1RTRCwgWC5tcDRhKGUpKTtcbiAgICAgIGlmICh0ID09PSBcImFjM1wiICYmIGUuY29uZmlnKVxuICAgICAgICByZXR1cm4gWC5ib3goWC50eXBlcy5zdHNkLCBYLlNUU0QsIFguYWMzKGUpKTtcbiAgICAgIGlmICh0ID09PSBcIm1wM1wiICYmIGUuY29kZWMgPT09IFwibXAzXCIpXG4gICAgICAgIHJldHVybiBYLmJveChYLnR5cGVzLnN0c2QsIFguU1RTRCwgWC5tcDMoZSkpO1xuICAgIH0gZWxzZSBpZiAoZS5wcHMgJiYgZS5zcHMpIHtcbiAgICAgIGlmICh0ID09PSBcImF2Y1wiKVxuICAgICAgICByZXR1cm4gWC5ib3goWC50eXBlcy5zdHNkLCBYLlNUU0QsIFguYXZjMShlKSk7XG4gICAgICBpZiAodCA9PT0gXCJoZXZjXCIgJiYgZS52cHMpXG4gICAgICAgIHJldHVybiBYLmJveChYLnR5cGVzLnN0c2QsIFguU1RTRCwgWC5odmMxKGUpKTtcbiAgICB9IGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihcInZpZGVvIHRyYWNrIG1pc3NpbmcgcHBzIG9yIHNwc1wiKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHVuc3VwcG9ydGVkICR7ZS50eXBlfSBzZWdtZW50IGNvZGVjICgke3R9LyR7ZS5jb2RlY30pYCk7XG4gIH1cbiAgc3RhdGljIHRraGQoZSkge1xuICAgIGNvbnN0IHQgPSBlLmlkLCByID0gKGUuZHVyYXRpb24gfHwgMCkgKiAoZS50aW1lc2NhbGUgfHwgMCksIG4gPSBlLndpZHRoIHx8IDAsIGkgPSBlLmhlaWdodCB8fCAwLCBvID0gTWF0aC5mbG9vcihyIC8gKFNzICsgMSkpLCBhID0gTWF0aC5mbG9vcihyICUgKFNzICsgMSkpO1xuICAgIHJldHVybiBYLmJveChYLnR5cGVzLnRraGQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgIDEsXG4gICAgICAvLyB2ZXJzaW9uIDFcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgNyxcbiAgICAgIC8vIGZsYWdzXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMixcbiAgICAgIC8vIGNyZWF0aW9uX3RpbWVcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAzLFxuICAgICAgLy8gbW9kaWZpY2F0aW9uX3RpbWVcbiAgICAgIHQgPj4gMjQgJiAyNTUsXG4gICAgICB0ID4+IDE2ICYgMjU1LFxuICAgICAgdCA+PiA4ICYgMjU1LFxuICAgICAgdCAmIDI1NSxcbiAgICAgIC8vIHRyYWNrX0lEXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIG8gPj4gMjQsXG4gICAgICBvID4+IDE2ICYgMjU1LFxuICAgICAgbyA+PiA4ICYgMjU1LFxuICAgICAgbyAmIDI1NSxcbiAgICAgIGEgPj4gMjQsXG4gICAgICBhID4+IDE2ICYgMjU1LFxuICAgICAgYSA+PiA4ICYgMjU1LFxuICAgICAgYSAmIDI1NSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLy8gbGF5ZXJcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLy8gYWx0ZXJuYXRlX2dyb3VwXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC8vIG5vbi1hdWRpbyB0cmFjayB2b2x1bWVcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgIDAsXG4gICAgICAxLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMSxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgNjQsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAvLyB0cmFuc2Zvcm1hdGlvbjogdW5pdHkgbWF0cml4XG4gICAgICBuID4+IDggJiAyNTUsXG4gICAgICBuICYgMjU1LFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAvLyB3aWR0aFxuICAgICAgaSA+PiA4ICYgMjU1LFxuICAgICAgaSAmIDI1NSxcbiAgICAgIDAsXG4gICAgICAwXG4gICAgICAvLyBoZWlnaHRcbiAgICBdKSk7XG4gIH1cbiAgc3RhdGljIHRyYWYoZSwgdCkge1xuICAgIGNvbnN0IHIgPSBYLnNkdHAoZSksIG4gPSBlLmlkLCBpID0gTWF0aC5mbG9vcih0IC8gKFNzICsgMSkpLCBvID0gTWF0aC5mbG9vcih0ICUgKFNzICsgMSkpO1xuICAgIHJldHVybiBYLmJveChcbiAgICAgIFgudHlwZXMudHJhZixcbiAgICAgIFguYm94KFgudHlwZXMudGZoZCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICAwLFxuICAgICAgICAvLyB2ZXJzaW9uIDBcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgLy8gZmxhZ3NcbiAgICAgICAgbiA+PiAyNCxcbiAgICAgICAgbiA+PiAxNiAmIDI1NSxcbiAgICAgICAgbiA+PiA4ICYgMjU1LFxuICAgICAgICBuICYgMjU1XG4gICAgICAgIC8vIHRyYWNrX0lEXG4gICAgICBdKSksXG4gICAgICBYLmJveChYLnR5cGVzLnRmZHQsIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMSxcbiAgICAgICAgLy8gdmVyc2lvbiAxXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIC8vIGZsYWdzXG4gICAgICAgIGkgPj4gMjQsXG4gICAgICAgIGkgPj4gMTYgJiAyNTUsXG4gICAgICAgIGkgPj4gOCAmIDI1NSxcbiAgICAgICAgaSAmIDI1NSxcbiAgICAgICAgbyA+PiAyNCxcbiAgICAgICAgbyA+PiAxNiAmIDI1NSxcbiAgICAgICAgbyA+PiA4ICYgMjU1LFxuICAgICAgICBvICYgMjU1XG4gICAgICBdKSksXG4gICAgICBYLnRydW4oZSwgci5sZW5ndGggKyAxNiArIC8vIHRmaGRcbiAgICAgIDIwICsgLy8gdGZkdFxuICAgICAgOCArIC8vIHRyYWYgaGVhZGVyXG4gICAgICAxNiArIC8vIG1maGRcbiAgICAgIDggKyAvLyBtb29mIGhlYWRlclxuICAgICAgOCksXG4gICAgICAvLyBtZGF0IGhlYWRlclxuICAgICAgclxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhY2sgYm94LlxuICAgKiBAcGFyYW0gdHJhY2sgYSB0cmFjayBkZWZpbml0aW9uXG4gICAqL1xuICBzdGF0aWMgdHJhayhlKSB7XG4gICAgcmV0dXJuIGUuZHVyYXRpb24gPSBlLmR1cmF0aW9uIHx8IDQyOTQ5NjcyOTUsIFguYm94KFgudHlwZXMudHJhaywgWC50a2hkKGUpLCBYLm1kaWEoZSkpO1xuICB9XG4gIHN0YXRpYyB0cmV4KGUpIHtcbiAgICBjb25zdCB0ID0gZS5pZDtcbiAgICByZXR1cm4gWC5ib3goWC50eXBlcy50cmV4LCBuZXcgVWludDhBcnJheShbXG4gICAgICAwLFxuICAgICAgLy8gdmVyc2lvbiAwXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAvLyBmbGFnc1xuICAgICAgdCA+PiAyNCxcbiAgICAgIHQgPj4gMTYgJiAyNTUsXG4gICAgICB0ID4+IDggJiAyNTUsXG4gICAgICB0ICYgMjU1LFxuICAgICAgLy8gdHJhY2tfSURcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAvLyBkZWZhdWx0X3NhbXBsZV9kZXNjcmlwdGlvbl9pbmRleFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIC8vIGRlZmF1bHRfc2FtcGxlX2R1cmF0aW9uXG4gICAgICAwLFxuICAgICAgMCxcbiAgICAgIDAsXG4gICAgICAwLFxuICAgICAgLy8gZGVmYXVsdF9zYW1wbGVfc2l6ZVxuICAgICAgMCxcbiAgICAgIDEsXG4gICAgICAwLFxuICAgICAgMVxuICAgICAgLy8gZGVmYXVsdF9zYW1wbGVfZmxhZ3NcbiAgICBdKSk7XG4gIH1cbiAgc3RhdGljIHRydW4oZSwgdCkge1xuICAgIGNvbnN0IHIgPSBlLnNhbXBsZXMgfHwgW10sIG4gPSByLmxlbmd0aCwgaSA9IDEyICsgMTYgKiBuLCBvID0gbmV3IFVpbnQ4QXJyYXkoaSk7XG4gICAgbGV0IGEsIGwsIGMsIHUsIGQsIGg7XG4gICAgZm9yICh0ICs9IDggKyBpLCBvLnNldChbXG4gICAgICBlLnR5cGUgPT09IFwidmlkZW9cIiA/IDEgOiAwLFxuICAgICAgLy8gdmVyc2lvbiAxIGZvciB2aWRlbyB3aXRoIHNpZ25lZC1pbnQgc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XG4gICAgICAwLFxuICAgICAgMTUsXG4gICAgICAxLFxuICAgICAgLy8gZmxhZ3NcbiAgICAgIG4gPj4+IDI0ICYgMjU1LFxuICAgICAgbiA+Pj4gMTYgJiAyNTUsXG4gICAgICBuID4+PiA4ICYgMjU1LFxuICAgICAgbiAmIDI1NSxcbiAgICAgIC8vIHNhbXBsZV9jb3VudFxuICAgICAgdCA+Pj4gMjQgJiAyNTUsXG4gICAgICB0ID4+PiAxNiAmIDI1NSxcbiAgICAgIHQgPj4+IDggJiAyNTUsXG4gICAgICB0ICYgMjU1XG4gICAgICAvLyBkYXRhX29mZnNldFxuICAgIF0sIDApLCBhID0gMDsgYSA8IG47IGErKylcbiAgICAgIGwgPSByW2FdLCBjID0gbC5kdXJhdGlvbiwgdSA9IGwuc2l6ZSwgZCA9IGwuZmxhZ3MsIGggPSBsLmN0cywgby5zZXQoW1xuICAgICAgICBjID4+PiAyNCAmIDI1NSxcbiAgICAgICAgYyA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIGMgPj4+IDggJiAyNTUsXG4gICAgICAgIGMgJiAyNTUsXG4gICAgICAgIC8vIHNhbXBsZV9kdXJhdGlvblxuICAgICAgICB1ID4+PiAyNCAmIDI1NSxcbiAgICAgICAgdSA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIHUgPj4+IDggJiAyNTUsXG4gICAgICAgIHUgJiAyNTUsXG4gICAgICAgIC8vIHNhbXBsZV9zaXplXG4gICAgICAgIGQuaXNMZWFkaW5nIDw8IDIgfCBkLmRlcGVuZHNPbixcbiAgICAgICAgZC5pc0RlcGVuZGVkT24gPDwgNiB8IGQuaGFzUmVkdW5kYW5jeSA8PCA0IHwgZC5wYWRkaW5nVmFsdWUgPDwgMSB8IGQuaXNOb25TeW5jLFxuICAgICAgICBkLmRlZ3JhZFByaW8gJiA2MTQ0MCxcbiAgICAgICAgZC5kZWdyYWRQcmlvICYgMTUsXG4gICAgICAgIC8vIHNhbXBsZV9mbGFnc1xuICAgICAgICBoID4+PiAyNCAmIDI1NSxcbiAgICAgICAgaCA+Pj4gMTYgJiAyNTUsXG4gICAgICAgIGggPj4+IDggJiAyNTUsXG4gICAgICAgIGggJiAyNTVcbiAgICAgICAgLy8gc2FtcGxlX2NvbXBvc2l0aW9uX3RpbWVfb2Zmc2V0XG4gICAgICBdLCAxMiArIDE2ICogYSk7XG4gICAgcmV0dXJuIFguYm94KFgudHlwZXMudHJ1biwgbyk7XG4gIH1cbiAgc3RhdGljIGluaXRTZWdtZW50KGUpIHtcbiAgICBYLnR5cGVzIHx8IFguaW5pdCgpO1xuICAgIGNvbnN0IHQgPSBYLm1vb3YoZSk7XG4gICAgcmV0dXJuIF9yKFguRlRZUCwgdCk7XG4gIH1cbiAgc3RhdGljIGh2YzEoZSkge1xuICAgIGNvbnN0IHQgPSBlLnBhcmFtcywgciA9IFtlLnZwcywgZS5zcHMsIGUucHBzXSwgbiA9IDQsIGkgPSBuZXcgVWludDhBcnJheShbMSwgdC5nZW5lcmFsX3Byb2ZpbGVfc3BhY2UgPDwgNiB8ICh0LmdlbmVyYWxfdGllcl9mbGFnID8gMzIgOiAwKSB8IHQuZ2VuZXJhbF9wcm9maWxlX2lkYywgdC5nZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc1swXSwgdC5nZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc1sxXSwgdC5nZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc1syXSwgdC5nZW5lcmFsX3Byb2ZpbGVfY29tcGF0aWJpbGl0eV9mbGFnc1szXSwgdC5nZW5lcmFsX2NvbnN0cmFpbnRfaW5kaWNhdG9yX2ZsYWdzWzBdLCB0LmdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NbMV0sIHQuZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc1syXSwgdC5nZW5lcmFsX2NvbnN0cmFpbnRfaW5kaWNhdG9yX2ZsYWdzWzNdLCB0LmdlbmVyYWxfY29uc3RyYWludF9pbmRpY2F0b3JfZmxhZ3NbNF0sIHQuZ2VuZXJhbF9jb25zdHJhaW50X2luZGljYXRvcl9mbGFnc1s1XSwgdC5nZW5lcmFsX2xldmVsX2lkYywgMjQwIHwgdC5taW5fc3BhdGlhbF9zZWdtZW50YXRpb25faWRjID4+IDgsIDI1NSAmIHQubWluX3NwYXRpYWxfc2VnbWVudGF0aW9uX2lkYywgMjUyIHwgdC5wYXJhbGxlbGlzbVR5cGUsIDI1MiB8IHQuY2hyb21hX2Zvcm1hdF9pZGMsIDI0OCB8IHQuYml0X2RlcHRoX2x1bWFfbWludXM4LCAyNDggfCB0LmJpdF9kZXB0aF9jaHJvbWFfbWludXM4LCAwLCBwYXJzZUludCh0LmZyYW1lX3JhdGUuZnBzKSwgbiAtIDEgfCB0LnRlbXBvcmFsX2lkX25lc3RlZCA8PCAyIHwgdC5udW1fdGVtcG9yYWxfbGF5ZXJzIDw8IDMgfCAodC5mcmFtZV9yYXRlLmZpeGVkID8gNjQgOiAwKSwgci5sZW5ndGhdKTtcbiAgICBsZXQgbyA9IGkubGVuZ3RoO1xuICAgIGZvciAobGV0IHAgPSAwOyBwIDwgci5sZW5ndGg7IHAgKz0gMSkge1xuICAgICAgbyArPSAzO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCByW3BdLmxlbmd0aDsgeSArPSAxKVxuICAgICAgICBvICs9IDIgKyByW3BdW3ldLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgYSA9IG5ldyBVaW50OEFycmF5KG8pO1xuICAgIGEuc2V0KGksIDApLCBvID0gaS5sZW5ndGg7XG4gICAgY29uc3QgbCA9IHIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKGxldCBwID0gMDsgcCA8IHIubGVuZ3RoOyBwICs9IDEpIHtcbiAgICAgIGEuc2V0KG5ldyBVaW50OEFycmF5KFszMiArIHAgfCAocCA9PT0gbCA/IDEyOCA6IDApLCAwLCByW3BdLmxlbmd0aF0pLCBvKSwgbyArPSAzO1xuICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCByW3BdLmxlbmd0aDsgeSArPSAxKVxuICAgICAgICBhLnNldChuZXcgVWludDhBcnJheShbcltwXVt5XS5sZW5ndGggPj4gOCwgcltwXVt5XS5sZW5ndGggJiAyNTVdKSwgbyksIG8gKz0gMiwgYS5zZXQocltwXVt5XSwgbyksIG8gKz0gcltwXVt5XS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IGMgPSBYLmJveChYLnR5cGVzLmh2Y0MsIGEpLCB1ID0gZS53aWR0aCwgZCA9IGUuaGVpZ2h0LCBoID0gZS5waXhlbFJhdGlvWzBdLCBmID0gZS5waXhlbFJhdGlvWzFdO1xuICAgIHJldHVybiBYLmJveChcbiAgICAgIFgudHlwZXMuaHZjMSxcbiAgICAgIG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMCxcbiAgICAgICAgMSxcbiAgICAgICAgLy8gZGF0YV9yZWZlcmVuY2VfaW5kZXhcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgLy8gcHJlX2RlZmluZWRcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgLy8gcmVzZXJ2ZWRcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgLy8gcHJlX2RlZmluZWRcbiAgICAgICAgdSA+PiA4ICYgMjU1LFxuICAgICAgICB1ICYgMjU1LFxuICAgICAgICAvLyB3aWR0aFxuICAgICAgICBkID4+IDggJiAyNTUsXG4gICAgICAgIGQgJiAyNTUsXG4gICAgICAgIC8vIGhlaWdodFxuICAgICAgICAwLFxuICAgICAgICA3MixcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgLy8gaG9yaXpyZXNvbHV0aW9uXG4gICAgICAgIDAsXG4gICAgICAgIDcyLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAvLyB2ZXJ0cmVzb2x1dGlvblxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAvLyByZXNlcnZlZFxuICAgICAgICAwLFxuICAgICAgICAxLFxuICAgICAgICAvLyBmcmFtZV9jb3VudFxuICAgICAgICAxOCxcbiAgICAgICAgMTAwLFxuICAgICAgICA5NyxcbiAgICAgICAgMTA1LFxuICAgICAgICAxMDgsXG4gICAgICAgIC8vIGRhaWx5bW90aW9uL2hscy5qc1xuICAgICAgICAxMjEsXG4gICAgICAgIDEwOSxcbiAgICAgICAgMTExLFxuICAgICAgICAxMTYsXG4gICAgICAgIDEwNSxcbiAgICAgICAgMTExLFxuICAgICAgICAxMTAsXG4gICAgICAgIDQ3LFxuICAgICAgICAxMDQsXG4gICAgICAgIDEwOCxcbiAgICAgICAgMTE1LFxuICAgICAgICA0NixcbiAgICAgICAgMTA2LFxuICAgICAgICAxMTUsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIC8vIGNvbXByZXNzb3JuYW1lXG4gICAgICAgIDAsXG4gICAgICAgIDI0LFxuICAgICAgICAvLyBkZXB0aCA9IDI0XG4gICAgICAgIDE3LFxuICAgICAgICAxN1xuICAgICAgXSksXG4gICAgICAvLyBwcmVfZGVmaW5lZCA9IC0xXG4gICAgICBjLFxuICAgICAgWC5ib3goWC50eXBlcy5idHJ0LCBuZXcgVWludDhBcnJheShbXG4gICAgICAgIDAsXG4gICAgICAgIDI4LFxuICAgICAgICAxNTYsXG4gICAgICAgIDEyOCxcbiAgICAgICAgLy8gYnVmZmVyU2l6ZURCXG4gICAgICAgIDAsXG4gICAgICAgIDQ1LFxuICAgICAgICAxOTgsXG4gICAgICAgIDE5MixcbiAgICAgICAgLy8gbWF4Qml0cmF0ZVxuICAgICAgICAwLFxuICAgICAgICA0NSxcbiAgICAgICAgMTk4LFxuICAgICAgICAxOTJcbiAgICAgIF0pKSxcbiAgICAgIC8vIGF2Z0JpdHJhdGVcbiAgICAgIFguYm94KFgudHlwZXMucGFzcCwgbmV3IFVpbnQ4QXJyYXkoW1xuICAgICAgICBoID4+IDI0LFxuICAgICAgICAvLyBoU3BhY2luZ1xuICAgICAgICBoID4+IDE2ICYgMjU1LFxuICAgICAgICBoID4+IDggJiAyNTUsXG4gICAgICAgIGggJiAyNTUsXG4gICAgICAgIGYgPj4gMjQsXG4gICAgICAgIC8vIHZTcGFjaW5nXG4gICAgICAgIGYgPj4gMTYgJiAyNTUsXG4gICAgICAgIGYgPj4gOCAmIDI1NSxcbiAgICAgICAgZiAmIDI1NVxuICAgICAgXSkpXG4gICAgKTtcbiAgfVxufVxuWC50eXBlcyA9IHZvaWQgMDtcblguSERMUl9UWVBFUyA9IHZvaWQgMDtcblguU1RUUyA9IHZvaWQgMDtcblguU1RTQyA9IHZvaWQgMDtcblguU1RDTyA9IHZvaWQgMDtcblguU1RTWiA9IHZvaWQgMDtcblguVk1IRCA9IHZvaWQgMDtcblguU01IRCA9IHZvaWQgMDtcblguU1RTRCA9IHZvaWQgMDtcblguRlRZUCA9IHZvaWQgMDtcblguRElORiA9IHZvaWQgMDtcbmNvbnN0IFNwID0gOWU0O1xuZnVuY3Rpb24gQ3UocywgZSwgdCA9IDEsIHIgPSAhMSkge1xuICBjb25zdCBuID0gcyAqIGUgKiB0O1xuICByZXR1cm4gciA/IE1hdGgucm91bmQobikgOiBuO1xufVxuZnVuY3Rpb24gcVQocywgZSwgdCA9IDEsIHIgPSAhMSkge1xuICByZXR1cm4gQ3UocywgZSwgMSAvIHQsIHIpO1xufVxuZnVuY3Rpb24gcW4ocywgZSA9ICExKSB7XG4gIHJldHVybiBDdShzLCAxZTMsIDEgLyBTcCwgZSk7XG59XG5mdW5jdGlvbiBXVChzLCBlID0gMSkge1xuICByZXR1cm4gQ3UocywgU3AsIDEgLyBlKTtcbn1cbmNvbnN0IHpUID0gMTAgKiAxZTMsIFlUID0gMTAyNCwgWlQgPSAxMTUyLCBYVCA9IDE1MzY7XG5sZXQgcG4gPSBudWxsLCBFbCA9IG51bGw7XG5mdW5jdGlvbiBVaChzLCBlLCB0LCByKSB7XG4gIHJldHVybiB7XG4gICAgZHVyYXRpb246IGUsXG4gICAgc2l6ZTogdCxcbiAgICBjdHM6IHIsXG4gICAgZmxhZ3M6IHtcbiAgICAgIGlzTGVhZGluZzogMCxcbiAgICAgIGlzRGVwZW5kZWRPbjogMCxcbiAgICAgIGhhc1JlZHVuZGFuY3k6IDAsXG4gICAgICBkZWdyYWRQcmlvOiAwLFxuICAgICAgZGVwZW5kc09uOiBzID8gMiA6IDEsXG4gICAgICBpc05vblN5bmM6IHMgPyAwIDogMVxuICAgIH1cbiAgfTtcbn1cbmNsYXNzIG1vIGV4dGVuZHMgTHIge1xuICBjb25zdHJ1Y3RvcihlLCB0LCByLCBuKSB7XG4gICAgaWYgKHN1cGVyKFwibXA0LXJlbXV4ZXJcIiwgbiksIHRoaXMub2JzZXJ2ZXIgPSB2b2lkIDAsIHRoaXMuY29uZmlnID0gdm9pZCAwLCB0aGlzLnR5cGVTdXBwb3J0ZWQgPSB2b2lkIDAsIHRoaXMuSVNHZW5lcmF0ZWQgPSAhMSwgdGhpcy5faW5pdFBUUyA9IG51bGwsIHRoaXMuX2luaXREVFMgPSBudWxsLCB0aGlzLm5leHRWaWRlb1RzID0gbnVsbCwgdGhpcy5uZXh0QXVkaW9UcyA9IG51bGwsIHRoaXMudmlkZW9TYW1wbGVEdXJhdGlvbiA9IG51bGwsIHRoaXMuaXNBdWRpb0NvbnRpZ3VvdXMgPSAhMSwgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9ICExLCB0aGlzLnZpZGVvVHJhY2tDb25maWcgPSB2b2lkIDAsIHRoaXMub2JzZXJ2ZXIgPSBlLCB0aGlzLmNvbmZpZyA9IHQsIHRoaXMudHlwZVN1cHBvcnRlZCA9IHIsIHRoaXMuSVNHZW5lcmF0ZWQgPSAhMSwgcG4gPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG8gPSAobmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBcIlwiKS5tYXRjaCgvQ2hyb21lXFwvKFxcZCspL2kpO1xuICAgICAgcG4gPSBvID8gcGFyc2VJbnQob1sxXSkgOiAwO1xuICAgIH1cbiAgICBpZiAoRWwgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IGkgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKykvaSk7XG4gICAgICBFbCA9IGkgPyBwYXJzZUludChpWzFdKSA6IDA7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jb25maWcgPSB0aGlzLnZpZGVvVHJhY2tDb25maWcgPSB0aGlzLl9pbml0UFRTID0gdGhpcy5faW5pdERUUyA9IG51bGw7XG4gIH1cbiAgcmVzZXRUaW1lU3RhbXAoZSkge1xuICAgIHRoaXMubG9nKFwiaW5pdFBUUyAmIGluaXREVFMgcmVzZXRcIiksIHRoaXMuX2luaXRQVFMgPSB0aGlzLl9pbml0RFRTID0gZTtcbiAgfVxuICByZXNldE5leHRUaW1lc3RhbXAoKSB7XG4gICAgdGhpcy5sb2coXCJyZXNldCBuZXh0IHRpbWVzdGFtcFwiKSwgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9ICExLCB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gITE7XG4gIH1cbiAgcmVzZXRJbml0U2VnbWVudCgpIHtcbiAgICB0aGlzLmxvZyhcIklTR2VuZXJhdGVkIGZsYWcgcmVzZXRcIiksIHRoaXMuSVNHZW5lcmF0ZWQgPSAhMSwgdGhpcy52aWRlb1RyYWNrQ29uZmlnID0gdm9pZCAwO1xuICB9XG4gIGdldFZpZGVvU3RhcnRQdHMoZSkge1xuICAgIGxldCB0ID0gITE7XG4gICAgY29uc3QgciA9IGVbMF0ucHRzLCBuID0gZS5yZWR1Y2UoKGksIG8pID0+IHtcbiAgICAgIGxldCBhID0gby5wdHMsIGwgPSBhIC0gaTtcbiAgICAgIHJldHVybiBsIDwgLTQyOTQ5NjcyOTYgJiYgKHQgPSAhMCwgYSA9IEFyKGEsIHIpLCBsID0gYSAtIGkpLCBsID4gMCA/IGkgOiBhO1xuICAgIH0sIHIpO1xuICAgIHJldHVybiB0ICYmIHRoaXMuZGVidWcoXCJQVFMgcm9sbG92ZXIgZGV0ZWN0ZWRcIiksIG47XG4gIH1cbiAgcmVtdXgoZSwgdCwgciwgbiwgaSwgbywgYSwgbCkge1xuICAgIGxldCBjLCB1LCBkLCBoLCBmLCBwLCB5ID0gaSwgRSA9IGk7XG4gICAgY29uc3QgYiA9IGUucGlkID4gLTEsIFIgPSB0LnBpZCA+IC0xLCBBID0gdC5zYW1wbGVzLmxlbmd0aCwgRiA9IGUuc2FtcGxlcy5sZW5ndGggPiAwLCBNID0gYSAmJiBBID4gMCB8fCBBID4gMTtcbiAgICBpZiAoKCFiIHx8IEYpICYmICghUiB8fCBNKSB8fCB0aGlzLklTR2VuZXJhdGVkIHx8IGEpIHtcbiAgICAgIGlmICh0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICAgIHZhciBLLCBqLCBDLCBrO1xuICAgICAgICBjb25zdCBnID0gdGhpcy52aWRlb1RyYWNrQ29uZmlnO1xuICAgICAgICAoZyAmJiAodC53aWR0aCAhPT0gZy53aWR0aCB8fCB0LmhlaWdodCAhPT0gZy5oZWlnaHQgfHwgKChLID0gdC5waXhlbFJhdGlvKSA9PSBudWxsID8gdm9pZCAwIDogS1swXSkgIT09ICgoaiA9IGcucGl4ZWxSYXRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IGpbMF0pIHx8ICgoQyA9IHQucGl4ZWxSYXRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IENbMV0pICE9PSAoKGsgPSBnLnBpeGVsUmF0aW8pID09IG51bGwgPyB2b2lkIDAgOiBrWzFdKSkgfHwgIWcgJiYgTSB8fCB0aGlzLm5leHRBdWRpb1RzID09PSBudWxsICYmIEYpICYmIHRoaXMucmVzZXRJbml0U2VnbWVudCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5JU0dlbmVyYXRlZCB8fCAoZCA9IHRoaXMuZ2VuZXJhdGVJUyhlLCB0LCBpLCBvKSk7XG4gICAgICBjb25zdCAkID0gdGhpcy5pc1ZpZGVvQ29udGlndW91cztcbiAgICAgIGxldCBXID0gLTEsIF87XG4gICAgICBpZiAoTSAmJiAoVyA9IEpUKHQuc2FtcGxlcyksICEkICYmIHRoaXMuY29uZmlnLmZvcmNlS2V5RnJhbWVPbkRpc2NvbnRpbnVpdHkpKVxuICAgICAgICBpZiAocCA9ICEwLCBXID4gMCkge1xuICAgICAgICAgIHRoaXMud2FybihgRHJvcHBlZCAke1d9IG91dCBvZiAke0F9IHZpZGVvIHNhbXBsZXMgZHVlIHRvIGEgbWlzc2luZyBrZXlmcmFtZWApO1xuICAgICAgICAgIGNvbnN0IGcgPSB0aGlzLmdldFZpZGVvU3RhcnRQdHModC5zYW1wbGVzKTtcbiAgICAgICAgICB0LnNhbXBsZXMgPSB0LnNhbXBsZXMuc2xpY2UoVyksIHQuZHJvcHBlZCArPSBXLCBFICs9ICh0LnNhbXBsZXNbMF0ucHRzIC0gZykgLyB0LmlucHV0VGltZVNjYWxlLCBfID0gRTtcbiAgICAgICAgfSBlbHNlIFcgPT09IC0xICYmICh0aGlzLndhcm4oYE5vIGtleWZyYW1lIGZvdW5kIG91dCBvZiAke0F9IHZpZGVvIHNhbXBsZXNgKSwgcCA9ICExKTtcbiAgICAgIGlmICh0aGlzLklTR2VuZXJhdGVkKSB7XG4gICAgICAgIGlmIChGICYmIE0pIHtcbiAgICAgICAgICBjb25zdCBnID0gdGhpcy5nZXRWaWRlb1N0YXJ0UHRzKHQuc2FtcGxlcyksIHcgPSAoQXIoZS5zYW1wbGVzWzBdLnB0cywgZykgLSBnKSAvIHQuaW5wdXRUaW1lU2NhbGU7XG4gICAgICAgICAgeSArPSBNYXRoLm1heCgwLCB3KSwgRSArPSBNYXRoLm1heCgwLCAtdyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEYpIHtcbiAgICAgICAgICBpZiAoZS5zYW1wbGVyYXRlIHx8ICh0aGlzLndhcm4oXCJyZWdlbmVyYXRlIEluaXRTZWdtZW50IGFzIGF1ZGlvIGRldGVjdGVkXCIpLCBkID0gdGhpcy5nZW5lcmF0ZUlTKGUsIHQsIGksIG8pKSwgdSA9IHRoaXMucmVtdXhBdWRpbyhlLCB5LCB0aGlzLmlzQXVkaW9Db250aWd1b3VzLCBvLCBSIHx8IE0gfHwgbCA9PT0gcGUuQVVESU8gPyBFIDogdm9pZCAwKSwgTSkge1xuICAgICAgICAgICAgY29uc3QgZyA9IHUgPyB1LmVuZFBUUyAtIHUuc3RhcnRQVFMgOiAwO1xuICAgICAgICAgICAgdC5pbnB1dFRpbWVTY2FsZSB8fCAodGhpcy53YXJuKFwicmVnZW5lcmF0ZSBJbml0U2VnbWVudCBhcyB2aWRlbyBkZXRlY3RlZFwiKSwgZCA9IHRoaXMuZ2VuZXJhdGVJUyhlLCB0LCBpLCBvKSksIGMgPSB0aGlzLnJlbXV4VmlkZW8odCwgRSwgJCwgZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgTSAmJiAoYyA9IHRoaXMucmVtdXhWaWRlbyh0LCBFLCAkLCAwKSk7XG4gICAgICAgIGMgJiYgKGMuZmlyc3RLZXlGcmFtZSA9IFcsIGMuaW5kZXBlbmRlbnQgPSBXICE9PSAtMSwgYy5maXJzdEtleUZyYW1lUFRTID0gXyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLklTR2VuZXJhdGVkICYmIHRoaXMuX2luaXRQVFMgJiYgdGhpcy5faW5pdERUUyAmJiAoci5zYW1wbGVzLmxlbmd0aCAmJiAoZiA9IGJwKHIsIGksIHRoaXMuX2luaXRQVFMsIHRoaXMuX2luaXREVFMpKSwgbi5zYW1wbGVzLmxlbmd0aCAmJiAoaCA9IFRwKG4sIGksIHRoaXMuX2luaXRQVFMpKSksIHtcbiAgICAgIGF1ZGlvOiB1LFxuICAgICAgdmlkZW86IGMsXG4gICAgICBpbml0U2VnbWVudDogZCxcbiAgICAgIGluZGVwZW5kZW50OiBwLFxuICAgICAgdGV4dDogaCxcbiAgICAgIGlkMzogZlxuICAgIH07XG4gIH1cbiAgZ2VuZXJhdGVJUyhlLCB0LCByLCBuKSB7XG4gICAgY29uc3QgaSA9IGUuc2FtcGxlcywgbyA9IHQuc2FtcGxlcywgYSA9IHRoaXMudHlwZVN1cHBvcnRlZCwgbCA9IHt9LCBjID0gdGhpcy5faW5pdFBUUztcbiAgICBsZXQgdSA9ICFjIHx8IG4sIGQgPSBcImF1ZGlvL21wNFwiLCBoLCBmLCBwLCB5ID0gLTE7XG4gICAgaWYgKHUgJiYgKGggPSBmID0gMSAvIDApLCBlLmNvbmZpZyAmJiBpLmxlbmd0aCkge1xuICAgICAgc3dpdGNoIChlLnRpbWVzY2FsZSA9IGUuc2FtcGxlcmF0ZSwgZS5zZWdtZW50Q29kZWMpIHtcbiAgICAgICAgY2FzZSBcIm1wM1wiOlxuICAgICAgICAgIGEubXBlZyA/IChkID0gXCJhdWRpby9tcGVnXCIsIGUuY29kZWMgPSBcIlwiKSA6IGEubXAzICYmIChlLmNvZGVjID0gXCJtcDNcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJhYzNcIjpcbiAgICAgICAgICBlLmNvZGVjID0gXCJhYy0zXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsLmF1ZGlvID0ge1xuICAgICAgICBpZDogXCJhdWRpb1wiLFxuICAgICAgICBjb250YWluZXI6IGQsXG4gICAgICAgIGNvZGVjOiBlLmNvZGVjLFxuICAgICAgICBpbml0U2VnbWVudDogZS5zZWdtZW50Q29kZWMgPT09IFwibXAzXCIgJiYgYS5tcGVnID8gbmV3IFVpbnQ4QXJyYXkoMCkgOiBYLmluaXRTZWdtZW50KFtlXSksXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgY2hhbm5lbENvdW50OiBlLmNoYW5uZWxDb3VudFxuICAgICAgICB9XG4gICAgICB9LCB1ICYmICh5ID0gZS5pZCwgcCA9IGUuaW5wdXRUaW1lU2NhbGUsICFjIHx8IHAgIT09IGMudGltZXNjYWxlID8gaCA9IGYgPSBpWzBdLnB0cyAtIE1hdGgucm91bmQocCAqIHIpIDogdSA9ICExKTtcbiAgICB9XG4gICAgaWYgKHQuc3BzICYmIHQucHBzICYmIG8ubGVuZ3RoKSB7XG4gICAgICBpZiAodC50aW1lc2NhbGUgPSB0LmlucHV0VGltZVNjYWxlLCBsLnZpZGVvID0ge1xuICAgICAgICBpZDogXCJtYWluXCIsXG4gICAgICAgIGNvbnRhaW5lcjogXCJ2aWRlby9tcDRcIixcbiAgICAgICAgY29kZWM6IHQuY29kZWMsXG4gICAgICAgIGluaXRTZWdtZW50OiBYLmluaXRTZWdtZW50KFt0XSksXG4gICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgd2lkdGg6IHQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB0LmhlaWdodFxuICAgICAgICB9XG4gICAgICB9LCB1KVxuICAgICAgICBpZiAoeSA9IHQuaWQsIHAgPSB0LmlucHV0VGltZVNjYWxlLCAhYyB8fCBwICE9PSBjLnRpbWVzY2FsZSkge1xuICAgICAgICAgIGNvbnN0IEUgPSB0aGlzLmdldFZpZGVvU3RhcnRQdHMobyksIGIgPSBNYXRoLnJvdW5kKHAgKiByKTtcbiAgICAgICAgICBmID0gTWF0aC5taW4oZiwgQXIob1swXS5kdHMsIEUpIC0gYiksIGggPSBNYXRoLm1pbihoLCBFIC0gYik7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHUgPSAhMTtcbiAgICAgIHRoaXMudmlkZW9UcmFja0NvbmZpZyA9IHtcbiAgICAgICAgd2lkdGg6IHQud2lkdGgsXG4gICAgICAgIGhlaWdodDogdC5oZWlnaHQsXG4gICAgICAgIHBpeGVsUmF0aW86IHQucGl4ZWxSYXRpb1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKGwpLmxlbmd0aClcbiAgICAgIHJldHVybiB0aGlzLklTR2VuZXJhdGVkID0gITAsIHUgPyAoYyAmJiB0aGlzLndhcm4oYFRpbWVzdGFtcHMgYXQgcGxheWxpc3QgdGltZTogJHtuID8gXCJcIiA6IFwiflwifSR7cn0gJHtoIC8gcH0gIT0gaW5pdFBUUzogJHtjLmJhc2VUaW1lIC8gYy50aW1lc2NhbGV9ICgke2MuYmFzZVRpbWV9LyR7Yy50aW1lc2NhbGV9KSB0cmFja0lkOiAke2MudHJhY2tJZH1gKSwgdGhpcy5sb2coYEZvdW5kIGluaXRQVFMgYXQgcGxheWxpc3QgdGltZTogJHtyfSBvZmZzZXQ6ICR7aCAvIHB9ICgke2h9LyR7cH0pIHRyYWNrSWQ6ICR7eX1gKSwgdGhpcy5faW5pdFBUUyA9IHtcbiAgICAgICAgYmFzZVRpbWU6IGgsXG4gICAgICAgIHRpbWVzY2FsZTogcCxcbiAgICAgICAgdHJhY2tJZDogeVxuICAgICAgfSwgdGhpcy5faW5pdERUUyA9IHtcbiAgICAgICAgYmFzZVRpbWU6IGYsXG4gICAgICAgIHRpbWVzY2FsZTogcCxcbiAgICAgICAgdHJhY2tJZDogeVxuICAgICAgfSkgOiBoID0gcCA9IHZvaWQgMCwge1xuICAgICAgICB0cmFja3M6IGwsXG4gICAgICAgIGluaXRQVFM6IGgsXG4gICAgICAgIHRpbWVzY2FsZTogcCxcbiAgICAgICAgdHJhY2tJZDogeVxuICAgICAgfTtcbiAgfVxuICByZW11eFZpZGVvKGUsIHQsIHIsIG4pIHtcbiAgICBjb25zdCBpID0gZS5pbnB1dFRpbWVTY2FsZSwgbyA9IGUuc2FtcGxlcywgYSA9IFtdLCBsID0gby5sZW5ndGgsIGMgPSB0aGlzLl9pbml0UFRTLCB1ID0gYy5iYXNlVGltZSAqIGkgLyBjLnRpbWVzY2FsZTtcbiAgICBsZXQgZCA9IHRoaXMubmV4dFZpZGVvVHMsIGggPSA4LCBmID0gdGhpcy52aWRlb1NhbXBsZUR1cmF0aW9uLCBwLCB5LCBFID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBiID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBSID0gITE7XG4gICAgaWYgKCFyIHx8IGQgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IEwgPSB1ICsgdCAqIGksIG0gPSBvWzBdLnB0cyAtIEFyKG9bMF0uZHRzLCBvWzBdLnB0cyk7XG4gICAgICBwbiAmJiBkICE9PSBudWxsICYmIE1hdGguYWJzKEwgLSBtIC0gKGQgKyB1KSkgPCAxNWUzID8gciA9ICEwIDogZCA9IEwgLSBtIC0gdTtcbiAgICB9XG4gICAgY29uc3QgQSA9IGQgKyB1O1xuICAgIGZvciAobGV0IEwgPSAwOyBMIDwgbDsgTCsrKSB7XG4gICAgICBjb25zdCBtID0gb1tMXTtcbiAgICAgIG0ucHRzID0gQXIobS5wdHMsIEEpLCBtLmR0cyA9IEFyKG0uZHRzLCBBKSwgbS5kdHMgPCBvW0wgPiAwID8gTCAtIDEgOiBMXS5kdHMgJiYgKFIgPSAhMCk7XG4gICAgfVxuICAgIFIgJiYgby5zb3J0KGZ1bmN0aW9uKEwsIG0pIHtcbiAgICAgIGNvbnN0IHYgPSBMLmR0cyAtIG0uZHRzLCBQID0gTC5wdHMgLSBtLnB0cztcbiAgICAgIHJldHVybiB2IHx8IFA7XG4gICAgfSksIHAgPSBvWzBdLmR0cywgeSA9IG9bby5sZW5ndGggLSAxXS5kdHM7XG4gICAgY29uc3QgRiA9IHkgLSBwLCBNID0gRiA/IE1hdGgucm91bmQoRiAvIChsIC0gMSkpIDogZiB8fCBlLmlucHV0VGltZVNjYWxlIC8gMzA7XG4gICAgaWYgKHIpIHtcbiAgICAgIGNvbnN0IEwgPSBwIC0gQSwgbSA9IEwgPiBNLCB2ID0gTCA8IC0xO1xuICAgICAgaWYgKChtIHx8IHYpICYmIChtID8gdGhpcy53YXJuKGAkeyhlLnNlZ21lbnRDb2RlYyB8fCBcIlwiKS50b1VwcGVyQ2FzZSgpfTogJHtxbihMLCAhMCl9IG1zICgke0x9ZHRzKSBob2xlIGJldHdlZW4gZnJhZ21lbnRzIGRldGVjdGVkIGF0ICR7dC50b0ZpeGVkKDMpfWApIDogdGhpcy53YXJuKGAkeyhlLnNlZ21lbnRDb2RlYyB8fCBcIlwiKS50b1VwcGVyQ2FzZSgpfTogJHtxbigtTCwgITApfSBtcyAoJHtMfWR0cykgb3ZlcmxhcHBpbmcgYmV0d2VlbiBmcmFnbWVudHMgZGV0ZWN0ZWQgYXQgJHt0LnRvRml4ZWQoMyl9YCksICF2IHx8IEEgPj0gb1swXS5wdHMgfHwgcG4pKSB7XG4gICAgICAgIHAgPSBBO1xuICAgICAgICBjb25zdCBQID0gb1swXS5wdHMgLSBMO1xuICAgICAgICBpZiAobSlcbiAgICAgICAgICBvWzBdLmR0cyA9IHAsIG9bMF0ucHRzID0gUDtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgbGV0IE4gPSAhMDtcbiAgICAgICAgICBmb3IgKGxldCBZID0gMDsgWSA8IG8ubGVuZ3RoICYmICEob1tZXS5kdHMgPiBQICYmIE4pOyBZKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVlID0gb1tZXS5wdHM7XG4gICAgICAgICAgICBpZiAob1tZXS5kdHMgLT0gTCwgb1tZXS5wdHMgLT0gTCwgWSA8IG8ubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICBjb25zdCBpZSA9IG9bWSArIDFdLnB0cywgbGUgPSBvW1ldLnB0cywgVGUgPSBpZSA8PSBsZSwgRGUgPSBpZSA8PSBlZTtcbiAgICAgICAgICAgICAgTiA9IFRlID09IERlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZyhgVmlkZW86IEluaXRpYWwgUFRTL0RUUyBhZGp1c3RlZDogJHtxbihQLCAhMCl9LyR7cW4ocCwgITApfSwgZGVsdGE6ICR7cW4oTCwgITApfSBtc2ApO1xuICAgICAgfVxuICAgIH1cbiAgICBwID0gTWF0aC5tYXgoMCwgcCk7XG4gICAgbGV0IEggPSAwLCBLID0gMCwgaiA9IHA7XG4gICAgZm9yIChsZXQgTCA9IDA7IEwgPCBsOyBMKyspIHtcbiAgICAgIGNvbnN0IG0gPSBvW0xdLCB2ID0gbS51bml0cywgUCA9IHYubGVuZ3RoO1xuICAgICAgbGV0IE4gPSAwO1xuICAgICAgZm9yIChsZXQgWSA9IDA7IFkgPCBQOyBZKyspXG4gICAgICAgIE4gKz0gdltZXS5kYXRhLmxlbmd0aDtcbiAgICAgIEsgKz0gTiwgSCArPSBQLCBtLmxlbmd0aCA9IE4sIG0uZHRzIDwgaiA/IChtLmR0cyA9IGosIGogKz0gTSAvIDQgfCAwIHx8IDEpIDogaiA9IG0uZHRzLCBFID0gTWF0aC5taW4obS5wdHMsIEUpLCBiID0gTWF0aC5tYXgobS5wdHMsIGIpO1xuICAgIH1cbiAgICB5ID0gb1tsIC0gMV0uZHRzO1xuICAgIGNvbnN0IEMgPSBLICsgNCAqIEggKyA4O1xuICAgIGxldCBrO1xuICAgIHRyeSB7XG4gICAgICBrID0gbmV3IFVpbnQ4QXJyYXkoQyk7XG4gICAgfSBjYXRjaCAoTCkge1xuICAgICAgdGhpcy5vYnNlcnZlci5lbWl0KEkuRVJST1IsIEkuRVJST1IsIHtcbiAgICAgICAgdHlwZTogdmUuTVVYX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBKLlJFTVVYX0FMTE9DX0VSUk9SLFxuICAgICAgICBmYXRhbDogITEsXG4gICAgICAgIGVycm9yOiBMLFxuICAgICAgICBieXRlczogQyxcbiAgICAgICAgcmVhc29uOiBgZmFpbCBhbGxvY2F0aW5nIHZpZGVvIG1kYXQgJHtDfWBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCAkID0gbmV3IERhdGFWaWV3KGsuYnVmZmVyKTtcbiAgICAkLnNldFVpbnQzMigwLCBDKSwgay5zZXQoWC50eXBlcy5tZGF0LCA0KTtcbiAgICBsZXQgVyA9ICExLCBfID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBnID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCB4ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCB3ID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgIGZvciAobGV0IEwgPSAwOyBMIDwgbDsgTCsrKSB7XG4gICAgICBjb25zdCBtID0gb1tMXSwgdiA9IG0udW5pdHM7XG4gICAgICBsZXQgUCA9IDA7XG4gICAgICBmb3IgKGxldCBlZSA9IDAsIGllID0gdi5sZW5ndGg7IGVlIDwgaWU7IGVlKyspIHtcbiAgICAgICAgY29uc3QgbGUgPSB2W2VlXSwgVGUgPSBsZS5kYXRhLCBEZSA9IGxlLmRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgICAgJC5zZXRVaW50MzIoaCwgRGUpLCBoICs9IDQsIGsuc2V0KFRlLCBoKSwgaCArPSBEZSwgUCArPSA0ICsgRGU7XG4gICAgICB9XG4gICAgICBsZXQgTjtcbiAgICAgIGlmIChMIDwgbCAtIDEpXG4gICAgICAgIGYgPSBvW0wgKyAxXS5kdHMgLSBtLmR0cywgTiA9IG9bTCArIDFdLnB0cyAtIG0ucHRzO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGVlID0gdGhpcy5jb25maWcsIGllID0gTCA+IDAgPyBtLmR0cyAtIG9bTCAtIDFdLmR0cyA6IE07XG4gICAgICAgIGlmIChOID0gTCA+IDAgPyBtLnB0cyAtIG9bTCAtIDFdLnB0cyA6IE0sIGVlLnN0cmV0Y2hTaG9ydFZpZGVvVHJhY2sgJiYgdGhpcy5uZXh0QXVkaW9UcyAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IGxlID0gTWF0aC5mbG9vcihlZS5tYXhCdWZmZXJIb2xlICogaSksIFRlID0gKG4gPyBFICsgbiAqIGkgOiB0aGlzLm5leHRBdWRpb1RzICsgdSkgLSBtLnB0cztcbiAgICAgICAgICBUZSA+IGxlID8gKGYgPSBUZSAtIGllLCBmIDwgMCA/IGYgPSBpZSA6IFcgPSAhMCwgdGhpcy5sb2coYEl0IGlzIGFwcHJveGltYXRlbHkgJHtUZSAvIDkwfSBtcyB0byB0aGUgbmV4dCBzZWdtZW50OyB1c2luZyBkdXJhdGlvbiAke2YgLyA5MH0gbXMgZm9yIHRoZSBsYXN0IHZpZGVvIGZyYW1lLmApKSA6IGYgPSBpZTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgZiA9IGllO1xuICAgICAgfVxuICAgICAgY29uc3QgWSA9IE1hdGgucm91bmQobS5wdHMgLSBtLmR0cyk7XG4gICAgICBfID0gTWF0aC5taW4oXywgZiksIHggPSBNYXRoLm1heCh4LCBmKSwgZyA9IE1hdGgubWluKGcsIE4pLCB3ID0gTWF0aC5tYXgodywgTiksIGEucHVzaChVaChtLmtleSwgZiwgUCwgWSkpO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGgpIHtcbiAgICAgIGlmIChwbikge1xuICAgICAgICBpZiAocG4gPCA3MCkge1xuICAgICAgICAgIGNvbnN0IEwgPSBhWzBdLmZsYWdzO1xuICAgICAgICAgIEwuZGVwZW5kc09uID0gMiwgTC5pc05vblN5bmMgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKEVsICYmIHcgLSBnIDwgeCAtIF8gJiYgTSAvIHggPCAwLjAyNSAmJiBhWzBdLmN0cyA9PT0gMCkge1xuICAgICAgICB0aGlzLndhcm4oXCJGb3VuZCBpcnJlZ3VsYXIgZ2FwcyBpbiBzYW1wbGUgZHVyYXRpb24uIFVzaW5nIFBUUyBpbnN0ZWFkIG9mIERUUyB0byBkZXRlcm1pbmUgTVA0IHNhbXBsZSBkdXJhdGlvbi5cIik7XG4gICAgICAgIGxldCBMID0gcDtcbiAgICAgICAgZm9yIChsZXQgbSA9IDAsIHYgPSBhLmxlbmd0aDsgbSA8IHY7IG0rKykge1xuICAgICAgICAgIGNvbnN0IFAgPSBMICsgYVttXS5kdXJhdGlvbiwgTiA9IEwgKyBhW21dLmN0cztcbiAgICAgICAgICBpZiAobSA8IHYgLSAxKSB7XG4gICAgICAgICAgICBjb25zdCBZID0gUCArIGFbbSArIDFdLmN0cztcbiAgICAgICAgICAgIGFbbV0uZHVyYXRpb24gPSBZIC0gTjtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIGFbbV0uZHVyYXRpb24gPSBtID8gYVttIC0gMV0uZHVyYXRpb24gOiBNO1xuICAgICAgICAgIGFbbV0uY3RzID0gMCwgTCA9IFA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZiA9IFcgfHwgIWYgPyBNIDogZjtcbiAgICBjb25zdCBEID0geSArIGY7XG4gICAgdGhpcy5uZXh0VmlkZW9UcyA9IGQgPSBEIC0gdSwgdGhpcy52aWRlb1NhbXBsZUR1cmF0aW9uID0gZiwgdGhpcy5pc1ZpZGVvQ29udGlndW91cyA9ICEwO1xuICAgIGNvbnN0IFYgPSB7XG4gICAgICBkYXRhMTogWC5tb29mKGUuc2VxdWVuY2VOdW1iZXIrKywgcCwgbnQoZSwge1xuICAgICAgICBzYW1wbGVzOiBhXG4gICAgICB9KSksXG4gICAgICBkYXRhMjogayxcbiAgICAgIHN0YXJ0UFRTOiAoRSAtIHUpIC8gaSxcbiAgICAgIGVuZFBUUzogKGIgKyBmIC0gdSkgLyBpLFxuICAgICAgc3RhcnREVFM6IChwIC0gdSkgLyBpLFxuICAgICAgZW5kRFRTOiBkIC8gaSxcbiAgICAgIHR5cGU6IFwidmlkZW9cIixcbiAgICAgIGhhc0F1ZGlvOiAhMSxcbiAgICAgIGhhc1ZpZGVvOiAhMCxcbiAgICAgIG5iOiBhLmxlbmd0aCxcbiAgICAgIGRyb3BwZWQ6IGUuZHJvcHBlZFxuICAgIH07XG4gICAgcmV0dXJuIGUuc2FtcGxlcyA9IFtdLCBlLmRyb3BwZWQgPSAwLCBWO1xuICB9XG4gIGdldFNhbXBsZXNQZXJGcmFtZShlKSB7XG4gICAgc3dpdGNoIChlLnNlZ21lbnRDb2RlYykge1xuICAgICAgY2FzZSBcIm1wM1wiOlxuICAgICAgICByZXR1cm4gWlQ7XG4gICAgICBjYXNlIFwiYWMzXCI6XG4gICAgICAgIHJldHVybiBYVDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBZVDtcbiAgICB9XG4gIH1cbiAgcmVtdXhBdWRpbyhlLCB0LCByLCBuLCBpKSB7XG4gICAgY29uc3QgbyA9IGUuaW5wdXRUaW1lU2NhbGUsIGEgPSBlLnNhbXBsZXJhdGUgPyBlLnNhbXBsZXJhdGUgOiBvLCBsID0gbyAvIGEsIGMgPSB0aGlzLmdldFNhbXBsZXNQZXJGcmFtZShlKSwgdSA9IGMgKiBsLCBkID0gdGhpcy5faW5pdFBUUywgaCA9IGUuc2VnbWVudENvZGVjID09PSBcIm1wM1wiICYmIHRoaXMudHlwZVN1cHBvcnRlZC5tcGVnLCBmID0gW10sIHAgPSBpICE9PSB2b2lkIDA7XG4gICAgbGV0IHkgPSBlLnNhbXBsZXMsIEUgPSBoID8gMCA6IDgsIGIgPSB0aGlzLm5leHRBdWRpb1RzIHx8IC0xO1xuICAgIGNvbnN0IFIgPSBkLmJhc2VUaW1lICogbyAvIGQudGltZXNjYWxlLCBBID0gUiArIHQgKiBvO1xuICAgIGlmICh0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gciA9IHIgfHwgeS5sZW5ndGggJiYgYiA+IDAgJiYgKG4gJiYgTWF0aC5hYnMoQSAtIChiICsgUikpIDwgOWUzIHx8IE1hdGguYWJzKEFyKHlbMF0ucHRzLCBBKSAtIChiICsgUikpIDwgMjAgKiB1KSwgeS5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcbiAgICAgIHcucHRzID0gQXIody5wdHMsIEEpO1xuICAgIH0pLCAhciB8fCBiIDwgMCkge1xuICAgICAgaWYgKHkgPSB5LmZpbHRlcigodykgPT4gdy5wdHMgPj0gMCksICF5Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaSA9PT0gMCA/IGIgPSAwIDogbiAmJiAhcCA/IGIgPSBNYXRoLm1heCgwLCBBIC0gUikgOiBiID0geVswXS5wdHMgLSBSO1xuICAgIH1cbiAgICBpZiAoZS5zZWdtZW50Q29kZWMgPT09IFwiYWFjXCIpIHtcbiAgICAgIGNvbnN0IHcgPSB0aGlzLmNvbmZpZy5tYXhBdWRpb0ZyYW1lc0RyaWZ0O1xuICAgICAgZm9yIChsZXQgRCA9IDAsIE8gPSBiICsgUjsgRCA8IHkubGVuZ3RoOyBEKyspIHtcbiAgICAgICAgY29uc3QgVSA9IHlbRF0sIFYgPSBVLnB0cywgTCA9IFYgLSBPLCBtID0gTWF0aC5hYnMoMWUzICogTCAvIG8pO1xuICAgICAgICBpZiAoTCA8PSAtdyAqIHUgJiYgcClcbiAgICAgICAgICBEID09PSAwICYmICh0aGlzLndhcm4oYEF1ZGlvIGZyYW1lIEAgJHsoViAvIG8pLnRvRml4ZWQoMyl9cyBvdmVybGFwcyBtYXJrZXIgYnkgJHtNYXRoLnJvdW5kKDFlMyAqIEwgLyBvKX0gbXMuYCksIHRoaXMubmV4dEF1ZGlvVHMgPSBiID0gViAtIFIsIE8gPSBWKTtcbiAgICAgICAgZWxzZSBpZiAoTCA+PSB3ICogdSAmJiBtIDwgelQgJiYgcCkge1xuICAgICAgICAgIGxldCB2ID0gTWF0aC5yb3VuZChMIC8gdSk7XG4gICAgICAgICAgZm9yIChPID0gViAtIHYgKiB1OyBPIDwgMCAmJiB2ICYmIHU7IClcbiAgICAgICAgICAgIHYtLSwgTyArPSB1O1xuICAgICAgICAgIEQgPT09IDAgJiYgKHRoaXMubmV4dEF1ZGlvVHMgPSBiID0gTyAtIFIpLCB0aGlzLndhcm4oYEluamVjdGluZyAke3Z9IGF1ZGlvIGZyYW1lcyBAICR7KChPIC0gUikgLyBvKS50b0ZpeGVkKDMpfXMgZHVlIHRvICR7TWF0aC5yb3VuZCgxZTMgKiBMIC8gbyl9IG1zIGdhcC5gKTtcbiAgICAgICAgICBmb3IgKGxldCBQID0gMDsgUCA8IHY7IFArKykge1xuICAgICAgICAgICAgbGV0IE4gPSBIVC5nZXRTaWxlbnRGcmFtZShlLnBhcnNlZENvZGVjIHx8IGUubWFuaWZlc3RDb2RlYyB8fCBlLmNvZGVjLCBlLmNoYW5uZWxDb3VudCk7XG4gICAgICAgICAgICBOIHx8ICh0aGlzLmxvZyhcIlVuYWJsZSB0byBnZXQgc2lsZW50IGZyYW1lIGZvciBnaXZlbiBhdWRpbyBjb2RlYzsgZHVwbGljYXRpbmcgbGFzdCBmcmFtZSBpbnN0ZWFkLlwiKSwgTiA9IFUudW5pdC5zdWJhcnJheSgpKSwgeS5zcGxpY2UoRCwgMCwge1xuICAgICAgICAgICAgICB1bml0OiBOLFxuICAgICAgICAgICAgICBwdHM6IE9cbiAgICAgICAgICAgIH0pLCBPICs9IHUsIEQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgVS5wdHMgPSBPLCBPICs9IHU7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBGID0gbnVsbCwgTSA9IG51bGwsIEgsIEsgPSAwLCBqID0geS5sZW5ndGg7XG4gICAgZm9yICg7IGotLTsgKVxuICAgICAgSyArPSB5W2pdLnVuaXQuYnl0ZUxlbmd0aDtcbiAgICBmb3IgKGxldCB3ID0gMCwgRCA9IHkubGVuZ3RoOyB3IDwgRDsgdysrKSB7XG4gICAgICBjb25zdCBPID0geVt3XSwgVSA9IE8udW5pdDtcbiAgICAgIGxldCBWID0gTy5wdHM7XG4gICAgICBpZiAoTSAhPT0gbnVsbCkge1xuICAgICAgICBjb25zdCBtID0gZlt3IC0gMV07XG4gICAgICAgIG0uZHVyYXRpb24gPSBNYXRoLnJvdW5kKChWIC0gTSkgLyBsKTtcbiAgICAgIH0gZWxzZSBpZiAociAmJiBlLnNlZ21lbnRDb2RlYyA9PT0gXCJhYWNcIiAmJiAoViA9IGIgKyBSKSwgRiA9IFYsIEsgPiAwKSB7XG4gICAgICAgIEsgKz0gRTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBIID0gbmV3IFVpbnQ4QXJyYXkoSyk7XG4gICAgICAgIH0gY2F0Y2ggKG0pIHtcbiAgICAgICAgICB0aGlzLm9ic2VydmVyLmVtaXQoSS5FUlJPUiwgSS5FUlJPUiwge1xuICAgICAgICAgICAgdHlwZTogdmUuTVVYX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogSi5SRU1VWF9BTExPQ19FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiAhMSxcbiAgICAgICAgICAgIGVycm9yOiBtLFxuICAgICAgICAgICAgYnl0ZXM6IEssXG4gICAgICAgICAgICByZWFzb246IGBmYWlsIGFsbG9jYXRpbmcgYXVkaW8gbWRhdCAke0t9YFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoIHx8IChuZXcgRGF0YVZpZXcoSC5idWZmZXIpLnNldFVpbnQzMigwLCBLKSwgSC5zZXQoWC50eXBlcy5tZGF0LCA0KSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgcmV0dXJuO1xuICAgICAgSC5zZXQoVSwgRSk7XG4gICAgICBjb25zdCBMID0gVS5ieXRlTGVuZ3RoO1xuICAgICAgRSArPSBMLCBmLnB1c2goVWgoITAsIGMsIEwsIDApKSwgTSA9IFY7XG4gICAgfVxuICAgIGNvbnN0IEMgPSBmLmxlbmd0aDtcbiAgICBpZiAoIUMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgayA9IGZbZi5sZW5ndGggLSAxXTtcbiAgICBiID0gTSAtIFIsIHRoaXMubmV4dEF1ZGlvVHMgPSBiICsgbCAqIGsuZHVyYXRpb247XG4gICAgY29uc3QgJCA9IGggPyBuZXcgVWludDhBcnJheSgwKSA6IFgubW9vZihlLnNlcXVlbmNlTnVtYmVyKyssIEYgLyBsLCBudCh7fSwgZSwge1xuICAgICAgc2FtcGxlczogZlxuICAgIH0pKTtcbiAgICBlLnNhbXBsZXMgPSBbXTtcbiAgICBjb25zdCBXID0gKEYgLSBSKSAvIG8sIF8gPSBiIC8gbywgeCA9IHtcbiAgICAgIGRhdGExOiAkLFxuICAgICAgZGF0YTI6IEgsXG4gICAgICBzdGFydFBUUzogVyxcbiAgICAgIGVuZFBUUzogXyxcbiAgICAgIHN0YXJ0RFRTOiBXLFxuICAgICAgZW5kRFRTOiBfLFxuICAgICAgdHlwZTogXCJhdWRpb1wiLFxuICAgICAgaGFzQXVkaW86ICEwLFxuICAgICAgaGFzVmlkZW86ICExLFxuICAgICAgbmI6IENcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLmlzQXVkaW9Db250aWd1b3VzID0gITAsIHg7XG4gIH1cbn1cbmZ1bmN0aW9uIEFyKHMsIGUpIHtcbiAgbGV0IHQ7XG4gIGlmIChlID09PSBudWxsKVxuICAgIHJldHVybiBzO1xuICBmb3IgKGUgPCBzID8gdCA9IC04NTg5OTM0NTkyIDogdCA9IDg1ODk5MzQ1OTI7IE1hdGguYWJzKHMgLSBlKSA+IDQyOTQ5NjcyOTY7IClcbiAgICBzICs9IHQ7XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gSlQocykge1xuICBmb3IgKGxldCBlID0gMDsgZSA8IHMubGVuZ3RoOyBlKyspXG4gICAgaWYgKHNbZV0ua2V5KVxuICAgICAgcmV0dXJuIGU7XG4gIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGJwKHMsIGUsIHQsIHIpIHtcbiAgY29uc3QgbiA9IHMuc2FtcGxlcy5sZW5ndGg7XG4gIGlmICghbilcbiAgICByZXR1cm47XG4gIGNvbnN0IGkgPSBzLmlucHV0VGltZVNjYWxlO1xuICBmb3IgKGxldCBhID0gMDsgYSA8IG47IGErKykge1xuICAgIGNvbnN0IGwgPSBzLnNhbXBsZXNbYV07XG4gICAgbC5wdHMgPSBBcihsLnB0cyAtIHQuYmFzZVRpbWUgKiBpIC8gdC50aW1lc2NhbGUsIGUgKiBpKSAvIGksIGwuZHRzID0gQXIobC5kdHMgLSByLmJhc2VUaW1lICogaSAvIHIudGltZXNjYWxlLCBlICogaSkgLyBpO1xuICB9XG4gIGNvbnN0IG8gPSBzLnNhbXBsZXM7XG4gIHJldHVybiBzLnNhbXBsZXMgPSBbXSwge1xuICAgIHNhbXBsZXM6IG9cbiAgfTtcbn1cbmZ1bmN0aW9uIFRwKHMsIGUsIHQpIHtcbiAgY29uc3QgciA9IHMuc2FtcGxlcy5sZW5ndGg7XG4gIGlmICghcilcbiAgICByZXR1cm47XG4gIGNvbnN0IG4gPSBzLmlucHV0VGltZVNjYWxlO1xuICBmb3IgKGxldCBvID0gMDsgbyA8IHI7IG8rKykge1xuICAgIGNvbnN0IGEgPSBzLnNhbXBsZXNbb107XG4gICAgYS5wdHMgPSBBcihhLnB0cyAtIHQuYmFzZVRpbWUgKiBuIC8gdC50aW1lc2NhbGUsIGUgKiBuKSAvIG47XG4gIH1cbiAgcy5zYW1wbGVzLnNvcnQoKG8sIGEpID0+IG8ucHRzIC0gYS5wdHMpO1xuICBjb25zdCBpID0gcy5zYW1wbGVzO1xuICByZXR1cm4gcy5zYW1wbGVzID0gW10sIHtcbiAgICBzYW1wbGVzOiBpXG4gIH07XG59XG5jbGFzcyBRVCBleHRlbmRzIExyIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgciwgbikge1xuICAgIHN1cGVyKFwicGFzc3Rocm91Z2gtcmVtdXhlclwiLCBuKSwgdGhpcy5lbWl0SW5pdFNlZ21lbnQgPSAhMSwgdGhpcy5hdWRpb0NvZGVjID0gdm9pZCAwLCB0aGlzLnZpZGVvQ29kZWMgPSB2b2lkIDAsIHRoaXMuaW5pdERhdGEgPSB2b2lkIDAsIHRoaXMuaW5pdFBUUyA9IG51bGwsIHRoaXMuaW5pdFRyYWNrcyA9IHZvaWQgMCwgdGhpcy5sYXN0RW5kVGltZSA9IG51bGwsIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSAhMTtcbiAgfVxuICBkZXN0cm95KCkge1xuICB9XG4gIHJlc2V0VGltZVN0YW1wKGUpIHtcbiAgICB0aGlzLmxhc3RFbmRUaW1lID0gbnVsbDtcbiAgICBjb25zdCB0ID0gdGhpcy5pbml0UFRTO1xuICAgIHQgJiYgZSAmJiB0LmJhc2VUaW1lID09PSBlLmJhc2VUaW1lICYmIHQudGltZXNjYWxlID09PSBlLnRpbWVzY2FsZSB8fCAodGhpcy5pbml0UFRTID0gZSk7XG4gIH1cbiAgcmVzZXROZXh0VGltZXN0YW1wKCkge1xuICAgIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgPSAhMSwgdGhpcy5sYXN0RW5kVGltZSA9IG51bGw7XG4gIH1cbiAgcmVzZXRJbml0U2VnbWVudChlLCB0LCByLCBuKSB7XG4gICAgdGhpcy5hdWRpb0NvZGVjID0gdCwgdGhpcy52aWRlb0NvZGVjID0gciwgdGhpcy5nZW5lcmF0ZUluaXRTZWdtZW50KGUsIG4pLCB0aGlzLmVtaXRJbml0U2VnbWVudCA9ICEwO1xuICB9XG4gIGdlbmVyYXRlSW5pdFNlZ21lbnQoZSwgdCkge1xuICAgIGxldCB7XG4gICAgICBhdWRpb0NvZGVjOiByLFxuICAgICAgdmlkZW9Db2RlYzogblxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghKGUgIT0gbnVsbCAmJiBlLmJ5dGVMZW5ndGgpKSB7XG4gICAgICB0aGlzLmluaXRUcmFja3MgPSB2b2lkIDAsIHRoaXMuaW5pdERhdGEgPSB2b2lkIDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGF1ZGlvOiBpLFxuICAgICAgdmlkZW86IG9cbiAgICB9ID0gdGhpcy5pbml0RGF0YSA9IERnKGUpO1xuICAgIGlmICh0KVxuICAgICAgJFMoZSwgdCk7XG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBsID0gaSB8fCBvO1xuICAgICAgbCAhPSBudWxsICYmIGwuZW5jcnlwdGVkICYmIHRoaXMud2FybihgSW5pdCBzZWdtZW50IHdpdGggZW5jcnlwdGVkIHRyYWNrIHdpdGggaGFzIG5vIGtleSAoXCIke2wuY29kZWN9XCIpIWApO1xuICAgIH1cbiAgICBpICYmIChyID0gJGgoaSwgb3QuQVVESU8sIHRoaXMpKSwgbyAmJiAobiA9ICRoKG8sIG90LlZJREVPLCB0aGlzKSk7XG4gICAgY29uc3QgYSA9IHt9O1xuICAgIGkgJiYgbyA/IGEuYXVkaW92aWRlbyA9IHtcbiAgICAgIGNvbnRhaW5lcjogXCJ2aWRlby9tcDRcIixcbiAgICAgIGNvZGVjOiByICsgXCIsXCIgKyBuLFxuICAgICAgc3VwcGxlbWVudGFsOiBvLnN1cHBsZW1lbnRhbCxcbiAgICAgIGVuY3J5cHRlZDogby5lbmNyeXB0ZWQsXG4gICAgICBpbml0U2VnbWVudDogZSxcbiAgICAgIGlkOiBcIm1haW5cIlxuICAgIH0gOiBpID8gYS5hdWRpbyA9IHtcbiAgICAgIGNvbnRhaW5lcjogXCJhdWRpby9tcDRcIixcbiAgICAgIGNvZGVjOiByLFxuICAgICAgZW5jcnlwdGVkOiBpLmVuY3J5cHRlZCxcbiAgICAgIGluaXRTZWdtZW50OiBlLFxuICAgICAgaWQ6IFwiYXVkaW9cIlxuICAgIH0gOiBvID8gYS52aWRlbyA9IHtcbiAgICAgIGNvbnRhaW5lcjogXCJ2aWRlby9tcDRcIixcbiAgICAgIGNvZGVjOiBuLFxuICAgICAgc3VwcGxlbWVudGFsOiBvLnN1cHBsZW1lbnRhbCxcbiAgICAgIGVuY3J5cHRlZDogby5lbmNyeXB0ZWQsXG4gICAgICBpbml0U2VnbWVudDogZSxcbiAgICAgIGlkOiBcIm1haW5cIlxuICAgIH0gOiB0aGlzLndhcm4oXCJpbml0U2VnbWVudCBkb2VzIG5vdCBjb250YWluIG1vb3Ygb3IgdHJhayBib3hlcy5cIiksIHRoaXMuaW5pdFRyYWNrcyA9IGE7XG4gIH1cbiAgcmVtdXgoZSwgdCwgciwgbiwgaSwgbykge1xuICAgIHZhciBhLCBsO1xuICAgIGxldCB7XG4gICAgICBpbml0UFRTOiBjLFxuICAgICAgbGFzdEVuZFRpbWU6IHVcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBkID0ge1xuICAgICAgYXVkaW86IHZvaWQgMCxcbiAgICAgIHZpZGVvOiB2b2lkIDAsXG4gICAgICB0ZXh0OiBuLFxuICAgICAgaWQzOiByLFxuICAgICAgaW5pdFNlZ21lbnQ6IHZvaWQgMFxuICAgIH07XG4gICAgdWUodSkgfHwgKHUgPSB0aGlzLmxhc3RFbmRUaW1lID0gaSB8fCAwKTtcbiAgICBjb25zdCBoID0gdC5zYW1wbGVzO1xuICAgIGlmICghaC5sZW5ndGgpXG4gICAgICByZXR1cm4gZDtcbiAgICBjb25zdCBmID0ge1xuICAgICAgaW5pdFBUUzogdm9pZCAwLFxuICAgICAgdGltZXNjYWxlOiB2b2lkIDAsXG4gICAgICB0cmFja0lkOiB2b2lkIDBcbiAgICB9O1xuICAgIGxldCBwID0gdGhpcy5pbml0RGF0YTtcbiAgICBpZiAoKGEgPSBwKSAhPSBudWxsICYmIGEubGVuZ3RoIHx8ICh0aGlzLmdlbmVyYXRlSW5pdFNlZ21lbnQoaCksIHAgPSB0aGlzLmluaXREYXRhKSwgISgobCA9IHApICE9IG51bGwgJiYgbC5sZW5ndGgpKVxuICAgICAgcmV0dXJuIHRoaXMud2FybihcIkZhaWxlZCB0byBnZW5lcmF0ZSBpbml0U2VnbWVudC5cIiksIGQ7XG4gICAgdGhpcy5lbWl0SW5pdFNlZ21lbnQgJiYgKGYudHJhY2tzID0gdGhpcy5pbml0VHJhY2tzLCB0aGlzLmVtaXRJbml0U2VnbWVudCA9ICExKTtcbiAgICBjb25zdCB5ID0gR1MoaCwgcCwgdGhpcyksIEUgPSBwLmF1ZGlvID8geVtwLmF1ZGlvLmlkXSA6IG51bGwsIGIgPSBwLnZpZGVvID8geVtwLnZpZGVvLmlkXSA6IG51bGwsIFIgPSBaaShiLCAxIC8gMCksIEEgPSBaaShFLCAxIC8gMCksIEYgPSBaaShiLCAwLCAhMCksIE0gPSBaaShFLCAwLCAhMCk7XG4gICAgbGV0IEggPSBpLCBLID0gMDtcbiAgICBjb25zdCBqID0gRSAmJiAoIWIgfHwgIWMgJiYgQSA8IFIgfHwgYyAmJiBjLnRyYWNrSWQgPT09IHAuYXVkaW8uaWQpLCBDID0gaiA/IEUgOiBiO1xuICAgIGlmIChDKSB7XG4gICAgICBjb25zdCBPID0gQy50aW1lc2NhbGUsIFUgPSBDLnN0YXJ0IC0gaSAqIE8sIFYgPSBqID8gcC5hdWRpby5pZCA6IHAudmlkZW8uaWQ7XG4gICAgICBIID0gQy5zdGFydCAvIE8sIEsgPSBqID8gTSAtIEEgOiBGIC0gUiwgKG8gfHwgIWMpICYmIChlMihjLCBILCBpLCBLKSB8fCBPICE9PSBjLnRpbWVzY2FsZSkgJiYgKGMgJiYgdGhpcy53YXJuKGBUaW1lc3RhbXBzIGF0IHBsYXlsaXN0IHRpbWU6ICR7byA/IFwiXCIgOiBcIn5cIn0ke2l9ICR7VSAvIE99ICE9IGluaXRQVFM6ICR7Yy5iYXNlVGltZSAvIGMudGltZXNjYWxlfSAoJHtjLmJhc2VUaW1lfS8ke2MudGltZXNjYWxlfSkgdHJhY2tJZDogJHtjLnRyYWNrSWR9YCksIHRoaXMubG9nKGBGb3VuZCBpbml0UFRTIGF0IHBsYXlsaXN0IHRpbWU6ICR7aX0gb2Zmc2V0OiAke0ggLSBpfSAoJHtVfS8ke099KSB0cmFja0lkOiAke1Z9YCksIGMgPSBudWxsLCBmLmluaXRQVFMgPSBVLCBmLnRpbWVzY2FsZSA9IE8sIGYudHJhY2tJZCA9IFYpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy53YXJuKGBObyBhdWRpbyBvciB2aWRlbyBzYW1wbGVzIGZvdW5kIGZvciBpbml0UFRTIGF0IHBsYXlsaXN0IHRpbWU6ICR7aX1gKTtcbiAgICBjID8gKGYuaW5pdFBUUyA9IGMuYmFzZVRpbWUsIGYudGltZXNjYWxlID0gYy50aW1lc2NhbGUsIGYudHJhY2tJZCA9IGMudHJhY2tJZCkgOiAoKCFmLnRpbWVzY2FsZSB8fCBmLnRyYWNrSWQgPT09IHZvaWQgMCB8fCBmLmluaXRQVFMgPT09IHZvaWQgMCkgJiYgKHRoaXMud2FybihcIkNvdWxkIG5vdCBzZXQgaW5pdFBUU1wiKSwgZi5pbml0UFRTID0gSCwgZi50aW1lc2NhbGUgPSAxLCBmLnRyYWNrSWQgPSAtMSksIHRoaXMuaW5pdFBUUyA9IGMgPSB7XG4gICAgICBiYXNlVGltZTogZi5pbml0UFRTLFxuICAgICAgdGltZXNjYWxlOiBmLnRpbWVzY2FsZSxcbiAgICAgIHRyYWNrSWQ6IGYudHJhY2tJZFxuICAgIH0pO1xuICAgIGNvbnN0IGsgPSBIIC0gYy5iYXNlVGltZSAvIGMudGltZXNjYWxlLCAkID0gayArIEs7XG4gICAgSyA+IDAgPyB0aGlzLmxhc3RFbmRUaW1lID0gJCA6ICh0aGlzLndhcm4oXCJEdXJhdGlvbiBwYXJzZWQgZnJvbSBtcDQgc2hvdWxkIGJlIGdyZWF0ZXIgdGhhbiB6ZXJvXCIpLCB0aGlzLnJlc2V0TmV4dFRpbWVzdGFtcCgpKTtcbiAgICBjb25zdCBXID0gISFwLmF1ZGlvLCBfID0gISFwLnZpZGVvO1xuICAgIGxldCBnID0gXCJcIjtcbiAgICBXICYmIChnICs9IFwiYXVkaW9cIiksIF8gJiYgKGcgKz0gXCJ2aWRlb1wiKTtcbiAgICBjb25zdCB4ID0gKHAuYXVkaW8gPyBwLmF1ZGlvLmVuY3J5cHRlZCA6ICExKSB8fCAocC52aWRlbyA/IHAudmlkZW8uZW5jcnlwdGVkIDogITEpLCB3ID0ge1xuICAgICAgZGF0YTE6IGgsXG4gICAgICBzdGFydFBUUzogayxcbiAgICAgIHN0YXJ0RFRTOiBrLFxuICAgICAgZW5kUFRTOiAkLFxuICAgICAgZW5kRFRTOiAkLFxuICAgICAgdHlwZTogZyxcbiAgICAgIGhhc0F1ZGlvOiBXLFxuICAgICAgaGFzVmlkZW86IF8sXG4gICAgICBuYjogMSxcbiAgICAgIGRyb3BwZWQ6IDAsXG4gICAgICBlbmNyeXB0ZWQ6IHhcbiAgICB9O1xuICAgIGQuYXVkaW8gPSBXICYmICFfID8gdyA6IHZvaWQgMCwgZC52aWRlbyA9IF8gPyB3IDogdm9pZCAwO1xuICAgIGNvbnN0IEQgPSBiID09IG51bGwgPyB2b2lkIDAgOiBiLnNhbXBsZUNvdW50O1xuICAgIGlmIChEKSB7XG4gICAgICBjb25zdCBPID0gYi5rZXlGcmFtZUluZGV4LCBVID0gTyAhPT0gLTE7XG4gICAgICB3Lm5iID0gRCwgdy5kcm9wcGVkID0gTyA9PT0gMCB8fCB0aGlzLmlzVmlkZW9Db250aWd1b3VzID8gMCA6IFUgPyBPIDogRCwgdy5pbmRlcGVuZGVudCA9IFUsIHcuZmlyc3RLZXlGcmFtZSA9IE8sIFUgJiYgYi5rZXlGcmFtZVN0YXJ0ICYmICh3LmZpcnN0S2V5RnJhbWVQVFMgPSAoYi5rZXlGcmFtZVN0YXJ0IC0gYy5iYXNlVGltZSkgLyBjLnRpbWVzY2FsZSksIHRoaXMuaXNWaWRlb0NvbnRpZ3VvdXMgfHwgKGQuaW5kZXBlbmRlbnQgPSBVKSwgdGhpcy5pc1ZpZGVvQ29udGlndW91cyB8fCAodGhpcy5pc1ZpZGVvQ29udGlndW91cyA9IFUpLCB3LmRyb3BwZWQgJiYgdGhpcy53YXJuKGBmbXA0IGRvZXMgbm90IHN0YXJ0IHdpdGggSURSOiBmaXJzdElEUiAke099LyR7RH0gZHJvcHBlZDogJHt3LmRyb3BwZWR9IHN0YXJ0OiAke3cuZmlyc3RLZXlGcmFtZVBUUyB8fCBcIk5BXCJ9YCk7XG4gICAgfVxuICAgIHJldHVybiBkLmluaXRTZWdtZW50ID0gZiwgZC5pZDMgPSBicChyLCBpLCBjLCBjKSwgbi5zYW1wbGVzLmxlbmd0aCAmJiAoZC50ZXh0ID0gVHAobiwgaSwgYykpLCBkO1xuICB9XG59XG5mdW5jdGlvbiBaaShzLCBlLCB0ID0gITEpIHtcbiAgcmV0dXJuIChzID09IG51bGwgPyB2b2lkIDAgOiBzLnN0YXJ0KSAhPT0gdm9pZCAwID8gKHMuc3RhcnQgKyAodCA/IHMuZHVyYXRpb24gOiAwKSkgLyBzLnRpbWVzY2FsZSA6IGU7XG59XG5mdW5jdGlvbiBlMihzLCBlLCB0LCByKSB7XG4gIGlmIChzID09PSBudWxsKVxuICAgIHJldHVybiAhMDtcbiAgY29uc3QgbiA9IE1hdGgubWF4KHIsIDEpLCBpID0gZSAtIHMuYmFzZVRpbWUgLyBzLnRpbWVzY2FsZTtcbiAgcmV0dXJuIE1hdGguYWJzKGkgLSB0KSA+IG47XG59XG5mdW5jdGlvbiAkaChzLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSBzLmNvZGVjO1xuICByZXR1cm4gciAmJiByLmxlbmd0aCA+IDQgPyByIDogZSA9PT0gb3QuQVVESU8gPyByID09PSBcImVjLTNcIiB8fCByID09PSBcImFjLTNcIiB8fCByID09PSBcImFsYWNcIiA/IHIgOiByID09PSBcImZMYUNcIiB8fCByID09PSBcIk9wdXNcIiA/IFhvKHIsICExKSA6ICh0Lndhcm4oYFVuaGFuZGxlZCBhdWRpbyBjb2RlYyBcIiR7cn1cIiBpbiBtcDQgTUFQYCksIHIgfHwgXCJtcDRhXCIpIDogKHQud2FybihgVW5oYW5kbGVkIHZpZGVvIGNvZGVjIFwiJHtyfVwiIGluIG1wNCBNQVBgKSwgciB8fCBcImF2YzFcIik7XG59XG5sZXQgbHM7XG50cnkge1xuICBscyA9IHNlbGYucGVyZm9ybWFuY2Uubm93LmJpbmQoc2VsZi5wZXJmb3JtYW5jZSk7XG59IGNhdGNoIHtcbiAgbHMgPSBEYXRlLm5vdztcbn1cbmNvbnN0IHlvID0gW3tcbiAgZGVtdXg6IFVULFxuICByZW11eDogUVRcbn0sIHtcbiAgZGVtdXg6IElzLFxuICByZW11eDogbW9cbn0sIHtcbiAgZGVtdXg6IE9ULFxuICByZW11eDogbW9cbn0sIHtcbiAgZGVtdXg6IEZULFxuICByZW11eDogbW9cbn1dO1xueW8uc3BsaWNlKDIsIDAsIHtcbiAgZGVtdXg6IEJULFxuICByZW11eDogbW9cbn0pO1xuY2xhc3MgR2gge1xuICBjb25zdHJ1Y3RvcihlLCB0LCByLCBuLCBpLCBvKSB7XG4gICAgdGhpcy5hc3luY1Jlc3VsdCA9ICExLCB0aGlzLmxvZ2dlciA9IHZvaWQgMCwgdGhpcy5vYnNlcnZlciA9IHZvaWQgMCwgdGhpcy50eXBlU3VwcG9ydGVkID0gdm9pZCAwLCB0aGlzLmNvbmZpZyA9IHZvaWQgMCwgdGhpcy5pZCA9IHZvaWQgMCwgdGhpcy5kZW11eGVyID0gdm9pZCAwLCB0aGlzLnJlbXV4ZXIgPSB2b2lkIDAsIHRoaXMuZGVjcnlwdGVyID0gdm9pZCAwLCB0aGlzLnByb2JlID0gdm9pZCAwLCB0aGlzLmRlY3J5cHRpb25Qcm9taXNlID0gbnVsbCwgdGhpcy50cmFuc211eENvbmZpZyA9IHZvaWQgMCwgdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZSA9IHZvaWQgMCwgdGhpcy5vYnNlcnZlciA9IGUsIHRoaXMudHlwZVN1cHBvcnRlZCA9IHQsIHRoaXMuY29uZmlnID0gciwgdGhpcy5pZCA9IGksIHRoaXMubG9nZ2VyID0gbztcbiAgfVxuICBjb25maWd1cmUoZSkge1xuICAgIHRoaXMudHJhbnNtdXhDb25maWcgPSBlLCB0aGlzLmRlY3J5cHRlciAmJiB0aGlzLmRlY3J5cHRlci5yZXNldCgpO1xuICB9XG4gIHB1c2goZSwgdCwgciwgbikge1xuICAgIGNvbnN0IGkgPSByLnRyYW5zbXV4aW5nO1xuICAgIGkuZXhlY3V0ZVN0YXJ0ID0gbHMoKTtcbiAgICBsZXQgbyA9IG5ldyBVaW50OEFycmF5KGUpO1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnRUcmFuc211eFN0YXRlOiBhLFxuICAgICAgdHJhbnNtdXhDb25maWc6IGxcbiAgICB9ID0gdGhpcztcbiAgICBuICYmICh0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlID0gbik7XG4gICAgY29uc3Qge1xuICAgICAgY29udGlndW91czogYyxcbiAgICAgIGRpc2NvbnRpbnVpdHk6IHUsXG4gICAgICB0cmFja1N3aXRjaDogZCxcbiAgICAgIGFjY3VyYXRlVGltZU9mZnNldDogaCxcbiAgICAgIHRpbWVPZmZzZXQ6IGYsXG4gICAgICBpbml0U2VnbWVudENoYW5nZTogcFxuICAgIH0gPSBuIHx8IGEsIHtcbiAgICAgIGF1ZGlvQ29kZWM6IHksXG4gICAgICB2aWRlb0NvZGVjOiBFLFxuICAgICAgZGVmYXVsdEluaXRQdHM6IGIsXG4gICAgICBkdXJhdGlvbjogUixcbiAgICAgIGluaXRTZWdtZW50RGF0YTogQVxuICAgIH0gPSBsLCBGID0gdDIobywgdCk7XG4gICAgaWYgKEYgJiYgSW4oRi5tZXRob2QpKSB7XG4gICAgICBjb25zdCBqID0gdGhpcy5nZXREZWNyeXB0ZXIoKSwgQyA9IFN1KEYubWV0aG9kKTtcbiAgICAgIGlmIChqLmlzU3luYygpKSB7XG4gICAgICAgIGxldCBrID0gai5zb2Z0d2FyZURlY3J5cHQobywgRi5rZXkuYnVmZmVyLCBGLml2LmJ1ZmZlciwgQyk7XG4gICAgICAgIGlmIChyLnBhcnQgPiAtMSkge1xuICAgICAgICAgIGNvbnN0IFcgPSBqLmZsdXNoKCk7XG4gICAgICAgICAgayA9IFcgJiYgVy5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFrKVxuICAgICAgICAgIHJldHVybiBpLmV4ZWN1dGVFbmQgPSBscygpLCB4bChyKTtcbiAgICAgICAgbyA9IG5ldyBVaW50OEFycmF5KGspO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJldHVybiB0aGlzLmFzeW5jUmVzdWx0ID0gITAsIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBqLndlYkNyeXB0b0RlY3J5cHQobywgRi5rZXkuYnVmZmVyLCBGLml2LmJ1ZmZlciwgQykudGhlbigoaykgPT4ge1xuICAgICAgICAgIGNvbnN0ICQgPSB0aGlzLnB1c2goaywgbnVsbCwgcik7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVjcnlwdGlvblByb21pc2UgPSBudWxsLCAkO1xuICAgICAgICB9KSwgdGhpcy5kZWNyeXB0aW9uUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgTSA9IHRoaXMubmVlZHNQcm9iaW5nKHUsIGQpO1xuICAgIGlmIChNKSB7XG4gICAgICBjb25zdCBqID0gdGhpcy5jb25maWd1cmVUcmFuc211eGVyKG8pO1xuICAgICAgaWYgKGopXG4gICAgICAgIHJldHVybiB0aGlzLmxvZ2dlci53YXJuKGBbdHJhbnNtdXhlcl0gJHtqLm1lc3NhZ2V9YCksIHRoaXMub2JzZXJ2ZXIuZW1pdChJLkVSUk9SLCBJLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogdmUuTUVESUFfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogSi5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICAgICAgZmF0YWw6ICExLFxuICAgICAgICAgIGVycm9yOiBqLFxuICAgICAgICAgIHJlYXNvbjogai5tZXNzYWdlXG4gICAgICAgIH0pLCBpLmV4ZWN1dGVFbmQgPSBscygpLCB4bChyKTtcbiAgICB9XG4gICAgKHUgfHwgZCB8fCBwIHx8IE0pICYmIHRoaXMucmVzZXRJbml0U2VnbWVudChBLCB5LCBFLCBSLCB0KSwgKHUgfHwgcCB8fCBNKSAmJiB0aGlzLnJlc2V0SW5pdGlhbFRpbWVzdGFtcChiKSwgYyB8fCB0aGlzLnJlc2V0Q29udGlndWl0eSgpO1xuICAgIGNvbnN0IEggPSB0aGlzLnRyYW5zbXV4KG8sIEYsIGYsIGgsIHIpO1xuICAgIHRoaXMuYXN5bmNSZXN1bHQgPSB4aShIKTtcbiAgICBjb25zdCBLID0gdGhpcy5jdXJyZW50VHJhbnNtdXhTdGF0ZTtcbiAgICByZXR1cm4gSy5jb250aWd1b3VzID0gITAsIEsuZGlzY29udGludWl0eSA9ICExLCBLLnRyYWNrU3dpdGNoID0gITEsIGkuZXhlY3V0ZUVuZCA9IGxzKCksIEg7XG4gIH1cbiAgLy8gRHVlIHRvIGRhdGEgY2FjaGluZywgZmx1c2ggY2FsbHMgY2FuIHByb2R1Y2UgbW9yZSB0aGFuIG9uZSBUcmFuc211eGVyUmVzdWx0IChoZW5jZSB0aGUgQXJyYXkgdHlwZSlcbiAgZmx1c2goZSkge1xuICAgIGNvbnN0IHQgPSBlLnRyYW5zbXV4aW5nO1xuICAgIHQuZXhlY3V0ZVN0YXJ0ID0gbHMoKTtcbiAgICBjb25zdCB7XG4gICAgICBkZWNyeXB0ZXI6IHIsXG4gICAgICBjdXJyZW50VHJhbnNtdXhTdGF0ZTogbixcbiAgICAgIGRlY3J5cHRpb25Qcm9taXNlOiBpXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGkpXG4gICAgICByZXR1cm4gdGhpcy5hc3luY1Jlc3VsdCA9ICEwLCBpLnRoZW4oKCkgPT4gdGhpcy5mbHVzaChlKSk7XG4gICAgY29uc3QgbyA9IFtdLCB7XG4gICAgICB0aW1lT2Zmc2V0OiBhXG4gICAgfSA9IG47XG4gICAgaWYgKHIpIHtcbiAgICAgIGNvbnN0IGQgPSByLmZsdXNoKCk7XG4gICAgICBkICYmIG8ucHVzaCh0aGlzLnB1c2goZC5idWZmZXIsIG51bGwsIGUpKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGVtdXhlcjogbCxcbiAgICAgIHJlbXV4ZXI6IGNcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWwgfHwgIWMpIHtcbiAgICAgIHQuZXhlY3V0ZUVuZCA9IGxzKCk7XG4gICAgICBjb25zdCBkID0gW3hsKGUpXTtcbiAgICAgIHJldHVybiB0aGlzLmFzeW5jUmVzdWx0ID8gUHJvbWlzZS5yZXNvbHZlKGQpIDogZDtcbiAgICB9XG4gICAgY29uc3QgdSA9IGwuZmx1c2goYSk7XG4gICAgcmV0dXJuIHhpKHUpID8gKHRoaXMuYXN5bmNSZXN1bHQgPSAhMCwgdS50aGVuKChkKSA9PiAodGhpcy5mbHVzaFJlbXV4KG8sIGQsIGUpLCBvKSkpIDogKHRoaXMuZmx1c2hSZW11eChvLCB1LCBlKSwgdGhpcy5hc3luY1Jlc3VsdCA/IFByb21pc2UucmVzb2x2ZShvKSA6IG8pO1xuICB9XG4gIGZsdXNoUmVtdXgoZSwgdCwgcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGF1ZGlvVHJhY2s6IG4sXG4gICAgICB2aWRlb1RyYWNrOiBpLFxuICAgICAgaWQzVHJhY2s6IG8sXG4gICAgICB0ZXh0VHJhY2s6IGFcbiAgICB9ID0gdCwge1xuICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0OiBsLFxuICAgICAgdGltZU9mZnNldDogY1xuICAgIH0gPSB0aGlzLmN1cnJlbnRUcmFuc211eFN0YXRlO1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgW3RyYW5zbXV4ZXIudHNdOiBGbHVzaGVkICR7dGhpcy5pZH0gc246ICR7ci5zbn0ke3IucGFydCA+IC0xID8gXCIgcGFydDogXCIgKyByLnBhcnQgOiBcIlwifSBvZiAke3RoaXMuaWQgPT09IHBlLk1BSU4gPyBcImxldmVsXCIgOiBcInRyYWNrXCJ9ICR7ci5sZXZlbH1gKTtcbiAgICBjb25zdCB1ID0gdGhpcy5yZW11eGVyLnJlbXV4KG4sIGksIG8sIGEsIGMsIGwsICEwLCB0aGlzLmlkKTtcbiAgICBlLnB1c2goe1xuICAgICAgcmVtdXhSZXN1bHQ6IHUsXG4gICAgICBjaHVua01ldGE6IHJcbiAgICB9KSwgci50cmFuc211eGluZy5leGVjdXRlRW5kID0gbHMoKTtcbiAgfVxuICByZXNldEluaXRpYWxUaW1lc3RhbXAoZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRlbXV4ZXI6IHQsXG4gICAgICByZW11eGVyOiByXG4gICAgfSA9IHRoaXM7XG4gICAgIXQgfHwgIXIgfHwgKHQucmVzZXRUaW1lU3RhbXAoZSksIHIucmVzZXRUaW1lU3RhbXAoZSkpO1xuICB9XG4gIHJlc2V0Q29udGlndWl0eSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBkZW11eGVyOiBlLFxuICAgICAgcmVtdXhlcjogdFxuICAgIH0gPSB0aGlzO1xuICAgICFlIHx8ICF0IHx8IChlLnJlc2V0Q29udGlndWl0eSgpLCB0LnJlc2V0TmV4dFRpbWVzdGFtcCgpKTtcbiAgfVxuICByZXNldEluaXRTZWdtZW50KGUsIHQsIHIsIG4sIGkpIHtcbiAgICBjb25zdCB7XG4gICAgICBkZW11eGVyOiBvLFxuICAgICAgcmVtdXhlcjogYVxuICAgIH0gPSB0aGlzO1xuICAgICFvIHx8ICFhIHx8IChvLnJlc2V0SW5pdFNlZ21lbnQoZSwgdCwgciwgbiksIGEucmVzZXRJbml0U2VnbWVudChlLCB0LCByLCBpKSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlbXV4ZXIgJiYgKHRoaXMuZGVtdXhlci5kZXN0cm95KCksIHRoaXMuZGVtdXhlciA9IHZvaWQgMCksIHRoaXMucmVtdXhlciAmJiAodGhpcy5yZW11eGVyLmRlc3Ryb3koKSwgdGhpcy5yZW11eGVyID0gdm9pZCAwKTtcbiAgfVxuICB0cmFuc211eChlLCB0LCByLCBuLCBpKSB7XG4gICAgbGV0IG87XG4gICAgcmV0dXJuIHQgJiYgdC5tZXRob2QgPT09IFwiU0FNUExFLUFFU1wiID8gbyA9IHRoaXMudHJhbnNtdXhTYW1wbGVBZXMoZSwgdCwgciwgbiwgaSkgOiBvID0gdGhpcy50cmFuc211eFVuZW5jcnlwdGVkKGUsIHIsIG4sIGkpLCBvO1xuICB9XG4gIHRyYW5zbXV4VW5lbmNyeXB0ZWQoZSwgdCwgciwgbikge1xuICAgIGNvbnN0IHtcbiAgICAgIGF1ZGlvVHJhY2s6IGksXG4gICAgICB2aWRlb1RyYWNrOiBvLFxuICAgICAgaWQzVHJhY2s6IGEsXG4gICAgICB0ZXh0VHJhY2s6IGxcbiAgICB9ID0gdGhpcy5kZW11eGVyLmRlbXV4KGUsIHQsICExLCAhdGhpcy5jb25maWcucHJvZ3Jlc3NpdmUpO1xuICAgIHJldHVybiB7XG4gICAgICByZW11eFJlc3VsdDogdGhpcy5yZW11eGVyLnJlbXV4KGksIG8sIGEsIGwsIHQsIHIsICExLCB0aGlzLmlkKSxcbiAgICAgIGNodW5rTWV0YTogblxuICAgIH07XG4gIH1cbiAgdHJhbnNtdXhTYW1wbGVBZXMoZSwgdCwgciwgbiwgaSkge1xuICAgIHJldHVybiB0aGlzLmRlbXV4ZXIuZGVtdXhTYW1wbGVBZXMoZSwgdCwgcikudGhlbigobykgPT4gKHtcbiAgICAgIHJlbXV4UmVzdWx0OiB0aGlzLnJlbXV4ZXIucmVtdXgoby5hdWRpb1RyYWNrLCBvLnZpZGVvVHJhY2ssIG8uaWQzVHJhY2ssIG8udGV4dFRyYWNrLCByLCBuLCAhMSwgdGhpcy5pZCksXG4gICAgICBjaHVua01ldGE6IGlcbiAgICB9KSk7XG4gIH1cbiAgY29uZmlndXJlVHJhbnNtdXhlcihlKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnOiB0LFxuICAgICAgb2JzZXJ2ZXI6IHIsXG4gICAgICB0eXBlU3VwcG9ydGVkOiBuXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IGk7XG4gICAgZm9yIChsZXQgZCA9IDAsIGggPSB5by5sZW5ndGg7IGQgPCBoOyBkKyspIHtcbiAgICAgIHZhciBvO1xuICAgICAgaWYgKChvID0geW9bZF0uZGVtdXgpICE9IG51bGwgJiYgby5wcm9iZShlLCB0aGlzLmxvZ2dlcikpIHtcbiAgICAgICAgaSA9IHlvW2RdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFpKVxuICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkZhaWxlZCB0byBmaW5kIGRlbXV4ZXIgYnkgcHJvYmluZyBmcmFnbWVudCBkYXRhXCIpO1xuICAgIGNvbnN0IGEgPSB0aGlzLmRlbXV4ZXIsIGwgPSB0aGlzLnJlbXV4ZXIsIGMgPSBpLnJlbXV4LCB1ID0gaS5kZW11eDtcbiAgICAoIWwgfHwgIShsIGluc3RhbmNlb2YgYykpICYmICh0aGlzLnJlbXV4ZXIgPSBuZXcgYyhyLCB0LCBuLCB0aGlzLmxvZ2dlcikpLCAoIWEgfHwgIShhIGluc3RhbmNlb2YgdSkpICYmICh0aGlzLmRlbXV4ZXIgPSBuZXcgdShyLCB0LCBuLCB0aGlzLmxvZ2dlciksIHRoaXMucHJvYmUgPSB1LnByb2JlKTtcbiAgfVxuICBuZWVkc1Byb2JpbmcoZSwgdCkge1xuICAgIHJldHVybiAhdGhpcy5kZW11eGVyIHx8ICF0aGlzLnJlbXV4ZXIgfHwgZSB8fCB0O1xuICB9XG4gIGdldERlY3J5cHRlcigpIHtcbiAgICBsZXQgZSA9IHRoaXMuZGVjcnlwdGVyO1xuICAgIHJldHVybiBlIHx8IChlID0gdGhpcy5kZWNyeXB0ZXIgPSBuZXcgdnUodGhpcy5jb25maWcpKSwgZTtcbiAgfVxufVxuZnVuY3Rpb24gdDIocywgZSkge1xuICBsZXQgdCA9IG51bGw7XG4gIHJldHVybiBzLmJ5dGVMZW5ndGggPiAwICYmIChlID09IG51bGwgPyB2b2lkIDAgOiBlLmtleSkgIT0gbnVsbCAmJiBlLml2ICE9PSBudWxsICYmIGUubWV0aG9kICE9IG51bGwgJiYgKHQgPSBlKSwgdDtcbn1cbmNvbnN0IHhsID0gKHMpID0+ICh7XG4gIHJlbXV4UmVzdWx0OiB7fSxcbiAgY2h1bmtNZXRhOiBzXG59KTtcbmZ1bmN0aW9uIHhpKHMpIHtcbiAgcmV0dXJuIFwidGhlblwiIGluIHMgJiYgcy50aGVuIGluc3RhbmNlb2YgRnVuY3Rpb247XG59XG5jbGFzcyByMiB7XG4gIGNvbnN0cnVjdG9yKGUsIHQsIHIsIG4sIGkpIHtcbiAgICB0aGlzLmF1ZGlvQ29kZWMgPSB2b2lkIDAsIHRoaXMudmlkZW9Db2RlYyA9IHZvaWQgMCwgdGhpcy5pbml0U2VnbWVudERhdGEgPSB2b2lkIDAsIHRoaXMuZHVyYXRpb24gPSB2b2lkIDAsIHRoaXMuZGVmYXVsdEluaXRQdHMgPSB2b2lkIDAsIHRoaXMuYXVkaW9Db2RlYyA9IGUsIHRoaXMudmlkZW9Db2RlYyA9IHQsIHRoaXMuaW5pdFNlZ21lbnREYXRhID0gciwgdGhpcy5kdXJhdGlvbiA9IG4sIHRoaXMuZGVmYXVsdEluaXRQdHMgPSBpIHx8IG51bGw7XG4gIH1cbn1cbmNsYXNzIHMyIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgciwgbiwgaSwgbykge1xuICAgIHRoaXMuZGlzY29udGludWl0eSA9IHZvaWQgMCwgdGhpcy5jb250aWd1b3VzID0gdm9pZCAwLCB0aGlzLmFjY3VyYXRlVGltZU9mZnNldCA9IHZvaWQgMCwgdGhpcy50cmFja1N3aXRjaCA9IHZvaWQgMCwgdGhpcy50aW1lT2Zmc2V0ID0gdm9pZCAwLCB0aGlzLmluaXRTZWdtZW50Q2hhbmdlID0gdm9pZCAwLCB0aGlzLmRpc2NvbnRpbnVpdHkgPSBlLCB0aGlzLmNvbnRpZ3VvdXMgPSB0LCB0aGlzLmFjY3VyYXRlVGltZU9mZnNldCA9IHIsIHRoaXMudHJhY2tTd2l0Y2ggPSBuLCB0aGlzLnRpbWVPZmZzZXQgPSBpLCB0aGlzLmluaXRTZWdtZW50Q2hhbmdlID0gbztcbiAgfVxufVxubGV0IFZoID0gMDtcbmNsYXNzIHdwIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgciwgbikge1xuICAgIHRoaXMuZXJyb3IgPSBudWxsLCB0aGlzLmhscyA9IHZvaWQgMCwgdGhpcy5pZCA9IHZvaWQgMCwgdGhpcy5pbnN0YW5jZU5vID0gVmgrKywgdGhpcy5vYnNlcnZlciA9IHZvaWQgMCwgdGhpcy5mcmFnID0gbnVsbCwgdGhpcy5wYXJ0ID0gbnVsbCwgdGhpcy51c2VXb3JrZXIgPSB2b2lkIDAsIHRoaXMud29ya2VyQ29udGV4dCA9IG51bGwsIHRoaXMudHJhbnNtdXhlciA9IG51bGwsIHRoaXMub25UcmFuc211eENvbXBsZXRlID0gdm9pZCAwLCB0aGlzLm9uRmx1c2ggPSB2b2lkIDAsIHRoaXMub25Xb3JrZXJNZXNzYWdlID0gKGwpID0+IHtcbiAgICAgIGNvbnN0IGMgPSBsLmRhdGEsIHUgPSB0aGlzLmhscztcbiAgICAgIGlmICghKCF1IHx8ICEoYyAhPSBudWxsICYmIGMuZXZlbnQpIHx8IGMuaW5zdGFuY2VObyAhPT0gdGhpcy5pbnN0YW5jZU5vKSlcbiAgICAgICAgc3dpdGNoIChjLmV2ZW50KSB7XG4gICAgICAgICAgY2FzZSBcImluaXRcIjoge1xuICAgICAgICAgICAgdmFyIGQ7XG4gICAgICAgICAgICBjb25zdCBoID0gKGQgPSB0aGlzLndvcmtlckNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBkLm9iamVjdFVSTDtcbiAgICAgICAgICAgIGggJiYgc2VsZi5VUkwucmV2b2tlT2JqZWN0VVJMKGgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ0cmFuc211eENvbXBsZXRlXCI6IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShjLmRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJmbHVzaFwiOiB7XG4gICAgICAgICAgICB0aGlzLm9uRmx1c2goYy5kYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBwYXNzIGxvZ3MgZnJvbSB0aGUgd29ya2VyIHRocmVhZCB0byB0aGUgbWFpbiBsb2dnZXJcbiAgICAgICAgICBjYXNlIFwid29ya2VyTG9nXCI6IHtcbiAgICAgICAgICAgIHUubG9nZ2VyW2MuZGF0YS5sb2dUeXBlXSAmJiB1LmxvZ2dlcltjLmRhdGEubG9nVHlwZV0oYy5kYXRhLm1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGMuZGF0YSA9IGMuZGF0YSB8fCB7fSwgYy5kYXRhLmZyYWcgPSB0aGlzLmZyYWcsIGMuZGF0YS5wYXJ0ID0gdGhpcy5wYXJ0LCBjLmRhdGEuaWQgPSB0aGlzLmlkLCB1LnRyaWdnZXIoYy5ldmVudCwgYy5kYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHRoaXMub25Xb3JrZXJFcnJvciA9IChsKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuaGxzKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBjID0gbmV3IEVycm9yKGAke2wubWVzc2FnZX0gICgke2wuZmlsZW5hbWV9OiR7bC5saW5lbm99KWApO1xuICAgICAgdGhpcy5obHMuY29uZmlnLmVuYWJsZVdvcmtlciA9ICExLCB0aGlzLmhscy5sb2dnZXIud2FybihgRXJyb3IgaW4gXCIke3RoaXMuaWR9XCIgV2ViIFdvcmtlciwgZmFsbGJhY2sgdG8gaW5saW5lYCksIHRoaXMuaGxzLnRyaWdnZXIoSS5FUlJPUiwge1xuICAgICAgICB0eXBlOiB2ZS5PVEhFUl9FUlJPUixcbiAgICAgICAgZGV0YWlsczogSi5JTlRFUk5BTF9FWENFUFRJT04sXG4gICAgICAgIGZhdGFsOiAhMSxcbiAgICAgICAgZXZlbnQ6IFwiZGVtdXhlcldvcmtlclwiLFxuICAgICAgICBlcnJvcjogY1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpID0gZS5jb25maWc7XG4gICAgdGhpcy5obHMgPSBlLCB0aGlzLmlkID0gdCwgdGhpcy51c2VXb3JrZXIgPSAhIWkuZW5hYmxlV29ya2VyLCB0aGlzLm9uVHJhbnNtdXhDb21wbGV0ZSA9IHIsIHRoaXMub25GbHVzaCA9IG47XG4gICAgY29uc3QgbyA9IChsLCBjKSA9PiB7XG4gICAgICBjID0gYyB8fCB7fSwgYy5mcmFnID0gdGhpcy5mcmFnIHx8IHZvaWQgMCwgbCA9PT0gSS5FUlJPUiAmJiAoYyA9IGMsIGMucGFyZW50ID0gdGhpcy5pZCwgYy5wYXJ0ID0gdGhpcy5wYXJ0LCB0aGlzLmVycm9yID0gYy5lcnJvciksIHRoaXMuaGxzLnRyaWdnZXIobCwgYyk7XG4gICAgfTtcbiAgICB0aGlzLm9ic2VydmVyID0gbmV3IHd1KCksIHRoaXMub2JzZXJ2ZXIub24oSS5GUkFHX0RFQ1JZUFRFRCwgbyksIHRoaXMub2JzZXJ2ZXIub24oSS5FUlJPUiwgbyk7XG4gICAgY29uc3QgYSA9IGloKGkucHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKTtcbiAgICBpZiAodGhpcy51c2VXb3JrZXIgJiYgdHlwZW9mIFdvcmtlciA8IFwidVwiKSB7XG4gICAgICBjb25zdCBsID0gdGhpcy5obHMubG9nZ2VyO1xuICAgICAgaWYgKGkud29ya2VyUGF0aCB8fCBhVCgpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaS53b3JrZXJQYXRoID8gKGwubG9nKGBsb2FkaW5nIFdlYiBXb3JrZXIgJHtpLndvcmtlclBhdGh9IGZvciBcIiR7dH1cImApLCB0aGlzLndvcmtlckNvbnRleHQgPSBjVChpLndvcmtlclBhdGgpKSA6IChsLmxvZyhgaW5qZWN0aW5nIFdlYiBXb3JrZXIgZm9yIFwiJHt0fVwiYCksIHRoaXMud29ya2VyQ29udGV4dCA9IGxUKCkpO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHdvcmtlcjogdVxuICAgICAgICAgIH0gPSB0aGlzLndvcmtlckNvbnRleHQ7XG4gICAgICAgICAgdS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLm9uV29ya2VyTWVzc2FnZSksIHUuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMub25Xb3JrZXJFcnJvciksIHUucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgaW5zdGFuY2VObzogdGhpcy5pbnN0YW5jZU5vLFxuICAgICAgICAgICAgY21kOiBcImluaXRcIixcbiAgICAgICAgICAgIHR5cGVTdXBwb3J0ZWQ6IGEsXG4gICAgICAgICAgICBpZDogdCxcbiAgICAgICAgICAgIGNvbmZpZzogYXQoaSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBjYXRjaCAodSkge1xuICAgICAgICAgIGwud2FybihgRXJyb3Igc2V0dGluZyB1cCBcIiR7dH1cIiBXZWIgV29ya2VyLCBmYWxsYmFjayB0byBpbmxpbmVgLCB1KSwgdGhpcy50ZXJtaW5hdGVXb3JrZXIoKSwgdGhpcy5lcnJvciA9IG51bGwsIHRoaXMudHJhbnNtdXhlciA9IG5ldyBHaCh0aGlzLm9ic2VydmVyLCBhLCBpLCBcIlwiLCB0LCBlLmxvZ2dlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRyYW5zbXV4ZXIgPSBuZXcgR2godGhpcy5vYnNlcnZlciwgYSwgaSwgXCJcIiwgdCwgZS5sb2dnZXIpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIGlmICh0aGlzLmZyYWcgPSBudWxsLCB0aGlzLnBhcnQgPSBudWxsLCB0aGlzLndvcmtlckNvbnRleHQpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLmluc3RhbmNlTm87XG4gICAgICB0aGlzLmluc3RhbmNlTm8gPSBWaCsrO1xuICAgICAgY29uc3QgdCA9IHRoaXMuaGxzLmNvbmZpZywgciA9IGloKHQucHJlZmVyTWFuYWdlZE1lZGlhU291cmNlKTtcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dC53b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBpbnN0YW5jZU5vOiB0aGlzLmluc3RhbmNlTm8sXG4gICAgICAgIGNtZDogXCJyZXNldFwiLFxuICAgICAgICByZXNldE5vOiBlLFxuICAgICAgICB0eXBlU3VwcG9ydGVkOiByLFxuICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgY29uZmlnOiBhdCh0KVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHRlcm1pbmF0ZVdvcmtlcigpIHtcbiAgICBpZiAodGhpcy53b3JrZXJDb250ZXh0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdvcmtlcjogZVxuICAgICAgfSA9IHRoaXMud29ya2VyQ29udGV4dDtcbiAgICAgIHRoaXMud29ya2VyQ29udGV4dCA9IG51bGwsIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5vbldvcmtlck1lc3NhZ2UpLCBlLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLm9uV29ya2VyRXJyb3IpLCB1VCh0aGlzLmhscy5jb25maWcud29ya2VyUGF0aCk7XG4gICAgfVxuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMud29ya2VyQ29udGV4dClcbiAgICAgIHRoaXMudGVybWluYXRlV29ya2VyKCksIHRoaXMub25Xb3JrZXJNZXNzYWdlID0gdGhpcy5vbldvcmtlckVycm9yID0gbnVsbDtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLnRyYW5zbXV4ZXI7XG4gICAgICB0ICYmICh0LmRlc3Ryb3koKSwgdGhpcy50cmFuc211eGVyID0gbnVsbCk7XG4gICAgfVxuICAgIGNvbnN0IGUgPSB0aGlzLm9ic2VydmVyO1xuICAgIGUgJiYgZS5yZW1vdmVBbGxMaXN0ZW5lcnMoKSwgdGhpcy5mcmFnID0gbnVsbCwgdGhpcy5wYXJ0ID0gbnVsbCwgdGhpcy5vYnNlcnZlciA9IG51bGwsIHRoaXMuaGxzID0gbnVsbDtcbiAgfVxuICBwdXNoKGUsIHQsIHIsIG4sIGksIG8sIGEsIGwsIGMsIHUpIHtcbiAgICB2YXIgZCwgaDtcbiAgICBjLnRyYW5zbXV4aW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCB7XG4gICAgICBpbnN0YW5jZU5vOiBmLFxuICAgICAgdHJhbnNtdXhlcjogcFxuICAgIH0gPSB0aGlzLCB5ID0gbyA/IG8uc3RhcnQgOiBpLnN0YXJ0LCBFID0gaS5kZWNyeXB0ZGF0YSwgYiA9IHRoaXMuZnJhZywgUiA9ICEoYiAmJiBpLmNjID09PSBiLmNjKSwgQSA9ICEoYiAmJiBjLmxldmVsID09PSBiLmxldmVsKSwgRiA9IGIgPyBjLnNuIC0gYi5zbiA6IC0xLCBNID0gdGhpcy5wYXJ0ID8gYy5wYXJ0IC0gdGhpcy5wYXJ0LmluZGV4IDogLTEsIEggPSBGID09PSAwICYmIGMuaWQgPiAxICYmIGMuaWQgPT09IChiID09IG51bGwgPyB2b2lkIDAgOiBiLnN0YXRzLmNodW5rQ291bnQpLCBLID0gIUEgJiYgKEYgPT09IDEgfHwgRiA9PT0gMCAmJiAoTSA9PT0gMSB8fCBIICYmIE0gPD0gMCkpLCBqID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAoQSB8fCBGIHx8IGkuc3RhdHMucGFyc2luZy5zdGFydCA9PT0gMCkgJiYgKGkuc3RhdHMucGFyc2luZy5zdGFydCA9IGopLCBvICYmIChNIHx8ICFLKSAmJiAoby5zdGF0cy5wYXJzaW5nLnN0YXJ0ID0gaik7XG4gICAgY29uc3QgQyA9ICEoYiAmJiAoKGQgPSBpLmluaXRTZWdtZW50KSA9PSBudWxsID8gdm9pZCAwIDogZC51cmwpID09PSAoKGggPSBiLmluaXRTZWdtZW50KSA9PSBudWxsID8gdm9pZCAwIDogaC51cmwpKSwgayA9IG5ldyBzMihSLCBLLCBsLCBBLCB5LCBDKTtcbiAgICBpZiAoIUsgfHwgUiB8fCBDKSB7XG4gICAgICB0aGlzLmhscy5sb2dnZXIubG9nKGBbdHJhbnNtdXhlci1pbnRlcmZhY2VdOiBTdGFydGluZyBuZXcgdHJhbnNtdXggc2Vzc2lvbiBmb3IgJHtpLnR5cGV9IHNuOiAke2Muc259JHtjLnBhcnQgPiAtMSA/IFwiIHBhcnQ6IFwiICsgYy5wYXJ0IDogXCJcIn0gJHt0aGlzLmlkID09PSBwZS5NQUlOID8gXCJsZXZlbFwiIDogXCJ0cmFja1wifTogJHtjLmxldmVsfSBpZDogJHtjLmlkfVxuICAgICAgICBkaXNjb250aW51aXR5OiAke1J9XG4gICAgICAgIHRyYWNrU3dpdGNoOiAke0F9XG4gICAgICAgIGNvbnRpZ3VvdXM6ICR7S31cbiAgICAgICAgYWNjdXJhdGVUaW1lT2Zmc2V0OiAke2x9XG4gICAgICAgIHRpbWVPZmZzZXQ6ICR7eX1cbiAgICAgICAgaW5pdFNlZ21lbnRDaGFuZ2U6ICR7Q31gKTtcbiAgICAgIGNvbnN0ICQgPSBuZXcgcjIociwgbiwgdCwgYSwgdSk7XG4gICAgICB0aGlzLmNvbmZpZ3VyZVRyYW5zbXV4ZXIoJCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmZyYWcgPSBpLCB0aGlzLnBhcnQgPSBvLCB0aGlzLndvcmtlckNvbnRleHQpXG4gICAgICB0aGlzLndvcmtlckNvbnRleHQud29ya2VyLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgaW5zdGFuY2VObzogZixcbiAgICAgICAgY21kOiBcImRlbXV4XCIsXG4gICAgICAgIGRhdGE6IGUsXG4gICAgICAgIGRlY3J5cHRkYXRhOiBFLFxuICAgICAgICBjaHVua01ldGE6IGMsXG4gICAgICAgIHN0YXRlOiBrXG4gICAgICB9LCBlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBbZV0gOiBbXSk7XG4gICAgZWxzZSBpZiAocCkge1xuICAgICAgY29uc3QgJCA9IHAucHVzaChlLCBFLCBjLCBrKTtcbiAgICAgIHhpKCQpID8gJC50aGVuKChXKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShXKTtcbiAgICAgIH0pLmNhdGNoKChXKSA9PiB7XG4gICAgICAgIHRoaXMudHJhbnNtdXhlckVycm9yKFcsIGMsIFwidHJhbnNtdXhlci1pbnRlcmZhY2UgcHVzaCBlcnJvclwiKTtcbiAgICAgIH0pIDogdGhpcy5oYW5kbGVUcmFuc211eENvbXBsZXRlKCQpO1xuICAgIH1cbiAgfVxuICBmbHVzaChlKSB7XG4gICAgZS50cmFuc211eGluZy5zdGFydCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc3Qge1xuICAgICAgaW5zdGFuY2VObzogdCxcbiAgICAgIHRyYW5zbXV4ZXI6IHJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAodGhpcy53b3JrZXJDb250ZXh0KVxuICAgICAgdGhpcy53b3JrZXJDb250ZXh0Lndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIGluc3RhbmNlTm86IHQsXG4gICAgICAgIGNtZDogXCJmbHVzaFwiLFxuICAgICAgICBjaHVua01ldGE6IGVcbiAgICAgIH0pO1xuICAgIGVsc2UgaWYgKHIpIHtcbiAgICAgIGNvbnN0IG4gPSByLmZsdXNoKGUpO1xuICAgICAgeGkobikgPyBuLnRoZW4oKGkpID0+IHtcbiAgICAgICAgdGhpcy5oYW5kbGVGbHVzaFJlc3VsdChpLCBlKTtcbiAgICAgIH0pLmNhdGNoKChpKSA9PiB7XG4gICAgICAgIHRoaXMudHJhbnNtdXhlckVycm9yKGksIGUsIFwidHJhbnNtdXhlci1pbnRlcmZhY2UgZmx1c2ggZXJyb3JcIik7XG4gICAgICB9KSA6IHRoaXMuaGFuZGxlRmx1c2hSZXN1bHQobiwgZSk7XG4gICAgfVxuICB9XG4gIHRyYW5zbXV4ZXJFcnJvcihlLCB0LCByKSB7XG4gICAgdGhpcy5obHMgJiYgKHRoaXMuZXJyb3IgPSBlLCB0aGlzLmhscy50cmlnZ2VyKEkuRVJST1IsIHtcbiAgICAgIHR5cGU6IHZlLk1FRElBX0VSUk9SLFxuICAgICAgZGV0YWlsczogSi5GUkFHX1BBUlNJTkdfRVJST1IsXG4gICAgICBjaHVua01ldGE6IHQsXG4gICAgICBmcmFnOiB0aGlzLmZyYWcgfHwgdm9pZCAwLFxuICAgICAgcGFydDogdGhpcy5wYXJ0IHx8IHZvaWQgMCxcbiAgICAgIGZhdGFsOiAhMSxcbiAgICAgIGVycm9yOiBlLFxuICAgICAgZXJyOiBlLFxuICAgICAgcmVhc29uOiByXG4gICAgfSkpO1xuICB9XG4gIGhhbmRsZUZsdXNoUmVzdWx0KGUsIHQpIHtcbiAgICBlLmZvckVhY2goKHIpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShyKTtcbiAgICB9KSwgdGhpcy5vbkZsdXNoKHQpO1xuICB9XG4gIGNvbmZpZ3VyZVRyYW5zbXV4ZXIoZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGluc3RhbmNlTm86IHQsXG4gICAgICB0cmFuc211eGVyOiByXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy53b3JrZXJDb250ZXh0ID8gdGhpcy53b3JrZXJDb250ZXh0Lndvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICBpbnN0YW5jZU5vOiB0LFxuICAgICAgY21kOiBcImNvbmZpZ3VyZVwiLFxuICAgICAgY29uZmlnOiBlXG4gICAgfSkgOiByICYmIHIuY29uZmlndXJlKGUpO1xuICB9XG4gIGhhbmRsZVRyYW5zbXV4Q29tcGxldGUoZSkge1xuICAgIGUuY2h1bmtNZXRhLnRyYW5zbXV4aW5nLmVuZCA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHRoaXMub25UcmFuc211eENvbXBsZXRlKGUpO1xuICB9XG59XG5jb25zdCBqaCA9IDEwMDtcbmNsYXNzIG4yIGV4dGVuZHMgVHUge1xuICBjb25zdHJ1Y3RvcihlLCB0LCByKSB7XG4gICAgc3VwZXIoZSwgdCwgciwgXCJhdWRpby1zdHJlYW0tY29udHJvbGxlclwiLCBwZS5BVURJTyksIHRoaXMubWFpbkFuY2hvciA9IG51bGwsIHRoaXMubWFpbkZyYWdMb2FkaW5nID0gbnVsbCwgdGhpcy5hdWRpb09ubHkgPSAhMSwgdGhpcy5idWZmZXJlZFRyYWNrID0gbnVsbCwgdGhpcy5zd2l0Y2hpbmdUcmFjayA9IG51bGwsIHRoaXMudHJhY2tJZCA9IC0xLCB0aGlzLndhaXRpbmdEYXRhID0gbnVsbCwgdGhpcy5tYWluRGV0YWlscyA9IG51bGwsIHRoaXMuZmx1c2hpbmcgPSAhMSwgdGhpcy5idWZmZXJGbHVzaGVkID0gITEsIHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gbnVsbCwgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIG9uSGFuZGxlckRlc3Ryb3lpbmcoKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCksIHN1cGVyLm9uSGFuZGxlckRlc3Ryb3lpbmcoKSwgdGhpcy5yZXNldEl0ZW0oKTtcbiAgfVxuICByZXNldEl0ZW0oKSB7XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IHRoaXMubWFpbkFuY2hvciA9IHRoaXMubWFpbkZyYWdMb2FkaW5nID0gdGhpcy5idWZmZXJlZFRyYWNrID0gdGhpcy5zd2l0Y2hpbmdUcmFjayA9IHRoaXMud2FpdGluZ0RhdGEgPSB0aGlzLmNhY2hlZFRyYWNrTG9hZGVkRGF0YSA9IG51bGw7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgc3VwZXIucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgICBjb25zdCB7XG4gICAgICBobHM6IGVcbiAgICB9ID0gdGhpcztcbiAgICBlLm9uKEkuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpLCBlLm9uKEkuQVVESU9fVFJBQ0tTX1VQREFURUQsIHRoaXMub25BdWRpb1RyYWNrc1VwZGF0ZWQsIHRoaXMpLCBlLm9uKEkuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZywgdGhpcyksIGUub24oSS5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKSwgZS5vbihJLkJVRkZFUl9SRVNFVCwgdGhpcy5vbkJ1ZmZlclJlc2V0LCB0aGlzKSwgZS5vbihJLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyksIGUub24oSS5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyksIGUub24oSS5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpLCBlLm9uKEkuSU5JVF9QVFNfRk9VTkQsIHRoaXMub25Jbml0UHRzRm91bmQsIHRoaXMpLCBlLm9uKEkuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpLCBlLm9uKEkuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHM6IGVcbiAgICB9ID0gdGhpcztcbiAgICBlICYmIChzdXBlci51bnJlZ2lzdGVyTGlzdGVuZXJzKCksIGUub2ZmKEkuTEVWRUxfTE9BREVELCB0aGlzLm9uTGV2ZWxMb2FkZWQsIHRoaXMpLCBlLm9mZihJLkFVRElPX1RSQUNLU19VUERBVEVELCB0aGlzLm9uQXVkaW9UcmFja3NVcGRhdGVkLCB0aGlzKSwgZS5vZmYoSS5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKSwgZS5vZmYoSS5BVURJT19UUkFDS19MT0FERUQsIHRoaXMub25BdWRpb1RyYWNrTG9hZGVkLCB0aGlzKSwgZS5vZmYoSS5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyksIGUub2ZmKEkuQlVGRkVSX0NSRUFURUQsIHRoaXMub25CdWZmZXJDcmVhdGVkLCB0aGlzKSwgZS5vZmYoSS5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyksIGUub2ZmKEkuQlVGRkVSX0ZMVVNIRUQsIHRoaXMub25CdWZmZXJGbHVzaGVkLCB0aGlzKSwgZS5vZmYoSS5JTklUX1BUU19GT1VORCwgdGhpcy5vbkluaXRQdHNGb3VuZCwgdGhpcyksIGUub2ZmKEkuRlJBR19MT0FESU5HLCB0aGlzLm9uRnJhZ0xvYWRpbmcsIHRoaXMpLCBlLm9mZihJLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpKTtcbiAgfVxuICAvLyBJTklUX1BUU19GT1VORCBpcyB0cmlnZ2VyZWQgd2hlbiB0aGUgdmlkZW8gdHJhY2sgcGFyc2VkIGluIHRoZSBzdHJlYW0tY29udHJvbGxlciBoYXMgYSBuZXcgUFRTIHZhbHVlXG4gIG9uSW5pdFB0c0ZvdW5kKGUsIHtcbiAgICBmcmFnOiB0LFxuICAgIGlkOiByLFxuICAgIGluaXRQVFM6IG4sXG4gICAgdGltZXNjYWxlOiBpLFxuICAgIHRyYWNrSWQ6IG9cbiAgfSkge1xuICAgIGlmIChyID09PSBwZS5NQUlOKSB7XG4gICAgICBjb25zdCBhID0gdC5jYywgbCA9IHRoaXMuZnJhZ0N1cnJlbnQ7XG4gICAgICBpZiAodGhpcy5pbml0UFRTW2FdID0ge1xuICAgICAgICBiYXNlVGltZTogbixcbiAgICAgICAgdGltZXNjYWxlOiBpLFxuICAgICAgICB0cmFja0lkOiBvXG4gICAgICB9LCB0aGlzLmxvZyhgSW5pdFBUUyBmb3IgY2M6ICR7YX0gZm91bmQgZnJvbSBtYWluOiAke24gLyBpfSAoJHtufS8ke2l9KSB0cmFja0lkOiAke299YCksIHRoaXMubWFpbkFuY2hvciA9IHQsIHRoaXMuc3RhdGUgPT09IG5lLldBSVRJTkdfSU5JVF9QVFMpIHtcbiAgICAgICAgY29uc3QgYyA9IHRoaXMud2FpdGluZ0RhdGE7XG4gICAgICAgICghYyAmJiAhdGhpcy5sb2FkaW5nUGFydHMgfHwgYyAmJiBjLmZyYWcuY2MgIT09IGEpICYmIHRoaXMuc3luY1dpdGhBbmNob3IodCwgYyA9PSBudWxsID8gdm9pZCAwIDogYy5mcmFnKTtcbiAgICAgIH0gZWxzZSAhdGhpcy5obHMuaGFzRW5vdWdoVG9TdGFydCAmJiBsICYmIGwuY2MgIT09IGEgPyAobC5hYm9ydFJlcXVlc3RzKCksIHRoaXMuc3luY1dpdGhBbmNob3IodCwgbCkpIDogdGhpcy5zdGF0ZSA9PT0gbmUuSURMRSAmJiB0aGlzLnRpY2soKTtcbiAgICB9XG4gIH1cbiAgZ2V0TG9hZFBvc2l0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID49IDAgPyB0aGlzLm5leHRMb2FkUG9zaXRpb24gOiBzdXBlci5nZXRMb2FkUG9zaXRpb24oKTtcbiAgfVxuICBzeW5jV2l0aEFuY2hvcihlLCB0KSB7XG4gICAgdmFyIHI7XG4gICAgY29uc3QgbiA9ICgociA9IHRoaXMubWFpbkZyYWdMb2FkaW5nKSA9PSBudWxsID8gdm9pZCAwIDogci5mcmFnKSB8fCBudWxsO1xuICAgIGlmICh0ICYmIChuID09IG51bGwgPyB2b2lkIDAgOiBuLmNjKSA9PT0gdC5jYylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gKG4gfHwgZSkuY2MsIG8gPSB0aGlzLmdldExldmVsRGV0YWlscygpLCBhID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKSwgbCA9IFZnKG8sIGksIGEpO1xuICAgIGwgJiYgKHRoaXMubG9nKGBTeW5jaW5nIHdpdGggbWFpbiBmcmFnIGF0ICR7bC5zdGFydH0gY2MgJHtsLmNjfWApLCB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9ICExLCB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBsLnN0YXJ0LCB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCksIHRoaXMuc3RhdGUgPT09IG5lLklETEUgJiYgdGhpcy5kb1RpY2tJZGxlKCkpO1xuICB9XG4gIHN0YXJ0TG9hZChlLCB0KSB7XG4gICAgaWYgKCF0aGlzLmxldmVscykge1xuICAgICAgdGhpcy5zdGFydFBvc2l0aW9uID0gZSwgdGhpcy5zdGF0ZSA9IG5lLlNUT1BQRUQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHIgPSB0aGlzLmxhc3RDdXJyZW50VGltZTtcbiAgICB0aGlzLnN0b3BMb2FkKCksIHRoaXMuc2V0SW50ZXJ2YWwoamgpLCByID4gMCAmJiBlID09PSAtMSA/ICh0aGlzLmxvZyhgT3ZlcnJpZGUgc3RhcnRQb3NpdGlvbiB3aXRoIGxhc3RDdXJyZW50VGltZSBAJHtyLnRvRml4ZWQoMyl9YCksIGUgPSByLCB0aGlzLnN0YXRlID0gbmUuSURMRSkgOiB0aGlzLnN0YXRlID0gbmUuV0FJVElOR19UUkFDSywgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBlICsgdGhpcy50aW1lbGluZU9mZnNldCwgdGhpcy5zdGFydFBvc2l0aW9uID0gdCA/IC0xIDogZSwgdGhpcy50aWNrKCk7XG4gIH1cbiAgZG9UaWNrKCkge1xuICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBuZS5JRExFOlxuICAgICAgICB0aGlzLmRvVGlja0lkbGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIG5lLldBSVRJTkdfVFJBQ0s6IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGxldmVsczogZSxcbiAgICAgICAgICB0cmFja0lkOiB0XG4gICAgICAgIH0gPSB0aGlzLCByID0gZSA9PSBudWxsID8gdm9pZCAwIDogZVt0XSwgbiA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuZGV0YWlscztcbiAgICAgICAgaWYgKG4gJiYgIXRoaXMud2FpdEZvckxpdmUocikpIHtcbiAgICAgICAgICBpZiAodGhpcy53YWl0Rm9yQ2RuVHVuZUluKG4pKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgdGhpcy5zdGF0ZSA9IG5lLldBSVRJTkdfSU5JVF9QVFM7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIG5lLkZSQUdfTE9BRElOR19XQUlUSU5HX1JFVFJZOiB7XG4gICAgICAgIHRoaXMuY2hlY2tSZXRyeURhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIG5lLldBSVRJTkdfSU5JVF9QVFM6IHtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMud2FpdGluZ0RhdGE7XG4gICAgICAgIGlmIChlKSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZnJhZzogdCxcbiAgICAgICAgICAgIHBhcnQ6IHIsXG4gICAgICAgICAgICBjYWNoZTogbixcbiAgICAgICAgICAgIGNvbXBsZXRlOiBpXG4gICAgICAgICAgfSA9IGUsIG8gPSB0aGlzLm1haW5BbmNob3I7XG4gICAgICAgICAgaWYgKHRoaXMuaW5pdFBUU1t0LmNjXSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB0aGlzLndhaXRpbmdEYXRhID0gbnVsbCwgdGhpcy5zdGF0ZSA9IG5lLkZSQUdfTE9BRElORztcbiAgICAgICAgICAgIGNvbnN0IGEgPSBuLmZsdXNoKCkuYnVmZmVyLCBsID0ge1xuICAgICAgICAgICAgICBmcmFnOiB0LFxuICAgICAgICAgICAgICBwYXJ0OiByLFxuICAgICAgICAgICAgICBwYXlsb2FkOiBhLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGwpLCBpICYmIHN1cGVyLl9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShsKTtcbiAgICAgICAgICB9IGVsc2UgbyAmJiBvLmNjICE9PSBlLmZyYWcuY2MgJiYgdGhpcy5zeW5jV2l0aEFuY2hvcihvLCBlLmZyYWcpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB0aGlzLnN0YXRlID0gbmUuSURMRTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5vblRpY2tFbmQoKTtcbiAgfVxuICByZXNldExvYWRpbmdTdGF0ZSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy53YWl0aW5nRGF0YTtcbiAgICBlICYmICh0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChlLmZyYWcpLCB0aGlzLndhaXRpbmdEYXRhID0gbnVsbCksIHN1cGVyLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gIH1cbiAgb25UaWNrRW5kKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhOiBlXG4gICAgfSA9IHRoaXM7XG4gICAgZSAhPSBudWxsICYmIGUucmVhZHlTdGF0ZSAmJiAodGhpcy5sYXN0Q3VycmVudFRpbWUgPSBlLmN1cnJlbnRUaW1lKTtcbiAgfVxuICBkb1RpY2tJZGxlKCkge1xuICAgIHZhciBlO1xuICAgIGNvbnN0IHtcbiAgICAgIGhsczogdCxcbiAgICAgIGxldmVsczogcixcbiAgICAgIG1lZGlhOiBuLFxuICAgICAgdHJhY2tJZDogaVxuICAgIH0gPSB0aGlzLCBvID0gdC5jb25maWc7XG4gICAgaWYgKCF0aGlzLmJ1ZmZlcmluZyB8fCAhbiAmJiAhdGhpcy5wcmltYXJ5UHJlZmV0Y2ggJiYgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8ICFvLnN0YXJ0RnJhZ1ByZWZldGNoKSB8fCAhKHIgIT0gbnVsbCAmJiByW2ldKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhID0gcltpXSwgbCA9IGEuZGV0YWlscztcbiAgICBpZiAoIWwgfHwgdGhpcy53YWl0Rm9yTGl2ZShhKSB8fCB0aGlzLndhaXRGb3JDZG5UdW5lSW4obCkpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBuZS5XQUlUSU5HX1RSQUNLLCB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9ICExO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjID0gdGhpcy5tZWRpYUJ1ZmZlciA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgIHRoaXMuYnVmZmVyRmx1c2hlZCAmJiBjICYmICh0aGlzLmJ1ZmZlckZsdXNoZWQgPSAhMSwgdGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQoYywgb3QuQVVESU8sIHBlLkFVRElPKSk7XG4gICAgY29uc3QgdSA9IHRoaXMuZ2V0RndkQnVmZmVySW5mbyhjLCBwZS5BVURJTyk7XG4gICAgaWYgKHUgPT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgaWYgKCF0aGlzLnN3aXRjaGluZ1RyYWNrICYmIHRoaXMuX3N0cmVhbUVuZGVkKHUsIGwpKSB7XG4gICAgICB0LnRyaWdnZXIoSS5CVUZGRVJfRU9TLCB7XG4gICAgICAgIHR5cGU6IFwiYXVkaW9cIlxuICAgICAgfSksIHRoaXMuc3RhdGUgPSBuZS5FTkRFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZCA9IHUubGVuLCBoID0gdC5tYXhCdWZmZXJMZW5ndGgsIGYgPSBsLmZyYWdtZW50cywgcCA9IGZbMF0uc3RhcnQsIHkgPSB0aGlzLmdldExvYWRQb3NpdGlvbigpLCBFID0gdGhpcy5mbHVzaGluZyA/IHkgOiB1LmVuZDtcbiAgICBpZiAodGhpcy5zd2l0Y2hpbmdUcmFjayAmJiBuKSB7XG4gICAgICBjb25zdCBBID0geTtcbiAgICAgIGwuUFRTS25vd24gJiYgQSA8IHAgJiYgKHUuZW5kID4gcCB8fCB1Lm5leHRTdGFydCkgJiYgKHRoaXMubG9nKFwiQWx0IGF1ZGlvIHRyYWNrIGFoZWFkIG9mIG1haW4gdHJhY2ssIHNlZWsgdG8gc3RhcnQgb2YgYWx0IGF1ZGlvIHRyYWNrXCIpLCBuLmN1cnJlbnRUaW1lID0gcCArIDAuMDUpO1xuICAgIH1cbiAgICBpZiAoZCA+PSBoICYmICF0aGlzLnN3aXRjaGluZ1RyYWNrICYmIEUgPCBmW2YubGVuZ3RoIC0gMV0uc3RhcnQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGIgPSB0aGlzLmdldE5leHRGcmFnbWVudChFLCBsKTtcbiAgICBpZiAoYiAmJiB0aGlzLmlzTG9vcExvYWRpbmcoYiwgRSkgJiYgKGIgPSB0aGlzLmdldE5leHRGcmFnbWVudExvb3BMb2FkaW5nKGIsIGwsIHUsIHBlLk1BSU4sIGgpKSwgIWIpIHtcbiAgICAgIHRoaXMuYnVmZmVyRmx1c2hlZCA9ICEwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgUiA9ICgoZSA9IHRoaXMubWFpbkZyYWdMb2FkaW5nKSA9PSBudWxsID8gdm9pZCAwIDogZS5mcmFnKSB8fCBudWxsO1xuICAgIGlmICghdGhpcy5hdWRpb09ubHkgJiYgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgUiAmJiBWdChiKSAmJiAhYi5lbmRMaXN0ICYmICghbC5saXZlIHx8ICF0aGlzLmxvYWRpbmdQYXJ0cyAmJiBFIDwgdGhpcy5obHMubGl2ZVN5bmNQb3NpdGlvbikgJiYgKHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKFIpID09PSBIdC5PSyAmJiAodGhpcy5tYWluRnJhZ0xvYWRpbmcgPSBSID0gbnVsbCksIFIgJiYgVnQoUikpKSB7XG4gICAgICBpZiAoYi5zdGFydCA+IFIuZW5kKSB7XG4gICAgICAgIGNvbnN0IEYgPSB0aGlzLmZyYWdtZW50VHJhY2tlci5nZXRGcmFnQXRQb3MoRSwgcGUuTUFJTik7XG4gICAgICAgIEYgJiYgRi5lbmQgPiBSLmVuZCAmJiAoUiA9IEYsIHRoaXMubWFpbkZyYWdMb2FkaW5nID0ge1xuICAgICAgICAgIGZyYWc6IEYsXG4gICAgICAgICAgdGFyZ2V0QnVmZmVyVGltZTogbnVsbFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChiLnN0YXJ0ID4gUi5lbmQpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2FkRnJhZ21lbnQoYiwgYSwgRSk7XG4gIH1cbiAgb25NZWRpYURldGFjaGluZyhlLCB0KSB7XG4gICAgdGhpcy5idWZmZXJGbHVzaGVkID0gdGhpcy5mbHVzaGluZyA9ICExLCBzdXBlci5vbk1lZGlhRGV0YWNoaW5nKGUsIHQpO1xuICB9XG4gIG9uQXVkaW9UcmFja3NVcGRhdGVkKGUsIHtcbiAgICBhdWRpb1RyYWNrczogdFxuICB9KSB7XG4gICAgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKSwgdGhpcy5sZXZlbHMgPSB0Lm1hcCgocikgPT4gbmV3IG1pKHIpKTtcbiAgfVxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcoZSwgdCkge1xuICAgIGNvbnN0IHIgPSAhIXQudXJsO1xuICAgIHRoaXMudHJhY2tJZCA9IHQuaWQ7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ0N1cnJlbnQ6IG5cbiAgICB9ID0gdGhpcztcbiAgICBuICYmIChuLmFib3J0UmVxdWVzdHMoKSwgdGhpcy5yZW1vdmVVbmJ1ZmZlcmVkRnJhZ3Mobi5zdGFydCkpLCB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCksIHIgPyAodGhpcy5zd2l0Y2hpbmdUcmFjayA9IHQsIHRoaXMuZmx1c2hBdWRpb0lmTmVlZGVkKHQpLCB0aGlzLnN0YXRlICE9PSBuZS5TVE9QUEVEICYmICh0aGlzLnNldEludGVydmFsKGpoKSwgdGhpcy5zdGF0ZSA9IG5lLklETEUsIHRoaXMudGljaygpKSkgOiAodGhpcy5yZXNldFRyYW5zbXV4ZXIoKSwgdGhpcy5zd2l0Y2hpbmdUcmFjayA9IG51bGwsIHRoaXMuYnVmZmVyZWRUcmFjayA9IHQsIHRoaXMuY2xlYXJJbnRlcnZhbCgpKTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICBzdXBlci5vbk1hbmlmZXN0TG9hZGluZygpLCB0aGlzLmJ1ZmZlckZsdXNoZWQgPSB0aGlzLmZsdXNoaW5nID0gdGhpcy5hdWRpb09ubHkgPSAhMSwgdGhpcy5yZXNldEl0ZW0oKSwgdGhpcy50cmFja0lkID0gLTE7XG4gIH1cbiAgb25MZXZlbExvYWRlZChlLCB0KSB7XG4gICAgdGhpcy5tYWluRGV0YWlscyA9IHQuZGV0YWlscztcbiAgICBjb25zdCByID0gdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGE7XG4gICAgciAmJiAodGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEgPSBudWxsLCB0aGlzLm9uQXVkaW9UcmFja0xvYWRlZChJLkFVRElPX1RSQUNLX0xPQURFRCwgcikpO1xuICB9XG4gIG9uQXVkaW9UcmFja0xvYWRlZChlLCB0KSB7XG4gICAgdmFyIHI7XG4gICAgY29uc3Qge1xuICAgICAgbGV2ZWxzOiBuXG4gICAgfSA9IHRoaXMsIHtcbiAgICAgIGRldGFpbHM6IGksXG4gICAgICBpZDogbyxcbiAgICAgIGdyb3VwSWQ6IGEsXG4gICAgICB0cmFjazogbFxuICAgIH0gPSB0O1xuICAgIGlmICghbikge1xuICAgICAgdGhpcy53YXJuKGBBdWRpbyB0cmFja3MgcmVzZXQgd2hpbGUgbG9hZGluZyB0cmFjayAke299IFwiJHtsLm5hbWV9XCIgb2YgXCIke2F9XCJgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYyA9IHRoaXMubWFpbkRldGFpbHM7XG4gICAgaWYgKCFjIHx8IGkuZW5kQ0MgPiBjLmVuZENDIHx8IGMuZXhwaXJlZCkge1xuICAgICAgdGhpcy5jYWNoZWRUcmFja0xvYWRlZERhdGEgPSB0LCB0aGlzLnN0YXRlICE9PSBuZS5TVE9QUEVEICYmICh0aGlzLnN0YXRlID0gbmUuV0FJVElOR19UUkFDSyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2FjaGVkVHJhY2tMb2FkZWREYXRhID0gbnVsbCwgdGhpcy5sb2coYEF1ZGlvIHRyYWNrICR7b30gXCIke2wubmFtZX1cIiBvZiBcIiR7YX1cIiBsb2FkZWQgWyR7aS5zdGFydFNOfSwke2kuZW5kU059XSR7aS5sYXN0UGFydFNuID8gYFtwYXJ0LSR7aS5sYXN0UGFydFNufS0ke2kubGFzdFBhcnRJbmRleH1dYCA6IFwiXCJ9LGR1cmF0aW9uOiR7aS50b3RhbGR1cmF0aW9ufWApO1xuICAgIGNvbnN0IHUgPSBuW29dO1xuICAgIGxldCBkID0gMDtcbiAgICBpZiAoaS5saXZlIHx8IChyID0gdS5kZXRhaWxzKSAhPSBudWxsICYmIHIubGl2ZSkge1xuICAgICAgaWYgKHRoaXMuY2hlY2tMaXZlVXBkYXRlKGkpLCBpLmRlbHRhVXBkYXRlRmFpbGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodS5kZXRhaWxzKSB7XG4gICAgICAgIHZhciBoO1xuICAgICAgICBkID0gdGhpcy5hbGlnblBsYXlsaXN0cyhpLCB1LmRldGFpbHMsIChoID0gdGhpcy5sZXZlbExhc3RMb2FkZWQpID09IG51bGwgPyB2b2lkIDAgOiBoLmRldGFpbHMpO1xuICAgICAgfVxuICAgICAgaS5hbGlnbmVkU2xpZGluZyB8fCAobnAoaSwgYyksIGkuYWxpZ25lZFNsaWRpbmcgfHwgc2EoaSwgYyksIGQgPSBpLmZyYWdtZW50U3RhcnQpO1xuICAgIH1cbiAgICB1LmRldGFpbHMgPSBpLCB0aGlzLmxldmVsTGFzdExvYWRlZCA9IHUsIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkIHx8IHRoaXMuc2V0U3RhcnRQb3NpdGlvbihjLCBkKSwgdGhpcy5obHMudHJpZ2dlcihJLkFVRElPX1RSQUNLX1VQREFURUQsIHtcbiAgICAgIGRldGFpbHM6IGksXG4gICAgICBpZDogbyxcbiAgICAgIGdyb3VwSWQ6IHQuZ3JvdXBJZFxuICAgIH0pLCB0aGlzLnN0YXRlID09PSBuZS5XQUlUSU5HX1RSQUNLICYmICF0aGlzLndhaXRGb3JDZG5UdW5lSW4oaSkgJiYgKHRoaXMuc3RhdGUgPSBuZS5JRExFKSwgdGhpcy50aWNrKCk7XG4gIH1cbiAgX2hhbmRsZUZyYWdtZW50TG9hZFByb2dyZXNzKGUpIHtcbiAgICB2YXIgdDtcbiAgICBjb25zdCByID0gZS5mcmFnLCB7XG4gICAgICBwYXJ0OiBuLFxuICAgICAgcGF5bG9hZDogaVxuICAgIH0gPSBlLCB7XG4gICAgICBjb25maWc6IG8sXG4gICAgICB0cmFja0lkOiBhLFxuICAgICAgbGV2ZWxzOiBsXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFsKSB7XG4gICAgICB0aGlzLndhcm4oYEF1ZGlvIHRyYWNrcyB3ZXJlIHJlc2V0IHdoaWxlIGZyYWdtZW50IGxvYWQgd2FzIGluIHByb2dyZXNzLiBGcmFnbWVudCAke3Iuc259IG9mIGxldmVsICR7ci5sZXZlbH0gd2lsbCBub3QgYmUgYnVmZmVyZWRgKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYyA9IGxbYV07XG4gICAgaWYgKCFjKSB7XG4gICAgICB0aGlzLndhcm4oXCJBdWRpbyB0cmFjayBpcyB1bmRlZmluZWQgb24gZnJhZ21lbnQgbG9hZCBwcm9ncmVzc1wiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdSA9IGMuZGV0YWlscztcbiAgICBpZiAoIXUpIHtcbiAgICAgIHRoaXMud2FybihcIkF1ZGlvIHRyYWNrIGRldGFpbHMgdW5kZWZpbmVkIG9uIGZyYWdtZW50IGxvYWQgcHJvZ3Jlc3NcIiksIHRoaXMucmVtb3ZlVW5idWZmZXJlZEZyYWdzKHIuc3RhcnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkID0gby5kZWZhdWx0QXVkaW9Db2RlYyB8fCBjLmF1ZGlvQ29kZWMgfHwgXCJtcDRhLjQwLjJcIjtcbiAgICBsZXQgaCA9IHRoaXMudHJhbnNtdXhlcjtcbiAgICBoIHx8IChoID0gdGhpcy50cmFuc211eGVyID0gbmV3IHdwKHRoaXMuaGxzLCBwZS5BVURJTywgdGhpcy5faGFuZGxlVHJhbnNtdXhDb21wbGV0ZS5iaW5kKHRoaXMpLCB0aGlzLl9oYW5kbGVUcmFuc211eGVyRmx1c2guYmluZCh0aGlzKSkpO1xuICAgIGNvbnN0IGYgPSB0aGlzLmluaXRQVFNbci5jY10sIHAgPSAodCA9IHIuaW5pdFNlZ21lbnQpID09IG51bGwgPyB2b2lkIDAgOiB0LmRhdGE7XG4gICAgaWYgKGYgIT09IHZvaWQgMCkge1xuICAgICAgY29uc3QgRSA9IG4gPyBuLmluZGV4IDogLTEsIGIgPSBFICE9PSAtMSwgUiA9IG5ldyBFdShyLmxldmVsLCByLnNuLCByLnN0YXRzLmNodW5rQ291bnQsIGkuYnl0ZUxlbmd0aCwgRSwgYik7XG4gICAgICBoLnB1c2goaSwgcCwgZCwgXCJcIiwgciwgbiwgdS50b3RhbGR1cmF0aW9uLCAhMSwgUiwgZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nKGBVbmtub3duIHZpZGVvIFBUUyBmb3IgY2MgJHtyLmNjfSwgd2FpdGluZyBmb3IgdmlkZW8gUFRTIGJlZm9yZSBkZW11eGluZyBhdWRpbyBmcmFnICR7ci5zbn0gb2YgWyR7dS5zdGFydFNOfSAsJHt1LmVuZFNOfV0sdHJhY2sgJHthfWApO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjYWNoZTogeVxuICAgICAgfSA9IHRoaXMud2FpdGluZ0RhdGEgPSB0aGlzLndhaXRpbmdEYXRhIHx8IHtcbiAgICAgICAgZnJhZzogcixcbiAgICAgICAgcGFydDogbixcbiAgICAgICAgY2FjaGU6IG5ldyBpcCgpLFxuICAgICAgICBjb21wbGV0ZTogITFcbiAgICAgIH07XG4gICAgICB5LnB1c2gobmV3IFVpbnQ4QXJyYXkoaSkpLCB0aGlzLnN0YXRlICE9PSBuZS5TVE9QUEVEICYmICh0aGlzLnN0YXRlID0gbmUuV0FJVElOR19JTklUX1BUUyk7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShlKSB7XG4gICAgaWYgKHRoaXMud2FpdGluZ0RhdGEpIHtcbiAgICAgIHRoaXMud2FpdGluZ0RhdGEuY29tcGxldGUgPSAhMDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3VwZXIuX2hhbmRsZUZyYWdtZW50TG9hZENvbXBsZXRlKGUpO1xuICB9XG4gIG9uQnVmZmVyUmVzZXQoKSB7XG4gICAgdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGw7XG4gIH1cbiAgb25CdWZmZXJDcmVhdGVkKGUsIHQpIHtcbiAgICB0aGlzLmJ1ZmZlckZsdXNoZWQgPSB0aGlzLmZsdXNoaW5nID0gITE7XG4gICAgY29uc3QgciA9IHQudHJhY2tzLmF1ZGlvO1xuICAgIHIgJiYgKHRoaXMubWVkaWFCdWZmZXIgPSByLmJ1ZmZlciB8fCBudWxsKTtcbiAgfVxuICBvbkZyYWdMb2FkaW5nKGUsIHQpIHtcbiAgICAhdGhpcy5hdWRpb09ubHkgJiYgdC5mcmFnLnR5cGUgPT09IHBlLk1BSU4gJiYgVnQodC5mcmFnKSAmJiAodGhpcy5tYWluRnJhZ0xvYWRpbmcgPSB0LCB0aGlzLnN0YXRlID09PSBuZS5JRExFICYmIHRoaXMudGljaygpKTtcbiAgfVxuICBvbkZyYWdCdWZmZXJlZChlLCB0KSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZzogcixcbiAgICAgIHBhcnQ6IG5cbiAgICB9ID0gdDtcbiAgICBpZiAoci50eXBlICE9PSBwZS5BVURJTykge1xuICAgICAgIXRoaXMuYXVkaW9Pbmx5ICYmIHIudHlwZSA9PT0gcGUuTUFJTiAmJiAhci5lbGVtZW50YXJ5U3RyZWFtcy52aWRlbyAmJiAhci5lbGVtZW50YXJ5U3RyZWFtcy5hdWRpb3ZpZGVvICYmICh0aGlzLmF1ZGlvT25seSA9ICEwLCB0aGlzLm1haW5GcmFnTG9hZGluZyA9IG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQocikpIHtcbiAgICAgIHRoaXMud2FybihgRnJhZ21lbnQgJHtyLnNufSR7biA/IFwiIHA6IFwiICsgbi5pbmRleCA6IFwiXCJ9IG9mIGxldmVsICR7ci5sZXZlbH0gZmluaXNoZWQgYnVmZmVyaW5nLCBidXQgd2FzIGFib3J0ZWQuIHN0YXRlOiAke3RoaXMuc3RhdGV9LCBhdWRpb1N3aXRjaDogJHt0aGlzLnN3aXRjaGluZ1RyYWNrID8gdGhpcy5zd2l0Y2hpbmdUcmFjay5uYW1lIDogXCJmYWxzZVwifWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoVnQocikpIHtcbiAgICAgIHRoaXMuZnJhZ1ByZXZpb3VzID0gcjtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLnN3aXRjaGluZ1RyYWNrO1xuICAgICAgaSAmJiAodGhpcy5idWZmZXJlZFRyYWNrID0gaSwgdGhpcy5zd2l0Y2hpbmdUcmFjayA9IG51bGwsIHRoaXMuaGxzLnRyaWdnZXIoSS5BVURJT19UUkFDS19TV0lUQ0hFRCwgdHQoe30sIGkpKSk7XG4gICAgfVxuICAgIHRoaXMuZnJhZ0J1ZmZlcmVkQ29tcGxldGUociwgbiksIHRoaXMubWVkaWEgJiYgdGhpcy50aWNrKCk7XG4gIH1cbiAgb25FcnJvcihlLCB0KSB7XG4gICAgdmFyIHI7XG4gICAgaWYgKHQuZmF0YWwpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSBuZS5FUlJPUjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoICh0LmRldGFpbHMpIHtcbiAgICAgIGNhc2UgSi5GUkFHX0dBUDpcbiAgICAgIGNhc2UgSi5GUkFHX1BBUlNJTkdfRVJST1I6XG4gICAgICBjYXNlIEouRlJBR19ERUNSWVBUX0VSUk9SOlxuICAgICAgY2FzZSBKLkZSQUdfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgSi5GUkFHX0xPQURfVElNRU9VVDpcbiAgICAgIGNhc2UgSi5LRVlfTE9BRF9FUlJPUjpcbiAgICAgIGNhc2UgSi5LRVlfTE9BRF9USU1FT1VUOlxuICAgICAgICB0aGlzLm9uRnJhZ21lbnRPcktleUxvYWRFcnJvcihwZS5BVURJTywgdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBKLkFVRElPX1RSQUNLX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEouQVVESU9fVFJBQ0tfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBKLkxFVkVMX1BBUlNJTkdfRVJST1I6XG4gICAgICAgICF0LmxldmVsUmV0cnkgJiYgdGhpcy5zdGF0ZSA9PT0gbmUuV0FJVElOR19UUkFDSyAmJiAoKHIgPSB0LmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiByLnR5cGUpID09PSBLZS5BVURJT19UUkFDSyAmJiAodGhpcy5zdGF0ZSA9IG5lLklETEUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSi5CVUZGRVJfQUREX0NPREVDX0VSUk9SOlxuICAgICAgY2FzZSBKLkJVRkZFUl9BUFBFTkRfRVJST1I6XG4gICAgICAgIGlmICh0LnBhcmVudCAhPT0gXCJhdWRpb1wiKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yZWR1Y2VMZW5ndGhBbmRGbHVzaEJ1ZmZlcih0KSB8fCB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBKLkJVRkZFUl9GVUxMX0VSUk9SOlxuICAgICAgICBpZiAodC5wYXJlbnQgIT09IFwiYXVkaW9cIilcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmVkdWNlTGVuZ3RoQW5kRmx1c2hCdWZmZXIodCkgJiYgKHRoaXMuYnVmZmVyZWRUcmFjayA9IG51bGwsIHN1cGVyLmZsdXNoTWFpbkJ1ZmZlcigwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIFwiYXVkaW9cIikpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSi5JTlRFUk5BTF9FWENFUFRJT046XG4gICAgICAgIHRoaXMucmVjb3ZlcldvcmtlckVycm9yKHQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgb25CdWZmZXJGbHVzaGluZyhlLCB7XG4gICAgdHlwZTogdFxuICB9KSB7XG4gICAgdCAhPT0gb3QuVklERU8gJiYgKHRoaXMuZmx1c2hpbmcgPSAhMCk7XG4gIH1cbiAgb25CdWZmZXJGbHVzaGVkKGUsIHtcbiAgICB0eXBlOiB0XG4gIH0pIHtcbiAgICBpZiAodCAhPT0gb3QuVklERU8pIHtcbiAgICAgIHRoaXMuZmx1c2hpbmcgPSAhMSwgdGhpcy5idWZmZXJGbHVzaGVkID0gITAsIHRoaXMuc3RhdGUgPT09IG5lLkVOREVEICYmICh0aGlzLnN0YXRlID0gbmUuSURMRSk7XG4gICAgICBjb25zdCByID0gdGhpcy5tZWRpYUJ1ZmZlciB8fCB0aGlzLm1lZGlhO1xuICAgICAgciAmJiAodGhpcy5hZnRlckJ1ZmZlckZsdXNoZWQociwgdCwgcGUuQVVESU8pLCB0aGlzLnRpY2soKSk7XG4gICAgfVxuICB9XG4gIF9oYW5kbGVUcmFuc211eENvbXBsZXRlKGUpIHtcbiAgICB2YXIgdDtcbiAgICBjb25zdCByID0gXCJhdWRpb1wiLCB7XG4gICAgICBobHM6IG5cbiAgICB9ID0gdGhpcywge1xuICAgICAgcmVtdXhSZXN1bHQ6IGksXG4gICAgICBjaHVua01ldGE6IG9cbiAgICB9ID0gZSwgYSA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQobyk7XG4gICAgaWYgKCFhKSB7XG4gICAgICB0aGlzLnJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KG8pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBmcmFnOiBsLFxuICAgICAgcGFydDogYyxcbiAgICAgIGxldmVsOiB1XG4gICAgfSA9IGEsIHtcbiAgICAgIGRldGFpbHM6IGRcbiAgICB9ID0gdSwge1xuICAgICAgYXVkaW86IGgsXG4gICAgICB0ZXh0OiBmLFxuICAgICAgaWQzOiBwLFxuICAgICAgaW5pdFNlZ21lbnQ6IHlcbiAgICB9ID0gaTtcbiAgICBpZiAodGhpcy5mcmFnQ29udGV4dENoYW5nZWQobCkgfHwgIWQpIHtcbiAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZSA9IG5lLlBBUlNJTkcsIHRoaXMuc3dpdGNoaW5nVHJhY2sgJiYgaCAmJiB0aGlzLmNvbXBsZXRlQXVkaW9Td2l0Y2godGhpcy5zd2l0Y2hpbmdUcmFjayksIHkgIT0gbnVsbCAmJiB5LnRyYWNrcykge1xuICAgICAgY29uc3QgRSA9IGwuaW5pdFNlZ21lbnQgfHwgbDtcbiAgICAgIGlmICh0aGlzLnVuaGFuZGxlZEVuY3J5cHRpb25FcnJvcih5LCBsKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5fYnVmZmVySW5pdFNlZ21lbnQodSwgeS50cmFja3MsIEUsIG8pLCBuLnRyaWdnZXIoSS5GUkFHX1BBUlNJTkdfSU5JVF9TRUdNRU5ULCB7XG4gICAgICAgIGZyYWc6IEUsXG4gICAgICAgIGlkOiByLFxuICAgICAgICB0cmFja3M6IHkudHJhY2tzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3RhcnRQVFM6IEUsXG4gICAgICAgIGVuZFBUUzogYixcbiAgICAgICAgc3RhcnREVFM6IFIsXG4gICAgICAgIGVuZERUUzogQVxuICAgICAgfSA9IGg7XG4gICAgICBjICYmIChjLmVsZW1lbnRhcnlTdHJlYW1zW290LkFVRElPXSA9IHtcbiAgICAgICAgc3RhcnRQVFM6IEUsXG4gICAgICAgIGVuZFBUUzogYixcbiAgICAgICAgc3RhcnREVFM6IFIsXG4gICAgICAgIGVuZERUUzogQVxuICAgICAgfSksIGwuc2V0RWxlbWVudGFyeVN0cmVhbUluZm8ob3QuQVVESU8sIEUsIGIsIFIsIEEpLCB0aGlzLmJ1ZmZlckZyYWdtZW50RGF0YShoLCBsLCBjLCBvKTtcbiAgICB9XG4gICAgaWYgKHAgIT0gbnVsbCAmJiAodCA9IHAuc2FtcGxlcykgIT0gbnVsbCAmJiB0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgRSA9IG50KHtcbiAgICAgICAgaWQ6IHIsXG4gICAgICAgIGZyYWc6IGwsXG4gICAgICAgIGRldGFpbHM6IGRcbiAgICAgIH0sIHApO1xuICAgICAgbi50cmlnZ2VyKEkuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBFKTtcbiAgICB9XG4gICAgaWYgKGYpIHtcbiAgICAgIGNvbnN0IEUgPSBudCh7XG4gICAgICAgIGlkOiByLFxuICAgICAgICBmcmFnOiBsLFxuICAgICAgICBkZXRhaWxzOiBkXG4gICAgICB9LCBmKTtcbiAgICAgIG4udHJpZ2dlcihJLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgRSk7XG4gICAgfVxuICB9XG4gIF9idWZmZXJJbml0U2VnbWVudChlLCB0LCByLCBuKSB7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT09IG5lLlBBUlNJTkcgfHwgKHQudmlkZW8gJiYgZGVsZXRlIHQudmlkZW8sIHQuYXVkaW92aWRlbyAmJiBkZWxldGUgdC5hdWRpb3ZpZGVvLCAhdC5hdWRpbykpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IHQuYXVkaW87XG4gICAgaS5pZCA9IHBlLkFVRElPO1xuICAgIGNvbnN0IG8gPSBlLmF1ZGlvQ29kZWM7XG4gICAgdGhpcy5sb2coYEluaXQgYXVkaW8gYnVmZmVyLCBjb250YWluZXI6JHtpLmNvbnRhaW5lcn0sIGNvZGVjc1tsZXZlbC9wYXJzZWRdPVske299LyR7aS5jb2RlY31dYCksIG8gJiYgby5zcGxpdChcIixcIikubGVuZ3RoID09PSAxICYmIChpLmxldmVsQ29kZWMgPSBvKSwgdGhpcy5obHMudHJpZ2dlcihJLkJVRkZFUl9DT0RFQ1MsIHQpO1xuICAgIGNvbnN0IGEgPSBpLmluaXRTZWdtZW50O1xuICAgIGlmIChhICE9IG51bGwgJiYgYS5ieXRlTGVuZ3RoKSB7XG4gICAgICBjb25zdCBsID0ge1xuICAgICAgICB0eXBlOiBcImF1ZGlvXCIsXG4gICAgICAgIGZyYWc6IHIsXG4gICAgICAgIHBhcnQ6IG51bGwsXG4gICAgICAgIGNodW5rTWV0YTogbixcbiAgICAgICAgcGFyZW50OiByLnR5cGUsXG4gICAgICAgIGRhdGE6IGFcbiAgICAgIH07XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEkuQlVGRkVSX0FQUEVORElORywgbCk7XG4gICAgfVxuICAgIHRoaXMudGlja0ltbWVkaWF0ZSgpO1xuICB9XG4gIGxvYWRGcmFnbWVudChlLCB0LCByKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGUpO1xuICAgIGlmICh0aGlzLnN3aXRjaGluZ1RyYWNrIHx8IG4gPT09IEh0Lk5PVF9MT0FERUQgfHwgbiA9PT0gSHQuUEFSVElBTCkge1xuICAgICAgdmFyIGk7XG4gICAgICBpZiAoIVZ0KGUpKVxuICAgICAgICB0aGlzLl9sb2FkSW5pdFNlZ21lbnQoZSwgdCk7XG4gICAgICBlbHNlIGlmICgoaSA9IHQuZGV0YWlscykgIT0gbnVsbCAmJiBpLmxpdmUgJiYgIXRoaXMuaW5pdFBUU1tlLmNjXSkge1xuICAgICAgICB0aGlzLmxvZyhgV2FpdGluZyBmb3IgdmlkZW8gUFRTIGluIGNvbnRpbnVpdHkgY291bnRlciAke2UuY2N9IG9mIGxpdmUgc3RyZWFtIGJlZm9yZSBsb2FkaW5nIGF1ZGlvIGZyYWdtZW50ICR7ZS5zbn0gb2YgbGV2ZWwgJHt0aGlzLnRyYWNrSWR9YCksIHRoaXMuc3RhdGUgPSBuZS5XQUlUSU5HX0lOSVRfUFRTO1xuICAgICAgICBjb25zdCBvID0gdGhpcy5tYWluRGV0YWlscztcbiAgICAgICAgbyAmJiBvLmZyYWdtZW50U3RhcnQgIT09IHQuZGV0YWlscy5mcmFnbWVudFN0YXJ0ICYmIHNhKHQuZGV0YWlscywgbyk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgc3VwZXIubG9hZEZyYWdtZW50KGUsIHQsIHIpO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5jbGVhclRyYWNrZXJJZk5lZWRlZChlKTtcbiAgfVxuICBmbHVzaEF1ZGlvSWZOZWVkZWQoZSkge1xuICAgIGlmICh0aGlzLm1lZGlhICYmIHRoaXMuYnVmZmVyZWRUcmFjaykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuYW1lOiB0LFxuICAgICAgICBsYW5nOiByLFxuICAgICAgICBhc3NvY0xhbmc6IG4sXG4gICAgICAgIGNoYXJhY3RlcmlzdGljczogaSxcbiAgICAgICAgYXVkaW9Db2RlYzogbyxcbiAgICAgICAgY2hhbm5lbHM6IGFcbiAgICAgIH0gPSB0aGlzLmJ1ZmZlcmVkVHJhY2s7XG4gICAgICBxcyh7XG4gICAgICAgIG5hbWU6IHQsXG4gICAgICAgIGxhbmc6IHIsXG4gICAgICAgIGFzc29jTGFuZzogbixcbiAgICAgICAgY2hhcmFjdGVyaXN0aWNzOiBpLFxuICAgICAgICBhdWRpb0NvZGVjOiBvLFxuICAgICAgICBjaGFubmVsczogYVxuICAgICAgfSwgZSwgVXMpIHx8IChRbyhlLnVybCwgdGhpcy5obHMpID8gKHRoaXMubG9nKFwiU3dpdGNoaW5nIGF1ZGlvIHRyYWNrIDogZmx1c2hpbmcgYWxsIGF1ZGlvXCIpLCBzdXBlci5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBcImF1ZGlvXCIpLCB0aGlzLmJ1ZmZlcmVkVHJhY2sgPSBudWxsKSA6IHRoaXMuYnVmZmVyZWRUcmFjayA9IGUpO1xuICAgIH1cbiAgfVxuICBjb21wbGV0ZUF1ZGlvU3dpdGNoKGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHM6IHRcbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmZsdXNoQXVkaW9JZk5lZWRlZChlKSwgdGhpcy5idWZmZXJlZFRyYWNrID0gZSwgdGhpcy5zd2l0Y2hpbmdUcmFjayA9IG51bGwsIHQudHJpZ2dlcihJLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0dCh7fSwgZSkpO1xuICB9XG59XG5jbGFzcyBrdSBleHRlbmRzIExyIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKHQsIGUubG9nZ2VyKSwgdGhpcy5obHMgPSB2b2lkIDAsIHRoaXMuY2FuTG9hZCA9ICExLCB0aGlzLnRpbWVyID0gLTEsIHRoaXMuaGxzID0gZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2xlYXJUaW1lcigpLCB0aGlzLmhscyA9IHRoaXMubG9nID0gdGhpcy53YXJuID0gbnVsbDtcbiAgfVxuICBjbGVhclRpbWVyKCkge1xuICAgIHRoaXMudGltZXIgIT09IC0xICYmIChzZWxmLmNsZWFyVGltZW91dCh0aGlzLnRpbWVyKSwgdGhpcy50aW1lciA9IC0xKTtcbiAgfVxuICBzdGFydExvYWQoKSB7XG4gICAgdGhpcy5jYW5Mb2FkID0gITAsIHRoaXMubG9hZFBsYXlsaXN0KCk7XG4gIH1cbiAgc3RvcExvYWQoKSB7XG4gICAgdGhpcy5jYW5Mb2FkID0gITEsIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9XG4gIHN3aXRjaFBhcmFtcyhlLCB0LCByKSB7XG4gICAgY29uc3QgbiA9IHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQucmVuZGl0aW9uUmVwb3J0cztcbiAgICBpZiAobikge1xuICAgICAgbGV0IGkgPSAtMTtcbiAgICAgIGZvciAobGV0IG8gPSAwOyBvIDwgbi5sZW5ndGg7IG8rKykge1xuICAgICAgICBjb25zdCBhID0gbltvXTtcbiAgICAgICAgbGV0IGw7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbCA9IG5ldyBzZWxmLlVSTChhLlVSSSwgdC51cmwpLmhyZWY7XG4gICAgICAgIH0gY2F0Y2ggKGMpIHtcbiAgICAgICAgICB0aGlzLndhcm4oYENvdWxkIG5vdCBjb25zdHJ1Y3QgbmV3IFVSTCBmb3IgUmVuZGl0aW9uIFJlcG9ydDogJHtjfWApLCBsID0gYS5VUkkgfHwgXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobCA9PT0gZSkge1xuICAgICAgICAgIGkgPSBvO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgbCA9PT0gZS5zdWJzdHJpbmcoMCwgbC5sZW5ndGgpICYmIChpID0gbyk7XG4gICAgICB9XG4gICAgICBpZiAoaSAhPT0gLTEpIHtcbiAgICAgICAgY29uc3QgbyA9IG5baV0sIGEgPSBwYXJzZUludChvW1wiTEFTVC1NU05cIl0pIHx8IHQubGFzdFBhcnRTbjtcbiAgICAgICAgbGV0IGwgPSBwYXJzZUludChvW1wiTEFTVC1QQVJUXCJdKSB8fCB0Lmxhc3RQYXJ0SW5kZXg7XG4gICAgICAgIGlmICh0aGlzLmhscy5jb25maWcubG93TGF0ZW5jeU1vZGUpIHtcbiAgICAgICAgICBjb25zdCB1ID0gTWF0aC5taW4odC5hZ2UgLSB0LnBhcnRUYXJnZXQsIHQudGFyZ2V0ZHVyYXRpb24pO1xuICAgICAgICAgIGwgPj0gMCAmJiB1ID4gdC5wYXJ0VGFyZ2V0ICYmIChsICs9IDEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGMgPSByICYmIG9oKHIpO1xuICAgICAgICByZXR1cm4gbmV3IGFoKGEsIGwgPj0gMCA/IGwgOiB2b2lkIDAsIGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsb2FkUGxheWxpc3QoZSkge1xuICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9XG4gIGxvYWRpbmdQbGF5bGlzdChlLCB0KSB7XG4gICAgdGhpcy5jbGVhclRpbWVyKCk7XG4gIH1cbiAgc2hvdWxkTG9hZFBsYXlsaXN0KGUpIHtcbiAgICByZXR1cm4gdGhpcy5jYW5Mb2FkICYmICEhZSAmJiAhIWUudXJsICYmICghZS5kZXRhaWxzIHx8IGUuZGV0YWlscy5saXZlKTtcbiAgfVxuICBnZXRVcmxXaXRoRGlyZWN0aXZlcyhlLCB0KSB7XG4gICAgaWYgKHQpXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdC5hZGREaXJlY3RpdmVzKGUpO1xuICAgICAgfSBjYXRjaCAocikge1xuICAgICAgICB0aGlzLndhcm4oYENvdWxkIG5vdCBjb25zdHJ1Y3QgbmV3IFVSTCB3aXRoIEhMUyBEZWxpdmVyeSBEaXJlY3RpdmVzOiAke3J9YCk7XG4gICAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgcGxheWxpc3RMb2FkZWQoZSwgdCwgcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGRldGFpbHM6IG4sXG4gICAgICBzdGF0czogaVxuICAgIH0gPSB0LCBvID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgYSA9IGkubG9hZGluZy5maXJzdCA/IE1hdGgubWF4KDAsIG8gLSBpLmxvYWRpbmcuZmlyc3QpIDogMDtcbiAgICBuLmFkdmFuY2VkRGF0ZVRpbWUgPSBEYXRlLm5vdygpIC0gYTtcbiAgICBjb25zdCBsID0gdGhpcy5obHMuY29uZmlnLnRpbWVsaW5lT2Zmc2V0O1xuICAgIGlmIChsICE9PSBuLmFwcGxpZWRUaW1lbGluZU9mZnNldCkge1xuICAgICAgY29uc3QgdSA9IE1hdGgubWF4KGwgfHwgMCwgMCk7XG4gICAgICBuLmFwcGxpZWRUaW1lbGluZU9mZnNldCA9IHUsIG4uZnJhZ21lbnRzLmZvckVhY2goKGQpID0+IHtcbiAgICAgICAgZC5zZXRTdGFydChkLnBsYXlsaXN0T2Zmc2V0ICsgdSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG4ubGl2ZSB8fCByICE9IG51bGwgJiYgci5saXZlKSB7XG4gICAgICBjb25zdCB1ID0gXCJsZXZlbEluZm9cIiBpbiB0ID8gdC5sZXZlbEluZm8gOiB0LnRyYWNrO1xuICAgICAgaWYgKG4ucmVsb2FkZWQociksIHIgJiYgbi5mcmFnbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICBaYihyLCBuLCB0aGlzKTtcbiAgICAgICAgY29uc3QgUiA9IG4ucGxheWxpc3RQYXJzaW5nRXJyb3I7XG4gICAgICAgIGlmIChSKSB7XG4gICAgICAgICAgdGhpcy53YXJuKFIpO1xuICAgICAgICAgIGNvbnN0IEEgPSB0aGlzLmhscztcbiAgICAgICAgICBpZiAoIUEuY29uZmlnLmlnbm9yZVBsYXlsaXN0UGFyc2luZ0Vycm9ycykge1xuICAgICAgICAgICAgdmFyIGM7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBGXG4gICAgICAgICAgICB9ID0gdDtcbiAgICAgICAgICAgIEEudHJpZ2dlcihJLkVSUk9SLCB7XG4gICAgICAgICAgICAgIHR5cGU6IHZlLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgICAgIGRldGFpbHM6IEouTEVWRUxfUEFSU0lOR19FUlJPUixcbiAgICAgICAgICAgICAgZmF0YWw6ICExLFxuICAgICAgICAgICAgICB1cmw6IG4udXJsLFxuICAgICAgICAgICAgICBlcnJvcjogUixcbiAgICAgICAgICAgICAgcmVhc29uOiBSLm1lc3NhZ2UsXG4gICAgICAgICAgICAgIGxldmVsOiB0LmxldmVsIHx8IHZvaWQgMCxcbiAgICAgICAgICAgICAgcGFyZW50OiAoYyA9IG4uZnJhZ21lbnRzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogYy50eXBlLFxuICAgICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogRixcbiAgICAgICAgICAgICAgc3RhdHM6IGlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuLnBsYXlsaXN0UGFyc2luZ0Vycm9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbi5yZXF1ZXN0U2NoZWR1bGVkID09PSAtMSAmJiAobi5yZXF1ZXN0U2NoZWR1bGVkID0gaS5sb2FkaW5nLnN0YXJ0KTtcbiAgICAgIGNvbnN0IGQgPSB0aGlzLmhscy5tYWluRm9yd2FyZEJ1ZmZlckluZm8sIGggPSBkID8gZC5lbmQgLSBkLmxlbiA6IDAsIGYgPSAobi5lZGdlIC0gaCkgKiAxZTMsIHAgPSBRZyhuLCBmKTtcbiAgICAgIGlmIChuLnJlcXVlc3RTY2hlZHVsZWQgKyBwIDwgbyA/IG4ucmVxdWVzdFNjaGVkdWxlZCA9IG8gOiBuLnJlcXVlc3RTY2hlZHVsZWQgKz0gcCwgdGhpcy5sb2coYGxpdmUgcGxheWxpc3QgJHtlfSAke24uYWR2YW5jZWQgPyBcIlJFRlJFU0hFRCBcIiArIG4ubGFzdFBhcnRTbiArIFwiLVwiICsgbi5sYXN0UGFydEluZGV4IDogbi51cGRhdGVkID8gXCJVUERBVEVEXCIgOiBcIk1JU1NFRFwifWApLCAhdGhpcy5jYW5Mb2FkIHx8ICFuLmxpdmUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCB5LCBFLCBiO1xuICAgICAgaWYgKG4uY2FuQmxvY2tSZWxvYWQgJiYgbi5lbmRTTiAmJiBuLmFkdmFuY2VkKSB7XG4gICAgICAgIGNvbnN0IFIgPSB0aGlzLmhscy5jb25maWcubG93TGF0ZW5jeU1vZGUsIEEgPSBuLmxhc3RQYXJ0U24sIEYgPSBuLmVuZFNOLCBNID0gbi5sYXN0UGFydEluZGV4LCBIID0gTSAhPT0gLTEsIEsgPSBBID09PSBGO1xuICAgICAgICBIID8gSyA/IChFID0gRiArIDEsIGIgPSBSID8gMCA6IE0pIDogKEUgPSBBLCBiID0gUiA/IE0gKyAxIDogbi5tYXhQYXJ0SW5kZXgpIDogRSA9IEYgKyAxO1xuICAgICAgICBjb25zdCBqID0gbi5hZ2UsIEMgPSBqICsgbi5hZ2VIZWFkZXI7XG4gICAgICAgIGxldCBrID0gTWF0aC5taW4oQyAtIG4ucGFydFRhcmdldCwgbi50YXJnZXRkdXJhdGlvbiAqIDEuNSk7XG4gICAgICAgIGlmIChrID4gMCkge1xuICAgICAgICAgIGlmIChDID4gbi50YXJnZXRkdXJhdGlvbiAqIDMpXG4gICAgICAgICAgICB0aGlzLmxvZyhgUGxheWxpc3QgbGFzdCBhZHZhbmNlZCAke2oudG9GaXhlZCgyKX1zIGFnby4gT21pdHRpbmcgc2VnbWVudCBhbmQgcGFydCBkaXJlY3RpdmVzLmApLCBFID0gdm9pZCAwLCBiID0gdm9pZCAwO1xuICAgICAgICAgIGVsc2UgaWYgKHIgIT0gbnVsbCAmJiByLnR1bmVJbkdvYWwgJiYgQyAtIG4ucGFydFRhcmdldCA+IHIudHVuZUluR29hbClcbiAgICAgICAgICAgIHRoaXMud2FybihgQ0ROIFR1bmUtaW4gZ29hbCBpbmNyZWFzZWQgZnJvbTogJHtyLnR1bmVJbkdvYWx9IHRvOiAke2t9IHdpdGggcGxheWxpc3QgYWdlOiAke24uYWdlfWApLCBrID0gMDtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0ICQgPSBNYXRoLmZsb29yKGsgLyBuLnRhcmdldGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChFICs9ICQsIGIgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjb25zdCBXID0gTWF0aC5yb3VuZChrICUgbi50YXJnZXRkdXJhdGlvbiAvIG4ucGFydFRhcmdldCk7XG4gICAgICAgICAgICAgIGIgKz0gVztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubG9nKGBDRE4gVHVuZS1pbiBhZ2U6ICR7bi5hZ2VIZWFkZXJ9cyBsYXN0IGFkdmFuY2VkICR7ai50b0ZpeGVkKDIpfXMgZ29hbDogJHtrfSBza2lwIHNuICR7JH0gdG8gcGFydCAke2J9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG4udHVuZUluR29hbCA9IGs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPSB0aGlzLmdldERlbGl2ZXJ5RGlyZWN0aXZlcyhuLCB0LmRlbGl2ZXJ5RGlyZWN0aXZlcywgRSwgYiksIFIgfHwgIUspIHtcbiAgICAgICAgICBuLnJlcXVlc3RTY2hlZHVsZWQgPSBvLCB0aGlzLmxvYWRpbmdQbGF5bGlzdCh1LCB5KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSAobi5jYW5CbG9ja1JlbG9hZCB8fCBuLmNhblNraXBVbnRpbCkgJiYgKHkgPSB0aGlzLmdldERlbGl2ZXJ5RGlyZWN0aXZlcyhuLCB0LmRlbGl2ZXJ5RGlyZWN0aXZlcywgRSwgYikpO1xuICAgICAgeSAmJiBFICE9PSB2b2lkIDAgJiYgbi5jYW5CbG9ja1JlbG9hZCAmJiAobi5yZXF1ZXN0U2NoZWR1bGVkID0gaS5sb2FkaW5nLmZpcnN0ICsgTWF0aC5tYXgocCAtIGEgKiAyLCBwIC8gMikpLCB0aGlzLnNjaGVkdWxlTG9hZGluZyh1LCB5LCBuKTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMuY2xlYXJUaW1lcigpO1xuICB9XG4gIHNjaGVkdWxlTG9hZGluZyhlLCB0LCByKSB7XG4gICAgY29uc3QgbiA9IHIgfHwgZS5kZXRhaWxzO1xuICAgIGlmICghbikge1xuICAgICAgdGhpcy5sb2FkaW5nUGxheWxpc3QoZSwgdCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBvID0gbi5yZXF1ZXN0U2NoZWR1bGVkO1xuICAgIGlmIChpID49IG8pIHtcbiAgICAgIHRoaXMubG9hZGluZ1BsYXlsaXN0KGUsIHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBhID0gbyAtIGk7XG4gICAgdGhpcy5sb2coYHJlbG9hZCBsaXZlIHBsYXlsaXN0ICR7ZS5uYW1lIHx8IGUuYml0cmF0ZSArIFwiYnBzXCJ9IGluICR7TWF0aC5yb3VuZChhKX0gbXNgKSwgdGhpcy5jbGVhclRpbWVyKCksIHRoaXMudGltZXIgPSBzZWxmLnNldFRpbWVvdXQoKCkgPT4gdGhpcy5sb2FkaW5nUGxheWxpc3QoZSwgdCksIGEpO1xuICB9XG4gIGdldERlbGl2ZXJ5RGlyZWN0aXZlcyhlLCB0LCByLCBuKSB7XG4gICAgbGV0IGkgPSBvaChlKTtcbiAgICByZXR1cm4gdCAhPSBudWxsICYmIHQuc2tpcCAmJiBlLmRlbHRhVXBkYXRlRmFpbGVkICYmIChyID0gdC5tc24sIG4gPSB0LnBhcnQsIGkgPSBnby5ObyksIG5ldyBhaChyLCBuLCBpKTtcbiAgfVxuICBjaGVja1JldHJ5KGUpIHtcbiAgICBjb25zdCB0ID0gZS5kZXRhaWxzLCByID0gZWEoZSksIG4gPSBlLmVycm9yQWN0aW9uLCB7XG4gICAgICBhY3Rpb246IGksXG4gICAgICByZXRyeUNvdW50OiBvID0gMCxcbiAgICAgIHJldHJ5Q29uZmlnOiBhXG4gICAgfSA9IG4gfHwge30sIGwgPSAhIW4gJiYgISFhICYmIChpID09PSBadC5SZXRyeVJlcXVlc3QgfHwgIW4ucmVzb2x2ZWQgJiYgaSA9PT0gWnQuU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCk7XG4gICAgaWYgKGwpIHtcbiAgICAgIHZhciBjO1xuICAgICAgaWYgKG8gPj0gYS5tYXhOdW1SZXRyeSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgaWYgKHIgJiYgKGMgPSBlLmNvbnRleHQpICE9IG51bGwgJiYgYy5kZWxpdmVyeURpcmVjdGl2ZXMpXG4gICAgICAgIHRoaXMud2FybihgUmV0cnlpbmcgcGxheWxpc3QgbG9hZGluZyAke28gKyAxfS8ke2EubWF4TnVtUmV0cnl9IGFmdGVyIFwiJHt0fVwiIHdpdGhvdXQgZGVsaXZlcnktZGlyZWN0aXZlc2ApLCB0aGlzLmxvYWRQbGF5bGlzdCgpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHUgPSB5dShhLCBvKTtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyKCksIHRoaXMudGltZXIgPSBzZWxmLnNldFRpbWVvdXQoKCkgPT4gdGhpcy5sb2FkUGxheWxpc3QoKSwgdSksIHRoaXMud2FybihgUmV0cnlpbmcgcGxheWxpc3QgbG9hZGluZyAke28gKyAxfS8ke2EubWF4TnVtUmV0cnl9IGFmdGVyIFwiJHt0fVwiIGluICR7dX1tc2ApO1xuICAgICAgfVxuICAgICAgZS5sZXZlbFJldHJ5ID0gITAsIG4ucmVzb2x2ZWQgPSAhMDtcbiAgICB9XG4gICAgcmV0dXJuIGw7XG4gIH1cbn1cbmZ1bmN0aW9uIEFwKHMsIGUpIHtcbiAgaWYgKHMubGVuZ3RoICE9PSBlLmxlbmd0aClcbiAgICByZXR1cm4gITE7XG4gIGZvciAobGV0IHQgPSAwOyB0IDwgcy5sZW5ndGg7IHQrKylcbiAgICBpZiAoIVNpKHNbdF0uYXR0cnMsIGVbdF0uYXR0cnMpKVxuICAgICAgcmV0dXJuICExO1xuICByZXR1cm4gITA7XG59XG5mdW5jdGlvbiBTaShzLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSBzW1wiU1RBQkxFLVJFTkRJVElPTi1JRFwiXTtcbiAgcmV0dXJuIHIgJiYgIXQgPyByID09PSBlW1wiU1RBQkxFLVJFTkRJVElPTi1JRFwiXSA6ICEodCB8fCBbXCJMQU5HVUFHRVwiLCBcIk5BTUVcIiwgXCJDSEFSQUNURVJJU1RJQ1NcIiwgXCJBVVRPU0VMRUNUXCIsIFwiREVGQVVMVFwiLCBcIkZPUkNFRFwiLCBcIkFTU09DLUxBTkdVQUdFXCJdKS5zb21lKChuKSA9PiBzW25dICE9PSBlW25dKTtcbn1cbmZ1bmN0aW9uIHljKHMsIGUpIHtcbiAgcmV0dXJuIGUubGFiZWwudG9Mb3dlckNhc2UoKSA9PT0gcy5uYW1lLnRvTG93ZXJDYXNlKCkgJiYgKCFlLmxhbmd1YWdlIHx8IGUubGFuZ3VhZ2UudG9Mb3dlckNhc2UoKSA9PT0gKHMubGFuZyB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpKTtcbn1cbmNsYXNzIGkyIGV4dGVuZHMga3Uge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoZSwgXCJhdWRpby10cmFjay1jb250cm9sbGVyXCIpLCB0aGlzLnRyYWNrcyA9IFtdLCB0aGlzLmdyb3VwSWRzID0gbnVsbCwgdGhpcy50cmFja3NJbkdyb3VwID0gW10sIHRoaXMudHJhY2tJZCA9IC0xLCB0aGlzLmN1cnJlbnRUcmFjayA9IG51bGwsIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gITAsIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHM6IGVcbiAgICB9ID0gdGhpcztcbiAgICBlLm9uKEkuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyksIGUub24oSS5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyksIGUub24oSS5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKSwgZS5vbihJLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKSwgZS5vbihJLkFVRElPX1RSQUNLX0xPQURFRCwgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkZWQsIHRoaXMpLCBlLm9uKEkuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHM6IGVcbiAgICB9ID0gdGhpcztcbiAgICBlLm9mZihJLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpLCBlLm9mZihJLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKSwgZS5vZmYoSS5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKSwgZS5vZmYoSS5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyksIGUub2ZmKEkuQVVESU9fVFJBQ0tfTE9BREVELCB0aGlzLm9uQXVkaW9UcmFja0xvYWRlZCwgdGhpcyksIGUub2ZmKEkuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKSwgdGhpcy50cmFja3MubGVuZ3RoID0gMCwgdGhpcy50cmFja3NJbkdyb3VwLmxlbmd0aCA9IDAsIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbCwgc3VwZXIuZGVzdHJveSgpO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMudHJhY2tzID0gW10sIHRoaXMudHJhY2tzSW5Hcm91cCA9IFtdLCB0aGlzLmdyb3VwSWRzID0gbnVsbCwgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsLCB0aGlzLnRyYWNrSWQgPSAtMSwgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSAhMDtcbiAgfVxuICBvbk1hbmlmZXN0UGFyc2VkKGUsIHQpIHtcbiAgICB0aGlzLnRyYWNrcyA9IHQuYXVkaW9UcmFja3MgfHwgW107XG4gIH1cbiAgb25BdWRpb1RyYWNrTG9hZGVkKGUsIHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZDogcixcbiAgICAgIGdyb3VwSWQ6IG4sXG4gICAgICBkZXRhaWxzOiBpXG4gICAgfSA9IHQsIG8gPSB0aGlzLnRyYWNrc0luR3JvdXBbcl07XG4gICAgaWYgKCFvIHx8IG8uZ3JvdXBJZCAhPT0gbikge1xuICAgICAgdGhpcy53YXJuKGBBdWRpbyB0cmFjayB3aXRoIGlkOiR7cn0gYW5kIGdyb3VwOiR7bn0gbm90IGZvdW5kIGluIGFjdGl2ZSBncm91cCAke28gPT0gbnVsbCA/IHZvaWQgMCA6IG8uZ3JvdXBJZH1gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYSA9IG8uZGV0YWlscztcbiAgICBvLmRldGFpbHMgPSB0LmRldGFpbHMsIHRoaXMubG9nKGBBdWRpbyB0cmFjayAke3J9IFwiJHtvLm5hbWV9XCIgbGFuZzoke28ubGFuZ30gZ3JvdXA6JHtufSBsb2FkZWQgWyR7aS5zdGFydFNOfS0ke2kuZW5kU059XWApLCByID09PSB0aGlzLnRyYWNrSWQgJiYgdGhpcy5wbGF5bGlzdExvYWRlZChyLCB0LCBhKTtcbiAgfVxuICBvbkxldmVsTG9hZGluZyhlLCB0KSB7XG4gICAgdGhpcy5zd2l0Y2hMZXZlbCh0LmxldmVsKTtcbiAgfVxuICBvbkxldmVsU3dpdGNoaW5nKGUsIHQpIHtcbiAgICB0aGlzLnN3aXRjaExldmVsKHQubGV2ZWwpO1xuICB9XG4gIHN3aXRjaExldmVsKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5obHMubGV2ZWxzW2VdO1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0gdC5hdWRpb0dyb3VwcyB8fCBudWxsLCBuID0gdGhpcy5ncm91cElkcztcbiAgICBsZXQgaSA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgIGlmICghciB8fCAobiA9PSBudWxsID8gdm9pZCAwIDogbi5sZW5ndGgpICE9PSAociA9PSBudWxsID8gdm9pZCAwIDogci5sZW5ndGgpIHx8IHIgIT0gbnVsbCAmJiByLnNvbWUoKGEpID0+IChuID09IG51bGwgPyB2b2lkIDAgOiBuLmluZGV4T2YoYSkpID09PSAtMSkpIHtcbiAgICAgIHRoaXMuZ3JvdXBJZHMgPSByLCB0aGlzLnRyYWNrSWQgPSAtMSwgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsO1xuICAgICAgY29uc3QgYSA9IHRoaXMudHJhY2tzLmZpbHRlcigoaCkgPT4gIXIgfHwgci5pbmRleE9mKGguZ3JvdXBJZCkgIT09IC0xKTtcbiAgICAgIGlmIChhLmxlbmd0aClcbiAgICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgJiYgIWEuc29tZSgoaCkgPT4gaC5kZWZhdWx0KSAmJiAodGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSAhMSksIGEuZm9yRWFjaCgoaCwgZikgPT4ge1xuICAgICAgICAgIGguaWQgPSBmO1xuICAgICAgICB9KTtcbiAgICAgIGVsc2UgaWYgKCFpICYmICF0aGlzLnRyYWNrc0luR3JvdXAubGVuZ3RoKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLnRyYWNrc0luR3JvdXAgPSBhO1xuICAgICAgY29uc3QgbCA9IHRoaXMuaGxzLmNvbmZpZy5hdWRpb1ByZWZlcmVuY2U7XG4gICAgICBpZiAoIWkgJiYgbCkge1xuICAgICAgICBjb25zdCBoID0gV3IobCwgYSwgVXMpO1xuICAgICAgICBpZiAoaCA+IC0xKVxuICAgICAgICAgIGkgPSBhW2hdO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBmID0gV3IobCwgdGhpcy50cmFja3MpO1xuICAgICAgICAgIGkgPSB0aGlzLnRyYWNrc1tmXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGMgPSB0aGlzLmZpbmRUcmFja0lkKGkpO1xuICAgICAgYyA9PT0gLTEgJiYgaSAmJiAoYyA9IHRoaXMuZmluZFRyYWNrSWQobnVsbCkpO1xuICAgICAgY29uc3QgdSA9IHtcbiAgICAgICAgYXVkaW9UcmFja3M6IGFcbiAgICAgIH07XG4gICAgICB0aGlzLmxvZyhgVXBkYXRpbmcgYXVkaW8gdHJhY2tzLCAke2EubGVuZ3RofSB0cmFjayhzKSBmb3VuZCBpbiBncm91cChzKTogJHtyID09IG51bGwgPyB2b2lkIDAgOiByLmpvaW4oXCIsXCIpfWApLCB0aGlzLmhscy50cmlnZ2VyKEkuQVVESU9fVFJBQ0tTX1VQREFURUQsIHUpO1xuICAgICAgY29uc3QgZCA9IHRoaXMudHJhY2tJZDtcbiAgICAgIGlmIChjICE9PSAtMSAmJiBkID09PSAtMSlcbiAgICAgICAgdGhpcy5zZXRBdWRpb1RyYWNrKGMpO1xuICAgICAgZWxzZSBpZiAoYS5sZW5ndGggJiYgZCA9PT0gLTEpIHtcbiAgICAgICAgdmFyIG87XG4gICAgICAgIGNvbnN0IGggPSBuZXcgRXJyb3IoYE5vIGF1ZGlvIHRyYWNrIHNlbGVjdGVkIGZvciBjdXJyZW50IGF1ZGlvIGdyb3VwLUlEKHMpOiAkeyhvID0gdGhpcy5ncm91cElkcykgPT0gbnVsbCA/IHZvaWQgMCA6IG8uam9pbihcIixcIil9IHRyYWNrIGNvdW50OiAke2EubGVuZ3RofWApO1xuICAgICAgICB0aGlzLndhcm4oaC5tZXNzYWdlKSwgdGhpcy5obHMudHJpZ2dlcihJLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogdmUuTUVESUFfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogSi5BVURJT19UUkFDS19MT0FEX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiAhMCxcbiAgICAgICAgICBlcnJvcjogaFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25FcnJvcihlLCB0KSB7XG4gICAgdC5mYXRhbCB8fCAhdC5jb250ZXh0IHx8IHQuY29udGV4dC50eXBlID09PSBLZS5BVURJT19UUkFDSyAmJiB0LmNvbnRleHQuaWQgPT09IHRoaXMudHJhY2tJZCAmJiAoIXRoaXMuZ3JvdXBJZHMgfHwgdGhpcy5ncm91cElkcy5pbmRleE9mKHQuY29udGV4dC5ncm91cElkKSAhPT0gLTEpICYmIHRoaXMuY2hlY2tSZXRyeSh0KTtcbiAgfVxuICBnZXQgYWxsQXVkaW9UcmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICB9XG4gIGdldCBhdWRpb1RyYWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3NJbkdyb3VwO1xuICB9XG4gIGdldCBhdWRpb1RyYWNrKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrSWQ7XG4gIH1cbiAgc2V0IGF1ZGlvVHJhY2soZSkge1xuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gITEsIHRoaXMuc2V0QXVkaW9UcmFjayhlKTtcbiAgfVxuICBzZXRBdWRpb09wdGlvbihlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuaGxzO1xuICAgIGlmICh0LmNvbmZpZy5hdWRpb1ByZWZlcmVuY2UgPSBlLCBlKSB7XG4gICAgICBjb25zdCByID0gdGhpcy5hbGxBdWRpb1RyYWNrcztcbiAgICAgIGlmICh0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9ICExLCByLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgICAgIGlmIChuICYmIHFzKGUsIG4sIFVzKSlcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgY29uc3QgaSA9IFdyKGUsIHRoaXMudHJhY2tzSW5Hcm91cCwgVXMpO1xuICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgY29uc3QgbyA9IHRoaXMudHJhY2tzSW5Hcm91cFtpXTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXRBdWRpb1RyYWNrKGkpLCBvO1xuICAgICAgICB9IGVsc2UgaWYgKG4pIHtcbiAgICAgICAgICBsZXQgbyA9IHQubG9hZExldmVsO1xuICAgICAgICAgIG8gPT09IC0xICYmIChvID0gdC5maXJzdEF1dG9MZXZlbCk7XG4gICAgICAgICAgY29uc3QgYSA9IG1iKGUsIHQubGV2ZWxzLCByLCBvLCBVcyk7XG4gICAgICAgICAgaWYgKGEgPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgdC5uZXh0TG9hZExldmVsID0gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5jaGFubmVscyB8fCBlLmF1ZGlvQ29kZWMpIHtcbiAgICAgICAgICBjb25zdCBvID0gV3IoZSwgcik7XG4gICAgICAgICAgaWYgKG8gPiAtMSlcbiAgICAgICAgICAgIHJldHVybiByW29dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHNldEF1ZGlvVHJhY2soZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnRyYWNrc0luR3JvdXA7XG4gICAgaWYgKGUgPCAwIHx8IGUgPj0gdC5sZW5ndGgpIHtcbiAgICAgIHRoaXMud2FybihgSW52YWxpZCBhdWRpbyB0cmFjayBpZDogJHtlfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9ICExO1xuICAgIGNvbnN0IHIgPSB0aGlzLmN1cnJlbnRUcmFjaywgbiA9IHRbZV0sIGkgPSBuLmRldGFpbHMgJiYgIW4uZGV0YWlscy5saXZlO1xuICAgIGlmIChlID09PSB0aGlzLnRyYWNrSWQgJiYgbiA9PT0gciAmJiBpIHx8ICh0aGlzLmxvZyhgU3dpdGNoaW5nIHRvIGF1ZGlvLXRyYWNrICR7ZX0gXCIke24ubmFtZX1cIiBsYW5nOiR7bi5sYW5nfSBncm91cDoke24uZ3JvdXBJZH0gY2hhbm5lbHM6JHtuLmNoYW5uZWxzfWApLCB0aGlzLnRyYWNrSWQgPSBlLCB0aGlzLmN1cnJlbnRUcmFjayA9IG4sIHRoaXMuaGxzLnRyaWdnZXIoSS5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHR0KHt9LCBuKSksIGkpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSB0aGlzLnN3aXRjaFBhcmFtcyhuLnVybCwgciA9PSBudWxsID8gdm9pZCAwIDogci5kZXRhaWxzLCBuLmRldGFpbHMpO1xuICAgIHRoaXMubG9hZFBsYXlsaXN0KG8pO1xuICB9XG4gIGZpbmRUcmFja0lkKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy50cmFja3NJbkdyb3VwO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykge1xuICAgICAgY29uc3QgbiA9IHRbcl07XG4gICAgICBpZiAoISh0aGlzLnNlbGVjdERlZmF1bHRUcmFjayAmJiAhbi5kZWZhdWx0KSAmJiAoIWUgfHwgcXMoZSwgbiwgVXMpKSlcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICAgIGlmIChlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWU6IHIsXG4gICAgICAgIGxhbmc6IG4sXG4gICAgICAgIGFzc29jTGFuZzogaSxcbiAgICAgICAgY2hhcmFjdGVyaXN0aWNzOiBvLFxuICAgICAgICBhdWRpb0NvZGVjOiBhLFxuICAgICAgICBjaGFubmVsczogbFxuICAgICAgfSA9IGU7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHQubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgY29uc3QgdSA9IHRbY107XG4gICAgICAgIGlmIChxcyh7XG4gICAgICAgICAgbmFtZTogcixcbiAgICAgICAgICBsYW5nOiBuLFxuICAgICAgICAgIGFzc29jTGFuZzogaSxcbiAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3M6IG8sXG4gICAgICAgICAgYXVkaW9Db2RlYzogYSxcbiAgICAgICAgICBjaGFubmVsczogbFxuICAgICAgICB9LCB1LCBVcykpXG4gICAgICAgICAgcmV0dXJuIGM7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHQubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgY29uc3QgdSA9IHRbY107XG4gICAgICAgIGlmIChTaShlLmF0dHJzLCB1LmF0dHJzLCBbXCJMQU5HVUFHRVwiLCBcIkFTU09DLUxBTkdVQUdFXCIsIFwiQ0hBUkFDVEVSSVNUSUNTXCJdKSlcbiAgICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgdC5sZW5ndGg7IGMrKykge1xuICAgICAgICBjb25zdCB1ID0gdFtjXTtcbiAgICAgICAgaWYgKFNpKGUuYXR0cnMsIHUuYXR0cnMsIFtcIkxBTkdVQUdFXCJdKSlcbiAgICAgICAgICByZXR1cm4gYztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGxvYWRQbGF5bGlzdChlKSB7XG4gICAgc3VwZXIubG9hZFBsYXlsaXN0KCk7XG4gICAgY29uc3QgdCA9IHRoaXMuY3VycmVudFRyYWNrO1xuICAgIHRoaXMuc2hvdWxkTG9hZFBsYXlsaXN0KHQpICYmIFFvKHQudXJsLCB0aGlzLmhscykgJiYgdGhpcy5zY2hlZHVsZUxvYWRpbmcodCwgZSk7XG4gIH1cbiAgbG9hZGluZ1BsYXlsaXN0KGUsIHQpIHtcbiAgICBzdXBlci5sb2FkaW5nUGxheWxpc3QoZSwgdCk7XG4gICAgY29uc3QgciA9IGUuaWQsIG4gPSBlLmdyb3VwSWQsIGkgPSB0aGlzLmdldFVybFdpdGhEaXJlY3RpdmVzKGUudXJsLCB0KSwgbyA9IGUuZGV0YWlscywgYSA9IG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uYWdlO1xuICAgIHRoaXMubG9nKGBMb2FkaW5nIGF1ZGlvLXRyYWNrICR7cn0gXCIke2UubmFtZX1cIiBsYW5nOiR7ZS5sYW5nfSBncm91cDoke259JHsodCA9PSBudWxsID8gdm9pZCAwIDogdC5tc24pICE9PSB2b2lkIDAgPyBcIiBhdCBzbiBcIiArIHQubXNuICsgXCIgcGFydCBcIiArIHQucGFydCA6IFwiXCJ9JHthICYmIG8ubGl2ZSA/IFwiIGFnZSBcIiArIGEudG9GaXhlZCgxKSArIChvLnR5cGUgJiYgXCIgXCIgKyBvLnR5cGUgfHwgXCJcIikgOiBcIlwifSAke2l9YCksIHRoaXMuaGxzLnRyaWdnZXIoSS5BVURJT19UUkFDS19MT0FESU5HLCB7XG4gICAgICB1cmw6IGksXG4gICAgICBpZDogcixcbiAgICAgIGdyb3VwSWQ6IG4sXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IHQgfHwgbnVsbCxcbiAgICAgIHRyYWNrOiBlXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIG8yIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMudHJhY2tzID0gdm9pZCAwLCB0aGlzLnF1ZXVlcyA9IHtcbiAgICAgIHZpZGVvOiBbXSxcbiAgICAgIGF1ZGlvOiBbXSxcbiAgICAgIGF1ZGlvdmlkZW86IFtdXG4gICAgfSwgdGhpcy50cmFja3MgPSBlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy50cmFja3MgPSB0aGlzLnF1ZXVlcyA9IG51bGw7XG4gIH1cbiAgYXBwZW5kKGUsIHQsIHIpIHtcbiAgICBpZiAodGhpcy5xdWV1ZXMgPT09IG51bGwgfHwgdGhpcy50cmFja3MgPT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbiA9IHRoaXMucXVldWVzW3RdO1xuICAgIG4ucHVzaChlKSwgbi5sZW5ndGggPT09IDEgJiYgIXIgJiYgdGhpcy5leGVjdXRlTmV4dCh0KTtcbiAgfVxuICBhcHBlbmRCbG9ja2VyKGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHQpID0+IHtcbiAgICAgIGNvbnN0IHIgPSB7XG4gICAgICAgIGxhYmVsOiBcImFzeW5jLWJsb2NrZXJcIixcbiAgICAgICAgZXhlY3V0ZTogdCxcbiAgICAgICAgb25TdGFydDogKCkgPT4ge1xuICAgICAgICB9LFxuICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6ICgpID0+IHtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuYXBwZW5kKHIsIGUpO1xuICAgIH0pO1xuICB9XG4gIHByZXBlbmRCbG9ja2VyKGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHQpID0+IHtcbiAgICAgIGlmICh0aGlzLnF1ZXVlcykge1xuICAgICAgICBjb25zdCByID0ge1xuICAgICAgICAgIGxhYmVsOiBcImFzeW5jLWJsb2NrZXItcHJlcGVuZFwiLFxuICAgICAgICAgIGV4ZWN1dGU6IHQsXG4gICAgICAgICAgb25TdGFydDogKCkgPT4ge1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICAgIH0sXG4gICAgICAgICAgb25FcnJvcjogKCkgPT4ge1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5xdWV1ZXNbZV0udW5zaGlmdChyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZW1vdmVCbG9ja2VycygpIHtcbiAgICB0aGlzLnF1ZXVlcyAhPT0gbnVsbCAmJiBbdGhpcy5xdWV1ZXMudmlkZW8sIHRoaXMucXVldWVzLmF1ZGlvLCB0aGlzLnF1ZXVlcy5hdWRpb3ZpZGVvXS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICB2YXIgdDtcbiAgICAgIGNvbnN0IHIgPSAodCA9IGVbMF0pID09IG51bGwgPyB2b2lkIDAgOiB0LmxhYmVsO1xuICAgICAgKHIgPT09IFwiYXN5bmMtYmxvY2tlclwiIHx8IHIgPT09IFwiYXN5bmMtYmxvY2tlci1wcmVwZW5kXCIpICYmIChlWzBdLmV4ZWN1dGUoKSwgZS5zcGxpY2UoMCwgMSkpO1xuICAgIH0pO1xuICB9XG4gIHVuYmxvY2tBdWRpbyhlKSB7XG4gICAgaWYgKHRoaXMucXVldWVzID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMucXVldWVzLmF1ZGlvWzBdID09PSBlICYmIHRoaXMuc2hpZnRBbmRFeGVjdXRlTmV4dChcImF1ZGlvXCIpO1xuICB9XG4gIGV4ZWN1dGVOZXh0KGUpIHtcbiAgICBpZiAodGhpcy5xdWV1ZXMgPT09IG51bGwgfHwgdGhpcy50cmFja3MgPT09IG51bGwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMucXVldWVzW2VdO1xuICAgIGlmICh0Lmxlbmd0aCkge1xuICAgICAgY29uc3QgbiA9IHRbMF07XG4gICAgICB0cnkge1xuICAgICAgICBuLmV4ZWN1dGUoKTtcbiAgICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgICAgdmFyIHI7XG4gICAgICAgIGlmIChuLm9uRXJyb3IoaSksIHRoaXMucXVldWVzID09PSBudWxsIHx8IHRoaXMudHJhY2tzID09PSBudWxsKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbyA9IChyID0gdGhpcy50cmFja3NbZV0pID09IG51bGwgPyB2b2lkIDAgOiByLmJ1ZmZlcjtcbiAgICAgICAgbyAhPSBudWxsICYmIG8udXBkYXRpbmcgfHwgdGhpcy5zaGlmdEFuZEV4ZWN1dGVOZXh0KGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzaGlmdEFuZEV4ZWN1dGVOZXh0KGUpIHtcbiAgICB0aGlzLnF1ZXVlcyAhPT0gbnVsbCAmJiAodGhpcy5xdWV1ZXNbZV0uc2hpZnQoKSwgdGhpcy5leGVjdXRlTmV4dChlKSk7XG4gIH1cbiAgY3VycmVudChlKSB7XG4gICAgdmFyIHQ7XG4gICAgcmV0dXJuICgodCA9IHRoaXMucXVldWVzKSA9PSBudWxsID8gdm9pZCAwIDogdFtlXVswXSkgfHwgbnVsbDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICBjb25zdCB7XG4gICAgICBxdWV1ZXM6IGUsXG4gICAgICB0cmFja3M6IHRcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gZSA9PT0gbnVsbCB8fCB0ID09PSBudWxsID8gXCI8ZGVzdHJveWVkPlwiIDogYFxuJHt0aGlzLmxpc3QoXCJ2aWRlb1wiKX1cbiR7dGhpcy5saXN0KFwiYXVkaW9cIil9XG4ke3RoaXMubGlzdChcImF1ZGlvdmlkZW9cIil9fWA7XG4gIH1cbiAgbGlzdChlKSB7XG4gICAgdmFyIHQsIHI7XG4gICAgcmV0dXJuICh0ID0gdGhpcy5xdWV1ZXMpICE9IG51bGwgJiYgdFtlXSB8fCAociA9IHRoaXMudHJhY2tzKSAhPSBudWxsICYmIHJbZV0gPyBgJHtlfTogKCR7dGhpcy5saXN0U2JJbmZvKGUpfSkgJHt0aGlzLmxpc3RPcHMoZSl9YCA6IFwiXCI7XG4gIH1cbiAgbGlzdFNiSW5mbyhlKSB7XG4gICAgdmFyIHQ7XG4gICAgY29uc3QgciA9ICh0ID0gdGhpcy50cmFja3MpID09IG51bGwgPyB2b2lkIDAgOiB0W2VdLCBuID0gciA9PSBudWxsID8gdm9pZCAwIDogci5idWZmZXI7XG4gICAgcmV0dXJuIG4gPyBgU291cmNlQnVmZmVyJHtuLnVwZGF0aW5nID8gXCIgdXBkYXRpbmdcIiA6IFwiXCJ9JHtyLmVuZGVkID8gXCIgZW5kZWRcIiA6IFwiXCJ9JHtyLmVuZGluZyA/IFwiIGVuZGluZ1wiIDogXCJcIn1gIDogXCJub25lXCI7XG4gIH1cbiAgbGlzdE9wcyhlKSB7XG4gICAgdmFyIHQ7XG4gICAgcmV0dXJuICgodCA9IHRoaXMucXVldWVzKSA9PSBudWxsID8gdm9pZCAwIDogdFtlXS5tYXAoKHIpID0+IHIubGFiZWwpLmpvaW4oXCIsIFwiKSkgfHwgXCJcIjtcbiAgfVxufVxuY29uc3QgS2ggPSAvKGF2Y1sxMjM0XXxodmMxfGhldjF8ZHZoWzFlXXx2cDA5fGF2MDEpKD86XFwuW14uLF0rKSsvLCBJcCA9IFwiSGxzSnNUcmFja1JlbW92ZWRFcnJvclwiO1xuY2xhc3MgYTIgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBzdXBlcihlKSwgdGhpcy5uYW1lID0gSXA7XG4gIH1cbn1cbmNsYXNzIGwyIGV4dGVuZHMgTHIge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoXCJidWZmZXItY29udHJvbGxlclwiLCBlLmxvZ2dlciksIHRoaXMuaGxzID0gdm9pZCAwLCB0aGlzLmZyYWdtZW50VHJhY2tlciA9IHZvaWQgMCwgdGhpcy5kZXRhaWxzID0gbnVsbCwgdGhpcy5fb2JqZWN0VXJsID0gbnVsbCwgdGhpcy5vcGVyYXRpb25RdWV1ZSA9IG51bGwsIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNUb3RhbCA9IDAsIHRoaXMubWVkaWEgPSBudWxsLCB0aGlzLm1lZGlhU291cmNlID0gbnVsbCwgdGhpcy5sYXN0TXBlZ0F1ZGlvQ2h1bmsgPSBudWxsLCB0aGlzLmJsb2NrZWRBdWRpb0FwcGVuZCA9IG51bGwsIHRoaXMubGFzdFZpZGVvQXBwZW5kRW5kID0gMCwgdGhpcy5hcHBlbmRTb3VyY2UgPSB2b2lkIDAsIHRoaXMudHJhbnNmZXJEYXRhID0gdm9pZCAwLCB0aGlzLm92ZXJyaWRlcyA9IHZvaWQgMCwgdGhpcy5hcHBlbmRFcnJvcnMgPSB7XG4gICAgICBhdWRpbzogMCxcbiAgICAgIHZpZGVvOiAwLFxuICAgICAgYXVkaW92aWRlbzogMFxuICAgIH0sIHRoaXMudHJhY2tzID0ge30sIHRoaXMuc291cmNlQnVmZmVycyA9IFtbbnVsbCwgbnVsbF0sIFtudWxsLCBudWxsXV0sIHRoaXMuX29uRW5kU3RyZWFtaW5nID0gKHIpID0+IHtcbiAgICAgIHZhciBuO1xuICAgICAgdGhpcy5obHMgJiYgKChuID0gdGhpcy5tZWRpYVNvdXJjZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG4ucmVhZHlTdGF0ZSkgPT09IFwib3BlblwiICYmIHRoaXMuaGxzLnBhdXNlQnVmZmVyaW5nKCk7XG4gICAgfSwgdGhpcy5fb25TdGFydFN0cmVhbWluZyA9IChyKSA9PiB7XG4gICAgICB0aGlzLmhscyAmJiB0aGlzLmhscy5yZXN1bWVCdWZmZXJpbmcoKTtcbiAgICB9LCB0aGlzLl9vbk1lZGlhU291cmNlT3BlbiA9IChyKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1lZGlhOiBuLFxuICAgICAgICBtZWRpYVNvdXJjZTogaVxuICAgICAgfSA9IHRoaXM7XG4gICAgICByICYmIHRoaXMubG9nKFwiTWVkaWEgc291cmNlIG9wZW5lZFwiKSwgISghbiB8fCAhaSkgJiYgKGkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNvdXJjZW9wZW5cIiwgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4pLCBuLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlbXB0aWVkXCIsIHRoaXMuX29uTWVkaWFFbXB0aWVkKSwgdGhpcy51cGRhdGVEdXJhdGlvbigpLCB0aGlzLmhscy50cmlnZ2VyKEkuTUVESUFfQVRUQUNIRUQsIHtcbiAgICAgICAgbWVkaWE6IG4sXG4gICAgICAgIG1lZGlhU291cmNlOiBpXG4gICAgICB9KSwgdGhpcy5tZWRpYVNvdXJjZSAhPT0gbnVsbCAmJiB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpKTtcbiAgICB9LCB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLmxvZyhcIk1lZGlhIHNvdXJjZSBjbG9zZWRcIik7XG4gICAgfSwgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5sb2coXCJNZWRpYSBzb3VyY2UgZW5kZWRcIik7XG4gICAgfSwgdGhpcy5fb25NZWRpYUVtcHRpZWQgPSAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1lZGlhU3JjOiByLFxuICAgICAgICBfb2JqZWN0VXJsOiBuXG4gICAgICB9ID0gdGhpcztcbiAgICAgIHIgIT09IG4gJiYgdGhpcy5lcnJvcihgTWVkaWEgZWxlbWVudCBzcmMgd2FzIHNldCB3aGlsZSBhdHRhY2hpbmcgTWVkaWFTb3VyY2UgKCR7bn0gPiAke3J9KWApO1xuICAgIH0sIHRoaXMuaGxzID0gZSwgdGhpcy5mcmFnbWVudFRyYWNrZXIgPSB0LCB0aGlzLmFwcGVuZFNvdXJjZSA9IENTKE1zKGUuY29uZmlnLnByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSkpLCB0aGlzLmluaXRUcmFja3MoKSwgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIGhhc1NvdXJjZVR5cGVzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRyYWNrcykubGVuZ3RoID4gMDtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpLCB0aGlzLmRldGFpbHMgPSBudWxsLCB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayA9IHRoaXMuYmxvY2tlZEF1ZGlvQXBwZW5kID0gbnVsbCwgdGhpcy50cmFuc2ZlckRhdGEgPSB0aGlzLm92ZXJyaWRlcyA9IHZvaWQgMCwgdGhpcy5vcGVyYXRpb25RdWV1ZSAmJiAodGhpcy5vcGVyYXRpb25RdWV1ZS5kZXN0cm95KCksIHRoaXMub3BlcmF0aW9uUXVldWUgPSBudWxsKSwgdGhpcy5obHMgPSB0aGlzLmZyYWdtZW50VHJhY2tlciA9IG51bGwsIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuID0gdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlID0gbnVsbCwgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkID0gbnVsbCwgdGhpcy5fb25TdGFydFN0cmVhbWluZyA9IHRoaXMuX29uRW5kU3RyZWFtaW5nID0gbnVsbDtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHM6IGVcbiAgICB9ID0gdGhpcztcbiAgICBlLm9uKEkuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpLCBlLm9uKEkuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpLCBlLm9uKEkuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyksIGUub24oSS5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyksIGUub24oSS5CVUZGRVJfUkVTRVQsIHRoaXMub25CdWZmZXJSZXNldCwgdGhpcyksIGUub24oSS5CVUZGRVJfQVBQRU5ESU5HLCB0aGlzLm9uQnVmZmVyQXBwZW5kaW5nLCB0aGlzKSwgZS5vbihJLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpLCBlLm9uKEkuQlVGRkVSX0VPUywgdGhpcy5vbkJ1ZmZlckVvcywgdGhpcyksIGUub24oSS5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyksIGUub24oSS5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKSwgZS5vbihJLkZSQUdfUEFSU0VELCB0aGlzLm9uRnJhZ1BhcnNlZCwgdGhpcyksIGUub24oSS5GUkFHX0NIQU5HRUQsIHRoaXMub25GcmFnQ2hhbmdlZCwgdGhpcyksIGUub24oSS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsczogZVxuICAgIH0gPSB0aGlzO1xuICAgIGUub2ZmKEkuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpLCBlLm9mZihJLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKSwgZS5vZmYoSS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKSwgZS5vZmYoSS5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyksIGUub2ZmKEkuQlVGRkVSX1JFU0VULCB0aGlzLm9uQnVmZmVyUmVzZXQsIHRoaXMpLCBlLm9mZihJLkJVRkZFUl9BUFBFTkRJTkcsIHRoaXMub25CdWZmZXJBcHBlbmRpbmcsIHRoaXMpLCBlLm9mZihJLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpLCBlLm9mZihJLkJVRkZFUl9FT1MsIHRoaXMub25CdWZmZXJFb3MsIHRoaXMpLCBlLm9mZihJLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKSwgZS5vZmYoSS5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKSwgZS5vZmYoSS5GUkFHX1BBUlNFRCwgdGhpcy5vbkZyYWdQYXJzZWQsIHRoaXMpLCBlLm9mZihJLkZSQUdfQ0hBTkdFRCwgdGhpcy5vbkZyYWdDaGFuZ2VkLCB0aGlzKSwgZS5vZmYoSS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICB0cmFuc2Zlck1lZGlhKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhOiBlLFxuICAgICAgbWVkaWFTb3VyY2U6IHRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWUpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCByID0ge307XG4gICAgaWYgKHRoaXMub3BlcmF0aW9uUXVldWUpIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLmlzVXBkYXRpbmcoKTtcbiAgICAgIGkgfHwgdGhpcy5vcGVyYXRpb25RdWV1ZS5yZW1vdmVCbG9ja2VycygpO1xuICAgICAgY29uc3QgbyA9IHRoaXMuaXNRdWV1ZWQoKTtcbiAgICAgIChpIHx8IG8pICYmIHRoaXMud2FybihgVHJhbnNmZXJpbmcgTWVkaWFTb3VyY2Ugd2l0aCR7byA/IFwiIG9wZXJhdGlvbnMgaW4gcXVldWVcIiA6IFwiXCJ9JHtpID8gXCIgdXBkYXRpbmcgU291cmNlQnVmZmVyKHMpXCIgOiBcIlwifSAke3RoaXMub3BlcmF0aW9uUXVldWV9YCksIHRoaXMub3BlcmF0aW9uUXVldWUuZGVzdHJveSgpO1xuICAgIH1cbiAgICBjb25zdCBuID0gdGhpcy50cmFuc2ZlckRhdGE7XG4gICAgcmV0dXJuICF0aGlzLnNvdXJjZUJ1ZmZlckNvdW50ICYmIG4gJiYgbi5tZWRpYVNvdXJjZSA9PT0gdCA/IG50KHIsIG4udHJhY2tzKSA6IHRoaXMuc291cmNlQnVmZmVycy5mb3JFYWNoKChpKSA9PiB7XG4gICAgICBjb25zdCBbb10gPSBpO1xuICAgICAgbyAmJiAocltvXSA9IG50KHt9LCB0aGlzLnRyYWNrc1tvXSksIHRoaXMucmVtb3ZlQnVmZmVyKG8pKSwgaVswXSA9IGlbMV0gPSBudWxsO1xuICAgIH0pLCB7XG4gICAgICBtZWRpYTogZSxcbiAgICAgIG1lZGlhU291cmNlOiB0LFxuICAgICAgdHJhY2tzOiByXG4gICAgfTtcbiAgfVxuICBpbml0VHJhY2tzKCkge1xuICAgIGNvbnN0IGUgPSB7fTtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMgPSBbW251bGwsIG51bGxdLCBbbnVsbCwgbnVsbF1dLCB0aGlzLnRyYWNrcyA9IGUsIHRoaXMucmVzZXRRdWV1ZSgpLCB0aGlzLnJlc2V0QXBwZW5kRXJyb3JzKCksIHRoaXMubGFzdE1wZWdBdWRpb0NodW5rID0gdGhpcy5ibG9ja2VkQXVkaW9BcHBlbmQgPSBudWxsLCB0aGlzLmxhc3RWaWRlb0FwcGVuZEVuZCA9IDA7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5idWZmZXJDb2RlY0V2ZW50c1RvdGFsID0gMCwgdGhpcy5kZXRhaWxzID0gbnVsbDtcbiAgfVxuICBvbk1hbmlmZXN0UGFyc2VkKGUsIHQpIHtcbiAgICB2YXIgcjtcbiAgICBsZXQgbiA9IDI7XG4gICAgKHQuYXVkaW8gJiYgIXQudmlkZW8gfHwgIXQuYWx0QXVkaW8pICYmIChuID0gMSksIHRoaXMuYnVmZmVyQ29kZWNFdmVudHNUb3RhbCA9IG4sIHRoaXMubG9nKGAke259IGJ1ZmZlckNvZGVjIGV2ZW50KHMpIGV4cGVjdGVkLmApLCAociA9IHRoaXMudHJhbnNmZXJEYXRhKSAhPSBudWxsICYmIHIubWVkaWFTb3VyY2UgJiYgdGhpcy5zb3VyY2VCdWZmZXJDb3VudCAmJiBuICYmIHRoaXMuYnVmZmVyQ3JlYXRlZCgpO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hpbmcoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLm1lZGlhID0gdC5tZWRpYTtcbiAgICB0aGlzLnRyYW5zZmVyRGF0YSA9IHRoaXMub3ZlcnJpZGVzID0gdm9pZCAwO1xuICAgIGNvbnN0IG4gPSBNcyh0aGlzLmFwcGVuZFNvdXJjZSk7XG4gICAgaWYgKG4pIHtcbiAgICAgIGNvbnN0IGkgPSAhIXQubWVkaWFTb3VyY2U7XG4gICAgICAoaSB8fCB0Lm92ZXJyaWRlcykgJiYgKHRoaXMudHJhbnNmZXJEYXRhID0gdCwgdGhpcy5vdmVycmlkZXMgPSB0Lm92ZXJyaWRlcyk7XG4gICAgICBjb25zdCBvID0gdGhpcy5tZWRpYVNvdXJjZSA9IHQubWVkaWFTb3VyY2UgfHwgbmV3IG4oKTtcbiAgICAgIGlmICh0aGlzLmFzc2lnbk1lZGlhU291cmNlKG8pLCBpKVxuICAgICAgICB0aGlzLl9vYmplY3RVcmwgPSByLnNyYywgdGhpcy5hdHRhY2hUcmFuc2ZlcnJlZCgpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLl9vYmplY3RVcmwgPSBzZWxmLlVSTC5jcmVhdGVPYmplY3RVUkwobyk7XG4gICAgICAgIGlmICh0aGlzLmFwcGVuZFNvdXJjZSlcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgci5yZW1vdmVBdHRyaWJ1dGUoXCJzcmNcIik7XG4gICAgICAgICAgICBjb25zdCBsID0gc2VsZi5NYW5hZ2VkTWVkaWFTb3VyY2U7XG4gICAgICAgICAgICByLmRpc2FibGVSZW1vdGVQbGF5YmFjayA9IHIuZGlzYWJsZVJlbW90ZVBsYXliYWNrIHx8IGwgJiYgbyBpbnN0YW5jZW9mIGwsIEhoKHIpLCBjMihyLCBhKSwgci5sb2FkKCk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICByLnNyYyA9IGE7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgci5zcmMgPSBhO1xuICAgICAgfVxuICAgICAgci5hZGRFdmVudExpc3RlbmVyKFwiZW1wdGllZFwiLCB0aGlzLl9vbk1lZGlhRW1wdGllZCk7XG4gICAgfVxuICB9XG4gIGFzc2lnbk1lZGlhU291cmNlKGUpIHtcbiAgICB2YXIgdCwgcjtcbiAgICB0aGlzLmxvZyhgJHsoKHQgPSB0aGlzLnRyYW5zZmVyRGF0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IHQubWVkaWFTb3VyY2UpID09PSBlID8gXCJ0cmFuc2ZlcnJlZFwiIDogXCJjcmVhdGVkXCJ9IG1lZGlhIHNvdXJjZTogJHsociA9IGUuY29uc3RydWN0b3IpID09IG51bGwgPyB2b2lkIDAgOiByLm5hbWV9YCksIGUuYWRkRXZlbnRMaXN0ZW5lcihcInNvdXJjZW9wZW5cIiwgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4pLCBlLmFkZEV2ZW50TGlzdGVuZXIoXCJzb3VyY2VlbmRlZFwiLCB0aGlzLl9vbk1lZGlhU291cmNlRW5kZWQpLCBlLmFkZEV2ZW50TGlzdGVuZXIoXCJzb3VyY2VjbG9zZVwiLCB0aGlzLl9vbk1lZGlhU291cmNlQ2xvc2UpLCB0aGlzLmFwcGVuZFNvdXJjZSAmJiAoZS5hZGRFdmVudExpc3RlbmVyKFwic3RhcnRzdHJlYW1pbmdcIiwgdGhpcy5fb25TdGFydFN0cmVhbWluZyksIGUuYWRkRXZlbnRMaXN0ZW5lcihcImVuZHN0cmVhbWluZ1wiLCB0aGlzLl9vbkVuZFN0cmVhbWluZykpO1xuICB9XG4gIGF0dGFjaFRyYW5zZmVycmVkKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm1lZGlhLCB0ID0gdGhpcy50cmFuc2ZlckRhdGE7XG4gICAgaWYgKCF0IHx8ICFlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSB0aGlzLnRyYWNrcywgbiA9IHQudHJhY2tzLCBpID0gbiA/IE9iamVjdC5rZXlzKG4pIDogbnVsbCwgbyA9IGkgPyBpLmxlbmd0aCA6IDAsIGEgPSAoKSA9PiB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgdGhpcy5tZWRpYSAmJiB0aGlzLm1lZGlhU291cmNlT3Blbk9yRW5kZWQgJiYgdGhpcy5fb25NZWRpYVNvdXJjZU9wZW4oKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKG4gJiYgaSAmJiBvKSB7XG4gICAgICBpZiAoIXRoaXMudHJhY2tzUmVhZHkpIHtcbiAgICAgICAgdGhpcy5obHMuY29uZmlnLnN0YXJ0RnJhZ1ByZWZldGNoID0gITAsIHRoaXMubG9nKFwiYXR0YWNoVHJhbnNmZXJyZWQ6IHdhaXRpbmcgZm9yIFNvdXJjZUJ1ZmZlciB0cmFjayBpbmZvXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5sb2coYGF0dGFjaFRyYW5zZmVycmVkOiAoYnVmZmVyQ29kZWNFdmVudHNUb3RhbCAke3RoaXMuYnVmZmVyQ29kZWNFdmVudHNUb3RhbH0pXG5yZXF1aXJlZCB0cmFja3M6ICR7YXQociwgKGwsIGMpID0+IGwgPT09IFwiaW5pdFNlZ21lbnRcIiA/IHZvaWQgMCA6IGMpfTtcbnRyYW5zZmVyIHRyYWNrczogJHthdChuLCAobCwgYykgPT4gbCA9PT0gXCJpbml0U2VnbWVudFwiID8gdm9pZCAwIDogYyl9fWApLCAhQWcobiwgcikpIHtcbiAgICAgICAgdC5tZWRpYVNvdXJjZSA9IG51bGwsIHQudHJhY2tzID0gdm9pZCAwO1xuICAgICAgICBjb25zdCBsID0gZS5jdXJyZW50VGltZSwgYyA9IHRoaXMuZGV0YWlscywgdSA9IE1hdGgubWF4KGwsIChjID09IG51bGwgPyB2b2lkIDAgOiBjLmZyYWdtZW50c1swXS5zdGFydCkgfHwgMCk7XG4gICAgICAgIGlmICh1IC0gbCA+IDEpIHtcbiAgICAgICAgICB0aGlzLmxvZyhgYXR0YWNoVHJhbnNmZXJyZWQ6IHdhaXRpbmcgZm9yIHBsYXliYWNrIHRvIHJlYWNoIG5ldyB0cmFja3Mgc3RhcnQgdGltZSAke2x9IC0+ICR7dX1gKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy53YXJuKGBhdHRhY2hUcmFuc2ZlcnJlZDogcmVzZXR0aW5nIE1lZGlhU291cmNlIGZvciBpbmNvbXBhdGlibGUgdHJhY2tzIChcIiR7T2JqZWN0LmtleXMobil9XCItPlwiJHtPYmplY3Qua2V5cyhyKX1cIikgc3RhcnQgdGltZTogJHt1fSBjdXJyZW50VGltZTogJHtsfWApLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcoSS5NRURJQV9ERVRBQ0hJTkcsIHt9KSwgdGhpcy5vbk1lZGlhQXR0YWNoaW5nKEkuTUVESUFfQVRUQUNISU5HLCB0KSwgZS5jdXJyZW50VGltZSA9IHU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNmZXJEYXRhID0gdm9pZCAwLCBpLmZvckVhY2goKGwpID0+IHtcbiAgICAgICAgY29uc3QgYyA9IGwsIHUgPSBuW2NdO1xuICAgICAgICBpZiAodSkge1xuICAgICAgICAgIGNvbnN0IGQgPSB1LmJ1ZmZlcjtcbiAgICAgICAgICBpZiAoZCkge1xuICAgICAgICAgICAgY29uc3QgaCA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLCBmID0gdS5pZDtcbiAgICAgICAgICAgIGlmIChoLmhhc0ZyYWdtZW50cyhmKSB8fCBoLmhhc1BhcnRzKGYpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IEUgPSBDZS5nZXRCdWZmZXJlZChkKTtcbiAgICAgICAgICAgICAgaC5kZXRlY3RFdmljdGVkRnJhZ21lbnRzKGMsIEUsIGYsIG51bGwsICEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHAgPSBTbChjKSwgeSA9IFtjLCBkXTtcbiAgICAgICAgICAgIHRoaXMuc291cmNlQnVmZmVyc1twXSA9IHksIGQudXBkYXRpbmcgJiYgdGhpcy5vcGVyYXRpb25RdWV1ZSAmJiB0aGlzLm9wZXJhdGlvblF1ZXVlLnByZXBlbmRCbG9ja2VyKGMpLCB0aGlzLnRyYWNrU291cmNlQnVmZmVyKGMsIHUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksIGEoKSwgdGhpcy5idWZmZXJDcmVhdGVkKCk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLmxvZyhcImF0dGFjaFRyYW5zZmVycmVkOiBNZWRpYVNvdXJjZSB3L28gU291cmNlQnVmZmVyc1wiKSwgYSgpO1xuICB9XG4gIGdldCBtZWRpYVNvdXJjZU9wZW5PckVuZGVkKCkge1xuICAgIHZhciBlO1xuICAgIGNvbnN0IHQgPSAoZSA9IHRoaXMubWVkaWFTb3VyY2UpID09IG51bGwgPyB2b2lkIDAgOiBlLnJlYWR5U3RhdGU7XG4gICAgcmV0dXJuIHQgPT09IFwib3BlblwiIHx8IHQgPT09IFwiZW5kZWRcIjtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKGUsIHQpIHtcbiAgICBjb25zdCByID0gISF0LnRyYW5zZmVyTWVkaWE7XG4gICAgdGhpcy50cmFuc2ZlckRhdGEgPSB0aGlzLm92ZXJyaWRlcyA9IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYTogbixcbiAgICAgIG1lZGlhU291cmNlOiBpLFxuICAgICAgX29iamVjdFVybDogb1xuICAgIH0gPSB0aGlzO1xuICAgIGlmIChpKSB7XG4gICAgICBpZiAodGhpcy5sb2coYG1lZGlhIHNvdXJjZSAke3IgPyBcInRyYW5zZmVycmluZ1wiIDogXCJkZXRhY2hpbmdcIn1gKSwgcilcbiAgICAgICAgdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goKFthXSkgPT4ge1xuICAgICAgICAgIGEgJiYgdGhpcy5yZW1vdmVCdWZmZXIoYSk7XG4gICAgICAgIH0pLCB0aGlzLnJlc2V0UXVldWUoKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5tZWRpYVNvdXJjZU9wZW5PckVuZGVkKSB7XG4gICAgICAgICAgY29uc3QgYSA9IGkucmVhZHlTdGF0ZSA9PT0gXCJvcGVuXCI7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBpLnNvdXJjZUJ1ZmZlcnM7XG4gICAgICAgICAgICBmb3IgKGxldCBjID0gbC5sZW5ndGg7IGMtLTsgKVxuICAgICAgICAgICAgICBhICYmIGxbY10uYWJvcnQoKSwgaS5yZW1vdmVTb3VyY2VCdWZmZXIobFtjXSk7XG4gICAgICAgICAgICBhICYmIGkuZW5kT2ZTdHJlYW0oKTtcbiAgICAgICAgICB9IGNhdGNoIChsKSB7XG4gICAgICAgICAgICB0aGlzLndhcm4oYG9uTWVkaWFEZXRhY2hpbmc6ICR7bC5tZXNzYWdlfSB3aGlsZSBjYWxsaW5nIGVuZE9mU3RyZWFtYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc291cmNlQnVmZmVyQ291bnQgJiYgdGhpcy5vbkJ1ZmZlclJlc2V0KCk7XG4gICAgICB9XG4gICAgICBpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzb3VyY2VvcGVuXCIsIHRoaXMuX29uTWVkaWFTb3VyY2VPcGVuKSwgaS5yZW1vdmVFdmVudExpc3RlbmVyKFwic291cmNlZW5kZWRcIiwgdGhpcy5fb25NZWRpYVNvdXJjZUVuZGVkKSwgaS5yZW1vdmVFdmVudExpc3RlbmVyKFwic291cmNlY2xvc2VcIiwgdGhpcy5fb25NZWRpYVNvdXJjZUNsb3NlKSwgdGhpcy5hcHBlbmRTb3VyY2UgJiYgKGkucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInN0YXJ0c3RyZWFtaW5nXCIsIHRoaXMuX29uU3RhcnRTdHJlYW1pbmcpLCBpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlbmRzdHJlYW1pbmdcIiwgdGhpcy5fb25FbmRTdHJlYW1pbmcpKSwgdGhpcy5tZWRpYVNvdXJjZSA9IG51bGwsIHRoaXMuX29iamVjdFVybCA9IG51bGw7XG4gICAgfVxuICAgIG4gJiYgKG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVtcHRpZWRcIiwgdGhpcy5fb25NZWRpYUVtcHRpZWQpLCByIHx8IChvICYmIHNlbGYuVVJMLnJldm9rZU9iamVjdFVSTChvKSwgdGhpcy5tZWRpYVNyYyA9PT0gbyA/IChuLnJlbW92ZUF0dHJpYnV0ZShcInNyY1wiKSwgdGhpcy5hcHBlbmRTb3VyY2UgJiYgSGgobiksIG4ubG9hZCgpKSA6IHRoaXMud2FybihcIm1lZGlhfHNvdXJjZS5zcmMgd2FzIGNoYW5nZWQgYnkgYSB0aGlyZCBwYXJ0eSAtIHNraXAgY2xlYW51cFwiKSksIHRoaXMubWVkaWEgPSBudWxsKSwgdGhpcy5obHMudHJpZ2dlcihJLk1FRElBX0RFVEFDSEVELCB0KTtcbiAgfVxuICBvbkJ1ZmZlclJlc2V0KCkge1xuICAgIHRoaXMuc291cmNlQnVmZmVycy5mb3JFYWNoKChbZV0pID0+IHtcbiAgICAgIGUgJiYgdGhpcy5yZXNldEJ1ZmZlcihlKTtcbiAgICB9KSwgdGhpcy5pbml0VHJhY2tzKCk7XG4gIH1cbiAgcmVzZXRCdWZmZXIoZSkge1xuICAgIHZhciB0O1xuICAgIGNvbnN0IHIgPSAodCA9IHRoaXMudHJhY2tzW2VdKSA9PSBudWxsID8gdm9pZCAwIDogdC5idWZmZXI7XG4gICAgaWYgKHRoaXMucmVtb3ZlQnVmZmVyKGUpLCByKVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIG47XG4gICAgICAgIChuID0gdGhpcy5tZWRpYVNvdXJjZSkgIT0gbnVsbCAmJiBuLnNvdXJjZUJ1ZmZlcnMubGVuZ3RoICYmIHRoaXMubWVkaWFTb3VyY2UucmVtb3ZlU291cmNlQnVmZmVyKHIpO1xuICAgICAgfSBjYXRjaCAoaSkge1xuICAgICAgICB0aGlzLndhcm4oYG9uQnVmZmVyUmVzZXQgJHtlfWAsIGkpO1xuICAgICAgfVxuICAgIGRlbGV0ZSB0aGlzLnRyYWNrc1tlXTtcbiAgfVxuICByZW1vdmVCdWZmZXIoZSkge1xuICAgIHRoaXMucmVtb3ZlQnVmZmVyTGlzdGVuZXJzKGUpLCB0aGlzLnNvdXJjZUJ1ZmZlcnNbU2woZSldID0gW251bGwsIG51bGxdO1xuICAgIGNvbnN0IHQgPSB0aGlzLnRyYWNrc1tlXTtcbiAgICB0ICYmICh0LmJ1ZmZlciA9IHZvaWQgMCk7XG4gIH1cbiAgcmVzZXRRdWV1ZSgpIHtcbiAgICB0aGlzLm9wZXJhdGlvblF1ZXVlICYmIHRoaXMub3BlcmF0aW9uUXVldWUuZGVzdHJveSgpLCB0aGlzLm9wZXJhdGlvblF1ZXVlID0gbmV3IG8yKHRoaXMudHJhY2tzKTtcbiAgfVxuICBvbkJ1ZmZlckNvZGVjcyhlLCB0KSB7XG4gICAgdmFyIHI7XG4gICAgY29uc3QgbiA9IHRoaXMudHJhY2tzLCBpID0gT2JqZWN0LmtleXModCk7XG4gICAgdGhpcy5sb2coYEJVRkZFUl9DT0RFQ1M6IFwiJHtpfVwiIChjdXJyZW50IFNCIGNvdW50ICR7dGhpcy5zb3VyY2VCdWZmZXJDb3VudH0pYCk7XG4gICAgY29uc3QgbyA9IFwiYXVkaW92aWRlb1wiIGluIHQgJiYgKG4uYXVkaW8gfHwgbi52aWRlbykgfHwgbi5hdWRpb3ZpZGVvICYmIChcImF1ZGlvXCIgaW4gdCB8fCBcInZpZGVvXCIgaW4gdCksIGEgPSAhbyAmJiB0aGlzLnNvdXJjZUJ1ZmZlckNvdW50ICYmIHRoaXMubWVkaWEgJiYgaS5zb21lKChsKSA9PiAhbltsXSk7XG4gICAgaWYgKG8gfHwgYSkge1xuICAgICAgdGhpcy53YXJuKGBVbnN1cHBvcnRlZCB0cmFuc2l0aW9uIGJldHdlZW4gXCIke09iamVjdC5rZXlzKG4pfVwiIGFuZCBcIiR7aX1cIiBTb3VyY2VCdWZmZXJzYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGkuZm9yRWFjaCgobCkgPT4ge1xuICAgICAgdmFyIGMsIHU7XG4gICAgICBjb25zdCBkID0gdFtsXSwge1xuICAgICAgICBpZDogaCxcbiAgICAgICAgY29kZWM6IGYsXG4gICAgICAgIGxldmVsQ29kZWM6IHAsXG4gICAgICAgIGNvbnRhaW5lcjogeSxcbiAgICAgICAgbWV0YWRhdGE6IEUsXG4gICAgICAgIHN1cHBsZW1lbnRhbDogYlxuICAgICAgfSA9IGQ7XG4gICAgICBsZXQgUiA9IG5bbF07XG4gICAgICBjb25zdCBBID0gKGMgPSB0aGlzLnRyYW5zZmVyRGF0YSkgPT0gbnVsbCB8fCAoYyA9IGMudHJhY2tzKSA9PSBudWxsID8gdm9pZCAwIDogY1tsXSwgRiA9IEEgIT0gbnVsbCAmJiBBLmJ1ZmZlciA/IEEgOiBSLCBNID0gKEYgPT0gbnVsbCA/IHZvaWQgMCA6IEYucGVuZGluZ0NvZGVjKSB8fCAoRiA9PSBudWxsID8gdm9pZCAwIDogRi5jb2RlYyksIEggPSBGID09IG51bGwgPyB2b2lkIDAgOiBGLmxldmVsQ29kZWM7XG4gICAgICBSIHx8IChSID0gbltsXSA9IHtcbiAgICAgICAgYnVmZmVyOiB2b2lkIDAsXG4gICAgICAgIGxpc3RlbmVyczogW10sXG4gICAgICAgIGNvZGVjOiBmLFxuICAgICAgICBzdXBwbGVtZW50YWw6IGIsXG4gICAgICAgIGNvbnRhaW5lcjogeSxcbiAgICAgICAgbGV2ZWxDb2RlYzogcCxcbiAgICAgICAgbWV0YWRhdGE6IEUsXG4gICAgICAgIGlkOiBoXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IEsgPSBmbyhNLCBIKSwgaiA9IEsgPT0gbnVsbCA/IHZvaWQgMCA6IEsucmVwbGFjZShLaCwgXCIkMVwiKTtcbiAgICAgIGxldCBDID0gZm8oZiwgcCk7XG4gICAgICBjb25zdCBrID0gKHUgPSBDKSA9PSBudWxsID8gdm9pZCAwIDogdS5yZXBsYWNlKEtoLCBcIiQxXCIpO1xuICAgICAgQyAmJiBLICYmIGogIT09IGsgJiYgKGwuc2xpY2UoMCwgNSkgPT09IFwiYXVkaW9cIiAmJiAoQyA9IFhvKEMsIHRoaXMuYXBwZW5kU291cmNlKSksIHRoaXMubG9nKGBzd2l0Y2hpbmcgY29kZWMgJHtNfSB0byAke0N9YCksIEMgIT09IChSLnBlbmRpbmdDb2RlYyB8fCBSLmNvZGVjKSAmJiAoUi5wZW5kaW5nQ29kZWMgPSBDKSwgUi5jb250YWluZXIgPSB5LCB0aGlzLmFwcGVuZENoYW5nZVR5cGUobCwgeSwgQykpO1xuICAgIH0pLCAodGhpcy50cmFja3NSZWFkeSB8fCB0aGlzLnNvdXJjZUJ1ZmZlckNvdW50KSAmJiAodC50cmFja3MgPSB0aGlzLnNvdXJjZUJ1ZmZlclRyYWNrcyksICF0aGlzLnNvdXJjZUJ1ZmZlckNvdW50ICYmICh0aGlzLmJ1ZmZlckNvZGVjRXZlbnRzVG90YWwgPiAxICYmICF0aGlzLnRyYWNrcy52aWRlbyAmJiAhdC52aWRlbyAmJiAoKHIgPSB0LmF1ZGlvKSA9PSBudWxsID8gdm9pZCAwIDogci5pZCkgPT09IFwibWFpblwiICYmICh0aGlzLmxvZyhcIk1haW4gYXVkaW8tb25seVwiKSwgdGhpcy5idWZmZXJDb2RlY0V2ZW50c1RvdGFsID0gMSksIHRoaXMubWVkaWFTb3VyY2VPcGVuT3JFbmRlZCAmJiB0aGlzLmNoZWNrUGVuZGluZ1RyYWNrcygpKTtcbiAgfVxuICBnZXQgc291cmNlQnVmZmVyVHJhY2tzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnRyYWNrcykucmVkdWNlKChlLCB0KSA9PiB7XG4gICAgICBjb25zdCByID0gdGhpcy50cmFja3NbdF07XG4gICAgICByZXR1cm4gZVt0XSA9IHtcbiAgICAgICAgaWQ6IHIuaWQsXG4gICAgICAgIGNvbnRhaW5lcjogci5jb250YWluZXIsXG4gICAgICAgIGNvZGVjOiByLmNvZGVjLFxuICAgICAgICBsZXZlbENvZGVjOiByLmxldmVsQ29kZWNcbiAgICAgIH0sIGU7XG4gICAgfSwge30pO1xuICB9XG4gIGFwcGVuZENoYW5nZVR5cGUoZSwgdCwgcikge1xuICAgIGNvbnN0IG4gPSBgJHt0fTtjb2RlY3M9JHtyfWAsIGkgPSB7XG4gICAgICBsYWJlbDogYGNoYW5nZS10eXBlPSR7bn1gLFxuICAgICAgZXhlY3V0ZTogKCkgPT4ge1xuICAgICAgICBjb25zdCBvID0gdGhpcy50cmFja3NbZV07XG4gICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgY29uc3QgYSA9IG8uYnVmZmVyO1xuICAgICAgICAgIGEgIT0gbnVsbCAmJiBhLmNoYW5nZVR5cGUgJiYgKHRoaXMubG9nKGBjaGFuZ2luZyAke2V9IHNvdXJjZUJ1ZmZlciB0eXBlIHRvICR7bn1gKSwgYS5jaGFuZ2VUeXBlKG4pLCBvLmNvZGVjID0gciwgby5jb250YWluZXIgPSB0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNoaWZ0QW5kRXhlY3V0ZU5leHQoZSk7XG4gICAgICB9LFxuICAgICAgb25TdGFydDogKCkgPT4ge1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiAobykgPT4ge1xuICAgICAgICB0aGlzLndhcm4oYEZhaWxlZCB0byBjaGFuZ2UgJHtlfSBTb3VyY2VCdWZmZXIgdHlwZWAsIG8pO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5hcHBlbmQoaSwgZSwgdGhpcy5pc1BlbmRpbmcodGhpcy50cmFja3NbZV0pKTtcbiAgfVxuICBibG9ja0F1ZGlvKGUpIHtcbiAgICB2YXIgdDtcbiAgICBjb25zdCByID0gZS5zdGFydCwgbiA9IHIgKyBlLmR1cmF0aW9uICogMC4wNTtcbiAgICBpZiAoKCh0ID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKHIsIHBlLk1BSU4pKSA9PSBudWxsID8gdm9pZCAwIDogdC5nYXApID09PSAhMClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvID0ge1xuICAgICAgbGFiZWw6IFwiYmxvY2stYXVkaW9cIixcbiAgICAgIGV4ZWN1dGU6ICgpID0+IHtcbiAgICAgICAgdmFyIGE7XG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLnRyYWNrcy52aWRlbztcbiAgICAgICAgKHRoaXMubGFzdFZpZGVvQXBwZW5kRW5kID4gbiB8fCBsICE9IG51bGwgJiYgbC5idWZmZXIgJiYgQ2UuaXNCdWZmZXJlZChsLmJ1ZmZlciwgbikgfHwgKChhID0gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QXBwZW5kZWRGcmFnKG4sIHBlLk1BSU4pKSA9PSBudWxsID8gdm9pZCAwIDogYS5nYXApID09PSAhMCkgJiYgKHRoaXMuYmxvY2tlZEF1ZGlvQXBwZW5kID0gbnVsbCwgdGhpcy5zaGlmdEFuZEV4ZWN1dGVOZXh0KFwiYXVkaW9cIikpO1xuICAgICAgfSxcbiAgICAgIG9uU3RhcnQ6ICgpID0+IHtcbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogKGEpID0+IHtcbiAgICAgICAgdGhpcy53YXJuKFwiRXJyb3IgZXhlY3V0aW5nIGJsb2NrLWF1ZGlvIG9wZXJhdGlvblwiLCBhKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYmxvY2tlZEF1ZGlvQXBwZW5kID0ge1xuICAgICAgb3A6IG8sXG4gICAgICBmcmFnOiBlXG4gICAgfSwgdGhpcy5hcHBlbmQobywgXCJhdWRpb1wiLCAhMCk7XG4gIH1cbiAgdW5ibG9ja0F1ZGlvKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJsb2NrZWRBdWRpb0FwcGVuZDogZSxcbiAgICAgIG9wZXJhdGlvblF1ZXVlOiB0XG4gICAgfSA9IHRoaXM7XG4gICAgZSAmJiB0ICYmICh0aGlzLmJsb2NrZWRBdWRpb0FwcGVuZCA9IG51bGwsIHQudW5ibG9ja0F1ZGlvKGUub3ApKTtcbiAgfVxuICBvbkJ1ZmZlckFwcGVuZGluZyhlLCB0KSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhY2tzOiByXG4gICAgfSA9IHRoaXMsIHtcbiAgICAgIGRhdGE6IG4sXG4gICAgICB0eXBlOiBpLFxuICAgICAgcGFyZW50OiBvLFxuICAgICAgZnJhZzogYSxcbiAgICAgIHBhcnQ6IGwsXG4gICAgICBjaHVua01ldGE6IGMsXG4gICAgICBvZmZzZXQ6IHVcbiAgICB9ID0gdCwgZCA9IGMuYnVmZmVyaW5nW2ldLCB7XG4gICAgICBzbjogaCxcbiAgICAgIGNjOiBmXG4gICAgfSA9IGEsIHAgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGQuc3RhcnQgPSBwO1xuICAgIGNvbnN0IHkgPSBhLnN0YXRzLmJ1ZmZlcmluZywgRSA9IGwgPyBsLnN0YXRzLmJ1ZmZlcmluZyA6IG51bGw7XG4gICAgeS5zdGFydCA9PT0gMCAmJiAoeS5zdGFydCA9IHApLCBFICYmIEUuc3RhcnQgPT09IDAgJiYgKEUuc3RhcnQgPSBwKTtcbiAgICBjb25zdCBiID0gci5hdWRpbztcbiAgICBsZXQgUiA9ICExO1xuICAgIGkgPT09IFwiYXVkaW9cIiAmJiAoYiA9PSBudWxsID8gdm9pZCAwIDogYi5jb250YWluZXIpID09PSBcImF1ZGlvL21wZWdcIiAmJiAoUiA9ICF0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayB8fCBjLmlkID09PSAxIHx8IHRoaXMubGFzdE1wZWdBdWRpb0NodW5rLnNuICE9PSBjLnNuLCB0aGlzLmxhc3RNcGVnQXVkaW9DaHVuayA9IGMpO1xuICAgIGNvbnN0IEEgPSByLnZpZGVvLCBGID0gQSA9PSBudWxsID8gdm9pZCAwIDogQS5idWZmZXI7XG4gICAgaWYgKEYgJiYgaCAhPT0gXCJpbml0U2VnbWVudFwiKSB7XG4gICAgICBjb25zdCBLID0gbCB8fCBhLCBqID0gdGhpcy5ibG9ja2VkQXVkaW9BcHBlbmQ7XG4gICAgICBpZiAoaSA9PT0gXCJhdWRpb1wiICYmIG8gIT09IFwibWFpblwiICYmICF0aGlzLmJsb2NrZWRBdWRpb0FwcGVuZCAmJiAhKEEuZW5kaW5nIHx8IEEuZW5kZWQpKSB7XG4gICAgICAgIGNvbnN0IGsgPSBLLnN0YXJ0ICsgSy5kdXJhdGlvbiAqIDAuMDUsICQgPSBGLmJ1ZmZlcmVkLCBXID0gdGhpcy5jdXJyZW50T3AoXCJ2aWRlb1wiKTtcbiAgICAgICAgISQubGVuZ3RoICYmICFXID8gdGhpcy5ibG9ja0F1ZGlvKEspIDogIVcgJiYgIUNlLmlzQnVmZmVyZWQoRiwgaykgJiYgdGhpcy5sYXN0VmlkZW9BcHBlbmRFbmQgPCBrICYmIHRoaXMuYmxvY2tBdWRpbyhLKTtcbiAgICAgIH0gZWxzZSBpZiAoaSA9PT0gXCJ2aWRlb1wiKSB7XG4gICAgICAgIGNvbnN0IEMgPSBLLmVuZDtcbiAgICAgICAgaWYgKGopIHtcbiAgICAgICAgICBjb25zdCBrID0gai5mcmFnLnN0YXJ0O1xuICAgICAgICAgIChDID4gayB8fCBDIDwgdGhpcy5sYXN0VmlkZW9BcHBlbmRFbmQgfHwgQ2UuaXNCdWZmZXJlZChGLCBrKSkgJiYgdGhpcy51bmJsb2NrQXVkaW8oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhc3RWaWRlb0FwcGVuZEVuZCA9IEM7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IE0gPSAobCB8fCBhKS5zdGFydCwgSCA9IHtcbiAgICAgIGxhYmVsOiBgYXBwZW5kLSR7aX1gLFxuICAgICAgZXhlY3V0ZTogKCkgPT4ge1xuICAgICAgICB2YXIgSztcbiAgICAgICAgZC5leGVjdXRlU3RhcnQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBjb25zdCBqID0gKEsgPSB0aGlzLnRyYWNrc1tpXSkgPT0gbnVsbCA/IHZvaWQgMCA6IEsuYnVmZmVyO1xuICAgICAgICBqICYmIChSID8gdGhpcy51cGRhdGVUaW1lc3RhbXBPZmZzZXQoaiwgTSwgMC4xLCBpLCBoLCBmKSA6IHUgIT09IHZvaWQgMCAmJiB1ZSh1KSAmJiB0aGlzLnVwZGF0ZVRpbWVzdGFtcE9mZnNldChqLCB1LCAxZS02LCBpLCBoLCBmKSksIHRoaXMuYXBwZW5kRXhlY3V0b3IobiwgaSk7XG4gICAgICB9LFxuICAgICAgb25TdGFydDogKCkgPT4ge1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgY29uc3QgSyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIGQuZXhlY3V0ZUVuZCA9IGQuZW5kID0gSywgeS5maXJzdCA9PT0gMCAmJiAoeS5maXJzdCA9IEspLCBFICYmIEUuZmlyc3QgPT09IDAgJiYgKEUuZmlyc3QgPSBLKTtcbiAgICAgICAgY29uc3QgaiA9IHt9O1xuICAgICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaCgoW0MsIGtdKSA9PiB7XG4gICAgICAgICAgQyAmJiAoaltDXSA9IENlLmdldEJ1ZmZlcmVkKGspKTtcbiAgICAgICAgfSksIHRoaXMuYXBwZW5kRXJyb3JzW2ldID0gMCwgaSA9PT0gXCJhdWRpb1wiIHx8IGkgPT09IFwidmlkZW9cIiA/IHRoaXMuYXBwZW5kRXJyb3JzLmF1ZGlvdmlkZW8gPSAwIDogKHRoaXMuYXBwZW5kRXJyb3JzLmF1ZGlvID0gMCwgdGhpcy5hcHBlbmRFcnJvcnMudmlkZW8gPSAwKSwgdGhpcy5obHMudHJpZ2dlcihJLkJVRkZFUl9BUFBFTkRFRCwge1xuICAgICAgICAgIHR5cGU6IGksXG4gICAgICAgICAgZnJhZzogYSxcbiAgICAgICAgICBwYXJ0OiBsLFxuICAgICAgICAgIGNodW5rTWV0YTogYyxcbiAgICAgICAgICBwYXJlbnQ6IGEudHlwZSxcbiAgICAgICAgICB0aW1lUmFuZ2VzOiBqXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3I6IChLKSA9PiB7XG4gICAgICAgIHZhciBqO1xuICAgICAgICBjb25zdCBDID0ge1xuICAgICAgICAgIHR5cGU6IHZlLk1FRElBX0VSUk9SLFxuICAgICAgICAgIHBhcmVudDogYS50eXBlLFxuICAgICAgICAgIGRldGFpbHM6IEouQlVGRkVSX0FQUEVORF9FUlJPUixcbiAgICAgICAgICBzb3VyY2VCdWZmZXJOYW1lOiBpLFxuICAgICAgICAgIGZyYWc6IGEsXG4gICAgICAgICAgcGFydDogbCxcbiAgICAgICAgICBjaHVua01ldGE6IGMsXG4gICAgICAgICAgZXJyb3I6IEssXG4gICAgICAgICAgZXJyOiBLLFxuICAgICAgICAgIGZhdGFsOiAhMVxuICAgICAgICB9LCBrID0gKGogPSB0aGlzLm1lZGlhKSA9PSBudWxsID8gdm9pZCAwIDogai5lcnJvcjtcbiAgICAgICAgaWYgKEsuY29kZSA9PT0gRE9NRXhjZXB0aW9uLlFVT1RBX0VYQ0VFREVEX0VSUiB8fCBLLm5hbWUgPT0gXCJRdW90YUV4Y2VlZGVkRXJyb3JcIiB8fCBcInF1b3RhXCIgaW4gSylcbiAgICAgICAgICBDLmRldGFpbHMgPSBKLkJVRkZFUl9GVUxMX0VSUk9SO1xuICAgICAgICBlbHNlIGlmIChLLmNvZGUgPT09IERPTUV4Y2VwdGlvbi5JTlZBTElEX1NUQVRFX0VSUiAmJiB0aGlzLm1lZGlhU291cmNlT3Blbk9yRW5kZWQgJiYgIWspXG4gICAgICAgICAgQy5lcnJvckFjdGlvbiA9IEFuKCEwKTtcbiAgICAgICAgZWxzZSBpZiAoSy5uYW1lID09PSBJcCAmJiB0aGlzLnNvdXJjZUJ1ZmZlckNvdW50ID09PSAwKVxuICAgICAgICAgIEMuZXJyb3JBY3Rpb24gPSBBbighMCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnN0ICQgPSArK3RoaXMuYXBwZW5kRXJyb3JzW2ldO1xuICAgICAgICAgIHRoaXMud2FybihgRmFpbGVkICR7JH0vJHt0aGlzLmhscy5jb25maWcuYXBwZW5kRXJyb3JNYXhSZXRyeX0gdGltZXMgdG8gYXBwZW5kIHNlZ21lbnQgaW4gXCIke2l9XCIgc291cmNlQnVmZmVyICgke2sgfHwgXCJubyBtZWRpYSBlcnJvclwifSlgKSwgKCQgPj0gdGhpcy5obHMuY29uZmlnLmFwcGVuZEVycm9yTWF4UmV0cnkgfHwgaykgJiYgKEMuZmF0YWwgPSAhMCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihJLkVSUk9SLCBDKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMubG9nKGBxdWV1aW5nIFwiJHtpfVwiIGFwcGVuZCBzbjogJHtofSR7bCA/IFwiIHA6IFwiICsgbC5pbmRleCA6IFwiXCJ9IG9mICR7YS50eXBlID09PSBwZS5NQUlOID8gXCJsZXZlbFwiIDogXCJ0cmFja1wifSAke2EubGV2ZWx9IGNjOiAke2Z9YCksIHRoaXMuYXBwZW5kKEgsIGksIHRoaXMuaXNQZW5kaW5nKHRoaXMudHJhY2tzW2ldKSk7XG4gIH1cbiAgZ2V0Rmx1c2hPcChlLCB0LCByKSB7XG4gICAgcmV0dXJuIHRoaXMubG9nKGBxdWV1aW5nIFwiJHtlfVwiIHJlbW92ZSAke3R9LSR7cn1gKSwge1xuICAgICAgbGFiZWw6IFwicmVtb3ZlXCIsXG4gICAgICBleGVjdXRlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXhlY3V0b3IoZSwgdCwgcik7XG4gICAgICB9LFxuICAgICAgb25TdGFydDogKCkgPT4ge1xuICAgICAgfSxcbiAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihJLkJVRkZFUl9GTFVTSEVELCB7XG4gICAgICAgICAgdHlwZTogZVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiAobikgPT4ge1xuICAgICAgICB0aGlzLndhcm4oYEZhaWxlZCB0byByZW1vdmUgJHt0fS0ke3J9IGZyb20gXCIke2V9XCIgU291cmNlQnVmZmVyYCwgbik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBvbkJ1ZmZlckZsdXNoaW5nKGUsIHQpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlOiByLFxuICAgICAgc3RhcnRPZmZzZXQ6IG4sXG4gICAgICBlbmRPZmZzZXQ6IGlcbiAgICB9ID0gdDtcbiAgICByID8gdGhpcy5hcHBlbmQodGhpcy5nZXRGbHVzaE9wKHIsIG4sIGkpLCByKSA6IHRoaXMuc291cmNlQnVmZmVycy5mb3JFYWNoKChbb10pID0+IHtcbiAgICAgIG8gJiYgdGhpcy5hcHBlbmQodGhpcy5nZXRGbHVzaE9wKG8sIG4sIGkpLCBvKTtcbiAgICB9KTtcbiAgfVxuICBvbkZyYWdQYXJzZWQoZSwgdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWc6IHIsXG4gICAgICBwYXJ0OiBuXG4gICAgfSA9IHQsIGkgPSBbXSwgbyA9IG4gPyBuLmVsZW1lbnRhcnlTdHJlYW1zIDogci5lbGVtZW50YXJ5U3RyZWFtcztcbiAgICBvW290LkFVRElPVklERU9dID8gaS5wdXNoKFwiYXVkaW92aWRlb1wiKSA6IChvW290LkFVRElPXSAmJiBpLnB1c2goXCJhdWRpb1wiKSwgb1tvdC5WSURFT10gJiYgaS5wdXNoKFwidmlkZW9cIikpO1xuICAgIGNvbnN0IGEgPSAoKSA9PiB7XG4gICAgICBjb25zdCBsID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHIuc3RhdHMuYnVmZmVyaW5nLmVuZCA9IGwsIG4gJiYgKG4uc3RhdHMuYnVmZmVyaW5nLmVuZCA9IGwpO1xuICAgICAgY29uc3QgYyA9IG4gPyBuLnN0YXRzIDogci5zdGF0cztcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoSS5GUkFHX0JVRkZFUkVELCB7XG4gICAgICAgIGZyYWc6IHIsXG4gICAgICAgIHBhcnQ6IG4sXG4gICAgICAgIHN0YXRzOiBjLFxuICAgICAgICBpZDogci50eXBlXG4gICAgICB9KTtcbiAgICB9O1xuICAgIGkubGVuZ3RoID09PSAwICYmIHRoaXMud2FybihgRnJhZ21lbnRzIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgRWxlbWVudGFyeVN0cmVhbVR5cGUgc2V0LiB0eXBlOiAke3IudHlwZX0gbGV2ZWw6ICR7ci5sZXZlbH0gc246ICR7ci5zbn1gKSwgdGhpcy5ibG9ja0J1ZmZlcnMoYSwgaSkuY2F0Y2goKGwpID0+IHtcbiAgICAgIHRoaXMud2FybihgRnJhZ21lbnQgYnVmZmVyZWQgY2FsbGJhY2sgJHtsfWApLCB0aGlzLnN0ZXBPcGVyYXRpb25RdWV1ZSh0aGlzLnNvdXJjZUJ1ZmZlclR5cGVzKTtcbiAgICB9KTtcbiAgfVxuICBvbkZyYWdDaGFuZ2VkKGUsIHQpIHtcbiAgICB0aGlzLnRyaW1CdWZmZXJzKCk7XG4gIH1cbiAgZ2V0IGJ1ZmZlcmVkVG9FbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlQnVmZmVyQ291bnQgPiAwICYmICF0aGlzLnNvdXJjZUJ1ZmZlcnMuc29tZSgoW2VdKSA9PiB7XG4gICAgICBpZiAoZSkge1xuICAgICAgICBjb25zdCB0ID0gdGhpcy50cmFja3NbZV07XG4gICAgICAgIGlmICh0KVxuICAgICAgICAgIHJldHVybiAhdC5lbmRlZCB8fCB0LmVuZGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiAhMTtcbiAgICB9KTtcbiAgfVxuICAvLyBvbiBCVUZGRVJfRU9TIG1hcmsgbWF0Y2hpbmcgc291cmNlYnVmZmVyKHMpIGFzIFwiZW5kaW5nXCIgYW5kIFwiZW5kZWRcIiBhbmQgcXVldWUgZW5kT2ZTdHJlYW0gYWZ0ZXIgcmVtYWluaW5nIG9wZXJhdGlvbnMocylcbiAgLy8gYW4gdW5kZWZpbmVkIGRhdGEudHlwZSB3aWxsIG1hcmsgYWxsIGJ1ZmZlcnMgYXMgRU9TLlxuICBvbkJ1ZmZlckVvcyhlLCB0KSB7XG4gICAgdmFyIHI7XG4gICAgdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goKFtvXSkgPT4ge1xuICAgICAgaWYgKG8pIHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMudHJhY2tzW29dO1xuICAgICAgICAoIXQudHlwZSB8fCB0LnR5cGUgPT09IG8pICYmIChhLmVuZGluZyA9ICEwLCBhLmVuZGVkIHx8IChhLmVuZGVkID0gITAsIHRoaXMubG9nKGAke299IGJ1ZmZlciByZWFjaGVkIEVPU2ApKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgbiA9ICgociA9IHRoaXMub3ZlcnJpZGVzKSA9PSBudWxsID8gdm9pZCAwIDogci5lbmRPZlN0cmVhbSkgIT09ICExO1xuICAgIHRoaXMuc291cmNlQnVmZmVyQ291bnQgPiAwICYmICF0aGlzLnNvdXJjZUJ1ZmZlcnMuc29tZSgoW29dKSA9PiB7XG4gICAgICB2YXIgYTtcbiAgICAgIHJldHVybiBvICYmICEoKGEgPSB0aGlzLnRyYWNrc1tvXSkgIT0gbnVsbCAmJiBhLmVuZGVkKTtcbiAgICB9KSA/IG4gPyAodGhpcy5sb2coXCJRdWV1ZWluZyBFT1NcIiksIHRoaXMuYmxvY2tVbnRpbE9wZW4oKCkgPT4ge1xuICAgICAgdGhpcy50cmFja3NFbmRlZCgpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBtZWRpYVNvdXJjZTogb1xuICAgICAgfSA9IHRoaXM7XG4gICAgICBpZiAoIW8gfHwgby5yZWFkeVN0YXRlICE9PSBcIm9wZW5cIikge1xuICAgICAgICBvICYmIHRoaXMubG9nKGBDb3VsZCBub3QgY2FsbCBtZWRpYVNvdXJjZS5lbmRPZlN0cmVhbSgpLiBtZWRpYVNvdXJjZS5yZWFkeVN0YXRlOiAke28ucmVhZHlTdGF0ZX1gKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2coXCJDYWxsaW5nIG1lZGlhU291cmNlLmVuZE9mU3RyZWFtKClcIiksIG8uZW5kT2ZTdHJlYW0oKSwgdGhpcy5obHMudHJpZ2dlcihJLkJVRkZFUkVEX1RPX0VORCwgdm9pZCAwKTtcbiAgICB9KSkgOiAodGhpcy50cmFja3NFbmRlZCgpLCB0aGlzLmhscy50cmlnZ2VyKEkuQlVGRkVSRURfVE9fRU5ELCB2b2lkIDApKSA6IHQudHlwZSA9PT0gXCJ2aWRlb1wiICYmIHRoaXMudW5ibG9ja0F1ZGlvKCk7XG4gIH1cbiAgdHJhY2tzRW5kZWQoKSB7XG4gICAgdGhpcy5zb3VyY2VCdWZmZXJzLmZvckVhY2goKFtlXSkgPT4ge1xuICAgICAgaWYgKGUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgdCA9IHRoaXMudHJhY2tzW2VdO1xuICAgICAgICB0ICYmICh0LmVuZGluZyA9ICExKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBvbkxldmVsVXBkYXRlZChlLCB7XG4gICAgZGV0YWlsczogdFxuICB9KSB7XG4gICAgdC5mcmFnbWVudHMubGVuZ3RoICYmICh0aGlzLmRldGFpbHMgPSB0LCB0aGlzLnVwZGF0ZUR1cmF0aW9uKCkpO1xuICB9XG4gIHVwZGF0ZUR1cmF0aW9uKCkge1xuICAgIHRoaXMuYmxvY2tVbnRpbE9wZW4oKCkgPT4ge1xuICAgICAgY29uc3QgZSA9IHRoaXMuZ2V0RHVyYXRpb25BbmRSYW5nZSgpO1xuICAgICAgZSAmJiB0aGlzLnVwZGF0ZU1lZGlhU291cmNlKGUpO1xuICAgIH0pO1xuICB9XG4gIG9uRXJyb3IoZSwgdCkge1xuICAgIGlmICh0LmRldGFpbHMgPT09IEouQlVGRkVSX0FQUEVORF9FUlJPUiAmJiB0LmZyYWcpIHtcbiAgICAgIHZhciByO1xuICAgICAgY29uc3QgbiA9IChyID0gdC5lcnJvckFjdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IHIubmV4dEF1dG9MZXZlbDtcbiAgICAgIHVlKG4pICYmIG4gIT09IHQuZnJhZy5sZXZlbCAmJiB0aGlzLnJlc2V0QXBwZW5kRXJyb3JzKCk7XG4gICAgfVxuICB9XG4gIHJlc2V0QXBwZW5kRXJyb3JzKCkge1xuICAgIHRoaXMuYXBwZW5kRXJyb3JzID0ge1xuICAgICAgYXVkaW86IDAsXG4gICAgICB2aWRlbzogMCxcbiAgICAgIGF1ZGlvdmlkZW86IDBcbiAgICB9O1xuICB9XG4gIHRyaW1CdWZmZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsczogZSxcbiAgICAgIGRldGFpbHM6IHQsXG4gICAgICBtZWRpYTogclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghciB8fCB0ID09PSBudWxsIHx8ICF0aGlzLnNvdXJjZUJ1ZmZlckNvdW50KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG4gPSBlLmNvbmZpZywgaSA9IHIuY3VycmVudFRpbWUsIG8gPSB0LmxldmVsVGFyZ2V0RHVyYXRpb24sIGEgPSB0LmxpdmUgJiYgbi5saXZlQmFja0J1ZmZlckxlbmd0aCAhPT0gbnVsbCA/IG4ubGl2ZUJhY2tCdWZmZXJMZW5ndGggOiBuLmJhY2tCdWZmZXJMZW5ndGg7XG4gICAgaWYgKHVlKGEpICYmIGEgPj0gMCkge1xuICAgICAgY29uc3QgYyA9IE1hdGgubWF4KGEsIG8pLCB1ID0gTWF0aC5mbG9vcihpIC8gbykgKiBvIC0gYztcbiAgICAgIHRoaXMuZmx1c2hCYWNrQnVmZmVyKGksIG8sIHUpO1xuICAgIH1cbiAgICBjb25zdCBsID0gbi5mcm9udEJ1ZmZlckZsdXNoVGhyZXNob2xkO1xuICAgIGlmICh1ZShsKSAmJiBsID4gMCkge1xuICAgICAgY29uc3QgYyA9IE1hdGgubWF4KG4ubWF4QnVmZmVyTGVuZ3RoLCBsKSwgdSA9IE1hdGgubWF4KGMsIG8pLCBkID0gTWF0aC5mbG9vcihpIC8gbykgKiBvICsgdTtcbiAgICAgIHRoaXMuZmx1c2hGcm9udEJ1ZmZlcihpLCBvLCBkKTtcbiAgICB9XG4gIH1cbiAgZmx1c2hCYWNrQnVmZmVyKGUsIHQsIHIpIHtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaCgoW24sIGldKSA9PiB7XG4gICAgICBpZiAoaSkge1xuICAgICAgICBjb25zdCBhID0gQ2UuZ2V0QnVmZmVyZWQoaSk7XG4gICAgICAgIGlmIChhLmxlbmd0aCA+IDAgJiYgciA+IGEuc3RhcnQoMCkpIHtcbiAgICAgICAgICB2YXIgbztcbiAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEkuQkFDS19CVUZGRVJfUkVBQ0hFRCwge1xuICAgICAgICAgICAgYnVmZmVyRW5kOiByXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgbCA9IHRoaXMudHJhY2tzW25dO1xuICAgICAgICAgIGlmICgobyA9IHRoaXMuZGV0YWlscykgIT0gbnVsbCAmJiBvLmxpdmUpXG4gICAgICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEkuTElWRV9CQUNLX0JVRkZFUl9SRUFDSEVELCB7XG4gICAgICAgICAgICAgIGJ1ZmZlckVuZDogclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgZWxzZSBpZiAobCAhPSBudWxsICYmIGwuZW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKGBDYW5ub3QgZmx1c2ggJHtufSBiYWNrIGJ1ZmZlciB3aGlsZSBTb3VyY2VCdWZmZXIgaXMgaW4gZW5kZWQgc3RhdGVgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihJLkJVRkZFUl9GTFVTSElORywge1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IDAsXG4gICAgICAgICAgICBlbmRPZmZzZXQ6IHIsXG4gICAgICAgICAgICB0eXBlOiBuXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmbHVzaEZyb250QnVmZmVyKGUsIHQsIHIpIHtcbiAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaCgoW24sIGldKSA9PiB7XG4gICAgICBpZiAoaSkge1xuICAgICAgICBjb25zdCBvID0gQ2UuZ2V0QnVmZmVyZWQoaSksIGEgPSBvLmxlbmd0aDtcbiAgICAgICAgaWYgKGEgPCAyKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgbCA9IG8uc3RhcnQoYSAtIDEpLCBjID0gby5lbmQoYSAtIDEpO1xuICAgICAgICBpZiAociA+IGwgfHwgZSA+PSBsICYmIGUgPD0gYylcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoSS5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICBzdGFydE9mZnNldDogbCxcbiAgICAgICAgICBlbmRPZmZzZXQ6IDEgLyAwLFxuICAgICAgICAgIHR5cGU6IG5cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBNZWRpYSBTb3VyY2UgZHVyYXRpb24gdG8gY3VycmVudCBsZXZlbCBkdXJhdGlvbiBvciBvdmVycmlkZSB0byBJbmZpbml0eSBpZiBjb25maWd1cmF0aW9uIHBhcmFtZXRlclxuICAgKiAnbGl2ZUR1cmF0aW9uSW5maW5pdHlgIGlzIHNldCB0byBgdHJ1ZWBcbiAgICogTW9yZSBkZXRhaWxzOiBodHRwczovL2dpdGh1Yi5jb20vdmlkZW8tZGV2L2hscy5qcy9pc3N1ZXMvMzU1XG4gICAqL1xuICBnZXREdXJhdGlvbkFuZFJhbmdlKCkge1xuICAgIHZhciBlO1xuICAgIGNvbnN0IHtcbiAgICAgIGRldGFpbHM6IHQsXG4gICAgICBtZWRpYVNvdXJjZTogclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghdCB8fCAhdGhpcy5tZWRpYSB8fCAociA9PSBudWxsID8gdm9pZCAwIDogci5yZWFkeVN0YXRlKSAhPT0gXCJvcGVuXCIpXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjb25zdCBuID0gdC5lZGdlO1xuICAgIGlmICh0LmxpdmUgJiYgdGhpcy5obHMuY29uZmlnLmxpdmVEdXJhdGlvbkluZmluaXR5KSB7XG4gICAgICBpZiAodC5mcmFnbWVudHMubGVuZ3RoICYmIHIuc2V0TGl2ZVNlZWthYmxlUmFuZ2UpIHtcbiAgICAgICAgY29uc3QgYyA9IE1hdGgubWF4KDAsIHQuZnJhZ21lbnRTdGFydCksIHUgPSBNYXRoLm1heChjLCBuKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkdXJhdGlvbjogMSAvIDAsXG4gICAgICAgICAgc3RhcnQ6IGMsXG4gICAgICAgICAgZW5kOiB1XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkdXJhdGlvbjogMSAvIDBcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGkgPSAoZSA9IHRoaXMub3ZlcnJpZGVzKSA9PSBudWxsID8gdm9pZCAwIDogZS5kdXJhdGlvbjtcbiAgICBpZiAoaSlcbiAgICAgIHJldHVybiB1ZShpKSA/IHtcbiAgICAgICAgZHVyYXRpb246IGlcbiAgICAgIH0gOiBudWxsO1xuICAgIGNvbnN0IG8gPSB0aGlzLm1lZGlhLmR1cmF0aW9uLCBhID0gdWUoci5kdXJhdGlvbikgPyByLmR1cmF0aW9uIDogMDtcbiAgICByZXR1cm4gbiA+IGEgJiYgbiA+IG8gfHwgIXVlKG8pID8ge1xuICAgICAgZHVyYXRpb246IG5cbiAgICB9IDogbnVsbDtcbiAgfVxuICB1cGRhdGVNZWRpYVNvdXJjZSh7XG4gICAgZHVyYXRpb246IGUsXG4gICAgc3RhcnQ6IHQsXG4gICAgZW5kOiByXG4gIH0pIHtcbiAgICBjb25zdCBuID0gdGhpcy5tZWRpYVNvdXJjZTtcbiAgICAhdGhpcy5tZWRpYSB8fCAhbiB8fCBuLnJlYWR5U3RhdGUgIT09IFwib3BlblwiIHx8IChuLmR1cmF0aW9uICE9PSBlICYmICh1ZShlKSAmJiB0aGlzLmxvZyhgVXBkYXRpbmcgTWVkaWFTb3VyY2UgZHVyYXRpb24gdG8gJHtlLnRvRml4ZWQoMyl9YCksIG4uZHVyYXRpb24gPSBlKSwgdCAhPT0gdm9pZCAwICYmIHIgIT09IHZvaWQgMCAmJiAodGhpcy5sb2coYE1lZGlhU291cmNlIGR1cmF0aW9uIGlzIHNldCB0byAke24uZHVyYXRpb259LiBTZXR0aW5nIHNlZWthYmxlIHJhbmdlIHRvICR7dH0tJHtyfS5gKSwgbi5zZXRMaXZlU2Vla2FibGVSYW5nZSh0LCByKSkpO1xuICB9XG4gIGdldCB0cmFja3NSZWFkeSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5wZW5kaW5nVHJhY2tDb3VudDtcbiAgICByZXR1cm4gZSA+IDAgJiYgKGUgPj0gdGhpcy5idWZmZXJDb2RlY0V2ZW50c1RvdGFsIHx8IHRoaXMuaXNQZW5kaW5nKHRoaXMudHJhY2tzLmF1ZGlvdmlkZW8pKTtcbiAgfVxuICBjaGVja1BlbmRpbmdUcmFja3MoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYnVmZmVyQ29kZWNFdmVudHNUb3RhbDogZSxcbiAgICAgIHBlbmRpbmdUcmFja0NvdW50OiB0LFxuICAgICAgdHJhY2tzOiByXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHRoaXMubG9nKGBjaGVja1BlbmRpbmdUcmFja3MgKHBlbmRpbmc6ICR7dH0gY29kZWMgZXZlbnRzIGV4cGVjdGVkOiAke2V9KSAke2F0KHIpfWApLCB0aGlzLnRyYWNrc1JlYWR5KSB7XG4gICAgICB2YXIgbjtcbiAgICAgIGNvbnN0IGkgPSAobiA9IHRoaXMudHJhbnNmZXJEYXRhKSA9PSBudWxsID8gdm9pZCAwIDogbi50cmFja3M7XG4gICAgICBpICYmIE9iamVjdC5rZXlzKGkpLmxlbmd0aCA/IHRoaXMuYXR0YWNoVHJhbnNmZXJyZWQoKSA6IHRoaXMuY3JlYXRlU291cmNlQnVmZmVycygpO1xuICAgIH1cbiAgfVxuICBidWZmZXJDcmVhdGVkKCkge1xuICAgIGlmICh0aGlzLnNvdXJjZUJ1ZmZlckNvdW50KSB7XG4gICAgICBjb25zdCBlID0ge307XG4gICAgICB0aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaCgoW3QsIHJdKSA9PiB7XG4gICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgY29uc3QgbiA9IHRoaXMudHJhY2tzW3RdO1xuICAgICAgICAgIGVbdF0gPSB7XG4gICAgICAgICAgICBidWZmZXI6IHIsXG4gICAgICAgICAgICBjb250YWluZXI6IG4uY29udGFpbmVyLFxuICAgICAgICAgICAgY29kZWM6IG4uY29kZWMsXG4gICAgICAgICAgICBzdXBwbGVtZW50YWw6IG4uc3VwcGxlbWVudGFsLFxuICAgICAgICAgICAgbGV2ZWxDb2RlYzogbi5sZXZlbENvZGVjLFxuICAgICAgICAgICAgaWQ6IG4uaWQsXG4gICAgICAgICAgICBtZXRhZGF0YTogbi5tZXRhZGF0YVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pLCB0aGlzLmhscy50cmlnZ2VyKEkuQlVGRkVSX0NSRUFURUQsIHtcbiAgICAgICAgdHJhY2tzOiBlXG4gICAgICB9KSwgdGhpcy5sb2coYFNvdXJjZUJ1ZmZlcnMgY3JlYXRlZC4gUnVubmluZyBxdWV1ZTogJHt0aGlzLm9wZXJhdGlvblF1ZXVlfWApLCB0aGlzLnNvdXJjZUJ1ZmZlcnMuZm9yRWFjaCgoW3RdKSA9PiB7XG4gICAgICAgIHRoaXMuZXhlY3V0ZU5leHQodCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcihcImNvdWxkIG5vdCBjcmVhdGUgc291cmNlIGJ1ZmZlciBmb3IgbWVkaWEgY29kZWMocylcIik7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEkuRVJST1IsIHtcbiAgICAgICAgdHlwZTogdmUuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEouQlVGRkVSX0lOQ09NUEFUSUJMRV9DT0RFQ1NfRVJST1IsXG4gICAgICAgIGZhdGFsOiAhMCxcbiAgICAgICAgZXJyb3I6IGUsXG4gICAgICAgIHJlYXNvbjogZS5tZXNzYWdlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlU291cmNlQnVmZmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICB0cmFja3M6IGUsXG4gICAgICBzb3VyY2VCdWZmZXJzOiB0LFxuICAgICAgbWVkaWFTb3VyY2U6IHJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXIpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjcmVhdGVTb3VyY2VCdWZmZXJzIGNhbGxlZCB3aGVuIG1lZGlhU291cmNlIHdhcyBudWxsXCIpO1xuICAgIGZvciAoY29uc3QgaSBpbiBlKSB7XG4gICAgICBjb25zdCBvID0gaSwgYSA9IGVbb107XG4gICAgICBpZiAodGhpcy5pc1BlbmRpbmcoYSkpIHtcbiAgICAgICAgY29uc3QgbCA9IHRoaXMuZ2V0VHJhY2tDb2RlYyhhLCBvKSwgYyA9IGAke2EuY29udGFpbmVyfTtjb2RlY3M9JHtsfWA7XG4gICAgICAgIGEuY29kZWMgPSBsLCB0aGlzLmxvZyhgY3JlYXRpbmcgc291cmNlQnVmZmVyKCR7Y30pJHt0aGlzLmN1cnJlbnRPcChvKSA/IFwiIFF1ZXVlZFwiIDogXCJcIn0gJHthdChhKX1gKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB1ID0gci5hZGRTb3VyY2VCdWZmZXIoYyksIGQgPSBTbChvKSwgaCA9IFtvLCB1XTtcbiAgICAgICAgICB0W2RdID0gaCwgYS5idWZmZXIgPSB1O1xuICAgICAgICB9IGNhdGNoICh1KSB7XG4gICAgICAgICAgdmFyIG47XG4gICAgICAgICAgdGhpcy5lcnJvcihgZXJyb3Igd2hpbGUgdHJ5aW5nIHRvIGFkZCBzb3VyY2VCdWZmZXI6ICR7dS5tZXNzYWdlfWApLCB0aGlzLnNoaWZ0QW5kRXhlY3V0ZU5leHQobyksIChuID0gdGhpcy5vcGVyYXRpb25RdWV1ZSkgPT0gbnVsbCB8fCBuLnJlbW92ZUJsb2NrZXJzKCksIGRlbGV0ZSB0aGlzLnRyYWNrc1tvXSwgdGhpcy5obHMudHJpZ2dlcihJLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiB2ZS5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEouQlVGRkVSX0FERF9DT0RFQ19FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiAhMSxcbiAgICAgICAgICAgIGVycm9yOiB1LFxuICAgICAgICAgICAgc291cmNlQnVmZmVyTmFtZTogbyxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBjLFxuICAgICAgICAgICAgcGFyZW50OiBhLmlkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2tTb3VyY2VCdWZmZXIobywgYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYnVmZmVyQ3JlYXRlZCgpO1xuICB9XG4gIGdldFRyYWNrQ29kZWMoZSwgdCkge1xuICAgIGNvbnN0IHIgPSBlLnN1cHBsZW1lbnRhbDtcbiAgICBsZXQgbiA9IGUuY29kZWM7XG4gICAgciAmJiAodCA9PT0gXCJ2aWRlb1wiIHx8IHQgPT09IFwiYXVkaW92aWRlb1wiKSAmJiBnaShyLCBcInZpZGVvXCIpICYmIChuID0gWFMobiwgcikpO1xuICAgIGNvbnN0IGkgPSBmbyhuLCBlLmxldmVsQ29kZWMpO1xuICAgIHJldHVybiBpID8gdC5zbGljZSgwLCA1KSA9PT0gXCJhdWRpb1wiID8gWG8oaSwgdGhpcy5hcHBlbmRTb3VyY2UpIDogaSA6IFwiXCI7XG4gIH1cbiAgdHJhY2tTb3VyY2VCdWZmZXIoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0LmJ1ZmZlcjtcbiAgICBpZiAoIXIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0VHJhY2tDb2RlYyh0LCBlKTtcbiAgICB0aGlzLnRyYWNrc1tlXSA9IHtcbiAgICAgIGJ1ZmZlcjogcixcbiAgICAgIGNvZGVjOiBuLFxuICAgICAgY29udGFpbmVyOiB0LmNvbnRhaW5lcixcbiAgICAgIGxldmVsQ29kZWM6IHQubGV2ZWxDb2RlYyxcbiAgICAgIHN1cHBsZW1lbnRhbDogdC5zdXBwbGVtZW50YWwsXG4gICAgICBtZXRhZGF0YTogdC5tZXRhZGF0YSxcbiAgICAgIGlkOiB0LmlkLFxuICAgICAgbGlzdGVuZXJzOiBbXVxuICAgIH0sIHRoaXMucmVtb3ZlQnVmZmVyTGlzdGVuZXJzKGUpLCB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKGUsIFwidXBkYXRlc3RhcnRcIiwgdGhpcy5vblNCVXBkYXRlU3RhcnQpLCB0aGlzLmFkZEJ1ZmZlckxpc3RlbmVyKGUsIFwidXBkYXRlZW5kXCIsIHRoaXMub25TQlVwZGF0ZUVuZCksIHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIoZSwgXCJlcnJvclwiLCB0aGlzLm9uU0JVcGRhdGVFcnJvciksIHRoaXMuYXBwZW5kU291cmNlICYmIHRoaXMuYWRkQnVmZmVyTGlzdGVuZXIoZSwgXCJidWZmZXJlZGNoYW5nZVwiLCAoaSwgbykgPT4ge1xuICAgICAgY29uc3QgYSA9IG8ucmVtb3ZlZFJhbmdlcztcbiAgICAgIGEgIT0gbnVsbCAmJiBhLmxlbmd0aCAmJiB0aGlzLmhscy50cmlnZ2VyKEkuQlVGRkVSX0ZMVVNIRUQsIHtcbiAgICAgICAgdHlwZTogaVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0IG1lZGlhU3JjKCkge1xuICAgIHZhciBlLCB0O1xuICAgIGNvbnN0IHIgPSAoKGUgPSB0aGlzLm1lZGlhKSA9PSBudWxsIHx8ICh0ID0gZS5xdWVyeVNlbGVjdG9yKSA9PSBudWxsID8gdm9pZCAwIDogdC5jYWxsKGUsIFwic291cmNlXCIpKSB8fCB0aGlzLm1lZGlhO1xuICAgIHJldHVybiByID09IG51bGwgPyB2b2lkIDAgOiByLnNyYztcbiAgfVxuICBvblNCVXBkYXRlU3RhcnQoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmN1cnJlbnRPcChlKTtcbiAgICB0ICYmIHQub25TdGFydCgpO1xuICB9XG4gIG9uU0JVcGRhdGVFbmQoZSkge1xuICAgIHZhciB0O1xuICAgIGlmICgoKHQgPSB0aGlzLm1lZGlhU291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogdC5yZWFkeVN0YXRlKSA9PT0gXCJjbG9zZWRcIikge1xuICAgICAgdGhpcy5yZXNldEJ1ZmZlcihlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgciA9IHRoaXMuY3VycmVudE9wKGUpO1xuICAgIHIgJiYgKHIub25Db21wbGV0ZSgpLCB0aGlzLnNoaWZ0QW5kRXhlY3V0ZU5leHQoZSkpO1xuICB9XG4gIG9uU0JVcGRhdGVFcnJvcihlLCB0KSB7XG4gICAgdmFyIHI7XG4gICAgY29uc3QgbiA9IG5ldyBFcnJvcihgJHtlfSBTb3VyY2VCdWZmZXIgZXJyb3IuIE1lZGlhU291cmNlIHJlYWR5U3RhdGU6ICR7KHIgPSB0aGlzLm1lZGlhU291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogci5yZWFkeVN0YXRlfWApO1xuICAgIHRoaXMuZXJyb3IoYCR7bn1gLCB0KSwgdGhpcy5obHMudHJpZ2dlcihJLkVSUk9SLCB7XG4gICAgICB0eXBlOiB2ZS5NRURJQV9FUlJPUixcbiAgICAgIGRldGFpbHM6IEouQlVGRkVSX0FQUEVORElOR19FUlJPUixcbiAgICAgIHNvdXJjZUJ1ZmZlck5hbWU6IGUsXG4gICAgICBlcnJvcjogbixcbiAgICAgIGZhdGFsOiAhMVxuICAgIH0pO1xuICAgIGNvbnN0IGkgPSB0aGlzLmN1cnJlbnRPcChlKTtcbiAgICBpICYmIGkub25FcnJvcihuKTtcbiAgfVxuICB1cGRhdGVUaW1lc3RhbXBPZmZzZXQoZSwgdCwgciwgbiwgaSwgbykge1xuICAgIGNvbnN0IGEgPSB0IC0gZS50aW1lc3RhbXBPZmZzZXQ7XG4gICAgTWF0aC5hYnMoYSkgPj0gciAmJiAodGhpcy5sb2coYFVwZGF0aW5nICR7bn0gU291cmNlQnVmZmVyIHRpbWVzdGFtcE9mZnNldCB0byAke3R9IChzbjogJHtpfSBjYzogJHtvfSlgKSwgZS50aW1lc3RhbXBPZmZzZXQgPSB0KTtcbiAgfVxuICAvLyBUaGlzIG1ldGhvZCBtdXN0IHJlc3VsdCBpbiBhbiB1cGRhdGVlbmQgZXZlbnQ7IGlmIHJlbW92ZSBpcyBub3QgY2FsbGVkLCBvblNCVXBkYXRlRW5kIG11c3QgYmUgY2FsbGVkIG1hbnVhbGx5XG4gIHJlbW92ZUV4ZWN1dG9yKGUsIHQsIHIpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYTogbixcbiAgICAgIG1lZGlhU291cmNlOiBpXG4gICAgfSA9IHRoaXMsIG8gPSB0aGlzLnRyYWNrc1tlXSwgYSA9IG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uYnVmZmVyO1xuICAgIGlmICghbiB8fCAhaSB8fCAhYSkge1xuICAgICAgdGhpcy53YXJuKGBBdHRlbXB0aW5nIHRvIHJlbW92ZSBmcm9tIHRoZSAke2V9IFNvdXJjZUJ1ZmZlciwgYnV0IGl0IGRvZXMgbm90IGV4aXN0YCksIHRoaXMuc2hpZnRBbmRFeGVjdXRlTmV4dChlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbCA9IHVlKG4uZHVyYXRpb24pID8gbi5kdXJhdGlvbiA6IDEgLyAwLCBjID0gdWUoaS5kdXJhdGlvbikgPyBpLmR1cmF0aW9uIDogMSAvIDAsIHUgPSBNYXRoLm1heCgwLCB0KSwgZCA9IE1hdGgubWluKHIsIGwsIGMpO1xuICAgIGQgPiB1ICYmICghby5lbmRpbmcgfHwgby5lbmRlZCkgPyAoby5lbmRlZCA9ICExLCB0aGlzLmxvZyhgUmVtb3ZpbmcgWyR7dX0sJHtkfV0gZnJvbSB0aGUgJHtlfSBTb3VyY2VCdWZmZXJgKSwgYS5yZW1vdmUodSwgZCkpIDogdGhpcy5zaGlmdEFuZEV4ZWN1dGVOZXh0KGUpO1xuICB9XG4gIC8vIFRoaXMgbWV0aG9kIG11c3QgcmVzdWx0IGluIGFuIHVwZGF0ZWVuZCBldmVudDsgaWYgYXBwZW5kIGlzIG5vdCBjYWxsZWQsIG9uU0JVcGRhdGVFbmQgbXVzdCBiZSBjYWxsZWQgbWFudWFsbHlcbiAgYXBwZW5kRXhlY3V0b3IoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLnRyYWNrc1t0XSwgbiA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuYnVmZmVyO1xuICAgIGlmICghbilcbiAgICAgIHRocm93IG5ldyBhMihgQXR0ZW1wdGluZyB0byBhcHBlbmQgdG8gdGhlICR7dH0gU291cmNlQnVmZmVyLCBidXQgaXQgZG9lcyBub3QgZXhpc3RgKTtcbiAgICByLmVuZGluZyA9ICExLCByLmVuZGVkID0gITEsIG4uYXBwZW5kQnVmZmVyKGUpO1xuICB9XG4gIGJsb2NrVW50aWxPcGVuKGUpIHtcbiAgICBpZiAodGhpcy5pc1VwZGF0aW5nKCkgfHwgdGhpcy5pc1F1ZXVlZCgpKVxuICAgICAgdGhpcy5ibG9ja0J1ZmZlcnMoZSkuY2F0Y2goKHQpID0+IHtcbiAgICAgICAgdGhpcy53YXJuKGBTb3VyY2VCdWZmZXIgYmxvY2tlZCBjYWxsYmFjayAke3R9YCksIHRoaXMuc3RlcE9wZXJhdGlvblF1ZXVlKHRoaXMuc291cmNlQnVmZmVyVHlwZXMpO1xuICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgdHJ5IHtcbiAgICAgICAgZSgpO1xuICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICB0aGlzLndhcm4oYENhbGxiYWNrIHJ1biB3aXRob3V0IGJsb2NraW5nICR7dGhpcy5vcGVyYXRpb25RdWV1ZX0gJHt0fWApO1xuICAgICAgfVxuICB9XG4gIGlzVXBkYXRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlQnVmZmVycy5zb21lKChbZSwgdF0pID0+IGUgJiYgdC51cGRhdGluZyk7XG4gIH1cbiAgaXNRdWV1ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc291cmNlQnVmZmVycy5zb21lKChbZV0pID0+IGUgJiYgISF0aGlzLmN1cnJlbnRPcChlKSk7XG4gIH1cbiAgaXNQZW5kaW5nKGUpIHtcbiAgICByZXR1cm4gISFlICYmICFlLmJ1ZmZlcjtcbiAgfVxuICAvLyBFbnF1ZXVlcyBhbiBvcGVyYXRpb24gdG8gZWFjaCBTb3VyY2VCdWZmZXIgcXVldWUgd2hpY2gsIHVwb24gZXhlY3V0aW9uLCByZXNvbHZlcyBhIHByb21pc2UuIFdoZW4gYWxsIHByb21pc2VzXG4gIC8vIHJlc29sdmUsIHRoZSBvblVuYmxvY2tlZCBmdW5jdGlvbiBpcyBleGVjdXRlZC4gRnVuY3Rpb25zIGNhbGxpbmcgdGhpcyBtZXRob2QgZG8gbm90IG5lZWQgdG8gdW5ibG9jayB0aGUgcXVldWVcbiAgLy8gdXBvbiBjb21wbGV0aW9uLCBzaW5jZSB3ZSBhbHJlYWR5IGRvIGl0IGhlcmVcbiAgYmxvY2tCdWZmZXJzKGUsIHQgPSB0aGlzLnNvdXJjZUJ1ZmZlclR5cGVzKSB7XG4gICAgaWYgKCF0Lmxlbmd0aClcbiAgICAgIHJldHVybiB0aGlzLmxvZyhcIkJsb2NraW5nIG9wZXJhdGlvbiByZXF1ZXN0ZWQsIGJ1dCBubyBTb3VyY2VCdWZmZXJzIGV4aXN0XCIpLCBQcm9taXNlLnJlc29sdmUoKS50aGVuKGUpO1xuICAgIGNvbnN0IHtcbiAgICAgIG9wZXJhdGlvblF1ZXVlOiByXG4gICAgfSA9IHRoaXMsIG4gPSB0Lm1hcCgobykgPT4gdGhpcy5hcHBlbmRCbG9ja2VyKG8pKTtcbiAgICByZXR1cm4gdC5sZW5ndGggPiAxICYmICEhdGhpcy5ibG9ja2VkQXVkaW9BcHBlbmQgJiYgdGhpcy51bmJsb2NrQXVkaW8oKSwgUHJvbWlzZS5hbGwobikudGhlbigobykgPT4ge1xuICAgICAgciA9PT0gdGhpcy5vcGVyYXRpb25RdWV1ZSAmJiAoZSgpLCB0aGlzLnN0ZXBPcGVyYXRpb25RdWV1ZSh0aGlzLnNvdXJjZUJ1ZmZlclR5cGVzKSk7XG4gICAgfSk7XG4gIH1cbiAgc3RlcE9wZXJhdGlvblF1ZXVlKGUpIHtcbiAgICBlLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHZhciByO1xuICAgICAgY29uc3QgbiA9IChyID0gdGhpcy50cmFja3NbdF0pID09IG51bGwgPyB2b2lkIDAgOiByLmJ1ZmZlcjtcbiAgICAgICFuIHx8IG4udXBkYXRpbmcgfHwgdGhpcy5zaGlmdEFuZEV4ZWN1dGVOZXh0KHQpO1xuICAgIH0pO1xuICB9XG4gIGFwcGVuZChlLCB0LCByKSB7XG4gICAgdGhpcy5vcGVyYXRpb25RdWV1ZSAmJiB0aGlzLm9wZXJhdGlvblF1ZXVlLmFwcGVuZChlLCB0LCByKTtcbiAgfVxuICBhcHBlbmRCbG9ja2VyKGUpIHtcbiAgICBpZiAodGhpcy5vcGVyYXRpb25RdWV1ZSlcbiAgICAgIHJldHVybiB0aGlzLm9wZXJhdGlvblF1ZXVlLmFwcGVuZEJsb2NrZXIoZSk7XG4gIH1cbiAgY3VycmVudE9wKGUpIHtcbiAgICByZXR1cm4gdGhpcy5vcGVyYXRpb25RdWV1ZSA/IHRoaXMub3BlcmF0aW9uUXVldWUuY3VycmVudChlKSA6IG51bGw7XG4gIH1cbiAgZXhlY3V0ZU5leHQoZSkge1xuICAgIGUgJiYgdGhpcy5vcGVyYXRpb25RdWV1ZSAmJiB0aGlzLm9wZXJhdGlvblF1ZXVlLmV4ZWN1dGVOZXh0KGUpO1xuICB9XG4gIHNoaWZ0QW5kRXhlY3V0ZU5leHQoZSkge1xuICAgIHRoaXMub3BlcmF0aW9uUXVldWUgJiYgdGhpcy5vcGVyYXRpb25RdWV1ZS5zaGlmdEFuZEV4ZWN1dGVOZXh0KGUpO1xuICB9XG4gIGdldCBwZW5kaW5nVHJhY2tDb3VudCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy50cmFja3MpLnJlZHVjZSgoZSwgdCkgPT4gZSArICh0aGlzLmlzUGVuZGluZyh0aGlzLnRyYWNrc1t0XSkgPyAxIDogMCksIDApO1xuICB9XG4gIGdldCBzb3VyY2VCdWZmZXJDb3VudCgpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2VCdWZmZXJzLnJlZHVjZSgoZSwgW3RdKSA9PiBlICsgKHQgPyAxIDogMCksIDApO1xuICB9XG4gIGdldCBzb3VyY2VCdWZmZXJUeXBlcygpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2VCdWZmZXJzLm1hcCgoW2VdKSA9PiBlKS5maWx0ZXIoKGUpID0+ICEhZSk7XG4gIH1cbiAgYWRkQnVmZmVyTGlzdGVuZXIoZSwgdCwgcikge1xuICAgIGNvbnN0IG4gPSB0aGlzLnRyYWNrc1tlXTtcbiAgICBpZiAoIW4pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IG4uYnVmZmVyO1xuICAgIGlmICghaSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBvID0gci5iaW5kKHRoaXMsIGUpO1xuICAgIG4ubGlzdGVuZXJzLnB1c2goe1xuICAgICAgZXZlbnQ6IHQsXG4gICAgICBsaXN0ZW5lcjogb1xuICAgIH0pLCBpLmFkZEV2ZW50TGlzdGVuZXIodCwgbyk7XG4gIH1cbiAgcmVtb3ZlQnVmZmVyTGlzdGVuZXJzKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy50cmFja3NbZV07XG4gICAgaWYgKCF0KVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSB0LmJ1ZmZlcjtcbiAgICByICYmICh0Lmxpc3RlbmVycy5mb3JFYWNoKChuKSA9PiB7XG4gICAgICByLnJlbW92ZUV2ZW50TGlzdGVuZXIobi5ldmVudCwgbi5saXN0ZW5lcik7XG4gICAgfSksIHQubGlzdGVuZXJzLmxlbmd0aCA9IDApO1xuICB9XG59XG5mdW5jdGlvbiBIaChzKSB7XG4gIGNvbnN0IGUgPSBzLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzb3VyY2VcIik7XG4gIFtdLnNsaWNlLmNhbGwoZSkuZm9yRWFjaCgodCkgPT4ge1xuICAgIHMucmVtb3ZlQ2hpbGQodCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gYzIocywgZSkge1xuICBjb25zdCB0ID0gc2VsZi5kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic291cmNlXCIpO1xuICB0LnR5cGUgPSBcInZpZGVvL21wNFwiLCB0LnNyYyA9IGUsIHMuYXBwZW5kQ2hpbGQodCk7XG59XG5mdW5jdGlvbiBTbChzKSB7XG4gIHJldHVybiBzID09PSBcImF1ZGlvXCIgPyAxIDogMDtcbn1cbmNsYXNzIER1IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwLCB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSB2b2lkIDAsIHRoaXMuZmlyc3RMZXZlbCA9IHZvaWQgMCwgdGhpcy5tZWRpYSA9IHZvaWQgMCwgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gdm9pZCAwLCB0aGlzLnRpbWVyID0gdm9pZCAwLCB0aGlzLmNsaWVudFJlY3QgPSB2b2lkIDAsIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMCwgdGhpcy5obHMgPSBlLCB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHRoaXMuZmlyc3RMZXZlbCA9IC0xLCB0aGlzLm1lZGlhID0gbnVsbCwgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW10sIHRoaXMudGltZXIgPSB2b2lkIDAsIHRoaXMuY2xpZW50UmVjdCA9IG51bGwsIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBzZXRTdHJlYW1Db250cm9sbGVyKGUpIHtcbiAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBlO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5obHMgJiYgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXIoKSwgdGhpcy50aW1lciAmJiB0aGlzLnN0b3BDYXBwaW5nKCksIHRoaXMubWVkaWEgPSBudWxsLCB0aGlzLmNsaWVudFJlY3QgPSBudWxsLCB0aGlzLmhscyA9IHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IG51bGw7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzOiBlXG4gICAgfSA9IHRoaXM7XG4gICAgZS5vbihJLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHRoaXMub25GcHNEcm9wTGV2ZWxDYXBwaW5nLCB0aGlzKSwgZS5vbihJLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKSwgZS5vbihJLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKSwgZS5vbihJLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyksIGUub24oSS5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKSwgZS5vbihJLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzOiBlXG4gICAgfSA9IHRoaXM7XG4gICAgZS5vZmYoSS5GUFNfRFJPUF9MRVZFTF9DQVBQSU5HLCB0aGlzLm9uRnBzRHJvcExldmVsQ2FwcGluZywgdGhpcyksIGUub2ZmKEkuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpLCBlLm9mZihJLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKSwgZS5vZmYoSS5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpLCBlLm9mZihJLkJVRkZFUl9DT0RFQ1MsIHRoaXMub25CdWZmZXJDb2RlY3MsIHRoaXMpLCBlLm9mZihJLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgfVxuICBvbkZwc0Ryb3BMZXZlbENhcHBpbmcoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLmhscy5sZXZlbHNbdC5kcm9wcGVkTGV2ZWxdO1xuICAgIHRoaXMuaXNMZXZlbEFsbG93ZWQocikgJiYgdGhpcy5yZXN0cmljdGVkTGV2ZWxzLnB1c2goe1xuICAgICAgYml0cmF0ZTogci5iaXRyYXRlLFxuICAgICAgaGVpZ2h0OiByLmhlaWdodCxcbiAgICAgIHdpZHRoOiByLndpZHRoXG4gICAgfSk7XG4gIH1cbiAgb25NZWRpYUF0dGFjaGluZyhlLCB0KSB7XG4gICAgdGhpcy5tZWRpYSA9IHQubWVkaWEgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50ID8gdC5tZWRpYSA6IG51bGwsIHRoaXMuY2xpZW50UmVjdCA9IG51bGwsIHRoaXMudGltZXIgJiYgdGhpcy5obHMubGV2ZWxzLmxlbmd0aCAmJiB0aGlzLmRldGVjdFBsYXllclNpemUoKTtcbiAgfVxuICBvbk1hbmlmZXN0UGFyc2VkKGUsIHQpIHtcbiAgICBjb25zdCByID0gdGhpcy5obHM7XG4gICAgdGhpcy5yZXN0cmljdGVkTGV2ZWxzID0gW10sIHRoaXMuZmlyc3RMZXZlbCA9IHQuZmlyc3RMZXZlbCwgci5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgdC52aWRlbyAmJiB0aGlzLnN0YXJ0Q2FwcGluZygpO1xuICB9XG4gIG9uTGV2ZWxzVXBkYXRlZChlLCB0KSB7XG4gICAgdGhpcy50aW1lciAmJiB1ZSh0aGlzLmF1dG9MZXZlbENhcHBpbmcpICYmIHRoaXMuZGV0ZWN0UGxheWVyU2l6ZSgpO1xuICB9XG4gIC8vIE9ubHkgYWN0aXZhdGUgY2FwcGluZyB3aGVuIHBsYXlpbmcgYSB2aWRlbyBzdHJlYW07IG90aGVyd2lzZSwgbXVsdGktYml0cmF0ZSBhdWRpby1vbmx5IHN0cmVhbXMgd2lsbCBiZSByZXN0cmljdGVkXG4gIC8vIHRvIHRoZSBmaXJzdCBsZXZlbFxuICBvbkJ1ZmZlckNvZGVjcyhlLCB0KSB7XG4gICAgdGhpcy5obHMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplICYmIHQudmlkZW8gJiYgdGhpcy5zdGFydENhcHBpbmcoKTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIHRoaXMuc3RvcENhcHBpbmcoKSwgdGhpcy5tZWRpYSA9IG51bGw7XG4gIH1cbiAgZGV0ZWN0UGxheWVyU2l6ZSgpIHtcbiAgICBpZiAodGhpcy5tZWRpYSkge1xuICAgICAgaWYgKHRoaXMubWVkaWFIZWlnaHQgPD0gMCB8fCB0aGlzLm1lZGlhV2lkdGggPD0gMCkge1xuICAgICAgICB0aGlzLmNsaWVudFJlY3QgPSBudWxsO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBlID0gdGhpcy5obHMubGV2ZWxzO1xuICAgICAgaWYgKGUubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLmhscywgciA9IHRoaXMuZ2V0TWF4TGV2ZWwoZS5sZW5ndGggLSAxKTtcbiAgICAgICAgciAhPT0gdGhpcy5hdXRvTGV2ZWxDYXBwaW5nICYmIHQubG9nZ2VyLmxvZyhgU2V0dGluZyBhdXRvTGV2ZWxDYXBwaW5nIHRvICR7cn06ICR7ZVtyXS5oZWlnaHR9cEAke2Vbcl0uYml0cmF0ZX0gZm9yIG1lZGlhICR7dGhpcy5tZWRpYVdpZHRofXgke3RoaXMubWVkaWFIZWlnaHR9YCksIHQuYXV0b0xldmVsQ2FwcGluZyA9IHIsIHQuYXV0b0xldmVsRW5hYmxlZCAmJiB0LmF1dG9MZXZlbENhcHBpbmcgPiB0aGlzLmF1dG9MZXZlbENhcHBpbmcgJiYgdGhpcy5zdHJlYW1Db250cm9sbGVyICYmIHRoaXMuc3RyZWFtQ29udHJvbGxlci5uZXh0TGV2ZWxTd2l0Y2goKSwgdGhpcy5hdXRvTGV2ZWxDYXBwaW5nID0gdC5hdXRvTGV2ZWxDYXBwaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKlxuICAgKiByZXR1cm5zIGxldmVsIHNob3VsZCBiZSB0aGUgb25lIHdpdGggdGhlIGRpbWVuc2lvbnMgZXF1YWwgb3IgZ3JlYXRlciB0aGFuIHRoZSBtZWRpYSAocGxheWVyKSBkaW1lbnNpb25zIChzbyB0aGUgdmlkZW8gd2lsbCBiZSBkb3duc2NhbGVkKVxuICAgKi9cbiAgZ2V0TWF4TGV2ZWwoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmhscy5sZXZlbHM7XG4gICAgaWYgKCF0Lmxlbmd0aClcbiAgICAgIHJldHVybiAtMTtcbiAgICBjb25zdCByID0gdC5maWx0ZXIoKG4sIGkpID0+IHRoaXMuaXNMZXZlbEFsbG93ZWQobikgJiYgaSA8PSBlKTtcbiAgICByZXR1cm4gdGhpcy5jbGllbnRSZWN0ID0gbnVsbCwgRHUuZ2V0TWF4TGV2ZWxCeU1lZGlhU2l6ZShyLCB0aGlzLm1lZGlhV2lkdGgsIHRoaXMubWVkaWFIZWlnaHQpO1xuICB9XG4gIHN0YXJ0Q2FwcGluZygpIHtcbiAgICB0aGlzLnRpbWVyIHx8ICh0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKSwgdGhpcy50aW1lciA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5kZXRlY3RQbGF5ZXJTaXplLmJpbmQodGhpcyksIDFlMyksIHRoaXMuZGV0ZWN0UGxheWVyU2l6ZSgpKTtcbiAgfVxuICBzdG9wQ2FwcGluZygpIHtcbiAgICB0aGlzLnJlc3RyaWN0ZWRMZXZlbHMgPSBbXSwgdGhpcy5maXJzdExldmVsID0gLTEsIHRoaXMuYXV0b0xldmVsQ2FwcGluZyA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgdGhpcy50aW1lciAmJiAoc2VsZi5jbGVhckludGVydmFsKHRoaXMudGltZXIpLCB0aGlzLnRpbWVyID0gdm9pZCAwKTtcbiAgfVxuICBnZXREaW1lbnNpb25zKCkge1xuICAgIGlmICh0aGlzLmNsaWVudFJlY3QpXG4gICAgICByZXR1cm4gdGhpcy5jbGllbnRSZWN0O1xuICAgIGNvbnN0IGUgPSB0aGlzLm1lZGlhLCB0ID0ge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIGlmIChlKSB7XG4gICAgICBjb25zdCByID0gZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHQud2lkdGggPSByLndpZHRoLCB0LmhlaWdodCA9IHIuaGVpZ2h0LCAhdC53aWR0aCAmJiAhdC5oZWlnaHQgJiYgKHQud2lkdGggPSByLnJpZ2h0IC0gci5sZWZ0IHx8IGUud2lkdGggfHwgMCwgdC5oZWlnaHQgPSByLmJvdHRvbSAtIHIudG9wIHx8IGUuaGVpZ2h0IHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbGllbnRSZWN0ID0gdCwgdDtcbiAgfVxuICBnZXQgbWVkaWFXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXREaW1lbnNpb25zKCkud2lkdGggKiB0aGlzLmNvbnRlbnRTY2FsZUZhY3RvcjtcbiAgfVxuICBnZXQgbWVkaWFIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RGltZW5zaW9ucygpLmhlaWdodCAqIHRoaXMuY29udGVudFNjYWxlRmFjdG9yO1xuICB9XG4gIGdldCBjb250ZW50U2NhbGVGYWN0b3IoKSB7XG4gICAgbGV0IGUgPSAxO1xuICAgIGlmICghdGhpcy5obHMuY29uZmlnLmlnbm9yZURldmljZVBpeGVsUmF0aW8pXG4gICAgICB0cnkge1xuICAgICAgICBlID0gc2VsZi5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgcmV0dXJuIE1hdGgubWluKGUsIHRoaXMuaGxzLmNvbmZpZy5tYXhEZXZpY2VQaXhlbFJhdGlvKTtcbiAgfVxuICBpc0xldmVsQWxsb3dlZChlKSB7XG4gICAgcmV0dXJuICF0aGlzLnJlc3RyaWN0ZWRMZXZlbHMuc29tZSgocikgPT4gZS5iaXRyYXRlID09PSByLmJpdHJhdGUgJiYgZS53aWR0aCA9PT0gci53aWR0aCAmJiBlLmhlaWdodCA9PT0gci5oZWlnaHQpO1xuICB9XG4gIHN0YXRpYyBnZXRNYXhMZXZlbEJ5TWVkaWFTaXplKGUsIHQsIHIpIHtcbiAgICBpZiAoIShlICE9IG51bGwgJiYgZS5sZW5ndGgpKVxuICAgICAgcmV0dXJuIC0xO1xuICAgIGNvbnN0IG4gPSAoYSwgbCkgPT4gbCA/IGEud2lkdGggIT09IGwud2lkdGggfHwgYS5oZWlnaHQgIT09IGwuaGVpZ2h0IDogITA7XG4gICAgbGV0IGkgPSBlLmxlbmd0aCAtIDE7XG4gICAgY29uc3QgbyA9IE1hdGgubWF4KHQsIHIpO1xuICAgIGZvciAobGV0IGEgPSAwOyBhIDwgZS5sZW5ndGg7IGEgKz0gMSkge1xuICAgICAgY29uc3QgbCA9IGVbYV07XG4gICAgICBpZiAoKGwud2lkdGggPj0gbyB8fCBsLmhlaWdodCA+PSBvKSAmJiBuKGwsIGVbYSArIDFdKSkge1xuICAgICAgICBpID0gYTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpO1xuICB9XG59XG5jb25zdCB1MiA9IHtcbiAgLyoqXG4gICAqIHRleHQgZmlsZSwgc3VjaCBhcyBhIG1hbmlmZXN0IG9yIHBsYXlsaXN0XG4gICAqL1xuICBNQU5JRkVTVDogXCJtXCIsXG4gIC8qKlxuICAgKiBhdWRpbyBvbmx5XG4gICAqL1xuICBBVURJTzogXCJhXCIsXG4gIC8qKlxuICAgKiB2aWRlbyBvbmx5XG4gICAqL1xuICBWSURFTzogXCJ2XCIsXG4gIC8qKlxuICAgKiBtdXhlZCBhdWRpbyBhbmQgdmlkZW9cbiAgICovXG4gIE1VWEVEOiBcImF2XCIsXG4gIC8qKlxuICAgKiBpbml0IHNlZ21lbnRcbiAgICovXG4gIElOSVQ6IFwiaVwiLFxuICAvKipcbiAgICogY2FwdGlvbiBvciBzdWJ0aXRsZVxuICAgKi9cbiAgQ0FQVElPTjogXCJjXCIsXG4gIC8qKlxuICAgKiBJU09CTUZGIHRpbWVkIHRleHQgdHJhY2tcbiAgICovXG4gIFRJTUVEX1RFWFQ6IFwidHRcIixcbiAgLyoqXG4gICAqIGNyeXB0b2dyYXBoaWMga2V5LCBsaWNlbnNlIG9yIGNlcnRpZmljYXRlLlxuICAgKi9cbiAgS0VZOiBcImtcIixcbiAgLyoqXG4gICAqIG90aGVyXG4gICAqL1xuICBPVEhFUjogXCJvXCJcbn0sIGhyID0gdTIsIGQyID0ge1xuICAvKipcbiAgICogSFRUUCBMaXZlIFN0cmVhbWluZyAoSExTKVxuICAgKi9cbiAgSExTOiBcImhcIlxufSwgaDIgPSBkMjtcbmNsYXNzIEpyIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIEFycmF5LmlzQXJyYXkoZSkgJiYgKGUgPSBlLm1hcCgocikgPT4gciBpbnN0YW5jZW9mIEpyID8gciA6IG5ldyBKcihyKSkpLCB0aGlzLnZhbHVlID0gZSwgdGhpcy5wYXJhbXMgPSB0O1xuICB9XG59XG5jb25zdCBmMiA9IFwiRGljdFwiO1xuZnVuY3Rpb24gZzIocykge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShzKSA/IEpTT04uc3RyaW5naWZ5KHMpIDogcyBpbnN0YW5jZW9mIE1hcCA/IFwiTWFwe31cIiA6IHMgaW5zdGFuY2VvZiBTZXQgPyBcIlNldHt9XCIgOiB0eXBlb2YgcyA9PSBcIm9iamVjdFwiID8gSlNPTi5zdHJpbmdpZnkocykgOiBTdHJpbmcocyk7XG59XG5mdW5jdGlvbiBwMihzLCBlLCB0LCByKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoYGZhaWxlZCB0byAke3N9IFwiJHtnMihlKX1cIiBhcyAke3R9YCwge1xuICAgIGNhdXNlOiByXG4gIH0pO1xufVxuZnVuY3Rpb24gUXIocywgZSwgdCkge1xuICByZXR1cm4gcDIoXCJzZXJpYWxpemVcIiwgcywgZSwgdCk7XG59XG5jbGFzcyBfcCB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLmRlc2NyaXB0aW9uID0gZTtcbiAgfVxufVxuY29uc3QgcWggPSBcIkJhcmUgSXRlbVwiLCBtMiA9IFwiQm9vbGVhblwiO1xuZnVuY3Rpb24geTIocykge1xuICBpZiAodHlwZW9mIHMgIT0gXCJib29sZWFuXCIpXG4gICAgdGhyb3cgUXIocywgbTIpO1xuICByZXR1cm4gcyA/IFwiPzFcIiA6IFwiPzBcIjtcbn1cbmZ1bmN0aW9uIHYyKHMpIHtcbiAgcmV0dXJuIGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5zKSk7XG59XG5jb25zdCBFMiA9IFwiQnl0ZSBTZXF1ZW5jZVwiO1xuZnVuY3Rpb24geDIocykge1xuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHMpID09PSAhMSlcbiAgICB0aHJvdyBRcihzLCBFMik7XG4gIHJldHVybiBgOiR7djIocyl9OmA7XG59XG5jb25zdCBTMiA9IFwiSW50ZWdlclwiO1xuZnVuY3Rpb24gYjIocykge1xuICByZXR1cm4gcyA8IC05OTk5OTk5OTk5OTk5OTkgfHwgOTk5OTk5OTk5OTk5OTk5IDwgcztcbn1cbmZ1bmN0aW9uIFJwKHMpIHtcbiAgaWYgKGIyKHMpKVxuICAgIHRocm93IFFyKHMsIFMyKTtcbiAgcmV0dXJuIHMudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIFQyKHMpIHtcbiAgcmV0dXJuIGBAJHtScChzLmdldFRpbWUoKSAvIDFlMyl9YDtcbn1cbmZ1bmN0aW9uIExwKHMsIGUpIHtcbiAgaWYgKHMgPCAwKVxuICAgIHJldHVybiAtTHAoLXMsIGUpO1xuICBjb25zdCB0ID0gTWF0aC5wb3coMTAsIGUpO1xuICBpZiAoTWF0aC5hYnMocyAqIHQgJSAxIC0gMC41KSA8IE51bWJlci5FUFNJTE9OKSB7XG4gICAgY29uc3QgbiA9IE1hdGguZmxvb3IocyAqIHQpO1xuICAgIHJldHVybiAobiAlIDIgPT09IDAgPyBuIDogbiArIDEpIC8gdDtcbiAgfSBlbHNlXG4gICAgcmV0dXJuIE1hdGgucm91bmQocyAqIHQpIC8gdDtcbn1cbmNvbnN0IHcyID0gXCJEZWNpbWFsXCI7XG5mdW5jdGlvbiBBMihzKSB7XG4gIGNvbnN0IGUgPSBMcChzLCAzKTtcbiAgaWYgKE1hdGguZmxvb3IoTWF0aC5hYnMoZSkpLnRvU3RyaW5nKCkubGVuZ3RoID4gMTIpXG4gICAgdGhyb3cgUXIocywgdzIpO1xuICBjb25zdCB0ID0gZS50b1N0cmluZygpO1xuICByZXR1cm4gdC5pbmNsdWRlcyhcIi5cIikgPyB0IDogYCR7dH0uMGA7XG59XG5jb25zdCBJMiA9IFwiU3RyaW5nXCIsIF8yID0gL1tcXHgwMC1cXHgxZlxceDdmXSsvO1xuZnVuY3Rpb24gUjIocykge1xuICBpZiAoXzIudGVzdChzKSlcbiAgICB0aHJvdyBRcihzLCBJMik7XG4gIHJldHVybiBgXCIke3MucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKX1cImA7XG59XG5mdW5jdGlvbiBMMihzKSB7XG4gIHJldHVybiBzLmRlc2NyaXB0aW9uIHx8IHMudG9TdHJpbmcoKS5zbGljZSg3LCAtMSk7XG59XG5jb25zdCBDMiA9IFwiVG9rZW5cIjtcbmZ1bmN0aW9uIFdoKHMpIHtcbiAgY29uc3QgZSA9IEwyKHMpO1xuICBpZiAoL14oW2EtekEtWipdKShbISMkJSYnKitcXC0uXl9gfH5cXHc6L10qKSQvLnRlc3QoZSkgPT09ICExKVxuICAgIHRocm93IFFyKGUsIEMyKTtcbiAgcmV0dXJuIGU7XG59XG5mdW5jdGlvbiB2YyhzKSB7XG4gIHN3aXRjaCAodHlwZW9mIHMpIHtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBpZiAoIXVlKHMpKVxuICAgICAgICB0aHJvdyBRcihzLCBxaCk7XG4gICAgICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcihzKSA/IFJwKHMpIDogQTIocyk7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgcmV0dXJuIFIyKHMpO1xuICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgIHJldHVybiBXaChzKTtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIHkyKHMpO1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmIChzIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgcmV0dXJuIFQyKHMpO1xuICAgICAgaWYgKHMgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4geDIocyk7XG4gICAgICBpZiAocyBpbnN0YW5jZW9mIF9wKVxuICAgICAgICByZXR1cm4gV2gocyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IFFyKHMsIHFoKTtcbiAgfVxufVxuY29uc3QgazIgPSBcIktleVwiO1xuZnVuY3Rpb24gRWMocykge1xuICBpZiAoL15bYS16Kl1bYS16MC05XFwtXy4qXSokLy50ZXN0KHMpID09PSAhMSlcbiAgICB0aHJvdyBRcihzLCBrMik7XG4gIHJldHVybiBzO1xufVxuZnVuY3Rpb24gUHUocykge1xuICByZXR1cm4gcyA9PSBudWxsID8gXCJcIiA6IE9iamVjdC5lbnRyaWVzKHMpLm1hcCgoW2UsIHRdKSA9PiB0ID09PSAhMCA/IGA7JHtFYyhlKX1gIDogYDske0VjKGUpfT0ke3ZjKHQpfWApLmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBDcChzKSB7XG4gIHJldHVybiBzIGluc3RhbmNlb2YgSnIgPyBgJHt2YyhzLnZhbHVlKX0ke1B1KHMucGFyYW1zKX1gIDogdmMocyk7XG59XG5mdW5jdGlvbiBEMihzKSB7XG4gIHJldHVybiBgKCR7cy52YWx1ZS5tYXAoQ3ApLmpvaW4oXCIgXCIpfSkke1B1KHMucGFyYW1zKX1gO1xufVxuZnVuY3Rpb24gUDIocywgZSA9IHtcbiAgd2hpdGVzcGFjZTogITBcbn0pIHtcbiAgaWYgKHR5cGVvZiBzICE9IFwib2JqZWN0XCIgfHwgcyA9PSBudWxsKVxuICAgIHRocm93IFFyKHMsIGYyKTtcbiAgY29uc3QgdCA9IHMgaW5zdGFuY2VvZiBNYXAgPyBzLmVudHJpZXMoKSA6IE9iamVjdC5lbnRyaWVzKHMpLCByID0gZSAhPSBudWxsICYmIGUud2hpdGVzcGFjZSA/IFwiIFwiIDogXCJcIjtcbiAgcmV0dXJuIEFycmF5LmZyb20odCkubWFwKChbbiwgaV0pID0+IHtcbiAgICBpIGluc3RhbmNlb2YgSnIgfHwgKGkgPSBuZXcgSnIoaSkpO1xuICAgIGxldCBvID0gRWMobik7XG4gICAgcmV0dXJuIGkudmFsdWUgPT09ICEwID8gbyArPSBQdShpLnBhcmFtcykgOiAobyArPSBcIj1cIiwgQXJyYXkuaXNBcnJheShpLnZhbHVlKSA/IG8gKz0gRDIoaSkgOiBvICs9IENwKGkpKSwgbztcbiAgfSkuam9pbihgLCR7cn1gKTtcbn1cbmZ1bmN0aW9uIGtwKHMsIGUpIHtcbiAgcmV0dXJuIFAyKHMsIGUpO1xufVxuY29uc3QgJHIgPSBcIkNNQ0QtT2JqZWN0XCIsIHl0ID0gXCJDTUNELVJlcXVlc3RcIiwgRnMgPSBcIkNNQ0QtU2Vzc2lvblwiLCBicyA9IFwiQ01DRC1TdGF0dXNcIiwgTTIgPSB7XG4gIC8vIE9iamVjdFxuICBicjogJHIsXG4gIGFiOiAkcixcbiAgZDogJHIsXG4gIG90OiAkcixcbiAgdGI6ICRyLFxuICB0cGI6ICRyLFxuICBsYjogJHIsXG4gIHRhYjogJHIsXG4gIGxhYjogJHIsXG4gIHVybDogJHIsXG4gIC8vIFJlcXVlc3RcbiAgcGI6IHl0LFxuICBibDogeXQsXG4gIHRibDogeXQsXG4gIGRsOiB5dCxcbiAgbHRjOiB5dCxcbiAgbXRwOiB5dCxcbiAgbm9yOiB5dCxcbiAgbnJyOiB5dCxcbiAgcmM6IHl0LFxuICBzbjogeXQsXG4gIHN0YTogeXQsXG4gIHN1OiB5dCxcbiAgdHRmYjogeXQsXG4gIHR0ZmJiOiB5dCxcbiAgdHRsYjogeXQsXG4gIGNtc2RkOiB5dCxcbiAgY21zZHM6IHl0LFxuICBzbXJ0OiB5dCxcbiAgZGY6IHl0LFxuICBjczogeXQsXG4gIC8vIFRPRE86IFdoaWNoIGhlYWRlciB0byBwdXQgdGhlIGB0c2AgZmllbGQgaXMgbm90IGRlZmluZWQgeWV0LlxuICB0czogeXQsXG4gIC8vIFNlc3Npb25cbiAgY2lkOiBGcyxcbiAgcHI6IEZzLFxuICBzZjogRnMsXG4gIHNpZDogRnMsXG4gIHN0OiBGcyxcbiAgdjogRnMsXG4gIG1zZDogRnMsXG4gIC8vIFN0YXR1c1xuICBicyxcbiAgYnNkOiBicyxcbiAgY2RuOiBicyxcbiAgcnRwOiBicyxcbiAgYmc6IGJzLFxuICBwdDogYnMsXG4gIGVjOiBicyxcbiAgZTogYnNcbn0sIE8yID0ge1xuICAvKipcbiAgICoga2V5cyB3aG9zZSB2YWx1ZXMgdmFyeSB3aXRoIGVhY2ggcmVxdWVzdC5cbiAgICovXG4gIFJFUVVFU1Q6IHl0XG59O1xuZnVuY3Rpb24gQjIocykge1xuICByZXR1cm4gT2JqZWN0LmtleXMocykucmVkdWNlKChlLCB0KSA9PiB7XG4gICAgdmFyIHI7XG4gICAgcmV0dXJuIChyID0gc1t0XSkgPT09IG51bGwgfHwgciA9PT0gdm9pZCAwIHx8IHIuZm9yRWFjaCgobikgPT4gZVtuXSA9IHQpLCBlO1xuICB9LCB7fSk7XG59XG5mdW5jdGlvbiBGMihzLCBlKSB7XG4gIGNvbnN0IHQgPSB7fTtcbiAgaWYgKCFzKVxuICAgIHJldHVybiB0O1xuICBjb25zdCByID0gT2JqZWN0LmtleXMocyksIG4gPSBlID8gQjIoZSkgOiB7fTtcbiAgcmV0dXJuIHIucmVkdWNlKChpLCBvKSA9PiB7XG4gICAgdmFyIGE7XG4gICAgY29uc3QgbCA9IE0yW29dIHx8IG5bb10gfHwgTzIuUkVRVUVTVCwgYyA9IChhID0gaVtsXSkgIT09IG51bGwgJiYgYSAhPT0gdm9pZCAwID8gYSA6IGlbbF0gPSB7fTtcbiAgICByZXR1cm4gY1tvXSA9IHNbb10sIGk7XG4gIH0sIHQpO1xufVxuZnVuY3Rpb24gTjIocykge1xuICByZXR1cm4gW1wib3RcIiwgXCJzZlwiLCBcInN0XCIsIFwiZVwiLCBcInN0YVwiXS5pbmNsdWRlcyhzKTtcbn1cbmZ1bmN0aW9uIFUyKHMpIHtcbiAgcmV0dXJuIHR5cGVvZiBzID09IFwibnVtYmVyXCIgPyB1ZShzKSA6IHMgIT0gbnVsbCAmJiBzICE9PSBcIlwiICYmIHMgIT09ICExO1xufVxuY29uc3QgRHAgPSBcImV2ZW50XCI7XG5mdW5jdGlvbiAkMihzLCBlKSB7XG4gIGNvbnN0IHQgPSBuZXcgVVJMKHMpLCByID0gbmV3IFVSTChlKTtcbiAgaWYgKHQub3JpZ2luICE9PSByLm9yaWdpbilcbiAgICByZXR1cm4gcztcbiAgY29uc3QgbiA9IHQucGF0aG5hbWUuc3BsaXQoXCIvXCIpLnNsaWNlKDEpLCBpID0gci5wYXRobmFtZS5zcGxpdChcIi9cIikuc2xpY2UoMSwgLTEpO1xuICBmb3IgKDsgblswXSA9PT0gaVswXTsgKVxuICAgIG4uc2hpZnQoKSwgaS5zaGlmdCgpO1xuICBmb3IgKDsgaS5sZW5ndGg7IClcbiAgICBpLnNoaWZ0KCksIG4udW5zaGlmdChcIi4uXCIpO1xuICByZXR1cm4gbi5qb2luKFwiL1wiKSArIHQuc2VhcmNoICsgdC5oYXNoO1xufVxuY29uc3Qgdm8gPSAocykgPT4gTWF0aC5yb3VuZChzKSwgeGMgPSAocywgZSkgPT4gQXJyYXkuaXNBcnJheShzKSA/IHMubWFwKCh0KSA9PiB4Yyh0LCBlKSkgOiBzIGluc3RhbmNlb2YgSnIgJiYgdHlwZW9mIHMudmFsdWUgPT0gXCJzdHJpbmdcIiA/IG5ldyBKcih4YyhzLnZhbHVlLCBlKSwgcy5wYXJhbXMpIDogKGUuYmFzZVVybCAmJiAocyA9ICQyKHMsIGUuYmFzZVVybCkpLCBlLnZlcnNpb24gPT09IDEgPyBlbmNvZGVVUklDb21wb25lbnQocykgOiBzKSwgWGkgPSAocykgPT4gdm8ocyAvIDEwMCkgKiAxMDAsIEcyID0gKHMsIGUpID0+IHtcbiAgbGV0IHQgPSBzO1xuICByZXR1cm4gZS52ZXJzaW9uID49IDIgJiYgKHMgaW5zdGFuY2VvZiBKciAmJiB0eXBlb2Ygcy52YWx1ZSA9PSBcInN0cmluZ1wiID8gdCA9IG5ldyBKcihbc10pIDogdHlwZW9mIHMgPT0gXCJzdHJpbmdcIiAmJiAodCA9IFtzXSkpLCB4Yyh0LCBlKTtcbn0sIFYyID0ge1xuICAvKipcbiAgICogQml0cmF0ZSAoa2Jwcykgcm91bmRlZCBpbnRlZ2VyXG4gICAqL1xuICBicjogdm8sXG4gIC8qKlxuICAgKiBEdXJhdGlvbiAobWlsbGlzZWNvbmRzKSByb3VuZGVkIGludGVnZXJcbiAgICovXG4gIGQ6IHZvLFxuICAvKipcbiAgICogQnVmZmVyIExlbmd0aCAobWlsbGlzZWNvbmRzKSByb3VuZGVkIG5lYXJlc3QgMTAwbXNcbiAgICovXG4gIGJsOiBYaSxcbiAgLyoqXG4gICAqIERlYWRsaW5lIChtaWxsaXNlY29uZHMpIHJvdW5kZWQgbmVhcmVzdCAxMDBtc1xuICAgKi9cbiAgZGw6IFhpLFxuICAvKipcbiAgICogTWVhc3VyZWQgVGhyb3VnaHB1dCAoa2Jwcykgcm91bmRlZCBuZWFyZXN0IDEwMGticHNcbiAgICovXG4gIG10cDogWGksXG4gIC8qKlxuICAgKiBOZXh0IE9iamVjdCBSZXF1ZXN0IFVSTCBlbmNvZGVkXG4gICAqL1xuICBub3I6IEcyLFxuICAvKipcbiAgICogUmVxdWVzdGVkIG1heGltdW0gdGhyb3VnaHB1dCAoa2Jwcykgcm91bmRlZCBuZWFyZXN0IDEwMGticHNcbiAgICovXG4gIHJ0cDogWGksXG4gIC8qKlxuICAgKiBUb3AgQml0cmF0ZSAoa2Jwcykgcm91bmRlZCBpbnRlZ2VyXG4gICAqL1xuICB0Yjogdm9cbn0sIFBwID0gXCJyZXF1ZXN0XCIsIE1wID0gXCJyZXNwb25zZVwiLCBNdSA9IFtcImFiXCIsIFwiYmdcIiwgXCJibFwiLCBcImJyXCIsIFwiYnNcIiwgXCJic2RcIiwgXCJjZG5cIiwgXCJjaWRcIiwgXCJjc1wiLCBcImRmXCIsIFwiZWNcIiwgXCJsYWJcIiwgXCJsYlwiLCBcImx0Y1wiLCBcIm1zZFwiLCBcIm10cFwiLCBcInBiXCIsIFwicHJcIiwgXCJwdFwiLCBcInNmXCIsIFwic2lkXCIsIFwic25cIiwgXCJzdFwiLCBcInN0YVwiLCBcInRhYlwiLCBcInRiXCIsIFwidGJsXCIsIFwidHBiXCIsIFwidHNcIiwgXCJ2XCJdLCBqMiA9IFtcImVcIl0sIEsyID0gL15bYS16QS1aMC05LS5dKy1bYS16QS1aMC05LS5dKyQvO1xuZnVuY3Rpb24gRWEocykge1xuICByZXR1cm4gSzIudGVzdChzKTtcbn1cbmZ1bmN0aW9uIEgyKHMpIHtcbiAgcmV0dXJuIE11LmluY2x1ZGVzKHMpIHx8IGoyLmluY2x1ZGVzKHMpIHx8IEVhKHMpO1xufVxuY29uc3QgT3AgPSBbXCJkXCIsIFwiZGxcIiwgXCJub3JcIiwgXCJvdFwiLCBcInJ0cFwiLCBcInN1XCJdO1xuZnVuY3Rpb24gcTIocykge1xuICByZXR1cm4gTXUuaW5jbHVkZXMocykgfHwgT3AuaW5jbHVkZXMocykgfHwgRWEocyk7XG59XG5jb25zdCBXMiA9IFtcImNtc2RkXCIsIFwiY21zZHNcIiwgXCJyY1wiLCBcInNtcnRcIiwgXCJ0dGZiXCIsIFwidHRmYmJcIiwgXCJ0dGxiXCIsIFwidXJsXCJdO1xuZnVuY3Rpb24gejIocykge1xuICByZXR1cm4gTXUuaW5jbHVkZXMocykgfHwgT3AuaW5jbHVkZXMocykgfHwgVzIuaW5jbHVkZXMocykgfHwgRWEocyk7XG59XG5jb25zdCBZMiA9IFtcImJsXCIsIFwiYnJcIiwgXCJic1wiLCBcImNpZFwiLCBcImRcIiwgXCJkbFwiLCBcIm10cFwiLCBcIm5vclwiLCBcIm5yclwiLCBcIm90XCIsIFwicHJcIiwgXCJydHBcIiwgXCJzZlwiLCBcInNpZFwiLCBcInN0XCIsIFwic3VcIiwgXCJ0YlwiLCBcInZcIl07XG5mdW5jdGlvbiBaMihzKSB7XG4gIHJldHVybiBZMi5pbmNsdWRlcyhzKSB8fCBFYShzKTtcbn1cbmNvbnN0IFgyID0ge1xuICBbTXBdOiB6MixcbiAgW0RwXTogSDIsXG4gIFtQcF06IHEyXG59O1xuZnVuY3Rpb24gQnAocywgZSA9IHt9KSB7XG4gIGNvbnN0IHQgPSB7fTtcbiAgaWYgKHMgPT0gbnVsbCB8fCB0eXBlb2YgcyAhPSBcIm9iamVjdFwiKVxuICAgIHJldHVybiB0O1xuICBjb25zdCByID0gZS52ZXJzaW9uIHx8IHMudiB8fCAxLCBuID0gZS5yZXBvcnRpbmdNb2RlIHx8IFBwLCBpID0gciA9PT0gMSA/IFoyIDogWDJbbl07XG4gIGxldCBvID0gT2JqZWN0LmtleXMocykuZmlsdGVyKGkpO1xuICBjb25zdCBhID0gZS5maWx0ZXI7XG4gIHR5cGVvZiBhID09IFwiZnVuY3Rpb25cIiAmJiAobyA9IG8uZmlsdGVyKGEpKTtcbiAgY29uc3QgbCA9IG4gPT09IE1wIHx8IG4gPT09IERwO1xuICBsICYmICFvLmluY2x1ZGVzKFwidHNcIikgJiYgby5wdXNoKFwidHNcIiksIHIgPiAxICYmICFvLmluY2x1ZGVzKFwidlwiKSAmJiBvLnB1c2goXCJ2XCIpO1xuICBjb25zdCBjID0gbnQoe30sIFYyLCBlLmZvcm1hdHRlcnMpLCB1ID0ge1xuICAgIHZlcnNpb246IHIsXG4gICAgcmVwb3J0aW5nTW9kZTogbixcbiAgICBiYXNlVXJsOiBlLmJhc2VVcmxcbiAgfTtcbiAgcmV0dXJuIG8uc29ydCgpLmZvckVhY2goKGQpID0+IHtcbiAgICBsZXQgaCA9IHNbZF07XG4gICAgY29uc3QgZiA9IGNbZF07XG4gICAgaWYgKHR5cGVvZiBmID09IFwiZnVuY3Rpb25cIiAmJiAoaCA9IGYoaCwgdSkpLCBkID09PSBcInZcIikge1xuICAgICAgaWYgKHIgPT09IDEpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGggPSByO1xuICAgIH1cbiAgICBkID09IFwicHJcIiAmJiBoID09PSAxIHx8IChsICYmIGQgPT09IFwidHNcIiAmJiAhdWUoaCkgJiYgKGggPSBEYXRlLm5vdygpKSwgVTIoaCkgJiYgKE4yKGQpICYmIHR5cGVvZiBoID09IFwic3RyaW5nXCIgJiYgKGggPSBuZXcgX3AoaCkpLCB0W2RdID0gaCkpO1xuICB9KSwgdDtcbn1cbmZ1bmN0aW9uIEoyKHMsIGUgPSB7fSkge1xuICBjb25zdCB0ID0ge307XG4gIGlmICghcylcbiAgICByZXR1cm4gdDtcbiAgY29uc3QgciA9IEJwKHMsIGUpLCBuID0gRjIociwgZSA9PSBudWxsID8gdm9pZCAwIDogZS5jdXN0b21IZWFkZXJNYXApO1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMobikucmVkdWNlKChpLCBbbywgYV0pID0+IHtcbiAgICBjb25zdCBsID0ga3AoYSwge1xuICAgICAgd2hpdGVzcGFjZTogITFcbiAgICB9KTtcbiAgICByZXR1cm4gbCAmJiAoaVtvXSA9IGwpLCBpO1xuICB9LCB0KTtcbn1cbmZ1bmN0aW9uIFEyKHMsIGUsIHQpIHtcbiAgcmV0dXJuIG50KHMsIEoyKGUsIHQpKTtcbn1cbmNvbnN0IGV3ID0gXCJDTUNEXCI7XG5mdW5jdGlvbiB0dyhzLCBlID0ge30pIHtcbiAgcmV0dXJuIHMgPyBrcChCcChzLCBlKSwge1xuICAgIHdoaXRlc3BhY2U6ICExXG4gIH0pIDogXCJcIjtcbn1cbmZ1bmN0aW9uIHJ3KHMsIGUgPSB7fSkge1xuICBpZiAoIXMpXG4gICAgcmV0dXJuIFwiXCI7XG4gIGNvbnN0IHQgPSB0dyhzLCBlKTtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh0KTtcbn1cbmZ1bmN0aW9uIHN3KHMsIGUgPSB7fSkge1xuICBpZiAoIXMpXG4gICAgcmV0dXJuIFwiXCI7XG4gIGNvbnN0IHQgPSBydyhzLCBlKTtcbiAgcmV0dXJuIGAke2V3fT0ke3R9YDtcbn1cbmNvbnN0IHpoID0gL0NNQ0Q9W14mI10rLztcbmZ1bmN0aW9uIG53KHMsIGUsIHQpIHtcbiAgY29uc3QgciA9IHN3KGUsIHQpO1xuICBpZiAoIXIpXG4gICAgcmV0dXJuIHM7XG4gIGlmICh6aC50ZXN0KHMpKVxuICAgIHJldHVybiBzLnJlcGxhY2UoemgsIHIpO1xuICBjb25zdCBuID0gcy5pbmNsdWRlcyhcIj9cIikgPyBcIiZcIiA6IFwiP1wiO1xuICByZXR1cm4gYCR7c30ke259JHtyfWA7XG59XG5jbGFzcyBpdyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMCwgdGhpcy5jb25maWcgPSB2b2lkIDAsIHRoaXMubWVkaWEgPSB2b2lkIDAsIHRoaXMuc2lkID0gdm9pZCAwLCB0aGlzLmNpZCA9IHZvaWQgMCwgdGhpcy51c2VIZWFkZXJzID0gITEsIHRoaXMuaW5jbHVkZUtleXMgPSB2b2lkIDAsIHRoaXMuaW5pdGlhbGl6ZWQgPSAhMSwgdGhpcy5zdGFydmVkID0gITEsIHRoaXMuYnVmZmVyaW5nID0gITAsIHRoaXMuYXVkaW9CdWZmZXIgPSB2b2lkIDAsIHRoaXMudmlkZW9CdWZmZXIgPSB2b2lkIDAsIHRoaXMub25XYWl0aW5nID0gKCkgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCAmJiAodGhpcy5zdGFydmVkID0gITApLCB0aGlzLmJ1ZmZlcmluZyA9ICEwO1xuICAgIH0sIHRoaXMub25QbGF5aW5nID0gKCkgPT4ge1xuICAgICAgdGhpcy5pbml0aWFsaXplZCB8fCAodGhpcy5pbml0aWFsaXplZCA9ICEwKSwgdGhpcy5idWZmZXJpbmcgPSAhMTtcbiAgICB9LCB0aGlzLmFwcGx5UGxheWxpc3REYXRhID0gKG4pID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuYXBwbHkobiwge1xuICAgICAgICAgIG90OiBoci5NQU5JRkVTVCxcbiAgICAgICAgICBzdTogIXRoaXMuaW5pdGlhbGl6ZWRcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChpKSB7XG4gICAgICAgIHRoaXMuaGxzLmxvZ2dlci53YXJuKFwiQ291bGQgbm90IGdlbmVyYXRlIG1hbmlmZXN0IENNQ0QgZGF0YS5cIiwgaSk7XG4gICAgICB9XG4gICAgfSwgdGhpcy5hcHBseUZyYWdtZW50RGF0YSA9IChuKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgZnJhZzogaSxcbiAgICAgICAgICBwYXJ0OiBvXG4gICAgICAgIH0gPSBuLCBhID0gdGhpcy5obHMubGV2ZWxzW2kubGV2ZWxdLCBsID0gdGhpcy5nZXRPYmplY3RUeXBlKGkpLCBjID0ge1xuICAgICAgICAgIGQ6IChvIHx8IGkpLmR1cmF0aW9uICogMWUzLFxuICAgICAgICAgIG90OiBsXG4gICAgICAgIH07XG4gICAgICAgIChsID09PSBoci5WSURFTyB8fCBsID09PSBoci5BVURJTyB8fCBsID09IGhyLk1VWEVEKSAmJiAoYy5iciA9IGEuYml0cmF0ZSAvIDFlMywgYy50YiA9IHRoaXMuZ2V0VG9wQmFuZHdpZHRoKGwpIC8gMWUzLCBjLmJsID0gdGhpcy5nZXRCdWZmZXJMZW5ndGgobCkpO1xuICAgICAgICBjb25zdCB1ID0gbyA/IHRoaXMuZ2V0TmV4dFBhcnQobykgOiB0aGlzLmdldE5leHRGcmFnKGkpO1xuICAgICAgICB1ICE9IG51bGwgJiYgdS51cmwgJiYgdS51cmwgIT09IGkudXJsICYmIChjLm5vciA9IHUudXJsKSwgdGhpcy5hcHBseShuLCBjKTtcbiAgICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgICAgdGhpcy5obHMubG9nZ2VyLndhcm4oXCJDb3VsZCBub3QgZ2VuZXJhdGUgc2VnbWVudCBDTUNEIGRhdGEuXCIsIGkpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuaGxzID0gZTtcbiAgICBjb25zdCB0ID0gdGhpcy5jb25maWcgPSBlLmNvbmZpZywge1xuICAgICAgY21jZDogclxuICAgIH0gPSB0O1xuICAgIHIgIT0gbnVsbCAmJiAodC5wTG9hZGVyID0gdGhpcy5jcmVhdGVQbGF5bGlzdExvYWRlcigpLCB0LmZMb2FkZXIgPSB0aGlzLmNyZWF0ZUZyYWdtZW50TG9hZGVyKCksIHRoaXMuc2lkID0gci5zZXNzaW9uSWQgfHwgZS5zZXNzaW9uSWQsIHRoaXMuY2lkID0gci5jb250ZW50SWQsIHRoaXMudXNlSGVhZGVycyA9IHIudXNlSGVhZGVycyA9PT0gITAsIHRoaXMuaW5jbHVkZUtleXMgPSByLmluY2x1ZGVLZXlzLCB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCkpO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmhscztcbiAgICBlLm9uKEkuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKSwgZS5vbihJLk1FRElBX0RFVEFDSEVELCB0aGlzLm9uTWVkaWFEZXRhY2hlZCwgdGhpcyksIGUub24oSS5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuaGxzO1xuICAgIGUub2ZmKEkuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKSwgZS5vZmYoSS5NRURJQV9ERVRBQ0hFRCwgdGhpcy5vbk1lZGlhRGV0YWNoZWQsIHRoaXMpLCBlLm9mZihJLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKSwgdGhpcy5vbk1lZGlhRGV0YWNoZWQoKSwgdGhpcy5obHMgPSB0aGlzLmNvbmZpZyA9IHRoaXMuYXVkaW9CdWZmZXIgPSB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbCwgdGhpcy5vbldhaXRpbmcgPSB0aGlzLm9uUGxheWluZyA9IHRoaXMubWVkaWEgPSBudWxsO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hlZChlLCB0KSB7XG4gICAgdGhpcy5tZWRpYSA9IHQubWVkaWEsIHRoaXMubWVkaWEuYWRkRXZlbnRMaXN0ZW5lcihcIndhaXRpbmdcIiwgdGhpcy5vbldhaXRpbmcpLCB0aGlzLm1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoXCJwbGF5aW5nXCIsIHRoaXMub25QbGF5aW5nKTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoZWQoKSB7XG4gICAgdGhpcy5tZWRpYSAmJiAodGhpcy5tZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKFwid2FpdGluZ1wiLCB0aGlzLm9uV2FpdGluZyksIHRoaXMubWVkaWEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBsYXlpbmdcIiwgdGhpcy5vblBsYXlpbmcpLCB0aGlzLm1lZGlhID0gbnVsbCk7XG4gIH1cbiAgb25CdWZmZXJDcmVhdGVkKGUsIHQpIHtcbiAgICB2YXIgciwgbjtcbiAgICB0aGlzLmF1ZGlvQnVmZmVyID0gKHIgPSB0LnRyYWNrcy5hdWRpbykgPT0gbnVsbCA/IHZvaWQgMCA6IHIuYnVmZmVyLCB0aGlzLnZpZGVvQnVmZmVyID0gKG4gPSB0LnRyYWNrcy52aWRlbykgPT0gbnVsbCA/IHZvaWQgMCA6IG4uYnVmZmVyO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYmFzZWxpbmUgQ01DRCBkYXRhXG4gICAqL1xuICBjcmVhdGVEYXRhKCkge1xuICAgIHZhciBlO1xuICAgIHJldHVybiB7XG4gICAgICB2OiAxLFxuICAgICAgc2Y6IGgyLkhMUyxcbiAgICAgIHNpZDogdGhpcy5zaWQsXG4gICAgICBjaWQ6IHRoaXMuY2lkLFxuICAgICAgcHI6IChlID0gdGhpcy5tZWRpYSkgPT0gbnVsbCA/IHZvaWQgMCA6IGUucGxheWJhY2tSYXRlLFxuICAgICAgbXRwOiB0aGlzLmhscy5iYW5kd2lkdGhFc3RpbWF0ZSAvIDFlM1xuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIEFwcGx5IENNQ0QgZGF0YSB0byBhIHJlcXVlc3QuXG4gICAqL1xuICBhcHBseShlLCB0ID0ge30pIHtcbiAgICBudCh0LCB0aGlzLmNyZWF0ZURhdGEoKSk7XG4gICAgY29uc3QgciA9IHQub3QgPT09IGhyLklOSVQgfHwgdC5vdCA9PT0gaHIuVklERU8gfHwgdC5vdCA9PT0gaHIuTVVYRUQ7XG4gICAgdGhpcy5zdGFydmVkICYmIHIgJiYgKHQuYnMgPSAhMCwgdC5zdSA9ICEwLCB0aGlzLnN0YXJ2ZWQgPSAhMSksIHQuc3UgPT0gbnVsbCAmJiAodC5zdSA9IHRoaXMuYnVmZmVyaW5nKTtcbiAgICBjb25zdCB7XG4gICAgICBpbmNsdWRlS2V5czogblxuICAgIH0gPSB0aGlzO1xuICAgIG4gJiYgKHQgPSBPYmplY3Qua2V5cyh0KS5yZWR1Y2UoKG8sIGEpID0+IChuLmluY2x1ZGVzKGEpICYmIChvW2FdID0gdFthXSksIG8pLCB7fSkpO1xuICAgIGNvbnN0IGkgPSB7XG4gICAgICBiYXNlVXJsOiBlLnVybFxuICAgIH07XG4gICAgdGhpcy51c2VIZWFkZXJzID8gKGUuaGVhZGVycyB8fCAoZS5oZWFkZXJzID0ge30pLCBRMihlLmhlYWRlcnMsIHQsIGkpKSA6IGUudXJsID0gbncoZS51cmwsIHQsIGkpO1xuICB9XG4gIGdldE5leHRGcmFnKGUpIHtcbiAgICB2YXIgdDtcbiAgICBjb25zdCByID0gKHQgPSB0aGlzLmhscy5sZXZlbHNbZS5sZXZlbF0pID09IG51bGwgPyB2b2lkIDAgOiB0LmRldGFpbHM7XG4gICAgaWYgKHIpIHtcbiAgICAgIGNvbnN0IG4gPSBlLnNuIC0gci5zdGFydFNOO1xuICAgICAgcmV0dXJuIHIuZnJhZ21lbnRzW24gKyAxXTtcbiAgICB9XG4gIH1cbiAgZ2V0TmV4dFBhcnQoZSkge1xuICAgIHZhciB0O1xuICAgIGNvbnN0IHtcbiAgICAgIGluZGV4OiByLFxuICAgICAgZnJhZ21lbnQ6IG5cbiAgICB9ID0gZSwgaSA9ICh0ID0gdGhpcy5obHMubGV2ZWxzW24ubGV2ZWxdKSA9PSBudWxsIHx8ICh0ID0gdC5kZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogdC5wYXJ0TGlzdDtcbiAgICBpZiAoaSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzbjogb1xuICAgICAgfSA9IG47XG4gICAgICBmb3IgKGxldCBhID0gaS5sZW5ndGggLSAxOyBhID49IDA7IGEtLSkge1xuICAgICAgICBjb25zdCBsID0gaVthXTtcbiAgICAgICAgaWYgKGwuaW5kZXggPT09IHIgJiYgbC5mcmFnbWVudC5zbiA9PT0gbylcbiAgICAgICAgICByZXR1cm4gaVthICsgMV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGUgQ01DRCBvYmplY3QgdHlwZS5cbiAgICovXG4gIGdldE9iamVjdFR5cGUoZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHR5cGU6IHRcbiAgICB9ID0gZTtcbiAgICBpZiAodCA9PT0gXCJzdWJ0aXRsZVwiKVxuICAgICAgcmV0dXJuIGhyLlRJTUVEX1RFWFQ7XG4gICAgaWYgKGUuc24gPT09IFwiaW5pdFNlZ21lbnRcIilcbiAgICAgIHJldHVybiBoci5JTklUO1xuICAgIGlmICh0ID09PSBcImF1ZGlvXCIpXG4gICAgICByZXR1cm4gaHIuQVVESU87XG4gICAgaWYgKHQgPT09IFwibWFpblwiKVxuICAgICAgcmV0dXJuIHRoaXMuaGxzLmF1ZGlvVHJhY2tzLmxlbmd0aCA/IGhyLlZJREVPIDogaHIuTVVYRUQ7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgaGlnaGVzdCBiaXRyYXRlLlxuICAgKi9cbiAgZ2V0VG9wQmFuZHdpZHRoKGUpIHtcbiAgICBsZXQgdCA9IDAsIHI7XG4gICAgY29uc3QgbiA9IHRoaXMuaGxzO1xuICAgIGlmIChlID09PSBoci5BVURJTylcbiAgICAgIHIgPSBuLmF1ZGlvVHJhY2tzO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgaSA9IG4ubWF4QXV0b0xldmVsLCBvID0gaSA+IC0xID8gaSArIDEgOiBuLmxldmVscy5sZW5ndGg7XG4gICAgICByID0gbi5sZXZlbHMuc2xpY2UoMCwgbyk7XG4gICAgfVxuICAgIHJldHVybiByLmZvckVhY2goKGkpID0+IHtcbiAgICAgIGkuYml0cmF0ZSA+IHQgJiYgKHQgPSBpLmJpdHJhdGUpO1xuICAgIH0pLCB0ID4gMCA/IHQgOiBOYU47XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgYnVmZmVyIGxlbmd0aCBmb3IgYSBtZWRpYSB0eXBlIGluIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgZ2V0QnVmZmVyTGVuZ3RoKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5tZWRpYSwgciA9IGUgPT09IGhyLkFVRElPID8gdGhpcy5hdWRpb0J1ZmZlciA6IHRoaXMudmlkZW9CdWZmZXI7XG4gICAgcmV0dXJuICFyIHx8ICF0ID8gTmFOIDogQ2UuYnVmZmVySW5mbyhyLCB0LmN1cnJlbnRUaW1lLCB0aGlzLmNvbmZpZy5tYXhCdWZmZXJIb2xlKS5sZW4gKiAxZTM7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHBsYXlsaXN0IGxvYWRlclxuICAgKi9cbiAgY3JlYXRlUGxheWxpc3RMb2FkZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcExvYWRlcjogZVxuICAgIH0gPSB0aGlzLmNvbmZpZywgdCA9IHRoaXMuYXBwbHlQbGF5bGlzdERhdGEsIHIgPSBlIHx8IHRoaXMuY29uZmlnLmxvYWRlcjtcbiAgICByZXR1cm4gY2xhc3Mge1xuICAgICAgY29uc3RydWN0b3IoaSkge1xuICAgICAgICB0aGlzLmxvYWRlciA9IHZvaWQgMCwgdGhpcy5sb2FkZXIgPSBuZXcgcihpKTtcbiAgICAgIH1cbiAgICAgIGdldCBzdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9hZGVyLnN0YXRzO1xuICAgICAgfVxuICAgICAgZ2V0IGNvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRlci5jb250ZXh0O1xuICAgICAgfVxuICAgICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgYWJvcnQoKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmFib3J0KCk7XG4gICAgICB9XG4gICAgICBsb2FkKGksIG8sIGEpIHtcbiAgICAgICAgdChpKSwgdGhpcy5sb2FkZXIubG9hZChpLCBvLCBhKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBwbGF5bGlzdCBsb2FkZXJcbiAgICovXG4gIGNyZWF0ZUZyYWdtZW50TG9hZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZMb2FkZXI6IGVcbiAgICB9ID0gdGhpcy5jb25maWcsIHQgPSB0aGlzLmFwcGx5RnJhZ21lbnREYXRhLCByID0gZSB8fCB0aGlzLmNvbmZpZy5sb2FkZXI7XG4gICAgcmV0dXJuIGNsYXNzIHtcbiAgICAgIGNvbnN0cnVjdG9yKGkpIHtcbiAgICAgICAgdGhpcy5sb2FkZXIgPSB2b2lkIDAsIHRoaXMubG9hZGVyID0gbmV3IHIoaSk7XG4gICAgICB9XG4gICAgICBnZXQgc3RhdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRlci5zdGF0cztcbiAgICAgIH1cbiAgICAgIGdldCBjb250ZXh0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2FkZXIuY29udGV4dDtcbiAgICAgIH1cbiAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMubG9hZGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIGFib3J0KCkge1xuICAgICAgICB0aGlzLmxvYWRlci5hYm9ydCgpO1xuICAgICAgfVxuICAgICAgbG9hZChpLCBvLCBhKSB7XG4gICAgICAgIHQoaSksIHRoaXMubG9hZGVyLmxvYWQoaSwgbywgYSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuY29uc3Qgb3cgPSAzZTU7XG5jbGFzcyBhdyBleHRlbmRzIExyIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKFwiY29udGVudC1zdGVlcmluZ1wiLCBlLmxvZ2dlciksIHRoaXMuaGxzID0gdm9pZCAwLCB0aGlzLmxvYWRlciA9IG51bGwsIHRoaXMudXJpID0gbnVsbCwgdGhpcy5wYXRod2F5SWQgPSBcIi5cIiwgdGhpcy5fcGF0aHdheVByaW9yaXR5ID0gbnVsbCwgdGhpcy50aW1lVG9Mb2FkID0gMzAwLCB0aGlzLnJlbG9hZFRpbWVyID0gLTEsIHRoaXMudXBkYXRlZCA9IDAsIHRoaXMuc3RhcnRlZCA9ICExLCB0aGlzLmVuYWJsZWQgPSAhMCwgdGhpcy5sZXZlbHMgPSBudWxsLCB0aGlzLmF1ZGlvVHJhY2tzID0gbnVsbCwgdGhpcy5zdWJ0aXRsZVRyYWNrcyA9IG51bGwsIHRoaXMucGVuYWxpemVkUGF0aHdheXMgPSB7fSwgdGhpcy5obHMgPSBlLCB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuaGxzO1xuICAgIGUub24oSS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKSwgZS5vbihJLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKSwgZS5vbihJLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKSwgZS5vbihJLkVSUk9SLCB0aGlzLm9uRXJyb3IsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuaGxzO1xuICAgIGUgJiYgKGUub2ZmKEkuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyksIGUub2ZmKEkuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpLCBlLm9mZihJLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKSwgZS5vZmYoSS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKSk7XG4gIH1cbiAgcGF0aHdheXMoKSB7XG4gICAgcmV0dXJuICh0aGlzLmxldmVscyB8fCBbXSkucmVkdWNlKChlLCB0KSA9PiAoZS5pbmRleE9mKHQucGF0aHdheUlkKSA9PT0gLTEgJiYgZS5wdXNoKHQucGF0aHdheUlkKSwgZSksIFtdKTtcbiAgfVxuICBnZXQgcGF0aHdheVByaW9yaXR5KCkge1xuICAgIHJldHVybiB0aGlzLl9wYXRod2F5UHJpb3JpdHk7XG4gIH1cbiAgc2V0IHBhdGh3YXlQcmlvcml0eShlKSB7XG4gICAgdGhpcy51cGRhdGVQYXRod2F5UHJpb3JpdHkoZSk7XG4gIH1cbiAgc3RhcnRMb2FkKCkge1xuICAgIGlmICh0aGlzLnN0YXJ0ZWQgPSAhMCwgdGhpcy5jbGVhclRpbWVvdXQoKSwgdGhpcy5lbmFibGVkICYmIHRoaXMudXJpKSB7XG4gICAgICBpZiAodGhpcy51cGRhdGVkKSB7XG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLnRpbWVUb0xvYWQgKiAxZTMgLSAocGVyZm9ybWFuY2Uubm93KCkgLSB0aGlzLnVwZGF0ZWQpO1xuICAgICAgICBpZiAoZSA+IDApIHtcbiAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVmcmVzaCh0aGlzLnVyaSwgZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxvYWRTdGVlcmluZ01hbmlmZXN0KHRoaXMudXJpKTtcbiAgICB9XG4gIH1cbiAgc3RvcExvYWQoKSB7XG4gICAgdGhpcy5zdGFydGVkID0gITEsIHRoaXMubG9hZGVyICYmICh0aGlzLmxvYWRlci5kZXN0cm95KCksIHRoaXMubG9hZGVyID0gbnVsbCksIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gIH1cbiAgY2xlYXJUaW1lb3V0KCkge1xuICAgIHRoaXMucmVsb2FkVGltZXIgIT09IC0xICYmIChzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlbG9hZFRpbWVyKSwgdGhpcy5yZWxvYWRUaW1lciA9IC0xKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpLCB0aGlzLnN0b3BMb2FkKCksIHRoaXMuaGxzID0gbnVsbCwgdGhpcy5sZXZlbHMgPSB0aGlzLmF1ZGlvVHJhY2tzID0gdGhpcy5zdWJ0aXRsZVRyYWNrcyA9IG51bGw7XG4gIH1cbiAgcmVtb3ZlTGV2ZWwoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmxldmVscztcbiAgICB0ICYmICh0aGlzLmxldmVscyA9IHQuZmlsdGVyKChyKSA9PiByICE9PSBlKSk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy5zdG9wTG9hZCgpLCB0aGlzLmVuYWJsZWQgPSAhMCwgdGhpcy50aW1lVG9Mb2FkID0gMzAwLCB0aGlzLnVwZGF0ZWQgPSAwLCB0aGlzLnVyaSA9IG51bGwsIHRoaXMucGF0aHdheUlkID0gXCIuXCIsIHRoaXMubGV2ZWxzID0gdGhpcy5hdWRpb1RyYWNrcyA9IHRoaXMuc3VidGl0bGVUcmFja3MgPSBudWxsO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkZWQoZSwgdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRlbnRTdGVlcmluZzogclxuICAgIH0gPSB0O1xuICAgIHIgIT09IG51bGwgJiYgKHRoaXMucGF0aHdheUlkID0gci5wYXRod2F5SWQsIHRoaXMudXJpID0gci51cmksIHRoaXMuc3RhcnRlZCAmJiB0aGlzLnN0YXJ0TG9hZCgpKTtcbiAgfVxuICBvbk1hbmlmZXN0UGFyc2VkKGUsIHQpIHtcbiAgICB0aGlzLmF1ZGlvVHJhY2tzID0gdC5hdWRpb1RyYWNrcywgdGhpcy5zdWJ0aXRsZVRyYWNrcyA9IHQuc3VidGl0bGVUcmFja3M7XG4gIH1cbiAgb25FcnJvcihlLCB0KSB7XG4gICAgY29uc3Qge1xuICAgICAgZXJyb3JBY3Rpb246IHJcbiAgICB9ID0gdDtcbiAgICBpZiAoKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuYWN0aW9uKSA9PT0gWnQuU2VuZEFsdGVybmF0ZVRvUGVuYWx0eUJveCAmJiByLmZsYWdzID09PSB2ci5Nb3ZlQWxsQWx0ZXJuYXRlc01hdGNoaW5nSG9zdCkge1xuICAgICAgY29uc3QgbiA9IHRoaXMubGV2ZWxzO1xuICAgICAgbGV0IGkgPSB0aGlzLl9wYXRod2F5UHJpb3JpdHksIG8gPSB0aGlzLnBhdGh3YXlJZDtcbiAgICAgIGlmICh0LmNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGdyb3VwSWQ6IGEsXG4gICAgICAgICAgcGF0aHdheUlkOiBsLFxuICAgICAgICAgIHR5cGU6IGNcbiAgICAgICAgfSA9IHQuY29udGV4dDtcbiAgICAgICAgYSAmJiBuID8gbyA9IHRoaXMuZ2V0UGF0aHdheUZvckdyb3VwSWQoYSwgYywgbykgOiBsICYmIChvID0gbCk7XG4gICAgICB9XG4gICAgICBvIGluIHRoaXMucGVuYWxpemVkUGF0aHdheXMgfHwgKHRoaXMucGVuYWxpemVkUGF0aHdheXNbb10gPSBwZXJmb3JtYW5jZS5ub3coKSksICFpICYmIG4gJiYgKGkgPSB0aGlzLnBhdGh3YXlzKCkpLCBpICYmIGkubGVuZ3RoID4gMSAmJiAodGhpcy51cGRhdGVQYXRod2F5UHJpb3JpdHkoaSksIHIucmVzb2x2ZWQgPSB0aGlzLnBhdGh3YXlJZCAhPT0gbyksIHQuZGV0YWlscyA9PT0gSi5CVUZGRVJfQVBQRU5EX0VSUk9SICYmICF0LmZhdGFsID8gci5yZXNvbHZlZCA9ICEwIDogci5yZXNvbHZlZCB8fCB0aGlzLndhcm4oYENvdWxkIG5vdCByZXNvbHZlICR7dC5kZXRhaWxzfSAoXCIke3QuZXJyb3IubWVzc2FnZX1cIikgd2l0aCBjb250ZW50LXN0ZWVyaW5nIGZvciBQYXRod2F5OiAke299IGxldmVsczogJHtuICYmIG4ubGVuZ3RofSBwcmlvcml0aWVzOiAke2F0KGkpfSBwZW5hbGl6ZWQ6ICR7YXQodGhpcy5wZW5hbGl6ZWRQYXRod2F5cyl9YCk7XG4gICAgfVxuICB9XG4gIGZpbHRlclBhcnNlZExldmVscyhlKSB7XG4gICAgdGhpcy5sZXZlbHMgPSBlO1xuICAgIGxldCB0ID0gdGhpcy5nZXRMZXZlbHNGb3JQYXRod2F5KHRoaXMucGF0aHdheUlkKTtcbiAgICBpZiAodC5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnN0IHIgPSBlWzBdLnBhdGh3YXlJZDtcbiAgICAgIHRoaXMubG9nKGBObyBsZXZlbHMgZm91bmQgaW4gUGF0aHdheSAke3RoaXMucGF0aHdheUlkfS4gU2V0dGluZyBpbml0aWFsIFBhdGh3YXkgdG8gXCIke3J9XCJgKSwgdCA9IHRoaXMuZ2V0TGV2ZWxzRm9yUGF0aHdheShyKSwgdGhpcy5wYXRod2F5SWQgPSByO1xuICAgIH1cbiAgICByZXR1cm4gdC5sZW5ndGggIT09IGUubGVuZ3RoICYmIHRoaXMubG9nKGBGb3VuZCAke3QubGVuZ3RofS8ke2UubGVuZ3RofSBsZXZlbHMgaW4gUGF0aHdheSBcIiR7dGhpcy5wYXRod2F5SWR9XCJgKSwgdDtcbiAgfVxuICBnZXRMZXZlbHNGb3JQYXRod2F5KGUpIHtcbiAgICByZXR1cm4gdGhpcy5sZXZlbHMgPT09IG51bGwgPyBbXSA6IHRoaXMubGV2ZWxzLmZpbHRlcigodCkgPT4gZSA9PT0gdC5wYXRod2F5SWQpO1xuICB9XG4gIHVwZGF0ZVBhdGh3YXlQcmlvcml0eShlKSB7XG4gICAgdGhpcy5fcGF0aHdheVByaW9yaXR5ID0gZTtcbiAgICBsZXQgdDtcbiAgICBjb25zdCByID0gdGhpcy5wZW5hbGl6ZWRQYXRod2F5cywgbiA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIE9iamVjdC5rZXlzKHIpLmZvckVhY2goKGkpID0+IHtcbiAgICAgIG4gLSByW2ldID4gb3cgJiYgZGVsZXRlIHJbaV07XG4gICAgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBvID0gZVtpXTtcbiAgICAgIGlmIChvIGluIHIpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgaWYgKG8gPT09IHRoaXMucGF0aHdheUlkKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBhID0gdGhpcy5obHMubmV4dExvYWRMZXZlbCwgbCA9IHRoaXMuaGxzLmxldmVsc1thXTtcbiAgICAgIGlmICh0ID0gdGhpcy5nZXRMZXZlbHNGb3JQYXRod2F5KG8pLCB0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5sb2coYFNldHRpbmcgUGF0aHdheSB0byBcIiR7b31cImApLCB0aGlzLnBhdGh3YXlJZCA9IG8sIHJwKHQpLCB0aGlzLmhscy50cmlnZ2VyKEkuTEVWRUxTX1VQREFURUQsIHtcbiAgICAgICAgICBsZXZlbHM6IHRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmhscy5sZXZlbHNbYV07XG4gICAgICAgIGwgJiYgYyAmJiB0aGlzLmxldmVscyAmJiAoYy5hdHRyc1tcIlNUQUJMRS1WQVJJQU5ULUlEXCJdICE9PSBsLmF0dHJzW1wiU1RBQkxFLVZBUklBTlQtSURcIl0gJiYgYy5iaXRyYXRlICE9PSBsLmJpdHJhdGUgJiYgdGhpcy5sb2coYFVuc3RhYmxlIFBhdGh3YXlzIGNoYW5nZSBmcm9tIGJpdHJhdGUgJHtsLmJpdHJhdGV9IHRvICR7Yy5iaXRyYXRlfWApLCB0aGlzLmhscy5uZXh0TG9hZExldmVsID0gYSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRQYXRod2F5Rm9yR3JvdXBJZChlLCB0LCByKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZ2V0TGV2ZWxzRm9yUGF0aHdheShyKS5jb25jYXQodGhpcy5sZXZlbHMgfHwgW10pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbi5sZW5ndGg7IGkrKylcbiAgICAgIGlmICh0ID09PSBLZS5BVURJT19UUkFDSyAmJiBuW2ldLmhhc0F1ZGlvR3JvdXAoZSkgfHwgdCA9PT0gS2UuU1VCVElUTEVfVFJBQ0sgJiYgbltpXS5oYXNTdWJ0aXRsZUdyb3VwKGUpKVxuICAgICAgICByZXR1cm4gbltpXS5wYXRod2F5SWQ7XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgY2xvbmVQYXRod2F5cyhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubGV2ZWxzO1xuICAgIGlmICghdClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByID0ge30sIG4gPSB7fTtcbiAgICBlLmZvckVhY2goKGkpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgSUQ6IG8sXG4gICAgICAgIFwiQkFTRS1JRFwiOiBhLFxuICAgICAgICBcIlVSSS1SRVBMQUNFTUVOVFwiOiBsXG4gICAgICB9ID0gaTtcbiAgICAgIGlmICh0LnNvbWUoKHUpID0+IHUucGF0aHdheUlkID09PSBvKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgYyA9IHRoaXMuZ2V0TGV2ZWxzRm9yUGF0aHdheShhKS5tYXAoKHUpID0+IHtcbiAgICAgICAgY29uc3QgZCA9IG5ldyBndCh1LmF0dHJzKTtcbiAgICAgICAgZFtcIlBBVEhXQVktSURcIl0gPSBvO1xuICAgICAgICBjb25zdCBoID0gZC5BVURJTyAmJiBgJHtkLkFVRElPfV9jbG9uZV8ke299YCwgZiA9IGQuU1VCVElUTEVTICYmIGAke2QuU1VCVElUTEVTfV9jbG9uZV8ke299YDtcbiAgICAgICAgaCAmJiAocltkLkFVRElPXSA9IGgsIGQuQVVESU8gPSBoKSwgZiAmJiAobltkLlNVQlRJVExFU10gPSBmLCBkLlNVQlRJVExFUyA9IGYpO1xuICAgICAgICBjb25zdCBwID0gRnAodS51cmksIGRbXCJTVEFCTEUtVkFSSUFOVC1JRFwiXSwgXCJQRVItVkFSSUFOVC1VUklTXCIsIGwpLCB5ID0gbmV3IG1pKHtcbiAgICAgICAgICBhdHRyczogZCxcbiAgICAgICAgICBhdWRpb0NvZGVjOiB1LmF1ZGlvQ29kZWMsXG4gICAgICAgICAgYml0cmF0ZTogdS5iaXRyYXRlLFxuICAgICAgICAgIGhlaWdodDogdS5oZWlnaHQsXG4gICAgICAgICAgbmFtZTogdS5uYW1lLFxuICAgICAgICAgIHVybDogcCxcbiAgICAgICAgICB2aWRlb0NvZGVjOiB1LnZpZGVvQ29kZWMsXG4gICAgICAgICAgd2lkdGg6IHUud2lkdGhcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh1LmF1ZGlvR3JvdXBzKVxuICAgICAgICAgIGZvciAobGV0IEUgPSAxOyBFIDwgdS5hdWRpb0dyb3Vwcy5sZW5ndGg7IEUrKylcbiAgICAgICAgICAgIHkuYWRkR3JvdXBJZChcImF1ZGlvXCIsIGAke3UuYXVkaW9Hcm91cHNbRV19X2Nsb25lXyR7b31gKTtcbiAgICAgICAgaWYgKHUuc3VidGl0bGVHcm91cHMpXG4gICAgICAgICAgZm9yIChsZXQgRSA9IDE7IEUgPCB1LnN1YnRpdGxlR3JvdXBzLmxlbmd0aDsgRSsrKVxuICAgICAgICAgICAgeS5hZGRHcm91cElkKFwidGV4dFwiLCBgJHt1LnN1YnRpdGxlR3JvdXBzW0VdfV9jbG9uZV8ke299YCk7XG4gICAgICAgIHJldHVybiB5O1xuICAgICAgfSk7XG4gICAgICB0LnB1c2goLi4uYyksIFloKHRoaXMuYXVkaW9UcmFja3MsIHIsIGwsIG8pLCBZaCh0aGlzLnN1YnRpdGxlVHJhY2tzLCBuLCBsLCBvKTtcbiAgICB9KTtcbiAgfVxuICBsb2FkU3RlZXJpbmdNYW5pZmVzdChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuaGxzLmNvbmZpZywgciA9IHQubG9hZGVyO1xuICAgIHRoaXMubG9hZGVyICYmIHRoaXMubG9hZGVyLmRlc3Ryb3koKSwgdGhpcy5sb2FkZXIgPSBuZXcgcih0KTtcbiAgICBsZXQgbjtcbiAgICB0cnkge1xuICAgICAgbiA9IG5ldyBzZWxmLlVSTChlKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9ICExLCB0aGlzLmxvZyhgRmFpbGVkIHRvIHBhcnNlIFN0ZWVyaW5nIE1hbmlmZXN0IFVSSTogJHtlfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobi5wcm90b2NvbCAhPT0gXCJkYXRhOlwiKSB7XG4gICAgICBjb25zdCB1ID0gKHRoaXMuaGxzLmJhbmR3aWR0aEVzdGltYXRlIHx8IHQuYWJyRXdtYURlZmF1bHRFc3RpbWF0ZSkgfCAwO1xuICAgICAgbi5zZWFyY2hQYXJhbXMuc2V0KFwiX0hMU19wYXRod2F5XCIsIHRoaXMucGF0aHdheUlkKSwgbi5zZWFyY2hQYXJhbXMuc2V0KFwiX0hMU190aHJvdWdocHV0XCIsIFwiXCIgKyB1KTtcbiAgICB9XG4gICAgY29uc3QgaSA9IHtcbiAgICAgIHJlc3BvbnNlVHlwZTogXCJqc29uXCIsXG4gICAgICB1cmw6IG4uaHJlZlxuICAgIH0sIG8gPSB0LnN0ZWVyaW5nTWFuaWZlc3RMb2FkUG9saWN5LmRlZmF1bHQsIGEgPSBvLmVycm9yUmV0cnkgfHwgby50aW1lb3V0UmV0cnkgfHwge30sIGwgPSB7XG4gICAgICBsb2FkUG9saWN5OiBvLFxuICAgICAgdGltZW91dDogby5tYXhMb2FkVGltZU1zLFxuICAgICAgbWF4UmV0cnk6IGEubWF4TnVtUmV0cnkgfHwgMCxcbiAgICAgIHJldHJ5RGVsYXk6IGEucmV0cnlEZWxheU1zIHx8IDAsXG4gICAgICBtYXhSZXRyeURlbGF5OiBhLm1heFJldHJ5RGVsYXlNcyB8fCAwXG4gICAgfSwgYyA9IHtcbiAgICAgIG9uU3VjY2VzczogKHUsIGQsIGgsIGYpID0+IHtcbiAgICAgICAgdGhpcy5sb2coYExvYWRlZCBzdGVlcmluZyBtYW5pZmVzdDogXCIke259XCJgKTtcbiAgICAgICAgY29uc3QgcCA9IHUuZGF0YTtcbiAgICAgICAgaWYgKChwID09IG51bGwgPyB2b2lkIDAgOiBwLlZFUlNJT04pICE9PSAxKSB7XG4gICAgICAgICAgdGhpcy5sb2coYFN0ZWVyaW5nIFZFUlNJT04gJHtwLlZFUlNJT059IG5vdCBzdXBwb3J0ZWQhYCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlZCA9IHBlcmZvcm1hbmNlLm5vdygpLCB0aGlzLnRpbWVUb0xvYWQgPSBwLlRUTDtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIFwiUkVMT0FELVVSSVwiOiB5LFxuICAgICAgICAgIFwiUEFUSFdBWS1DTE9ORVNcIjogRSxcbiAgICAgICAgICBcIlBBVEhXQVktUFJJT1JJVFlcIjogYlxuICAgICAgICB9ID0gcDtcbiAgICAgICAgaWYgKHkpXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudXJpID0gbmV3IHNlbGYuVVJMKHksIG4pLmhyZWY7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZWQgPSAhMSwgdGhpcy5sb2coYEZhaWxlZCB0byBwYXJzZSBTdGVlcmluZyBNYW5pZmVzdCBSRUxPQUQtVVJJOiAke3l9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB0aGlzLnNjaGVkdWxlUmVmcmVzaCh0aGlzLnVyaSB8fCBoLnVybCksIEUgJiYgdGhpcy5jbG9uZVBhdGh3YXlzKEUpO1xuICAgICAgICBjb25zdCBSID0ge1xuICAgICAgICAgIHN0ZWVyaW5nTWFuaWZlc3Q6IHAsXG4gICAgICAgICAgdXJsOiBuLnRvU3RyaW5nKClcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihJLlNURUVSSU5HX01BTklGRVNUX0xPQURFRCwgUiksIGIgJiYgdGhpcy51cGRhdGVQYXRod2F5UHJpb3JpdHkoYik7XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogKHUsIGQsIGgsIGYpID0+IHtcbiAgICAgICAgaWYgKHRoaXMubG9nKGBFcnJvciBsb2FkaW5nIHN0ZWVyaW5nIG1hbmlmZXN0OiAke3UuY29kZX0gJHt1LnRleHR9ICgke2QudXJsfSlgKSwgdGhpcy5zdG9wTG9hZCgpLCB1LmNvZGUgPT09IDQxMCkge1xuICAgICAgICAgIHRoaXMuZW5hYmxlZCA9ICExLCB0aGlzLmxvZyhgU3RlZXJpbmcgbWFuaWZlc3QgJHtkLnVybH0gbm8gbG9uZ2VyIGF2YWlsYWJsZWApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcCA9IHRoaXMudGltZVRvTG9hZCAqIDFlMztcbiAgICAgICAgaWYgKHUuY29kZSA9PT0gNDI5KSB7XG4gICAgICAgICAgY29uc3QgeSA9IHRoaXMubG9hZGVyO1xuICAgICAgICAgIGlmICh0eXBlb2YgKHkgPT0gbnVsbCA/IHZvaWQgMCA6IHkuZ2V0UmVzcG9uc2VIZWFkZXIpID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgRSA9IHkuZ2V0UmVzcG9uc2VIZWFkZXIoXCJSZXRyeS1BZnRlclwiKTtcbiAgICAgICAgICAgIEUgJiYgKHAgPSBwYXJzZUZsb2F0KEUpICogMWUzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5sb2coYFN0ZWVyaW5nIG1hbmlmZXN0ICR7ZC51cmx9IHJhdGUgbGltaXRlZGApO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjaGVkdWxlUmVmcmVzaCh0aGlzLnVyaSB8fCBkLnVybCwgcCk7XG4gICAgICB9LFxuICAgICAgb25UaW1lb3V0OiAodSwgZCwgaCkgPT4ge1xuICAgICAgICB0aGlzLmxvZyhgVGltZW91dCBsb2FkaW5nIHN0ZWVyaW5nIG1hbmlmZXN0ICgke2QudXJsfSlgKSwgdGhpcy5zY2hlZHVsZVJlZnJlc2godGhpcy51cmkgfHwgZC51cmwpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5sb2coYFJlcXVlc3Rpbmcgc3RlZXJpbmcgbWFuaWZlc3Q6ICR7bn1gKSwgdGhpcy5sb2FkZXIubG9hZChpLCBsLCBjKTtcbiAgfVxuICBzY2hlZHVsZVJlZnJlc2goZSwgdCA9IHRoaXMudGltZVRvTG9hZCAqIDFlMykge1xuICAgIHRoaXMuY2xlYXJUaW1lb3V0KCksIHRoaXMucmVsb2FkVGltZXIgPSBzZWxmLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdmFyIHI7XG4gICAgICBjb25zdCBuID0gKHIgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IHIubWVkaWE7XG4gICAgICBpZiAobiAmJiAhbi5lbmRlZCkge1xuICAgICAgICB0aGlzLmxvYWRTdGVlcmluZ01hbmlmZXN0KGUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNjaGVkdWxlUmVmcmVzaChlLCB0aGlzLnRpbWVUb0xvYWQgKiAxZTMpO1xuICAgIH0sIHQpO1xuICB9XG59XG5mdW5jdGlvbiBZaChzLCBlLCB0LCByKSB7XG4gIHMgJiYgT2JqZWN0LmtleXMoZSkuZm9yRWFjaCgobikgPT4ge1xuICAgIGNvbnN0IGkgPSBzLmZpbHRlcigobykgPT4gby5ncm91cElkID09PSBuKS5tYXAoKG8pID0+IHtcbiAgICAgIGNvbnN0IGEgPSBudCh7fSwgbyk7XG4gICAgICByZXR1cm4gYS5kZXRhaWxzID0gdm9pZCAwLCBhLmF0dHJzID0gbmV3IGd0KGEuYXR0cnMpLCBhLnVybCA9IGEuYXR0cnMuVVJJID0gRnAoby51cmwsIG8uYXR0cnNbXCJTVEFCTEUtUkVORElUSU9OLUlEXCJdLCBcIlBFUi1SRU5ESVRJT04tVVJJU1wiLCB0KSwgYS5ncm91cElkID0gYS5hdHRyc1tcIkdST1VQLUlEXCJdID0gZVtuXSwgYS5hdHRyc1tcIlBBVEhXQVktSURcIl0gPSByLCBhO1xuICAgIH0pO1xuICAgIHMucHVzaCguLi5pKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBGcChzLCBlLCB0LCByKSB7XG4gIGNvbnN0IHtcbiAgICBIT1NUOiBuLFxuICAgIFBBUkFNUzogaSxcbiAgICBbdF06IG9cbiAgfSA9IHI7XG4gIGxldCBhO1xuICBlICYmIChhID0gbyA9PSBudWxsID8gdm9pZCAwIDogb1tlXSwgYSAmJiAocyA9IGEpKTtcbiAgY29uc3QgbCA9IG5ldyBzZWxmLlVSTChzKTtcbiAgcmV0dXJuIG4gJiYgIWEgJiYgKGwuaG9zdCA9IG4pLCBpICYmIE9iamVjdC5rZXlzKGkpLnNvcnQoKS5mb3JFYWNoKChjKSA9PiB7XG4gICAgYyAmJiBsLnNlYXJjaFBhcmFtcy5zZXQoYywgaVtjXSk7XG4gIH0pLCBsLmhyZWY7XG59XG5jbGFzcyBfbiBleHRlbmRzIExyIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHN1cGVyKFwiZW1lXCIsIGUubG9nZ2VyKSwgdGhpcy5obHMgPSB2b2lkIDAsIHRoaXMuY29uZmlnID0gdm9pZCAwLCB0aGlzLm1lZGlhID0gbnVsbCwgdGhpcy5rZXlGb3JtYXRQcm9taXNlID0gbnVsbCwgdGhpcy5rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlcyA9IHt9LCB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDAsIHRoaXMubWVkaWFLZXlTZXNzaW9ucyA9IFtdLCB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZSA9IHt9LCB0aGlzLm1lZGlhS2V5cyA9IG51bGwsIHRoaXMuc2V0TWVkaWFLZXlzUXVldWUgPSBfbi5DRE1DbGVhbnVwUHJvbWlzZSA/IFtfbi5DRE1DbGVhbnVwUHJvbWlzZV0gOiBbXSwgdGhpcy5iYW5uZWRLZXlJZHMgPSB7fSwgdGhpcy5vbk1lZGlhRW5jcnlwdGVkID0gKHQpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaW5pdERhdGFUeXBlOiByLFxuICAgICAgICBpbml0RGF0YTogblxuICAgICAgfSA9IHQsIGkgPSBgXCIke3QudHlwZX1cIiBldmVudDogaW5pdCBkYXRhIHR5cGU6IFwiJHtyfVwiYDtcbiAgICAgIGlmICh0aGlzLmRlYnVnKGkpLCBuICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5rZXlGb3JtYXRQcm9taXNlKSB7XG4gICAgICAgICAgbGV0IG8gPSBPYmplY3Qua2V5cyh0aGlzLmtleVN5c3RlbUFjY2Vzc1Byb21pc2VzKTtcbiAgICAgICAgICBvLmxlbmd0aCB8fCAobyA9IHpuKHRoaXMuY29uZmlnKSk7XG4gICAgICAgICAgY29uc3QgYSA9IG8ubWFwKGZsKS5maWx0ZXIoKGwpID0+ICEhbCk7XG4gICAgICAgICAgdGhpcy5rZXlGb3JtYXRQcm9taXNlID0gdGhpcy5nZXRLZXlGb3JtYXRQcm9taXNlKGEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMua2V5Rm9ybWF0UHJvbWlzZS50aGVuKChvKSA9PiB7XG4gICAgICAgICAgY29uc3QgYSA9IHBvKG8pO1xuICAgICAgICAgIGlmIChyICE9PSBcInNpbmZcIiB8fCBhICE9PSBtdC5GQUlSUExBWSkge1xuICAgICAgICAgICAgdGhpcy5sb2coYElnbm9yaW5nIFwiJHt0LnR5cGV9XCIgZXZlbnQgd2l0aCBpbml0IGRhdGEgdHlwZTogXCIke3J9XCIgZm9yIHNlbGVjdGVkIGtleS1zeXN0ZW0gJHthfWApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgbDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZiA9IGp0KG5ldyBVaW50OEFycmF5KG4pKSwgcCA9IGJ1KEpTT04ucGFyc2UoZikuc2luZiksIHkgPSBQZyhwKTtcbiAgICAgICAgICAgIGlmICgheSlcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3NjaG0nIGJveCBtaXNzaW5nIG9yIG5vdCBjYmNzL2NlbmMgd2l0aCBzY2hpID4gdGVuY1wiKTtcbiAgICAgICAgICAgIGwgPSBuZXcgVWludDhBcnJheSh5LnN1YmFycmF5KDgsIDI0KSk7XG4gICAgICAgICAgfSBjYXRjaCAoZikge1xuICAgICAgICAgICAgdGhpcy53YXJuKGAke2l9IEZhaWxlZCB0byBwYXJzZSBzaW5mOiAke2Z9YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGMgPSBmcihsKSwge1xuICAgICAgICAgICAga2V5SWRUb0tleVNlc3Npb25Qcm9taXNlOiB1LFxuICAgICAgICAgICAgbWVkaWFLZXlTZXNzaW9uczogZFxuICAgICAgICAgIH0gPSB0aGlzO1xuICAgICAgICAgIGxldCBoID0gdVtjXTtcbiAgICAgICAgICBmb3IgKGxldCBmID0gMDsgZiA8IGQubGVuZ3RoOyBmKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBkW2ZdLCB5ID0gcC5kZWNyeXB0ZGF0YTtcbiAgICAgICAgICAgIGlmICgheS5rZXlJZClcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBFID0gZnIoeS5rZXlJZCk7XG4gICAgICAgICAgICBpZiAoeHUobCwgeS5rZXlJZCkgfHwgeS51cmkucmVwbGFjZSgvLS9nLCBcIlwiKS5pbmRleE9mKGMpICE9PSAtMSkge1xuICAgICAgICAgICAgICBpZiAoaCA9IHVbRV0sICFoKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICBpZiAoeS5wc3NoKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWxldGUgdVtFXSwgeS5wc3NoID0gbmV3IFVpbnQ4QXJyYXkobiksIHkua2V5SWQgPSBsLCBoID0gdVtjXSA9IGgudGhlbigoKSA9PiB0aGlzLmdlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKHAsIHIsIG4sIFwiZW5jcnlwdGVkLWV2ZW50LWtleS1tYXRjaFwiKSksIGguY2F0Y2goKGIpID0+IHRoaXMuaGFuZGxlRXJyb3IoYikpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaCB8fCB0aGlzLmhhbmRsZUVycm9yKG5ldyBFcnJvcihgS2V5IElEICR7Y30gbm90IGVuY291bnRlcmVkIGluIHBsYXlsaXN0LiBLZXktc3lzdGVtIHNlc3Npb25zICR7ZC5sZW5ndGh9LmApKTtcbiAgICAgICAgfSkuY2F0Y2goKG8pID0+IHRoaXMuaGFuZGxlRXJyb3IobykpO1xuICAgICAgfVxuICAgIH0sIHRoaXMub25XYWl0aW5nRm9yS2V5ID0gKHQpID0+IHtcbiAgICAgIHRoaXMubG9nKGBcIiR7dC50eXBlfVwiIGV2ZW50YCk7XG4gICAgfSwgdGhpcy5obHMgPSBlLCB0aGlzLmNvbmZpZyA9IGUuY29uZmlnLCB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLm9uRGVzdHJveWluZygpLCB0aGlzLm9uTWVkaWFEZXRhY2hlZCgpO1xuICAgIGNvbnN0IGUgPSB0aGlzLmNvbmZpZztcbiAgICBlLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2Vzc0Z1bmMgPSBudWxsLCBlLmxpY2Vuc2VYaHJTZXR1cCA9IGUubGljZW5zZVJlc3BvbnNlQ2FsbGJhY2sgPSB2b2lkIDAsIGUuZHJtU3lzdGVtcyA9IGUuZHJtU3lzdGVtT3B0aW9ucyA9IHt9LCB0aGlzLmhscyA9IHRoaXMuY29uZmlnID0gdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2UgPSBudWxsLCB0aGlzLm9uTWVkaWFFbmNyeXB0ZWQgPSB0aGlzLm9uV2FpdGluZ0ZvcktleSA9IG51bGw7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5obHMub24oSS5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpLCB0aGlzLmhscy5vbihJLk1FRElBX0RFVEFDSEVELCB0aGlzLm9uTWVkaWFEZXRhY2hlZCwgdGhpcyksIHRoaXMuaGxzLm9uKEkuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyksIHRoaXMuaGxzLm9uKEkuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpLCB0aGlzLmhscy5vbihJLkRFU1RST1lJTkcsIHRoaXMub25EZXN0cm95aW5nLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHRoaXMuaGxzLm9mZihJLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyksIHRoaXMuaGxzLm9mZihJLk1FRElBX0RFVEFDSEVELCB0aGlzLm9uTWVkaWFEZXRhY2hlZCwgdGhpcyksIHRoaXMuaGxzLm9mZihJLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpLCB0aGlzLmhscy5vZmYoSS5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyksIHRoaXMuaGxzLm9mZihJLkRFU1RST1lJTkcsIHRoaXMub25EZXN0cm95aW5nLCB0aGlzKTtcbiAgfVxuICBnZXRMaWNlbnNlU2VydmVyVXJsKGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBkcm1TeXN0ZW1zOiB0LFxuICAgICAgd2lkZXZpbmVMaWNlbnNlVXJsOiByXG4gICAgfSA9IHRoaXMuY29uZmlnLCBuID0gdCA9PSBudWxsID8gdm9pZCAwIDogdFtlXTtcbiAgICBpZiAobilcbiAgICAgIHJldHVybiBuLmxpY2Vuc2VVcmw7XG4gICAgaWYgKGUgPT09IG10LldJREVWSU5FICYmIHIpXG4gICAgICByZXR1cm4gcjtcbiAgfVxuICBnZXRMaWNlbnNlU2VydmVyVXJsT3JUaHJvdyhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0TGljZW5zZVNlcnZlclVybChlKTtcbiAgICBpZiAodCA9PT0gdm9pZCAwKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBsaWNlbnNlIHNlcnZlciBVUkwgY29uZmlndXJlZCBmb3Iga2V5LXN5c3RlbSBcIiR7ZX1cImApO1xuICAgIHJldHVybiB0O1xuICB9XG4gIGdldFNlcnZlckNlcnRpZmljYXRlVXJsKGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBkcm1TeXN0ZW1zOiB0XG4gICAgfSA9IHRoaXMuY29uZmlnLCByID0gdCA9PSBudWxsID8gdm9pZCAwIDogdFtlXTtcbiAgICBpZiAocilcbiAgICAgIHJldHVybiByLnNlcnZlckNlcnRpZmljYXRlVXJsO1xuICAgIHRoaXMubG9nKGBObyBTZXJ2ZXIgQ2VydGlmaWNhdGUgaW4gY29uZmlnLmRybVN5c3RlbXNbXCIke2V9XCJdYCk7XG4gIH1cbiAgYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuaGxzLmxldmVscywgciA9IChvLCBhLCBsKSA9PiAhIW8gJiYgbC5pbmRleE9mKG8pID09PSBhLCBuID0gdC5tYXAoKG8pID0+IG8uYXVkaW9Db2RlYykuZmlsdGVyKHIpLCBpID0gdC5tYXAoKG8pID0+IG8udmlkZW9Db2RlYykuZmlsdGVyKHIpO1xuICAgIHJldHVybiBuLmxlbmd0aCArIGkubGVuZ3RoID09PSAwICYmIGkucHVzaChcImF2YzEuNDJlMDFlXCIpLCBuZXcgUHJvbWlzZSgobywgYSkgPT4ge1xuICAgICAgY29uc3QgbCA9IChjKSA9PiB7XG4gICAgICAgIGNvbnN0IHUgPSBjLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMuZ2V0TWVkaWFLZXlzUHJvbWlzZSh1LCBuLCBpKS50aGVuKChkKSA9PiBvKHtcbiAgICAgICAgICBrZXlTeXN0ZW06IHUsXG4gICAgICAgICAgbWVkaWFLZXlzOiBkXG4gICAgICAgIH0pKS5jYXRjaCgoZCkgPT4ge1xuICAgICAgICAgIGMubGVuZ3RoID8gbChjKSA6IGQgaW5zdGFuY2VvZiB5ciA/IGEoZCkgOiBhKG5ldyB5cih7XG4gICAgICAgICAgICB0eXBlOiB2ZS5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgICAgZGV0YWlsczogSi5LRVlfU1lTVEVNX05PX0FDQ0VTUyxcbiAgICAgICAgICAgIGVycm9yOiBkLFxuICAgICAgICAgICAgZmF0YWw6ICEwXG4gICAgICAgICAgfSwgZC5tZXNzYWdlKSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGwoZSk7XG4gICAgfSk7XG4gIH1cbiAgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzKGUsIHQpIHtcbiAgICBjb25zdCB7XG4gICAgICByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jOiByXG4gICAgfSA9IHRoaXMuY29uZmlnO1xuICAgIGlmICh0eXBlb2YgciAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGxldCBuID0gYENvbmZpZ3VyZWQgcmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIGlzIG5vdCBhIGZ1bmN0aW9uICR7cn1gO1xuICAgICAgcmV0dXJuIFlnID09PSBudWxsICYmIHNlbGYubG9jYXRpb24ucHJvdG9jb2wgPT09IFwiaHR0cDpcIiAmJiAobiA9IGBuYXZpZ2F0b3IucmVxdWVzdE1lZGlhS2V5U3lzdGVtQWNjZXNzIGlzIG5vdCBhdmFpbGFibGUgb3ZlciBpbnNlY3VyZSBwcm90b2NvbCAke2xvY2F0aW9uLnByb3RvY29sfWApLCBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IobikpO1xuICAgIH1cbiAgICByZXR1cm4gcihlLCB0KTtcbiAgfVxuICBnZXRNZWRpYUtleXNQcm9taXNlKGUsIHQsIHIpIHtcbiAgICB2YXIgbjtcbiAgICBjb25zdCBpID0gR2IoZSwgdCwgciwgdGhpcy5jb25maWcuZHJtU3lzdGVtT3B0aW9ucyB8fCB7fSk7XG4gICAgbGV0IG8gPSB0aGlzLmtleVN5c3RlbUFjY2Vzc1Byb21pc2VzW2VdLCBhID0gKG4gPSBvKSA9PSBudWxsID8gdm9pZCAwIDogbi5rZXlTeXN0ZW1BY2Nlc3M7XG4gICAgaWYgKCFhKSB7XG4gICAgICB0aGlzLmxvZyhgUmVxdWVzdGluZyBlbmNyeXB0ZWQgbWVkaWEgXCIke2V9XCIga2V5LXN5c3RlbSBhY2Nlc3Mgd2l0aCBjb25maWc6ICR7YXQoaSl9YCksIGEgPSB0aGlzLnJlcXVlc3RNZWRpYUtleVN5c3RlbUFjY2VzcyhlLCBpKTtcbiAgICAgIGNvbnN0IGwgPSBvID0gdGhpcy5rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlc1tlXSA9IHtcbiAgICAgICAga2V5U3lzdGVtQWNjZXNzOiBhXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGEuY2F0Y2goKGMpID0+IHtcbiAgICAgICAgdGhpcy5sb2coYEZhaWxlZCB0byBvYnRhaW4gYWNjZXNzIHRvIGtleS1zeXN0ZW0gXCIke2V9XCI6ICR7Y31gKTtcbiAgICAgIH0pLCBhLnRoZW4oKGMpID0+IHtcbiAgICAgICAgdGhpcy5sb2coYEFjY2VzcyBmb3Iga2V5LXN5c3RlbSBcIiR7Yy5rZXlTeXN0ZW19XCIgb2J0YWluZWRgKTtcbiAgICAgICAgY29uc3QgdSA9IHRoaXMuZmV0Y2hTZXJ2ZXJDZXJ0aWZpY2F0ZShlKTtcbiAgICAgICAgdGhpcy5sb2coYENyZWF0ZSBtZWRpYS1rZXlzIGZvciBcIiR7ZX1cImApO1xuICAgICAgICBjb25zdCBkID0gbC5tZWRpYUtleXMgPSBjLmNyZWF0ZU1lZGlhS2V5cygpLnRoZW4oKGgpID0+ICh0aGlzLmxvZyhgTWVkaWEta2V5cyBjcmVhdGVkIGZvciBcIiR7ZX1cImApLCBsLmhhc01lZGlhS2V5cyA9ICEwLCB1LnRoZW4oKGYpID0+IGYgPyB0aGlzLnNldE1lZGlhS2V5c1NlcnZlckNlcnRpZmljYXRlKGgsIGUsIGYpIDogaCkpKTtcbiAgICAgICAgcmV0dXJuIGQuY2F0Y2goKGgpID0+IHtcbiAgICAgICAgICB0aGlzLmVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIG1lZGlhLWtleXMgZm9yIFwiJHtlfVwifTogJHtofWApO1xuICAgICAgICB9KSwgZDtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYS50aGVuKCgpID0+IG8ubWVkaWFLZXlzKTtcbiAgfVxuICBjcmVhdGVNZWRpYUtleVNlc3Npb25Db250ZXh0KHtcbiAgICBkZWNyeXB0ZGF0YTogZSxcbiAgICBrZXlTeXN0ZW06IHQsXG4gICAgbWVkaWFLZXlzOiByXG4gIH0pIHtcbiAgICB0aGlzLmxvZyhgQ3JlYXRpbmcga2V5LXN5c3RlbSBzZXNzaW9uIFwiJHt0fVwiIGtleUlkOiAke2ZyKGUua2V5SWQgfHwgW10pfSBrZXlVcmk6ICR7ZS51cml9YCk7XG4gICAgY29uc3QgbiA9IHIuY3JlYXRlU2Vzc2lvbigpLCBpID0ge1xuICAgICAgZGVjcnlwdGRhdGE6IGUsXG4gICAgICBrZXlTeXN0ZW06IHQsXG4gICAgICBtZWRpYUtleXM6IHIsXG4gICAgICBtZWRpYUtleXNTZXNzaW9uOiBuLFxuICAgICAga2V5U3RhdHVzOiBcInN0YXR1cy1wZW5kaW5nXCJcbiAgICB9O1xuICAgIHJldHVybiB0aGlzLm1lZGlhS2V5U2Vzc2lvbnMucHVzaChpKSwgaTtcbiAgfVxuICByZW5ld0tleVNlc3Npb24oZSkge1xuICAgIGNvbnN0IHQgPSBlLmRlY3J5cHRkYXRhO1xuICAgIGlmICh0LnBzc2gpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLmNyZWF0ZU1lZGlhS2V5U2Vzc2lvbkNvbnRleHQoZSksIG4gPSBKaSh0KSwgaSA9IFwiY2VuY1wiO1xuICAgICAgdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vbbl0gPSB0aGlzLmdlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKHIsIGksIHQucHNzaC5idWZmZXIsIFwiZXhwaXJlZFwiKTtcbiAgICB9IGVsc2VcbiAgICAgIHRoaXMud2FybihcIkNvdWxkIG5vdCByZW5ldyBleHBpcmVkIHNlc3Npb24uIE1pc3NpbmcgcHNzaCBpbml0RGF0YS5cIik7XG4gICAgdGhpcy5yZW1vdmVTZXNzaW9uKGUpO1xuICB9XG4gIHVwZGF0ZUtleVNlc3Npb24oZSwgdCkge1xuICAgIGNvbnN0IHIgPSBlLm1lZGlhS2V5c1Nlc3Npb247XG4gICAgcmV0dXJuIHRoaXMubG9nKGBVcGRhdGluZyBrZXktc2Vzc2lvbiBcIiR7ci5zZXNzaW9uSWR9XCIgZm9yIGtleUlkICR7ZnIoZS5kZWNyeXB0ZGF0YS5rZXlJZCB8fCBbXSl9XG4gICAgICB9IChkYXRhIGxlbmd0aDogJHt0LmJ5dGVMZW5ndGh9KWApLCByLnVwZGF0ZSh0KTtcbiAgfVxuICBnZXRTZWxlY3RlZEtleVN5c3RlbUZvcm1hdHMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMua2V5U3lzdGVtQWNjZXNzUHJvbWlzZXMpLm1hcCgoZSkgPT4gKHtcbiAgICAgIGtleVN5c3RlbTogZSxcbiAgICAgIGhhc01lZGlhS2V5czogdGhpcy5rZXlTeXN0ZW1BY2Nlc3NQcm9taXNlc1tlXS5oYXNNZWRpYUtleXNcbiAgICB9KSkuZmlsdGVyKCh7XG4gICAgICBoYXNNZWRpYUtleXM6IGVcbiAgICB9KSA9PiAhIWUpLm1hcCgoe1xuICAgICAga2V5U3lzdGVtOiBlXG4gICAgfSkgPT4gZmwoZSkpLmZpbHRlcigoZSkgPT4gISFlKTtcbiAgfVxuICBnZXRLZXlTeXN0ZW1BY2Nlc3MoZSkge1xuICAgIHJldHVybiB0aGlzLmdldEtleVN5c3RlbVNlbGVjdGlvblByb21pc2UoZSkudGhlbigoe1xuICAgICAga2V5U3lzdGVtOiB0LFxuICAgICAgbWVkaWFLZXlzOiByXG4gICAgfSkgPT4gdGhpcy5hdHRlbXB0U2V0TWVkaWFLZXlzKHQsIHIpKTtcbiAgfVxuICBzZWxlY3RLZXlTeXN0ZW0oZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgodCwgcikgPT4ge1xuICAgICAgdGhpcy5nZXRLZXlTeXN0ZW1TZWxlY3Rpb25Qcm9taXNlKGUpLnRoZW4oKHtcbiAgICAgICAga2V5U3lzdGVtOiBuXG4gICAgICB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGkgPSBmbChuKTtcbiAgICAgICAgaSA/IHQoaSkgOiByKG5ldyBFcnJvcihgVW5hYmxlIHRvIGZpbmQgZm9ybWF0IGZvciBrZXktc3lzdGVtIFwiJHtufVwiYCkpO1xuICAgICAgfSkuY2F0Y2gocik7XG4gICAgfSk7XG4gIH1cbiAgc2VsZWN0S2V5U3lzdGVtRm9ybWF0KGUpIHtcbiAgICBjb25zdCB0ID0gT2JqZWN0LmtleXMoZS5sZXZlbGtleXMgfHwge30pO1xuICAgIHJldHVybiB0aGlzLmtleUZvcm1hdFByb21pc2UgfHwgKHRoaXMubG9nKGBTZWxlY3Rpbmcga2V5LXN5c3RlbSBmcm9tIGZyYWdtZW50IChzbjogJHtlLnNufSAke2UudHlwZX06ICR7ZS5sZXZlbH0pIGtleSBmb3JtYXRzICR7dC5qb2luKFwiLCBcIil9YCksIHRoaXMua2V5Rm9ybWF0UHJvbWlzZSA9IHRoaXMuZ2V0S2V5Rm9ybWF0UHJvbWlzZSh0KSksIHRoaXMua2V5Rm9ybWF0UHJvbWlzZTtcbiAgfVxuICBnZXRLZXlGb3JtYXRQcm9taXNlKGUpIHtcbiAgICBjb25zdCB0ID0gem4odGhpcy5jb25maWcpLCByID0gZS5tYXAocG8pLmZpbHRlcigobikgPT4gISFuICYmIHQuaW5kZXhPZihuKSAhPT0gLTEpO1xuICAgIHJldHVybiB0aGlzLnNlbGVjdEtleVN5c3RlbShyKTtcbiAgfVxuICBnZXRLZXlTdGF0dXMoZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhS2V5U2Vzc2lvbnM6IHRcbiAgICB9ID0gdGhpcztcbiAgICBmb3IgKGxldCByID0gMDsgciA8IHQubGVuZ3RoOyByKyspIHtcbiAgICAgIGNvbnN0IG4gPSBsdyhlLCB0W3JdKTtcbiAgICAgIGlmIChuKVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gIH1cbiAgbG9hZEtleShlKSB7XG4gICAgY29uc3QgdCA9IGUua2V5SW5mby5kZWNyeXB0ZGF0YSwgciA9IEppKHQpLCBuID0gdGhpcy5iYW5uZWRLZXlJZHNbcl07XG4gICAgaWYgKG4gfHwgdGhpcy5nZXRLZXlTdGF0dXModCkgPT09IFwiaW50ZXJuYWwtZXJyb3JcIikge1xuICAgICAgY29uc3QgYSA9IFpoKG4gfHwgXCJpbnRlcm5hbC1lcnJvclwiLCB0KTtcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZUVycm9yKGEsIGUuZnJhZyksIFByb21pc2UucmVqZWN0KGEpO1xuICAgIH1cbiAgICBjb25zdCBpID0gYChrZXlJZDogJHtyfSBmb3JtYXQ6IFwiJHt0LmtleUZvcm1hdH1cIiBtZXRob2Q6ICR7dC5tZXRob2R9IHVyaTogJHt0LnVyaX0pYDtcbiAgICB0aGlzLmxvZyhgU3RhcnRpbmcgc2Vzc2lvbiBmb3Iga2V5ICR7aX1gKTtcbiAgICBjb25zdCBvID0gdGhpcy5rZXlJZFRvS2V5U2Vzc2lvblByb21pc2Vbcl07XG4gICAgaWYgKCFvKSB7XG4gICAgICBjb25zdCBhID0gdGhpcy5nZXRLZXlTeXN0ZW1Gb3JLZXlQcm9taXNlKHQpLnRoZW4oKHtcbiAgICAgICAga2V5U3lzdGVtOiBsLFxuICAgICAgICBtZWRpYUtleXM6IGNcbiAgICAgIH0pID0+ICh0aGlzLnRocm93SWZEZXN0cm95ZWQoKSwgdGhpcy5sb2coYEhhbmRsZSBlbmNyeXB0ZWQgbWVkaWEgc246ICR7ZS5mcmFnLnNufSAke2UuZnJhZy50eXBlfTogJHtlLmZyYWcubGV2ZWx9IHVzaW5nIGtleSAke2l9YCksIHRoaXMuYXR0ZW1wdFNldE1lZGlhS2V5cyhsLCBjKS50aGVuKCgpID0+ICh0aGlzLnRocm93SWZEZXN0cm95ZWQoKSwgdGhpcy5jcmVhdGVNZWRpYUtleVNlc3Npb25Db250ZXh0KHtcbiAgICAgICAga2V5U3lzdGVtOiBsLFxuICAgICAgICBtZWRpYUtleXM6IGMsXG4gICAgICAgIGRlY3J5cHRkYXRhOiB0XG4gICAgICB9KSkpKSkudGhlbigobCkgPT4ge1xuICAgICAgICBjb25zdCBjID0gXCJjZW5jXCIsIHUgPSB0LnBzc2ggPyB0LnBzc2guYnVmZmVyIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVSZXF1ZXN0V2l0aFByZWZlcnJlZEtleVNlc3Npb24obCwgYywgdSwgXCJwbGF5bGlzdC1rZXlcIik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhLmNhdGNoKChsKSA9PiB0aGlzLmhhbmRsZUVycm9yKGwsIGUuZnJhZykpLCB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVtyXSA9IGEsIGE7XG4gICAgfVxuICAgIHJldHVybiBvLmNhdGNoKChhKSA9PiB7XG4gICAgICBpZiAoYSBpbnN0YW5jZW9mIHlyKSB7XG4gICAgICAgIGNvbnN0IGwgPSB0dCh7fSwgYS5kYXRhKTtcbiAgICAgICAgdGhpcy5nZXRLZXlTdGF0dXModCkgPT09IFwiaW50ZXJuYWwtZXJyb3JcIiAmJiAobC5kZWNyeXB0ZGF0YSA9IHQpO1xuICAgICAgICBjb25zdCBjID0gbmV3IHlyKGwsIGEubWVzc2FnZSk7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoYywgZS5mcmFnKTtcbiAgICAgIH1cbiAgICB9KSwgbztcbiAgfVxuICB0aHJvd0lmRGVzdHJveWVkKGUgPSBcIkludmFsaWQgc3RhdGVcIikge1xuICAgIGlmICghdGhpcy5obHMpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHN0YXRlXCIpO1xuICB9XG4gIGhhbmRsZUVycm9yKGUsIHQpIHtcbiAgICBpZiAodGhpcy5obHMpXG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIHlyKSB7XG4gICAgICAgIHQgJiYgKGUuZGF0YS5mcmFnID0gdCk7XG4gICAgICAgIGNvbnN0IHIgPSBlLmRhdGEuZGVjcnlwdGRhdGE7XG4gICAgICAgIHRoaXMuZXJyb3IoYCR7ZS5tZXNzYWdlfSR7ciA/IGAgKCR7ZnIoci5rZXlJZCB8fCBbXSl9KWAgOiBcIlwifWApLCB0aGlzLmhscy50cmlnZ2VyKEkuRVJST1IsIGUuZGF0YSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgdGhpcy5lcnJvcihlLm1lc3NhZ2UpLCB0aGlzLmhscy50cmlnZ2VyKEkuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiB2ZS5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEouS0VZX1NZU1RFTV9OT19LRVlTLFxuICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgIGZhdGFsOiAhMFxuICAgICAgICB9KTtcbiAgfVxuICBnZXRLZXlTeXN0ZW1Gb3JLZXlQcm9taXNlKGUpIHtcbiAgICBjb25zdCB0ID0gSmkoZSksIHIgPSB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZVt0XTtcbiAgICBpZiAoIXIpIHtcbiAgICAgIGNvbnN0IG4gPSBwbyhlLmtleUZvcm1hdCksIGkgPSBuID8gW25dIDogem4odGhpcy5jb25maWcpO1xuICAgICAgcmV0dXJuIHRoaXMuYXR0ZW1wdEtleVN5c3RlbUFjY2VzcyhpKTtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgZ2V0S2V5U3lzdGVtU2VsZWN0aW9uUHJvbWlzZShlKSB7XG4gICAgaWYgKGUubGVuZ3RoIHx8IChlID0gem4odGhpcy5jb25maWcpKSwgZS5sZW5ndGggPT09IDApXG4gICAgICB0aHJvdyBuZXcgeXIoe1xuICAgICAgICB0eXBlOiB2ZS5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBKLktFWV9TWVNURU1fTk9fQ09ORklHVVJFRF9MSUNFTlNFLFxuICAgICAgICBmYXRhbDogITBcbiAgICAgIH0sIGBNaXNzaW5nIGtleS1zeXN0ZW0gbGljZW5zZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgJHthdCh7XG4gICAgICAgIGRybVN5c3RlbXM6IHRoaXMuY29uZmlnLmRybVN5c3RlbXNcbiAgICAgIH0pfWApO1xuICAgIHJldHVybiB0aGlzLmF0dGVtcHRLZXlTeXN0ZW1BY2Nlc3MoZSk7XG4gIH1cbiAgYXR0ZW1wdFNldE1lZGlhS2V5cyhlLCB0KSB7XG4gICAgaWYgKHRoaXMubWVkaWFLZXlzID09PSB0KVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGNvbnN0IHIgPSB0aGlzLnNldE1lZGlhS2V5c1F1ZXVlLnNsaWNlKCk7XG4gICAgdGhpcy5sb2coYFNldHRpbmcgbWVkaWEta2V5cyBmb3IgXCIke2V9XCJgKTtcbiAgICBjb25zdCBuID0gUHJvbWlzZS5hbGwocikudGhlbigoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMubWVkaWEpXG4gICAgICAgIHRocm93IHRoaXMubWVkaWFLZXlzID0gbnVsbCwgbmV3IEVycm9yKFwiQXR0ZW1wdGVkIHRvIHNldCBtZWRpYUtleXMgd2l0aG91dCBtZWRpYSBlbGVtZW50IGF0dGFjaGVkXCIpO1xuICAgICAgcmV0dXJuIHRoaXMubWVkaWEuc2V0TWVkaWFLZXlzKHQpO1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLm1lZGlhS2V5cyA9IHQsIHRoaXMuc2V0TWVkaWFLZXlzUXVldWUucHVzaChuKSwgbi50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMubG9nKGBNZWRpYS1rZXlzIHNldCBmb3IgXCIke2V9XCJgKSwgci5wdXNoKG4pLCB0aGlzLnNldE1lZGlhS2V5c1F1ZXVlID0gdGhpcy5zZXRNZWRpYUtleXNRdWV1ZS5maWx0ZXIoKGkpID0+IHIuaW5kZXhPZihpKSA9PT0gLTEpO1xuICAgIH0pO1xuICB9XG4gIGdlbmVyYXRlUmVxdWVzdFdpdGhQcmVmZXJyZWRLZXlTZXNzaW9uKGUsIHQsIHIsIG4pIHtcbiAgICB2YXIgaTtcbiAgICBjb25zdCBvID0gKGkgPSB0aGlzLmNvbmZpZy5kcm1TeXN0ZW1zKSA9PSBudWxsIHx8IChpID0gaVtlLmtleVN5c3RlbV0pID09IG51bGwgPyB2b2lkIDAgOiBpLmdlbmVyYXRlUmVxdWVzdDtcbiAgICBpZiAobylcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHAgPSBvLmNhbGwodGhpcy5obHMsIHQsIHIsIGUpO1xuICAgICAgICBpZiAoIXApXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByZXNwb25zZSBmcm9tIGNvbmZpZ3VyZWQgZ2VuZXJhdGVSZXF1ZXN0IGZpbHRlclwiKTtcbiAgICAgICAgdCA9IHAuaW5pdERhdGFUeXBlLCByID0gcC5pbml0RGF0YSA/IHAuaW5pdERhdGEgOiBudWxsLCBlLmRlY3J5cHRkYXRhLnBzc2ggPSByID8gbmV3IFVpbnQ4QXJyYXkocikgOiBudWxsO1xuICAgICAgfSBjYXRjaCAocCkge1xuICAgICAgICBpZiAodGhpcy53YXJuKHAubWVzc2FnZSksIHRoaXMuaGxzICYmIHRoaXMuaGxzLmNvbmZpZy5kZWJ1ZylcbiAgICAgICAgICB0aHJvdyBwO1xuICAgICAgfVxuICAgIGlmIChyID09PSBudWxsKVxuICAgICAgcmV0dXJuIHRoaXMubG9nKGBTa2lwcGluZyBrZXktc2Vzc2lvbiByZXF1ZXN0IGZvciBcIiR7bn1cIiAobm8gaW5pdERhdGEpYCksIFByb21pc2UucmVzb2x2ZShlKTtcbiAgICBjb25zdCBhID0gSmkoZS5kZWNyeXB0ZGF0YSksIGwgPSBlLmRlY3J5cHRkYXRhLnVyaTtcbiAgICB0aGlzLmxvZyhgR2VuZXJhdGluZyBrZXktc2Vzc2lvbiByZXF1ZXN0IGZvciBcIiR7bn1cIiBrZXlJZDogJHthfSBVUkk6ICR7bH0gKGluaXQgZGF0YSB0eXBlOiAke3R9IGxlbmd0aDogJHtyLmJ5dGVMZW5ndGh9KWApO1xuICAgIGNvbnN0IGMgPSBuZXcgd3UoKSwgdSA9IGUuX29ubWVzc2FnZSA9IChwKSA9PiB7XG4gICAgICBjb25zdCB5ID0gZS5tZWRpYUtleXNTZXNzaW9uO1xuICAgICAgaWYgKCF5KSB7XG4gICAgICAgIGMuZW1pdChcImVycm9yXCIsIG5ldyBFcnJvcihcImludmFsaWQgc3RhdGVcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1lc3NhZ2VUeXBlOiBFLFxuICAgICAgICBtZXNzYWdlOiBiXG4gICAgICB9ID0gcDtcbiAgICAgIHRoaXMubG9nKGBcIiR7RX1cIiBtZXNzYWdlIGV2ZW50IGZvciBzZXNzaW9uIFwiJHt5LnNlc3Npb25JZH1cIiBtZXNzYWdlIHNpemU6ICR7Yi5ieXRlTGVuZ3RofWApLCBFID09PSBcImxpY2Vuc2UtcmVxdWVzdFwiIHx8IEUgPT09IFwibGljZW5zZS1yZW5ld2FsXCIgPyB0aGlzLnJlbmV3TGljZW5zZShlLCBiKS5jYXRjaCgoUikgPT4ge1xuICAgICAgICBjLmV2ZW50TmFtZXMoKS5sZW5ndGggPyBjLmVtaXQoXCJlcnJvclwiLCBSKSA6IHRoaXMuaGFuZGxlRXJyb3IoUik7XG4gICAgICB9KSA6IEUgPT09IFwibGljZW5zZS1yZWxlYXNlXCIgPyBlLmtleVN5c3RlbSA9PT0gbXQuRkFJUlBMQVkgJiYgdGhpcy51cGRhdGVLZXlTZXNzaW9uKGUsIGhjKFwiYWNrbm93bGVkZ2VkXCIpKS50aGVuKCgpID0+IHRoaXMucmVtb3ZlU2Vzc2lvbihlKSkuY2F0Y2goKFIpID0+IHRoaXMuaGFuZGxlRXJyb3IoUikpIDogdGhpcy53YXJuKGB1bmhhbmRsZWQgbWVkaWEga2V5IG1lc3NhZ2UgdHlwZSBcIiR7RX1cImApO1xuICAgIH0sIGQgPSAocCwgeSkgPT4ge1xuICAgICAgeS5rZXlTdGF0dXMgPSBwO1xuICAgICAgbGV0IEU7XG4gICAgICBwLnN0YXJ0c1dpdGgoXCJ1c2FibGVcIikgPyBjLmVtaXQoXCJyZXNvbHZlZFwiKSA6IHAgPT09IFwiaW50ZXJuYWwtZXJyb3JcIiB8fCBwID09PSBcIm91dHB1dC1yZXN0cmljdGVkXCIgfHwgcCA9PT0gXCJvdXRwdXQtZG93bnNjYWxlZFwiID8gRSA9IFpoKHAsIHkuZGVjcnlwdGRhdGEpIDogcCA9PT0gXCJleHBpcmVkXCIgPyBFID0gbmV3IEVycm9yKGBrZXkgZXhwaXJlZCAoa2V5SWQ6ICR7YX0pYCkgOiBwID09PSBcInJlbGVhc2VkXCIgPyBFID0gbmV3IEVycm9yKFwia2V5IHJlbGVhc2VkXCIpIDogcCA9PT0gXCJzdGF0dXMtcGVuZGluZ1wiIHx8IHRoaXMud2FybihgdW5oYW5kbGVkIGtleSBzdGF0dXMgY2hhbmdlIFwiJHtwfVwiIChrZXlJZDogJHthfSlgKSwgRSAmJiAoYy5ldmVudE5hbWVzKCkubGVuZ3RoID8gYy5lbWl0KFwiZXJyb3JcIiwgRSkgOiB0aGlzLmhhbmRsZUVycm9yKEUpKTtcbiAgICB9LCBoID0gZS5fb25rZXlzdGF0dXNlc2NoYW5nZSA9IChwKSA9PiB7XG4gICAgICBpZiAoIWUubWVkaWFLZXlzU2Vzc2lvbikge1xuICAgICAgICBjLmVtaXQoXCJlcnJvclwiLCBuZXcgRXJyb3IoXCJpbnZhbGlkIHN0YXRlXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgRSA9IHRoaXMuZ2V0S2V5U3RhdHVzZXMoZSk7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKEUpLnNvbWUoKEYpID0+IEVbRl0gIT09IFwic3RhdHVzLXBlbmRpbmdcIikpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChFW2FdID09PSBcImV4cGlyZWRcIikge1xuICAgICAgICB0aGlzLmxvZyhgRXhwaXJlZCBrZXkgJHthdChFKX0gaW4ga2V5LXNlc3Npb24gXCIke2UubWVkaWFLZXlzU2Vzc2lvbi5zZXNzaW9uSWR9XCJgKSwgdGhpcy5yZW5ld0tleVNlc3Npb24oZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBSID0gRVthXTtcbiAgICAgIGlmIChSKVxuICAgICAgICBkKFIsIGUpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBBO1xuICAgICAgICBlLmtleVN0YXR1c1RpbWVvdXRzIHx8IChlLmtleVN0YXR1c1RpbWVvdXRzID0ge30pLCAoQSA9IGUua2V5U3RhdHVzVGltZW91dHMpW2FdIHx8IChBW2FdID0gc2VsZi5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBpZiAoIWUubWVkaWFLZXlzU2Vzc2lvbiB8fCAhdGhpcy5tZWRpYUtleXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgY29uc3QgTSA9IHRoaXMuZ2V0S2V5U3RhdHVzKGUuZGVjcnlwdGRhdGEpO1xuICAgICAgICAgIGlmIChNICYmIE0gIT09IFwic3RhdHVzLXBlbmRpbmdcIilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvZyhgTm8gc3RhdHVzIGZvciBrZXlJZCAke2F9IGluIGtleS1zZXNzaW9uIFwiJHtlLm1lZGlhS2V5c1Nlc3Npb24uc2Vzc2lvbklkfVwiLiBVc2luZyBzZXNzaW9uIGtleS1zdGF0dXMgJHtNfSBmcm9tIG90aGVyIHNlc3Npb24uYCksIGQoTSwgZSk7XG4gICAgICAgICAgdGhpcy5sb2coYGtleSBzdGF0dXMgZm9yICR7YX0gaW4ga2V5LXNlc3Npb24gXCIke2UubWVkaWFLZXlzU2Vzc2lvbi5zZXNzaW9uSWR9XCIgdGltZWQgb3V0IGFmdGVyIDBtc2ApLCBSID0gXCJpbnRlcm5hbC1lcnJvclwiLCBkKFIsIGUpO1xuICAgICAgICB9LCAwKSksIHRoaXMubG9nKGBObyBzdGF0dXMgZm9yIGtleUlkICR7YX0gKCR7YXQoRSl9KS5gKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNyKGUubWVkaWFLZXlzU2Vzc2lvbiwgXCJtZXNzYWdlXCIsIHUpLCBjcihlLm1lZGlhS2V5c1Nlc3Npb24sIFwia2V5c3RhdHVzZXNjaGFuZ2VcIiwgaCk7XG4gICAgY29uc3QgZiA9IG5ldyBQcm9taXNlKChwLCB5KSA9PiB7XG4gICAgICBjLm9uKFwiZXJyb3JcIiwgeSksIGMub24oXCJyZXNvbHZlZFwiLCBwKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZS5tZWRpYUtleXNTZXNzaW9uLmdlbmVyYXRlUmVxdWVzdCh0LCByKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMubG9nKGBSZXF1ZXN0IGdlbmVyYXRlZCBmb3Iga2V5LXNlc3Npb24gXCIke2UubWVkaWFLZXlzU2Vzc2lvbi5zZXNzaW9uSWR9XCIga2V5SWQ6ICR7YX0gVVJJOiAke2x9YCk7XG4gICAgfSkuY2F0Y2goKHApID0+IHtcbiAgICAgIHRocm93IG5ldyB5cih7XG4gICAgICAgIHR5cGU6IHZlLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEouS0VZX1NZU1RFTV9OT19TRVNTSU9OLFxuICAgICAgICBlcnJvcjogcCxcbiAgICAgICAgZGVjcnlwdGRhdGE6IGUuZGVjcnlwdGRhdGEsXG4gICAgICAgIGZhdGFsOiAhMVxuICAgICAgfSwgYEVycm9yIGdlbmVyYXRpbmcga2V5LXNlc3Npb24gcmVxdWVzdDogJHtwfWApO1xuICAgIH0pLnRoZW4oKCkgPT4gZikuY2F0Y2goKHApID0+IChjLnJlbW92ZUFsbExpc3RlbmVycygpLCB0aGlzLnJlbW92ZVNlc3Npb24oZSkudGhlbigoKSA9PiB7XG4gICAgICB0aHJvdyBwO1xuICAgIH0pKSkudGhlbigoKSA9PiAoYy5yZW1vdmVBbGxMaXN0ZW5lcnMoKSwgZSkpO1xuICB9XG4gIGdldEtleVN0YXR1c2VzKGUpIHtcbiAgICBjb25zdCB0ID0ge307XG4gICAgcmV0dXJuIGUubWVkaWFLZXlzU2Vzc2lvbi5rZXlTdGF0dXNlcy5mb3JFYWNoKChyLCBuKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG4gPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgciA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IGEgPSBuO1xuICAgICAgICBuID0gciwgciA9IGE7XG4gICAgICB9XG4gICAgICBjb25zdCBpID0gXCJidWZmZXJcIiBpbiBuID8gbmV3IFVpbnQ4QXJyYXkobi5idWZmZXIsIG4uYnl0ZU9mZnNldCwgbi5ieXRlTGVuZ3RoKSA6IG5ldyBVaW50OEFycmF5KG4pO1xuICAgICAgZS5rZXlTeXN0ZW0gPT09IG10LlBMQVlSRUFEWSAmJiBpLmxlbmd0aCA9PT0gMTYgJiYgemcoaSk7XG4gICAgICBjb25zdCBvID0gZnIoaSk7XG4gICAgICByID09PSBcImludGVybmFsLWVycm9yXCIgJiYgKHRoaXMuYmFubmVkS2V5SWRzW29dID0gciksIHRoaXMubG9nKGBrZXkgc3RhdHVzIGNoYW5nZSBcIiR7cn1cIiBmb3Iga2V5U3RhdHVzZXMga2V5SWQ6ICR7b30ga2V5LXNlc3Npb24gXCIke2UubWVkaWFLZXlzU2Vzc2lvbi5zZXNzaW9uSWR9XCJgKSwgdFtvXSA9IHI7XG4gICAgfSksIHQ7XG4gIH1cbiAgZmV0Y2hTZXJ2ZXJDZXJ0aWZpY2F0ZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuY29uZmlnLCByID0gdC5sb2FkZXIsIG4gPSBuZXcgcih0KSwgaSA9IHRoaXMuZ2V0U2VydmVyQ2VydGlmaWNhdGVVcmwoZSk7XG4gICAgcmV0dXJuIGkgPyAodGhpcy5sb2coYEZldGNoaW5nIHNlcnZlciBjZXJ0aWZpY2F0ZSBmb3IgXCIke2V9XCJgKSwgbmV3IFByb21pc2UoKG8sIGEpID0+IHtcbiAgICAgIGNvbnN0IGwgPSB7XG4gICAgICAgIHJlc3BvbnNlVHlwZTogXCJhcnJheWJ1ZmZlclwiLFxuICAgICAgICB1cmw6IGlcbiAgICAgIH0sIGMgPSB0LmNlcnRMb2FkUG9saWN5LmRlZmF1bHQsIHUgPSB7XG4gICAgICAgIGxvYWRQb2xpY3k6IGMsXG4gICAgICAgIHRpbWVvdXQ6IGMubWF4TG9hZFRpbWVNcyxcbiAgICAgICAgbWF4UmV0cnk6IDAsXG4gICAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXk6IDBcbiAgICAgIH0sIGQgPSB7XG4gICAgICAgIG9uU3VjY2VzczogKGgsIGYsIHAsIHkpID0+IHtcbiAgICAgICAgICBvKGguZGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRXJyb3I6IChoLCBmLCBwLCB5KSA9PiB7XG4gICAgICAgICAgYShuZXcgeXIoe1xuICAgICAgICAgICAgdHlwZTogdmUuS0VZX1NZU1RFTV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEouS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgICBmYXRhbDogITAsXG4gICAgICAgICAgICBuZXR3b3JrRGV0YWlsczogcCxcbiAgICAgICAgICAgIHJlc3BvbnNlOiB0dCh7XG4gICAgICAgICAgICAgIHVybDogbC51cmwsXG4gICAgICAgICAgICAgIGRhdGE6IHZvaWQgMFxuICAgICAgICAgICAgfSwgaClcbiAgICAgICAgICB9LCBgXCIke2V9XCIgY2VydGlmaWNhdGUgcmVxdWVzdCBmYWlsZWQgKCR7aX0pLiBTdGF0dXM6ICR7aC5jb2RlfSAoJHtoLnRleHR9KWApKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25UaW1lb3V0OiAoaCwgZiwgcCkgPT4ge1xuICAgICAgICAgIGEobmV3IHlyKHtcbiAgICAgICAgICAgIHR5cGU6IHZlLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBKLktFWV9TWVNURU1fU0VSVkVSX0NFUlRJRklDQVRFX1JFUVVFU1RfRkFJTEVELFxuICAgICAgICAgICAgZmF0YWw6ICEwLFxuICAgICAgICAgICAgbmV0d29ya0RldGFpbHM6IHAsXG4gICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICB1cmw6IGwudXJsLFxuICAgICAgICAgICAgICBkYXRhOiB2b2lkIDBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBgXCIke2V9XCIgY2VydGlmaWNhdGUgcmVxdWVzdCB0aW1lZCBvdXQgKCR7aX0pYCkpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFib3J0OiAoaCwgZiwgcCkgPT4ge1xuICAgICAgICAgIGEobmV3IEVycm9yKFwiYWJvcnRlZFwiKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBuLmxvYWQobCwgdSwgZCk7XG4gICAgfSkpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cbiAgc2V0TWVkaWFLZXlzU2VydmVyQ2VydGlmaWNhdGUoZSwgdCwgcikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgobiwgaSkgPT4ge1xuICAgICAgZS5zZXRTZXJ2ZXJDZXJ0aWZpY2F0ZShyKS50aGVuKChvKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBzZXRTZXJ2ZXJDZXJ0aWZpY2F0ZSAke28gPyBcInN1Y2Nlc3NcIiA6IFwibm90IHN1cHBvcnRlZCBieSBDRE1cIn0gKCR7ci5ieXRlTGVuZ3RofSkgb24gXCIke3R9XCJgKSwgbihlKTtcbiAgICAgIH0pLmNhdGNoKChvKSA9PiB7XG4gICAgICAgIGkobmV3IHlyKHtcbiAgICAgICAgICB0eXBlOiB2ZS5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEouS0VZX1NZU1RFTV9TRVJWRVJfQ0VSVElGSUNBVEVfVVBEQVRFX0ZBSUxFRCxcbiAgICAgICAgICBlcnJvcjogbyxcbiAgICAgICAgICBmYXRhbDogITBcbiAgICAgICAgfSwgby5tZXNzYWdlKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZW5ld0xpY2Vuc2UoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RMaWNlbnNlKGUsIG5ldyBVaW50OEFycmF5KHQpKS50aGVuKChyKSA9PiB0aGlzLnVwZGF0ZUtleVNlc3Npb24oZSwgbmV3IFVpbnQ4QXJyYXkocikpLmNhdGNoKChuKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgeXIoe1xuICAgICAgICB0eXBlOiB2ZS5LRVlfU1lTVEVNX0VSUk9SLFxuICAgICAgICBkZXRhaWxzOiBKLktFWV9TWVNURU1fU0VTU0lPTl9VUERBVEVfRkFJTEVELFxuICAgICAgICBkZWNyeXB0ZGF0YTogZS5kZWNyeXB0ZGF0YSxcbiAgICAgICAgZXJyb3I6IG4sXG4gICAgICAgIGZhdGFsOiAhMVxuICAgICAgfSwgbi5tZXNzYWdlKTtcbiAgICB9KSk7XG4gIH1cbiAgdW5wYWNrUGxheVJlYWR5S2V5TWVzc2FnZShlLCB0KSB7XG4gICAgY29uc3QgciA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQxNkFycmF5KHQuYnVmZmVyKSk7XG4gICAgaWYgKCFyLmluY2x1ZGVzKFwiUGxheVJlYWR5S2V5TWVzc2FnZVwiKSlcbiAgICAgIHJldHVybiBlLnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgXCJ0ZXh0L3htbDsgY2hhcnNldD11dGYtOFwiKSwgdDtcbiAgICBjb25zdCBuID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhyLCBcImFwcGxpY2F0aW9uL3htbFwiKSwgaSA9IG4ucXVlcnlTZWxlY3RvckFsbChcIkh0dHBIZWFkZXJcIik7XG4gICAgaWYgKGkubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IHU7XG4gICAgICBmb3IgKGxldCBkID0gMCwgaCA9IGkubGVuZ3RoOyBkIDwgaDsgZCsrKSB7XG4gICAgICAgIHZhciBvLCBhO1xuICAgICAgICB1ID0gaVtkXTtcbiAgICAgICAgY29uc3QgZiA9IChvID0gdS5xdWVyeVNlbGVjdG9yKFwibmFtZVwiKSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8udGV4dENvbnRlbnQsIHAgPSAoYSA9IHUucXVlcnlTZWxlY3RvcihcInZhbHVlXCIpKSA9PSBudWxsID8gdm9pZCAwIDogYS50ZXh0Q29udGVudDtcbiAgICAgICAgZiAmJiBwICYmIGUuc2V0UmVxdWVzdEhlYWRlcihmLCBwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbCA9IG4ucXVlcnlTZWxlY3RvcihcIkNoYWxsZW5nZVwiKSwgYyA9IGwgPT0gbnVsbCA/IHZvaWQgMCA6IGwudGV4dENvbnRlbnQ7XG4gICAgaWYgKCFjKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgPENoYWxsZW5nZT4gaW4ga2V5IG1lc3NhZ2VcIik7XG4gICAgcmV0dXJuIGhjKGF0b2IoYykpO1xuICB9XG4gIHNldHVwTGljZW5zZVhIUihlLCB0LCByLCBuKSB7XG4gICAgY29uc3QgaSA9IHRoaXMuY29uZmlnLmxpY2Vuc2VYaHJTZXR1cDtcbiAgICByZXR1cm4gaSA/IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKCFyLmRlY3J5cHRkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJLZXkgcmVtb3ZlZFwiKTtcbiAgICAgIHJldHVybiBpLmNhbGwodGhpcy5obHMsIGUsIHQsIHIsIG4pO1xuICAgIH0pLmNhdGNoKChvKSA9PiB7XG4gICAgICBpZiAoIXIuZGVjcnlwdGRhdGEpXG4gICAgICAgIHRocm93IG87XG4gICAgICByZXR1cm4gZS5vcGVuKFwiUE9TVFwiLCB0LCAhMCksIGkuY2FsbCh0aGlzLmhscywgZSwgdCwgciwgbik7XG4gICAgfSkudGhlbigobykgPT4gKGUucmVhZHlTdGF0ZSB8fCBlLm9wZW4oXCJQT1NUXCIsIHQsICEwKSwge1xuICAgICAgeGhyOiBlLFxuICAgICAgbGljZW5zZUNoYWxsZW5nZTogbyB8fCBuXG4gICAgfSkpIDogKGUub3BlbihcIlBPU1RcIiwgdCwgITApLCBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgeGhyOiBlLFxuICAgICAgbGljZW5zZUNoYWxsZW5nZTogblxuICAgIH0pKTtcbiAgfVxuICByZXF1ZXN0TGljZW5zZShlLCB0KSB7XG4gICAgY29uc3QgciA9IHRoaXMuY29uZmlnLmtleUxvYWRQb2xpY3kuZGVmYXVsdDtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKG4sIGkpID0+IHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLmdldExpY2Vuc2VTZXJ2ZXJVcmxPclRocm93KGUua2V5U3lzdGVtKTtcbiAgICAgIHRoaXMubG9nKGBTZW5kaW5nIGxpY2Vuc2UgcmVxdWVzdCB0byBVUkw6ICR7b31gKTtcbiAgICAgIGNvbnN0IGEgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgIGEucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiLCBhLm9ucmVhZHlzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmhscyB8fCAhZS5tZWRpYUtleXNTZXNzaW9uKVxuICAgICAgICAgIHJldHVybiBpKG5ldyBFcnJvcihcImludmFsaWQgc3RhdGVcIikpO1xuICAgICAgICBpZiAoYS5yZWFkeVN0YXRlID09PSA0KVxuICAgICAgICAgIGlmIChhLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0TGljZW5zZUZhaWx1cmVDb3VudCA9IDA7XG4gICAgICAgICAgICBsZXQgbCA9IGEucmVzcG9uc2U7XG4gICAgICAgICAgICB0aGlzLmxvZyhgTGljZW5zZSByZWNlaXZlZCAke2wgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciA/IGwuYnl0ZUxlbmd0aCA6IGx9YCk7XG4gICAgICAgICAgICBjb25zdCBjID0gdGhpcy5jb25maWcubGljZW5zZVJlc3BvbnNlQ2FsbGJhY2s7XG4gICAgICAgICAgICBpZiAoYylcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsID0gYy5jYWxsKHRoaXMuaGxzLCBhLCBvLCBlKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAodSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IodSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG4obCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSByLmVycm9yUmV0cnksIGMgPSBsID8gbC5tYXhOdW1SZXRyeSA6IDA7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQrKywgdGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgPiBjIHx8IGEuc3RhdHVzID49IDQwMCAmJiBhLnN0YXR1cyA8IDUwMClcbiAgICAgICAgICAgICAgaShuZXcgeXIoe1xuICAgICAgICAgICAgICAgIHR5cGU6IHZlLktFWV9TWVNURU1fRVJST1IsXG4gICAgICAgICAgICAgICAgZGV0YWlsczogSi5LRVlfU1lTVEVNX0xJQ0VOU0VfUkVRVUVTVF9GQUlMRUQsXG4gICAgICAgICAgICAgICAgZGVjcnlwdGRhdGE6IGUuZGVjcnlwdGRhdGEsXG4gICAgICAgICAgICAgICAgZmF0YWw6ICEwLFxuICAgICAgICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBhLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAgICAgICB1cmw6IG8sXG4gICAgICAgICAgICAgICAgICBkYXRhOiB2b2lkIDAsXG4gICAgICAgICAgICAgICAgICBjb2RlOiBhLnN0YXR1cyxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGEuc3RhdHVzVGV4dFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSwgYExpY2Vuc2UgUmVxdWVzdCBYSFIgZmFpbGVkICgke299KS4gU3RhdHVzOiAke2Euc3RhdHVzfSAoJHthLnN0YXR1c1RleHR9KWApKTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBjb25zdCB1ID0gYyAtIHRoaXMuX3JlcXVlc3RMaWNlbnNlRmFpbHVyZUNvdW50ICsgMTtcbiAgICAgICAgICAgICAgdGhpcy53YXJuKGBSZXRyeWluZyBsaWNlbnNlIHJlcXVlc3QsICR7dX0gYXR0ZW1wdHMgbGVmdGApLCB0aGlzLnJlcXVlc3RMaWNlbnNlKGUsIHQpLnRoZW4obiwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfSwgZS5saWNlbnNlWGhyICYmIGUubGljZW5zZVhoci5yZWFkeVN0YXRlICE9PSBYTUxIdHRwUmVxdWVzdC5ET05FICYmIGUubGljZW5zZVhoci5hYm9ydCgpLCBlLmxpY2Vuc2VYaHIgPSBhLCB0aGlzLnNldHVwTGljZW5zZVhIUihhLCBvLCBlLCB0KS50aGVuKCh7XG4gICAgICAgIHhocjogbCxcbiAgICAgICAgbGljZW5zZUNoYWxsZW5nZTogY1xuICAgICAgfSkgPT4ge1xuICAgICAgICBlLmtleVN5c3RlbSA9PSBtdC5QTEFZUkVBRFkgJiYgKGMgPSB0aGlzLnVucGFja1BsYXlSZWFkeUtleU1lc3NhZ2UobCwgYykpLCBsLnNlbmQoYyk7XG4gICAgICB9KS5jYXRjaChpKTtcbiAgICB9KTtcbiAgfVxuICBvbkRlc3Ryb3lpbmcoKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCksIHRoaXMuX2NsZWFyKCk7XG4gIH1cbiAgb25NZWRpYUF0dGFjaGVkKGUsIHQpIHtcbiAgICBpZiAoIXRoaXMuY29uZmlnLmVtZUVuYWJsZWQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IHQubWVkaWE7XG4gICAgdGhpcy5tZWRpYSA9IHIsIGNyKHIsIFwiZW5jcnlwdGVkXCIsIHRoaXMub25NZWRpYUVuY3J5cHRlZCksIGNyKHIsIFwid2FpdGluZ2ZvcmtleVwiLCB0aGlzLm9uV2FpdGluZ0ZvcktleSk7XG4gIH1cbiAgb25NZWRpYURldGFjaGVkKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm1lZGlhO1xuICAgIGUgJiYgKHByKGUsIFwiZW5jcnlwdGVkXCIsIHRoaXMub25NZWRpYUVuY3J5cHRlZCksIHByKGUsIFwid2FpdGluZ2ZvcmtleVwiLCB0aGlzLm9uV2FpdGluZ0ZvcktleSksIHRoaXMubWVkaWEgPSBudWxsLCB0aGlzLm1lZGlhS2V5cyA9IG51bGwpO1xuICB9XG4gIF9jbGVhcigpIHtcbiAgICB2YXIgZTtcbiAgICBpZiAodGhpcy5fcmVxdWVzdExpY2Vuc2VGYWlsdXJlQ291bnQgPSAwLCB0aGlzLmtleUlkVG9LZXlTZXNzaW9uUHJvbWlzZSA9IHt9LCB0aGlzLmJhbm5lZEtleUlkcyA9IHt9LCAhdGhpcy5tZWRpYUtleXMgJiYgIXRoaXMubWVkaWFLZXlTZXNzaW9ucy5sZW5ndGgpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMubWVkaWEsIHIgPSB0aGlzLm1lZGlhS2V5U2Vzc2lvbnMuc2xpY2UoKTtcbiAgICB0aGlzLm1lZGlhS2V5U2Vzc2lvbnMgPSBbXSwgdGhpcy5tZWRpYUtleXMgPSBudWxsLCB5aS5jbGVhcktleVVyaVRvS2V5SWRNYXAoKTtcbiAgICBjb25zdCBuID0gci5sZW5ndGg7XG4gICAgX24uQ0RNQ2xlYW51cFByb21pc2UgPSBQcm9taXNlLmFsbChyLm1hcCgoaSkgPT4gdGhpcy5yZW1vdmVTZXNzaW9uKGkpKS5jb25jYXQoKHQgPT0gbnVsbCB8fCAoZSA9IHQuc2V0TWVkaWFLZXlzKG51bGwpKSA9PSBudWxsID8gdm9pZCAwIDogZS5jYXRjaCgoaSkgPT4ge1xuICAgICAgdGhpcy5sb2coYENvdWxkIG5vdCBjbGVhciBtZWRpYSBrZXlzOiAke2l9YCksIHRoaXMuaGxzICYmIHRoaXMuaGxzLnRyaWdnZXIoSS5FUlJPUiwge1xuICAgICAgICB0eXBlOiB2ZS5PVEhFUl9FUlJPUixcbiAgICAgICAgZGV0YWlsczogSi5LRVlfU1lTVEVNX0RFU1RST1lfTUVESUFfS0VZU19FUlJPUixcbiAgICAgICAgZmF0YWw6ICExLFxuICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBDb3VsZCBub3QgY2xlYXIgbWVkaWEga2V5czogJHtpfWApXG4gICAgICB9KTtcbiAgICB9KSkgfHwgUHJvbWlzZS5yZXNvbHZlKCkpKS5jYXRjaCgoaSkgPT4ge1xuICAgICAgdGhpcy5sb2coYENvdWxkIG5vdCBjbG9zZSBzZXNzaW9ucyBhbmQgY2xlYXIgbWVkaWEga2V5czogJHtpfWApLCB0aGlzLmhscyAmJiB0aGlzLmhscy50cmlnZ2VyKEkuRVJST1IsIHtcbiAgICAgICAgdHlwZTogdmUuT1RIRVJfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEouS0VZX1NZU1RFTV9ERVNUUk9ZX0NMT1NFX1NFU1NJT05fRVJST1IsXG4gICAgICAgIGZhdGFsOiAhMSxcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihgQ291bGQgbm90IGNsb3NlIHNlc3Npb25zIGFuZCBjbGVhciBtZWRpYSBrZXlzOiAke2l9YClcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4oKCkgPT4ge1xuICAgICAgbiAmJiB0aGlzLmxvZyhcImZpbmlzaGVkIGNsb3Npbmcga2V5IHNlc3Npb25zIGFuZCBjbGVhcmluZyBtZWRpYSBrZXlzXCIpO1xuICAgIH0pO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMua2V5Rm9ybWF0UHJvbWlzZSA9IG51bGwsIHRoaXMuYmFubmVkS2V5SWRzID0ge307XG4gIH1cbiAgb25NYW5pZmVzdExvYWRlZChlLCB7XG4gICAgc2Vzc2lvbktleXM6IHRcbiAgfSkge1xuICAgIGlmICghKCF0IHx8ICF0aGlzLmNvbmZpZy5lbWVFbmFibGVkKSAmJiAhdGhpcy5rZXlGb3JtYXRQcm9taXNlKSB7XG4gICAgICBjb25zdCByID0gdC5yZWR1Y2UoKG4sIGkpID0+IChuLmluZGV4T2YoaS5rZXlGb3JtYXQpID09PSAtMSAmJiBuLnB1c2goaS5rZXlGb3JtYXQpLCBuKSwgW10pO1xuICAgICAgdGhpcy5sb2coYFNlbGVjdGluZyBrZXktc3lzdGVtIGZyb20gc2Vzc2lvbi1rZXlzICR7ci5qb2luKFwiLCBcIil9YCksIHRoaXMua2V5Rm9ybWF0UHJvbWlzZSA9IHRoaXMuZ2V0S2V5Rm9ybWF0UHJvbWlzZShyKTtcbiAgICB9XG4gIH1cbiAgcmVtb3ZlU2Vzc2lvbihlKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWFLZXlzU2Vzc2lvbjogdCxcbiAgICAgIGxpY2Vuc2VYaHI6IHIsXG4gICAgICBkZWNyeXB0ZGF0YTogblxuICAgIH0gPSBlO1xuICAgIGlmICh0KSB7XG4gICAgICB0aGlzLmxvZyhgUmVtb3ZlIGxpY2Vuc2VzIGFuZCBrZXlzIGFuZCBjbG9zZSBzZXNzaW9uIFwiJHt0LnNlc3Npb25JZH1cIiBrZXlJZDogJHtmcigobiA9PSBudWxsID8gdm9pZCAwIDogbi5rZXlJZCkgfHwgW10pfWApLCBlLl9vbm1lc3NhZ2UgJiYgKHQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZS5fb25tZXNzYWdlKSwgZS5fb25tZXNzYWdlID0gdm9pZCAwKSwgZS5fb25rZXlzdGF0dXNlc2NoYW5nZSAmJiAodC5yZW1vdmVFdmVudExpc3RlbmVyKFwia2V5c3RhdHVzZXNjaGFuZ2VcIiwgZS5fb25rZXlzdGF0dXNlc2NoYW5nZSksIGUuX29ua2V5c3RhdHVzZXNjaGFuZ2UgPSB2b2lkIDApLCByICYmIHIucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSAmJiByLmFib3J0KCksIGUubWVkaWFLZXlzU2Vzc2lvbiA9IGUuZGVjcnlwdGRhdGEgPSBlLmxpY2Vuc2VYaHIgPSB2b2lkIDA7XG4gICAgICBjb25zdCBpID0gdGhpcy5tZWRpYUtleVNlc3Npb25zLmluZGV4T2YoZSk7XG4gICAgICBpID4gLTEgJiYgdGhpcy5tZWRpYUtleVNlc3Npb25zLnNwbGljZShpLCAxKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAga2V5U3RhdHVzVGltZW91dHM6IG9cbiAgICAgIH0gPSBlO1xuICAgICAgbyAmJiBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKChjKSA9PiBzZWxmLmNsZWFyVGltZW91dChvW2NdKSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRybVN5c3RlbU9wdGlvbnM6IGFcbiAgICAgIH0gPSB0aGlzLmNvbmZpZztcbiAgICAgIHJldHVybiAoamIoYSkgPyBuZXcgUHJvbWlzZSgoYywgdSkgPT4ge1xuICAgICAgICBzZWxmLnNldFRpbWVvdXQoKCkgPT4gdShuZXcgRXJyb3IoXCJNZWRpYUtleVNlc3Npb24ucmVtb3ZlKCkgdGltZW91dFwiKSksIDhlMyksIHQucmVtb3ZlKCkudGhlbihjKS5jYXRjaCh1KTtcbiAgICAgIH0pIDogUHJvbWlzZS5yZXNvbHZlKCkpLmNhdGNoKChjKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBDb3VsZCBub3QgcmVtb3ZlIHNlc3Npb246ICR7Y31gKSwgdGhpcy5obHMgJiYgdGhpcy5obHMudHJpZ2dlcihJLkVSUk9SLCB7XG4gICAgICAgICAgdHlwZTogdmUuT1RIRVJfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogSi5LRVlfU1lTVEVNX0RFU1RST1lfUkVNT1ZFX1NFU1NJT05fRVJST1IsXG4gICAgICAgICAgZmF0YWw6ICExLFxuICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoYENvdWxkIG5vdCByZW1vdmUgc2Vzc2lvbjogJHtjfWApXG4gICAgICAgIH0pO1xuICAgICAgfSkudGhlbigoKSA9PiB0LmNsb3NlKCkpLmNhdGNoKChjKSA9PiB7XG4gICAgICAgIHRoaXMubG9nKGBDb3VsZCBub3QgY2xvc2Ugc2Vzc2lvbjogJHtjfWApLCB0aGlzLmhscyAmJiB0aGlzLmhscy50cmlnZ2VyKEkuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiB2ZS5PVEhFUl9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBKLktFWV9TWVNURU1fREVTVFJPWV9DTE9TRV9TRVNTSU9OX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiAhMSxcbiAgICAgICAgICBlcnJvcjogbmV3IEVycm9yKGBDb3VsZCBub3QgY2xvc2Ugc2Vzc2lvbjogJHtjfWApXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfVxufVxuX24uQ0RNQ2xlYW51cFByb21pc2UgPSB2b2lkIDA7XG5mdW5jdGlvbiBKaShzKSB7XG4gIGlmICghcylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcmVhZCBrZXlJZCBvZiB1bmRlZmluZWQgZGVjcnlwdGRhdGFcIik7XG4gIGlmIChzLmtleUlkID09PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcImtleUlkIGlzIG51bGxcIik7XG4gIHJldHVybiBmcihzLmtleUlkKTtcbn1cbmZ1bmN0aW9uIGx3KHMsIGUpIHtcbiAgaWYgKHMua2V5SWQgJiYgZS5tZWRpYUtleXNTZXNzaW9uLmtleVN0YXR1c2VzLmhhcyhzLmtleUlkKSlcbiAgICByZXR1cm4gZS5tZWRpYUtleXNTZXNzaW9uLmtleVN0YXR1c2VzLmdldChzLmtleUlkKTtcbiAgaWYgKHMubWF0Y2hlcyhlLmRlY3J5cHRkYXRhKSlcbiAgICByZXR1cm4gZS5rZXlTdGF0dXM7XG59XG5jbGFzcyB5ciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKHQpLCB0aGlzLmRhdGEgPSB2b2lkIDAsIGUuZXJyb3IgfHwgKGUuZXJyb3IgPSBuZXcgRXJyb3IodCkpLCB0aGlzLmRhdGEgPSBlLCBlLmVyciA9IGUuZXJyb3I7XG4gIH1cbn1cbmZ1bmN0aW9uIFpoKHMsIGUpIHtcbiAgY29uc3QgdCA9IHMgPT09IFwib3V0cHV0LXJlc3RyaWN0ZWRcIiwgciA9IHQgPyBKLktFWV9TWVNURU1fU1RBVFVTX09VVFBVVF9SRVNUUklDVEVEIDogSi5LRVlfU1lTVEVNX1NUQVRVU19JTlRFUk5BTF9FUlJPUjtcbiAgcmV0dXJuIG5ldyB5cih7XG4gICAgdHlwZTogdmUuS0VZX1NZU1RFTV9FUlJPUixcbiAgICBkZXRhaWxzOiByLFxuICAgIGZhdGFsOiAhMSxcbiAgICBkZWNyeXB0ZGF0YTogZVxuICB9LCB0ID8gXCJIRENQIGxldmVsIG91dHB1dCByZXN0cmljdGVkXCIgOiBga2V5IHN0YXR1cyBjaGFuZ2VkIHRvIFwiJHtzfVwiYCk7XG59XG5jbGFzcyBjdyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLmhscyA9IHZvaWQgMCwgdGhpcy5pc1ZpZGVvUGxheWJhY2tRdWFsaXR5QXZhaWxhYmxlID0gITEsIHRoaXMudGltZXIgPSB2b2lkIDAsIHRoaXMubWVkaWEgPSBudWxsLCB0aGlzLmxhc3RUaW1lID0gdm9pZCAwLCB0aGlzLmxhc3REcm9wcGVkRnJhbWVzID0gMCwgdGhpcy5sYXN0RGVjb2RlZEZyYW1lcyA9IDAsIHRoaXMuc3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMCwgdGhpcy5obHMgPSBlLCB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgc2V0U3RyZWFtQ29udHJvbGxlcihlKSB7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gZTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vbihJLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKSwgdGhpcy5obHMub24oSS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICB0aGlzLmhscy5vZmYoSS5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyksIHRoaXMuaGxzLm9mZihJLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudGltZXIgJiYgY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKSwgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCksIHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSA9ICExLCB0aGlzLm1lZGlhID0gbnVsbDtcbiAgfVxuICBvbk1lZGlhQXR0YWNoaW5nKGUsIHQpIHtcbiAgICBjb25zdCByID0gdGhpcy5obHMuY29uZmlnO1xuICAgIGlmIChyLmNhcExldmVsT25GUFNEcm9wKSB7XG4gICAgICBjb25zdCBuID0gdC5tZWRpYSBpbnN0YW5jZW9mIHNlbGYuSFRNTFZpZGVvRWxlbWVudCA/IHQubWVkaWEgOiBudWxsO1xuICAgICAgdGhpcy5tZWRpYSA9IG4sIG4gJiYgdHlwZW9mIG4uZ2V0VmlkZW9QbGF5YmFja1F1YWxpdHkgPT0gXCJmdW5jdGlvblwiICYmICh0aGlzLmlzVmlkZW9QbGF5YmFja1F1YWxpdHlBdmFpbGFibGUgPSAhMCksIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVyKSwgdGhpcy50aW1lciA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5jaGVja0ZQU0ludGVydmFsLmJpbmQodGhpcyksIHIuZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2QpO1xuICAgIH1cbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKCkge1xuICAgIHRoaXMubWVkaWEgPSBudWxsO1xuICB9XG4gIGNoZWNrRlBTKGUsIHQsIHIpIHtcbiAgICBjb25zdCBuID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgaWYgKHQpIHtcbiAgICAgIGlmICh0aGlzLmxhc3RUaW1lKSB7XG4gICAgICAgIGNvbnN0IGkgPSBuIC0gdGhpcy5sYXN0VGltZSwgbyA9IHIgLSB0aGlzLmxhc3REcm9wcGVkRnJhbWVzLCBhID0gdCAtIHRoaXMubGFzdERlY29kZWRGcmFtZXMsIGwgPSAxZTMgKiBvIC8gaSwgYyA9IHRoaXMuaGxzO1xuICAgICAgICBpZiAoYy50cmlnZ2VyKEkuRlBTX0RST1AsIHtcbiAgICAgICAgICBjdXJyZW50RHJvcHBlZDogbyxcbiAgICAgICAgICBjdXJyZW50RGVjb2RlZDogYSxcbiAgICAgICAgICB0b3RhbERyb3BwZWRGcmFtZXM6IHJcbiAgICAgICAgfSksIGwgPiAwICYmIG8gPiBjLmNvbmZpZy5mcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZCAqIGEpIHtcbiAgICAgICAgICBsZXQgdSA9IGMuY3VycmVudExldmVsO1xuICAgICAgICAgIGMubG9nZ2VyLndhcm4oXCJkcm9wIEZQUyByYXRpbyBncmVhdGVyIHRoYW4gbWF4IGFsbG93ZWQgdmFsdWUgZm9yIGN1cnJlbnRMZXZlbDogXCIgKyB1KSwgdSA+IDAgJiYgKGMuYXV0b0xldmVsQ2FwcGluZyA9PT0gLTEgfHwgYy5hdXRvTGV2ZWxDYXBwaW5nID49IHUpICYmICh1ID0gdSAtIDEsIGMudHJpZ2dlcihJLkZQU19EUk9QX0xFVkVMX0NBUFBJTkcsIHtcbiAgICAgICAgICAgIGxldmVsOiB1LFxuICAgICAgICAgICAgZHJvcHBlZExldmVsOiBjLmN1cnJlbnRMZXZlbFxuICAgICAgICAgIH0pLCBjLmF1dG9MZXZlbENhcHBpbmcgPSB1LCB0aGlzLnN0cmVhbUNvbnRyb2xsZXIubmV4dExldmVsU3dpdGNoKCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxhc3RUaW1lID0gbiwgdGhpcy5sYXN0RHJvcHBlZEZyYW1lcyA9IHIsIHRoaXMubGFzdERlY29kZWRGcmFtZXMgPSB0O1xuICAgIH1cbiAgfVxuICBjaGVja0ZQU0ludGVydmFsKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm1lZGlhO1xuICAgIGlmIChlKVxuICAgICAgaWYgKHRoaXMuaXNWaWRlb1BsYXliYWNrUXVhbGl0eUF2YWlsYWJsZSkge1xuICAgICAgICBjb25zdCB0ID0gZS5nZXRWaWRlb1BsYXliYWNrUXVhbGl0eSgpO1xuICAgICAgICB0aGlzLmNoZWNrRlBTKGUsIHQudG90YWxWaWRlb0ZyYW1lcywgdC5kcm9wcGVkVmlkZW9GcmFtZXMpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHRoaXMuY2hlY2tGUFMoZSwgZS53ZWJraXREZWNvZGVkRnJhbWVDb3VudCwgZS53ZWJraXREcm9wcGVkRnJhbWVDb3VudCk7XG4gIH1cbn1cbmZ1bmN0aW9uIE5wKHMsIGUpIHtcbiAgbGV0IHQ7XG4gIHRyeSB7XG4gICAgdCA9IG5ldyBFdmVudChcImFkZHRyYWNrXCIpO1xuICB9IGNhdGNoIHtcbiAgICB0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKSwgdC5pbml0RXZlbnQoXCJhZGR0cmFja1wiLCAhMSwgITEpO1xuICB9XG4gIHQudHJhY2sgPSBzLCBlLmRpc3BhdGNoRXZlbnQodCk7XG59XG5mdW5jdGlvbiBVcChzLCBlKSB7XG4gIGNvbnN0IHQgPSBzLm1vZGU7XG4gIGlmICh0ID09PSBcImRpc2FibGVkXCIgJiYgKHMubW9kZSA9IFwiaGlkZGVuXCIpLCBzLmN1ZXMgJiYgIXMuY3Vlcy5nZXRDdWVCeUlkKGUuaWQpKVxuICAgIHRyeSB7XG4gICAgICBpZiAocy5hZGRDdWUoZSksICFzLmN1ZXMuZ2V0Q3VlQnlJZChlLmlkKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBhZGRDdWUgaXMgZmFpbGVkIGZvcjogJHtlfWApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIHJ0LmRlYnVnKGBbdGV4dHRyYWNrLXV0aWxzXTogJHtyfWApO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbiA9IG5ldyBzZWxmLlRleHRUcmFja0N1ZShlLnN0YXJ0VGltZSwgZS5lbmRUaW1lLCBlLnRleHQpO1xuICAgICAgICBuLmlkID0gZS5pZCwgcy5hZGRDdWUobik7XG4gICAgICB9IGNhdGNoIChuKSB7XG4gICAgICAgIHJ0LmRlYnVnKGBbdGV4dHRyYWNrLXV0aWxzXTogTGVnYWN5IFRleHRUcmFja0N1ZSBmYWxsYmFjayBmYWlsZWQ6ICR7bn1gKTtcbiAgICAgIH1cbiAgICB9XG4gIHQgPT09IFwiZGlzYWJsZWRcIiAmJiAocy5tb2RlID0gdCk7XG59XG5mdW5jdGlvbiBTbihzLCBlKSB7XG4gIGNvbnN0IHQgPSBzLm1vZGU7XG4gIGlmICh0ID09PSBcImRpc2FibGVkXCIgJiYgKHMubW9kZSA9IFwiaGlkZGVuXCIpLCBzLmN1ZXMpXG4gICAgZm9yIChsZXQgciA9IHMuY3Vlcy5sZW5ndGg7IHItLTsgKVxuICAgICAgZSAmJiBzLmN1ZXNbcl0ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVudGVyXCIsIGUpLCBzLnJlbW92ZUN1ZShzLmN1ZXNbcl0pO1xuICB0ID09PSBcImRpc2FibGVkXCIgJiYgKHMubW9kZSA9IHQpO1xufVxuZnVuY3Rpb24gU2MocywgZSwgdCwgcikge1xuICBjb25zdCBuID0gcy5tb2RlO1xuICBpZiAobiA9PT0gXCJkaXNhYmxlZFwiICYmIChzLm1vZGUgPSBcImhpZGRlblwiKSwgcy5jdWVzICYmIHMuY3Vlcy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgaSA9IGR3KHMuY3VlcywgZSwgdCk7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBpLmxlbmd0aDsgbysrKVxuICAgICAgKCFyIHx8IHIoaVtvXSkpICYmIHMucmVtb3ZlQ3VlKGlbb10pO1xuICB9XG4gIG4gPT09IFwiZGlzYWJsZWRcIiAmJiAocy5tb2RlID0gbik7XG59XG5mdW5jdGlvbiB1dyhzLCBlKSB7XG4gIGlmIChlIDw9IHNbMF0uc3RhcnRUaW1lKVxuICAgIHJldHVybiAwO1xuICBjb25zdCB0ID0gcy5sZW5ndGggLSAxO1xuICBpZiAoZSA+IHNbdF0uZW5kVGltZSlcbiAgICByZXR1cm4gLTE7XG4gIGxldCByID0gMCwgbiA9IHQsIGk7XG4gIGZvciAoOyByIDw9IG47IClcbiAgICBpZiAoaSA9IE1hdGguZmxvb3IoKG4gKyByKSAvIDIpLCBlIDwgc1tpXS5zdGFydFRpbWUpXG4gICAgICBuID0gaSAtIDE7XG4gICAgZWxzZSBpZiAoZSA+IHNbaV0uc3RhcnRUaW1lICYmIHIgPCB0KVxuICAgICAgciA9IGkgKyAxO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBpO1xuICByZXR1cm4gc1tyXS5zdGFydFRpbWUgLSBlIDwgZSAtIHNbbl0uc3RhcnRUaW1lID8gciA6IG47XG59XG5mdW5jdGlvbiBkdyhzLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSBbXSwgbiA9IHV3KHMsIGUpO1xuICBpZiAobiA+IC0xKVxuICAgIGZvciAobGV0IGkgPSBuLCBvID0gcy5sZW5ndGg7IGkgPCBvOyBpKyspIHtcbiAgICAgIGNvbnN0IGEgPSBzW2ldO1xuICAgICAgaWYgKGEuc3RhcnRUaW1lID49IGUgJiYgYS5lbmRUaW1lIDw9IHQpXG4gICAgICAgIHIucHVzaChhKTtcbiAgICAgIGVsc2UgaWYgKGEuc3RhcnRUaW1lID4gdClcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgfVxuICByZXR1cm4gcjtcbn1cbmZ1bmN0aW9uIEVvKHMpIHtcbiAgY29uc3QgZSA9IFtdO1xuICBmb3IgKGxldCB0ID0gMDsgdCA8IHMubGVuZ3RoOyB0KyspIHtcbiAgICBjb25zdCByID0gc1t0XTtcbiAgICAoci5raW5kID09PSBcInN1YnRpdGxlc1wiIHx8IHIua2luZCA9PT0gXCJjYXB0aW9uc1wiKSAmJiByLmxhYmVsICYmIGUucHVzaChzW3RdKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmNsYXNzIGh3IGV4dGVuZHMga3Uge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgc3VwZXIoZSwgXCJzdWJ0aXRsZS10cmFjay1jb250cm9sbGVyXCIpLCB0aGlzLm1lZGlhID0gbnVsbCwgdGhpcy50cmFja3MgPSBbXSwgdGhpcy5ncm91cElkcyA9IG51bGwsIHRoaXMudHJhY2tzSW5Hcm91cCA9IFtdLCB0aGlzLnRyYWNrSWQgPSAtMSwgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsLCB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9ICEwLCB0aGlzLnF1ZXVlZERlZmF1bHRUcmFjayA9IC0xLCB0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcgPSAhMSwgdGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCA9IC0xLCB0aGlzLl9zdWJ0aXRsZURpc3BsYXkgPSAhMCwgdGhpcy5hc3luY1BvbGxUcmFja0NoYW5nZSA9ICgpID0+IHRoaXMucG9sbFRyYWNrQ2hhbmdlKDApLCB0aGlzLm9uVGV4dFRyYWNrc0NoYW5nZWQgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nIHx8IHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsKSwgIXRoaXMubWVkaWEgfHwgIXRoaXMuaGxzLmNvbmZpZy5yZW5kZXJUZXh0VHJhY2tzTmF0aXZlbHkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGxldCB0ID0gbnVsbDtcbiAgICAgIGNvbnN0IHIgPSBFbyh0aGlzLm1lZGlhLnRleHRUcmFja3MpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAocltpXS5tb2RlID09PSBcImhpZGRlblwiKVxuICAgICAgICAgIHQgPSByW2ldO1xuICAgICAgICBlbHNlIGlmIChyW2ldLm1vZGUgPT09IFwic2hvd2luZ1wiKSB7XG4gICAgICAgICAgdCA9IHJbaV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIGNvbnN0IG4gPSB0aGlzLmZpbmRUcmFja0ZvclRleHRUcmFjayh0KTtcbiAgICAgIHRoaXMuc3VidGl0bGVUcmFjayAhPT0gbiAmJiB0aGlzLnNldFN1YnRpdGxlVHJhY2sobik7XG4gICAgfSwgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCksIHRoaXMudHJhY2tzLmxlbmd0aCA9IDAsIHRoaXMudHJhY2tzSW5Hcm91cC5sZW5ndGggPSAwLCB0aGlzLmN1cnJlbnRUcmFjayA9IG51bGwsIHRoaXMub25UZXh0VHJhY2tzQ2hhbmdlZCA9IHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UgPSBudWxsLCBzdXBlci5kZXN0cm95KCk7XG4gIH1cbiAgZ2V0IHN1YnRpdGxlRGlzcGxheSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3VidGl0bGVEaXNwbGF5O1xuICB9XG4gIHNldCBzdWJ0aXRsZURpc3BsYXkoZSkge1xuICAgIHRoaXMuX3N1YnRpdGxlRGlzcGxheSA9IGUsIHRoaXMudHJhY2tJZCA+IC0xICYmIHRoaXMudG9nZ2xlVHJhY2tNb2RlcygpO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsczogZVxuICAgIH0gPSB0aGlzO1xuICAgIGUub24oSS5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpLCBlLm9uKEkuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpLCBlLm9uKEkuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyksIGUub24oSS5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyksIGUub24oSS5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKSwgZS5vbihJLkxFVkVMX1NXSVRDSElORywgdGhpcy5vbkxldmVsU3dpdGNoaW5nLCB0aGlzKSwgZS5vbihJLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkZWQsIHRoaXMpLCBlLm9uKEkuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHM6IGVcbiAgICB9ID0gdGhpcztcbiAgICBlLm9mZihJLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyksIGUub2ZmKEkuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpLCBlLm9mZihJLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpLCBlLm9mZihJLk1BTklGRVNUX1BBUlNFRCwgdGhpcy5vbk1hbmlmZXN0UGFyc2VkLCB0aGlzKSwgZS5vZmYoSS5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKSwgZS5vZmYoSS5MRVZFTF9TV0lUQ0hJTkcsIHRoaXMub25MZXZlbFN3aXRjaGluZywgdGhpcyksIGUub2ZmKEkuU1VCVElUTEVfVFJBQ0tfTE9BREVELCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRlZCwgdGhpcyksIGUub2ZmKEkuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcyk7XG4gIH1cbiAgLy8gTGlzdGVuIGZvciBzdWJ0aXRsZSB0cmFjayBjaGFuZ2UsIHRoZW4gZXh0cmFjdCB0aGUgY3VycmVudCB0cmFjayBJRC5cbiAgb25NZWRpYUF0dGFjaGVkKGUsIHQpIHtcbiAgICB0aGlzLm1lZGlhID0gdC5tZWRpYSwgdGhpcy5tZWRpYSAmJiAodGhpcy5xdWV1ZWREZWZhdWx0VHJhY2sgPiAtMSAmJiAodGhpcy5zdWJ0aXRsZVRyYWNrID0gdGhpcy5xdWV1ZWREZWZhdWx0VHJhY2ssIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gLTEpLCB0aGlzLnVzZVRleHRUcmFja1BvbGxpbmcgPSAhKHRoaXMubWVkaWEudGV4dFRyYWNrcyAmJiBcIm9uY2hhbmdlXCIgaW4gdGhpcy5tZWRpYS50ZXh0VHJhY2tzKSwgdGhpcy51c2VUZXh0VHJhY2tQb2xsaW5nID8gdGhpcy5wb2xsVHJhY2tDaGFuZ2UoNTAwKSA6IHRoaXMubWVkaWEudGV4dFRyYWNrcy5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIHRoaXMuYXN5bmNQb2xsVHJhY2tDaGFuZ2UpKTtcbiAgfVxuICBwb2xsVHJhY2tDaGFuZ2UoZSkge1xuICAgIHNlbGYuY2xlYXJJbnRlcnZhbCh0aGlzLnN1YnRpdGxlUG9sbGluZ0ludGVydmFsKSwgdGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCA9IHNlbGYuc2V0SW50ZXJ2YWwodGhpcy5vblRleHRUcmFja3NDaGFuZ2VkLCBlKTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKGUsIHQpIHtcbiAgICBjb25zdCByID0gdGhpcy5tZWRpYTtcbiAgICBpZiAoIXIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbiA9ICEhdC50cmFuc2Zlck1lZGlhO1xuICAgIGlmIChzZWxmLmNsZWFySW50ZXJ2YWwodGhpcy5zdWJ0aXRsZVBvbGxpbmdJbnRlcnZhbCksIHRoaXMudXNlVGV4dFRyYWNrUG9sbGluZyB8fCByLnRleHRUcmFja3MucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLmFzeW5jUG9sbFRyYWNrQ2hhbmdlKSwgdGhpcy50cmFja0lkID4gLTEgJiYgKHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gdGhpcy50cmFja0lkKSwgdGhpcy5zdWJ0aXRsZVRyYWNrID0gLTEsIHRoaXMubWVkaWEgPSBudWxsLCBuKVxuICAgICAgcmV0dXJuO1xuICAgIEVvKHIudGV4dFRyYWNrcykuZm9yRWFjaCgobykgPT4ge1xuICAgICAgU24obyk7XG4gICAgfSk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdGhpcy50cmFja3MgPSBbXSwgdGhpcy5ncm91cElkcyA9IG51bGwsIHRoaXMudHJhY2tzSW5Hcm91cCA9IFtdLCB0aGlzLnRyYWNrSWQgPSAtMSwgdGhpcy5jdXJyZW50VHJhY2sgPSBudWxsLCB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9ICEwO1xuICB9XG4gIC8vIEZpcmVkIHdoZW5ldmVyIGEgbmV3IG1hbmlmZXN0IGlzIGxvYWRlZC5cbiAgb25NYW5pZmVzdFBhcnNlZChlLCB0KSB7XG4gICAgdGhpcy50cmFja3MgPSB0LnN1YnRpdGxlVHJhY2tzO1xuICB9XG4gIG9uU3VidGl0bGVUcmFja0xvYWRlZChlLCB0KSB7XG4gICAgY29uc3Qge1xuICAgICAgaWQ6IHIsXG4gICAgICBncm91cElkOiBuLFxuICAgICAgZGV0YWlsczogaVxuICAgIH0gPSB0LCBvID0gdGhpcy50cmFja3NJbkdyb3VwW3JdO1xuICAgIGlmICghbyB8fCBvLmdyb3VwSWQgIT09IG4pIHtcbiAgICAgIHRoaXMud2FybihgU3VidGl0bGUgdHJhY2sgd2l0aCBpZDoke3J9IGFuZCBncm91cDoke259IG5vdCBmb3VuZCBpbiBhY3RpdmUgZ3JvdXAgJHtvID09IG51bGwgPyB2b2lkIDAgOiBvLmdyb3VwSWR9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGEgPSBvLmRldGFpbHM7XG4gICAgby5kZXRhaWxzID0gdC5kZXRhaWxzLCB0aGlzLmxvZyhgU3VidGl0bGUgdHJhY2sgJHtyfSBcIiR7by5uYW1lfVwiIGxhbmc6JHtvLmxhbmd9IGdyb3VwOiR7bn0gbG9hZGVkIFske2kuc3RhcnRTTn0tJHtpLmVuZFNOfV1gKSwgciA9PT0gdGhpcy50cmFja0lkICYmIHRoaXMucGxheWxpc3RMb2FkZWQociwgdCwgYSk7XG4gIH1cbiAgb25MZXZlbExvYWRpbmcoZSwgdCkge1xuICAgIHRoaXMuc3dpdGNoTGV2ZWwodC5sZXZlbCk7XG4gIH1cbiAgb25MZXZlbFN3aXRjaGluZyhlLCB0KSB7XG4gICAgdGhpcy5zd2l0Y2hMZXZlbCh0LmxldmVsKTtcbiAgfVxuICBzd2l0Y2hMZXZlbChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuaGxzLmxldmVsc1tlXTtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IHQuc3VidGl0bGVHcm91cHMgfHwgbnVsbCwgbiA9IHRoaXMuZ3JvdXBJZHM7XG4gICAgbGV0IGkgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICBpZiAoIXIgfHwgKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4ubGVuZ3RoKSAhPT0gKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIubGVuZ3RoKSB8fCByICE9IG51bGwgJiYgci5zb21lKChvKSA9PiAobiA9PSBudWxsID8gdm9pZCAwIDogbi5pbmRleE9mKG8pKSA9PT0gLTEpKSB7XG4gICAgICB0aGlzLmdyb3VwSWRzID0gciwgdGhpcy50cmFja0lkID0gLTEsIHRoaXMuY3VycmVudFRyYWNrID0gbnVsbDtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLnRyYWNrcy5maWx0ZXIoKHUpID0+ICFyIHx8IHIuaW5kZXhPZih1Lmdyb3VwSWQpICE9PSAtMSk7XG4gICAgICBpZiAoby5sZW5ndGgpXG4gICAgICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrICYmICFvLnNvbWUoKHUpID0+IHUuZGVmYXVsdCkgJiYgKHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gITEpLCBvLmZvckVhY2goKHUsIGQpID0+IHtcbiAgICAgICAgICB1LmlkID0gZDtcbiAgICAgICAgfSk7XG4gICAgICBlbHNlIGlmICghaSAmJiAhdGhpcy50cmFja3NJbkdyb3VwLmxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy50cmFja3NJbkdyb3VwID0gbztcbiAgICAgIGNvbnN0IGEgPSB0aGlzLmhscy5jb25maWcuc3VidGl0bGVQcmVmZXJlbmNlO1xuICAgICAgaWYgKCFpICYmIGEpIHtcbiAgICAgICAgdGhpcy5zZWxlY3REZWZhdWx0VHJhY2sgPSAhMTtcbiAgICAgICAgY29uc3QgdSA9IFdyKGEsIG8pO1xuICAgICAgICBpZiAodSA+IC0xKVxuICAgICAgICAgIGkgPSBvW3VdO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBjb25zdCBkID0gV3IoYSwgdGhpcy50cmFja3MpO1xuICAgICAgICAgIGkgPSB0aGlzLnRyYWNrc1tkXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGV0IGwgPSB0aGlzLmZpbmRUcmFja0lkKGkpO1xuICAgICAgbCA9PT0gLTEgJiYgaSAmJiAobCA9IHRoaXMuZmluZFRyYWNrSWQobnVsbCkpO1xuICAgICAgY29uc3QgYyA9IHtcbiAgICAgICAgc3VidGl0bGVUcmFja3M6IG9cbiAgICAgIH07XG4gICAgICB0aGlzLmxvZyhgVXBkYXRpbmcgc3VidGl0bGUgdHJhY2tzLCAke28ubGVuZ3RofSB0cmFjayhzKSBmb3VuZCBpbiBcIiR7ciA9PSBudWxsID8gdm9pZCAwIDogci5qb2luKFwiLFwiKX1cIiBncm91cC1pZGApLCB0aGlzLmhscy50cmlnZ2VyKEkuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIGMpLCBsICE9PSAtMSAmJiB0aGlzLnRyYWNrSWQgPT09IC0xICYmIHRoaXMuc2V0U3VidGl0bGVUcmFjayhsKTtcbiAgICB9XG4gIH1cbiAgZmluZFRyYWNrSWQoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnRyYWNrc0luR3JvdXAsIHIgPSB0aGlzLnNlbGVjdERlZmF1bHRUcmFjaztcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHtcbiAgICAgIGNvbnN0IGkgPSB0W25dO1xuICAgICAgaWYgKCEociAmJiAhaS5kZWZhdWx0IHx8ICFyICYmICFlKSAmJiAoIWUgfHwgcXMoaSwgZSkpKVxuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgaWYgKGUpIHtcbiAgICAgIGZvciAobGV0IG4gPSAwOyBuIDwgdC5sZW5ndGg7IG4rKykge1xuICAgICAgICBjb25zdCBpID0gdFtuXTtcbiAgICAgICAgaWYgKFNpKGUuYXR0cnMsIGkuYXR0cnMsIFtcIkxBTkdVQUdFXCIsIFwiQVNTT0MtTEFOR1VBR0VcIiwgXCJDSEFSQUNURVJJU1RJQ1NcIl0pKVxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCB0Lmxlbmd0aDsgbisrKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0W25dO1xuICAgICAgICBpZiAoU2koZS5hdHRycywgaS5hdHRycywgW1wiTEFOR1VBR0VcIl0pKVxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZmluZFRyYWNrRm9yVGV4dFRyYWNrKGUpIHtcbiAgICBpZiAoZSkge1xuICAgICAgY29uc3QgdCA9IHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKykge1xuICAgICAgICBjb25zdCBuID0gdFtyXTtcbiAgICAgICAgaWYgKHljKG4sIGUpKVxuICAgICAgICAgIHJldHVybiByO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgb25FcnJvcihlLCB0KSB7XG4gICAgdC5mYXRhbCB8fCAhdC5jb250ZXh0IHx8IHQuY29udGV4dC50eXBlID09PSBLZS5TVUJUSVRMRV9UUkFDSyAmJiB0LmNvbnRleHQuaWQgPT09IHRoaXMudHJhY2tJZCAmJiAoIXRoaXMuZ3JvdXBJZHMgfHwgdGhpcy5ncm91cElkcy5pbmRleE9mKHQuY29udGV4dC5ncm91cElkKSAhPT0gLTEpICYmIHRoaXMuY2hlY2tSZXRyeSh0KTtcbiAgfVxuICBnZXQgYWxsU3VidGl0bGVUcmFja3MoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhY2tzO1xuICB9XG4gIC8qKiBnZXQgYWx0ZXJuYXRlIHN1YnRpdGxlIHRyYWNrcyBsaXN0IGZyb20gcGxheWxpc3QgKiovXG4gIGdldCBzdWJ0aXRsZVRyYWNrcygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja3NJbkdyb3VwO1xuICB9XG4gIC8qKiBnZXQvc2V0IGluZGV4IG9mIHRoZSBzZWxlY3RlZCBzdWJ0aXRsZSB0cmFjayAoYmFzZWQgb24gaW5kZXggaW4gc3VidGl0bGUgdHJhY2sgbGlzdHMpICoqL1xuICBnZXQgc3VidGl0bGVUcmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja0lkO1xuICB9XG4gIHNldCBzdWJ0aXRsZVRyYWNrKGUpIHtcbiAgICB0aGlzLnNlbGVjdERlZmF1bHRUcmFjayA9ICExLCB0aGlzLnNldFN1YnRpdGxlVHJhY2soZSk7XG4gIH1cbiAgc2V0U3VidGl0bGVPcHRpb24oZSkge1xuICAgIGlmICh0aGlzLmhscy5jb25maWcuc3VidGl0bGVQcmVmZXJlbmNlID0gZSwgZSkge1xuICAgICAgaWYgKGUuaWQgPT09IC0xKVxuICAgICAgICByZXR1cm4gdGhpcy5zZXRTdWJ0aXRsZVRyYWNrKC0xKSwgbnVsbDtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLmFsbFN1YnRpdGxlVHJhY2tzO1xuICAgICAgaWYgKHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gITEsIHQubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHIgPSB0aGlzLmN1cnJlbnRUcmFjaztcbiAgICAgICAgaWYgKHIgJiYgcXMoZSwgcikpXG4gICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIGNvbnN0IG4gPSBXcihlLCB0aGlzLnRyYWNrc0luR3JvdXApO1xuICAgICAgICBpZiAobiA+IC0xKSB7XG4gICAgICAgICAgY29uc3QgaSA9IHRoaXMudHJhY2tzSW5Hcm91cFtuXTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXRTdWJ0aXRsZVRyYWNrKG4pLCBpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChyKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgaSA9IFdyKGUsIHQpO1xuICAgICAgICAgICAgaWYgKGkgPiAtMSlcbiAgICAgICAgICAgICAgcmV0dXJuIHRbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxvYWRQbGF5bGlzdChlKSB7XG4gICAgc3VwZXIubG9hZFBsYXlsaXN0KCksIHRoaXMuc2hvdWxkTG9hZFBsYXlsaXN0KHRoaXMuY3VycmVudFRyYWNrKSAmJiB0aGlzLnNjaGVkdWxlTG9hZGluZyh0aGlzLmN1cnJlbnRUcmFjaywgZSk7XG4gIH1cbiAgbG9hZGluZ1BsYXlsaXN0KGUsIHQpIHtcbiAgICBzdXBlci5sb2FkaW5nUGxheWxpc3QoZSwgdCk7XG4gICAgY29uc3QgciA9IGUuaWQsIG4gPSBlLmdyb3VwSWQsIGkgPSB0aGlzLmdldFVybFdpdGhEaXJlY3RpdmVzKGUudXJsLCB0KSwgbyA9IGUuZGV0YWlscywgYSA9IG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uYWdlO1xuICAgIHRoaXMubG9nKGBMb2FkaW5nIHN1YnRpdGxlICR7cn0gXCIke2UubmFtZX1cIiBsYW5nOiR7ZS5sYW5nfSBncm91cDoke259JHsodCA9PSBudWxsID8gdm9pZCAwIDogdC5tc24pICE9PSB2b2lkIDAgPyBcIiBhdCBzbiBcIiArIHQubXNuICsgXCIgcGFydCBcIiArIHQucGFydCA6IFwiXCJ9JHthICYmIG8ubGl2ZSA/IFwiIGFnZSBcIiArIGEudG9GaXhlZCgxKSArIChvLnR5cGUgJiYgXCIgXCIgKyBvLnR5cGUgfHwgXCJcIikgOiBcIlwifSAke2l9YCksIHRoaXMuaGxzLnRyaWdnZXIoSS5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB7XG4gICAgICB1cmw6IGksXG4gICAgICBpZDogcixcbiAgICAgIGdyb3VwSWQ6IG4sXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IHQgfHwgbnVsbCxcbiAgICAgIHRyYWNrOiBlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2FibGVzIHRoZSBvbGQgc3VidGl0bGVUcmFjayBhbmQgc2V0cyBjdXJyZW50IG1vZGUgb24gdGhlIG5leHQgc3VidGl0bGVUcmFjay5cbiAgICogVGhpcyBvcGVyYXRlcyBvbiB0aGUgRE9NIHRleHRUcmFja3MuXG4gICAqIEEgdmFsdWUgb2YgLTEgd2lsbCBkaXNhYmxlIGFsbCBzdWJ0aXRsZSB0cmFja3MuXG4gICAqL1xuICB0b2dnbGVUcmFja01vZGVzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhOiBlXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBFbyhlLnRleHRUcmFja3MpLCByID0gdGhpcy5jdXJyZW50VHJhY2s7XG4gICAgbGV0IG47XG4gICAgaWYgKHIgJiYgKG4gPSB0LmZpbHRlcigoaSkgPT4geWMociwgaSkpWzBdLCBuIHx8IHRoaXMud2FybihgVW5hYmxlIHRvIGZpbmQgc3VidGl0bGUgVGV4dFRyYWNrIHdpdGggbmFtZSBcIiR7ci5uYW1lfVwiIGFuZCBsYW5ndWFnZSBcIiR7ci5sYW5nfVwiYCkpLCBbXS5zbGljZS5jYWxsKHQpLmZvckVhY2goKGkpID0+IHtcbiAgICAgIGkubW9kZSAhPT0gXCJkaXNhYmxlZFwiICYmIGkgIT09IG4gJiYgKGkubW9kZSA9IFwiZGlzYWJsZWRcIik7XG4gICAgfSksIG4pIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLnN1YnRpdGxlRGlzcGxheSA/IFwic2hvd2luZ1wiIDogXCJoaWRkZW5cIjtcbiAgICAgIG4ubW9kZSAhPT0gaSAmJiAobi5tb2RlID0gaSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBpcyByZXNwb25zaWJsZSBmb3IgdmFsaWRhdGluZyB0aGUgc3VidGl0bGUgaW5kZXggYW5kIHBlcmlvZGljYWxseSByZWxvYWRpbmcgaWYgbGl2ZS5cbiAgICogRGlzcGF0Y2hlcyB0aGUgU1VCVElUTEVfVFJBQ0tfU1dJVENIIGV2ZW50LCB3aGljaCBpbnN0cnVjdHMgdGhlIHN1YnRpdGxlLXN0cmVhbS1jb250cm9sbGVyIHRvIGxvYWQgdGhlIHNlbGVjdGVkIHRyYWNrLlxuICAgKi9cbiAgc2V0U3VidGl0bGVUcmFjayhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMudHJhY2tzSW5Hcm91cDtcbiAgICBpZiAoIXRoaXMubWVkaWEpIHtcbiAgICAgIHRoaXMucXVldWVkRGVmYXVsdFRyYWNrID0gZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGUgPCAtMSB8fCBlID49IHQubGVuZ3RoIHx8ICF1ZShlKSkge1xuICAgICAgdGhpcy53YXJuKGBJbnZhbGlkIHN1YnRpdGxlIHRyYWNrIGlkOiAke2V9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2VsZWN0RGVmYXVsdFRyYWNrID0gITE7XG4gICAgY29uc3QgciA9IHRoaXMuY3VycmVudFRyYWNrLCBuID0gdFtlXSB8fCBudWxsO1xuICAgIGlmICh0aGlzLnRyYWNrSWQgPSBlLCB0aGlzLmN1cnJlbnRUcmFjayA9IG4sIHRoaXMudG9nZ2xlVHJhY2tNb2RlcygpLCAhbikge1xuICAgICAgdGhpcy5obHMudHJpZ2dlcihJLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwge1xuICAgICAgICBpZDogZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGkgPSAhIW4uZGV0YWlscyAmJiAhbi5kZXRhaWxzLmxpdmU7XG4gICAgaWYgKGUgPT09IHRoaXMudHJhY2tJZCAmJiBuID09PSByICYmIGkpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5sb2coYFN3aXRjaGluZyB0byBzdWJ0aXRsZS10cmFjayAke2V9YCArIChuID8gYCBcIiR7bi5uYW1lfVwiIGxhbmc6JHtuLmxhbmd9IGdyb3VwOiR7bi5ncm91cElkfWAgOiBcIlwiKSk7XG4gICAgY29uc3Qge1xuICAgICAgaWQ6IG8sXG4gICAgICBncm91cElkOiBhID0gXCJcIixcbiAgICAgIG5hbWU6IGwsXG4gICAgICB0eXBlOiBjLFxuICAgICAgdXJsOiB1XG4gICAgfSA9IG47XG4gICAgdGhpcy5obHMudHJpZ2dlcihJLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwge1xuICAgICAgaWQ6IG8sXG4gICAgICBncm91cElkOiBhLFxuICAgICAgbmFtZTogbCxcbiAgICAgIHR5cGU6IGMsXG4gICAgICB1cmw6IHVcbiAgICB9KTtcbiAgICBjb25zdCBkID0gdGhpcy5zd2l0Y2hQYXJhbXMobi51cmwsIHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuZGV0YWlscywgbi5kZXRhaWxzKTtcbiAgICB0aGlzLmxvYWRQbGF5bGlzdChkKTtcbiAgfVxufVxuZnVuY3Rpb24gZncoKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKCk7XG4gIH0gY2F0Y2gge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBlID0gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYigpKSwgdCA9IGUudG9TdHJpbmcoKTtcbiAgICAgIHJldHVybiBVUkwucmV2b2tlT2JqZWN0VVJMKGUpLCB0LnNsaWNlKHQubGFzdEluZGV4T2YoXCIvXCIpICsgMSk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBsZXQgdCA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgcmV0dXJuIFwieHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4XCIucmVwbGFjZSgvW3h5XS9nLCAobikgPT4ge1xuICAgICAgICBjb25zdCBpID0gKHQgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYgfCAwO1xuICAgICAgICByZXR1cm4gdCA9IE1hdGguZmxvb3IodCAvIDE2KSwgKG4gPT0gXCJ4XCIgPyBpIDogaSAmIDMgfCA4KS50b1N0cmluZygxNik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIFhuKHMpIHtcbiAgbGV0IGUgPSA1MzgxLCB0ID0gcy5sZW5ndGg7XG4gIGZvciAoOyB0OyApXG4gICAgZSA9IGUgKiAzMyBeIHMuY2hhckNvZGVBdCgtLXQpO1xuICByZXR1cm4gKGUgPj4+IDApLnRvU3RyaW5nKCk7XG59XG5jb25zdCBSbiA9IDAuMDI1O1xubGV0IGlhID0gLyogQF9fUFVSRV9fICovIChmdW5jdGlvbihzKSB7XG4gIHJldHVybiBzW3MuUG9pbnQgPSAwXSA9IFwiUG9pbnRcIiwgc1tzLlJhbmdlID0gMV0gPSBcIlJhbmdlXCIsIHM7XG59KSh7fSk7XG5mdW5jdGlvbiBndyhzLCBlLCB0KSB7XG4gIHJldHVybiBgJHtzLmlkZW50aWZpZXJ9LSR7dCArIDF9LSR7WG4oZSl9YDtcbn1cbmNsYXNzIHB3IHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHRoaXMuYmFzZSA9IHZvaWQgMCwgdGhpcy5fZHVyYXRpb24gPSBudWxsLCB0aGlzLl90aW1lbGluZVN0YXJ0ID0gbnVsbCwgdGhpcy5hcHBlbmRJblBsYWNlRGlzYWJsZWQgPSB2b2lkIDAsIHRoaXMuYXBwZW5kSW5QbGFjZVN0YXJ0ZWQgPSB2b2lkIDAsIHRoaXMuZGF0ZVJhbmdlID0gdm9pZCAwLCB0aGlzLmhhc1BsYXllZCA9ICExLCB0aGlzLmN1bXVsYXRpdmVEdXJhdGlvbiA9IDAsIHRoaXMucmVzdW1lT2Zmc2V0ID0gTmFOLCB0aGlzLnBsYXlvdXRMaW1pdCA9IE5hTiwgdGhpcy5yZXN0cmljdGlvbnMgPSB7XG4gICAgICBza2lwOiAhMSxcbiAgICAgIGp1bXA6ICExXG4gICAgfSwgdGhpcy5zbmFwT3B0aW9ucyA9IHtcbiAgICAgIG91dDogITEsXG4gICAgICBpbjogITFcbiAgICB9LCB0aGlzLmFzc2V0TGlzdCA9IFtdLCB0aGlzLmFzc2V0TGlzdExvYWRlciA9IHZvaWQgMCwgdGhpcy5hc3NldExpc3RSZXNwb25zZSA9IG51bGwsIHRoaXMucmVzdW1lQW5jaG9yID0gdm9pZCAwLCB0aGlzLmVycm9yID0gdm9pZCAwLCB0aGlzLnJlc2V0T25SZXN1bWUgPSB2b2lkIDAsIHRoaXMuYmFzZSA9IHQsIHRoaXMuZGF0ZVJhbmdlID0gZSwgdGhpcy5zZXREYXRlUmFuZ2UoZSk7XG4gIH1cbiAgc2V0RGF0ZVJhbmdlKGUpIHtcbiAgICB0aGlzLmRhdGVSYW5nZSA9IGUsIHRoaXMucmVzdW1lT2Zmc2V0ID0gZS5hdHRyLm9wdGlvbmFsRmxvYXQoXCJYLVJFU1VNRS1PRkZTRVRcIiwgdGhpcy5yZXN1bWVPZmZzZXQpLCB0aGlzLnBsYXlvdXRMaW1pdCA9IGUuYXR0ci5vcHRpb25hbEZsb2F0KFwiWC1QTEFZT1VULUxJTUlUXCIsIHRoaXMucGxheW91dExpbWl0KSwgdGhpcy5yZXN0cmljdGlvbnMgPSBlLmF0dHIuZW51bWVyYXRlZFN0cmluZ0xpc3QoXCJYLVJFU1RSSUNUXCIsIHRoaXMucmVzdHJpY3Rpb25zKSwgdGhpcy5zbmFwT3B0aW9ucyA9IGUuYXR0ci5lbnVtZXJhdGVkU3RyaW5nTGlzdChcIlgtU05BUFwiLCB0aGlzLnNuYXBPcHRpb25zKTtcbiAgfVxuICByZXNldCgpIHtcbiAgICB2YXIgZTtcbiAgICB0aGlzLmFwcGVuZEluUGxhY2VTdGFydGVkID0gITEsIChlID0gdGhpcy5hc3NldExpc3RMb2FkZXIpID09IG51bGwgfHwgZS5kZXN0cm95KCksIHRoaXMuYXNzZXRMaXN0TG9hZGVyID0gdm9pZCAwLCB0aGlzLnN1cHBsZW1lbnRzUHJpbWFyeSB8fCAodGhpcy5hc3NldExpc3RSZXNwb25zZSA9IG51bGwsIHRoaXMuYXNzZXRMaXN0ID0gW10sIHRoaXMuX2R1cmF0aW9uID0gbnVsbCk7XG4gIH1cbiAgaXNBc3NldFBhc3RQbGF5b3V0TGltaXQoZSkge1xuICAgIHZhciB0O1xuICAgIGlmIChlID4gMCAmJiBlID49IHRoaXMuYXNzZXRMaXN0Lmxlbmd0aClcbiAgICAgIHJldHVybiAhMDtcbiAgICBjb25zdCByID0gdGhpcy5wbGF5b3V0TGltaXQ7XG4gICAgcmV0dXJuIGUgPD0gMCB8fCBpc05hTihyKSA/ICExIDogciA9PT0gMCA/ICEwIDogKCgodCA9IHRoaXMuYXNzZXRMaXN0W2VdKSA9PSBudWxsID8gdm9pZCAwIDogdC5zdGFydE9mZnNldCkgfHwgMCkgPiByO1xuICB9XG4gIGZpbmRBc3NldEluZGV4KGUpIHtcbiAgICByZXR1cm4gdGhpcy5hc3NldExpc3QuaW5kZXhPZihlKTtcbiAgfVxuICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlUmFuZ2UuaWQ7XG4gIH1cbiAgZ2V0IHN0YXJ0RGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlUmFuZ2Uuc3RhcnREYXRlO1xuICB9XG4gIGdldCBzdGFydFRpbWUoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuZGF0ZVJhbmdlLnN0YXJ0VGltZTtcbiAgICBpZiAodGhpcy5zbmFwT3B0aW9ucy5vdXQpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLmRhdGVSYW5nZS50YWdBbmNob3I7XG4gICAgICBpZiAodClcbiAgICAgICAgcmV0dXJuIGJsKGUsIHQpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICBnZXQgc3RhcnRPZmZzZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VlLnByZSA/IDAgOiB0aGlzLnN0YXJ0VGltZTtcbiAgfVxuICBnZXQgc3RhcnRJc0FsaWduZWQoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRUaW1lID09PSAwIHx8IHRoaXMuc25hcE9wdGlvbnMub3V0KVxuICAgICAgcmV0dXJuICEwO1xuICAgIGNvbnN0IGUgPSB0aGlzLmRhdGVSYW5nZS50YWdBbmNob3I7XG4gICAgaWYgKGUpIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLmRhdGVSYW5nZS5zdGFydFRpbWUsIHIgPSBibCh0LCBlKTtcbiAgICAgIHJldHVybiB0IC0gciA8IDAuMTtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIGdldCByZXN1bXB0aW9uT2Zmc2V0KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnJlc3VtZU9mZnNldCwgdCA9IHVlKGUpID8gZSA6IHRoaXMuZHVyYXRpb247XG4gICAgcmV0dXJuIHRoaXMuY3VtdWxhdGl2ZUR1cmF0aW9uICsgdDtcbiAgfVxuICBnZXQgcmVzdW1lVGltZSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5zdGFydE9mZnNldCArIHRoaXMucmVzdW1wdGlvbk9mZnNldDtcbiAgICBpZiAodGhpcy5zbmFwT3B0aW9ucy5pbikge1xuICAgICAgY29uc3QgdCA9IHRoaXMucmVzdW1lQW5jaG9yO1xuICAgICAgaWYgKHQpXG4gICAgICAgIHJldHVybiBibChlLCB0KTtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZ2V0IGFwcGVuZEluUGxhY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBwZW5kSW5QbGFjZVN0YXJ0ZWQgPyAhMCA6IHRoaXMuYXBwZW5kSW5QbGFjZURpc2FibGVkID8gITEgOiAhISghdGhpcy5jdWUub25jZSAmJiAhdGhpcy5jdWUucHJlICYmIC8vIHByZXJvbGwgc3RhcnRzIGF0IHN0YXJ0UG9zaXRpb24gYmVmb3JlIHN0YXJ0UG9zaXRpb24gaXMga25vd24gKGxpdmUpXG4gICAgdGhpcy5zdGFydElzQWxpZ25lZCAmJiAoaXNOYU4odGhpcy5wbGF5b3V0TGltaXQpICYmIGlzTmFOKHRoaXMucmVzdW1lT2Zmc2V0KSB8fCB0aGlzLnJlc3VtZU9mZnNldCAmJiB0aGlzLmR1cmF0aW9uICYmIE1hdGguYWJzKHRoaXMucmVzdW1lT2Zmc2V0IC0gdGhpcy5kdXJhdGlvbikgPCBSbikpO1xuICB9XG4gIHNldCBhcHBlbmRJblBsYWNlKGUpIHtcbiAgICBpZiAodGhpcy5hcHBlbmRJblBsYWNlU3RhcnRlZCkge1xuICAgICAgdGhpcy5yZXNldE9uUmVzdW1lID0gIWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXBwZW5kSW5QbGFjZURpc2FibGVkID0gIWU7XG4gIH1cbiAgLy8gRXh0ZW5kZWQgdGltZWxpbmUgc3RhcnQgdGltZVxuICBnZXQgdGltZWxpbmVTdGFydCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZWxpbmVTdGFydCAhPT0gbnVsbCA/IHRoaXMuX3RpbWVsaW5lU3RhcnQgOiB0aGlzLnN0YXJ0VGltZTtcbiAgfVxuICBzZXQgdGltZWxpbmVTdGFydChlKSB7XG4gICAgdGhpcy5fdGltZWxpbmVTdGFydCA9IGU7XG4gIH1cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnBsYXlvdXRMaW1pdDtcbiAgICBsZXQgdDtcbiAgICByZXR1cm4gdGhpcy5fZHVyYXRpb24gIT09IG51bGwgPyB0ID0gdGhpcy5fZHVyYXRpb24gOiB0aGlzLmRhdGVSYW5nZS5kdXJhdGlvbiA/IHQgPSB0aGlzLmRhdGVSYW5nZS5kdXJhdGlvbiA6IHQgPSB0aGlzLmRhdGVSYW5nZS5wbGFubmVkRHVyYXRpb24gfHwgMCwgIWlzTmFOKGUpICYmIGUgPCB0ICYmICh0ID0gZSksIHQ7XG4gIH1cbiAgc2V0IGR1cmF0aW9uKGUpIHtcbiAgICB0aGlzLl9kdXJhdGlvbiA9IGU7XG4gIH1cbiAgZ2V0IGN1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlUmFuZ2UuY3VlO1xuICB9XG4gIGdldCB0aW1lbGluZU9jY3VwYW5jeSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlUmFuZ2UuYXR0cltcIlgtVElNRUxJTkUtT0NDVVBJRVNcIl0gPT09IFwiUkFOR0VcIiA/IGlhLlJhbmdlIDogaWEuUG9pbnQ7XG4gIH1cbiAgZ2V0IHN1cHBsZW1lbnRzUHJpbWFyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlUmFuZ2UuYXR0cltcIlgtVElNRUxJTkUtU1RZTEVcIl0gPT09IFwiUFJJTUFSWVwiO1xuICB9XG4gIGdldCBjb250ZW50TWF5VmFyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlUmFuZ2UuYXR0cltcIlgtQ09OVEVOVC1NQVktVkFSWVwiXSAhPT0gXCJOT1wiO1xuICB9XG4gIGdldCBhc3NldFVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlUmFuZ2UuYXR0cltcIlgtQVNTRVQtVVJJXCJdO1xuICB9XG4gIGdldCBhc3NldExpc3RVcmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0ZVJhbmdlLmF0dHJbXCJYLUFTU0VULUxJU1RcIl07XG4gIH1cbiAgZ2V0IGJhc2VVcmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFzZS51cmw7XG4gIH1cbiAgZ2V0IGFzc2V0TGlzdExvYWRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5hc3NldExpc3QubGVuZ3RoID4gMCB8fCB0aGlzLmFzc2V0TGlzdFJlc3BvbnNlICE9PSBudWxsO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBtdyh0aGlzKTtcbiAgfVxufVxuZnVuY3Rpb24gYmwocywgZSkge1xuICByZXR1cm4gcyAtIGUuc3RhcnQgPCBlLmR1cmF0aW9uIC8gMiAmJiAhKE1hdGguYWJzKHMgLSAoZS5zdGFydCArIGUuZHVyYXRpb24pKSA8IFJuKSA/IGUuc3RhcnQgOiBlLnN0YXJ0ICsgZS5kdXJhdGlvbjtcbn1cbmZ1bmN0aW9uICRwKHMsIGUsIHQpIHtcbiAgY29uc3QgciA9IG5ldyBzZWxmLlVSTChzLCB0KTtcbiAgcmV0dXJuIHIucHJvdG9jb2wgIT09IFwiZGF0YTpcIiAmJiByLnNlYXJjaFBhcmFtcy5zZXQoXCJfSExTX3ByaW1hcnlfaWRcIiwgZSksIHI7XG59XG5mdW5jdGlvbiBUbChzLCBlKSB7XG4gIGZvciAoOyAodCA9IHMuYXNzZXRMaXN0WysrZV0pICE9IG51bGwgJiYgdC5lcnJvcjsgKVxuICAgIHZhciB0O1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIG13KHMpIHtcbiAgcmV0dXJuIGBbXCIke3MuaWRlbnRpZmllcn1cIiAke3MuY3VlLnByZSA/IFwiPHByZT5cIiA6IHMuY3VlLnBvc3QgPyBcIjxwb3N0PlwiIDogXCJcIn0ke3MudGltZWxpbmVTdGFydC50b0ZpeGVkKDIpfS0ke3MucmVzdW1lVGltZS50b0ZpeGVkKDIpfV1gO1xufVxuZnVuY3Rpb24gdm4ocykge1xuICBjb25zdCBlID0gcy50aW1lbGluZVN0YXJ0LCB0ID0gcy5kdXJhdGlvbiB8fCAwO1xuICByZXR1cm4gYFtcIiR7cy5pZGVudGlmaWVyfVwiICR7ZS50b0ZpeGVkKDIpfS0keyhlICsgdCkudG9GaXhlZCgyKX1dYDtcbn1cbmNsYXNzIHl3IHtcbiAgY29uc3RydWN0b3IoZSwgdCwgciwgbikge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwLCB0aGlzLmludGVyc3RpdGlhbCA9IHZvaWQgMCwgdGhpcy5hc3NldEl0ZW0gPSB2b2lkIDAsIHRoaXMudHJhY2tzID0gbnVsbCwgdGhpcy5oYXNEZXRhaWxzID0gITEsIHRoaXMubWVkaWFBdHRhY2hlZCA9IG51bGwsIHRoaXMuX2N1cnJlbnRUaW1lID0gdm9pZCAwLCB0aGlzLl9idWZmZXJlZEVvc1RpbWUgPSB2b2lkIDAsIHRoaXMuY2hlY2tQbGF5b3V0ID0gKCkgPT4ge1xuICAgICAgdGhpcy5yZWFjaGVkUGxheW91dCh0aGlzLmN1cnJlbnRUaW1lKSAmJiB0aGlzLmhscyAmJiB0aGlzLmhscy50cmlnZ2VyKEkuUExBWU9VVF9MSU1JVF9SRUFDSEVELCB7fSk7XG4gICAgfTtcbiAgICBjb25zdCBpID0gdGhpcy5obHMgPSBuZXcgZSh0KTtcbiAgICB0aGlzLmludGVyc3RpdGlhbCA9IHIsIHRoaXMuYXNzZXRJdGVtID0gbjtcbiAgICBjb25zdCBvID0gKCkgPT4ge1xuICAgICAgdGhpcy5oYXNEZXRhaWxzID0gITA7XG4gICAgfTtcbiAgICBpLm9uY2UoSS5MRVZFTF9MT0FERUQsIG8pLCBpLm9uY2UoSS5BVURJT19UUkFDS19MT0FERUQsIG8pLCBpLm9uY2UoSS5TVUJUSVRMRV9UUkFDS19MT0FERUQsIG8pLCBpLm9uKEkuTUVESUFfQVRUQUNISU5HLCAoYSwge1xuICAgICAgbWVkaWE6IGxcbiAgICB9KSA9PiB7XG4gICAgICB0aGlzLnJlbW92ZU1lZGlhTGlzdGVuZXJzKCksIHRoaXMubWVkaWFBdHRhY2hlZCA9IGwsIHRoaXMuaW50ZXJzdGl0aWFsLnBsYXlvdXRMaW1pdCAmJiAobC5hZGRFdmVudExpc3RlbmVyKFwidGltZXVwZGF0ZVwiLCB0aGlzLmNoZWNrUGxheW91dCksIHRoaXMuYXBwZW5kSW5QbGFjZSAmJiBpLm9uKEkuQlVGRkVSX0FQUEVOREVELCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHUgPSB0aGlzLmJ1ZmZlcmVkRW5kO1xuICAgICAgICB0aGlzLnJlYWNoZWRQbGF5b3V0KHUpICYmICh0aGlzLl9idWZmZXJlZEVvc1RpbWUgPSB1LCBpLnRyaWdnZXIoSS5CVUZGRVJFRF9UT19FTkQsIHZvaWQgMCkpO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG4gIGdldCBhcHBlbmRJblBsYWNlKCkge1xuICAgIHJldHVybiB0aGlzLmludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlO1xuICB9XG4gIGxvYWRTb3VyY2UoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuaGxzO1xuICAgIGlmIChlKVxuICAgICAgaWYgKGUudXJsKVxuICAgICAgICBlLmxldmVscy5sZW5ndGggJiYgIWUuc3RhcnRlZCAmJiBlLnN0YXJ0TG9hZCgtMSwgITApO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGxldCB0ID0gdGhpcy5hc3NldEl0ZW0udXJpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHQgPSAkcCh0LCBlLmNvbmZpZy5wcmltYXJ5U2Vzc2lvbklkIHx8IFwiXCIpLmhyZWY7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICB9XG4gICAgICAgIGUubG9hZFNvdXJjZSh0KTtcbiAgICAgIH1cbiAgfVxuICBidWZmZXJlZEluUGxhY2VUb0VuZChlKSB7XG4gICAgdmFyIHQ7XG4gICAgaWYgKCF0aGlzLmFwcGVuZEluUGxhY2UpXG4gICAgICByZXR1cm4gITE7XG4gICAgaWYgKCh0ID0gdGhpcy5obHMpICE9IG51bGwgJiYgdC5idWZmZXJlZFRvRW5kKVxuICAgICAgcmV0dXJuICEwO1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCByID0gTWF0aC5taW4odGhpcy5fYnVmZmVyZWRFb3NUaW1lIHx8IDEgLyAwLCB0aGlzLmR1cmF0aW9uKSwgbiA9IHRoaXMudGltZWxpbmVPZmZzZXQsIGkgPSBDZS5idWZmZXJJbmZvKGUsIG4sIDApO1xuICAgIHJldHVybiB0aGlzLmdldEFzc2V0VGltZShpLmVuZCkgPj0gciAtIDAuMDI7XG4gIH1cbiAgcmVhY2hlZFBsYXlvdXQoZSkge1xuICAgIGNvbnN0IHIgPSB0aGlzLmludGVyc3RpdGlhbC5wbGF5b3V0TGltaXQ7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnRPZmZzZXQgKyBlID49IHI7XG4gIH1cbiAgZ2V0IGRlc3Ryb3llZCgpIHtcbiAgICB2YXIgZTtcbiAgICByZXR1cm4gISgoZSA9IHRoaXMuaGxzKSAhPSBudWxsICYmIGUudXNlckNvbmZpZyk7XG4gIH1cbiAgZ2V0IGFzc2V0SWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNzZXRJdGVtLmlkZW50aWZpZXI7XG4gIH1cbiAgZ2V0IGludGVyc3RpdGlhbElkKCkge1xuICAgIHJldHVybiB0aGlzLmFzc2V0SXRlbS5wYXJlbnRJZGVudGlmaWVyO1xuICB9XG4gIGdldCBtZWRpYSgpIHtcbiAgICB2YXIgZTtcbiAgICByZXR1cm4gKChlID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBlLm1lZGlhKSB8fCBudWxsO1xuICB9XG4gIGdldCBidWZmZXJlZEVuZCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5tZWRpYSB8fCB0aGlzLm1lZGlhQXR0YWNoZWQ7XG4gICAgaWYgKCFlKVxuICAgICAgcmV0dXJuIHRoaXMuX2J1ZmZlcmVkRW9zVGltZSA/IHRoaXMuX2J1ZmZlcmVkRW9zVGltZSA6IHRoaXMuY3VycmVudFRpbWU7XG4gICAgY29uc3QgdCA9IENlLmJ1ZmZlckluZm8oZSwgZS5jdXJyZW50VGltZSwgMWUtMyk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXNzZXRUaW1lKHQuZW5kKTtcbiAgfVxuICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMubWVkaWEgfHwgdGhpcy5tZWRpYUF0dGFjaGVkO1xuICAgIHJldHVybiBlID8gdGhpcy5nZXRBc3NldFRpbWUoZS5jdXJyZW50VGltZSkgOiB0aGlzLl9jdXJyZW50VGltZSB8fCAwO1xuICB9XG4gIGdldCBkdXJhdGlvbigpIHtcbiAgICBjb25zdCBlID0gdGhpcy5hc3NldEl0ZW0uZHVyYXRpb247XG4gICAgaWYgKCFlKVxuICAgICAgcmV0dXJuIDA7XG4gICAgY29uc3QgdCA9IHRoaXMuaW50ZXJzdGl0aWFsLnBsYXlvdXRMaW1pdDtcbiAgICBpZiAodCkge1xuICAgICAgY29uc3QgciA9IHQgLSB0aGlzLnN0YXJ0T2Zmc2V0O1xuICAgICAgaWYgKHIgPiAwICYmIHIgPCBlKVxuICAgICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZ2V0IHJlbWFpbmluZygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5kdXJhdGlvbjtcbiAgICByZXR1cm4gZSA/IE1hdGgubWF4KDAsIGUgLSB0aGlzLmN1cnJlbnRUaW1lKSA6IDA7XG4gIH1cbiAgZ2V0IHN0YXJ0T2Zmc2V0KCkge1xuICAgIHJldHVybiB0aGlzLmFzc2V0SXRlbS5zdGFydE9mZnNldDtcbiAgfVxuICBnZXQgdGltZWxpbmVPZmZzZXQoKSB7XG4gICAgdmFyIGU7XG4gICAgcmV0dXJuICgoZSA9IHRoaXMuaGxzKSA9PSBudWxsID8gdm9pZCAwIDogZS5jb25maWcudGltZWxpbmVPZmZzZXQpIHx8IDA7XG4gIH1cbiAgc2V0IHRpbWVsaW5lT2Zmc2V0KGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy50aW1lbGluZU9mZnNldDtcbiAgICBpZiAoZSAhPT0gdCkge1xuICAgICAgY29uc3QgciA9IGUgLSB0O1xuICAgICAgaWYgKE1hdGguYWJzKHIpID4gMSAvIDllNCAmJiB0aGlzLmhscykge1xuICAgICAgICBpZiAodGhpcy5oYXNEZXRhaWxzKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgdGltZWxpbmVPZmZzZXQgYWZ0ZXIgcGxheWxpc3RzIGFyZSBsb2FkZWRcIik7XG4gICAgICAgIHRoaXMuaGxzLmNvbmZpZy50aW1lbGluZU9mZnNldCA9IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldEFzc2V0VGltZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMudGltZWxpbmVPZmZzZXQsIHIgPSB0aGlzLmR1cmF0aW9uO1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCgwLCBlIC0gdCksIHIpO1xuICB9XG4gIHJlbW92ZU1lZGlhTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm1lZGlhQXR0YWNoZWQ7XG4gICAgZSAmJiAodGhpcy5fY3VycmVudFRpbWUgPSBlLmN1cnJlbnRUaW1lLCB0aGlzLmJ1ZmZlclNuYXBTaG90KCksIGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRpbWV1cGRhdGVcIiwgdGhpcy5jaGVja1BsYXlvdXQpKTtcbiAgfVxuICBidWZmZXJTbmFwU2hvdCgpIHtcbiAgICBpZiAodGhpcy5tZWRpYUF0dGFjaGVkKSB7XG4gICAgICB2YXIgZTtcbiAgICAgIChlID0gdGhpcy5obHMpICE9IG51bGwgJiYgZS5idWZmZXJlZFRvRW5kICYmICh0aGlzLl9idWZmZXJlZEVvc1RpbWUgPSB0aGlzLmJ1ZmZlcmVkRW5kKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbW92ZU1lZGlhTGlzdGVuZXJzKCksIHRoaXMuaGxzICYmIHRoaXMuaGxzLmRlc3Ryb3koKSwgdGhpcy5obHMgPSBudWxsLCB0aGlzLnRyYWNrcyA9IHRoaXMubWVkaWFBdHRhY2hlZCA9IHRoaXMuY2hlY2tQbGF5b3V0ID0gbnVsbDtcbiAgfVxuICBhdHRhY2hNZWRpYShlKSB7XG4gICAgdmFyIHQ7XG4gICAgdGhpcy5sb2FkU291cmNlKCksICh0ID0gdGhpcy5obHMpID09IG51bGwgfHwgdC5hdHRhY2hNZWRpYShlKTtcbiAgfVxuICBkZXRhY2hNZWRpYSgpIHtcbiAgICB2YXIgZTtcbiAgICB0aGlzLnJlbW92ZU1lZGlhTGlzdGVuZXJzKCksIHRoaXMubWVkaWFBdHRhY2hlZCA9IG51bGwsIChlID0gdGhpcy5obHMpID09IG51bGwgfHwgZS5kZXRhY2hNZWRpYSgpO1xuICB9XG4gIHJlc3VtZUJ1ZmZlcmluZygpIHtcbiAgICB2YXIgZTtcbiAgICAoZSA9IHRoaXMuaGxzKSA9PSBudWxsIHx8IGUucmVzdW1lQnVmZmVyaW5nKCk7XG4gIH1cbiAgcGF1c2VCdWZmZXJpbmcoKSB7XG4gICAgdmFyIGU7XG4gICAgKGUgPSB0aGlzLmhscykgPT0gbnVsbCB8fCBlLnBhdXNlQnVmZmVyaW5nKCk7XG4gIH1cbiAgdHJhbnNmZXJNZWRpYSgpIHtcbiAgICB2YXIgZTtcbiAgICByZXR1cm4gdGhpcy5idWZmZXJTbmFwU2hvdCgpLCAoKGUgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IGUudHJhbnNmZXJNZWRpYSgpKSB8fCBudWxsO1xuICB9XG4gIHJlc2V0RGV0YWlscygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5obHM7XG4gICAgaWYgKGUgJiYgdGhpcy5oYXNEZXRhaWxzKSB7XG4gICAgICBlLnN0b3BMb2FkKCk7XG4gICAgICBjb25zdCB0ID0gKHIpID0+IGRlbGV0ZSByLmRldGFpbHM7XG4gICAgICBlLmxldmVscy5mb3JFYWNoKHQpLCBlLmFsbEF1ZGlvVHJhY2tzLmZvckVhY2godCksIGUuYWxsU3VidGl0bGVUcmFja3MuZm9yRWFjaCh0KSwgdGhpcy5oYXNEZXRhaWxzID0gITE7XG4gICAgfVxuICB9XG4gIG9uKGUsIHQsIHIpIHtcbiAgICB2YXIgbjtcbiAgICAobiA9IHRoaXMuaGxzKSA9PSBudWxsIHx8IG4ub24oZSwgdCk7XG4gIH1cbiAgb25jZShlLCB0LCByKSB7XG4gICAgdmFyIG47XG4gICAgKG4gPSB0aGlzLmhscykgPT0gbnVsbCB8fCBuLm9uY2UoZSwgdCk7XG4gIH1cbiAgb2ZmKGUsIHQsIHIpIHtcbiAgICB2YXIgbjtcbiAgICAobiA9IHRoaXMuaGxzKSA9PSBudWxsIHx8IG4ub2ZmKGUsIHQpO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIHZhciBlO1xuICAgIHJldHVybiBgSGxzQXNzZXRQbGF5ZXI6ICR7dm4odGhpcy5hc3NldEl0ZW0pfSAkeyhlID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBlLnNlc3Npb25JZH0gJHt0aGlzLmFwcGVuZEluUGxhY2UgPyBcImFwcGVuZC1pbi1wbGFjZVwiIDogXCJcIn1gO1xuICB9XG59XG5jb25zdCBYaCA9IDAuMDMzO1xuY2xhc3MgdncgZXh0ZW5kcyBMciB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihcImludGVyc3RpdGlhbHMtc2NoZWRcIiwgdCksIHRoaXMub25TY2hlZHVsZVVwZGF0ZSA9IHZvaWQgMCwgdGhpcy5ldmVudE1hcCA9IHt9LCB0aGlzLmV2ZW50cyA9IG51bGwsIHRoaXMuaXRlbXMgPSBudWxsLCB0aGlzLmR1cmF0aW9ucyA9IHtcbiAgICAgIHByaW1hcnk6IDAsXG4gICAgICBwbGF5b3V0OiAwLFxuICAgICAgaW50ZWdyYXRlZDogMFxuICAgIH0sIHRoaXMub25TY2hlZHVsZVVwZGF0ZSA9IGU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnJlc2V0KCksIHRoaXMub25TY2hlZHVsZVVwZGF0ZSA9IG51bGw7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5ldmVudE1hcCA9IHt9LCB0aGlzLnNldER1cmF0aW9ucygwLCAwLCAwKSwgdGhpcy5ldmVudHMgJiYgdGhpcy5ldmVudHMuZm9yRWFjaCgoZSkgPT4gZS5yZXNldCgpKSwgdGhpcy5ldmVudHMgPSB0aGlzLml0ZW1zID0gbnVsbDtcbiAgfVxuICByZXNldEVycm9yc0luUmFuZ2UoZSwgdCkge1xuICAgIHJldHVybiB0aGlzLmV2ZW50cyA/IHRoaXMuZXZlbnRzLnJlZHVjZSgociwgbikgPT4gZSA8PSBuLnN0YXJ0T2Zmc2V0ICYmIHQgPiBuLnN0YXJ0T2Zmc2V0ID8gKGRlbGV0ZSBuLmVycm9yLCByICsgMSkgOiByLCAwKSA6IDA7XG4gIH1cbiAgZ2V0IGR1cmF0aW9uKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLml0ZW1zO1xuICAgIHJldHVybiBlID8gZVtlLmxlbmd0aCAtIDFdLmVuZCA6IDA7XG4gIH1cbiAgZ2V0IGxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5pdGVtcyA/IHRoaXMuaXRlbXMubGVuZ3RoIDogMDtcbiAgfVxuICBnZXRFdmVudChlKSB7XG4gICAgcmV0dXJuIGUgJiYgdGhpcy5ldmVudE1hcFtlXSB8fCBudWxsO1xuICB9XG4gIGhhc0V2ZW50KGUpIHtcbiAgICByZXR1cm4gZSBpbiB0aGlzLmV2ZW50TWFwO1xuICB9XG4gIGZpbmRJdGVtSW5kZXgoZSwgdCkge1xuICAgIGlmIChlLmV2ZW50KVxuICAgICAgcmV0dXJuIHRoaXMuZmluZEV2ZW50SW5kZXgoZS5ldmVudC5pZGVudGlmaWVyKTtcbiAgICBsZXQgciA9IC0xO1xuICAgIGUubmV4dEV2ZW50ID8gciA9IHRoaXMuZmluZEV2ZW50SW5kZXgoZS5uZXh0RXZlbnQuaWRlbnRpZmllcikgLSAxIDogZS5wcmV2aW91c0V2ZW50ICYmIChyID0gdGhpcy5maW5kRXZlbnRJbmRleChlLnByZXZpb3VzRXZlbnQuaWRlbnRpZmllcikgKyAxKTtcbiAgICBjb25zdCBuID0gdGhpcy5pdGVtcztcbiAgICBpZiAobilcbiAgICAgIGZvciAobltyXSB8fCAodCA9PT0gdm9pZCAwICYmICh0ID0gZS5zdGFydCksIHIgPSB0aGlzLmZpbmRJdGVtSW5kZXhBdFRpbWUodCkpOyByID49IDAgJiYgKGkgPSBuW3JdKSAhPSBudWxsICYmIGkuZXZlbnQ7ICkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgci0tO1xuICAgICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIGZpbmRJdGVtSW5kZXhBdFRpbWUoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLml0ZW1zO1xuICAgIGlmIChyKVxuICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCByLmxlbmd0aDsgbisrKSB7XG4gICAgICAgIGxldCBpID0gcltuXTtcbiAgICAgICAgaWYgKHQgJiYgdCAhPT0gXCJwcmltYXJ5XCIgJiYgKGkgPSBpW3RdKSwgZSA9PT0gaS5zdGFydCB8fCBlID4gaS5zdGFydCAmJiBlIDwgaS5lbmQpXG4gICAgICAgICAgcmV0dXJuIG47XG4gICAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGZpbmRKdW1wUmVzdHJpY3RlZEluZGV4KGUsIHQpIHtcbiAgICBjb25zdCByID0gdGhpcy5pdGVtcztcbiAgICBpZiAocilcbiAgICAgIGZvciAobGV0IG4gPSBlOyBuIDw9IHQgJiYgcltuXTsgbisrKSB7XG4gICAgICAgIGNvbnN0IGkgPSByW25dLmV2ZW50O1xuICAgICAgICBpZiAoaSAhPSBudWxsICYmIGkucmVzdHJpY3Rpb25zLmp1bXAgJiYgIWkuYXBwZW5kSW5QbGFjZSlcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cbiAgZmluZEV2ZW50SW5kZXgoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLml0ZW1zO1xuICAgIGlmICh0KVxuICAgICAgZm9yIChsZXQgbiA9IHQubGVuZ3RoOyBuLS07ICkge1xuICAgICAgICB2YXIgcjtcbiAgICAgICAgaWYgKCgociA9IHRbbl0uZXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiByLmlkZW50aWZpZXIpID09PSBlKVxuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuICBmaW5kQXNzZXRJbmRleChlLCB0KSB7XG4gICAgY29uc3QgciA9IGUuYXNzZXRMaXN0LCBuID0gci5sZW5ndGg7XG4gICAgaWYgKG4gPiAxKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgY29uc3QgbyA9IHJbaV07XG4gICAgICAgIGlmICghby5lcnJvcikge1xuICAgICAgICAgIGNvbnN0IGEgPSBvLnRpbWVsaW5lU3RhcnQ7XG4gICAgICAgICAgaWYgKHQgPT09IGEgfHwgdCA+IGEgJiYgKHQgPCBhICsgKG8uZHVyYXRpb24gfHwgMCkgfHwgaSA9PT0gbiAtIDEpKVxuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXQgYXNzZXRJZEF0RW5kKCkge1xuICAgIHZhciBlO1xuICAgIGNvbnN0IHQgPSAoZSA9IHRoaXMuaXRlbXMpID09IG51bGwgfHwgKGUgPSBlW3RoaXMubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBlLmV2ZW50O1xuICAgIGlmICh0KSB7XG4gICAgICBjb25zdCByID0gdC5hc3NldExpc3QsIG4gPSByW3IubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobilcbiAgICAgICAgcmV0dXJuIG4uaWRlbnRpZmllcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcGFyc2VJbnRlcnN0aXRpYWxEYXRlUmFuZ2VzKGUsIHQpIHtcbiAgICBjb25zdCByID0gZS5tYWluLmRldGFpbHMsIHtcbiAgICAgIGRhdGVSYW5nZXM6IG5cbiAgICB9ID0gciwgaSA9IHRoaXMuZXZlbnRzLCBvID0gdGhpcy5wYXJzZURhdGVSYW5nZXMobiwge1xuICAgICAgdXJsOiByLnVybFxuICAgIH0sIHQpLCBhID0gT2JqZWN0LmtleXMobiksIGwgPSBpID8gaS5maWx0ZXIoKGMpID0+ICFhLmluY2x1ZGVzKGMuaWRlbnRpZmllcikpIDogW107XG4gICAgby5sZW5ndGggJiYgby5zb3J0KChjLCB1KSA9PiB7XG4gICAgICBjb25zdCBkID0gYy5jdWUucHJlLCBoID0gYy5jdWUucG9zdCwgZiA9IHUuY3VlLnByZSwgcCA9IHUuY3VlLnBvc3Q7XG4gICAgICBpZiAoZCAmJiAhZilcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKGYgJiYgIWQgfHwgaCAmJiAhcClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICBpZiAocCAmJiAhaClcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgaWYgKCFkICYmICFmICYmICFoICYmICFwKSB7XG4gICAgICAgIGNvbnN0IHkgPSBjLnN0YXJ0VGltZSwgRSA9IHUuc3RhcnRUaW1lO1xuICAgICAgICBpZiAoeSAhPT0gRSlcbiAgICAgICAgICByZXR1cm4geSAtIEU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYy5kYXRlUmFuZ2UudGFnT3JkZXIgLSB1LmRhdGVSYW5nZS50YWdPcmRlcjtcbiAgICB9KSwgdGhpcy5ldmVudHMgPSBvLCBsLmZvckVhY2goKGMpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlRXZlbnQoYyk7XG4gICAgfSksIHRoaXMudXBkYXRlU2NoZWR1bGUoZSwgbCk7XG4gIH1cbiAgdXBkYXRlU2NoZWR1bGUoZSwgdCA9IFtdLCByID0gITEpIHtcbiAgICBjb25zdCBuID0gdGhpcy5ldmVudHMgfHwgW107XG4gICAgaWYgKG4ubGVuZ3RoIHx8IHQubGVuZ3RoIHx8IHRoaXMubGVuZ3RoIDwgMikge1xuICAgICAgY29uc3QgaSA9IHRoaXMuaXRlbXMsIG8gPSB0aGlzLnBhcnNlU2NoZWR1bGUobiwgZSk7XG4gICAgICAociB8fCB0Lmxlbmd0aCB8fCAoaSA9PSBudWxsID8gdm9pZCAwIDogaS5sZW5ndGgpICE9PSBvLmxlbmd0aCB8fCBvLnNvbWUoKGwsIGMpID0+IE1hdGguYWJzKGwucGxheW91dC5zdGFydCAtIGlbY10ucGxheW91dC5zdGFydCkgPiA1ZS0zIHx8IE1hdGguYWJzKGwucGxheW91dC5lbmQgLSBpW2NdLnBsYXlvdXQuZW5kKSA+IDVlLTMpKSAmJiAodGhpcy5pdGVtcyA9IG8sIHRoaXMub25TY2hlZHVsZVVwZGF0ZSh0LCBpKSk7XG4gICAgfVxuICB9XG4gIHBhcnNlRGF0ZVJhbmdlcyhlLCB0LCByKSB7XG4gICAgY29uc3QgbiA9IFtdLCBpID0gT2JqZWN0LmtleXMoZSk7XG4gICAgZm9yIChsZXQgbyA9IDA7IG8gPCBpLmxlbmd0aDsgbysrKSB7XG4gICAgICBjb25zdCBhID0gaVtvXSwgbCA9IGVbYV07XG4gICAgICBpZiAobC5pc0ludGVyc3RpdGlhbCkge1xuICAgICAgICBsZXQgYyA9IHRoaXMuZXZlbnRNYXBbYV07XG4gICAgICAgIGMgPyBjLnNldERhdGVSYW5nZShsKSA6IChjID0gbmV3IHB3KGwsIHQpLCB0aGlzLmV2ZW50TWFwW2FdID0gYywgciA9PT0gITEgJiYgKGMuYXBwZW5kSW5QbGFjZSA9IHIpKSwgbi5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICBwYXJzZVNjaGVkdWxlKGUsIHQpIHtcbiAgICBjb25zdCByID0gW10sIG4gPSB0Lm1haW4uZGV0YWlscywgaSA9IG4ubGl2ZSA/IDEgLyAwIDogbi5lZGdlO1xuICAgIGxldCBvID0gMDtcbiAgICBpZiAoZSA9IGUuZmlsdGVyKChsKSA9PiAhbC5lcnJvciAmJiAhKGwuY3VlLm9uY2UgJiYgbC5oYXNQbGF5ZWQpKSwgZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMucmVzb2x2ZU9mZnNldHMoZSwgdCk7XG4gICAgICBsZXQgbCA9IDAsIGMgPSAwO1xuICAgICAgaWYgKGUuZm9yRWFjaCgodSwgZCkgPT4ge1xuICAgICAgICBjb25zdCBoID0gdS5jdWUucHJlLCBmID0gdS5jdWUucG9zdCwgcCA9IGVbZCAtIDFdIHx8IG51bGwsIHkgPSB1LmFwcGVuZEluUGxhY2UsIEUgPSBmID8gaSA6IHUuc3RhcnRPZmZzZXQsIGIgPSB1LmR1cmF0aW9uLCBSID0gdS50aW1lbGluZU9jY3VwYW5jeSA9PT0gaWEuUmFuZ2UgPyBiIDogMCwgQSA9IHUucmVzdW1wdGlvbk9mZnNldCwgRiA9IChwID09IG51bGwgPyB2b2lkIDAgOiBwLnN0YXJ0VGltZSkgPT09IEUsIE0gPSBFICsgdS5jdW11bGF0aXZlRHVyYXRpb247XG4gICAgICAgIGxldCBIID0geSA/IE0gKyBiIDogRSArIEE7XG4gICAgICAgIGlmIChoIHx8ICFmICYmIEUgPD0gMCkge1xuICAgICAgICAgIGNvbnN0IGogPSBjO1xuICAgICAgICAgIGMgKz0gUiwgdS50aW1lbGluZVN0YXJ0ID0gTTtcbiAgICAgICAgICBjb25zdCBDID0gbztcbiAgICAgICAgICBvICs9IGIsIHIucHVzaCh7XG4gICAgICAgICAgICBldmVudDogdSxcbiAgICAgICAgICAgIHN0YXJ0OiBNLFxuICAgICAgICAgICAgZW5kOiBILFxuICAgICAgICAgICAgcGxheW91dDoge1xuICAgICAgICAgICAgICBzdGFydDogQyxcbiAgICAgICAgICAgICAgZW5kOiBvXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW50ZWdyYXRlZDoge1xuICAgICAgICAgICAgICBzdGFydDogaixcbiAgICAgICAgICAgICAgZW5kOiBjXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoRSA8PSBpKSB7XG4gICAgICAgICAgaWYgKCFGKSB7XG4gICAgICAgICAgICBjb25zdCBrID0gRSAtIGw7XG4gICAgICAgICAgICBpZiAoayA+IFhoKSB7XG4gICAgICAgICAgICAgIGNvbnN0ICQgPSBsLCBXID0gYztcbiAgICAgICAgICAgICAgYyArPSBrO1xuICAgICAgICAgICAgICBjb25zdCBfID0gbztcbiAgICAgICAgICAgICAgbyArPSBrO1xuICAgICAgICAgICAgICBjb25zdCBnID0ge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzRXZlbnQ6IGVbZCAtIDFdIHx8IG51bGwsXG4gICAgICAgICAgICAgICAgbmV4dEV2ZW50OiB1LFxuICAgICAgICAgICAgICAgIHN0YXJ0OiAkLFxuICAgICAgICAgICAgICAgIGVuZDogJCArIGssXG4gICAgICAgICAgICAgICAgcGxheW91dDoge1xuICAgICAgICAgICAgICAgICAgc3RhcnQ6IF8sXG4gICAgICAgICAgICAgICAgICBlbmQ6IG9cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGludGVncmF0ZWQ6IHtcbiAgICAgICAgICAgICAgICAgIHN0YXJ0OiBXLFxuICAgICAgICAgICAgICAgICAgZW5kOiBjXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByLnB1c2goZyk7XG4gICAgICAgICAgICB9IGVsc2UgayA+IDAgJiYgcCAmJiAocC5jdW11bGF0aXZlRHVyYXRpb24gKz0gaywgcltyLmxlbmd0aCAtIDFdLmVuZCA9IEUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmICYmIChIID0gTSksIHUudGltZWxpbmVTdGFydCA9IE07XG4gICAgICAgICAgY29uc3QgaiA9IGM7XG4gICAgICAgICAgYyArPSBSO1xuICAgICAgICAgIGNvbnN0IEMgPSBvO1xuICAgICAgICAgIG8gKz0gYiwgci5wdXNoKHtcbiAgICAgICAgICAgIGV2ZW50OiB1LFxuICAgICAgICAgICAgc3RhcnQ6IE0sXG4gICAgICAgICAgICBlbmQ6IEgsXG4gICAgICAgICAgICBwbGF5b3V0OiB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBDLFxuICAgICAgICAgICAgICBlbmQ6IG9cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpbnRlZ3JhdGVkOiB7XG4gICAgICAgICAgICAgIHN0YXJ0OiBqLFxuICAgICAgICAgICAgICBlbmQ6IGNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBLID0gdS5yZXN1bWVUaW1lO1xuICAgICAgICBmIHx8IEsgPiBpID8gbCA9IGkgOiBsID0gSztcbiAgICAgIH0pLCBsIDwgaSkge1xuICAgICAgICB2YXIgYTtcbiAgICAgICAgY29uc3QgdSA9IGwsIGQgPSBjLCBoID0gaSAtIGw7XG4gICAgICAgIGMgKz0gaDtcbiAgICAgICAgY29uc3QgZiA9IG87XG4gICAgICAgIG8gKz0gaCwgci5wdXNoKHtcbiAgICAgICAgICBwcmV2aW91c0V2ZW50OiAoKGEgPSByW3IubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBhLmV2ZW50KSB8fCBudWxsLFxuICAgICAgICAgIG5leHRFdmVudDogbnVsbCxcbiAgICAgICAgICBzdGFydDogbCxcbiAgICAgICAgICBlbmQ6IHUgKyBoLFxuICAgICAgICAgIHBsYXlvdXQ6IHtcbiAgICAgICAgICAgIHN0YXJ0OiBmLFxuICAgICAgICAgICAgZW5kOiBvXG4gICAgICAgICAgfSxcbiAgICAgICAgICBpbnRlZ3JhdGVkOiB7XG4gICAgICAgICAgICBzdGFydDogZCxcbiAgICAgICAgICAgIGVuZDogY1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldER1cmF0aW9ucyhpLCBvLCBjKTtcbiAgICB9IGVsc2VcbiAgICAgIHIucHVzaCh7XG4gICAgICAgIHByZXZpb3VzRXZlbnQ6IG51bGwsXG4gICAgICAgIG5leHRFdmVudDogbnVsbCxcbiAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgIGVuZDogaSxcbiAgICAgICAgcGxheW91dDoge1xuICAgICAgICAgIHN0YXJ0OiAwLFxuICAgICAgICAgIGVuZDogaVxuICAgICAgICB9LFxuICAgICAgICBpbnRlZ3JhdGVkOiB7XG4gICAgICAgICAgc3RhcnQ6IDAsXG4gICAgICAgICAgZW5kOiBpXG4gICAgICAgIH1cbiAgICAgIH0pLCB0aGlzLnNldER1cmF0aW9ucyhpLCBpLCBpKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuICBzZXREdXJhdGlvbnMoZSwgdCwgcikge1xuICAgIHRoaXMuZHVyYXRpb25zID0ge1xuICAgICAgcHJpbWFyeTogZSxcbiAgICAgIHBsYXlvdXQ6IHQsXG4gICAgICBpbnRlZ3JhdGVkOiByXG4gICAgfTtcbiAgfVxuICByZXNvbHZlT2Zmc2V0cyhlLCB0KSB7XG4gICAgY29uc3QgciA9IHQubWFpbi5kZXRhaWxzLCBuID0gci5saXZlID8gMSAvIDAgOiByLmVkZ2U7XG4gICAgbGV0IGkgPSAwLCBvID0gLTE7XG4gICAgZS5mb3JFYWNoKChhLCBsKSA9PiB7XG4gICAgICBjb25zdCBjID0gYS5jdWUucHJlLCB1ID0gYS5jdWUucG9zdCwgZCA9IGMgPyAwIDogdSA/IG4gOiBhLnN0YXJ0VGltZTtcbiAgICAgIHRoaXMudXBkYXRlQXNzZXREdXJhdGlvbnMoYSksIG8gPT09IGQgPyBhLmN1bXVsYXRpdmVEdXJhdGlvbiA9IGkgOiAoaSA9IDAsIG8gPSBkKSwgIXUgJiYgYS5zbmFwT3B0aW9ucy5pbiAmJiAoYS5yZXN1bWVBbmNob3IgPSBKcyhudWxsLCByLmZyYWdtZW50cywgYS5zdGFydE9mZnNldCArIGEucmVzdW1wdGlvbk9mZnNldCwgMCwgMCkgfHwgdm9pZCAwKSwgYS5hcHBlbmRJblBsYWNlICYmICFhLmFwcGVuZEluUGxhY2VTdGFydGVkICYmICh0aGlzLnByaW1hcnlDYW5SZXN1bWVJblBsYWNlQXQoYSwgdCkgfHwgKGEuYXBwZW5kSW5QbGFjZSA9ICExKSksICFhLmFwcGVuZEluUGxhY2UgJiYgbCArIDEgPCBlLmxlbmd0aCAmJiBlW2wgKyAxXS5zdGFydFRpbWUgLSBlW2xdLnJlc3VtZVRpbWUgPCBYaCAmJiAoZVtsICsgMV0uYXBwZW5kSW5QbGFjZSA9ICExLCBlW2wgKyAxXS5hcHBlbmRJblBsYWNlICYmIHRoaXMud2FybihgQ291bGQgbm90IGNoYW5nZSBhcHBlbmQgc3RyYXRlZ3kgZm9yIGFidXR0aW5nIGV2ZW50ICR7YX1gKSk7XG4gICAgICBjb25zdCBmID0gdWUoYS5yZXN1bWVPZmZzZXQpID8gYS5yZXN1bWVPZmZzZXQgOiBhLmR1cmF0aW9uO1xuICAgICAgaSArPSBmO1xuICAgIH0pO1xuICB9XG4gIHByaW1hcnlDYW5SZXN1bWVJblBsYWNlQXQoZSwgdCkge1xuICAgIGNvbnN0IHIgPSBlLnJlc3VtZVRpbWUsIG4gPSBlLnN0YXJ0VGltZSArIGUucmVzdW1wdGlvbk9mZnNldDtcbiAgICByZXR1cm4gTWF0aC5hYnMociAtIG4pID4gUm4gPyAodGhpcy5sb2coYFwiJHtlLmlkZW50aWZpZXJ9XCIgcmVzdW1wdGlvbiAke3J9IG5vdCBhbGlnbmVkIHdpdGggZXN0aW1hdGVkIHRpbWVsaW5lIGVuZCAke259YCksICExKSA6ICFPYmplY3Qua2V5cyh0KS5zb21lKChvKSA9PiB7XG4gICAgICBjb25zdCBhID0gdFtvXS5kZXRhaWxzLCBsID0gYS5lZGdlO1xuICAgICAgaWYgKHIgPj0gbClcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nKGBcIiR7ZS5pZGVudGlmaWVyfVwiIHJlc3VtcHRpb24gJHtyfSBwYXN0ICR7b30gcGxheWxpc3QgZW5kICR7bH1gKSwgITE7XG4gICAgICBjb25zdCBjID0gSnMobnVsbCwgYS5mcmFnbWVudHMsIHIpO1xuICAgICAgaWYgKCFjKVxuICAgICAgICByZXR1cm4gdGhpcy5sb2coYFwiJHtlLmlkZW50aWZpZXJ9XCIgcmVzdW1wdGlvbiAke3J9IGRvZXMgbm90IGFsaWduIHdpdGggYW55IGZyYWdtZW50cyBpbiAke299IHBsYXlsaXN0ICgke2EuZnJhZ1N0YXJ0fS0ke2EuZnJhZ21lbnRFbmR9KWApLCAhMDtcbiAgICAgIGNvbnN0IHUgPSBvID09PSBcImF1ZGlvXCIgPyAwLjE3NSA6IDA7XG4gICAgICByZXR1cm4gTWF0aC5hYnMoYy5zdGFydCAtIHIpIDwgUm4gKyB1IHx8IE1hdGguYWJzKGMuZW5kIC0gcikgPCBSbiArIHUgPyAhMSA6ICh0aGlzLmxvZyhgXCIke2UuaWRlbnRpZmllcn1cIiByZXN1bXB0aW9uICR7cn0gbm90IGFsaWduZWQgd2l0aCAke299IGZyYWdtZW50IGJvdW5kcyAoJHtjLnN0YXJ0fS0ke2MuZW5kfSBzbjogJHtjLnNufSBjYzogJHtjLmNjfSlgKSwgITApO1xuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUFzc2V0RHVyYXRpb25zKGUpIHtcbiAgICBpZiAoIWUuYXNzZXRMaXN0TG9hZGVkKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBlLnRpbWVsaW5lU3RhcnQ7XG4gICAgbGV0IHIgPSAwLCBuID0gITEsIGkgPSAhMTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IGUuYXNzZXRMaXN0Lmxlbmd0aDsgbysrKSB7XG4gICAgICBjb25zdCBhID0gZS5hc3NldExpc3Rbb10sIGwgPSB0ICsgcjtcbiAgICAgIGEuc3RhcnRPZmZzZXQgPSByLCBhLnRpbWVsaW5lU3RhcnQgPSBsLCBuIHx8IChuID0gYS5kdXJhdGlvbiA9PT0gbnVsbCksIGkgfHwgKGkgPSAhIWEuZXJyb3IpO1xuICAgICAgY29uc3QgYyA9IGEuZXJyb3IgPyAwIDogYS5kdXJhdGlvbiB8fCAwO1xuICAgICAgciArPSBjO1xuICAgIH1cbiAgICBuICYmICFpID8gZS5kdXJhdGlvbiA9IE1hdGgubWF4KHIsIGUuZHVyYXRpb24pIDogZS5kdXJhdGlvbiA9IHI7XG4gIH1cbiAgcmVtb3ZlRXZlbnQoZSkge1xuICAgIGUucmVzZXQoKSwgZGVsZXRlIHRoaXMuZXZlbnRNYXBbZS5pZGVudGlmaWVyXTtcbiAgfVxufVxuZnVuY3Rpb24ga3Iocykge1xuICByZXR1cm4gYFske3MuZXZlbnQgPyAnXCInICsgcy5ldmVudC5pZGVudGlmaWVyICsgJ1wiJyA6IFwicHJpbWFyeVwifTogJHtzLnN0YXJ0LnRvRml4ZWQoMil9LSR7cy5lbmQudG9GaXhlZCgyKX1dYDtcbn1cbmNsYXNzIEV3IHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwLCB0aGlzLmhscyA9IGU7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmhscyA9IG51bGw7XG4gIH1cbiAgbG9hZEFzc2V0TGlzdChlLCB0KSB7XG4gICAgY29uc3QgciA9IGUuYXNzZXRMaXN0VXJsO1xuICAgIGxldCBuO1xuICAgIHRyeSB7XG4gICAgICBuID0gJHAociwgdGhpcy5obHMuc2Vzc2lvbklkLCBlLmJhc2VVcmwpO1xuICAgIH0gY2F0Y2ggKGgpIHtcbiAgICAgIGNvbnN0IGYgPSB0aGlzLmFzc2lnbkFzc2V0TGlzdEVycm9yKGUsIEouQVNTRVRfTElTVF9MT0FEX0VSUk9SLCBoLCByKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoSS5FUlJPUiwgZik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHQgJiYgbi5wcm90b2NvbCAhPT0gXCJkYXRhOlwiICYmIG4uc2VhcmNoUGFyYW1zLnNldChcIl9ITFNfc3RhcnRfb2Zmc2V0XCIsIFwiXCIgKyB0KTtcbiAgICBjb25zdCBpID0gdGhpcy5obHMuY29uZmlnLCBvID0gaS5sb2FkZXIsIGEgPSBuZXcgbyhpKSwgbCA9IHtcbiAgICAgIHJlc3BvbnNlVHlwZTogXCJqc29uXCIsXG4gICAgICB1cmw6IG4uaHJlZlxuICAgIH0sIGMgPSBpLmludGVyc3RpdGlhbEFzc2V0TGlzdExvYWRQb2xpY3kuZGVmYXVsdCwgdSA9IHtcbiAgICAgIGxvYWRQb2xpY3k6IGMsXG4gICAgICB0aW1lb3V0OiBjLm1heExvYWRUaW1lTXMsXG4gICAgICBtYXhSZXRyeTogMCxcbiAgICAgIHJldHJ5RGVsYXk6IDAsXG4gICAgICBtYXhSZXRyeURlbGF5OiAwXG4gICAgfSwgZCA9IHtcbiAgICAgIG9uU3VjY2VzczogKGgsIGYsIHAsIHkpID0+IHtcbiAgICAgICAgY29uc3QgRSA9IGguZGF0YSwgYiA9IEUgPT0gbnVsbCA/IHZvaWQgMCA6IEUuQVNTRVRTO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgICBjb25zdCBSID0gdGhpcy5hc3NpZ25Bc3NldExpc3RFcnJvcihlLCBKLkFTU0VUX0xJU1RfUEFSU0lOR19FUlJPUiwgbmV3IEVycm9yKFwiSW52YWxpZCBpbnRlcnN0aXRpYWwgYXNzZXQgbGlzdFwiKSwgcC51cmwsIGYsIHkpO1xuICAgICAgICAgIHRoaXMuaGxzLnRyaWdnZXIoSS5FUlJPUiwgUik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGUuYXNzZXRMaXN0UmVzcG9uc2UgPSBFLCB0aGlzLmhscy50cmlnZ2VyKEkuQVNTRVRfTElTVF9MT0FERUQsIHtcbiAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICBhc3NldExpc3RSZXNwb25zZTogRSxcbiAgICAgICAgICBuZXR3b3JrRGV0YWlsczogeVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkVycm9yOiAoaCwgZiwgcCwgeSkgPT4ge1xuICAgICAgICBjb25zdCBFID0gdGhpcy5hc3NpZ25Bc3NldExpc3RFcnJvcihlLCBKLkFTU0VUX0xJU1RfTE9BRF9FUlJPUiwgbmV3IEVycm9yKGBFcnJvciBsb2FkaW5nIFgtQVNTRVQtTElTVDogSFRUUCBzdGF0dXMgJHtoLmNvZGV9ICR7aC50ZXh0fSAoJHtmLnVybH0pYCksIGYudXJsLCB5LCBwKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihJLkVSUk9SLCBFKTtcbiAgICAgIH0sXG4gICAgICBvblRpbWVvdXQ6IChoLCBmLCBwKSA9PiB7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLmFzc2lnbkFzc2V0TGlzdEVycm9yKGUsIEouQVNTRVRfTElTVF9MT0FEX1RJTUVPVVQsIG5ldyBFcnJvcihgVGltZW91dCBsb2FkaW5nIFgtQVNTRVQtTElTVCAoJHtmLnVybH0pYCksIGYudXJsLCBoLCBwKTtcbiAgICAgICAgdGhpcy5obHMudHJpZ2dlcihJLkVSUk9SLCB5KTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBhLmxvYWQobCwgdSwgZCksIHRoaXMuaGxzLnRyaWdnZXIoSS5BU1NFVF9MSVNUX0xPQURJTkcsIHtcbiAgICAgIGV2ZW50OiBlXG4gICAgfSksIGE7XG4gIH1cbiAgYXNzaWduQXNzZXRMaXN0RXJyb3IoZSwgdCwgciwgbiwgaSwgbykge1xuICAgIHJldHVybiBlLmVycm9yID0gciwge1xuICAgICAgdHlwZTogdmUuTkVUV09SS19FUlJPUixcbiAgICAgIGRldGFpbHM6IHQsXG4gICAgICBmYXRhbDogITEsXG4gICAgICBpbnRlcnN0aXRpYWw6IGUsXG4gICAgICB1cmw6IG4sXG4gICAgICBlcnJvcjogcixcbiAgICAgIG5ldHdvcmtEZXRhaWxzOiBvLFxuICAgICAgc3RhdHM6IGlcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBKaChzKSB7XG4gIHMgPT0gbnVsbCB8fCBzLnBsYXkoKS5jYXRjaCgoKSA9PiB7XG4gIH0pO1xufVxuZnVuY3Rpb24gUWkocywgZSkge1xuICByZXR1cm4gYFske3N9XSBBZHZhbmNpbmcgdGltZWxpbmUgcG9zaXRpb24gdG8gJHtlfWA7XG59XG5jbGFzcyB4dyBleHRlbmRzIExyIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKFwiaW50ZXJzdGl0aWFsc1wiLCBlLmxvZ2dlciksIHRoaXMuSGxzUGxheWVyQ2xhc3MgPSB2b2lkIDAsIHRoaXMuaGxzID0gdm9pZCAwLCB0aGlzLmFzc2V0TGlzdExvYWRlciA9IHZvaWQgMCwgdGhpcy5tZWRpYVNlbGVjdGlvbiA9IG51bGwsIHRoaXMuYWx0U2VsZWN0aW9uID0gbnVsbCwgdGhpcy5tZWRpYSA9IG51bGwsIHRoaXMuZGV0YWNoZWREYXRhID0gbnVsbCwgdGhpcy5yZXF1aXJlZFRyYWNrcyA9IG51bGwsIHRoaXMubWFuYWdlciA9IG51bGwsIHRoaXMucGxheWVyUXVldWUgPSBbXSwgdGhpcy5idWZmZXJlZFBvcyA9IC0xLCB0aGlzLnRpbWVsaW5lUG9zID0gLTEsIHRoaXMuc2NoZWR1bGUgPSB2b2lkIDAsIHRoaXMucGxheWluZ0l0ZW0gPSBudWxsLCB0aGlzLmJ1ZmZlcmluZ0l0ZW0gPSBudWxsLCB0aGlzLndhaXRpbmdJdGVtID0gbnVsbCwgdGhpcy5lbmRlZEl0ZW0gPSBudWxsLCB0aGlzLnBsYXlpbmdBc3NldCA9IG51bGwsIHRoaXMuZW5kZWRBc3NldCA9IG51bGwsIHRoaXMuYnVmZmVyaW5nQXNzZXQgPSBudWxsLCB0aGlzLnNob3VsZFBsYXkgPSAhMSwgdGhpcy5vblBsYXkgPSAoKSA9PiB7XG4gICAgICB0aGlzLnNob3VsZFBsYXkgPSAhMDtcbiAgICB9LCB0aGlzLm9uUGF1c2UgPSAoKSA9PiB7XG4gICAgICB0aGlzLnNob3VsZFBsYXkgPSAhMTtcbiAgICB9LCB0aGlzLm9uU2Vla2luZyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgICAgaWYgKHIgPT09IHZvaWQgMCB8fCB0aGlzLnBsYXliYWNrRGlzYWJsZWQgfHwgIXRoaXMuc2NoZWR1bGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG4gPSByIC0gdGhpcy50aW1lbGluZVBvcztcbiAgICAgIGlmIChNYXRoLmFicyhuKSA8IDEgLyA3MDU2ZTUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG8gPSBuIDw9IC0wLjAxO1xuICAgICAgdGhpcy50aW1lbGluZVBvcyA9IHIsIHRoaXMuYnVmZmVyZWRQb3MgPSByO1xuICAgICAgY29uc3QgYSA9IHRoaXMucGxheWluZ0l0ZW07XG4gICAgICBpZiAoIWEpIHtcbiAgICAgICAgdGhpcy5jaGVja0J1ZmZlcigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobyAmJiB0aGlzLnNjaGVkdWxlLnJlc2V0RXJyb3JzSW5SYW5nZShyLCByIC0gbikgJiYgdGhpcy51cGRhdGVTY2hlZHVsZSghMCksIHRoaXMuY2hlY2tCdWZmZXIoKSwgbyAmJiByIDwgYS5zdGFydCB8fCByID49IGEuZW5kKSB7XG4gICAgICAgIHZhciBsO1xuICAgICAgICBjb25zdCBmID0gdGhpcy5maW5kSXRlbUluZGV4KGEpO1xuICAgICAgICBsZXQgcCA9IHRoaXMuc2NoZWR1bGUuZmluZEl0ZW1JbmRleEF0VGltZShyKTtcbiAgICAgICAgaWYgKHAgPT09IC0xICYmIChwID0gZiArIChvID8gLTEgOiAxKSwgdGhpcy5sb2coYHNlZWtlZCAke28gPyBcImJhY2sgXCIgOiBcIlwifXRvIHBvc2l0aW9uIG5vdCBjb3ZlcmVkIGJ5IHNjaGVkdWxlICR7cn0gKHJlc29sdmluZyBmcm9tICR7Zn0gdG8gJHtwfSlgKSksICF0aGlzLmlzSW50ZXJzdGl0aWFsKGEpICYmIChsID0gdGhpcy5tZWRpYSkgIT0gbnVsbCAmJiBsLnBhdXNlZCAmJiAodGhpcy5zaG91bGRQbGF5ID0gITEpLCAhbyAmJiBwID4gZikge1xuICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLnNjaGVkdWxlLmZpbmRKdW1wUmVzdHJpY3RlZEluZGV4KGYgKyAxLCBwKTtcbiAgICAgICAgICBpZiAoeSA+IGYpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbih5KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKHApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBjID0gdGhpcy5wbGF5aW5nQXNzZXQ7XG4gICAgICBpZiAoIWMpIHtcbiAgICAgICAgaWYgKHRoaXMucGxheWluZ0xhc3RJdGVtICYmIHRoaXMuaXNJbnRlcnN0aXRpYWwoYSkpIHtcbiAgICAgICAgICBjb25zdCBmID0gYS5ldmVudC5hc3NldExpc3RbMF07XG4gICAgICAgICAgZiAmJiAodGhpcy5lbmRlZEl0ZW0gPSB0aGlzLnBsYXlpbmdJdGVtLCB0aGlzLnBsYXlpbmdJdGVtID0gbnVsbCwgdGhpcy5zZXRTY2hlZHVsZVRvQXNzZXRBdFRpbWUociwgZikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHUgPSBjLnRpbWVsaW5lU3RhcnQsIGQgPSBjLmR1cmF0aW9uIHx8IDA7XG4gICAgICBpZiAobyAmJiByIDwgdSB8fCByID49IHUgKyBkKSB7XG4gICAgICAgIHZhciBoO1xuICAgICAgICAoaCA9IGEuZXZlbnQpICE9IG51bGwgJiYgaC5hcHBlbmRJblBsYWNlICYmICh0aGlzLmNsZWFySW50ZXJzdGl0aWFsKGEuZXZlbnQsIGEpLCB0aGlzLmZsdXNoRnJvbnRCdWZmZXIocikpLCB0aGlzLnNldFNjaGVkdWxlVG9Bc3NldEF0VGltZShyLCBjKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLm9uVGltZXVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgICAgaWYgKHIgPT09IHZvaWQgMCB8fCB0aGlzLnBsYXliYWNrRGlzYWJsZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChyID4gdGhpcy50aW1lbGluZVBvcylcbiAgICAgICAgdGhpcy50aW1lbGluZVBvcyA9IHIsIHIgPiB0aGlzLmJ1ZmZlcmVkUG9zICYmIHRoaXMuY2hlY2tCdWZmZXIoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbiA9IHRoaXMucGxheWluZ0l0ZW07XG4gICAgICBpZiAoIW4gfHwgdGhpcy5wbGF5aW5nTGFzdEl0ZW0pXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmIChyID49IG4uZW5kKSB7XG4gICAgICAgIHRoaXMudGltZWxpbmVQb3MgPSBuLmVuZDtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuZmluZEl0ZW1JbmRleChuKTtcbiAgICAgICAgdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKGEgKyAxKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGkgPSB0aGlzLnBsYXlpbmdBc3NldDtcbiAgICAgIGlmICghaSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbyA9IGkudGltZWxpbmVTdGFydCArIChpLmR1cmF0aW9uIHx8IDApO1xuICAgICAgciA+PSBvICYmIHRoaXMuc2V0U2NoZWR1bGVUb0Fzc2V0QXRUaW1lKHIsIGkpO1xuICAgIH0sIHRoaXMub25TY2hlZHVsZVVwZGF0ZSA9IChyLCBuKSA9PiB7XG4gICAgICBjb25zdCBpID0gdGhpcy5zY2hlZHVsZTtcbiAgICAgIGlmICghaSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgbyA9IHRoaXMucGxheWluZ0l0ZW0sIGEgPSBpLmV2ZW50cyB8fCBbXSwgbCA9IGkuaXRlbXMgfHwgW10sIGMgPSBpLmR1cmF0aW9ucywgdSA9IHIubWFwKCh5KSA9PiB5LmlkZW50aWZpZXIpLCBkID0gISEoYS5sZW5ndGggfHwgdS5sZW5ndGgpO1xuICAgICAgKGQgfHwgbikgJiYgdGhpcy5sb2coYElOVEVSU1RJVElBTFNfVVBEQVRFRCAoJHthLmxlbmd0aH0pOiAke2F9XG5TY2hlZHVsZTogJHtsLm1hcCgoeSkgPT4ga3IoeSkpfSBwb3M6ICR7dGhpcy50aW1lbGluZVBvc31gKSwgdS5sZW5ndGggJiYgdGhpcy5sb2coYFJlbW92ZWQgZXZlbnRzICR7dX1gKTtcbiAgICAgIGxldCBoID0gbnVsbCwgZiA9IG51bGw7XG4gICAgICBvICYmIChoID0gdGhpcy51cGRhdGVJdGVtKG8sIHRoaXMudGltZWxpbmVQb3MpLCB0aGlzLml0ZW1zTWF0Y2gobywgaCkgPyB0aGlzLnBsYXlpbmdJdGVtID0gaCA6IHRoaXMud2FpdGluZ0l0ZW0gPSB0aGlzLmVuZGVkSXRlbSA9IG51bGwpLCB0aGlzLndhaXRpbmdJdGVtID0gdGhpcy51cGRhdGVJdGVtKHRoaXMud2FpdGluZ0l0ZW0pLCB0aGlzLmVuZGVkSXRlbSA9IHRoaXMudXBkYXRlSXRlbSh0aGlzLmVuZGVkSXRlbSk7XG4gICAgICBjb25zdCBwID0gdGhpcy5idWZmZXJpbmdJdGVtO1xuICAgICAgaWYgKHAgJiYgKGYgPSB0aGlzLnVwZGF0ZUl0ZW0ocCwgdGhpcy5idWZmZXJlZFBvcyksIHRoaXMuaXRlbXNNYXRjaChwLCBmKSA/IHRoaXMuYnVmZmVyaW5nSXRlbSA9IGYgOiBwLmV2ZW50ICYmICh0aGlzLmJ1ZmZlcmluZ0l0ZW0gPSB0aGlzLnBsYXlpbmdJdGVtLCB0aGlzLmNsZWFySW50ZXJzdGl0aWFsKHAuZXZlbnQsIG51bGwpKSksIHIuZm9yRWFjaCgoeSkgPT4ge1xuICAgICAgICB5LmFzc2V0TGlzdC5mb3JFYWNoKChFKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbGVhckFzc2V0UGxheWVyKEUuaWRlbnRpZmllciwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgfSksIHRoaXMucGxheWVyUXVldWUuZm9yRWFjaCgoeSkgPT4ge1xuICAgICAgICBpZiAoeS5pbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAgIGNvbnN0IEUgPSB5LmFzc2V0SXRlbS50aW1lbGluZVN0YXJ0LCBiID0geS50aW1lbGluZU9mZnNldCAtIEU7XG4gICAgICAgICAgaWYgKGIpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB5LnRpbWVsaW5lT2Zmc2V0ID0gRTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKFIpIHtcbiAgICAgICAgICAgICAgTWF0aC5hYnMoYikgPiBSbiAmJiB0aGlzLndhcm4oYCR7Un0gKFwiJHt5LmFzc2V0SWR9XCIgJHt5LnRpbWVsaW5lT2Zmc2V0fS0+JHtFfSlgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksIGQgfHwgbikge1xuICAgICAgICBpZiAodGhpcy5obHMudHJpZ2dlcihJLklOVEVSU1RJVElBTFNfVVBEQVRFRCwge1xuICAgICAgICAgIGV2ZW50czogYS5zbGljZSgwKSxcbiAgICAgICAgICBzY2hlZHVsZTogbC5zbGljZSgwKSxcbiAgICAgICAgICBkdXJhdGlvbnM6IGMsXG4gICAgICAgICAgcmVtb3ZlZElkczogdVxuICAgICAgICB9KSwgdGhpcy5pc0ludGVyc3RpdGlhbChvKSAmJiB1LmluY2x1ZGVzKG8uZXZlbnQuaWRlbnRpZmllcikpIHtcbiAgICAgICAgICB0aGlzLndhcm4oYEludGVyc3RpdGlhbCBcIiR7by5ldmVudC5pZGVudGlmaWVyfVwiIHJlbW92ZWQgd2hpbGUgcGxheWluZ2ApLCB0aGlzLnByaW1hcnlGYWxsYmFjayhvLmV2ZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbyAmJiB0aGlzLnRyaW1JblBsYWNlKGgsIG8pLCBwICYmIGYgIT09IGggJiYgdGhpcy50cmltSW5QbGFjZShmLCBwKSwgdGhpcy5jaGVja0J1ZmZlcigpO1xuICAgICAgfVxuICAgIH0sIHRoaXMuaGxzID0gZSwgdGhpcy5IbHNQbGF5ZXJDbGFzcyA9IHQsIHRoaXMuYXNzZXRMaXN0TG9hZGVyID0gbmV3IEV3KGUpLCB0aGlzLnNjaGVkdWxlID0gbmV3IHZ3KHRoaXMub25TY2hlZHVsZVVwZGF0ZSwgZS5sb2dnZXIpLCB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuaGxzO1xuICAgIGUgJiYgKGUub24oSS5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyksIGUub24oSS5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpLCBlLm9uKEkuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpLCBlLm9uKEkuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyksIGUub24oSS5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKSwgZS5vbihJLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpLCBlLm9uKEkuQVVESU9fVFJBQ0tfVVBEQVRFRCwgdGhpcy5vbkF1ZGlvVHJhY2tVcGRhdGVkLCB0aGlzKSwgZS5vbihJLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwgdGhpcy5vblN1YnRpdGxlVHJhY2tTd2l0Y2gsIHRoaXMpLCBlLm9uKEkuU1VCVElUTEVfVFJBQ0tfVVBEQVRFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tVcGRhdGVkLCB0aGlzKSwgZS5vbihJLkVWRU5UX0NVRV9FTlRFUiwgdGhpcy5vbkludGVyc3RpdGlhbEN1ZUVudGVyLCB0aGlzKSwgZS5vbihJLkFTU0VUX0xJU1RfTE9BREVELCB0aGlzLm9uQXNzZXRMaXN0TG9hZGVkLCB0aGlzKSwgZS5vbihJLkJVRkZFUl9BUFBFTkRFRCwgdGhpcy5vbkJ1ZmZlckFwcGVuZGVkLCB0aGlzKSwgZS5vbihJLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyksIGUub24oSS5CVUZGRVJFRF9UT19FTkQsIHRoaXMub25CdWZmZXJlZFRvRW5kLCB0aGlzKSwgZS5vbihJLk1FRElBX0VOREVELCB0aGlzLm9uTWVkaWFFbmRlZCwgdGhpcyksIGUub24oSS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKSwgZS5vbihJLkRFU1RST1lJTkcsIHRoaXMub25EZXN0cm95aW5nLCB0aGlzKSk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5obHM7XG4gICAgZSAmJiAoZS5vZmYoSS5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyksIGUub2ZmKEkuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKSwgZS5vZmYoSS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyksIGUub2ZmKEkuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyksIGUub2ZmKEkuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyksIGUub2ZmKEkuQVVESU9fVFJBQ0tfU1dJVENISU5HLCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGluZywgdGhpcyksIGUub2ZmKEkuQVVESU9fVFJBQ0tfVVBEQVRFRCwgdGhpcy5vbkF1ZGlvVHJhY2tVcGRhdGVkLCB0aGlzKSwgZS5vZmYoSS5TVUJUSVRMRV9UUkFDS19TV0lUQ0gsIHRoaXMub25TdWJ0aXRsZVRyYWNrU3dpdGNoLCB0aGlzKSwgZS5vZmYoSS5TVUJUSVRMRV9UUkFDS19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja1VwZGF0ZWQsIHRoaXMpLCBlLm9mZihJLkVWRU5UX0NVRV9FTlRFUiwgdGhpcy5vbkludGVyc3RpdGlhbEN1ZUVudGVyLCB0aGlzKSwgZS5vZmYoSS5BU1NFVF9MSVNUX0xPQURFRCwgdGhpcy5vbkFzc2V0TGlzdExvYWRlZCwgdGhpcyksIGUub2ZmKEkuQlVGRkVSX0NPREVDUywgdGhpcy5vbkJ1ZmZlckNvZGVjcywgdGhpcyksIGUub2ZmKEkuQlVGRkVSX0FQUEVOREVELCB0aGlzLm9uQnVmZmVyQXBwZW5kZWQsIHRoaXMpLCBlLm9mZihJLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyksIGUub2ZmKEkuQlVGRkVSRURfVE9fRU5ELCB0aGlzLm9uQnVmZmVyZWRUb0VuZCwgdGhpcyksIGUub2ZmKEkuTUVESUFfRU5ERUQsIHRoaXMub25NZWRpYUVuZGVkLCB0aGlzKSwgZS5vZmYoSS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKSwgZS5vZmYoSS5ERVNUUk9ZSU5HLCB0aGlzLm9uRGVzdHJveWluZywgdGhpcykpO1xuICB9XG4gIHN0YXJ0TG9hZCgpIHtcbiAgICB0aGlzLnJlc3VtZUJ1ZmZlcmluZygpO1xuICB9XG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMucGF1c2VCdWZmZXJpbmcoKTtcbiAgfVxuICByZXN1bWVCdWZmZXJpbmcoKSB7XG4gICAgdmFyIGU7XG4gICAgKGUgPSB0aGlzLmdldEJ1ZmZlcmluZ1BsYXllcigpKSA9PSBudWxsIHx8IGUucmVzdW1lQnVmZmVyaW5nKCk7XG4gIH1cbiAgcGF1c2VCdWZmZXJpbmcoKSB7XG4gICAgdmFyIGU7XG4gICAgKGUgPSB0aGlzLmdldEJ1ZmZlcmluZ1BsYXllcigpKSA9PSBudWxsIHx8IGUucGF1c2VCdWZmZXJpbmcoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpLCB0aGlzLnN0b3BMb2FkKCksIHRoaXMuYXNzZXRMaXN0TG9hZGVyICYmIHRoaXMuYXNzZXRMaXN0TG9hZGVyLmRlc3Ryb3koKSwgdGhpcy5lbXB0eVBsYXllclF1ZXVlKCksIHRoaXMuY2xlYXJTY2hlZHVsZVN0YXRlKCksIHRoaXMuc2NoZWR1bGUgJiYgdGhpcy5zY2hlZHVsZS5kZXN0cm95KCksIHRoaXMubWVkaWEgPSB0aGlzLmRldGFjaGVkRGF0YSA9IHRoaXMubWVkaWFTZWxlY3Rpb24gPSB0aGlzLnJlcXVpcmVkVHJhY2tzID0gdGhpcy5hbHRTZWxlY3Rpb24gPSB0aGlzLnNjaGVkdWxlID0gdGhpcy5tYW5hZ2VyID0gbnVsbCwgdGhpcy5obHMgPSB0aGlzLkhsc1BsYXllckNsYXNzID0gdGhpcy5sb2cgPSBudWxsLCB0aGlzLmFzc2V0TGlzdExvYWRlciA9IG51bGwsIHRoaXMub25QbGF5ID0gdGhpcy5vblBhdXNlID0gdGhpcy5vblNlZWtpbmcgPSB0aGlzLm9uVGltZXVwZGF0ZSA9IG51bGwsIHRoaXMub25TY2hlZHVsZVVwZGF0ZSA9IG51bGw7XG4gIH1cbiAgb25EZXN0cm95aW5nKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnByaW1hcnlNZWRpYSB8fCB0aGlzLm1lZGlhO1xuICAgIGUgJiYgdGhpcy5yZW1vdmVNZWRpYUxpc3RlbmVycyhlKTtcbiAgfVxuICByZW1vdmVNZWRpYUxpc3RlbmVycyhlKSB7XG4gICAgcHIoZSwgXCJwbGF5XCIsIHRoaXMub25QbGF5KSwgcHIoZSwgXCJwYXVzZVwiLCB0aGlzLm9uUGF1c2UpLCBwcihlLCBcInNlZWtpbmdcIiwgdGhpcy5vblNlZWtpbmcpLCBwcihlLCBcInRpbWV1cGRhdGVcIiwgdGhpcy5vblRpbWV1cGRhdGUpO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hpbmcoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLm1lZGlhID0gdC5tZWRpYTtcbiAgICBjcihyLCBcInNlZWtpbmdcIiwgdGhpcy5vblNlZWtpbmcpLCBjcihyLCBcInRpbWV1cGRhdGVcIiwgdGhpcy5vblRpbWV1cGRhdGUpLCBjcihyLCBcInBsYXlcIiwgdGhpcy5vblBsYXkpLCBjcihyLCBcInBhdXNlXCIsIHRoaXMub25QYXVzZSk7XG4gIH1cbiAgb25NZWRpYUF0dGFjaGVkKGUsIHQpIHtcbiAgICBjb25zdCByID0gdGhpcy5lZmZlY3RpdmVQbGF5aW5nSXRlbSwgbiA9IHRoaXMuZGV0YWNoZWREYXRhO1xuICAgIGlmICh0aGlzLmRldGFjaGVkRGF0YSA9IG51bGwsIHIgPT09IG51bGwpXG4gICAgICB0aGlzLmNoZWNrU3RhcnQoKTtcbiAgICBlbHNlIGlmICghbikge1xuICAgICAgdGhpcy5jbGVhclNjaGVkdWxlU3RhdGUoKTtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLmZpbmRJdGVtSW5kZXgocik7XG4gICAgICB0aGlzLnNldFNjaGVkdWxlUG9zaXRpb24oaSk7XG4gICAgfVxuICB9XG4gIGNsZWFyU2NoZWR1bGVTdGF0ZSgpIHtcbiAgICB0aGlzLmxvZyhcImNsZWFyIHNjaGVkdWxlIHN0YXRlXCIpLCB0aGlzLnBsYXlpbmdJdGVtID0gdGhpcy5idWZmZXJpbmdJdGVtID0gdGhpcy53YWl0aW5nSXRlbSA9IHRoaXMuZW5kZWRJdGVtID0gdGhpcy5wbGF5aW5nQXNzZXQgPSB0aGlzLmVuZGVkQXNzZXQgPSB0aGlzLmJ1ZmZlcmluZ0Fzc2V0ID0gbnVsbDtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKGUsIHQpIHtcbiAgICBjb25zdCByID0gISF0LnRyYW5zZmVyTWVkaWEsIG4gPSB0aGlzLm1lZGlhO1xuICAgIGlmICh0aGlzLm1lZGlhID0gbnVsbCwgIXIgJiYgKG4gJiYgdGhpcy5yZW1vdmVNZWRpYUxpc3RlbmVycyhuKSwgdGhpcy5kZXRhY2hlZERhdGEpKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5nZXRCdWZmZXJpbmdQbGF5ZXIoKTtcbiAgICAgIGkgJiYgKHRoaXMubG9nKGBSZW1vdmluZyBzY2hlZHVsZSBzdGF0ZSBmb3IgZGV0YWNoZWREYXRhIGFuZCAke2l9YCksIHRoaXMucGxheWluZ0Fzc2V0ID0gdGhpcy5lbmRlZEFzc2V0ID0gdGhpcy5idWZmZXJpbmdBc3NldCA9IHRoaXMuYnVmZmVyaW5nSXRlbSA9IHRoaXMud2FpdGluZ0l0ZW0gPSB0aGlzLmRldGFjaGVkRGF0YSA9IG51bGwsIGkuZGV0YWNoTWVkaWEoKSksIHRoaXMuc2hvdWxkUGxheSA9ICExO1xuICAgIH1cbiAgfVxuICBnZXQgaW50ZXJzdGl0aWFsc01hbmFnZXIoKSB7XG4gICAgaWYgKCF0aGlzLmhscylcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGlmICh0aGlzLm1hbmFnZXIpXG4gICAgICByZXR1cm4gdGhpcy5tYW5hZ2VyO1xuICAgIGNvbnN0IGUgPSB0aGlzLCB0ID0gKCkgPT4gZS5idWZmZXJpbmdJdGVtIHx8IGUud2FpdGluZ0l0ZW0sIHIgPSAoZCkgPT4gZCAmJiBlLmdldEFzc2V0UGxheWVyKGQuaWRlbnRpZmllciksIG4gPSAoZCwgaCwgZiwgcCwgeSkgPT4ge1xuICAgICAgaWYgKGQpIHtcbiAgICAgICAgbGV0IEUgPSBkW2hdLnN0YXJ0O1xuICAgICAgICBjb25zdCBiID0gZC5ldmVudDtcbiAgICAgICAgaWYgKGIpIHtcbiAgICAgICAgICBpZiAoaCA9PT0gXCJwbGF5b3V0XCIgfHwgYi50aW1lbGluZU9jY3VwYW5jeSAhPT0gaWEuUG9pbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IFIgPSByKGYpO1xuICAgICAgICAgICAgKFIgPT0gbnVsbCA/IHZvaWQgMCA6IFIuaW50ZXJzdGl0aWFsKSA9PT0gYiAmJiAoRSArPSBSLmFzc2V0SXRlbS5zdGFydE9mZnNldCArIFJbeV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBSID0gcCA9PT0gXCJidWZmZXJlZFBvc1wiID8gbygpIDogZVtwXTtcbiAgICAgICAgICBFICs9IFIgLSBkLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfSwgaSA9IChkLCBoKSA9PiB7XG4gICAgICB2YXIgZjtcbiAgICAgIGlmIChkICE9PSAwICYmIGggIT09IFwicHJpbWFyeVwiICYmIChmID0gZS5zY2hlZHVsZSkgIT0gbnVsbCAmJiBmLmxlbmd0aCkge1xuICAgICAgICB2YXIgcDtcbiAgICAgICAgY29uc3QgeSA9IGUuc2NoZWR1bGUuZmluZEl0ZW1JbmRleEF0VGltZShkKSwgRSA9IChwID0gZS5zY2hlZHVsZS5pdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IHBbeV07XG4gICAgICAgIGlmIChFKSB7XG4gICAgICAgICAgY29uc3QgYiA9IEVbaF0uc3RhcnQgLSBFLnN0YXJ0O1xuICAgICAgICAgIHJldHVybiBkICsgYjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGQ7XG4gICAgfSwgbyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGQgPSBlLmJ1ZmZlcmVkUG9zO1xuICAgICAgcmV0dXJuIGQgPT09IE51bWJlci5NQVhfVkFMVUUgPyBhKFwicHJpbWFyeVwiKSA6IE1hdGgubWF4KGQsIDApO1xuICAgIH0sIGEgPSAoZCkgPT4ge1xuICAgICAgdmFyIGgsIGY7XG4gICAgICByZXR1cm4gKGggPSBlLnByaW1hcnlEZXRhaWxzKSAhPSBudWxsICYmIGgubGl2ZSA/IGUucHJpbWFyeURldGFpbHMuZWRnZSA6ICgoZiA9IGUuc2NoZWR1bGUpID09IG51bGwgPyB2b2lkIDAgOiBmLmR1cmF0aW9uc1tkXSkgfHwgMDtcbiAgICB9LCBsID0gKGQsIGgpID0+IHtcbiAgICAgIHZhciBmLCBwO1xuICAgICAgY29uc3QgeSA9IGUuZWZmZWN0aXZlUGxheWluZ0l0ZW07XG4gICAgICBpZiAoeSAhPSBudWxsICYmIChmID0geS5ldmVudCkgIT0gbnVsbCAmJiBmLnJlc3RyaWN0aW9ucy5za2lwIHx8ICFlLnNjaGVkdWxlKVxuICAgICAgICByZXR1cm47XG4gICAgICBlLmxvZyhgc2VlayB0byAke2R9IFwiJHtofVwiYCk7XG4gICAgICBjb25zdCBFID0gZS5lZmZlY3RpdmVQbGF5aW5nSXRlbSwgYiA9IGUuc2NoZWR1bGUuZmluZEl0ZW1JbmRleEF0VGltZShkLCBoKSwgUiA9IChwID0gZS5zY2hlZHVsZS5pdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IHBbYl0sIEEgPSBlLmdldEJ1ZmZlcmluZ1BsYXllcigpLCBGID0gQSA9PSBudWxsID8gdm9pZCAwIDogQS5pbnRlcnN0aXRpYWwsIE0gPSBGID09IG51bGwgPyB2b2lkIDAgOiBGLmFwcGVuZEluUGxhY2UsIEggPSBFICYmIGUuaXRlbXNNYXRjaChFLCBSKTtcbiAgICAgIGlmIChFICYmIChNIHx8IEgpKSB7XG4gICAgICAgIGNvbnN0IEsgPSByKGUucGxheWluZ0Fzc2V0KSwgaiA9IChLID09IG51bGwgPyB2b2lkIDAgOiBLLm1lZGlhKSB8fCBlLnByaW1hcnlNZWRpYTtcbiAgICAgICAgaWYgKGopIHtcbiAgICAgICAgICBjb25zdCBDID0gaCA9PT0gXCJwcmltYXJ5XCIgPyBqLmN1cnJlbnRUaW1lIDogbihFLCBoLCBlLnBsYXlpbmdBc3NldCwgXCJ0aW1lbGluZVBvc1wiLCBcImN1cnJlbnRUaW1lXCIpLCBrID0gZCAtIEMsICQgPSAoTSA/IEMgOiBqLmN1cnJlbnRUaW1lKSArIGs7XG4gICAgICAgICAgaWYgKCQgPj0gMCAmJiAoIUsgfHwgTSB8fCAkIDw9IEsuZHVyYXRpb24pKSB7XG4gICAgICAgICAgICBqLmN1cnJlbnRUaW1lID0gJDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChSKSB7XG4gICAgICAgIGxldCBLID0gZDtcbiAgICAgICAgaWYgKGggIT09IFwicHJpbWFyeVwiKSB7XG4gICAgICAgICAgY29uc3QgQyA9IFJbaF0uc3RhcnQsIGsgPSBkIC0gQztcbiAgICAgICAgICBLID0gUi5zdGFydCArIGs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaiA9ICFlLmlzSW50ZXJzdGl0aWFsKFIpO1xuICAgICAgICBpZiAoKCFlLmlzSW50ZXJzdGl0aWFsKEUpIHx8IEUuZXZlbnQuYXBwZW5kSW5QbGFjZSkgJiYgKGogfHwgUi5ldmVudC5hcHBlbmRJblBsYWNlKSkge1xuICAgICAgICAgIGNvbnN0IEMgPSBlLm1lZGlhIHx8IChNID8gQSA9PSBudWxsID8gdm9pZCAwIDogQS5tZWRpYSA6IG51bGwpO1xuICAgICAgICAgIEMgJiYgKEMuY3VycmVudFRpbWUgPSBLKTtcbiAgICAgICAgfSBlbHNlIGlmIChFKSB7XG4gICAgICAgICAgY29uc3QgQyA9IGUuZmluZEl0ZW1JbmRleChFKTtcbiAgICAgICAgICBpZiAoYiA+IEMpIHtcbiAgICAgICAgICAgIGNvbnN0ICQgPSBlLnNjaGVkdWxlLmZpbmRKdW1wUmVzdHJpY3RlZEluZGV4KEMgKyAxLCBiKTtcbiAgICAgICAgICAgIGlmICgkID4gQykge1xuICAgICAgICAgICAgICBlLnNldFNjaGVkdWxlUG9zaXRpb24oJCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGsgPSAwO1xuICAgICAgICAgIGlmIChqKVxuICAgICAgICAgICAgZS50aW1lbGluZVBvcyA9IEssIGUuY2hlY2tCdWZmZXIoKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0ICQgPSBSLmV2ZW50LmFzc2V0TGlzdCwgVyA9IGQgLSAoUltoXSB8fCBSKS5zdGFydDtcbiAgICAgICAgICAgIGZvciAobGV0IF8gPSAkLmxlbmd0aDsgXy0tOyApIHtcbiAgICAgICAgICAgICAgY29uc3QgZyA9ICRbX107XG4gICAgICAgICAgICAgIGlmIChnLmR1cmF0aW9uICYmIFcgPj0gZy5zdGFydE9mZnNldCAmJiBXIDwgZy5zdGFydE9mZnNldCArIGcuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBrID0gXztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlLnNldFNjaGVkdWxlUG9zaXRpb24oYiwgayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBjID0gKCkgPT4ge1xuICAgICAgY29uc3QgZCA9IGUuZWZmZWN0aXZlUGxheWluZ0l0ZW07XG4gICAgICBpZiAoZS5pc0ludGVyc3RpdGlhbChkKSlcbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgICBjb25zdCBoID0gdCgpO1xuICAgICAgcmV0dXJuIGUuaXNJbnRlcnN0aXRpYWwoaCkgPyBoIDogbnVsbDtcbiAgICB9LCB1ID0ge1xuICAgICAgZ2V0IGJ1ZmZlcmVkRW5kKCkge1xuICAgICAgICBjb25zdCBkID0gdCgpLCBoID0gZS5idWZmZXJpbmdJdGVtO1xuICAgICAgICBpZiAoaCAmJiBoID09PSBkKSB7XG4gICAgICAgICAgdmFyIGY7XG4gICAgICAgICAgcmV0dXJuIG4oaCwgXCJwbGF5b3V0XCIsIGUuYnVmZmVyaW5nQXNzZXQsIFwiYnVmZmVyZWRQb3NcIiwgXCJidWZmZXJlZEVuZFwiKSAtIGgucGxheW91dC5zdGFydCB8fCAoKGYgPSBlLmJ1ZmZlcmluZ0Fzc2V0KSA9PSBudWxsID8gdm9pZCAwIDogZi5zdGFydE9mZnNldCkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH0sXG4gICAgICBnZXQgY3VycmVudFRpbWUoKSB7XG4gICAgICAgIGNvbnN0IGQgPSBjKCksIGggPSBlLmVmZmVjdGl2ZVBsYXlpbmdJdGVtO1xuICAgICAgICByZXR1cm4gaCAmJiBoID09PSBkID8gbihoLCBcInBsYXlvdXRcIiwgZS5lZmZlY3RpdmVQbGF5aW5nQXNzZXQsIFwidGltZWxpbmVQb3NcIiwgXCJjdXJyZW50VGltZVwiKSAtIGgucGxheW91dC5zdGFydCA6IDA7XG4gICAgICB9LFxuICAgICAgc2V0IGN1cnJlbnRUaW1lKGQpIHtcbiAgICAgICAgY29uc3QgaCA9IGMoKSwgZiA9IGUuZWZmZWN0aXZlUGxheWluZ0l0ZW07XG4gICAgICAgIGYgJiYgZiA9PT0gaCAmJiBsKGQgKyBmLnBsYXlvdXQuc3RhcnQsIFwicGxheW91dFwiKTtcbiAgICAgIH0sXG4gICAgICBnZXQgZHVyYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGQgPSBjKCk7XG4gICAgICAgIHJldHVybiBkID8gZC5wbGF5b3V0LmVuZCAtIGQucGxheW91dC5zdGFydCA6IDA7XG4gICAgICB9LFxuICAgICAgZ2V0IGFzc2V0UGxheWVycygpIHtcbiAgICAgICAgdmFyIGQ7XG4gICAgICAgIGNvbnN0IGggPSAoZCA9IGMoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGQuZXZlbnQuYXNzZXRMaXN0O1xuICAgICAgICByZXR1cm4gaCA/IGgubWFwKChmKSA9PiBlLmdldEFzc2V0UGxheWVyKGYuaWRlbnRpZmllcikpIDogW107XG4gICAgICB9LFxuICAgICAgZ2V0IHBsYXlpbmdJbmRleCgpIHtcbiAgICAgICAgdmFyIGQ7XG4gICAgICAgIGNvbnN0IGggPSAoZCA9IGMoKSkgPT0gbnVsbCA/IHZvaWQgMCA6IGQuZXZlbnQ7XG4gICAgICAgIHJldHVybiBoICYmIGUuZWZmZWN0aXZlUGxheWluZ0Fzc2V0ID8gaC5maW5kQXNzZXRJbmRleChlLmVmZmVjdGl2ZVBsYXlpbmdBc3NldCkgOiAtMTtcbiAgICAgIH0sXG4gICAgICBnZXQgc2NoZWR1bGVJdGVtKCkge1xuICAgICAgICByZXR1cm4gYygpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHRoaXMubWFuYWdlciA9IHtcbiAgICAgIGdldCBldmVudHMoKSB7XG4gICAgICAgIHZhciBkO1xuICAgICAgICByZXR1cm4gKChkID0gZS5zY2hlZHVsZSkgPT0gbnVsbCB8fCAoZCA9IGQuZXZlbnRzKSA9PSBudWxsID8gdm9pZCAwIDogZC5zbGljZSgwKSkgfHwgW107XG4gICAgICB9LFxuICAgICAgZ2V0IHNjaGVkdWxlKCkge1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgcmV0dXJuICgoZCA9IGUuc2NoZWR1bGUpID09IG51bGwgfHwgKGQgPSBkLml0ZW1zKSA9PSBudWxsID8gdm9pZCAwIDogZC5zbGljZSgwKSkgfHwgW107XG4gICAgICB9LFxuICAgICAgZ2V0IGludGVyc3RpdGlhbFBsYXllcigpIHtcbiAgICAgICAgcmV0dXJuIGMoKSA/IHUgOiBudWxsO1xuICAgICAgfSxcbiAgICAgIGdldCBwbGF5ZXJRdWV1ZSgpIHtcbiAgICAgICAgcmV0dXJuIGUucGxheWVyUXVldWUuc2xpY2UoMCk7XG4gICAgICB9LFxuICAgICAgZ2V0IGJ1ZmZlcmluZ0Fzc2V0KCkge1xuICAgICAgICByZXR1cm4gZS5idWZmZXJpbmdBc3NldDtcbiAgICAgIH0sXG4gICAgICBnZXQgYnVmZmVyaW5nSXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIHQoKTtcbiAgICAgIH0sXG4gICAgICBnZXQgYnVmZmVyaW5nSW5kZXgoKSB7XG4gICAgICAgIGNvbnN0IGQgPSB0KCk7XG4gICAgICAgIHJldHVybiBlLmZpbmRJdGVtSW5kZXgoZCk7XG4gICAgICB9LFxuICAgICAgZ2V0IHBsYXlpbmdBc3NldCgpIHtcbiAgICAgICAgcmV0dXJuIGUuZWZmZWN0aXZlUGxheWluZ0Fzc2V0O1xuICAgICAgfSxcbiAgICAgIGdldCBwbGF5aW5nSXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIGUuZWZmZWN0aXZlUGxheWluZ0l0ZW07XG4gICAgICB9LFxuICAgICAgZ2V0IHBsYXlpbmdJbmRleCgpIHtcbiAgICAgICAgY29uc3QgZCA9IGUuZWZmZWN0aXZlUGxheWluZ0l0ZW07XG4gICAgICAgIHJldHVybiBlLmZpbmRJdGVtSW5kZXgoZCk7XG4gICAgICB9LFxuICAgICAgcHJpbWFyeToge1xuICAgICAgICBnZXQgYnVmZmVyZWRFbmQoKSB7XG4gICAgICAgICAgcmV0dXJuIG8oKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgICAgICAgIGNvbnN0IGQgPSBlLnRpbWVsaW5lUG9zO1xuICAgICAgICAgIHJldHVybiBkID4gMCA/IGQgOiAwO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgY3VycmVudFRpbWUoZCkge1xuICAgICAgICAgIGwoZCwgXCJwcmltYXJ5XCIpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgZHVyYXRpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGEoXCJwcmltYXJ5XCIpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgc2Vla2FibGVTdGFydCgpIHtcbiAgICAgICAgICB2YXIgZDtcbiAgICAgICAgICByZXR1cm4gKChkID0gZS5wcmltYXJ5RGV0YWlscykgPT0gbnVsbCA/IHZvaWQgMCA6IGQuZnJhZ21lbnRTdGFydCkgfHwgMDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGludGVncmF0ZWQ6IHtcbiAgICAgICAgZ2V0IGJ1ZmZlcmVkRW5kKCkge1xuICAgICAgICAgIHJldHVybiBuKHQoKSwgXCJpbnRlZ3JhdGVkXCIsIGUuYnVmZmVyaW5nQXNzZXQsIFwiYnVmZmVyZWRQb3NcIiwgXCJidWZmZXJlZEVuZFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgICAgICAgIHJldHVybiBuKGUuZWZmZWN0aXZlUGxheWluZ0l0ZW0sIFwiaW50ZWdyYXRlZFwiLCBlLmVmZmVjdGl2ZVBsYXlpbmdBc3NldCwgXCJ0aW1lbGluZVBvc1wiLCBcImN1cnJlbnRUaW1lXCIpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQgY3VycmVudFRpbWUoZCkge1xuICAgICAgICAgIGwoZCwgXCJpbnRlZ3JhdGVkXCIpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgZHVyYXRpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGEoXCJpbnRlZ3JhdGVkXCIpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgc2Vla2FibGVTdGFydCgpIHtcbiAgICAgICAgICB2YXIgZDtcbiAgICAgICAgICByZXR1cm4gaSgoKGQgPSBlLnByaW1hcnlEZXRhaWxzKSA9PSBudWxsID8gdm9pZCAwIDogZC5mcmFnbWVudFN0YXJ0KSB8fCAwLCBcImludGVncmF0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBza2lwOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGQgPSBlLmVmZmVjdGl2ZVBsYXlpbmdJdGVtLCBoID0gZCA9PSBudWxsID8gdm9pZCAwIDogZC5ldmVudDtcbiAgICAgICAgaWYgKGggJiYgIWgucmVzdHJpY3Rpb25zLnNraXApIHtcbiAgICAgICAgICBjb25zdCBmID0gZS5maW5kSXRlbUluZGV4KGQpO1xuICAgICAgICAgIGlmIChoLmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBkLnBsYXlvdXQuc3RhcnQgKyBkLmV2ZW50LmR1cmF0aW9uO1xuICAgICAgICAgICAgbChwICsgMWUtMywgXCJwbGF5b3V0XCIpO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgZS5hZHZhbmNlQWZ0ZXJBc3NldEVuZGVkKGgsIGYsIDEgLyAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLy8gU2NoZWR1bGUgZ2V0dGVyc1xuICBnZXQgZWZmZWN0aXZlUGxheWluZ0l0ZW0oKSB7XG4gICAgcmV0dXJuIHRoaXMud2FpdGluZ0l0ZW0gfHwgdGhpcy5wbGF5aW5nSXRlbSB8fCB0aGlzLmVuZGVkSXRlbTtcbiAgfVxuICBnZXQgZWZmZWN0aXZlUGxheWluZ0Fzc2V0KCkge1xuICAgIHJldHVybiB0aGlzLnBsYXlpbmdBc3NldCB8fCB0aGlzLmVuZGVkQXNzZXQ7XG4gIH1cbiAgZ2V0IHBsYXlpbmdMYXN0SXRlbSgpIHtcbiAgICB2YXIgZTtcbiAgICBjb25zdCB0ID0gdGhpcy5wbGF5aW5nSXRlbSwgciA9IChlID0gdGhpcy5zY2hlZHVsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IGUuaXRlbXM7XG4gICAgcmV0dXJuICF0aGlzLnBsYXliYWNrU3RhcnRlZCB8fCAhdCB8fCAhciA/ICExIDogdGhpcy5maW5kSXRlbUluZGV4KHQpID09PSByLmxlbmd0aCAtIDE7XG4gIH1cbiAgZ2V0IHBsYXliYWNrU3RhcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lZmZlY3RpdmVQbGF5aW5nSXRlbSAhPT0gbnVsbDtcbiAgfVxuICAvLyBNZWRpYSBnZXR0ZXJzIGFuZCBldmVudCBjYWxsYmFja3NcbiAgZ2V0IGN1cnJlbnRUaW1lKCkge1xuICAgIHZhciBlLCB0O1xuICAgIGlmICh0aGlzLm1lZGlhU2VsZWN0aW9uID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSB0aGlzLndhaXRpbmdJdGVtIHx8IHRoaXMucGxheWluZ0l0ZW07XG4gICAgaWYgKHRoaXMuaXNJbnRlcnN0aXRpYWwocikgJiYgIXIuZXZlbnQuYXBwZW5kSW5QbGFjZSlcbiAgICAgIHJldHVybjtcbiAgICBsZXQgbiA9IHRoaXMubWVkaWE7XG4gICAgIW4gJiYgKGUgPSB0aGlzLmJ1ZmZlcmluZ0l0ZW0pICE9IG51bGwgJiYgKGUgPSBlLmV2ZW50KSAhPSBudWxsICYmIGUuYXBwZW5kSW5QbGFjZSAmJiAobiA9IHRoaXMucHJpbWFyeU1lZGlhKTtcbiAgICBjb25zdCBpID0gKHQgPSBuKSA9PSBudWxsID8gdm9pZCAwIDogdC5jdXJyZW50VGltZTtcbiAgICBpZiAoIShpID09PSB2b2lkIDAgfHwgIXVlKGkpKSlcbiAgICAgIHJldHVybiBpO1xuICB9XG4gIGdldCBwcmltYXJ5TWVkaWEoKSB7XG4gICAgdmFyIGU7XG4gICAgcmV0dXJuIHRoaXMubWVkaWEgfHwgKChlID0gdGhpcy5kZXRhY2hlZERhdGEpID09IG51bGwgPyB2b2lkIDAgOiBlLm1lZGlhKSB8fCBudWxsO1xuICB9XG4gIGlzSW50ZXJzdGl0aWFsKGUpIHtcbiAgICByZXR1cm4gISEoZSAhPSBudWxsICYmIGUuZXZlbnQpO1xuICB9XG4gIHJldHJlaXZlTWVkaWFTb3VyY2UoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLmdldEFzc2V0UGxheWVyKGUpO1xuICAgIHIgJiYgdGhpcy50cmFuc2Zlck1lZGlhRnJvbVBsYXllcihyLCB0KTtcbiAgfVxuICB0cmFuc2Zlck1lZGlhRnJvbVBsYXllcihlLCB0KSB7XG4gICAgY29uc3QgciA9IGUuaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UsIG4gPSBlLm1lZGlhO1xuICAgIGlmIChyICYmIG4gPT09IHRoaXMucHJpbWFyeU1lZGlhKSB7XG4gICAgICBpZiAodGhpcy5idWZmZXJpbmdBc3NldCA9IG51bGwsICghdCB8fCB0aGlzLmlzSW50ZXJzdGl0aWFsKHQpICYmICF0LmV2ZW50LmFwcGVuZEluUGxhY2UpICYmIHQgJiYgbikge1xuICAgICAgICB0aGlzLmRldGFjaGVkRGF0YSA9IHtcbiAgICAgICAgICBtZWRpYTogblxuICAgICAgICB9O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpID0gZS50cmFuc2Zlck1lZGlhKCk7XG4gICAgICB0aGlzLmxvZyhgdHJhbnNmZXIgTWVkaWFTb3VyY2UgZnJvbSAke2V9ICR7YXQoaSl9YCksIHRoaXMuZGV0YWNoZWREYXRhID0gaTtcbiAgICB9IGVsc2UgdCAmJiBuICYmICh0aGlzLnNob3VsZFBsYXkgfHwgKHRoaXMuc2hvdWxkUGxheSA9ICFuLnBhdXNlZCkpO1xuICB9XG4gIHRyYW5zZmVyTWVkaWFUbyhlLCB0KSB7XG4gICAgdmFyIHIsIG47XG4gICAgaWYgKGUubWVkaWEgPT09IHQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGkgPSBudWxsO1xuICAgIGNvbnN0IG8gPSB0aGlzLmhscywgYSA9IGUgIT09IG8sIGwgPSBhICYmIGUuaW50ZXJzdGl0aWFsLmFwcGVuZEluUGxhY2UsIGMgPSAociA9IHRoaXMuZGV0YWNoZWREYXRhKSA9PSBudWxsID8gdm9pZCAwIDogci5tZWRpYVNvdXJjZTtcbiAgICBsZXQgdTtcbiAgICBpZiAoby5tZWRpYSlcbiAgICAgIGwgJiYgKGkgPSBvLnRyYW5zZmVyTWVkaWEoKSwgdGhpcy5kZXRhY2hlZERhdGEgPSBpKSwgdSA9IFwiUHJpbWFyeVwiO1xuICAgIGVsc2UgaWYgKGMpIHtcbiAgICAgIGNvbnN0IHAgPSB0aGlzLmdldEJ1ZmZlcmluZ1BsYXllcigpO1xuICAgICAgcCA/IChpID0gcC50cmFuc2Zlck1lZGlhKCksIHUgPSBgJHtwfWApIDogdSA9IFwiZGV0YWNoZWQgTWVkaWFTb3VyY2VcIjtcbiAgICB9IGVsc2VcbiAgICAgIHUgPSBcImRldGFjaGVkIG1lZGlhXCI7XG4gICAgaWYgKCFpKSB7XG4gICAgICBpZiAoYylcbiAgICAgICAgaSA9IHRoaXMuZGV0YWNoZWREYXRhLCB0aGlzLmxvZyhgdXNpbmcgZGV0YWNoZWREYXRhOiBNZWRpYVNvdXJjZSAke2F0KGkpfWApO1xuICAgICAgZWxzZSBpZiAoIXRoaXMuZGV0YWNoZWREYXRhIHx8IG8ubWVkaWEgPT09IHQpIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXMucGxheWVyUXVldWU7XG4gICAgICAgIHAubGVuZ3RoID4gMSAmJiBwLmZvckVhY2goKHkpID0+IHtcbiAgICAgICAgICBpZiAoYSAmJiB5LmludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlICE9PSBsKSB7XG4gICAgICAgICAgICBjb25zdCBFID0geS5pbnRlcnN0aXRpYWw7XG4gICAgICAgICAgICB0aGlzLmNsZWFySW50ZXJzdGl0aWFsKHkuaW50ZXJzdGl0aWFsLCBudWxsKSwgRS5hcHBlbmRJblBsYWNlID0gITEsIEUuYXBwZW5kSW5QbGFjZSAmJiB0aGlzLndhcm4oYENvdWxkIG5vdCBjaGFuZ2UgYXBwZW5kIHN0cmF0ZWd5IGZvciBxdWV1ZWQgYXNzZXRzICR7RX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCB0aGlzLmhscy5kZXRhY2hNZWRpYSgpLCB0aGlzLmRldGFjaGVkRGF0YSA9IHtcbiAgICAgICAgICBtZWRpYTogdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkID0gaSAmJiBcIm1lZGlhU291cmNlXCIgaW4gaSAmJiAoKG4gPSBpLm1lZGlhU291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogbi5yZWFkeVN0YXRlKSAhPT0gXCJjbG9zZWRcIiwgaCA9IGQgJiYgaSA/IGkgOiB0O1xuICAgIHRoaXMubG9nKGAke2QgPyBcInRyYW5zZmVyaW5nIE1lZGlhU291cmNlXCIgOiBcImF0dGFjaGluZyBtZWRpYVwifSB0byAke2EgPyBlIDogXCJQcmltYXJ5XCJ9IGZyb20gJHt1fSAobWVkaWEuY3VycmVudFRpbWU6ICR7dC5jdXJyZW50VGltZX0pYCk7XG4gICAgY29uc3QgZiA9IHRoaXMuc2NoZWR1bGU7XG4gICAgaWYgKGggPT09IGkgJiYgZikge1xuICAgICAgY29uc3QgcCA9IGEgJiYgZS5hc3NldElkID09PSBmLmFzc2V0SWRBdEVuZDtcbiAgICAgIGgub3ZlcnJpZGVzID0ge1xuICAgICAgICBkdXJhdGlvbjogZi5kdXJhdGlvbixcbiAgICAgICAgZW5kT2ZTdHJlYW06ICFhIHx8IHAsXG4gICAgICAgIGN1ZVJlbW92YWw6ICFhXG4gICAgICB9O1xuICAgIH1cbiAgICBlLmF0dGFjaE1lZGlhKGgpO1xuICB9XG4gIG9uSW50ZXJzdGl0aWFsQ3VlRW50ZXIoKSB7XG4gICAgdGhpcy5vblRpbWV1cGRhdGUoKTtcbiAgfVxuICAvLyBTY2hlZHVsaW5nIG1ldGhvZHNcbiAgY2hlY2tTdGFydCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5zY2hlZHVsZSwgdCA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuZXZlbnRzO1xuICAgIGlmICghdCB8fCB0aGlzLnBsYXliYWNrRGlzYWJsZWQgfHwgIXRoaXMubWVkaWEpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5idWZmZXJlZFBvcyA9PT0gLTEgJiYgKHRoaXMuYnVmZmVyZWRQb3MgPSAwKTtcbiAgICBjb25zdCByID0gdGhpcy50aW1lbGluZVBvcywgbiA9IHRoaXMuZWZmZWN0aXZlUGxheWluZ0l0ZW07XG4gICAgaWYgKHIgPT09IC0xKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5obHMuc3RhcnRQb3NpdGlvbjtcbiAgICAgIGlmICh0aGlzLmxvZyhRaShcImNoZWNrU3RhcnRcIiwgaSkpLCB0aGlzLnRpbWVsaW5lUG9zID0gaSwgdC5sZW5ndGggJiYgdFswXS5jdWUucHJlKSB7XG4gICAgICAgIGNvbnN0IG8gPSBlLmZpbmRFdmVudEluZGV4KHRbMF0uaWRlbnRpZmllcik7XG4gICAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbihvKTtcbiAgICAgIH0gZWxzZSBpZiAoaSA+PSAwIHx8ICF0aGlzLnByaW1hcnlMaXZlKSB7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLnRpbWVsaW5lUG9zID0gaSA+IDAgPyBpIDogMCwgYSA9IGUuZmluZEl0ZW1JbmRleEF0VGltZShvKTtcbiAgICAgICAgdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobiAmJiAhdGhpcy5wbGF5aW5nSXRlbSkge1xuICAgICAgY29uc3QgaSA9IGUuZmluZEl0ZW1JbmRleChuKTtcbiAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbihpKTtcbiAgICB9XG4gIH1cbiAgYWR2YW5jZUFzc2V0QnVmZmVyaW5nKGUsIHQpIHtcbiAgICBjb25zdCByID0gZS5ldmVudCwgbiA9IHIuZmluZEFzc2V0SW5kZXgodCksIGkgPSBUbChyLCBuKTtcbiAgICBpZiAoIXIuaXNBc3NldFBhc3RQbGF5b3V0TGltaXQoaSkpXG4gICAgICB0aGlzLmJ1ZmZlcmVkVG9FdmVudChlLCBpKTtcbiAgICBlbHNlIGlmICh0aGlzLnNjaGVkdWxlKSB7XG4gICAgICB2YXIgbztcbiAgICAgIGNvbnN0IGEgPSAobyA9IHRoaXMuc2NoZWR1bGUuaXRlbXMpID09IG51bGwgPyB2b2lkIDAgOiBvW3RoaXMuZmluZEl0ZW1JbmRleChlKSArIDFdO1xuICAgICAgYSAmJiB0aGlzLmJ1ZmZlcmVkVG9JdGVtKGEpO1xuICAgIH1cbiAgfVxuICBhZHZhbmNlQWZ0ZXJBc3NldEVuZGVkKGUsIHQsIHIpIHtcbiAgICBjb25zdCBuID0gVGwoZSwgcik7XG4gICAgaWYgKGUuaXNBc3NldFBhc3RQbGF5b3V0TGltaXQobikpIHtcbiAgICAgIGlmICh0aGlzLnNjaGVkdWxlKSB7XG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLnNjaGVkdWxlLml0ZW1zO1xuICAgICAgICBpZiAoaSkge1xuICAgICAgICAgIGNvbnN0IG8gPSB0ICsgMSwgYSA9IGkubGVuZ3RoO1xuICAgICAgICAgIGlmIChvID49IGEpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbigtMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGwgPSBlLnJlc3VtZVRpbWU7XG4gICAgICAgICAgdGhpcy50aW1lbGluZVBvcyA8IGwgJiYgKHRoaXMubG9nKFFpKFwiYWR2YW5jZUFmdGVyQXNzZXRFbmRlZFwiLCBsKSksIHRoaXMudGltZWxpbmVQb3MgPSBsLCBlLmFwcGVuZEluUGxhY2UgJiYgdGhpcy5hZHZhbmNlSW5QbGFjZShsKSwgdGhpcy5jaGVja0J1ZmZlcih0aGlzLmJ1ZmZlcmVkUG9zIDwgbCkpLCB0aGlzLnNldFNjaGVkdWxlUG9zaXRpb24obyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGUuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICBjb25zdCBpID0gZS5hc3NldExpc3Rbbl07XG4gICAgICAgIGkgJiYgdGhpcy5hZHZhbmNlSW5QbGFjZShpLnRpbWVsaW5lU3RhcnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKHQsIG4pO1xuICAgIH1cbiAgfVxuICBzZXRTY2hlZHVsZVRvQXNzZXRBdFRpbWUoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLnNjaGVkdWxlO1xuICAgIGlmICghcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuID0gdC5wYXJlbnRJZGVudGlmaWVyLCBpID0gci5nZXRFdmVudChuKTtcbiAgICBpZiAoaSkge1xuICAgICAgY29uc3QgbyA9IHIuZmluZEV2ZW50SW5kZXgobiksIGEgPSByLmZpbmRBc3NldEluZGV4KGksIGUpO1xuICAgICAgdGhpcy5hZHZhbmNlQWZ0ZXJBc3NldEVuZGVkKGksIG8sIGEgLSAxKTtcbiAgICB9XG4gIH1cbiAgc2V0U2NoZWR1bGVQb3NpdGlvbihlLCB0KSB7XG4gICAgdmFyIHI7XG4gICAgY29uc3QgbiA9IChyID0gdGhpcy5zY2hlZHVsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHIuaXRlbXM7XG4gICAgaWYgKCFuIHx8IHRoaXMucGxheWJhY2tEaXNhYmxlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gZSA+PSAwID8gbltlXSA6IG51bGw7XG4gICAgdGhpcy5sb2coYHNldFNjaGVkdWxlUG9zaXRpb24gJHtlfSwgJHt0fSAoJHtpICYmIGtyKGkpfSkgcG9zOiAke3RoaXMudGltZWxpbmVQb3N9YCk7XG4gICAgY29uc3QgbyA9IHRoaXMud2FpdGluZ0l0ZW0gfHwgdGhpcy5wbGF5aW5nSXRlbSwgYSA9IHRoaXMucGxheWluZ0xhc3RJdGVtO1xuICAgIGlmICh0aGlzLmlzSW50ZXJzdGl0aWFsKG8pKSB7XG4gICAgICBjb25zdCB1ID0gby5ldmVudCwgZCA9IHRoaXMucGxheWluZ0Fzc2V0LCBoID0gZCA9PSBudWxsID8gdm9pZCAwIDogZC5pZGVudGlmaWVyLCBmID0gaCA/IHRoaXMuZ2V0QXNzZXRQbGF5ZXIoaCkgOiBudWxsO1xuICAgICAgaWYgKGYgJiYgaCAmJiAoIXRoaXMuZXZlbnRJdGVtc01hdGNoKG8sIGkpIHx8IHQgIT09IHZvaWQgMCAmJiBoICE9PSB1LmFzc2V0TGlzdFt0XS5pZGVudGlmaWVyKSkge1xuICAgICAgICB2YXIgbDtcbiAgICAgICAgY29uc3QgcCA9IHUuZmluZEFzc2V0SW5kZXgoZCk7XG4gICAgICAgIGlmICh0aGlzLmxvZyhgSU5URVJTVElUSUFMX0FTU0VUX0VOREVEICR7cCArIDF9LyR7dS5hc3NldExpc3QubGVuZ3RofSAke3ZuKGQpfWApLCB0aGlzLmVuZGVkQXNzZXQgPSBkLCB0aGlzLnBsYXlpbmdBc3NldCA9IG51bGwsIHRoaXMuaGxzLnRyaWdnZXIoSS5JTlRFUlNUSVRJQUxfQVNTRVRfRU5ERUQsIHtcbiAgICAgICAgICBhc3NldDogZCxcbiAgICAgICAgICBhc3NldExpc3RJbmRleDogcCxcbiAgICAgICAgICBldmVudDogdSxcbiAgICAgICAgICBzY2hlZHVsZTogbi5zbGljZSgwKSxcbiAgICAgICAgICBzY2hlZHVsZUluZGV4OiBlLFxuICAgICAgICAgIHBsYXllcjogZlxuICAgICAgICB9KSwgbyAhPT0gdGhpcy5wbGF5aW5nSXRlbSkge1xuICAgICAgICAgIHRoaXMuaXRlbXNNYXRjaChvLCB0aGlzLnBsYXlpbmdJdGVtKSAmJiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICAgICF0aGlzLnBsYXlpbmdBc3NldCAmJiB0aGlzLmFkdmFuY2VBZnRlckFzc2V0RW5kZWQodSwgdGhpcy5maW5kSXRlbUluZGV4KHRoaXMucGxheWluZ0l0ZW0pLCBwKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXRyZWl2ZU1lZGlhU291cmNlKGgsIGkpLCBmLm1lZGlhICYmICEoKGwgPSB0aGlzLmRldGFjaGVkRGF0YSkgIT0gbnVsbCAmJiBsLm1lZGlhU291cmNlKSAmJiBmLmRldGFjaE1lZGlhKCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZXZlbnRJdGVtc01hdGNoKG8sIGkpICYmICh0aGlzLmVuZGVkSXRlbSA9IG8sIHRoaXMucGxheWluZ0l0ZW0gPSBudWxsLCB0aGlzLmxvZyhgSU5URVJTVElUSUFMX0VOREVEICR7dX0gJHtrcihvKX1gKSwgdS5oYXNQbGF5ZWQgPSAhMCwgdGhpcy5obHMudHJpZ2dlcihJLklOVEVSU1RJVElBTF9FTkRFRCwge1xuICAgICAgICBldmVudDogdSxcbiAgICAgICAgc2NoZWR1bGU6IG4uc2xpY2UoMCksXG4gICAgICAgIHNjaGVkdWxlSW5kZXg6IGVcbiAgICAgIH0pLCB1LmN1ZS5vbmNlKSkge1xuICAgICAgICB2YXIgYztcbiAgICAgICAgdGhpcy51cGRhdGVTY2hlZHVsZSgpO1xuICAgICAgICBjb25zdCBwID0gKGMgPSB0aGlzLnNjaGVkdWxlKSA9PSBudWxsID8gdm9pZCAwIDogYy5pdGVtcztcbiAgICAgICAgaWYgKGkgJiYgcCkge1xuICAgICAgICAgIGNvbnN0IHkgPSB0aGlzLmZpbmRJdGVtSW5kZXgoaSk7XG4gICAgICAgICAgdGhpcy5hZHZhbmNlU2NoZWR1bGUoeSwgcCwgdCwgbywgYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFkdmFuY2VTY2hlZHVsZShlLCBuLCB0LCBvLCBhKTtcbiAgfVxuICBhZHZhbmNlU2NoZWR1bGUoZSwgdCwgciwgbiwgaSkge1xuICAgIGNvbnN0IG8gPSB0aGlzLnNjaGVkdWxlO1xuICAgIGlmICghbylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhID0gdFtlXSB8fCBudWxsLCBsID0gdGhpcy5wcmltYXJ5TWVkaWEsIGMgPSB0aGlzLnBsYXllclF1ZXVlO1xuICAgIGlmIChjLmxlbmd0aCAmJiBjLmZvckVhY2goKHUpID0+IHtcbiAgICAgIGNvbnN0IGQgPSB1LmludGVyc3RpdGlhbCwgaCA9IG8uZmluZEV2ZW50SW5kZXgoZC5pZGVudGlmaWVyKTtcbiAgICAgIChoIDwgZSB8fCBoID4gZSArIDEpICYmIHRoaXMuY2xlYXJJbnRlcnN0aXRpYWwoZCwgYSk7XG4gICAgfSksIHRoaXMuaXNJbnRlcnN0aXRpYWwoYSkpIHtcbiAgICAgIHRoaXMudGltZWxpbmVQb3MgPSBNYXRoLm1pbihNYXRoLm1heCh0aGlzLnRpbWVsaW5lUG9zLCBhLnN0YXJ0KSwgYS5lbmQpO1xuICAgICAgY29uc3QgdSA9IGEuZXZlbnQ7XG4gICAgICBpZiAociA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHIgPSBvLmZpbmRBc3NldEluZGV4KHUsIHRoaXMudGltZWxpbmVQb3MpO1xuICAgICAgICBjb25zdCBwID0gVGwodSwgciAtIDEpO1xuICAgICAgICBpZiAodS5pc0Fzc2V0UGFzdFBsYXlvdXRMaW1pdChwKSB8fCB1LmFwcGVuZEluUGxhY2UgJiYgdGhpcy50aW1lbGluZVBvcyA9PT0gYS5lbmQpIHtcbiAgICAgICAgICB0aGlzLmFkdmFuY2VBZnRlckFzc2V0RW5kZWQodSwgZSwgcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHIgPSBwO1xuICAgICAgfVxuICAgICAgY29uc3QgZCA9IHRoaXMud2FpdGluZ0l0ZW07XG4gICAgICB0aGlzLmFzc2V0c0J1ZmZlcmVkKGEsIGwpIHx8IHRoaXMuc2V0QnVmZmVyaW5nSXRlbShhKTtcbiAgICAgIGxldCBoID0gdGhpcy5wcmVsb2FkQXNzZXRzKHUsIHIpO1xuICAgICAgaWYgKHRoaXMuZXZlbnRJdGVtc01hdGNoKGEsIGQgfHwgbikgfHwgKHRoaXMud2FpdGluZ0l0ZW0gPSBhLCB0aGlzLmxvZyhgSU5URVJTVElUSUFMX1NUQVJURUQgJHtrcihhKX0gJHt1LmFwcGVuZEluUGxhY2UgPyBcImFwcGVuZCBpbiBwbGFjZVwiIDogXCJcIn1gKSwgdGhpcy5obHMudHJpZ2dlcihJLklOVEVSU1RJVElBTF9TVEFSVEVELCB7XG4gICAgICAgIGV2ZW50OiB1LFxuICAgICAgICBzY2hlZHVsZTogdC5zbGljZSgwKSxcbiAgICAgICAgc2NoZWR1bGVJbmRleDogZVxuICAgICAgfSkpLCAhdS5hc3NldExpc3RMb2FkZWQpIHtcbiAgICAgICAgdGhpcy5sb2coYFdhaXRpbmcgZm9yIEFTU0VULUxJU1QgdG8gY29tcGxldGUgbG9hZGluZyAke3V9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh1LmFzc2V0TGlzdExvYWRlciAmJiAodS5hc3NldExpc3RMb2FkZXIuZGVzdHJveSgpLCB1LmFzc2V0TGlzdExvYWRlciA9IHZvaWQgMCksICFsKSB7XG4gICAgICAgIHRoaXMubG9nKGBXYWl0aW5nIGZvciBhdHRhY2hNZWRpYSB0byBzdGFydCBJbnRlcnN0aXRpYWwgJHt1fWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLndhaXRpbmdJdGVtID0gdGhpcy5lbmRlZEl0ZW0gPSBudWxsLCB0aGlzLnBsYXlpbmdJdGVtID0gYTtcbiAgICAgIGNvbnN0IGYgPSB1LmFzc2V0TGlzdFtyXTtcbiAgICAgIGlmICghZikge1xuICAgICAgICB0aGlzLmFkdmFuY2VBZnRlckFzc2V0RW5kZWQodSwgZSwgciB8fCAwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGggfHwgKGggPSB0aGlzLmdldEFzc2V0UGxheWVyKGYuaWRlbnRpZmllcikpLCBoID09PSBudWxsIHx8IGguZGVzdHJveWVkKSB7XG4gICAgICAgIGNvbnN0IHAgPSB1LmFzc2V0TGlzdC5sZW5ndGg7XG4gICAgICAgIHRoaXMud2FybihgYXNzZXQgJHtyICsgMX0vJHtwfSBwbGF5ZXIgZGVzdHJveWVkICR7dX1gKSwgaCA9IHRoaXMuY3JlYXRlQXNzZXRQbGF5ZXIodSwgZiwgciksIGgubG9hZFNvdXJjZSgpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmV2ZW50SXRlbXNNYXRjaChhLCB0aGlzLmJ1ZmZlcmluZ0l0ZW0pICYmIHUuYXBwZW5kSW5QbGFjZSAmJiB0aGlzLmlzQXNzZXRCdWZmZXJlZChmKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5zdGFydEFzc2V0UGxheWVyKGgsIHIsIHQsIGUsIGwpLCB0aGlzLnNob3VsZFBsYXkgJiYgSmgoaC5tZWRpYSk7XG4gICAgfSBlbHNlIGEgPyAodGhpcy5yZXN1bWVQcmltYXJ5KGEsIGUsIG4pLCB0aGlzLnNob3VsZFBsYXkgJiYgSmgodGhpcy5obHMubWVkaWEpKSA6IGkgJiYgdGhpcy5pc0ludGVyc3RpdGlhbChuKSAmJiAodGhpcy5lbmRlZEl0ZW0gPSBudWxsLCB0aGlzLnBsYXlpbmdJdGVtID0gbiwgbi5ldmVudC5hcHBlbmRJblBsYWNlIHx8IHRoaXMuYXR0YWNoUHJpbWFyeShvLmR1cmF0aW9ucy5wcmltYXJ5LCBudWxsKSk7XG4gIH1cbiAgZ2V0IHBsYXliYWNrRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGxzLmNvbmZpZy5lbmFibGVJbnRlcnN0aXRpYWxQbGF5YmFjayA9PT0gITE7XG4gIH1cbiAgZ2V0IHByaW1hcnlEZXRhaWxzKCkge1xuICAgIHZhciBlO1xuICAgIHJldHVybiAoZSA9IHRoaXMubWVkaWFTZWxlY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBlLm1haW4uZGV0YWlscztcbiAgfVxuICBnZXQgcHJpbWFyeUxpdmUoKSB7XG4gICAgdmFyIGU7XG4gICAgcmV0dXJuICEhKChlID0gdGhpcy5wcmltYXJ5RGV0YWlscykgIT0gbnVsbCAmJiBlLmxpdmUpO1xuICB9XG4gIHJlc3VtZVByaW1hcnkoZSwgdCwgcikge1xuICAgIHZhciBuLCBpO1xuICAgIGlmICh0aGlzLnBsYXlpbmdJdGVtID0gZSwgdGhpcy5wbGF5aW5nQXNzZXQgPSB0aGlzLmVuZGVkQXNzZXQgPSBudWxsLCB0aGlzLndhaXRpbmdJdGVtID0gdGhpcy5lbmRlZEl0ZW0gPSBudWxsLCB0aGlzLmJ1ZmZlcmVkVG9JdGVtKGUpLCB0aGlzLmxvZyhgcmVzdW1pbmcgJHtrcihlKX1gKSwgISgobiA9IHRoaXMuZGV0YWNoZWREYXRhKSAhPSBudWxsICYmIG4ubWVkaWFTb3VyY2UpKSB7XG4gICAgICBsZXQgYSA9IHRoaXMudGltZWxpbmVQb3M7XG4gICAgICAoYSA8IGUuc3RhcnQgfHwgYSA+PSBlLmVuZCkgJiYgKGEgPSB0aGlzLmdldFByaW1hcnlSZXN1bXB0aW9uKGUsIHQpLCB0aGlzLmxvZyhRaShcInJlc3VtZVByaW1hcnlcIiwgYSkpLCB0aGlzLnRpbWVsaW5lUG9zID0gYSksIHRoaXMuYXR0YWNoUHJpbWFyeShhLCBlKTtcbiAgICB9XG4gICAgaWYgKCFyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSAoaSA9IHRoaXMuc2NoZWR1bGUpID09IG51bGwgPyB2b2lkIDAgOiBpLml0ZW1zO1xuICAgIG8gJiYgKHRoaXMubG9nKGBJTlRFUlNUSVRJQUxTX1BSSU1BUllfUkVTVU1FRCAke2tyKGUpfWApLCB0aGlzLmhscy50cmlnZ2VyKEkuSU5URVJTVElUSUFMU19QUklNQVJZX1JFU1VNRUQsIHtcbiAgICAgIHNjaGVkdWxlOiBvLnNsaWNlKDApLFxuICAgICAgc2NoZWR1bGVJbmRleDogdFxuICAgIH0pLCB0aGlzLmNoZWNrQnVmZmVyKCkpO1xuICB9XG4gIGdldFByaW1hcnlSZXN1bXB0aW9uKGUsIHQpIHtcbiAgICBjb25zdCByID0gZS5zdGFydDtcbiAgICBpZiAodGhpcy5wcmltYXJ5TGl2ZSkge1xuICAgICAgY29uc3QgbiA9IHRoaXMucHJpbWFyeURldGFpbHM7XG4gICAgICBpZiAodCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHRoaXMuaGxzLnN0YXJ0UG9zaXRpb247XG4gICAgICBpZiAobiAmJiAociA8IG4uZnJhZ21lbnRTdGFydCB8fCByID4gbi5lZGdlKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuaGxzLmxpdmVTeW5jUG9zaXRpb24gfHwgLTE7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIGlzQXNzZXRCdWZmZXJlZChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXIoZS5pZGVudGlmaWVyKTtcbiAgICByZXR1cm4gdCAhPSBudWxsICYmIHQuaGxzID8gdC5obHMuYnVmZmVyZWRUb0VuZCA6IENlLmJ1ZmZlckluZm8odGhpcy5wcmltYXJ5TWVkaWEsIHRoaXMudGltZWxpbmVQb3MsIDApLmVuZCArIDEgPj0gZS50aW1lbGluZVN0YXJ0ICsgKGUuZHVyYXRpb24gfHwgMCk7XG4gIH1cbiAgYXR0YWNoUHJpbWFyeShlLCB0LCByKSB7XG4gICAgdCA/IHRoaXMuc2V0QnVmZmVyaW5nSXRlbSh0KSA6IHRoaXMuYnVmZmVyaW5nSXRlbSA9IHRoaXMucGxheWluZ0l0ZW0sIHRoaXMuYnVmZmVyaW5nQXNzZXQgPSBudWxsO1xuICAgIGNvbnN0IG4gPSB0aGlzLnByaW1hcnlNZWRpYTtcbiAgICBpZiAoIW4pXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IHRoaXMuaGxzO1xuICAgIGkubWVkaWEgPyB0aGlzLmNoZWNrQnVmZmVyKCkgOiAodGhpcy50cmFuc2Zlck1lZGlhVG8oaSwgbiksIHIgJiYgdGhpcy5zdGFydExvYWRpbmdQcmltYXJ5QXQoZSwgcikpLCByIHx8ICh0aGlzLmxvZyhRaShcImF0dGFjaFByaW1hcnlcIiwgZSkpLCB0aGlzLnRpbWVsaW5lUG9zID0gZSwgdGhpcy5zdGFydExvYWRpbmdQcmltYXJ5QXQoZSwgcikpO1xuICB9XG4gIHN0YXJ0TG9hZGluZ1ByaW1hcnlBdChlLCB0KSB7XG4gICAgdmFyIHI7XG4gICAgY29uc3QgbiA9IHRoaXMuaGxzO1xuICAgICFuLmxvYWRpbmdFbmFibGVkIHx8ICFuLm1lZGlhIHx8IE1hdGguYWJzKCgoKHIgPSBuLm1haW5Gb3J3YXJkQnVmZmVySW5mbykgPT0gbnVsbCA/IHZvaWQgMCA6IHIuc3RhcnQpIHx8IG4ubWVkaWEuY3VycmVudFRpbWUpIC0gZSkgPiAwLjUgPyBuLnN0YXJ0TG9hZChlLCB0KSA6IG4uYnVmZmVyaW5nRW5hYmxlZCB8fCBuLnJlc3VtZUJ1ZmZlcmluZygpO1xuICB9XG4gIC8vIEhMUy5qcyBldmVudCBjYWxsYmFja3NcbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgdmFyIGU7XG4gICAgdGhpcy5zdG9wTG9hZCgpLCAoZSA9IHRoaXMuc2NoZWR1bGUpID09IG51bGwgfHwgZS5yZXNldCgpLCB0aGlzLmVtcHR5UGxheWVyUXVldWUoKSwgdGhpcy5jbGVhclNjaGVkdWxlU3RhdGUoKSwgdGhpcy5zaG91bGRQbGF5ID0gITEsIHRoaXMuYnVmZmVyZWRQb3MgPSB0aGlzLnRpbWVsaW5lUG9zID0gLTEsIHRoaXMubWVkaWFTZWxlY3Rpb24gPSB0aGlzLmFsdFNlbGVjdGlvbiA9IHRoaXMubWFuYWdlciA9IHRoaXMucmVxdWlyZWRUcmFja3MgPSBudWxsLCB0aGlzLmhscy5vZmYoSS5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKSwgdGhpcy5obHMub24oSS5CVUZGRVJfQ09ERUNTLCB0aGlzLm9uQnVmZmVyQ29kZWNzLCB0aGlzKTtcbiAgfVxuICBvbkxldmVsVXBkYXRlZChlLCB0KSB7XG4gICAgaWYgKHQubGV2ZWwgPT09IC0xIHx8ICF0aGlzLnNjaGVkdWxlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSB0aGlzLmhscy5sZXZlbHNbdC5sZXZlbF07XG4gICAgaWYgKCFyLmRldGFpbHMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbiA9IHR0KHR0KHt9LCB0aGlzLm1lZGlhU2VsZWN0aW9uIHx8IHRoaXMuYWx0U2VsZWN0aW9uKSwge30sIHtcbiAgICAgIG1haW46IHJcbiAgICB9KTtcbiAgICB0aGlzLm1lZGlhU2VsZWN0aW9uID0gbiwgdGhpcy5zY2hlZHVsZS5wYXJzZUludGVyc3RpdGlhbERhdGVSYW5nZXMobiwgdGhpcy5obHMuY29uZmlnLmludGVyc3RpdGlhbEFwcGVuZEluUGxhY2UpLCAhdGhpcy5lZmZlY3RpdmVQbGF5aW5nSXRlbSAmJiB0aGlzLnNjaGVkdWxlLml0ZW1zICYmIHRoaXMuY2hlY2tTdGFydCgpO1xuICB9XG4gIG9uQXVkaW9UcmFja1VwZGF0ZWQoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLmhscy5hdWRpb1RyYWNrc1t0LmlkXSwgbiA9IHRoaXMubWVkaWFTZWxlY3Rpb247XG4gICAgaWYgKCFuKSB7XG4gICAgICB0aGlzLmFsdFNlbGVjdGlvbiA9IHR0KHR0KHt9LCB0aGlzLmFsdFNlbGVjdGlvbiksIHt9LCB7XG4gICAgICAgIGF1ZGlvOiByXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaSA9IHR0KHR0KHt9LCBuKSwge30sIHtcbiAgICAgIGF1ZGlvOiByXG4gICAgfSk7XG4gICAgdGhpcy5tZWRpYVNlbGVjdGlvbiA9IGk7XG4gIH1cbiAgb25TdWJ0aXRsZVRyYWNrVXBkYXRlZChlLCB0KSB7XG4gICAgY29uc3QgciA9IHRoaXMuaGxzLnN1YnRpdGxlVHJhY2tzW3QuaWRdLCBuID0gdGhpcy5tZWRpYVNlbGVjdGlvbjtcbiAgICBpZiAoIW4pIHtcbiAgICAgIHRoaXMuYWx0U2VsZWN0aW9uID0gdHQodHQoe30sIHRoaXMuYWx0U2VsZWN0aW9uKSwge30sIHtcbiAgICAgICAgc3VidGl0bGVzOiByXG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaSA9IHR0KHR0KHt9LCBuKSwge30sIHtcbiAgICAgIHN1YnRpdGxlczogclxuICAgIH0pO1xuICAgIHRoaXMubWVkaWFTZWxlY3Rpb24gPSBpO1xuICB9XG4gIG9uQXVkaW9UcmFja1N3aXRjaGluZyhlLCB0KSB7XG4gICAgY29uc3QgciA9IGNoKHQpO1xuICAgIHRoaXMucGxheWVyUXVldWUuZm9yRWFjaCgoe1xuICAgICAgaGxzOiBuXG4gICAgfSkgPT4gbiAmJiAobi5zZXRBdWRpb09wdGlvbih0KSB8fCBuLnNldEF1ZGlvT3B0aW9uKHIpKSk7XG4gIH1cbiAgb25TdWJ0aXRsZVRyYWNrU3dpdGNoKGUsIHQpIHtcbiAgICBjb25zdCByID0gY2godCk7XG4gICAgdGhpcy5wbGF5ZXJRdWV1ZS5mb3JFYWNoKCh7XG4gICAgICBobHM6IG5cbiAgICB9KSA9PiBuICYmIChuLnNldFN1YnRpdGxlT3B0aW9uKHQpIHx8IHQuaWQgIT09IC0xICYmIG4uc2V0U3VidGl0bGVPcHRpb24ocikpKTtcbiAgfVxuICBvbkJ1ZmZlckNvZGVjcyhlLCB0KSB7XG4gICAgY29uc3QgciA9IHQudHJhY2tzO1xuICAgIHIgJiYgKHRoaXMucmVxdWlyZWRUcmFja3MgPSByKTtcbiAgfVxuICBvbkJ1ZmZlckFwcGVuZGVkKGUsIHQpIHtcbiAgICB0aGlzLmNoZWNrQnVmZmVyKCk7XG4gIH1cbiAgb25CdWZmZXJGbHVzaGVkKGUsIHQpIHtcbiAgICBjb25zdCByID0gdGhpcy5wbGF5aW5nSXRlbTtcbiAgICBpZiAociAmJiAhdGhpcy5pdGVtc01hdGNoKHIsIHRoaXMuYnVmZmVyaW5nSXRlbSkgJiYgIXRoaXMuaXNJbnRlcnN0aXRpYWwocikpIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLnRpbWVsaW5lUG9zO1xuICAgICAgdGhpcy5idWZmZXJlZFBvcyA9IG4sIHRoaXMuY2hlY2tCdWZmZXIoKTtcbiAgICB9XG4gIH1cbiAgb25CdWZmZXJlZFRvRW5kKGUpIHtcbiAgICBpZiAoIXRoaXMuc2NoZWR1bGUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdCA9IHRoaXMuc2NoZWR1bGUuZXZlbnRzO1xuICAgIGlmICh0aGlzLmJ1ZmZlcmVkUG9zIDwgTnVtYmVyLk1BWF9WQUxVRSAmJiB0KSB7XG4gICAgICBmb3IgKGxldCBuID0gMDsgbiA8IHQubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgY29uc3QgaSA9IHRbbl07XG4gICAgICAgIGlmIChpLmN1ZS5wb3N0KSB7XG4gICAgICAgICAgdmFyIHI7XG4gICAgICAgICAgY29uc3QgbyA9IHRoaXMuc2NoZWR1bGUuZmluZEV2ZW50SW5kZXgoaS5pZGVudGlmaWVyKSwgYSA9IChyID0gdGhpcy5zY2hlZHVsZS5pdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IHJbb107XG4gICAgICAgICAgdGhpcy5pc0ludGVyc3RpdGlhbChhKSAmJiB0aGlzLmV2ZW50SXRlbXNNYXRjaChhLCB0aGlzLmJ1ZmZlcmluZ0l0ZW0pICYmIHRoaXMuYnVmZmVyZWRUb0l0ZW0oYSwgMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuYnVmZmVyZWRQb3MgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIH1cbiAgfVxuICBvbk1lZGlhRW5kZWQoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnBsYXlpbmdJdGVtO1xuICAgIGlmICghdGhpcy5wbGF5aW5nTGFzdEl0ZW0gJiYgdCkge1xuICAgICAgY29uc3QgciA9IHRoaXMuZmluZEl0ZW1JbmRleCh0KTtcbiAgICAgIHRoaXMuc2V0U2NoZWR1bGVQb3NpdGlvbihyICsgMSk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLnNob3VsZFBsYXkgPSAhMTtcbiAgfVxuICB1cGRhdGVJdGVtKGUsIHQpIHtcbiAgICB2YXIgcjtcbiAgICBjb25zdCBuID0gKHIgPSB0aGlzLnNjaGVkdWxlKSA9PSBudWxsID8gdm9pZCAwIDogci5pdGVtcztcbiAgICBpZiAoZSAmJiBuKSB7XG4gICAgICBjb25zdCBpID0gdGhpcy5maW5kSXRlbUluZGV4KGUsIHQpO1xuICAgICAgcmV0dXJuIG5baV0gfHwgbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJpbUluUGxhY2UoZSwgdCkge1xuICAgIGlmICh0aGlzLmlzSW50ZXJzdGl0aWFsKGUpICYmIGUuZXZlbnQuYXBwZW5kSW5QbGFjZSAmJiB0LmVuZCAtIGUuZW5kID4gMC4yNSkge1xuICAgICAgZS5ldmVudC5hc3NldExpc3QuZm9yRWFjaCgoaSwgbykgPT4ge1xuICAgICAgICBlLmV2ZW50LmlzQXNzZXRQYXN0UGxheW91dExpbWl0KG8pICYmIHRoaXMuY2xlYXJBc3NldFBsYXllcihpLmlkZW50aWZpZXIsIG51bGwpO1xuICAgICAgfSk7XG4gICAgICBjb25zdCByID0gZS5lbmQgKyAwLjI1LCBuID0gQ2UuYnVmZmVySW5mbyh0aGlzLnByaW1hcnlNZWRpYSwgciwgMCk7XG4gICAgICAobi5lbmQgPiByIHx8IChuLm5leHRTdGFydCB8fCAwKSA+IHIpICYmICh0aGlzLmxvZyhgdHJpbSBidWZmZXJlZCBpbnRlcnN0aXRpYWwgJHtrcihlKX0gKHdhcyAke2tyKHQpfSlgKSwgdGhpcy5hdHRhY2hQcmltYXJ5KHIsIG51bGwsICEwKSwgdGhpcy5mbHVzaEZyb250QnVmZmVyKHIpKTtcbiAgICB9XG4gIH1cbiAgaXRlbXNNYXRjaChlLCB0KSB7XG4gICAgcmV0dXJuICEhdCAmJiAoZSA9PT0gdCB8fCBlLmV2ZW50ICYmIHQuZXZlbnQgJiYgdGhpcy5ldmVudEl0ZW1zTWF0Y2goZSwgdCkgfHwgIWUuZXZlbnQgJiYgIXQuZXZlbnQgJiYgdGhpcy5maW5kSXRlbUluZGV4KGUpID09PSB0aGlzLmZpbmRJdGVtSW5kZXgodCkpO1xuICB9XG4gIGV2ZW50SXRlbXNNYXRjaChlLCB0KSB7XG4gICAgdmFyIHI7XG4gICAgcmV0dXJuICEhdCAmJiAoZSA9PT0gdCB8fCBlLmV2ZW50LmlkZW50aWZpZXIgPT09ICgociA9IHQuZXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiByLmlkZW50aWZpZXIpKTtcbiAgfVxuICBmaW5kSXRlbUluZGV4KGUsIHQpIHtcbiAgICByZXR1cm4gZSAmJiB0aGlzLnNjaGVkdWxlID8gdGhpcy5zY2hlZHVsZS5maW5kSXRlbUluZGV4KGUsIHQpIDogLTE7XG4gIH1cbiAgdXBkYXRlU2NoZWR1bGUoZSA9ICExKSB7XG4gICAgdmFyIHQ7XG4gICAgY29uc3QgciA9IHRoaXMubWVkaWFTZWxlY3Rpb247XG4gICAgciAmJiAoKHQgPSB0aGlzLnNjaGVkdWxlKSA9PSBudWxsIHx8IHQudXBkYXRlU2NoZWR1bGUociwgW10sIGUpKTtcbiAgfVxuICAvLyBTY2hlZHVsZSBidWZmZXIgY29udHJvbFxuICBjaGVja0J1ZmZlcihlKSB7XG4gICAgdmFyIHQ7XG4gICAgY29uc3QgciA9ICh0ID0gdGhpcy5zY2hlZHVsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IHQuaXRlbXM7XG4gICAgaWYgKCFyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG4gPSBDZS5idWZmZXJJbmZvKHRoaXMucHJpbWFyeU1lZGlhLCB0aGlzLnRpbWVsaW5lUG9zLCAwKTtcbiAgICBlICYmICh0aGlzLmJ1ZmZlcmVkUG9zID0gdGhpcy50aW1lbGluZVBvcyksIGUgfHwgKGUgPSBuLmxlbiA8IDEpLCB0aGlzLnVwZGF0ZUJ1ZmZlcmVkUG9zKG4uZW5kLCByLCBlKTtcbiAgfVxuICB1cGRhdGVCdWZmZXJlZFBvcyhlLCB0LCByKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuc2NoZWR1bGUsIGkgPSB0aGlzLmJ1ZmZlcmluZ0l0ZW07XG4gICAgaWYgKHRoaXMuYnVmZmVyZWRQb3MgPiBlIHx8ICFuKVxuICAgICAgcmV0dXJuO1xuICAgIGlmICh0Lmxlbmd0aCA9PT0gMSAmJiB0aGlzLml0ZW1zTWF0Y2godFswXSwgaSkpIHtcbiAgICAgIHRoaXMuYnVmZmVyZWRQb3MgPSBlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvID0gdGhpcy5wbGF5aW5nSXRlbSwgYSA9IHRoaXMuZmluZEl0ZW1JbmRleChvKTtcbiAgICBsZXQgbCA9IG4uZmluZEl0ZW1JbmRleEF0VGltZShlKTtcbiAgICBpZiAodGhpcy5idWZmZXJlZFBvcyA8IGUpIHtcbiAgICAgIHZhciBjO1xuICAgICAgY29uc3QgdSA9IHRoaXMuZmluZEl0ZW1JbmRleChpKSwgZCA9IE1hdGgubWluKHUgKyAxLCB0Lmxlbmd0aCAtIDEpLCBoID0gdFtkXTtcbiAgICAgIGlmICgobCA9PT0gLTEgJiYgaSAmJiBlID49IGkuZW5kIHx8IChjID0gaC5ldmVudCkgIT0gbnVsbCAmJiBjLmFwcGVuZEluUGxhY2UgJiYgZSArIDAuMDEgPj0gaC5zdGFydCkgJiYgKGwgPSBkKSwgdGhpcy5pc0ludGVyc3RpdGlhbChpKSkge1xuICAgICAgICBjb25zdCBmID0gaS5ldmVudDtcbiAgICAgICAgaWYgKGQgLSBhID4gMSAmJiBmLmFwcGVuZEluUGxhY2UgPT09ICExIHx8IGYuYXNzZXRMaXN0Lmxlbmd0aCA9PT0gMCAmJiBmLmFzc2V0TGlzdExvYWRlcilcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5idWZmZXJlZFBvcyA9IGUsIGwgPiB1ICYmIGwgPiBhKVxuICAgICAgICB0aGlzLmJ1ZmZlcmVkVG9JdGVtKGgpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGYgPSB0aGlzLnByaW1hcnlEZXRhaWxzO1xuICAgICAgICB0aGlzLnByaW1hcnlMaXZlICYmIGYgJiYgZSA+IGYuZWRnZSAtIGYudGFyZ2V0ZHVyYXRpb24gJiYgaC5zdGFydCA8IGYuZWRnZSArIHRoaXMuaGxzLmNvbmZpZy5pbnRlcnN0aXRpYWxMaXZlTG9va0FoZWFkICYmIHRoaXMuaXNJbnRlcnN0aXRpYWwoaCkgJiYgdGhpcy5wcmVsb2FkQXNzZXRzKGguZXZlbnQsIDApO1xuICAgICAgfVxuICAgIH0gZWxzZSByICYmIG8gJiYgIXRoaXMuaXRlbXNNYXRjaChvLCBpKSAmJiAobCA9PT0gYSA/IHRoaXMuYnVmZmVyZWRUb0l0ZW0obykgOiBsID09PSBhICsgMSAmJiB0aGlzLmJ1ZmZlcmVkVG9JdGVtKHRbbF0pKTtcbiAgfVxuICBhc3NldHNCdWZmZXJlZChlLCB0KSB7XG4gICAgcmV0dXJuIGUuZXZlbnQuYXNzZXRMaXN0Lmxlbmd0aCA9PT0gMCA/ICExIDogIWUuZXZlbnQuYXNzZXRMaXN0LnNvbWUoKG4pID0+IHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzLmdldEFzc2V0UGxheWVyKG4uaWRlbnRpZmllcik7XG4gICAgICByZXR1cm4gIShpICE9IG51bGwgJiYgaS5idWZmZXJlZEluUGxhY2VUb0VuZCh0KSk7XG4gICAgfSk7XG4gIH1cbiAgc2V0QnVmZmVyaW5nSXRlbShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuYnVmZmVyaW5nSXRlbSwgciA9IHRoaXMuc2NoZWR1bGU7XG4gICAgaWYgKCF0aGlzLml0ZW1zTWF0Y2goZSwgdCkgJiYgcikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBpdGVtczogbixcbiAgICAgICAgZXZlbnRzOiBpXG4gICAgICB9ID0gcjtcbiAgICAgIGlmICghbiB8fCAhaSlcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICBjb25zdCBvID0gdGhpcy5pc0ludGVyc3RpdGlhbChlKSwgYSA9IHRoaXMuZ2V0QnVmZmVyaW5nUGxheWVyKCk7XG4gICAgICB0aGlzLmJ1ZmZlcmluZ0l0ZW0gPSBlLCB0aGlzLmJ1ZmZlcmVkUG9zID0gTWF0aC5tYXgoZS5zdGFydCwgTWF0aC5taW4oZS5lbmQsIHRoaXMudGltZWxpbmVQb3MpKTtcbiAgICAgIGNvbnN0IGwgPSBhID8gYS5yZW1haW5pbmcgOiB0ID8gdC5lbmQgLSB0aGlzLnRpbWVsaW5lUG9zIDogMDtcbiAgICAgIGlmICh0aGlzLmxvZyhgSU5URVJTVElUSUFMU19CVUZGRVJFRF9UT19CT1VOREFSWSAke2tyKGUpfWAgKyAodCA/IGAgKCR7bC50b0ZpeGVkKDIpfSByZW1haW5pbmcpYCA6IFwiXCIpKSwgIXRoaXMucGxheWJhY2tEaXNhYmxlZClcbiAgICAgICAgaWYgKG8pIHtcbiAgICAgICAgICBjb25zdCBjID0gci5maW5kQXNzZXRJbmRleChlLmV2ZW50LCB0aGlzLmJ1ZmZlcmVkUG9zKTtcbiAgICAgICAgICBlLmV2ZW50LmFzc2V0TGlzdC5mb3JFYWNoKCh1LCBkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBoID0gdGhpcy5nZXRBc3NldFBsYXllcih1LmlkZW50aWZpZXIpO1xuICAgICAgICAgICAgaCAmJiAoZCA9PT0gYyAmJiBoLmxvYWRTb3VyY2UoKSwgaC5yZXN1bWVCdWZmZXJpbmcoKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHRoaXMuaGxzLnJlc3VtZUJ1ZmZlcmluZygpLCB0aGlzLnBsYXllclF1ZXVlLmZvckVhY2goKGMpID0+IGMucGF1c2VCdWZmZXJpbmcoKSk7XG4gICAgICB0aGlzLmhscy50cmlnZ2VyKEkuSU5URVJTVElUSUFMU19CVUZGRVJFRF9UT19CT1VOREFSWSwge1xuICAgICAgICBldmVudHM6IGkuc2xpY2UoMCksXG4gICAgICAgIHNjaGVkdWxlOiBuLnNsaWNlKDApLFxuICAgICAgICBidWZmZXJpbmdJbmRleDogdGhpcy5maW5kSXRlbUluZGV4KGUpLFxuICAgICAgICBwbGF5aW5nSW5kZXg6IHRoaXMuZmluZEl0ZW1JbmRleCh0aGlzLnBsYXlpbmdJdGVtKVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHRoaXMuYnVmZmVyaW5nSXRlbSAhPT0gZSAmJiAodGhpcy5idWZmZXJpbmdJdGVtID0gZSk7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgYnVmZmVyZWRUb0l0ZW0oZSwgdCA9IDApIHtcbiAgICBjb25zdCByID0gdGhpcy5zZXRCdWZmZXJpbmdJdGVtKGUpO1xuICAgIGlmICghdGhpcy5wbGF5YmFja0Rpc2FibGVkKSB7XG4gICAgICBpZiAodGhpcy5pc0ludGVyc3RpdGlhbChlKSlcbiAgICAgICAgdGhpcy5idWZmZXJlZFRvRXZlbnQoZSwgdCk7XG4gICAgICBlbHNlIGlmIChyICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuYnVmZmVyaW5nQXNzZXQgPSBudWxsO1xuICAgICAgICBjb25zdCBuID0gdGhpcy5kZXRhY2hlZERhdGE7XG4gICAgICAgIG4gPyBuLm1lZGlhU291cmNlID8gdGhpcy5hdHRhY2hQcmltYXJ5KGUuc3RhcnQsIGUsICEwKSA6IHRoaXMucHJlbG9hZFByaW1hcnkoZSkgOiB0aGlzLnByZWxvYWRQcmltYXJ5KGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwcmVsb2FkUHJpbWFyeShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZmluZEl0ZW1JbmRleChlKSwgciA9IHRoaXMuZ2V0UHJpbWFyeVJlc3VtcHRpb24oZSwgdCk7XG4gICAgdGhpcy5zdGFydExvYWRpbmdQcmltYXJ5QXQocik7XG4gIH1cbiAgYnVmZmVyZWRUb0V2ZW50KGUsIHQpIHtcbiAgICBjb25zdCByID0gZS5ldmVudCwgbiA9IHIuYXNzZXRMaXN0Lmxlbmd0aCA9PT0gMCAmJiAhci5hc3NldExpc3RMb2FkZXIsIGkgPSByLmN1ZS5vbmNlO1xuICAgIGlmIChuIHx8ICFpKSB7XG4gICAgICBjb25zdCBvID0gdGhpcy5wcmVsb2FkQXNzZXRzKHIsIHQpO1xuICAgICAgaWYgKG8gIT0gbnVsbCAmJiBvLmludGVyc3RpdGlhbC5hcHBlbmRJblBsYWNlKSB7XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLnByaW1hcnlNZWRpYTtcbiAgICAgICAgYSAmJiB0aGlzLmJ1ZmZlckFzc2V0UGxheWVyKG8sIGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBwcmVsb2FkQXNzZXRzKGUsIHQpIHtcbiAgICBjb25zdCByID0gZS5hc3NldFVybCwgbiA9IGUuYXNzZXRMaXN0Lmxlbmd0aCwgaSA9IG4gPT09IDAgJiYgIWUuYXNzZXRMaXN0TG9hZGVyLCBvID0gZS5jdWUub25jZTtcbiAgICBpZiAoaSkge1xuICAgICAgY29uc3QgbCA9IGUudGltZWxpbmVTdGFydDtcbiAgICAgIGlmIChlLmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgdmFyIGE7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLnBsYXlpbmdJdGVtO1xuICAgICAgICAhdGhpcy5pc0ludGVyc3RpdGlhbChoKSAmJiAoaCA9PSBudWxsIHx8IChhID0gaC5uZXh0RXZlbnQpID09IG51bGwgPyB2b2lkIDAgOiBhLmlkZW50aWZpZXIpID09PSBlLmlkZW50aWZpZXIgJiYgdGhpcy5mbHVzaEZyb250QnVmZmVyKGwgKyAwLjI1KTtcbiAgICAgIH1cbiAgICAgIGxldCBjLCB1ID0gMDtcbiAgICAgIGlmICghdGhpcy5wbGF5aW5nSXRlbSAmJiB0aGlzLnByaW1hcnlMaXZlICYmICh1ID0gdGhpcy5obHMuc3RhcnRQb3NpdGlvbiwgdSA9PT0gLTEgJiYgKHUgPSB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uIHx8IDApKSwgdSAmJiAhKGUuY3VlLnByZSB8fCBlLmN1ZS5wb3N0KSkge1xuICAgICAgICBjb25zdCBoID0gdSAtIGw7XG4gICAgICAgIGggPiAwICYmIChjID0gTWF0aC5yb3VuZChoICogMWUzKSAvIDFlMyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5sb2coYExvYWQgaW50ZXJzdGl0aWFsIGFzc2V0ICR7dCArIDF9LyR7ciA/IDEgOiBufSAke2V9JHtjID8gYCBsaXZlLXN0YXJ0OiAke3V9IHN0YXJ0LW9mZnNldDogJHtjfWAgOiBcIlwifWApLCByKVxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVBc3NldChlLCAwLCAwLCBsLCBlLmR1cmF0aW9uLCByKTtcbiAgICAgIGNvbnN0IGQgPSB0aGlzLmFzc2V0TGlzdExvYWRlci5sb2FkQXNzZXRMaXN0KGUsIGMpO1xuICAgICAgZCAmJiAoZS5hc3NldExpc3RMb2FkZXIgPSBkKTtcbiAgICB9IGVsc2UgaWYgKCFvICYmIG4pIHtcbiAgICAgIGZvciAobGV0IGMgPSB0OyBjIDwgbjsgYysrKSB7XG4gICAgICAgIGNvbnN0IHUgPSBlLmFzc2V0TGlzdFtjXSwgZCA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXJRdWV1ZUluZGV4KHUuaWRlbnRpZmllcik7XG4gICAgICAgIChkID09PSAtMSB8fCB0aGlzLnBsYXllclF1ZXVlW2RdLmRlc3Ryb3llZCkgJiYgIXUuZXJyb3IgJiYgdGhpcy5jcmVhdGVBc3NldFBsYXllcihlLCB1LCBjKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGwgPSBlLmFzc2V0TGlzdFt0XTtcbiAgICAgIGlmIChsKSB7XG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmdldEFzc2V0UGxheWVyKGwuaWRlbnRpZmllcik7XG4gICAgICAgIHJldHVybiBjICYmIGMubG9hZFNvdXJjZSgpLCBjO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBmbHVzaEZyb250QnVmZmVyKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5yZXF1aXJlZFRyYWNrcztcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5sb2coYFJlbW92aW5nIGZyb250IGJ1ZmZlciBzdGFydGluZyBhdCAke2V9YCksIE9iamVjdC5rZXlzKHQpLmZvckVhY2goKG4pID0+IHtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoSS5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgc3RhcnRPZmZzZXQ6IGUsXG4gICAgICAgIGVuZE9mZnNldDogMSAvIDAsXG4gICAgICAgIHR5cGU6IG5cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8vIEludGVyc3RpdGlhbCBBc3NldCBQbGF5ZXIgY29udHJvbFxuICBnZXRBc3NldFBsYXllclF1ZXVlSW5kZXgoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnBsYXllclF1ZXVlO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgdC5sZW5ndGg7IHIrKylcbiAgICAgIGlmIChlID09PSB0W3JdLmFzc2V0SWQpXG4gICAgICAgIHJldHVybiByO1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBnZXRBc3NldFBsYXllcihlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXJRdWV1ZUluZGV4KGUpO1xuICAgIHJldHVybiB0aGlzLnBsYXllclF1ZXVlW3RdIHx8IG51bGw7XG4gIH1cbiAgZ2V0QnVmZmVyaW5nUGxheWVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBsYXllclF1ZXVlOiBlLFxuICAgICAgcHJpbWFyeU1lZGlhOiB0XG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHQpIHtcbiAgICAgIGZvciAobGV0IHIgPSAwOyByIDwgZS5sZW5ndGg7IHIrKylcbiAgICAgICAgaWYgKGVbcl0ubWVkaWEgPT09IHQpXG4gICAgICAgICAgcmV0dXJuIGVbcl07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNyZWF0ZUFzc2V0KGUsIHQsIHIsIG4sIGksIG8pIHtcbiAgICBjb25zdCBhID0ge1xuICAgICAgcGFyZW50SWRlbnRpZmllcjogZS5pZGVudGlmaWVyLFxuICAgICAgaWRlbnRpZmllcjogZ3coZSwgbywgdCksXG4gICAgICBkdXJhdGlvbjogaSxcbiAgICAgIHN0YXJ0T2Zmc2V0OiByLFxuICAgICAgdGltZWxpbmVTdGFydDogbixcbiAgICAgIHVyaTogb1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlQXNzZXRQbGF5ZXIoZSwgYSwgdCk7XG4gIH1cbiAgY3JlYXRlQXNzZXRQbGF5ZXIoZSwgdCwgcikge1xuICAgIGNvbnN0IG4gPSB0aGlzLmhscywgaSA9IG4udXNlckNvbmZpZztcbiAgICBsZXQgbyA9IGkudmlkZW9QcmVmZXJlbmNlO1xuICAgIGNvbnN0IGEgPSBuLmxvYWRMZXZlbE9iaiB8fCBuLmxldmVsc1tuLmN1cnJlbnRMZXZlbF07XG4gICAgKG8gfHwgYSkgJiYgKG8gPSBudCh7fSwgbyksIGEudmlkZW9Db2RlYyAmJiAoby52aWRlb0NvZGVjID0gYS52aWRlb0NvZGVjKSwgYS52aWRlb1JhbmdlICYmIChvLmFsbG93ZWRWaWRlb1JhbmdlcyA9IFthLnZpZGVvUmFuZ2VdKSk7XG4gICAgY29uc3QgbCA9IG4uYXVkaW9UcmFja3Nbbi5hdWRpb1RyYWNrXSwgYyA9IG4uc3VidGl0bGVUcmFja3Nbbi5zdWJ0aXRsZVRyYWNrXTtcbiAgICBsZXQgdSA9IDA7XG4gICAgaWYgKHRoaXMucHJpbWFyeUxpdmUgfHwgZS5hcHBlbmRJblBsYWNlKSB7XG4gICAgICBjb25zdCBGID0gdGhpcy50aW1lbGluZVBvcyAtIHQudGltZWxpbmVTdGFydDtcbiAgICAgIGlmIChGID4gMSkge1xuICAgICAgICBjb25zdCBNID0gdC5kdXJhdGlvbjtcbiAgICAgICAgTSAmJiBGIDwgTSAmJiAodSA9IEYpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkID0gdC5pZGVudGlmaWVyLCBoID0gdHQodHQoe30sIGkpLCB7fSwge1xuICAgICAgbWF4TWF4QnVmZmVyTGVuZ3RoOiBNYXRoLm1pbigxODAsIG4uY29uZmlnLm1heE1heEJ1ZmZlckxlbmd0aCksXG4gICAgICBhdXRvU3RhcnRMb2FkOiAhMCxcbiAgICAgIHN0YXJ0RnJhZ1ByZWZldGNoOiAhMCxcbiAgICAgIHByaW1hcnlTZXNzaW9uSWQ6IG4uc2Vzc2lvbklkLFxuICAgICAgYXNzZXRQbGF5ZXJJZDogZCxcbiAgICAgIGFickV3bWFEZWZhdWx0RXN0aW1hdGU6IG4uYmFuZHdpZHRoRXN0aW1hdGUsXG4gICAgICBpbnRlcnN0aXRpYWxzQ29udHJvbGxlcjogdm9pZCAwLFxuICAgICAgc3RhcnRQb3NpdGlvbjogdSxcbiAgICAgIGxpdmVEdXJhdGlvbkluZmluaXR5OiAhMSxcbiAgICAgIHRlc3RCYW5kd2lkdGg6ICExLFxuICAgICAgdmlkZW9QcmVmZXJlbmNlOiBvLFxuICAgICAgYXVkaW9QcmVmZXJlbmNlOiBsIHx8IGkuYXVkaW9QcmVmZXJlbmNlLFxuICAgICAgc3VidGl0bGVQcmVmZXJlbmNlOiBjIHx8IGkuc3VidGl0bGVQcmVmZXJlbmNlXG4gICAgfSk7XG4gICAgZS5hcHBlbmRJblBsYWNlICYmIChlLmFwcGVuZEluUGxhY2VTdGFydGVkID0gITAsIHQudGltZWxpbmVTdGFydCAmJiAoaC50aW1lbGluZU9mZnNldCA9IHQudGltZWxpbmVTdGFydCkpO1xuICAgIGNvbnN0IGYgPSBoLmNtY2Q7XG4gICAgZiAhPSBudWxsICYmIGYuc2Vzc2lvbklkICYmIGYuY29udGVudElkICYmIChoLmNtY2QgPSBudCh7fSwgZiwge1xuICAgICAgY29udGVudElkOiBYbih0LnVyaSlcbiAgICB9KSksIHRoaXMuZ2V0QXNzZXRQbGF5ZXIoZCkgJiYgdGhpcy53YXJuKGBEdXBsaWNhdGUgZGF0ZSByYW5nZSBpZGVudGlmaWVyICR7ZX0gYW5kIGFzc2V0ICR7ZH1gKTtcbiAgICBjb25zdCBwID0gbmV3IHl3KHRoaXMuSGxzUGxheWVyQ2xhc3MsIGgsIGUsIHQpO1xuICAgIHRoaXMucGxheWVyUXVldWUucHVzaChwKSwgZS5hc3NldExpc3Rbcl0gPSB0O1xuICAgIGxldCB5ID0gITA7XG4gICAgY29uc3QgRSA9IChGKSA9PiB7XG4gICAgICBpZiAoRi5saXZlKSB7XG4gICAgICAgIHZhciBNO1xuICAgICAgICBjb25zdCBqID0gbmV3IEVycm9yKGBJbnRlcnN0aXRpYWxzIE1VU1QgYmUgVk9EIGFzc2V0cyAke2V9YCksIEMgPSB7XG4gICAgICAgICAgZmF0YWw6ICEwLFxuICAgICAgICAgIHR5cGU6IHZlLk9USEVSX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEouSU5URVJTVElUSUFMX0FTU0VUX0lURU1fRVJST1IsXG4gICAgICAgICAgZXJyb3I6IGpcbiAgICAgICAgfSwgayA9ICgoTSA9IHRoaXMuc2NoZWR1bGUpID09IG51bGwgPyB2b2lkIDAgOiBNLmZpbmRFdmVudEluZGV4KGUuaWRlbnRpZmllcikpIHx8IC0xO1xuICAgICAgICB0aGlzLmhhbmRsZUFzc2V0SXRlbUVycm9yKEMsIGUsIGssIHIsIGoubWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IEggPSBGLmVkZ2UgLSBGLmZyYWdtZW50U3RhcnQsIEsgPSB0LmR1cmF0aW9uO1xuICAgICAgKHkgfHwgSyA9PT0gbnVsbCB8fCBIID4gSykgJiYgKHkgPSAhMSwgdGhpcy5sb2coYEludGVyc3RpdGlhbCBhc3NldCBcIiR7ZH1cIiBkdXJhdGlvbiBjaGFuZ2UgJHtLfSA+ICR7SH1gKSwgdC5kdXJhdGlvbiA9IEgsIHRoaXMudXBkYXRlU2NoZWR1bGUoKSk7XG4gICAgfTtcbiAgICBwLm9uKEkuTEVWRUxfVVBEQVRFRCwgKEYsIHtcbiAgICAgIGRldGFpbHM6IE1cbiAgICB9KSA9PiBFKE0pKSwgcC5vbihJLkxFVkVMX1BUU19VUERBVEVELCAoRiwge1xuICAgICAgZGV0YWlsczogTVxuICAgIH0pID0+IEUoTSkpLCBwLm9uKEkuRVZFTlRfQ1VFX0VOVEVSLCAoKSA9PiB0aGlzLm9uSW50ZXJzdGl0aWFsQ3VlRW50ZXIoKSk7XG4gICAgY29uc3QgYiA9IChGLCBNKSA9PiB7XG4gICAgICBjb25zdCBIID0gdGhpcy5nZXRBc3NldFBsYXllcihkKTtcbiAgICAgIGlmIChIICYmIE0udHJhY2tzKSB7XG4gICAgICAgIEgub2ZmKEkuQlVGRkVSX0NPREVDUywgYiksIEgudHJhY2tzID0gTS50cmFja3M7XG4gICAgICAgIGNvbnN0IEsgPSB0aGlzLnByaW1hcnlNZWRpYTtcbiAgICAgICAgdGhpcy5idWZmZXJpbmdBc3NldCA9PT0gSC5hc3NldEl0ZW0gJiYgSyAmJiAhSC5tZWRpYSAmJiB0aGlzLmJ1ZmZlckFzc2V0UGxheWVyKEgsIEspO1xuICAgICAgfVxuICAgIH07XG4gICAgcC5vbihJLkJVRkZFUl9DT0RFQ1MsIGIpO1xuICAgIGNvbnN0IFIgPSAoKSA9PiB7XG4gICAgICB2YXIgRjtcbiAgICAgIGNvbnN0IE0gPSB0aGlzLmdldEFzc2V0UGxheWVyKGQpO1xuICAgICAgaWYgKHRoaXMubG9nKGBidWZmZXJlZCB0byBlbmQgb2YgYXNzZXQgJHtNfWApLCAhTSB8fCAhdGhpcy5zY2hlZHVsZSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY29uc3QgSCA9IHRoaXMuc2NoZWR1bGUuZmluZEV2ZW50SW5kZXgoZS5pZGVudGlmaWVyKSwgSyA9IChGID0gdGhpcy5zY2hlZHVsZS5pdGVtcykgPT0gbnVsbCA/IHZvaWQgMCA6IEZbSF07XG4gICAgICB0aGlzLmlzSW50ZXJzdGl0aWFsKEspICYmIHRoaXMuYWR2YW5jZUFzc2V0QnVmZmVyaW5nKEssIHQpO1xuICAgIH07XG4gICAgcC5vbihJLkJVRkZFUkVEX1RPX0VORCwgUik7XG4gICAgY29uc3QgQSA9IChGKSA9PiAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZ2V0QXNzZXRQbGF5ZXIoZCkgfHwgIXRoaXMuc2NoZWR1bGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuc2hvdWxkUGxheSA9ICEwO1xuICAgICAgY29uc3QgSCA9IHRoaXMuc2NoZWR1bGUuZmluZEV2ZW50SW5kZXgoZS5pZGVudGlmaWVyKTtcbiAgICAgIHRoaXMuYWR2YW5jZUFmdGVyQXNzZXRFbmRlZChlLCBILCBGKTtcbiAgICB9O1xuICAgIHJldHVybiBwLm9uY2UoSS5NRURJQV9FTkRFRCwgQShyKSksIHAub25jZShJLlBMQVlPVVRfTElNSVRfUkVBQ0hFRCwgQSgxIC8gMCkpLCBwLm9uKEkuRVJST1IsIChGLCBNKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuc2NoZWR1bGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IEggPSB0aGlzLmdldEFzc2V0UGxheWVyKGQpO1xuICAgICAgaWYgKE0uZGV0YWlscyA9PT0gSi5CVUZGRVJfU1RBTExFRF9FUlJPUikge1xuICAgICAgICBpZiAoSCAhPSBudWxsICYmIEguYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlSW5QbGFjZVN0YWxsKGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uVGltZXVwZGF0ZSgpLCB0aGlzLmNoZWNrQnVmZmVyKCEwKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5oYW5kbGVBc3NldEl0ZW1FcnJvcihNLCBlLCB0aGlzLnNjaGVkdWxlLmZpbmRFdmVudEluZGV4KGUuaWRlbnRpZmllciksIHIsIGBBc3NldCBwbGF5ZXIgZXJyb3IgJHtNLmVycm9yfSAke2V9YCk7XG4gICAgfSksIHAub24oSS5ERVNUUk9ZSU5HLCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuZ2V0QXNzZXRQbGF5ZXIoZCkgfHwgIXRoaXMuc2NoZWR1bGUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IE0gPSBuZXcgRXJyb3IoYEFzc2V0IHBsYXllciBkZXN0cm95ZWQgdW5leHBlY3RlZGx5ICR7ZH1gKSwgSCA9IHtcbiAgICAgICAgZmF0YWw6ICEwLFxuICAgICAgICB0eXBlOiB2ZS5PVEhFUl9FUlJPUixcbiAgICAgICAgZGV0YWlsczogSi5JTlRFUlNUSVRJQUxfQVNTRVRfSVRFTV9FUlJPUixcbiAgICAgICAgZXJyb3I6IE1cbiAgICAgIH07XG4gICAgICB0aGlzLmhhbmRsZUFzc2V0SXRlbUVycm9yKEgsIGUsIHRoaXMuc2NoZWR1bGUuZmluZEV2ZW50SW5kZXgoZS5pZGVudGlmaWVyKSwgciwgTS5tZXNzYWdlKTtcbiAgICB9KSwgdGhpcy5sb2coYElOVEVSU1RJVElBTF9BU1NFVF9QTEFZRVJfQ1JFQVRFRCAke3ZuKHQpfWApLCB0aGlzLmhscy50cmlnZ2VyKEkuSU5URVJTVElUSUFMX0FTU0VUX1BMQVlFUl9DUkVBVEVELCB7XG4gICAgICBhc3NldDogdCxcbiAgICAgIGFzc2V0TGlzdEluZGV4OiByLFxuICAgICAgZXZlbnQ6IGUsXG4gICAgICBwbGF5ZXI6IHBcbiAgICB9KSwgcDtcbiAgfVxuICBjbGVhckludGVyc3RpdGlhbChlLCB0KSB7XG4gICAgZS5hc3NldExpc3QuZm9yRWFjaCgocikgPT4ge1xuICAgICAgdGhpcy5jbGVhckFzc2V0UGxheWVyKHIuaWRlbnRpZmllciwgdCk7XG4gICAgfSksIGUucmVzZXQoKTtcbiAgfVxuICByZXNldEFzc2V0UGxheWVyKGUpIHtcbiAgICBjb25zdCB0ID0gdGhpcy5nZXRBc3NldFBsYXllclF1ZXVlSW5kZXgoZSk7XG4gICAgaWYgKHQgIT09IC0xKSB7XG4gICAgICB0aGlzLmxvZyhgcmVzZXQgYXNzZXQgcGxheWVyIFwiJHtlfVwiIGFmdGVyIGVycm9yYCk7XG4gICAgICBjb25zdCByID0gdGhpcy5wbGF5ZXJRdWV1ZVt0XTtcbiAgICAgIHRoaXMudHJhbnNmZXJNZWRpYUZyb21QbGF5ZXIociwgbnVsbCksIHIucmVzZXREZXRhaWxzKCk7XG4gICAgfVxuICB9XG4gIGNsZWFyQXNzZXRQbGF5ZXIoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLmdldEFzc2V0UGxheWVyUXVldWVJbmRleChlKTtcbiAgICBpZiAociAhPT0gLTEpIHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLnBsYXllclF1ZXVlW3JdO1xuICAgICAgdGhpcy5sb2coYGNsZWFyICR7bn0gdG9TZWdtZW50OiAke3QgJiYga3IodCl9YCksIHRoaXMudHJhbnNmZXJNZWRpYUZyb21QbGF5ZXIobiwgdCksIHRoaXMucGxheWVyUXVldWUuc3BsaWNlKHIsIDEpLCBuLmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbiAgZW1wdHlQbGF5ZXJRdWV1ZSgpIHtcbiAgICBsZXQgZTtcbiAgICBmb3IgKDsgZSA9IHRoaXMucGxheWVyUXVldWUucG9wKCk7IClcbiAgICAgIGUuZGVzdHJveSgpO1xuICAgIHRoaXMucGxheWVyUXVldWUgPSBbXTtcbiAgfVxuICBzdGFydEFzc2V0UGxheWVyKGUsIHQsIHIsIG4sIGkpIHtcbiAgICBjb25zdCB7XG4gICAgICBpbnRlcnN0aXRpYWw6IG8sXG4gICAgICBhc3NldEl0ZW06IGEsXG4gICAgICBhc3NldElkOiBsXG4gICAgfSA9IGUsIGMgPSBvLmFzc2V0TGlzdC5sZW5ndGgsIHUgPSB0aGlzLnBsYXlpbmdBc3NldDtcbiAgICB0aGlzLmVuZGVkQXNzZXQgPSBudWxsLCB0aGlzLnBsYXlpbmdBc3NldCA9IGEsICghdSB8fCB1LmlkZW50aWZpZXIgIT09IGwpICYmICh1ICYmICh0aGlzLmNsZWFyQXNzZXRQbGF5ZXIodS5pZGVudGlmaWVyLCByW25dKSwgZGVsZXRlIHUuZXJyb3IpLCB0aGlzLmxvZyhgSU5URVJTVElUSUFMX0FTU0VUX1NUQVJURUQgJHt0ICsgMX0vJHtjfSAke3ZuKGEpfWApLCB0aGlzLmhscy50cmlnZ2VyKEkuSU5URVJTVElUSUFMX0FTU0VUX1NUQVJURUQsIHtcbiAgICAgIGFzc2V0OiBhLFxuICAgICAgYXNzZXRMaXN0SW5kZXg6IHQsXG4gICAgICBldmVudDogbyxcbiAgICAgIHNjaGVkdWxlOiByLnNsaWNlKDApLFxuICAgICAgc2NoZWR1bGVJbmRleDogbixcbiAgICAgIHBsYXllcjogZVxuICAgIH0pKSwgdGhpcy5idWZmZXJBc3NldFBsYXllcihlLCBpKTtcbiAgfVxuICBidWZmZXJBc3NldFBsYXllcihlLCB0KSB7XG4gICAgdmFyIHIsIG47XG4gICAgaWYgKCF0aGlzLnNjaGVkdWxlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVyc3RpdGlhbDogaSxcbiAgICAgIGFzc2V0SXRlbTogb1xuICAgIH0gPSBlLCBhID0gdGhpcy5zY2hlZHVsZS5maW5kRXZlbnRJbmRleChpLmlkZW50aWZpZXIpLCBsID0gKHIgPSB0aGlzLnNjaGVkdWxlLml0ZW1zKSA9PSBudWxsID8gdm9pZCAwIDogclthXTtcbiAgICBpZiAoIWwpXG4gICAgICByZXR1cm47XG4gICAgZS5sb2FkU291cmNlKCksIHRoaXMuc2V0QnVmZmVyaW5nSXRlbShsKSwgdGhpcy5idWZmZXJpbmdBc3NldCA9IG87XG4gICAgY29uc3QgYyA9IHRoaXMuZ2V0QnVmZmVyaW5nUGxheWVyKCk7XG4gICAgaWYgKGMgPT09IGUpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgdSA9IGkuYXBwZW5kSW5QbGFjZTtcbiAgICBpZiAodSAmJiAoYyA9PSBudWxsID8gdm9pZCAwIDogYy5pbnRlcnN0aXRpYWwuYXBwZW5kSW5QbGFjZSkgPT09ICExKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGQgPSAoYyA9PSBudWxsID8gdm9pZCAwIDogYy50cmFja3MpIHx8ICgobiA9IHRoaXMuZGV0YWNoZWREYXRhKSA9PSBudWxsID8gdm9pZCAwIDogbi50cmFja3MpIHx8IHRoaXMucmVxdWlyZWRUcmFja3M7XG4gICAgaWYgKHUgJiYgbyAhPT0gdGhpcy5wbGF5aW5nQXNzZXQpIHtcbiAgICAgIGlmICghZS50cmFja3MpIHtcbiAgICAgICAgdGhpcy5sb2coYFdhaXRpbmcgZm9yIHRyYWNrIGluZm8gYmVmb3JlIGJ1ZmZlcmluZyAke2V9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkICYmICFBZyhkLCBlLnRyYWNrcykpIHtcbiAgICAgICAgY29uc3QgaCA9IG5ldyBFcnJvcihgQXNzZXQgJHt2bihvKX0gU291cmNlQnVmZmVyIHRyYWNrcyAoJyR7T2JqZWN0LmtleXMoZS50cmFja3MpfScpIGFyZSBub3QgY29tcGF0aWJsZSB3aXRoIHByaW1hcnkgY29udGVudCB0cmFja3MgKCcke09iamVjdC5rZXlzKGQpfScpYCksIGYgPSB7XG4gICAgICAgICAgZmF0YWw6ICEwLFxuICAgICAgICAgIHR5cGU6IHZlLk9USEVSX0VSUk9SLFxuICAgICAgICAgIGRldGFpbHM6IEouSU5URVJTVElUSUFMX0FTU0VUX0lURU1fRVJST1IsXG4gICAgICAgICAgZXJyb3I6IGhcbiAgICAgICAgfSwgcCA9IGkuZmluZEFzc2V0SW5kZXgobyk7XG4gICAgICAgIHRoaXMuaGFuZGxlQXNzZXRJdGVtRXJyb3IoZiwgaSwgYSwgcCwgaC5tZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRyYW5zZmVyTWVkaWFUbyhlLCB0KTtcbiAgfVxuICBoYW5kbGVJblBsYWNlU3RhbGwoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnNjaGVkdWxlLCByID0gdGhpcy5wcmltYXJ5TWVkaWE7XG4gICAgaWYgKCF0IHx8ICFyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG4gPSByLmN1cnJlbnRUaW1lLCBpID0gdC5maW5kQXNzZXRJbmRleChlLCBuKSwgbyA9IGUuYXNzZXRMaXN0W2ldO1xuICAgIGlmIChvKSB7XG4gICAgICBjb25zdCBhID0gdGhpcy5nZXRBc3NldFBsYXllcihvLmlkZW50aWZpZXIpO1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgY29uc3QgbCA9IGEuY3VycmVudFRpbWUgfHwgbiAtIG8udGltZWxpbmVTdGFydCwgYyA9IGEuZHVyYXRpb24gLSBsO1xuICAgICAgICBpZiAodGhpcy53YXJuKGBTdGFsbGVkIGF0ICR7bH0gb2YgJHtsICsgY30gaW4gJHthfSAke2V9IChtZWRpYS5jdXJyZW50VGltZTogJHtufSlgKSwgbCAmJiAoYyAvIHIucGxheWJhY2tSYXRlIDwgMC41IHx8IGEuYnVmZmVyZWRJblBsYWNlVG9FbmQocikpICYmIGEuaGxzKSB7XG4gICAgICAgICAgY29uc3QgdSA9IHQuZmluZEV2ZW50SW5kZXgoZS5pZGVudGlmaWVyKTtcbiAgICAgICAgICB0aGlzLmFkdmFuY2VBZnRlckFzc2V0RW5kZWQoZSwgdSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWR2YW5jZUluUGxhY2UoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnByaW1hcnlNZWRpYTtcbiAgICB0ICYmIHQuY3VycmVudFRpbWUgPCBlICYmICh0LmN1cnJlbnRUaW1lID0gZSk7XG4gIH1cbiAgaGFuZGxlQXNzZXRJdGVtRXJyb3IoZSwgdCwgciwgbiwgaSkge1xuICAgIGlmIChlLmRldGFpbHMgPT09IEouQlVGRkVSX1NUQUxMRURfRVJST1IpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgbyA9IHQuYXNzZXRMaXN0W25dIHx8IG51bGw7XG4gICAgaWYgKHRoaXMud2FybihgSU5URVJTVElUSUFMX0FTU0VUX0VSUk9SICR7byAmJiB2bihvKX0gJHtlLmVycm9yfWApLCAhdGhpcy5zY2hlZHVsZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBhID0gKG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8uaWRlbnRpZmllcikgfHwgXCJcIiwgbCA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXJRdWV1ZUluZGV4KGEpLCBjID0gdGhpcy5wbGF5ZXJRdWV1ZVtsXSB8fCBudWxsLCB1ID0gdGhpcy5zY2hlZHVsZS5pdGVtcywgZCA9IG50KHt9LCBlLCB7XG4gICAgICBmYXRhbDogITEsXG4gICAgICBlcnJvckFjdGlvbjogQW4oITApLFxuICAgICAgYXNzZXQ6IG8sXG4gICAgICBhc3NldExpc3RJbmRleDogbixcbiAgICAgIGV2ZW50OiB0LFxuICAgICAgc2NoZWR1bGU6IHUsXG4gICAgICBzY2hlZHVsZUluZGV4OiByLFxuICAgICAgcGxheWVyOiBjXG4gICAgfSk7XG4gICAgaWYgKHRoaXMuaGxzLnRyaWdnZXIoSS5JTlRFUlNUSVRJQUxfQVNTRVRfRVJST1IsIGQpLCAhZS5mYXRhbClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBoID0gdGhpcy5wbGF5aW5nQXNzZXQsIGYgPSB0aGlzLmJ1ZmZlcmluZ0Fzc2V0LCBwID0gbmV3IEVycm9yKGkpO1xuICAgIGlmIChvICYmICh0aGlzLmNsZWFyQXNzZXRQbGF5ZXIoYSwgbnVsbCksIG8uZXJyb3IgPSBwKSwgIXQuYXNzZXRMaXN0LnNvbWUoKHkpID0+ICF5LmVycm9yKSlcbiAgICAgIHQuZXJyb3IgPSBwO1xuICAgIGVsc2VcbiAgICAgIGZvciAobGV0IHkgPSBuOyB5IDwgdC5hc3NldExpc3QubGVuZ3RoOyB5KyspXG4gICAgICAgIHRoaXMucmVzZXRBc3NldFBsYXllcih0LmFzc2V0TGlzdFt5XS5pZGVudGlmaWVyKTtcbiAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlKCEwKSwgdC5lcnJvciA/IHRoaXMucHJpbWFyeUZhbGxiYWNrKHQpIDogaCAmJiBoLmlkZW50aWZpZXIgPT09IGEgPyB0aGlzLmFkdmFuY2VBZnRlckFzc2V0RW5kZWQodCwgciwgbikgOiBmICYmIGYuaWRlbnRpZmllciA9PT0gYSAmJiB0aGlzLmlzSW50ZXJzdGl0aWFsKHRoaXMuYnVmZmVyaW5nSXRlbSkgJiYgdGhpcy5hZHZhbmNlQXNzZXRCdWZmZXJpbmcodGhpcy5idWZmZXJpbmdJdGVtLCBmKTtcbiAgfVxuICBwcmltYXJ5RmFsbGJhY2soZSkge1xuICAgIGNvbnN0IHQgPSBlLnRpbWVsaW5lU3RhcnQsIHIgPSB0aGlzLmVmZmVjdGl2ZVBsYXlpbmdJdGVtO1xuICAgIGlmIChyKSB7XG4gICAgICB0aGlzLmxvZyhgRmFsbGJhY2sgdG8gcHJpbWFyeSBmcm9tIGV2ZW50IFwiJHtlLmlkZW50aWZpZXJ9XCIgc3RhcnQ6ICR7dH0gcG9zOiAke3RoaXMudGltZWxpbmVQb3N9IHBsYXlpbmc6ICR7a3Iocil9IGVycm9yOiAke2UuZXJyb3J9YCk7XG4gICAgICBsZXQgbiA9IHRoaXMudGltZWxpbmVQb3M7XG4gICAgICBuID09PSAtMSAmJiAobiA9IHRoaXMuaGxzLnN0YXJ0UG9zaXRpb24pO1xuICAgICAgY29uc3QgaSA9IHRoaXMudXBkYXRlSXRlbShyLCBuKTtcbiAgICAgIGlmICh0aGlzLml0ZW1zTWF0Y2gociwgaSkgJiYgdGhpcy5jbGVhckludGVyc3RpdGlhbChlLCBudWxsKSwgZS5hcHBlbmRJblBsYWNlICYmICh0aGlzLmF0dGFjaFByaW1hcnkodCwgbnVsbCksIHRoaXMuZmx1c2hGcm9udEJ1ZmZlcih0KSksICF0aGlzLnNjaGVkdWxlKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBvID0gdGhpcy5zY2hlZHVsZS5maW5kSXRlbUluZGV4QXRUaW1lKG4pO1xuICAgICAgdGhpcy5zZXRTY2hlZHVsZVBvc2l0aW9uKG8pO1xuICAgIH0gZWxzZVxuICAgICAgdGhpcy5jaGVja1N0YXJ0KCk7XG4gIH1cbiAgLy8gQXNzZXQgTGlzdCBsb2FkaW5nXG4gIG9uQXNzZXRMaXN0TG9hZGVkKGUsIHQpIHtcbiAgICB2YXIgciwgbjtcbiAgICBjb25zdCBpID0gdC5ldmVudCwgbyA9IGkuaWRlbnRpZmllciwgYSA9IHQuYXNzZXRMaXN0UmVzcG9uc2UuQVNTRVRTO1xuICAgIGlmICghKChyID0gdGhpcy5zY2hlZHVsZSkgIT0gbnVsbCAmJiByLmhhc0V2ZW50KG8pKSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBsID0gaS50aW1lbGluZVN0YXJ0LCBjID0gaS5kdXJhdGlvbjtcbiAgICBsZXQgdSA9IDA7XG4gICAgYS5mb3JFYWNoKCh5LCBFKSA9PiB7XG4gICAgICBjb25zdCBiID0gcGFyc2VGbG9hdCh5LkRVUkFUSU9OKTtcbiAgICAgIHRoaXMuY3JlYXRlQXNzZXQoaSwgRSwgdSwgbCArIHUsIGIsIHkuVVJJKSwgdSArPSBiO1xuICAgIH0pLCBpLmR1cmF0aW9uID0gdSwgdGhpcy5sb2coYExvYWRlZCBhc3NldC1saXN0IHdpdGggZHVyYXRpb246ICR7dX0gKHdhczogJHtjfSkgJHtpfWApO1xuICAgIGNvbnN0IGQgPSB0aGlzLndhaXRpbmdJdGVtLCBoID0gKGQgPT0gbnVsbCA/IHZvaWQgMCA6IGQuZXZlbnQuaWRlbnRpZmllcikgPT09IG87XG4gICAgdGhpcy51cGRhdGVTY2hlZHVsZSgpO1xuICAgIGNvbnN0IGYgPSAobiA9IHRoaXMuYnVmZmVyaW5nSXRlbSkgPT0gbnVsbCA/IHZvaWQgMCA6IG4uZXZlbnQ7XG4gICAgaWYgKGgpIHtcbiAgICAgIHZhciBwO1xuICAgICAgY29uc3QgeSA9IHRoaXMuc2NoZWR1bGUuZmluZEV2ZW50SW5kZXgobyksIEUgPSAocCA9IHRoaXMuc2NoZWR1bGUuaXRlbXMpID09IG51bGwgPyB2b2lkIDAgOiBwW3ldO1xuICAgICAgaWYgKEUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnBsYXlpbmdJdGVtICYmIHRoaXMudGltZWxpbmVQb3MgPiBFLmVuZCAmJiB0aGlzLnNjaGVkdWxlLmZpbmRJdGVtSW5kZXhBdFRpbWUodGhpcy50aW1lbGluZVBvcykgIT09IHkpIHtcbiAgICAgICAgICBpLmVycm9yID0gbmV3IEVycm9yKGBJbnRlcnN0aXRpYWwgbm8gbG9uZ2VyIHdpdGhpbiBwbGF5YmFjayByYW5nZSAke3RoaXMudGltZWxpbmVQb3N9ICR7aX1gKSwgdGhpcy51cGRhdGVTY2hlZHVsZSghMCksIHRoaXMucHJpbWFyeUZhbGxiYWNrKGkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEJ1ZmZlcmluZ0l0ZW0oRSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFNjaGVkdWxlUG9zaXRpb24oeSk7XG4gICAgfSBlbHNlIGlmICgoZiA9PSBudWxsID8gdm9pZCAwIDogZi5pZGVudGlmaWVyKSA9PT0gbykge1xuICAgICAgY29uc3QgeSA9IGkuYXNzZXRMaXN0WzBdO1xuICAgICAgaWYgKHkpIHtcbiAgICAgICAgY29uc3QgRSA9IHRoaXMuZ2V0QXNzZXRQbGF5ZXIoeS5pZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKGYuYXBwZW5kSW5QbGFjZSkge1xuICAgICAgICAgIGNvbnN0IGIgPSB0aGlzLnByaW1hcnlNZWRpYTtcbiAgICAgICAgICBFICYmIGIgJiYgdGhpcy5idWZmZXJBc3NldFBsYXllcihFLCBiKTtcbiAgICAgICAgfSBlbHNlIEUgJiYgRS5sb2FkU291cmNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG9uRXJyb3IoZSwgdCkge1xuICAgIGlmICh0aGlzLnNjaGVkdWxlKVxuICAgICAgc3dpdGNoICh0LmRldGFpbHMpIHtcbiAgICAgICAgY2FzZSBKLkFTU0VUX0xJU1RfUEFSU0lOR19FUlJPUjpcbiAgICAgICAgY2FzZSBKLkFTU0VUX0xJU1RfTE9BRF9FUlJPUjpcbiAgICAgICAgY2FzZSBKLkFTU0VUX0xJU1RfTE9BRF9USU1FT1VUOiB7XG4gICAgICAgICAgY29uc3QgciA9IHQuaW50ZXJzdGl0aWFsO1xuICAgICAgICAgIHIgJiYgKHRoaXMudXBkYXRlU2NoZWR1bGUoITApLCB0aGlzLnByaW1hcnlGYWxsYmFjayhyKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBKLkJVRkZFUl9TVEFMTEVEX0VSUk9SOiB7XG4gICAgICAgICAgY29uc3QgciA9IHRoaXMuZW5kZWRJdGVtIHx8IHRoaXMud2FpdGluZ0l0ZW0gfHwgdGhpcy5wbGF5aW5nSXRlbTtcbiAgICAgICAgICBpZiAodGhpcy5pc0ludGVyc3RpdGlhbChyKSAmJiByLmV2ZW50LmFwcGVuZEluUGxhY2UpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSW5QbGFjZVN0YWxsKHIuZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxvZyhgUHJpbWFyeSBwbGF5ZXIgc3RhbGwgQCR7dGhpcy50aW1lbGluZVBvc30gYnVmZmVyZWRQb3M6ICR7dGhpcy5idWZmZXJlZFBvc31gKSwgdGhpcy5vblRpbWV1cGRhdGUoKSwgdGhpcy5jaGVja0J1ZmZlcighMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxufVxuY29uc3QgUWggPSA1MDA7XG5jbGFzcyBTdyBleHRlbmRzIFR1IHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcikge1xuICAgIHN1cGVyKGUsIHQsIHIsIFwic3VidGl0bGUtc3RyZWFtLWNvbnRyb2xsZXJcIiwgcGUuU1VCVElUTEUpLCB0aGlzLmN1cnJlbnRUcmFja0lkID0gLTEsIHRoaXMudHJhY2tzQnVmZmVyZWQgPSBbXSwgdGhpcy5tYWluRGV0YWlscyA9IG51bGwsIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpLCBzdXBlci5vbkhhbmRsZXJEZXN0cm95aW5nKCksIHRoaXMubWFpbkRldGFpbHMgPSBudWxsO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIHN1cGVyLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgY29uc3Qge1xuICAgICAgaGxzOiBlXG4gICAgfSA9IHRoaXM7XG4gICAgZS5vbihJLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKSwgZS5vbihJLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkLCB0aGlzKSwgZS5vbihJLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwgdGhpcy5vblN1YnRpdGxlVHJhY2tTd2l0Y2gsIHRoaXMpLCBlLm9uKEkuU1VCVElUTEVfVFJBQ0tfTE9BREVELCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRlZCwgdGhpcyksIGUub24oSS5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwgdGhpcy5vblN1YnRpdGxlRnJhZ1Byb2Nlc3NlZCwgdGhpcyksIGUub24oSS5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gIH1cbiAgdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBzdXBlci51bnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gICAgY29uc3Qge1xuICAgICAgaGxzOiBlXG4gICAgfSA9IHRoaXM7XG4gICAgZS5vZmYoSS5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyksIGUub2ZmKEkuU1VCVElUTEVfVFJBQ0tTX1VQREFURUQsIHRoaXMub25TdWJ0aXRsZVRyYWNrc1VwZGF0ZWQsIHRoaXMpLCBlLm9mZihJLlNVQlRJVExFX1RSQUNLX1NXSVRDSCwgdGhpcy5vblN1YnRpdGxlVHJhY2tTd2l0Y2gsIHRoaXMpLCBlLm9mZihJLlNVQlRJVExFX1RSQUNLX0xPQURFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tMb2FkZWQsIHRoaXMpLCBlLm9mZihJLlNVQlRJVExFX0ZSQUdfUFJPQ0VTU0VELCB0aGlzLm9uU3VidGl0bGVGcmFnUHJvY2Vzc2VkLCB0aGlzKSwgZS5vZmYoSS5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gIH1cbiAgc3RhcnRMb2FkKGUsIHQpIHtcbiAgICB0aGlzLnN0b3BMb2FkKCksIHRoaXMuc3RhdGUgPSBuZS5JRExFLCB0aGlzLnNldEludGVydmFsKFFoKSwgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBlICsgdGhpcy50aW1lbGluZU9mZnNldCwgdGhpcy5zdGFydFBvc2l0aW9uID0gdCA/IC0xIDogZSwgdGhpcy50aWNrKCk7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoKSB7XG4gICAgc3VwZXIub25NYW5pZmVzdExvYWRpbmcoKSwgdGhpcy5tYWluRGV0YWlscyA9IG51bGw7XG4gIH1cbiAgb25NZWRpYURldGFjaGluZyhlLCB0KSB7XG4gICAgdGhpcy50cmFja3NCdWZmZXJlZCA9IFtdLCBzdXBlci5vbk1lZGlhRGV0YWNoaW5nKGUsIHQpO1xuICB9XG4gIG9uTGV2ZWxMb2FkZWQoZSwgdCkge1xuICAgIHRoaXMubWFpbkRldGFpbHMgPSB0LmRldGFpbHM7XG4gIH1cbiAgb25TdWJ0aXRsZUZyYWdQcm9jZXNzZWQoZSwgdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWc6IHIsXG4gICAgICBzdWNjZXNzOiBuXG4gICAgfSA9IHQ7XG4gICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKHIpIHx8IChWdChyKSAmJiAodGhpcy5mcmFnUHJldmlvdXMgPSByKSwgdGhpcy5zdGF0ZSA9IG5lLklETEUpLCAhbilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBpID0gdGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXTtcbiAgICBpZiAoIWkpXG4gICAgICByZXR1cm47XG4gICAgbGV0IG87XG4gICAgY29uc3QgYSA9IHIuc3RhcnQ7XG4gICAgZm9yIChsZXQgYyA9IDA7IGMgPCBpLmxlbmd0aDsgYysrKVxuICAgICAgaWYgKGEgPj0gaVtjXS5zdGFydCAmJiBhIDw9IGlbY10uZW5kKSB7XG4gICAgICAgIG8gPSBpW2NdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjb25zdCBsID0gci5zdGFydCArIHIuZHVyYXRpb247XG4gICAgbyA/IG8uZW5kID0gbCA6IChvID0ge1xuICAgICAgc3RhcnQ6IGEsXG4gICAgICBlbmQ6IGxcbiAgICB9LCBpLnB1c2gobykpLCB0aGlzLmZyYWdtZW50VHJhY2tlci5mcmFnQnVmZmVyZWQociksIHRoaXMuZnJhZ0J1ZmZlcmVkQ29tcGxldGUociwgbnVsbCksIHRoaXMubWVkaWEgJiYgdGhpcy50aWNrKCk7XG4gIH1cbiAgb25CdWZmZXJGbHVzaGluZyhlLCB0KSB7XG4gICAgY29uc3Qge1xuICAgICAgc3RhcnRPZmZzZXQ6IHIsXG4gICAgICBlbmRPZmZzZXQ6IG5cbiAgICB9ID0gdDtcbiAgICBpZiAociA9PT0gMCAmJiBuICE9PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgIGNvbnN0IGkgPSBuIC0gMTtcbiAgICAgIGlmIChpIDw9IDApXG4gICAgICAgIHJldHVybjtcbiAgICAgIHQuZW5kT2Zmc2V0U3VidGl0bGVzID0gTWF0aC5tYXgoMCwgaSksIHRoaXMudHJhY2tzQnVmZmVyZWQuZm9yRWFjaCgobykgPT4ge1xuICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IG8ubGVuZ3RoOyApIHtcbiAgICAgICAgICBpZiAob1thXS5lbmQgPD0gaSkge1xuICAgICAgICAgICAgby5zaGlmdCgpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChvW2FdLnN0YXJ0IDwgaSlcbiAgICAgICAgICAgIG9bYV0uc3RhcnQgPSBpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGErKztcbiAgICAgICAgfVxuICAgICAgfSksIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50c0luUmFuZ2UociwgaSwgcGUuU1VCVElUTEUpO1xuICAgIH1cbiAgfVxuICAvLyBJZiBzb21ldGhpbmcgZ29lcyB3cm9uZywgcHJvY2VlZCB0byBuZXh0IGZyYWcsIGlmIHdlIHdlcmUgcHJvY2Vzc2luZyBvbmUuXG4gIG9uRXJyb3IoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0LmZyYWc7XG4gICAgKHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIudHlwZSkgPT09IHBlLlNVQlRJVExFICYmICh0LmRldGFpbHMgPT09IEouRlJBR19HQVAgJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZnJhZ0J1ZmZlcmVkKHIsICEwKSwgdGhpcy5mcmFnQ3VycmVudCAmJiB0aGlzLmZyYWdDdXJyZW50LmFib3J0UmVxdWVzdHMoKSwgdGhpcy5zdGF0ZSAhPT0gbmUuU1RPUFBFRCAmJiAodGhpcy5zdGF0ZSA9IG5lLklETEUpKTtcbiAgfVxuICAvLyBHb3QgYWxsIG5ldyBzdWJ0aXRsZSBsZXZlbHMuXG4gIG9uU3VidGl0bGVUcmFja3NVcGRhdGVkKGUsIHtcbiAgICBzdWJ0aXRsZVRyYWNrczogdFxuICB9KSB7XG4gICAgaWYgKHRoaXMubGV2ZWxzICYmIEFwKHRoaXMubGV2ZWxzLCB0KSkge1xuICAgICAgdGhpcy5sZXZlbHMgPSB0Lm1hcCgocikgPT4gbmV3IG1pKHIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy50cmFja3NCdWZmZXJlZCA9IFtdLCB0aGlzLmxldmVscyA9IHQubWFwKChyKSA9PiB7XG4gICAgICBjb25zdCBuID0gbmV3IG1pKHIpO1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2tzQnVmZmVyZWRbbi5pZF0gPSBbXSwgbjtcbiAgICB9KSwgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnRzSW5SYW5nZSgwLCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIHBlLlNVQlRJVExFKSwgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsLCB0aGlzLm1lZGlhQnVmZmVyID0gbnVsbDtcbiAgfVxuICBvblN1YnRpdGxlVHJhY2tTd2l0Y2goZSwgdCkge1xuICAgIHZhciByO1xuICAgIGlmICh0aGlzLmN1cnJlbnRUcmFja0lkID0gdC5pZCwgISgociA9IHRoaXMubGV2ZWxzKSAhPSBudWxsICYmIHIubGVuZ3RoKSB8fCB0aGlzLmN1cnJlbnRUcmFja0lkID09PSAtMSkge1xuICAgICAgdGhpcy5jbGVhckludGVydmFsKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG4gPSB0aGlzLmxldmVsc1t0aGlzLmN1cnJlbnRUcmFja0lkXTtcbiAgICBuICE9IG51bGwgJiYgbi5kZXRhaWxzID8gdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWFCdWZmZXJUaW1lUmFuZ2VzIDogdGhpcy5tZWRpYUJ1ZmZlciA9IG51bGwsIG4gJiYgdGhpcy5zdGF0ZSAhPT0gbmUuU1RPUFBFRCAmJiB0aGlzLnNldEludGVydmFsKFFoKTtcbiAgfVxuICAvLyBHb3QgYSBuZXcgc2V0IG9mIHN1YnRpdGxlIGZyYWdtZW50cy5cbiAgb25TdWJ0aXRsZVRyYWNrTG9hZGVkKGUsIHQpIHtcbiAgICB2YXIgcjtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50VHJhY2tJZDogbixcbiAgICAgIGxldmVsczogaVxuICAgIH0gPSB0aGlzLCB7XG4gICAgICBkZXRhaWxzOiBvLFxuICAgICAgaWQ6IGFcbiAgICB9ID0gdDtcbiAgICBpZiAoIWkpIHtcbiAgICAgIHRoaXMud2FybihgU3VidGl0bGUgdHJhY2tzIHdlcmUgcmVzZXQgd2hpbGUgbG9hZGluZyBsZXZlbCAke2F9YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGwgPSBpW2FdO1xuICAgIGlmIChhID49IGkubGVuZ3RoIHx8ICFsKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMubG9nKGBTdWJ0aXRsZSB0cmFjayAke2F9IGxvYWRlZCBbJHtvLnN0YXJ0U059LCR7by5lbmRTTn1dJHtvLmxhc3RQYXJ0U24gPyBgW3BhcnQtJHtvLmxhc3RQYXJ0U259LSR7by5sYXN0UGFydEluZGV4fV1gIDogXCJcIn0sZHVyYXRpb246JHtvLnRvdGFsZHVyYXRpb259YCksIHRoaXMubWVkaWFCdWZmZXIgPSB0aGlzLm1lZGlhQnVmZmVyVGltZVJhbmdlcztcbiAgICBsZXQgYyA9IDA7XG4gICAgaWYgKG8ubGl2ZSB8fCAociA9IGwuZGV0YWlscykgIT0gbnVsbCAmJiByLmxpdmUpIHtcbiAgICAgIGlmIChvLmRlbHRhVXBkYXRlRmFpbGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBkID0gdGhpcy5tYWluRGV0YWlscztcbiAgICAgIGlmICghZCkge1xuICAgICAgICB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9ICExO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBoID0gZC5mcmFnbWVudHNbMF07XG4gICAgICBpZiAoIWwuZGV0YWlscylcbiAgICAgICAgby5oYXNQcm9ncmFtRGF0ZVRpbWUgJiYgZC5oYXNQcm9ncmFtRGF0ZVRpbWUgPyAoc2EobywgZCksIGMgPSBvLmZyYWdtZW50U3RhcnQpIDogaCAmJiAoYyA9IGguc3RhcnQsIGdjKG8sIGMpKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgdTtcbiAgICAgICAgYyA9IHRoaXMuYWxpZ25QbGF5bGlzdHMobywgbC5kZXRhaWxzLCAodSA9IHRoaXMubGV2ZWxMYXN0TG9hZGVkKSA9PSBudWxsID8gdm9pZCAwIDogdS5kZXRhaWxzKSwgYyA9PT0gMCAmJiBoICYmIChjID0gaC5zdGFydCwgZ2MobywgYykpO1xuICAgICAgfVxuICAgICAgZCAmJiAhdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgJiYgdGhpcy5zZXRTdGFydFBvc2l0aW9uKGQsIGMpO1xuICAgIH1cbiAgICBsLmRldGFpbHMgPSBvLCB0aGlzLmxldmVsTGFzdExvYWRlZCA9IGwsIGEgPT09IG4gJiYgKHRoaXMuaGxzLnRyaWdnZXIoSS5TVUJUSVRMRV9UUkFDS19VUERBVEVELCB7XG4gICAgICBkZXRhaWxzOiBvLFxuICAgICAgaWQ6IGEsXG4gICAgICBncm91cElkOiB0Lmdyb3VwSWRcbiAgICB9KSwgdGhpcy50aWNrKCksIG8ubGl2ZSAmJiAhdGhpcy5mcmFnQ3VycmVudCAmJiB0aGlzLm1lZGlhICYmIHRoaXMuc3RhdGUgPT09IG5lLklETEUgJiYgKEpzKG51bGwsIG8uZnJhZ21lbnRzLCB0aGlzLm1lZGlhLmN1cnJlbnRUaW1lLCAwKSB8fCAodGhpcy53YXJuKFwiU3VidGl0bGUgcGxheWxpc3Qgbm90IGFsaWduZWQgd2l0aCBwbGF5YmFja1wiKSwgbC5kZXRhaWxzID0gdm9pZCAwKSkpO1xuICB9XG4gIF9oYW5kbGVGcmFnbWVudExvYWRDb21wbGV0ZShlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZzogdCxcbiAgICAgIHBheWxvYWQ6IHJcbiAgICB9ID0gZSwgbiA9IHQuZGVjcnlwdGRhdGEsIGkgPSB0aGlzLmhscztcbiAgICBpZiAoIXRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKHQpICYmIHIgJiYgci5ieXRlTGVuZ3RoID4gMCAmJiBuICE9IG51bGwgJiYgbi5rZXkgJiYgbi5pdiAmJiBJbihuLm1ldGhvZCkpIHtcbiAgICAgIGNvbnN0IG8gPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHRoaXMuZGVjcnlwdGVyLmRlY3J5cHQobmV3IFVpbnQ4QXJyYXkociksIG4ua2V5LmJ1ZmZlciwgbi5pdi5idWZmZXIsIFN1KG4ubWV0aG9kKSkuY2F0Y2goKGEpID0+IHtcbiAgICAgICAgdGhyb3cgaS50cmlnZ2VyKEkuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiB2ZS5NRURJQV9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBKLkZSQUdfREVDUllQVF9FUlJPUixcbiAgICAgICAgICBmYXRhbDogITEsXG4gICAgICAgICAgZXJyb3I6IGEsXG4gICAgICAgICAgcmVhc29uOiBhLm1lc3NhZ2UsXG4gICAgICAgICAgZnJhZzogdFxuICAgICAgICB9KSwgYTtcbiAgICAgIH0pLnRoZW4oKGEpID0+IHtcbiAgICAgICAgY29uc3QgbCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBpLnRyaWdnZXIoSS5GUkFHX0RFQ1JZUFRFRCwge1xuICAgICAgICAgIGZyYWc6IHQsXG4gICAgICAgICAgcGF5bG9hZDogYSxcbiAgICAgICAgICBzdGF0czoge1xuICAgICAgICAgICAgdHN0YXJ0OiBvLFxuICAgICAgICAgICAgdGRlY3J5cHQ6IGxcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSkuY2F0Y2goKGEpID0+IHtcbiAgICAgICAgdGhpcy53YXJuKGAke2EubmFtZX06ICR7YS5tZXNzYWdlfWApLCB0aGlzLnN0YXRlID0gbmUuSURMRTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBkb1RpY2soKSB7XG4gICAgaWYgKCF0aGlzLm1lZGlhKSB7XG4gICAgICB0aGlzLnN0YXRlID0gbmUuSURMRTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IG5lLklETEUpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY3VycmVudFRyYWNrSWQ6IGUsXG4gICAgICAgIGxldmVsczogdFxuICAgICAgfSA9IHRoaXMsIHIgPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0W2VdO1xuICAgICAgaWYgKCFyIHx8ICF0Lmxlbmd0aCB8fCAhci5kZXRhaWxzIHx8IHRoaXMud2FpdEZvckxpdmUocikpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY29uZmlnOiBuXG4gICAgICB9ID0gdGhpcywgaSA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCksIG8gPSBDZS5idWZmZXJlZEluZm8odGhpcy50cmFja3NCdWZmZXJlZFt0aGlzLmN1cnJlbnRUcmFja0lkXSB8fCBbXSwgaSwgbi5tYXhCdWZmZXJIb2xlKSwge1xuICAgICAgICBlbmQ6IGEsXG4gICAgICAgIGxlbjogbFxuICAgICAgfSA9IG8sIGMgPSByLmRldGFpbHMsIHUgPSB0aGlzLmhscy5tYXhCdWZmZXJMZW5ndGggKyBjLmxldmVsVGFyZ2V0RHVyYXRpb247XG4gICAgICBpZiAobCA+IHUpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGQgPSBjLmZyYWdtZW50cywgaCA9IGQubGVuZ3RoLCBmID0gYy5lZGdlO1xuICAgICAgbGV0IHAgPSBudWxsO1xuICAgICAgY29uc3QgeSA9IHRoaXMuZnJhZ1ByZXZpb3VzO1xuICAgICAgaWYgKGEgPCBmKSB7XG4gICAgICAgIGNvbnN0IFIgPSBuLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsIEEgPSBhID4gZiAtIFIgPyAwIDogUjtcbiAgICAgICAgcCA9IEpzKHksIGQsIE1hdGgubWF4KGRbMF0uc3RhcnQsIGEpLCBBKSwgIXAgJiYgeSAmJiB5LnN0YXJ0IDwgZFswXS5zdGFydCAmJiAocCA9IGRbMF0pO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHAgPSBkW2ggLSAxXTtcbiAgICAgIGlmIChwID0gdGhpcy5maWx0ZXJSZXBsYWNlZFByaW1hcnkocCwgci5kZXRhaWxzKSwgIXApXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IEUgPSBwLnNuIC0gYy5zdGFydFNOLCBiID0gZFtFIC0gMV07XG4gICAgICBpZiAoYiAmJiBiLmNjID09PSBwLmNjICYmIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGIpID09PSBIdC5OT1RfTE9BREVEICYmIChwID0gYiksIHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKHApID09PSBIdC5OT1RfTE9BREVEKSB7XG4gICAgICAgIGNvbnN0IFIgPSB0aGlzLm1hcFRvSW5pdEZyYWdXaGVuUmVxdWlyZWQocCk7XG4gICAgICAgIFIgJiYgdGhpcy5sb2FkRnJhZ21lbnQoUiwgciwgYSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvYWRGcmFnbWVudChlLCB0LCByKSB7XG4gICAgVnQoZSkgPyBzdXBlci5sb2FkRnJhZ21lbnQoZSwgdCwgcikgOiB0aGlzLl9sb2FkSW5pdFNlZ21lbnQoZSwgdCk7XG4gIH1cbiAgZ2V0IG1lZGlhQnVmZmVyVGltZVJhbmdlcygpIHtcbiAgICByZXR1cm4gbmV3IGJ3KHRoaXMudHJhY2tzQnVmZmVyZWRbdGhpcy5jdXJyZW50VHJhY2tJZF0gfHwgW10pO1xuICB9XG59XG5jbGFzcyBidyB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLmJ1ZmZlcmVkID0gdm9pZCAwO1xuICAgIGNvbnN0IHQgPSAociwgbiwgaSkgPT4ge1xuICAgICAgaWYgKG4gPSBuID4+PiAwLCBuID4gaSAtIDEpXG4gICAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oYEZhaWxlZCB0byBleGVjdXRlICcke3J9JyBvbiAnVGltZVJhbmdlcyc6IFRoZSBpbmRleCBwcm92aWRlZCAoJHtufSkgaXMgZ3JlYXRlciB0aGFuIHRoZSBtYXhpbXVtIGJvdW5kICgke2l9KWApO1xuICAgICAgcmV0dXJuIGVbbl1bcl07XG4gICAgfTtcbiAgICB0aGlzLmJ1ZmZlcmVkID0ge1xuICAgICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIGUubGVuZ3RoO1xuICAgICAgfSxcbiAgICAgIGVuZChyKSB7XG4gICAgICAgIHJldHVybiB0KFwiZW5kXCIsIHIsIGUubGVuZ3RoKTtcbiAgICAgIH0sXG4gICAgICBzdGFydChyKSB7XG4gICAgICAgIHJldHVybiB0KFwic3RhcnRcIiwgciwgZS5sZW5ndGgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cbmNvbnN0IFR3ID0ge1xuICA0MjogMjI1LFxuICAvLyBsb3dlcmNhc2UgYSwgYWN1dGUgYWNjZW50XG4gIDkyOiAyMzMsXG4gIC8vIGxvd2VyY2FzZSBlLCBhY3V0ZSBhY2NlbnRcbiAgOTQ6IDIzNyxcbiAgLy8gbG93ZXJjYXNlIGksIGFjdXRlIGFjY2VudFxuICA5NTogMjQzLFxuICAvLyBsb3dlcmNhc2UgbywgYWN1dGUgYWNjZW50XG4gIDk2OiAyNTAsXG4gIC8vIGxvd2VyY2FzZSB1LCBhY3V0ZSBhY2NlbnRcbiAgMTIzOiAyMzEsXG4gIC8vIGxvd2VyY2FzZSBjIHdpdGggY2VkaWxsYVxuICAxMjQ6IDI0NyxcbiAgLy8gZGl2aXNpb24gc3ltYm9sXG4gIDEyNTogMjA5LFxuICAvLyB1cHBlcmNhc2UgTiB0aWxkZVxuICAxMjY6IDI0MSxcbiAgLy8gbG93ZXJjYXNlIG4gdGlsZGVcbiAgMTI3OiA5NjA4LFxuICAvLyBGdWxsIGJsb2NrXG4gIC8vIFRISVMgQkxPQ0sgSU5DTFVERVMgVEhFIDE2IEVYVEVOREVEIChUV08tQllURSkgTElORSAyMSBDSEFSQUNURVJTXG4gIC8vIFRIQVQgQ09NRSBGUk9NIEhJIEJZVEU9MHgxMSBBTkQgTE9XIEJFVFdFRU4gMHgzMCBBTkQgMHgzRlxuICAvLyBUSElTIE1FQU5TIFRIQVQgXFx4NTAgTVVTVCBCRSBBRERFRCBUTyBUSEUgVkFMVUVTXG4gIDEyODogMTc0LFxuICAvLyBSZWdpc3RlcmVkIHN5bWJvbCAoUilcbiAgMTI5OiAxNzYsXG4gIC8vIGRlZ3JlZSBzaWduXG4gIDEzMDogMTg5LFxuICAvLyAxLzIgc3ltYm9sXG4gIDEzMTogMTkxLFxuICAvLyBJbnZlcnRlZCAob3BlbikgcXVlc3Rpb24gbWFya1xuICAxMzI6IDg0ODIsXG4gIC8vIFRyYWRlbWFyayBzeW1ib2wgKFRNKVxuICAxMzM6IDE2MixcbiAgLy8gQ2VudHMgc3ltYm9sXG4gIDEzNDogMTYzLFxuICAvLyBQb3VuZHMgc3RlcmxpbmdcbiAgMTM1OiA5ODM0LFxuICAvLyBNdXNpYyA4J3RoIG5vdGVcbiAgMTM2OiAyMjQsXG4gIC8vIGxvd2VyY2FzZSBhLCBncmF2ZSBhY2NlbnRcbiAgMTM3OiAzMixcbiAgLy8gdHJhbnNwYXJlbnQgc3BhY2UgKHJlZ3VsYXIpXG4gIDEzODogMjMyLFxuICAvLyBsb3dlcmNhc2UgZSwgZ3JhdmUgYWNjZW50XG4gIDEzOTogMjI2LFxuICAvLyBsb3dlcmNhc2UgYSwgY2lyY3VtZmxleCBhY2NlbnRcbiAgMTQwOiAyMzQsXG4gIC8vIGxvd2VyY2FzZSBlLCBjaXJjdW1mbGV4IGFjY2VudFxuICAxNDE6IDIzOCxcbiAgLy8gbG93ZXJjYXNlIGksIGNpcmN1bWZsZXggYWNjZW50XG4gIDE0MjogMjQ0LFxuICAvLyBsb3dlcmNhc2UgbywgY2lyY3VtZmxleCBhY2NlbnRcbiAgMTQzOiAyNTEsXG4gIC8vIGxvd2VyY2FzZSB1LCBjaXJjdW1mbGV4IGFjY2VudFxuICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAzMiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAvLyBUSEFUIENPTUUgRlJPTSBISSBCWVRFPTB4MTIgQU5EIExPVyBCRVRXRUVOIDB4MjAgQU5EIDB4M0ZcbiAgMTQ0OiAxOTMsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIEEgd2l0aCBhY3V0ZVxuICAxNDU6IDIwMSxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgRSB3aXRoIGFjdXRlXG4gIDE0NjogMjExLFxuICAvLyBjYXBpdGFsIGxldHRlciBPIHdpdGggYWN1dGVcbiAgMTQ3OiAyMTgsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIFUgd2l0aCBhY3V0ZVxuICAxNDg6IDIyMCxcbiAgLy8gY2FwaXRhbCBsZXR0ZXIgVSB3aXRoIGRpYXJlc2lzXG4gIDE0OTogMjUyLFxuICAvLyBsb3dlcmNhc2UgbGV0dGVyIFUgd2l0aCBkaWFlcmVzaXNcbiAgMTUwOiA4MjE2LFxuICAvLyBvcGVuaW5nIHNpbmdsZSBxdW90ZVxuICAxNTE6IDE2MSxcbiAgLy8gaW52ZXJ0ZWQgZXhjbGFtYXRpb24gbWFya1xuICAxNTI6IDQyLFxuICAvLyBhc3Rlcmlza1xuICAxNTM6IDgyMTcsXG4gIC8vIGNsb3Npbmcgc2luZ2xlIHF1b3RlXG4gIDE1NDogOTQ3MyxcbiAgLy8gYm94IGRyYXdpbmdzIGhlYXZ5IGhvcml6b250YWxcbiAgMTU1OiAxNjksXG4gIC8vIGNvcHlyaWdodCBzaWduXG4gIDE1NjogODQ4MCxcbiAgLy8gU2VydmljZSBtYXJrXG4gIDE1NzogODIyNixcbiAgLy8gKHJvdW5kKSBidWxsZXRcbiAgMTU4OiA4MjIwLFxuICAvLyBMZWZ0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAxNTk6IDgyMjEsXG4gIC8vIFJpZ2h0IGRvdWJsZSBxdW90YXRpb24gbWFya1xuICAxNjA6IDE5MixcbiAgLy8gdXBwZXJjYXNlIEEsIGdyYXZlIGFjY2VudFxuICAxNjE6IDE5NCxcbiAgLy8gdXBwZXJjYXNlIEEsIGNpcmN1bWZsZXhcbiAgMTYyOiAxOTksXG4gIC8vIHVwcGVyY2FzZSBDIHdpdGggY2VkaWxsYVxuICAxNjM6IDIwMCxcbiAgLy8gdXBwZXJjYXNlIEUsIGdyYXZlIGFjY2VudFxuICAxNjQ6IDIwMixcbiAgLy8gdXBwZXJjYXNlIEUsIGNpcmN1bWZsZXhcbiAgMTY1OiAyMDMsXG4gIC8vIGNhcGl0YWwgbGV0dGVyIEUgd2l0aCBkaWFyZXNpc1xuICAxNjY6IDIzNSxcbiAgLy8gbG93ZXJjYXNlIGxldHRlciBlIHdpdGggZGlhcmVzaXNcbiAgMTY3OiAyMDYsXG4gIC8vIHVwcGVyY2FzZSBJLCBjaXJjdW1mbGV4XG4gIDE2ODogMjA3LFxuICAvLyB1cHBlcmNhc2UgSSwgd2l0aCBkaWFyZXNpc1xuICAxNjk6IDIzOSxcbiAgLy8gbG93ZXJjYXNlIGksIHdpdGggZGlhcmVzaXNcbiAgMTcwOiAyMTIsXG4gIC8vIHVwcGVyY2FzZSBPLCBjaXJjdW1mbGV4XG4gIDE3MTogMjE3LFxuICAvLyB1cHBlcmNhc2UgVSwgZ3JhdmUgYWNjZW50XG4gIDE3MjogMjQ5LFxuICAvLyBsb3dlcmNhc2UgdSwgZ3JhdmUgYWNjZW50XG4gIDE3MzogMjE5LFxuICAvLyB1cHBlcmNhc2UgVSwgY2lyY3VtZmxleFxuICAxNzQ6IDE3MSxcbiAgLy8gbGVmdC1wb2ludGluZyBkb3VibGUgYW5nbGUgcXVvdGF0aW9uIG1hcmtcbiAgMTc1OiAxODcsXG4gIC8vIHJpZ2h0LXBvaW50aW5nIGRvdWJsZSBhbmdsZSBxdW90YXRpb24gbWFya1xuICAvLyBUSElTIEJMT0NLIElOQ0xVREVTIFRIRSAzMiBFWFRFTkRFRCAoVFdPLUJZVEUpIExJTkUgMjEgQ0hBUkFDVEVSU1xuICAvLyBUSEFUIENPTUUgRlJPTSBISSBCWVRFPTB4MTMgQU5EIExPVyBCRVRXRUVOIDB4MjAgQU5EIDB4M0ZcbiAgMTc2OiAxOTUsXG4gIC8vIFVwcGVyY2FzZSBBLCB0aWxkZVxuICAxNzc6IDIyNyxcbiAgLy8gTG93ZXJjYXNlIGEsIHRpbGRlXG4gIDE3ODogMjA1LFxuICAvLyBVcHBlcmNhc2UgSSwgYWN1dGUgYWNjZW50XG4gIDE3OTogMjA0LFxuICAvLyBVcHBlcmNhc2UgSSwgZ3JhdmUgYWNjZW50XG4gIDE4MDogMjM2LFxuICAvLyBMb3dlcmNhc2UgaSwgZ3JhdmUgYWNjZW50XG4gIDE4MTogMjEwLFxuICAvLyBVcHBlcmNhc2UgTywgZ3JhdmUgYWNjZW50XG4gIDE4MjogMjQyLFxuICAvLyBMb3dlcmNhc2UgbywgZ3JhdmUgYWNjZW50XG4gIDE4MzogMjEzLFxuICAvLyBVcHBlcmNhc2UgTywgdGlsZGVcbiAgMTg0OiAyNDUsXG4gIC8vIExvd2VyY2FzZSBvLCB0aWxkZVxuICAxODU6IDEyMyxcbiAgLy8gT3BlbiBjdXJseSBicmFjZVxuICAxODY6IDEyNSxcbiAgLy8gQ2xvc2luZyBjdXJseSBicmFjZVxuICAxODc6IDkyLFxuICAvLyBCYWNrc2xhc2hcbiAgMTg4OiA5NCxcbiAgLy8gQ2FyZXRcbiAgMTg5OiA5NSxcbiAgLy8gVW5kZXJzY29yZVxuICAxOTA6IDEyNCxcbiAgLy8gUGlwZSAodmVydGljYWwgbGluZSlcbiAgMTkxOiA4NzY0LFxuICAvLyBUaWxkZSBvcGVyYXRvclxuICAxOTI6IDE5NixcbiAgLy8gVXBwZXJjYXNlIEEsIHVtbGF1dFxuICAxOTM6IDIyOCxcbiAgLy8gTG93ZXJjYXNlIEEsIHVtbGF1dFxuICAxOTQ6IDIxNCxcbiAgLy8gVXBwZXJjYXNlIE8sIHVtbGF1dFxuICAxOTU6IDI0NixcbiAgLy8gTG93ZXJjYXNlIG8sIHVtbGF1dFxuICAxOTY6IDIyMyxcbiAgLy8gRXNzemV0dCAoc2hhcnAgUylcbiAgMTk3OiAxNjUsXG4gIC8vIFllbiBzeW1ib2xcbiAgMTk4OiAxNjQsXG4gIC8vIEdlbmVyaWMgY3VycmVuY3kgc2lnblxuICAxOTk6IDk0NzUsXG4gIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB2ZXJ0aWNhbFxuICAyMDA6IDE5NyxcbiAgLy8gVXBwZXJjYXNlIEEsIHJpbmdcbiAgMjAxOiAyMjksXG4gIC8vIExvd2VyY2FzZSBBLCByaW5nXG4gIDIwMjogMjE2LFxuICAvLyBVcHBlcmNhc2UgTywgc3Ryb2tlXG4gIDIwMzogMjQ4LFxuICAvLyBMb3dlcmNhc2Ugbywgc3Ryb2tcbiAgMjA0OiA5NDg3LFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgcmlnaHRcbiAgMjA1OiA5NDkxLFxuICAvLyBCb3ggZHJhd2luZ3MgaGVhdnkgZG93biBhbmQgbGVmdFxuICAyMDY6IDk0OTUsXG4gIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgcmlnaHRcbiAgMjA3OiA5NDk5XG4gIC8vIEJveCBkcmF3aW5ncyBoZWF2eSB1cCBhbmQgbGVmdFxufSwgR3AgPSAocykgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShUd1tzXSB8fCBzKSwgRHIgPSAxNSwgaXMgPSAxMDAsIHd3ID0ge1xuICAxNzogMSxcbiAgMTg6IDMsXG4gIDIxOiA1LFxuICAyMjogNyxcbiAgMjM6IDksXG4gIDE2OiAxMSxcbiAgMTk6IDEyLFxuICAyMDogMTRcbn0sIEF3ID0ge1xuICAxNzogMixcbiAgMTg6IDQsXG4gIDIxOiA2LFxuICAyMjogOCxcbiAgMjM6IDEwLFxuICAxOTogMTMsXG4gIDIwOiAxNVxufSwgSXcgPSB7XG4gIDI1OiAxLFxuICAyNjogMyxcbiAgMjk6IDUsXG4gIDMwOiA3LFxuICAzMTogOSxcbiAgMjQ6IDExLFxuICAyNzogMTIsXG4gIDI4OiAxNFxufSwgX3cgPSB7XG4gIDI1OiAyLFxuICAyNjogNCxcbiAgMjk6IDYsXG4gIDMwOiA4LFxuICAzMTogMTAsXG4gIDI3OiAxMyxcbiAgMjg6IDE1XG59LCBSdyA9IFtcIndoaXRlXCIsIFwiZ3JlZW5cIiwgXCJibHVlXCIsIFwiY3lhblwiLCBcInJlZFwiLCBcInllbGxvd1wiLCBcIm1hZ2VudGFcIiwgXCJibGFja1wiLCBcInRyYW5zcGFyZW50XCJdO1xuY2xhc3MgTHcge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnRpbWUgPSBudWxsLCB0aGlzLnZlcmJvc2VMZXZlbCA9IDA7XG4gIH1cbiAgbG9nKGUsIHQpIHtcbiAgICBpZiAodGhpcy52ZXJib3NlTGV2ZWwgPj0gZSkge1xuICAgICAgY29uc3QgciA9IHR5cGVvZiB0ID09IFwiZnVuY3Rpb25cIiA/IHQoKSA6IHQ7XG4gICAgICBydC5sb2coYCR7dGhpcy50aW1lfSBbJHtlfV0gJHtyfWApO1xuICAgIH1cbiAgfVxufVxuY29uc3QgTnMgPSBmdW5jdGlvbihlKSB7XG4gIGNvbnN0IHQgPSBbXTtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCBlLmxlbmd0aDsgcisrKVxuICAgIHQucHVzaChlW3JdLnRvU3RyaW5nKDE2KSk7XG4gIHJldHVybiB0O1xufTtcbmNsYXNzIFZwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gXCJ3aGl0ZVwiLCB0aGlzLnVuZGVybGluZSA9ICExLCB0aGlzLml0YWxpY3MgPSAhMSwgdGhpcy5iYWNrZ3JvdW5kID0gXCJibGFja1wiLCB0aGlzLmZsYXNoID0gITE7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgdGhpcy5mb3JlZ3JvdW5kID0gXCJ3aGl0ZVwiLCB0aGlzLnVuZGVybGluZSA9ICExLCB0aGlzLml0YWxpY3MgPSAhMSwgdGhpcy5iYWNrZ3JvdW5kID0gXCJibGFja1wiLCB0aGlzLmZsYXNoID0gITE7XG4gIH1cbiAgc2V0U3R5bGVzKGUpIHtcbiAgICBjb25zdCB0ID0gW1wiZm9yZWdyb3VuZFwiLCBcInVuZGVybGluZVwiLCBcIml0YWxpY3NcIiwgXCJiYWNrZ3JvdW5kXCIsIFwiZmxhc2hcIl07XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKSB7XG4gICAgICBjb25zdCBuID0gdFtyXTtcbiAgICAgIGUuaGFzT3duUHJvcGVydHkobikgJiYgKHRoaXNbbl0gPSBlW25dKTtcbiAgICB9XG4gIH1cbiAgaXNEZWZhdWx0KCkge1xuICAgIHJldHVybiB0aGlzLmZvcmVncm91bmQgPT09IFwid2hpdGVcIiAmJiAhdGhpcy51bmRlcmxpbmUgJiYgIXRoaXMuaXRhbGljcyAmJiB0aGlzLmJhY2tncm91bmQgPT09IFwiYmxhY2tcIiAmJiAhdGhpcy5mbGFzaDtcbiAgfVxuICBlcXVhbHMoZSkge1xuICAgIHJldHVybiB0aGlzLmZvcmVncm91bmQgPT09IGUuZm9yZWdyb3VuZCAmJiB0aGlzLnVuZGVybGluZSA9PT0gZS51bmRlcmxpbmUgJiYgdGhpcy5pdGFsaWNzID09PSBlLml0YWxpY3MgJiYgdGhpcy5iYWNrZ3JvdW5kID09PSBlLmJhY2tncm91bmQgJiYgdGhpcy5mbGFzaCA9PT0gZS5mbGFzaDtcbiAgfVxuICBjb3B5KGUpIHtcbiAgICB0aGlzLmZvcmVncm91bmQgPSBlLmZvcmVncm91bmQsIHRoaXMudW5kZXJsaW5lID0gZS51bmRlcmxpbmUsIHRoaXMuaXRhbGljcyA9IGUuaXRhbGljcywgdGhpcy5iYWNrZ3JvdW5kID0gZS5iYWNrZ3JvdW5kLCB0aGlzLmZsYXNoID0gZS5mbGFzaDtcbiAgfVxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gXCJjb2xvcj1cIiArIHRoaXMuZm9yZWdyb3VuZCArIFwiLCB1bmRlcmxpbmU9XCIgKyB0aGlzLnVuZGVybGluZSArIFwiLCBpdGFsaWNzPVwiICsgdGhpcy5pdGFsaWNzICsgXCIsIGJhY2tncm91bmQ9XCIgKyB0aGlzLmJhY2tncm91bmQgKyBcIiwgZmxhc2g9XCIgKyB0aGlzLmZsYXNoO1xuICB9XG59XG5jbGFzcyBDdyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudWNoYXIgPSBcIiBcIiwgdGhpcy5wZW5TdGF0ZSA9IG5ldyBWcCgpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMudWNoYXIgPSBcIiBcIiwgdGhpcy5wZW5TdGF0ZS5yZXNldCgpO1xuICB9XG4gIHNldENoYXIoZSwgdCkge1xuICAgIHRoaXMudWNoYXIgPSBlLCB0aGlzLnBlblN0YXRlLmNvcHkodCk7XG4gIH1cbiAgc2V0UGVuU3RhdGUoZSkge1xuICAgIHRoaXMucGVuU3RhdGUuY29weShlKTtcbiAgfVxuICBlcXVhbHMoZSkge1xuICAgIHJldHVybiB0aGlzLnVjaGFyID09PSBlLnVjaGFyICYmIHRoaXMucGVuU3RhdGUuZXF1YWxzKGUucGVuU3RhdGUpO1xuICB9XG4gIGNvcHkoZSkge1xuICAgIHRoaXMudWNoYXIgPSBlLnVjaGFyLCB0aGlzLnBlblN0YXRlLmNvcHkoZS5wZW5TdGF0ZSk7XG4gIH1cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy51Y2hhciA9PT0gXCIgXCIgJiYgdGhpcy5wZW5TdGF0ZS5pc0RlZmF1bHQoKTtcbiAgfVxufVxuY2xhc3Mga3cge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5jaGFycyA9IFtdLCB0aGlzLnBvcyA9IDAsIHRoaXMuY3VyclBlblN0YXRlID0gbmV3IFZwKCksIHRoaXMuY3VlU3RhcnRUaW1lID0gbnVsbCwgdGhpcy5sb2dnZXIgPSB2b2lkIDA7XG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCBpczsgdCsrKVxuICAgICAgdGhpcy5jaGFycy5wdXNoKG5ldyBDdygpKTtcbiAgICB0aGlzLmxvZ2dlciA9IGU7XG4gIH1cbiAgZXF1YWxzKGUpIHtcbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IGlzOyB0KyspXG4gICAgICBpZiAoIXRoaXMuY2hhcnNbdF0uZXF1YWxzKGUuY2hhcnNbdF0pKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgcmV0dXJuICEwO1xuICB9XG4gIGNvcHkoZSkge1xuICAgIGZvciAobGV0IHQgPSAwOyB0IDwgaXM7IHQrKylcbiAgICAgIHRoaXMuY2hhcnNbdF0uY29weShlLmNoYXJzW3RdKTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIGxldCBlID0gITA7XG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCBpczsgdCsrKVxuICAgICAgaWYgKCF0aGlzLmNoYXJzW3RdLmlzRW1wdHkoKSkge1xuICAgICAgICBlID0gITE7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIHJldHVybiBlO1xuICB9XG4gIC8qKlxuICAgKiAgU2V0IHRoZSBjdXJzb3IgdG8gYSB2YWxpZCBjb2x1bW4uXG4gICAqL1xuICBzZXRDdXJzb3IoZSkge1xuICAgIHRoaXMucG9zICE9PSBlICYmICh0aGlzLnBvcyA9IGUpLCB0aGlzLnBvcyA8IDAgPyAodGhpcy5sb2dnZXIubG9nKDMsIFwiTmVnYXRpdmUgY3Vyc29yIHBvc2l0aW9uIFwiICsgdGhpcy5wb3MpLCB0aGlzLnBvcyA9IDApIDogdGhpcy5wb3MgPiBpcyAmJiAodGhpcy5sb2dnZXIubG9nKDMsIFwiVG9vIGxhcmdlIGN1cnNvciBwb3NpdGlvbiBcIiArIHRoaXMucG9zKSwgdGhpcy5wb3MgPSBpcyk7XG4gIH1cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGN1cnNvciByZWxhdGl2ZSB0byBjdXJyZW50IHBvc2l0aW9uLlxuICAgKi9cbiAgbW92ZUN1cnNvcihlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMucG9zICsgZTtcbiAgICBpZiAoZSA+IDEpXG4gICAgICBmb3IgKGxldCByID0gdGhpcy5wb3MgKyAxOyByIDwgdCArIDE7IHIrKylcbiAgICAgICAgdGhpcy5jaGFyc1tyXS5zZXRQZW5TdGF0ZSh0aGlzLmN1cnJQZW5TdGF0ZSk7XG4gICAgdGhpcy5zZXRDdXJzb3IodCk7XG4gIH1cbiAgLyoqXG4gICAqIEJhY2tzcGFjZSwgbW92ZSBvbmUgc3RlcCBiYWNrIGFuZCBjbGVhciBjaGFyYWN0ZXIuXG4gICAqL1xuICBiYWNrU3BhY2UoKSB7XG4gICAgdGhpcy5tb3ZlQ3Vyc29yKC0xKSwgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcihcIiBcIiwgdGhpcy5jdXJyUGVuU3RhdGUpO1xuICB9XG4gIGluc2VydENoYXIoZSkge1xuICAgIGUgPj0gMTQ0ICYmIHRoaXMuYmFja1NwYWNlKCk7XG4gICAgY29uc3QgdCA9IEdwKGUpO1xuICAgIGlmICh0aGlzLnBvcyA+PSBpcykge1xuICAgICAgdGhpcy5sb2dnZXIubG9nKDAsICgpID0+IFwiQ2Fubm90IGluc2VydCBcIiArIGUudG9TdHJpbmcoMTYpICsgXCIgKFwiICsgdCArIFwiKSBhdCBwb3NpdGlvbiBcIiArIHRoaXMucG9zICsgXCIuIFNraXBwaW5nIGl0IVwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jaGFyc1t0aGlzLnBvc10uc2V0Q2hhcih0LCB0aGlzLmN1cnJQZW5TdGF0ZSksIHRoaXMubW92ZUN1cnNvcigxKTtcbiAgfVxuICBjbGVhckZyb21Qb3MoZSkge1xuICAgIGxldCB0O1xuICAgIGZvciAodCA9IGU7IHQgPCBpczsgdCsrKVxuICAgICAgdGhpcy5jaGFyc1t0XS5yZXNldCgpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIHRoaXMuY2xlYXJGcm9tUG9zKDApLCB0aGlzLnBvcyA9IDAsIHRoaXMuY3VyclBlblN0YXRlLnJlc2V0KCk7XG4gIH1cbiAgY2xlYXJUb0VuZE9mUm93KCkge1xuICAgIHRoaXMuY2xlYXJGcm9tUG9zKHRoaXMucG9zKTtcbiAgfVxuICBnZXRUZXh0U3RyaW5nKCkge1xuICAgIGNvbnN0IGUgPSBbXTtcbiAgICBsZXQgdCA9ICEwO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgaXM7IHIrKykge1xuICAgICAgY29uc3QgbiA9IHRoaXMuY2hhcnNbcl0udWNoYXI7XG4gICAgICBuICE9PSBcIiBcIiAmJiAodCA9ICExKSwgZS5wdXNoKG4pO1xuICAgIH1cbiAgICByZXR1cm4gdCA/IFwiXCIgOiBlLmpvaW4oXCJcIik7XG4gIH1cbiAgc2V0UGVuU3R5bGVzKGUpIHtcbiAgICB0aGlzLmN1cnJQZW5TdGF0ZS5zZXRTdHlsZXMoZSksIHRoaXMuY2hhcnNbdGhpcy5wb3NdLnNldFBlblN0YXRlKHRoaXMuY3VyclBlblN0YXRlKTtcbiAgfVxufVxuY2xhc3Mgd2wge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5yb3dzID0gW10sIHRoaXMuY3VyclJvdyA9IERyIC0gMSwgdGhpcy5uclJvbGxVcFJvd3MgPSBudWxsLCB0aGlzLmxhc3RPdXRwdXRTY3JlZW4gPSBudWxsLCB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IERyOyB0KyspXG4gICAgICB0aGlzLnJvd3MucHVzaChuZXcga3coZSkpO1xuICAgIHRoaXMubG9nZ2VyID0gZTtcbiAgfVxuICByZXNldCgpIHtcbiAgICBmb3IgKGxldCBlID0gMDsgZSA8IERyOyBlKyspXG4gICAgICB0aGlzLnJvd3NbZV0uY2xlYXIoKTtcbiAgICB0aGlzLmN1cnJSb3cgPSBEciAtIDE7XG4gIH1cbiAgZXF1YWxzKGUpIHtcbiAgICBsZXQgdCA9ICEwO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgRHI7IHIrKylcbiAgICAgIGlmICghdGhpcy5yb3dzW3JdLmVxdWFscyhlLnJvd3Nbcl0pKSB7XG4gICAgICAgIHQgPSAhMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgY29weShlKSB7XG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCBEcjsgdCsrKVxuICAgICAgdGhpcy5yb3dzW3RdLmNvcHkoZS5yb3dzW3RdKTtcbiAgfVxuICBpc0VtcHR5KCkge1xuICAgIGxldCBlID0gITA7XG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCBEcjsgdCsrKVxuICAgICAgaWYgKCF0aGlzLnJvd3NbdF0uaXNFbXB0eSgpKSB7XG4gICAgICAgIGUgPSAhMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgYmFja1NwYWNlKCkge1xuICAgIHRoaXMucm93c1t0aGlzLmN1cnJSb3ddLmJhY2tTcGFjZSgpO1xuICB9XG4gIGNsZWFyVG9FbmRPZlJvdygpIHtcbiAgICB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XS5jbGVhclRvRW5kT2ZSb3coKTtcbiAgfVxuICAvKipcbiAgICogSW5zZXJ0IGEgY2hhcmFjdGVyICh3aXRob3V0IHN0eWxpbmcpIGluIHRoZSBjdXJyZW50IHJvdy5cbiAgICovXG4gIGluc2VydENoYXIoZSkge1xuICAgIHRoaXMucm93c1t0aGlzLmN1cnJSb3ddLmluc2VydENoYXIoZSk7XG4gIH1cbiAgc2V0UGVuKGUpIHtcbiAgICB0aGlzLnJvd3NbdGhpcy5jdXJyUm93XS5zZXRQZW5TdHlsZXMoZSk7XG4gIH1cbiAgbW92ZUN1cnNvcihlKSB7XG4gICAgdGhpcy5yb3dzW3RoaXMuY3VyclJvd10ubW92ZUN1cnNvcihlKTtcbiAgfVxuICBzZXRDdXJzb3IoZSkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCBcInNldEN1cnNvcjogXCIgKyBlKSwgdGhpcy5yb3dzW3RoaXMuY3VyclJvd10uc2V0Q3Vyc29yKGUpO1xuICB9XG4gIHNldFBBQyhlKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsICgpID0+IFwicGFjRGF0YSA9IFwiICsgYXQoZSkpO1xuICAgIGxldCB0ID0gZS5yb3cgLSAxO1xuICAgIGlmICh0aGlzLm5yUm9sbFVwUm93cyAmJiB0IDwgdGhpcy5uclJvbGxVcFJvd3MgLSAxICYmICh0ID0gdGhpcy5uclJvbGxVcFJvd3MgLSAxKSwgdGhpcy5uclJvbGxVcFJvd3MgJiYgdGhpcy5jdXJyUm93ICE9PSB0KSB7XG4gICAgICBmb3IgKGxldCBhID0gMDsgYSA8IERyOyBhKyspXG4gICAgICAgIHRoaXMucm93c1thXS5jbGVhcigpO1xuICAgICAgY29uc3QgaSA9IHRoaXMuY3VyclJvdyArIDEgLSB0aGlzLm5yUm9sbFVwUm93cywgbyA9IHRoaXMubGFzdE91dHB1dFNjcmVlbjtcbiAgICAgIGlmIChvKSB7XG4gICAgICAgIGNvbnN0IGEgPSBvLnJvd3NbaV0uY3VlU3RhcnRUaW1lLCBsID0gdGhpcy5sb2dnZXIudGltZTtcbiAgICAgICAgaWYgKGEgIT09IG51bGwgJiYgbCAhPT0gbnVsbCAmJiBhIDwgbClcbiAgICAgICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRoaXMubnJSb2xsVXBSb3dzOyBjKyspXG4gICAgICAgICAgICB0aGlzLnJvd3NbdCAtIHRoaXMubnJSb2xsVXBSb3dzICsgYyArIDFdLmNvcHkoby5yb3dzW2kgKyBjXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3VyclJvdyA9IHQ7XG4gICAgY29uc3QgciA9IHRoaXMucm93c1t0aGlzLmN1cnJSb3ddO1xuICAgIGlmIChlLmluZGVudCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgaSA9IGUuaW5kZW50LCBvID0gTWF0aC5tYXgoaSAtIDEsIDApO1xuICAgICAgci5zZXRDdXJzb3IoZS5pbmRlbnQpLCBlLmNvbG9yID0gci5jaGFyc1tvXS5wZW5TdGF0ZS5mb3JlZ3JvdW5kO1xuICAgIH1cbiAgICBjb25zdCBuID0ge1xuICAgICAgZm9yZWdyb3VuZDogZS5jb2xvcixcbiAgICAgIHVuZGVybGluZTogZS51bmRlcmxpbmUsXG4gICAgICBpdGFsaWNzOiBlLml0YWxpY3MsXG4gICAgICBiYWNrZ3JvdW5kOiBcImJsYWNrXCIsXG4gICAgICBmbGFzaDogITFcbiAgICB9O1xuICAgIHRoaXMuc2V0UGVuKG4pO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgYmFja2dyb3VuZC9leHRyYSBmb3JlZ3JvdW5kLCBidXQgZmlyc3QgZG8gYmFja19zcGFjZSwgYW5kIHRoZW4gaW5zZXJ0IHNwYWNlIChiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSkuXG4gICAqL1xuICBzZXRCa2dEYXRhKGUpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coMiwgKCkgPT4gXCJia2dEYXRhID0gXCIgKyBhdChlKSksIHRoaXMuYmFja1NwYWNlKCksIHRoaXMuc2V0UGVuKGUpLCB0aGlzLmluc2VydENoYXIoMzIpO1xuICB9XG4gIHNldFJvbGxVcFJvd3MoZSkge1xuICAgIHRoaXMubnJSb2xsVXBSb3dzID0gZTtcbiAgfVxuICByb2xsVXAoKSB7XG4gICAgaWYgKHRoaXMubnJSb2xsVXBSb3dzID09PSBudWxsKSB7XG4gICAgICB0aGlzLmxvZ2dlci5sb2coMywgXCJyb2xsX3VwIGJ1dCBuclJvbGxVcFJvd3Mgbm90IHNldCB5ZXRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLmxvZygxLCAoKSA9PiB0aGlzLmdldERpc3BsYXlUZXh0KCkpO1xuICAgIGNvbnN0IGUgPSB0aGlzLmN1cnJSb3cgKyAxIC0gdGhpcy5uclJvbGxVcFJvd3MsIHQgPSB0aGlzLnJvd3Muc3BsaWNlKGUsIDEpWzBdO1xuICAgIHQuY2xlYXIoKSwgdGhpcy5yb3dzLnNwbGljZSh0aGlzLmN1cnJSb3csIDAsIHQpLCB0aGlzLmxvZ2dlci5sb2coMiwgXCJSb2xsaW5nIHVwXCIpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYWxsIG5vbi1lbXB0eSByb3dzIHdpdGggYXMgdW5pY29kZSB0ZXh0LlxuICAgKi9cbiAgZ2V0RGlzcGxheVRleHQoZSkge1xuICAgIGUgPSBlIHx8ICExO1xuICAgIGNvbnN0IHQgPSBbXTtcbiAgICBsZXQgciA9IFwiXCIsIG4gPSAtMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IERyOyBpKyspIHtcbiAgICAgIGNvbnN0IG8gPSB0aGlzLnJvd3NbaV0uZ2V0VGV4dFN0cmluZygpO1xuICAgICAgbyAmJiAobiA9IGkgKyAxLCBlID8gdC5wdXNoKFwiUm93IFwiICsgbiArIFwiOiAnXCIgKyBvICsgXCInXCIpIDogdC5wdXNoKG8udHJpbSgpKSk7XG4gICAgfVxuICAgIHJldHVybiB0Lmxlbmd0aCA+IDAgJiYgKGUgPyByID0gXCJbXCIgKyB0LmpvaW4oXCIgfCBcIikgKyBcIl1cIiA6IHIgPSB0LmpvaW4oYFxuYCkpLCByO1xuICB9XG4gIGdldFRleHRBbmRGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMucm93cztcbiAgfVxufVxuY2xhc3MgZWYge1xuICBjb25zdHJ1Y3RvcihlLCB0LCByKSB7XG4gICAgdGhpcy5jaE5yID0gdm9pZCAwLCB0aGlzLm91dHB1dEZpbHRlciA9IHZvaWQgMCwgdGhpcy5tb2RlID0gdm9pZCAwLCB0aGlzLnZlcmJvc2UgPSB2b2lkIDAsIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gdm9pZCAwLCB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeSA9IHZvaWQgMCwgdGhpcy5sYXN0T3V0cHV0U2NyZWVuID0gdm9pZCAwLCB0aGlzLmN1cnJSb2xsVXBSb3cgPSB2b2lkIDAsIHRoaXMud3JpdGVTY3JlZW4gPSB2b2lkIDAsIHRoaXMuY3VlU3RhcnRUaW1lID0gdm9pZCAwLCB0aGlzLmxvZ2dlciA9IHZvaWQgMCwgdGhpcy5jaE5yID0gZSwgdGhpcy5vdXRwdXRGaWx0ZXIgPSB0LCB0aGlzLm1vZGUgPSBudWxsLCB0aGlzLnZlcmJvc2UgPSAwLCB0aGlzLmRpc3BsYXllZE1lbW9yeSA9IG5ldyB3bChyKSwgdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgPSBuZXcgd2wociksIHRoaXMubGFzdE91dHB1dFNjcmVlbiA9IG5ldyB3bChyKSwgdGhpcy5jdXJyUm9sbFVwUm93ID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkucm93c1tEciAtIDFdLCB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5kaXNwbGF5ZWRNZW1vcnksIHRoaXMubW9kZSA9IG51bGwsIHRoaXMuY3VlU3RhcnRUaW1lID0gbnVsbCwgdGhpcy5sb2dnZXIgPSByO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMubW9kZSA9IG51bGwsIHRoaXMuZGlzcGxheWVkTWVtb3J5LnJlc2V0KCksIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5LnJlc2V0KCksIHRoaXMubGFzdE91dHB1dFNjcmVlbi5yZXNldCgpLCB0aGlzLm91dHB1dEZpbHRlci5yZXNldCgpLCB0aGlzLmN1cnJSb2xsVXBSb3cgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5yb3dzW0RyIC0gMV0sIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeSwgdGhpcy5tb2RlID0gbnVsbCwgdGhpcy5jdWVTdGFydFRpbWUgPSBudWxsO1xuICB9XG4gIGdldEhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0RmlsdGVyO1xuICB9XG4gIHNldEhhbmRsZXIoZSkge1xuICAgIHRoaXMub3V0cHV0RmlsdGVyID0gZTtcbiAgfVxuICBzZXRQQUMoZSkge1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0UEFDKGUpO1xuICB9XG4gIHNldEJrZ0RhdGEoZSkge1xuICAgIHRoaXMud3JpdGVTY3JlZW4uc2V0QmtnRGF0YShlKTtcbiAgfVxuICBzZXRNb2RlKGUpIHtcbiAgICBlICE9PSB0aGlzLm1vZGUgJiYgKHRoaXMubW9kZSA9IGUsIHRoaXMubG9nZ2VyLmxvZygyLCAoKSA9PiBcIk1PREU9XCIgKyBlKSwgdGhpcy5tb2RlID09PSBcIk1PREVfUE9QLU9OXCIgPyB0aGlzLndyaXRlU2NyZWVuID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnkgOiAodGhpcy53cml0ZVNjcmVlbiA9IHRoaXMuZGlzcGxheWVkTWVtb3J5LCB0aGlzLndyaXRlU2NyZWVuLnJlc2V0KCkpLCB0aGlzLm1vZGUgIT09IFwiTU9ERV9ST0xMLVVQXCIgJiYgKHRoaXMuZGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGwsIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5Lm5yUm9sbFVwUm93cyA9IG51bGwpLCB0aGlzLm1vZGUgPSBlKTtcbiAgfVxuICBpbnNlcnRDaGFycyhlKSB7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCBlLmxlbmd0aDsgcisrKVxuICAgICAgdGhpcy53cml0ZVNjcmVlbi5pbnNlcnRDaGFyKGVbcl0pO1xuICAgIGNvbnN0IHQgPSB0aGlzLndyaXRlU2NyZWVuID09PSB0aGlzLmRpc3BsYXllZE1lbW9yeSA/IFwiRElTUFwiIDogXCJOT05fRElTUFwiO1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCAoKSA9PiB0ICsgXCI6IFwiICsgdGhpcy53cml0ZVNjcmVlbi5nZXREaXNwbGF5VGV4dCghMCkpLCAodGhpcy5tb2RlID09PSBcIk1PREVfUEFJTlQtT05cIiB8fCB0aGlzLm1vZGUgPT09IFwiTU9ERV9ST0xMLVVQXCIpICYmICh0aGlzLmxvZ2dlci5sb2coMSwgKCkgPT4gXCJESVNQTEFZRUQ6IFwiICsgdGhpcy5kaXNwbGF5ZWRNZW1vcnkuZ2V0RGlzcGxheVRleHQoITApKSwgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCkpO1xuICB9XG4gIGNjUkNMKCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCBcIlJDTCAtIFJlc3VtZSBDYXB0aW9uIExvYWRpbmdcIiksIHRoaXMuc2V0TW9kZShcIk1PREVfUE9QLU9OXCIpO1xuICB9XG4gIGNjQlMoKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsIFwiQlMgLSBCYWNrU3BhY2VcIiksIHRoaXMubW9kZSAhPT0gXCJNT0RFX1RFWFRcIiAmJiAodGhpcy53cml0ZVNjcmVlbi5iYWNrU3BhY2UoKSwgdGhpcy53cml0ZVNjcmVlbiA9PT0gdGhpcy5kaXNwbGF5ZWRNZW1vcnkgJiYgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCkpO1xuICB9XG4gIGNjQU9GKCkge1xuICB9XG4gIGNjQU9OKCkge1xuICB9XG4gIGNjREVSKCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCBcIkRFUi0gRGVsZXRlIHRvIEVuZCBvZiBSb3dcIiksIHRoaXMud3JpdGVTY3JlZW4uY2xlYXJUb0VuZE9mUm93KCksIHRoaXMub3V0cHV0RGF0YVVwZGF0ZSgpO1xuICB9XG4gIGNjUlUoZSkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCBcIlJVKFwiICsgZSArIFwiKSAtIFJvbGwgVXBcIiksIHRoaXMud3JpdGVTY3JlZW4gPSB0aGlzLmRpc3BsYXllZE1lbW9yeSwgdGhpcy5zZXRNb2RlKFwiTU9ERV9ST0xMLVVQXCIpLCB0aGlzLndyaXRlU2NyZWVuLnNldFJvbGxVcFJvd3MoZSk7XG4gIH1cbiAgY2NGT04oKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsIFwiRk9OIC0gRmxhc2ggT25cIiksIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHtcbiAgICAgIGZsYXNoOiAhMFxuICAgIH0pO1xuICB9XG4gIGNjUkRDKCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCBcIlJEQyAtIFJlc3VtZSBEaXJlY3QgQ2FwdGlvbmluZ1wiKSwgdGhpcy5zZXRNb2RlKFwiTU9ERV9QQUlOVC1PTlwiKTtcbiAgfVxuICBjY1RSKCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCBcIlRSXCIpLCB0aGlzLnNldE1vZGUoXCJNT0RFX1RFWFRcIik7XG4gIH1cbiAgY2NSVEQoKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsIFwiUlREXCIpLCB0aGlzLnNldE1vZGUoXCJNT0RFX1RFWFRcIik7XG4gIH1cbiAgY2NFRE0oKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKDIsIFwiRURNIC0gRXJhc2UgRGlzcGxheWVkIE1lbW9yeVwiKSwgdGhpcy5kaXNwbGF5ZWRNZW1vcnkucmVzZXQoKSwgdGhpcy5vdXRwdXREYXRhVXBkYXRlKCEwKTtcbiAgfVxuICBjY0NSKCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCBcIkNSIC0gQ2FycmlhZ2UgUmV0dXJuXCIpLCB0aGlzLndyaXRlU2NyZWVuLnJvbGxVcCgpLCB0aGlzLm91dHB1dERhdGFVcGRhdGUoITApO1xuICB9XG4gIGNjRU5NKCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCBcIkVOTSAtIEVyYXNlIE5vbi1kaXNwbGF5ZWQgTWVtb3J5XCIpLCB0aGlzLm5vbkRpc3BsYXllZE1lbW9yeS5yZXNldCgpO1xuICB9XG4gIGNjRU9DKCkge1xuICAgIGlmICh0aGlzLmxvZ2dlci5sb2coMiwgXCJFT0MgLSBFbmQgT2YgQ2FwdGlvblwiKSwgdGhpcy5tb2RlID09PSBcIk1PREVfUE9QLU9OXCIpIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLmRpc3BsYXllZE1lbW9yeTtcbiAgICAgIHRoaXMuZGlzcGxheWVkTWVtb3J5ID0gdGhpcy5ub25EaXNwbGF5ZWRNZW1vcnksIHRoaXMubm9uRGlzcGxheWVkTWVtb3J5ID0gZSwgdGhpcy53cml0ZVNjcmVlbiA9IHRoaXMubm9uRGlzcGxheWVkTWVtb3J5LCB0aGlzLmxvZ2dlci5sb2coMSwgKCkgPT4gXCJESVNQOiBcIiArIHRoaXMuZGlzcGxheWVkTWVtb3J5LmdldERpc3BsYXlUZXh0KCkpO1xuICAgIH1cbiAgICB0aGlzLm91dHB1dERhdGFVcGRhdGUoITApO1xuICB9XG4gIGNjVE8oZSkge1xuICAgIHRoaXMubG9nZ2VyLmxvZygyLCBcIlRPKFwiICsgZSArIFwiKSAtIFRhYiBPZmZzZXRcIiksIHRoaXMud3JpdGVTY3JlZW4ubW92ZUN1cnNvcihlKTtcbiAgfVxuICBjY01JRFJPVyhlKSB7XG4gICAgY29uc3QgdCA9IHtcbiAgICAgIGZsYXNoOiAhMVxuICAgIH07XG4gICAgaWYgKHQudW5kZXJsaW5lID0gZSAlIDIgPT09IDEsIHQuaXRhbGljcyA9IGUgPj0gNDYsIHQuaXRhbGljcylcbiAgICAgIHQuZm9yZWdyb3VuZCA9IFwid2hpdGVcIjtcbiAgICBlbHNlIHtcbiAgICAgIGNvbnN0IHIgPSBNYXRoLmZsb29yKGUgLyAyKSAtIDE2LCBuID0gW1wid2hpdGVcIiwgXCJncmVlblwiLCBcImJsdWVcIiwgXCJjeWFuXCIsIFwicmVkXCIsIFwieWVsbG93XCIsIFwibWFnZW50YVwiXTtcbiAgICAgIHQuZm9yZWdyb3VuZCA9IG5bcl07XG4gICAgfVxuICAgIHRoaXMubG9nZ2VyLmxvZygyLCBcIk1JRFJPVzogXCIgKyBhdCh0KSksIHRoaXMud3JpdGVTY3JlZW4uc2V0UGVuKHQpO1xuICB9XG4gIG91dHB1dERhdGFVcGRhdGUoZSA9ICExKSB7XG4gICAgY29uc3QgdCA9IHRoaXMubG9nZ2VyLnRpbWU7XG4gICAgdCAhPT0gbnVsbCAmJiB0aGlzLm91dHB1dEZpbHRlciAmJiAodGhpcy5jdWVTdGFydFRpbWUgPT09IG51bGwgJiYgIXRoaXMuZGlzcGxheWVkTWVtb3J5LmlzRW1wdHkoKSA/IHRoaXMuY3VlU3RhcnRUaW1lID0gdCA6IHRoaXMuZGlzcGxheWVkTWVtb3J5LmVxdWFscyh0aGlzLmxhc3RPdXRwdXRTY3JlZW4pIHx8ICh0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIHQsIHRoaXMubGFzdE91dHB1dFNjcmVlbiksIGUgJiYgdGhpcy5vdXRwdXRGaWx0ZXIuZGlzcGF0Y2hDdWUgJiYgdGhpcy5vdXRwdXRGaWx0ZXIuZGlzcGF0Y2hDdWUoKSwgdGhpcy5jdWVTdGFydFRpbWUgPSB0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkgPyBudWxsIDogdCksIHRoaXMubGFzdE91dHB1dFNjcmVlbi5jb3B5KHRoaXMuZGlzcGxheWVkTWVtb3J5KSk7XG4gIH1cbiAgY3VlU3BsaXRBdFRpbWUoZSkge1xuICAgIHRoaXMub3V0cHV0RmlsdGVyICYmICh0aGlzLmRpc3BsYXllZE1lbW9yeS5pc0VtcHR5KCkgfHwgKHRoaXMub3V0cHV0RmlsdGVyLm5ld0N1ZSAmJiB0aGlzLm91dHB1dEZpbHRlci5uZXdDdWUodGhpcy5jdWVTdGFydFRpbWUsIGUsIHRoaXMuZGlzcGxheWVkTWVtb3J5KSwgdGhpcy5jdWVTdGFydFRpbWUgPSBlKSk7XG4gIH1cbn1cbmNsYXNzIHRmIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcikge1xuICAgIHRoaXMuY2hhbm5lbHMgPSB2b2lkIDAsIHRoaXMuY3VycmVudENoYW5uZWwgPSAwLCB0aGlzLmNtZEhpc3RvcnkgPSBQdygpLCB0aGlzLmxvZ2dlciA9IHZvaWQgMDtcbiAgICBjb25zdCBuID0gdGhpcy5sb2dnZXIgPSBuZXcgTHcoKTtcbiAgICB0aGlzLmNoYW5uZWxzID0gW251bGwsIG5ldyBlZihlLCB0LCBuKSwgbmV3IGVmKGUgKyAxLCByLCBuKV07XG4gIH1cbiAgZ2V0SGFuZGxlcihlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbZV0uZ2V0SGFuZGxlcigpO1xuICB9XG4gIHNldEhhbmRsZXIoZSwgdCkge1xuICAgIHRoaXMuY2hhbm5lbHNbZV0uc2V0SGFuZGxlcih0KTtcbiAgfVxuICAvKipcbiAgICogQWRkIGRhdGEgZm9yIHRpbWUgdCBpbiBmb3JtcyBvZiBsaXN0IG9mIGJ5dGVzICh1bnNpZ25lZCBpbnRzKS4gVGhlIGJ5dGVzIGFyZSB0cmVhdGVkIGFzIHBhaXJzLlxuICAgKi9cbiAgYWRkRGF0YShlLCB0KSB7XG4gICAgdGhpcy5sb2dnZXIudGltZSA9IGU7XG4gICAgZm9yIChsZXQgciA9IDA7IHIgPCB0Lmxlbmd0aDsgciArPSAyKSB7XG4gICAgICBjb25zdCBuID0gdFtyXSAmIDEyNywgaSA9IHRbciArIDFdICYgMTI3O1xuICAgICAgbGV0IG8gPSAhMSwgYSA9IG51bGw7XG4gICAgICBpZiAobiA9PT0gMCAmJiBpID09PSAwKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHRoaXMubG9nZ2VyLmxvZygzLCAoKSA9PiBcIltcIiArIE5zKFt0W3JdLCB0W3IgKyAxXV0pICsgXCJdIC0+IChcIiArIE5zKFtuLCBpXSkgKyBcIilcIik7XG4gICAgICBjb25zdCBsID0gdGhpcy5jbWRIaXN0b3J5O1xuICAgICAgaWYgKG4gPj0gMTYgJiYgbiA8PSAzMSkge1xuICAgICAgICBpZiAoRHcobiwgaSwgbCkpIHtcbiAgICAgICAgICBlbyhudWxsLCBudWxsLCBsKSwgdGhpcy5sb2dnZXIubG9nKDMsICgpID0+IFwiUmVwZWF0ZWQgY29tbWFuZCAoXCIgKyBOcyhbbiwgaV0pICsgXCIpIGlzIGRyb3BwZWRcIik7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZW8obiwgaSwgdGhpcy5jbWRIaXN0b3J5KSwgbyA9IHRoaXMucGFyc2VDbWQobiwgaSksIG8gfHwgKG8gPSB0aGlzLnBhcnNlTWlkcm93KG4sIGkpKSwgbyB8fCAobyA9IHRoaXMucGFyc2VQQUMobiwgaSkpLCBvIHx8IChvID0gdGhpcy5wYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzKG4sIGkpKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBlbyhudWxsLCBudWxsLCBsKTtcbiAgICAgIGlmICghbyAmJiAoYSA9IHRoaXMucGFyc2VDaGFycyhuLCBpKSwgYSkpIHtcbiAgICAgICAgY29uc3QgdSA9IHRoaXMuY3VycmVudENoYW5uZWw7XG4gICAgICAgIHUgJiYgdSA+IDAgPyB0aGlzLmNoYW5uZWxzW3VdLmluc2VydENoYXJzKGEpIDogdGhpcy5sb2dnZXIubG9nKDIsIFwiTm8gY2hhbm5lbCBmb3VuZCB5ZXQuIFRFWFQtTU9ERT9cIik7XG4gICAgICB9XG4gICAgICAhbyAmJiAhYSAmJiB0aGlzLmxvZ2dlci5sb2coMiwgKCkgPT4gXCJDb3VsZG4ndCBwYXJzZSBjbGVhbmVkIGRhdGEgXCIgKyBOcyhbbiwgaV0pICsgXCIgb3JpZzogXCIgKyBOcyhbdFtyXSwgdFtyICsgMV1dKSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBDb21tYW5kLlxuICAgKiBAcmV0dXJucyBUcnVlIGlmIGEgY29tbWFuZCB3YXMgZm91bmRcbiAgICovXG4gIHBhcnNlQ21kKGUsIHQpIHtcbiAgICBjb25zdCByID0gKGUgPT09IDIwIHx8IGUgPT09IDI4IHx8IGUgPT09IDIxIHx8IGUgPT09IDI5KSAmJiB0ID49IDMyICYmIHQgPD0gNDcsIG4gPSAoZSA9PT0gMjMgfHwgZSA9PT0gMzEpICYmIHQgPj0gMzMgJiYgdCA8PSAzNTtcbiAgICBpZiAoIShyIHx8IG4pKVxuICAgICAgcmV0dXJuICExO1xuICAgIGNvbnN0IGkgPSBlID09PSAyMCB8fCBlID09PSAyMSB8fCBlID09PSAyMyA/IDEgOiAyLCBvID0gdGhpcy5jaGFubmVsc1tpXTtcbiAgICByZXR1cm4gZSA9PT0gMjAgfHwgZSA9PT0gMjEgfHwgZSA9PT0gMjggfHwgZSA9PT0gMjkgPyB0ID09PSAzMiA/IG8uY2NSQ0woKSA6IHQgPT09IDMzID8gby5jY0JTKCkgOiB0ID09PSAzNCA/IG8uY2NBT0YoKSA6IHQgPT09IDM1ID8gby5jY0FPTigpIDogdCA9PT0gMzYgPyBvLmNjREVSKCkgOiB0ID09PSAzNyA/IG8uY2NSVSgyKSA6IHQgPT09IDM4ID8gby5jY1JVKDMpIDogdCA9PT0gMzkgPyBvLmNjUlUoNCkgOiB0ID09PSA0MCA/IG8uY2NGT04oKSA6IHQgPT09IDQxID8gby5jY1JEQygpIDogdCA9PT0gNDIgPyBvLmNjVFIoKSA6IHQgPT09IDQzID8gby5jY1JURCgpIDogdCA9PT0gNDQgPyBvLmNjRURNKCkgOiB0ID09PSA0NSA/IG8uY2NDUigpIDogdCA9PT0gNDYgPyBvLmNjRU5NKCkgOiB0ID09PSA0NyAmJiBvLmNjRU9DKCkgOiBvLmNjVE8odCAtIDMyKSwgdGhpcy5jdXJyZW50Q2hhbm5lbCA9IGksICEwO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBtaWRyb3cgc3R5bGluZyBjb21tYW5kXG4gICAqL1xuICBwYXJzZU1pZHJvdyhlLCB0KSB7XG4gICAgbGV0IHIgPSAwO1xuICAgIGlmICgoZSA9PT0gMTcgfHwgZSA9PT0gMjUpICYmIHQgPj0gMzIgJiYgdCA8PSA0Nykge1xuICAgICAgaWYgKGUgPT09IDE3ID8gciA9IDEgOiByID0gMiwgciAhPT0gdGhpcy5jdXJyZW50Q2hhbm5lbClcbiAgICAgICAgcmV0dXJuIHRoaXMubG9nZ2VyLmxvZygwLCBcIk1pc21hdGNoIGNoYW5uZWwgaW4gbWlkcm93IHBhcnNpbmdcIiksICExO1xuICAgICAgY29uc3QgbiA9IHRoaXMuY2hhbm5lbHNbcl07XG4gICAgICByZXR1cm4gbiA/IChuLmNjTUlEUk9XKHQpLCB0aGlzLmxvZ2dlci5sb2coMywgKCkgPT4gXCJNSURST1cgKFwiICsgTnMoW2UsIHRdKSArIFwiKVwiKSwgITApIDogITE7XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICAvKipcbiAgICogUGFyc2UgUHJlYWJsZSBBY2Nlc3MgQ29kZXMgKFRhYmxlIDUzKS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFRlbGxzIGlmIFBBQyBmb3VuZFxuICAgKi9cbiAgcGFyc2VQQUMoZSwgdCkge1xuICAgIGxldCByO1xuICAgIGNvbnN0IG4gPSAoZSA+PSAxNyAmJiBlIDw9IDIzIHx8IGUgPj0gMjUgJiYgZSA8PSAzMSkgJiYgdCA+PSA2NCAmJiB0IDw9IDEyNywgaSA9IChlID09PSAxNiB8fCBlID09PSAyNCkgJiYgdCA+PSA2NCAmJiB0IDw9IDk1O1xuICAgIGlmICghKG4gfHwgaSkpXG4gICAgICByZXR1cm4gITE7XG4gICAgY29uc3QgbyA9IGUgPD0gMjMgPyAxIDogMjtcbiAgICB0ID49IDY0ICYmIHQgPD0gOTUgPyByID0gbyA9PT0gMSA/IHd3W2VdIDogSXdbZV0gOiByID0gbyA9PT0gMSA/IEF3W2VdIDogX3dbZV07XG4gICAgY29uc3QgYSA9IHRoaXMuY2hhbm5lbHNbb107XG4gICAgcmV0dXJuIGEgPyAoYS5zZXRQQUModGhpcy5pbnRlcnByZXRQQUMociwgdCkpLCB0aGlzLmN1cnJlbnRDaGFubmVsID0gbywgITApIDogITE7XG4gIH1cbiAgLyoqXG4gICAqIEludGVycHJldCB0aGUgc2Vjb25kIGJ5dGUgb2YgdGhlIHBhYywgYW5kIHJldHVybiB0aGUgaW5mb3JtYXRpb24uXG4gICAqIEByZXR1cm5zIHBhY0RhdGEgd2l0aCBzdHlsZSBwYXJhbWV0ZXJzXG4gICAqL1xuICBpbnRlcnByZXRQQUMoZSwgdCkge1xuICAgIGxldCByO1xuICAgIGNvbnN0IG4gPSB7XG4gICAgICBjb2xvcjogbnVsbCxcbiAgICAgIGl0YWxpY3M6ICExLFxuICAgICAgaW5kZW50OiBudWxsLFxuICAgICAgdW5kZXJsaW5lOiAhMSxcbiAgICAgIHJvdzogZVxuICAgIH07XG4gICAgcmV0dXJuIHQgPiA5NSA/IHIgPSB0IC0gOTYgOiByID0gdCAtIDY0LCBuLnVuZGVybGluZSA9IChyICYgMSkgPT09IDEsIHIgPD0gMTMgPyBuLmNvbG9yID0gW1wid2hpdGVcIiwgXCJncmVlblwiLCBcImJsdWVcIiwgXCJjeWFuXCIsIFwicmVkXCIsIFwieWVsbG93XCIsIFwibWFnZW50YVwiLCBcIndoaXRlXCJdW01hdGguZmxvb3IociAvIDIpXSA6IHIgPD0gMTUgPyAobi5pdGFsaWNzID0gITAsIG4uY29sb3IgPSBcIndoaXRlXCIpIDogbi5pbmRlbnQgPSBNYXRoLmZsb29yKChyIC0gMTYpIC8gMikgKiA0LCBuO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBjaGFyYWN0ZXJzLlxuICAgKiBAcmV0dXJucyBBbiBhcnJheSB3aXRoIDEgdG8gMiBjb2RlcyBjb3JyZXNwb25kaW5nIHRvIGNoYXJzLCBpZiBmb3VuZC4gbnVsbCBvdGhlcndpc2UuXG4gICAqL1xuICBwYXJzZUNoYXJzKGUsIHQpIHtcbiAgICBsZXQgciwgbiA9IG51bGwsIGkgPSBudWxsO1xuICAgIGlmIChlID49IDI1ID8gKHIgPSAyLCBpID0gZSAtIDgpIDogKHIgPSAxLCBpID0gZSksIGkgPj0gMTcgJiYgaSA8PSAxOSkge1xuICAgICAgbGV0IG87XG4gICAgICBpID09PSAxNyA/IG8gPSB0ICsgODAgOiBpID09PSAxOCA/IG8gPSB0ICsgMTEyIDogbyA9IHQgKyAxNDQsIHRoaXMubG9nZ2VyLmxvZygyLCAoKSA9PiBcIlNwZWNpYWwgY2hhciAnXCIgKyBHcChvKSArIFwiJyBpbiBjaGFubmVsIFwiICsgciksIG4gPSBbb107XG4gICAgfSBlbHNlIGUgPj0gMzIgJiYgZSA8PSAxMjcgJiYgKG4gPSB0ID09PSAwID8gW2VdIDogW2UsIHRdKTtcbiAgICByZXR1cm4gbiAmJiB0aGlzLmxvZ2dlci5sb2coMywgKCkgPT4gXCJDaGFyIGNvZGVzID0gIFwiICsgTnMobikuam9pbihcIixcIikpLCBuO1xuICB9XG4gIC8qKlxuICAgKiBQYXJzZSBleHRlbmRlZCBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXMgd2VsbCBhcyBuZXcgZm9yZWdyb3VuZCBjb2xvciBibGFjay5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiBiYWNrZ3JvdW5kIGF0dHJpYnV0ZXMgYXJlIGZvdW5kXG4gICAqL1xuICBwYXJzZUJhY2tncm91bmRBdHRyaWJ1dGVzKGUsIHQpIHtcbiAgICBjb25zdCByID0gKGUgPT09IDE2IHx8IGUgPT09IDI0KSAmJiB0ID49IDMyICYmIHQgPD0gNDcsIG4gPSAoZSA9PT0gMjMgfHwgZSA9PT0gMzEpICYmIHQgPj0gNDUgJiYgdCA8PSA0NztcbiAgICBpZiAoIShyIHx8IG4pKVxuICAgICAgcmV0dXJuICExO1xuICAgIGxldCBpO1xuICAgIGNvbnN0IG8gPSB7fTtcbiAgICBlID09PSAxNiB8fCBlID09PSAyNCA/IChpID0gTWF0aC5mbG9vcigodCAtIDMyKSAvIDIpLCBvLmJhY2tncm91bmQgPSBSd1tpXSwgdCAlIDIgPT09IDEgJiYgKG8uYmFja2dyb3VuZCA9IG8uYmFja2dyb3VuZCArIFwiX3NlbWlcIikpIDogdCA9PT0gNDUgPyBvLmJhY2tncm91bmQgPSBcInRyYW5zcGFyZW50XCIgOiAoby5mb3JlZ3JvdW5kID0gXCJibGFja1wiLCB0ID09PSA0NyAmJiAoby51bmRlcmxpbmUgPSAhMCkpO1xuICAgIGNvbnN0IGEgPSBlIDw9IDIzID8gMSA6IDI7XG4gICAgcmV0dXJuIHRoaXMuY2hhbm5lbHNbYV0uc2V0QmtnRGF0YShvKSwgITA7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0IHN0YXRlIG9mIHBhcnNlciBhbmQgaXRzIGNoYW5uZWxzLlxuICAgKi9cbiAgcmVzZXQoKSB7XG4gICAgZm9yIChsZXQgZSA9IDA7IGUgPCBPYmplY3Qua2V5cyh0aGlzLmNoYW5uZWxzKS5sZW5ndGg7IGUrKykge1xuICAgICAgY29uc3QgdCA9IHRoaXMuY2hhbm5lbHNbZV07XG4gICAgICB0ICYmIHQucmVzZXQoKTtcbiAgICB9XG4gICAgZW8obnVsbCwgbnVsbCwgdGhpcy5jbWRIaXN0b3J5KTtcbiAgfVxuICAvKipcbiAgICogVHJpZ2dlciB0aGUgZ2VuZXJhdGlvbiBvZiBhIGN1ZSwgYW5kIHRoZSBzdGFydCBvZiBhIG5ldyBvbmUgaWYgZGlzcGxheVNjcmVlbnMgYXJlIG5vdCBlbXB0eS5cbiAgICovXG4gIGN1ZVNwbGl0QXRUaW1lKGUpIHtcbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyB0KyspIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLmNoYW5uZWxzW3RdO1xuICAgICAgciAmJiByLmN1ZVNwbGl0QXRUaW1lKGUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZW8ocywgZSwgdCkge1xuICB0LmEgPSBzLCB0LmIgPSBlO1xufVxuZnVuY3Rpb24gRHcocywgZSwgdCkge1xuICByZXR1cm4gdC5hID09PSBzICYmIHQuYiA9PT0gZTtcbn1cbmZ1bmN0aW9uIFB3KCkge1xuICByZXR1cm4ge1xuICAgIGE6IG51bGwsXG4gICAgYjogbnVsbFxuICB9O1xufVxudmFyIE91ID0gKGZ1bmN0aW9uKCkge1xuICBpZiAocmEgIT0gbnVsbCAmJiByYS5WVFRDdWUpXG4gICAgcmV0dXJuIHNlbGYuVlRUQ3VlO1xuICBjb25zdCBzID0gW1wiXCIsIFwibHJcIiwgXCJybFwiXSwgZSA9IFtcInN0YXJ0XCIsIFwibWlkZGxlXCIsIFwiZW5kXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdO1xuICBmdW5jdGlvbiB0KGEsIGwpIHtcbiAgICBpZiAodHlwZW9mIGwgIT0gXCJzdHJpbmdcIiB8fCAhQXJyYXkuaXNBcnJheShhKSlcbiAgICAgIHJldHVybiAhMTtcbiAgICBjb25zdCBjID0gbC50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiB+YS5pbmRleE9mKGMpID8gYyA6ICExO1xuICB9XG4gIGZ1bmN0aW9uIHIoYSkge1xuICAgIHJldHVybiB0KHMsIGEpO1xuICB9XG4gIGZ1bmN0aW9uIG4oYSkge1xuICAgIHJldHVybiB0KGUsIGEpO1xuICB9XG4gIGZ1bmN0aW9uIGkoYSwgLi4ubCkge1xuICAgIGxldCBjID0gMTtcbiAgICBmb3IgKDsgYyA8IGFyZ3VtZW50cy5sZW5ndGg7IGMrKykge1xuICAgICAgY29uc3QgdSA9IGFyZ3VtZW50c1tjXTtcbiAgICAgIGZvciAoY29uc3QgZCBpbiB1KVxuICAgICAgICBhW2RdID0gdVtkXTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG4gIH1cbiAgZnVuY3Rpb24gbyhhLCBsLCBjKSB7XG4gICAgY29uc3QgdSA9IHRoaXMsIGQgPSB7XG4gICAgICBlbnVtZXJhYmxlOiAhMFxuICAgIH07XG4gICAgdS5oYXNCZWVuUmVzZXQgPSAhMTtcbiAgICBsZXQgaCA9IFwiXCIsIGYgPSAhMSwgcCA9IGEsIHkgPSBsLCBFID0gYywgYiA9IG51bGwsIFIgPSBcIlwiLCBBID0gITAsIEYgPSBcImF1dG9cIiwgTSA9IFwic3RhcnRcIiwgSCA9IDUwLCBLID0gXCJtaWRkbGVcIiwgaiA9IDUwLCBDID0gXCJtaWRkbGVcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodSwgXCJpZFwiLCBpKHt9LCBkLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaDtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgaCA9IFwiXCIgKyBrO1xuICAgICAgfVxuICAgIH0pKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHUsIFwicGF1c2VPbkV4aXRcIiwgaSh7fSwgZCwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihrKSB7XG4gICAgICAgIGYgPSAhIWs7XG4gICAgICB9XG4gICAgfSkpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodSwgXCJzdGFydFRpbWVcIiwgaSh7fSwgZCwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgayAhPSBcIm51bWJlclwiKVxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdGFydCB0aW1lIG11c3QgYmUgc2V0IHRvIGEgbnVtYmVyLlwiKTtcbiAgICAgICAgcCA9IGssIHRoaXMuaGFzQmVlblJlc2V0ID0gITA7XG4gICAgICB9XG4gICAgfSkpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodSwgXCJlbmRUaW1lXCIsIGkoe30sIGQsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB5O1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oaykge1xuICAgICAgICBpZiAodHlwZW9mIGsgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRW5kIHRpbWUgbXVzdCBiZSBzZXQgdG8gYSBudW1iZXIuXCIpO1xuICAgICAgICB5ID0gaywgdGhpcy5oYXNCZWVuUmVzZXQgPSAhMDtcbiAgICAgIH1cbiAgICB9KSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LCBcInRleHRcIiwgaSh7fSwgZCwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEU7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihrKSB7XG4gICAgICAgIEUgPSBcIlwiICsgaywgdGhpcy5oYXNCZWVuUmVzZXQgPSAhMDtcbiAgICAgIH1cbiAgICB9KSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LCBcInJlZ2lvblwiLCBpKHt9LCBkLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgYiA9IGssIHRoaXMuaGFzQmVlblJlc2V0ID0gITA7XG4gICAgICB9XG4gICAgfSkpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodSwgXCJ2ZXJ0aWNhbFwiLCBpKHt9LCBkLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gUjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgY29uc3QgJCA9IHIoayk7XG4gICAgICAgIGlmICgkID09PSAhMSlcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJBbiBpbnZhbGlkIG9yIGlsbGVnYWwgc3RyaW5nIHdhcyBzcGVjaWZpZWQuXCIpO1xuICAgICAgICBSID0gJCwgdGhpcy5oYXNCZWVuUmVzZXQgPSAhMDtcbiAgICAgIH1cbiAgICB9KSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LCBcInNuYXBUb0xpbmVzXCIsIGkoe30sIGQsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oaykge1xuICAgICAgICBBID0gISFrLCB0aGlzLmhhc0JlZW5SZXNldCA9ICEwO1xuICAgICAgfVxuICAgIH0pKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHUsIFwibGluZVwiLCBpKHt9LCBkLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gRjtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKGspIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrICE9IFwibnVtYmVyXCIgJiYgayAhPT0gXCJhdXRvXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBudW1iZXIgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC5cIik7XG4gICAgICAgIEYgPSBrLCB0aGlzLmhhc0JlZW5SZXNldCA9ICEwO1xuICAgICAgfVxuICAgIH0pKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHUsIFwibGluZUFsaWduXCIsIGkoe30sIGQsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oaykge1xuICAgICAgICBjb25zdCAkID0gbihrKTtcbiAgICAgICAgaWYgKCEkKVxuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC5cIik7XG4gICAgICAgIE0gPSAkLCB0aGlzLmhhc0JlZW5SZXNldCA9ICEwO1xuICAgICAgfVxuICAgIH0pKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHUsIFwicG9zaXRpb25cIiwgaSh7fSwgZCwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEg7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihrKSB7XG4gICAgICAgIGlmIChrIDwgMCB8fCBrID4gMTAwKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBvc2l0aW9uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xuICAgICAgICBIID0gaywgdGhpcy5oYXNCZWVuUmVzZXQgPSAhMDtcbiAgICAgIH1cbiAgICB9KSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LCBcInBvc2l0aW9uQWxpZ25cIiwgaSh7fSwgZCwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEs7XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbihrKSB7XG4gICAgICAgIGNvbnN0ICQgPSBuKGspO1xuICAgICAgICBpZiAoISQpXG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiQW4gaW52YWxpZCBvciBpbGxlZ2FsIHN0cmluZyB3YXMgc3BlY2lmaWVkLlwiKTtcbiAgICAgICAgSyA9ICQsIHRoaXMuaGFzQmVlblJlc2V0ID0gITA7XG4gICAgICB9XG4gICAgfSkpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodSwgXCJzaXplXCIsIGkoe30sIGQsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBqO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oaykge1xuICAgICAgICBpZiAoayA8IDAgfHwgayA+IDEwMClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaXplIG11c3QgYmUgYmV0d2VlbiAwIGFuZCAxMDAuXCIpO1xuICAgICAgICBqID0gaywgdGhpcy5oYXNCZWVuUmVzZXQgPSAhMDtcbiAgICAgIH1cbiAgICB9KSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh1LCBcImFsaWduXCIsIGkoe30sIGQsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBDO1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24oaykge1xuICAgICAgICBjb25zdCAkID0gbihrKTtcbiAgICAgICAgaWYgKCEkKVxuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIkFuIGludmFsaWQgb3IgaWxsZWdhbCBzdHJpbmcgd2FzIHNwZWNpZmllZC5cIik7XG4gICAgICAgIEMgPSAkLCB0aGlzLmhhc0JlZW5SZXNldCA9ICEwO1xuICAgICAgfVxuICAgIH0pKSwgdS5kaXNwbGF5U3RhdGUgPSB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIG8ucHJvdG90eXBlLmdldEN1ZUFzSFRNTCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBzZWxmLldlYlZUVC5jb252ZXJ0Q3VlVG9ET01UcmVlKHNlbGYsIHRoaXMudGV4dCk7XG4gIH0sIG87XG59KSgpO1xuY2xhc3MgTXcge1xuICBkZWNvZGUoZSwgdCkge1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIGlmICh0eXBlb2YgZSAhPSBcInN0cmluZ1wiKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgLSBleHBlY3RlZCBzdHJpbmcgZGF0YS5cIik7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlbmNvZGVVUklDb21wb25lbnQoZSkpO1xuICB9XG59XG5mdW5jdGlvbiBqcChzKSB7XG4gIGZ1bmN0aW9uIGUociwgbiwgaSwgbykge1xuICAgIHJldHVybiAociB8IDApICogMzYwMCArIChuIHwgMCkgKiA2MCArIChpIHwgMCkgKyBwYXJzZUZsb2F0KG8gfHwgMCk7XG4gIH1cbiAgY29uc3QgdCA9IHMubWF0Y2goL14oPzooXFxkKyk6KT8oXFxkezJ9KTooXFxkezJ9KShcXC5cXGQrKT8vKTtcbiAgcmV0dXJuIHQgPyBwYXJzZUZsb2F0KHRbMl0pID4gNTkgPyBlKHRbMl0sIHRbM10sIDAsIHRbNF0pIDogZSh0WzFdLCB0WzJdLCB0WzNdLCB0WzRdKSA6IG51bGw7XG59XG5jbGFzcyBPdyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudmFsdWVzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgLy8gT25seSBhY2NlcHQgdGhlIGZpcnN0IGFzc2lnbm1lbnQgdG8gYW55IGtleS5cbiAgc2V0KGUsIHQpIHtcbiAgICAhdGhpcy5nZXQoZSkgJiYgdCAhPT0gXCJcIiAmJiAodGhpcy52YWx1ZXNbZV0gPSB0KTtcbiAgfVxuICAvLyBSZXR1cm4gdGhlIHZhbHVlIGZvciBhIGtleSwgb3IgYSBkZWZhdWx0IHZhbHVlLlxuICAvLyBJZiAnZGVmYXVsdEtleScgaXMgcGFzc2VkIHRoZW4gJ2RmbHQnIGlzIGFzc3VtZWQgdG8gYmUgYW4gb2JqZWN0IHdpdGhcbiAgLy8gYSBudW1iZXIgb2YgcG9zc2libGUgZGVmYXVsdCB2YWx1ZXMgYXMgcHJvcGVydGllcyB3aGVyZSAnZGVmYXVsdEtleScgaXNcbiAgLy8gdGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdGhhdCB3aWxsIGJlIGNob3Nlbjsgb3RoZXJ3aXNlIGl0J3MgYXNzdW1lZCB0byBiZVxuICAvLyBhIHNpbmdsZSB2YWx1ZS5cbiAgZ2V0KGUsIHQsIHIpIHtcbiAgICByZXR1cm4gciA/IHRoaXMuaGFzKGUpID8gdGhpcy52YWx1ZXNbZV0gOiB0W3JdIDogdGhpcy5oYXMoZSkgPyB0aGlzLnZhbHVlc1tlXSA6IHQ7XG4gIH1cbiAgLy8gQ2hlY2sgd2hldGhlciB3ZSBoYXZlIGEgdmFsdWUgZm9yIGEga2V5LlxuICBoYXMoZSkge1xuICAgIHJldHVybiBlIGluIHRoaXMudmFsdWVzO1xuICB9XG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIG9uZSBvZiB0aGUgZ2l2ZW4gYWx0ZXJuYXRpdmVzLlxuICBhbHQoZSwgdCwgcikge1xuICAgIGZvciAobGV0IG4gPSAwOyBuIDwgci5sZW5ndGg7ICsrbilcbiAgICAgIGlmICh0ID09PSByW25dKSB7XG4gICAgICAgIHRoaXMuc2V0KGUsIHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuICAvLyBBY2NlcHQgYSBzZXR0aW5nIGlmIGl0cyBhIHZhbGlkIChzaWduZWQpIGludGVnZXIuXG4gIGludGVnZXIoZSwgdCkge1xuICAgIC9eLT9cXGQrJC8udGVzdCh0KSAmJiB0aGlzLnNldChlLCBwYXJzZUludCh0LCAxMCkpO1xuICB9XG4gIC8vIEFjY2VwdCBhIHNldHRpbmcgaWYgaXRzIGEgdmFsaWQgcGVyY2VudGFnZS5cbiAgcGVyY2VudChlLCB0KSB7XG4gICAgaWYgKC9eKFtcXGRdezEsM30pKFxcLltcXGRdKik/JSQvLnRlc3QodCkpIHtcbiAgICAgIGNvbnN0IHIgPSBwYXJzZUZsb2F0KHQpO1xuICAgICAgaWYgKHIgPj0gMCAmJiByIDw9IDEwMClcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0KGUsIHIpLCAhMDtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG59XG5mdW5jdGlvbiBLcChzLCBlLCB0LCByKSB7XG4gIGNvbnN0IG4gPSByID8gcy5zcGxpdChyKSA6IFtzXTtcbiAgZm9yIChjb25zdCBpIGluIG4pIHtcbiAgICBpZiAodHlwZW9mIG5baV0gIT0gXCJzdHJpbmdcIilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IG8gPSBuW2ldLnNwbGl0KHQpO1xuICAgIGlmIChvLmxlbmd0aCAhPT0gMilcbiAgICAgIGNvbnRpbnVlO1xuICAgIGNvbnN0IGEgPSBvWzBdLCBsID0gb1sxXTtcbiAgICBlKGEsIGwpO1xuICB9XG59XG5jb25zdCBiYyA9IG5ldyBPdSgwLCAwLCBcIlwiKSwgdG8gPSBiYy5hbGlnbiA9PT0gXCJtaWRkbGVcIiA/IFwibWlkZGxlXCIgOiBcImNlbnRlclwiO1xuZnVuY3Rpb24gQncocywgZSwgdCkge1xuICBjb25zdCByID0gcztcbiAgZnVuY3Rpb24gbigpIHtcbiAgICBjb25zdCBhID0ganAocyk7XG4gICAgaWYgKGEgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgdGltZXN0YW1wOiBcIiArIHIpO1xuICAgIHJldHVybiBzID0gcy5yZXBsYWNlKC9eW15cXHNhLXpBLVotXSsvLCBcIlwiKSwgYTtcbiAgfVxuICBmdW5jdGlvbiBpKGEsIGwpIHtcbiAgICBjb25zdCBjID0gbmV3IE93KCk7XG4gICAgS3AoYSwgZnVuY3Rpb24oaCwgZikge1xuICAgICAgbGV0IHA7XG4gICAgICBzd2l0Y2ggKGgpIHtcbiAgICAgICAgY2FzZSBcInJlZ2lvblwiOlxuICAgICAgICAgIGZvciAobGV0IHkgPSB0Lmxlbmd0aCAtIDE7IHkgPj0gMDsgeS0tKVxuICAgICAgICAgICAgaWYgKHRbeV0uaWQgPT09IGYpIHtcbiAgICAgICAgICAgICAgYy5zZXQoaCwgdFt5XS5yZWdpb24pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInZlcnRpY2FsXCI6XG4gICAgICAgICAgYy5hbHQoaCwgZiwgW1wicmxcIiwgXCJsclwiXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsaW5lXCI6XG4gICAgICAgICAgcCA9IGYuc3BsaXQoXCIsXCIpLCBjLmludGVnZXIoaCwgcFswXSksIGMucGVyY2VudChoLCBwWzBdKSAmJiBjLnNldChcInNuYXBUb0xpbmVzXCIsICExKSwgYy5hbHQoaCwgcFswXSwgW1wiYXV0b1wiXSksIHAubGVuZ3RoID09PSAyICYmIGMuYWx0KFwibGluZUFsaWduXCIsIHBbMV0sIFtcInN0YXJ0XCIsIHRvLCBcImVuZFwiXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJwb3NpdGlvblwiOlxuICAgICAgICAgIHAgPSBmLnNwbGl0KFwiLFwiKSwgYy5wZXJjZW50KGgsIHBbMF0pLCBwLmxlbmd0aCA9PT0gMiAmJiBjLmFsdChcInBvc2l0aW9uQWxpZ25cIiwgcFsxXSwgW1wic3RhcnRcIiwgdG8sIFwiZW5kXCIsIFwibGluZS1sZWZ0XCIsIFwibGluZS1yaWdodFwiLCBcImF1dG9cIl0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2l6ZVwiOlxuICAgICAgICAgIGMucGVyY2VudChoLCBmKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImFsaWduXCI6XG4gICAgICAgICAgYy5hbHQoaCwgZiwgW1wic3RhcnRcIiwgdG8sIFwiZW5kXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LCAvOi8sIC9cXHMvKSwgbC5yZWdpb24gPSBjLmdldChcInJlZ2lvblwiLCBudWxsKSwgbC52ZXJ0aWNhbCA9IGMuZ2V0KFwidmVydGljYWxcIiwgXCJcIik7XG4gICAgbGV0IHUgPSBjLmdldChcImxpbmVcIiwgXCJhdXRvXCIpO1xuICAgIHUgPT09IFwiYXV0b1wiICYmIGJjLmxpbmUgPT09IC0xICYmICh1ID0gLTEpLCBsLmxpbmUgPSB1LCBsLmxpbmVBbGlnbiA9IGMuZ2V0KFwibGluZUFsaWduXCIsIFwic3RhcnRcIiksIGwuc25hcFRvTGluZXMgPSBjLmdldChcInNuYXBUb0xpbmVzXCIsICEwKSwgbC5zaXplID0gYy5nZXQoXCJzaXplXCIsIDEwMCksIGwuYWxpZ24gPSBjLmdldChcImFsaWduXCIsIHRvKTtcbiAgICBsZXQgZCA9IGMuZ2V0KFwicG9zaXRpb25cIiwgXCJhdXRvXCIpO1xuICAgIGQgPT09IFwiYXV0b1wiICYmIGJjLnBvc2l0aW9uID09PSA1MCAmJiAoZCA9IGwuYWxpZ24gPT09IFwic3RhcnRcIiB8fCBsLmFsaWduID09PSBcImxlZnRcIiA/IDAgOiBsLmFsaWduID09PSBcImVuZFwiIHx8IGwuYWxpZ24gPT09IFwicmlnaHRcIiA/IDEwMCA6IDUwKSwgbC5wb3NpdGlvbiA9IGQ7XG4gIH1cbiAgZnVuY3Rpb24gbygpIHtcbiAgICBzID0gcy5yZXBsYWNlKC9eXFxzKy8sIFwiXCIpO1xuICB9XG4gIGlmIChvKCksIGUuc3RhcnRUaW1lID0gbigpLCBvKCksIHMuc2xpY2UoMCwgMykgIT09IFwiLS0+XCIpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWFsZm9ybWVkIHRpbWUgc3RhbXAgKHRpbWUgc3RhbXBzIG11c3QgYmUgc2VwYXJhdGVkIGJ5ICctLT4nKTogXCIgKyByKTtcbiAgcyA9IHMuc2xpY2UoMyksIG8oKSwgZS5lbmRUaW1lID0gbigpLCBvKCksIGkocywgZSk7XG59XG5mdW5jdGlvbiBIcChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoLzxicig/OiBcXC8pPz4vZ2ksIGBcbmApO1xufVxuY2xhc3MgRncge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnN0YXRlID0gXCJJTklUSUFMXCIsIHRoaXMuYnVmZmVyID0gXCJcIiwgdGhpcy5kZWNvZGVyID0gbmV3IE13KCksIHRoaXMucmVnaW9uTGlzdCA9IFtdLCB0aGlzLmN1ZSA9IG51bGwsIHRoaXMub25jdWUgPSB2b2lkIDAsIHRoaXMub25wYXJzaW5nZXJyb3IgPSB2b2lkIDAsIHRoaXMub25mbHVzaCA9IHZvaWQgMDtcbiAgfVxuICBwYXJzZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXM7XG4gICAgZSAmJiAodC5idWZmZXIgKz0gdC5kZWNvZGVyLmRlY29kZShlLCB7XG4gICAgICBzdHJlYW06ICEwXG4gICAgfSkpO1xuICAgIGZ1bmN0aW9uIHIoKSB7XG4gICAgICBsZXQgaSA9IHQuYnVmZmVyLCBvID0gMDtcbiAgICAgIGZvciAoaSA9IEhwKGkpOyBvIDwgaS5sZW5ndGggJiYgaVtvXSAhPT0gXCJcXHJcIiAmJiBpW29dICE9PSBgXG5gOyApXG4gICAgICAgICsrbztcbiAgICAgIGNvbnN0IGEgPSBpLnNsaWNlKDAsIG8pO1xuICAgICAgcmV0dXJuIGlbb10gPT09IFwiXFxyXCIgJiYgKytvLCBpW29dID09PSBgXG5gICYmICsrbywgdC5idWZmZXIgPSBpLnNsaWNlKG8pLCBhO1xuICAgIH1cbiAgICBmdW5jdGlvbiBuKGkpIHtcbiAgICAgIEtwKGksIGZ1bmN0aW9uKG8sIGEpIHtcbiAgICAgIH0sIC86Lyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsZXQgaSA9IFwiXCI7XG4gICAgICBpZiAodC5zdGF0ZSA9PT0gXCJJTklUSUFMXCIpIHtcbiAgICAgICAgaWYgKCEvXFxyXFxufFxcbi8udGVzdCh0LmJ1ZmZlcikpXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGkgPSByKCk7XG4gICAgICAgIGNvbnN0IGEgPSBpLm1hdGNoKC9eKMOvwrvCvyk/V0VCVlRUKFsgXFx0XS4qKT8kLyk7XG4gICAgICAgIGlmICghKGEgIT0gbnVsbCAmJiBhWzBdKSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgV2ViVlRUIHNpZ25hdHVyZS5cIik7XG4gICAgICAgIHQuc3RhdGUgPSBcIkhFQURFUlwiO1xuICAgICAgfVxuICAgICAgbGV0IG8gPSAhMTtcbiAgICAgIGZvciAoOyB0LmJ1ZmZlcjsgKSB7XG4gICAgICAgIGlmICghL1xcclxcbnxcXG4vLnRlc3QodC5idWZmZXIpKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBzd2l0Y2ggKG8gPyBvID0gITEgOiBpID0gcigpLCB0LnN0YXRlKSB7XG4gICAgICAgICAgY2FzZSBcIkhFQURFUlwiOlxuICAgICAgICAgICAgLzovLnRlc3QoaSkgPyBuKGkpIDogaSB8fCAodC5zdGF0ZSA9IFwiSURcIik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFwiTk9URVwiOlxuICAgICAgICAgICAgaSB8fCAodC5zdGF0ZSA9IFwiSURcIik7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjYXNlIFwiSURcIjpcbiAgICAgICAgICAgIGlmICgvXk5PVEUoJHxbIFxcdF0pLy50ZXN0KGkpKSB7XG4gICAgICAgICAgICAgIHQuc3RhdGUgPSBcIk5PVEVcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWkpXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHQuY3VlID0gbmV3IE91KDAsIDAsIFwiXCIpLCB0LnN0YXRlID0gXCJDVUVcIiwgaS5pbmRleE9mKFwiLS0+XCIpID09PSAtMSkge1xuICAgICAgICAgICAgICB0LmN1ZS5pZCA9IGk7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIFByb2Nlc3MgbGluZSBhcyBzdGFydCBvZiBhIGN1ZS5cbiAgICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICAgICAgY2FzZSBcIkNVRVwiOlxuICAgICAgICAgICAgaWYgKCF0LmN1ZSkge1xuICAgICAgICAgICAgICB0LnN0YXRlID0gXCJCQURDVUVcIjtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBCdyhpLCB0LmN1ZSwgdC5yZWdpb25MaXN0KTtcbiAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICB0LmN1ZSA9IG51bGwsIHQuc3RhdGUgPSBcIkJBRENVRVwiO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQuc3RhdGUgPSBcIkNVRVRFWFRcIjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgXCJDVUVURVhUXCI6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IGEgPSBpLmluZGV4T2YoXCItLT5cIikgIT09IC0xO1xuICAgICAgICAgICAgICBpZiAoIWkgfHwgYSAmJiAobyA9ICEwKSkge1xuICAgICAgICAgICAgICAgIHQub25jdWUgJiYgdC5jdWUgJiYgdC5vbmN1ZSh0LmN1ZSksIHQuY3VlID0gbnVsbCwgdC5zdGF0ZSA9IFwiSURcIjtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodC5jdWUgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIHQuY3VlLnRleHQgJiYgKHQuY3VlLnRleHQgKz0gYFxuYCksIHQuY3VlLnRleHQgKz0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIGNhc2UgXCJCQURDVUVcIjpcbiAgICAgICAgICAgIGkgfHwgKHQuc3RhdGUgPSBcIklEXCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICB0LnN0YXRlID09PSBcIkNVRVRFWFRcIiAmJiB0LmN1ZSAmJiB0Lm9uY3VlICYmIHQub25jdWUodC5jdWUpLCB0LmN1ZSA9IG51bGwsIHQuc3RhdGUgPSB0LnN0YXRlID09PSBcIklOSVRJQUxcIiA/IFwiQkFEV0VCVlRUXCIgOiBcIkJBRENVRVwiO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBmbHVzaCgpIHtcbiAgICBjb25zdCBlID0gdGhpcztcbiAgICB0cnkge1xuICAgICAgaWYgKChlLmN1ZSB8fCBlLnN0YXRlID09PSBcIkhFQURFUlwiKSAmJiAoZS5idWZmZXIgKz0gYFxuXG5gLCBlLnBhcnNlKCkpLCBlLnN0YXRlID09PSBcIklOSVRJQUxcIiB8fCBlLnN0YXRlID09PSBcIkJBRFdFQlZUVFwiKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgV2ViVlRUIHNpZ25hdHVyZS5cIik7XG4gICAgfSBjYXRjaCAodCkge1xuICAgICAgZS5vbnBhcnNpbmdlcnJvciAmJiBlLm9ucGFyc2luZ2Vycm9yKHQpO1xuICAgIH1cbiAgICByZXR1cm4gZS5vbmZsdXNoICYmIGUub25mbHVzaCgpLCB0aGlzO1xuICB9XG59XG5jb25zdCBOdyA9IC9cXHJcXG58XFxuXFxyfFxcbnxcXHIvZywgQWwgPSBmdW5jdGlvbihlLCB0LCByID0gMCkge1xuICByZXR1cm4gZS5zbGljZShyLCByICsgdC5sZW5ndGgpID09PSB0O1xufSwgVXcgPSBmdW5jdGlvbihlKSB7XG4gIGxldCB0ID0gcGFyc2VJbnQoZS5zbGljZSgtMykpO1xuICBjb25zdCByID0gcGFyc2VJbnQoZS5zbGljZSgtNiwgLTQpKSwgbiA9IHBhcnNlSW50KGUuc2xpY2UoLTksIC03KSksIGkgPSBlLmxlbmd0aCA+IDkgPyBwYXJzZUludChlLnN1YnN0cmluZygwLCBlLmluZGV4T2YoXCI6XCIpKSkgOiAwO1xuICBpZiAoIXVlKHQpIHx8ICF1ZShyKSB8fCAhdWUobikgfHwgIXVlKGkpKVxuICAgIHRocm93IEVycm9yKGBNYWxmb3JtZWQgWC1USU1FU1RBTVAtTUFQOiBMb2NhbDoke2V9YCk7XG4gIHJldHVybiB0ICs9IDFlMyAqIHIsIHQgKz0gNjAgKiAxZTMgKiBuLCB0ICs9IDM2MDAgKiAxZTMgKiBpLCB0O1xufTtcbmZ1bmN0aW9uIEJ1KHMsIGUsIHQpIHtcbiAgcmV0dXJuIFhuKHMudG9TdHJpbmcoKSkgKyBYbihlLnRvU3RyaW5nKCkpICsgWG4odCk7XG59XG5jb25zdCAkdyA9IGZ1bmN0aW9uKGUsIHQsIHIpIHtcbiAgbGV0IG4gPSBlW3RdLCBpID0gZVtuLnByZXZDQ107XG4gIGlmICghaSB8fCAhaS5uZXcgJiYgbi5uZXcpIHtcbiAgICBlLmNjT2Zmc2V0ID0gZS5wcmVzZW50YXRpb25PZmZzZXQgPSBuLnN0YXJ0LCBuLm5ldyA9ICExO1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKDsgKG8gPSBpKSAhPSBudWxsICYmIG8ubmV3OyApIHtcbiAgICB2YXIgbztcbiAgICBlLmNjT2Zmc2V0ICs9IG4uc3RhcnQgLSBpLnN0YXJ0LCBuLm5ldyA9ICExLCBuID0gaSwgaSA9IGVbbi5wcmV2Q0NdO1xuICB9XG4gIGUucHJlc2VudGF0aW9uT2Zmc2V0ID0gcjtcbn07XG5mdW5jdGlvbiBHdyhzLCBlLCB0LCByLCBuLCBpLCBvKSB7XG4gIGNvbnN0IGEgPSBuZXcgRncoKSwgbCA9IFRyKG5ldyBVaW50OEFycmF5KHMpKS50cmltKCkucmVwbGFjZShOdywgYFxuYCkuc3BsaXQoYFxuYCksIGMgPSBbXSwgdSA9IGUgPyBXVChlLmJhc2VUaW1lLCBlLnRpbWVzY2FsZSkgOiAwO1xuICBsZXQgZCA9IFwiMDA6MDAuMDAwXCIsIGggPSAwLCBmID0gMCwgcCwgeSA9ICEwO1xuICBhLm9uY3VlID0gZnVuY3Rpb24oRSkge1xuICAgIGNvbnN0IGIgPSB0W3JdO1xuICAgIGxldCBSID0gdC5jY09mZnNldDtcbiAgICBjb25zdCBBID0gKGggLSB1KSAvIDllNDtcbiAgICBpZiAoYiAhPSBudWxsICYmIGIubmV3ICYmIChmICE9PSB2b2lkIDAgPyBSID0gdC5jY09mZnNldCA9IGIuc3RhcnQgOiAkdyh0LCByLCBBKSksIEEpIHtcbiAgICAgIGlmICghZSkge1xuICAgICAgICBwID0gbmV3IEVycm9yKFwiTWlzc2luZyBpbml0UFRTIGZvciBWVFQgTVBFR1RTXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBSID0gQSAtIHQucHJlc2VudGF0aW9uT2Zmc2V0O1xuICAgIH1cbiAgICBjb25zdCBGID0gRS5lbmRUaW1lIC0gRS5zdGFydFRpbWUsIE0gPSBBcigoRS5zdGFydFRpbWUgKyBSIC0gZikgKiA5ZTQsIG4gKiA5ZTQpIC8gOWU0O1xuICAgIEUuc3RhcnRUaW1lID0gTWF0aC5tYXgoTSwgMCksIEUuZW5kVGltZSA9IE1hdGgubWF4KE0gKyBGLCAwKTtcbiAgICBjb25zdCBIID0gRS50ZXh0LnRyaW0oKTtcbiAgICBFLnRleHQgPSBkZWNvZGVVUklDb21wb25lbnQoZW5jb2RlVVJJQ29tcG9uZW50KEgpKSwgRS5pZCB8fCAoRS5pZCA9IEJ1KEUuc3RhcnRUaW1lLCBFLmVuZFRpbWUsIEgpKSwgRS5lbmRUaW1lID4gMCAmJiBjLnB1c2goRSk7XG4gIH0sIGEub25wYXJzaW5nZXJyb3IgPSBmdW5jdGlvbihFKSB7XG4gICAgcCA9IEU7XG4gIH0sIGEub25mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChwKSB7XG4gICAgICBvKHApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpKGMpO1xuICB9LCBsLmZvckVhY2goKEUpID0+IHtcbiAgICBpZiAoeSlcbiAgICAgIGlmIChBbChFLCBcIlgtVElNRVNUQU1QLU1BUD1cIikpIHtcbiAgICAgICAgeSA9ICExLCBFLnNsaWNlKDE2KS5zcGxpdChcIixcIikuZm9yRWFjaCgoYikgPT4ge1xuICAgICAgICAgIEFsKGIsIFwiTE9DQUw6XCIpID8gZCA9IGIuc2xpY2UoNikgOiBBbChiLCBcIk1QRUdUUzpcIikgJiYgKGggPSBwYXJzZUludChiLnNsaWNlKDcpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGYgPSBVdyhkKSAvIDFlMztcbiAgICAgICAgfSBjYXRjaCAoYikge1xuICAgICAgICAgIHAgPSBiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBFID09PSBcIlwiICYmICh5ID0gITEpO1xuICAgIGEucGFyc2UoRSArIGBcbmApO1xuICB9KSwgYS5mbHVzaCgpO1xufVxuY29uc3QgSWwgPSBcInN0cHAudHRtbC5pbTF0XCIsIHFwID0gL14oXFxkezIsfSk6KFxcZHsyfSk6KFxcZHsyfSk6KFxcZHsyfSlcXC4/KFxcZCspPyQvLCBXcCA9IC9eKFxcZCooPzpcXC5cXGQqKT8pKGh8bXxzfG1zfGZ8dCkkLywgVncgPSB7XG4gIGxlZnQ6IFwic3RhcnRcIixcbiAgY2VudGVyOiBcImNlbnRlclwiLFxuICByaWdodDogXCJlbmRcIixcbiAgc3RhcnQ6IFwic3RhcnRcIixcbiAgZW5kOiBcImVuZFwiXG59O1xuZnVuY3Rpb24gcmYocywgZSwgdCwgcikge1xuICBjb25zdCBuID0gR2UobmV3IFVpbnQ4QXJyYXkocyksIFtcIm1kYXRcIl0pO1xuICBpZiAobi5sZW5ndGggPT09IDApIHtcbiAgICByKG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSBJTVNDMSBtZGF0XCIpKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgaSA9IG4ubWFwKChhKSA9PiBUcihhKSksIG8gPSBxVChlLmJhc2VUaW1lLCAxLCBlLnRpbWVzY2FsZSk7XG4gIHRyeSB7XG4gICAgaS5mb3JFYWNoKChhKSA9PiB0KGp3KGEsIG8pKSk7XG4gIH0gY2F0Y2ggKGEpIHtcbiAgICByKGEpO1xuICB9XG59XG5mdW5jdGlvbiBqdyhzLCBlKSB7XG4gIGNvbnN0IG4gPSBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKHMsIFwidGV4dC94bWxcIikuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJ0dFwiKVswXTtcbiAgaWYgKCFuKVxuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdHRtbFwiKTtcbiAgY29uc3QgaSA9IHtcbiAgICBmcmFtZVJhdGU6IDMwLFxuICAgIHN1YkZyYW1lUmF0ZTogMSxcbiAgICBmcmFtZVJhdGVNdWx0aXBsaWVyOiAwLFxuICAgIHRpY2tSYXRlOiAwXG4gIH0sIG8gPSBPYmplY3Qua2V5cyhpKS5yZWR1Y2UoKGQsIGgpID0+IChkW2hdID0gbi5nZXRBdHRyaWJ1dGUoYHR0cDoke2h9YCkgfHwgaVtoXSwgZCksIHt9KSwgYSA9IG4uZ2V0QXR0cmlidXRlKFwieG1sOnNwYWNlXCIpICE9PSBcInByZXNlcnZlXCIsIGwgPSBzZihfbChuLCBcInN0eWxpbmdcIiwgXCJzdHlsZVwiKSksIGMgPSBzZihfbChuLCBcImxheW91dFwiLCBcInJlZ2lvblwiKSksIHUgPSBfbChuLCBcImJvZHlcIiwgXCJbYmVnaW5dXCIpO1xuICByZXR1cm4gW10ubWFwLmNhbGwodSwgKGQpID0+IHtcbiAgICBjb25zdCBoID0genAoZCwgYSk7XG4gICAgaWYgKCFoIHx8ICFkLmhhc0F0dHJpYnV0ZShcImJlZ2luXCIpKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgZiA9IExsKGQuZ2V0QXR0cmlidXRlKFwiYmVnaW5cIiksIG8pLCBwID0gTGwoZC5nZXRBdHRyaWJ1dGUoXCJkdXJcIiksIG8pO1xuICAgIGxldCB5ID0gTGwoZC5nZXRBdHRyaWJ1dGUoXCJlbmRcIiksIG8pO1xuICAgIGlmIChmID09PSBudWxsKVxuICAgICAgdGhyb3cgbmYoZCk7XG4gICAgaWYgKHkgPT09IG51bGwpIHtcbiAgICAgIGlmIChwID09PSBudWxsKVxuICAgICAgICB0aHJvdyBuZihkKTtcbiAgICAgIHkgPSBmICsgcDtcbiAgICB9XG4gICAgY29uc3QgRSA9IG5ldyBPdShmIC0gZSwgeSAtIGUsIGgpO1xuICAgIEUuaWQgPSBCdShFLnN0YXJ0VGltZSwgRS5lbmRUaW1lLCBFLnRleHQpO1xuICAgIGNvbnN0IGIgPSBjW2QuZ2V0QXR0cmlidXRlKFwicmVnaW9uXCIpXSwgUiA9IGxbZC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKV0sIEEgPSBLdyhiLCBSLCBsKSwge1xuICAgICAgdGV4dEFsaWduOiBGXG4gICAgfSA9IEE7XG4gICAgaWYgKEYpIHtcbiAgICAgIGNvbnN0IE0gPSBWd1tGXTtcbiAgICAgIE0gJiYgKEUubGluZUFsaWduID0gTSksIEUuYWxpZ24gPSBGO1xuICAgIH1cbiAgICByZXR1cm4gbnQoRSwgQSksIEU7XG4gIH0pLmZpbHRlcigoZCkgPT4gZCAhPT0gbnVsbCk7XG59XG5mdW5jdGlvbiBfbChzLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSBzLmdldEVsZW1lbnRzQnlUYWdOYW1lKGUpWzBdO1xuICByZXR1cm4gciA/IFtdLnNsaWNlLmNhbGwoci5xdWVyeVNlbGVjdG9yQWxsKHQpKSA6IFtdO1xufVxuZnVuY3Rpb24gc2Yocykge1xuICByZXR1cm4gcy5yZWR1Y2UoKGUsIHQpID0+IHtcbiAgICBjb25zdCByID0gdC5nZXRBdHRyaWJ1dGUoXCJ4bWw6aWRcIik7XG4gICAgcmV0dXJuIHIgJiYgKGVbcl0gPSB0KSwgZTtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24genAocywgZSkge1xuICByZXR1cm4gW10uc2xpY2UuY2FsbChzLmNoaWxkTm9kZXMpLnJlZHVjZSgodCwgciwgbikgPT4ge1xuICAgIHZhciBpO1xuICAgIHJldHVybiByLm5vZGVOYW1lID09PSBcImJyXCIgJiYgbiA/IHQgKyBgXG5gIDogKGkgPSByLmNoaWxkTm9kZXMpICE9IG51bGwgJiYgaS5sZW5ndGggPyB6cChyLCBlKSA6IGUgPyB0ICsgci50ZXh0Q29udGVudC50cmltKCkucmVwbGFjZSgvXFxzKy9nLCBcIiBcIikgOiB0ICsgci50ZXh0Q29udGVudDtcbiAgfSwgXCJcIik7XG59XG5mdW5jdGlvbiBLdyhzLCBlLCB0KSB7XG4gIGNvbnN0IHIgPSBcImh0dHA6Ly93d3cudzMub3JnL25zL3R0bWwjc3R5bGluZ1wiO1xuICBsZXQgbiA9IG51bGw7XG4gIGNvbnN0IGkgPSBbXG4gICAgXCJkaXNwbGF5QWxpZ25cIixcbiAgICBcInRleHRBbGlnblwiLFxuICAgIFwiY29sb3JcIixcbiAgICBcImJhY2tncm91bmRDb2xvclwiLFxuICAgIFwiZm9udFNpemVcIixcbiAgICBcImZvbnRGYW1pbHlcIlxuICAgIC8vICdmb250V2VpZ2h0JyxcbiAgICAvLyAnbGluZUhlaWdodCcsXG4gICAgLy8gJ3dyYXBPcHRpb24nLFxuICAgIC8vICdmb250U3R5bGUnLFxuICAgIC8vICdkaXJlY3Rpb24nLFxuICAgIC8vICd3cml0aW5nTW9kZSdcbiAgXSwgbyA9IHMgIT0gbnVsbCAmJiBzLmhhc0F0dHJpYnV0ZShcInN0eWxlXCIpID8gcy5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSA6IG51bGw7XG4gIHJldHVybiBvICYmIHQuaGFzT3duUHJvcGVydHkobykgJiYgKG4gPSB0W29dKSwgaS5yZWR1Y2UoKGEsIGwpID0+IHtcbiAgICBjb25zdCBjID0gUmwoZSwgciwgbCkgfHwgUmwocywgciwgbCkgfHwgUmwobiwgciwgbCk7XG4gICAgcmV0dXJuIGMgJiYgKGFbbF0gPSBjKSwgYTtcbiAgfSwge30pO1xufVxuZnVuY3Rpb24gUmwocywgZSwgdCkge1xuICByZXR1cm4gcyAmJiBzLmhhc0F0dHJpYnV0ZU5TKGUsIHQpID8gcy5nZXRBdHRyaWJ1dGVOUyhlLCB0KSA6IG51bGw7XG59XG5mdW5jdGlvbiBuZihzKSB7XG4gIHJldHVybiBuZXcgRXJyb3IoYENvdWxkIG5vdCBwYXJzZSB0dG1sIHRpbWVzdGFtcCAke3N9YCk7XG59XG5mdW5jdGlvbiBMbChzLCBlKSB7XG4gIGlmICghcylcbiAgICByZXR1cm4gbnVsbDtcbiAgbGV0IHQgPSBqcChzKTtcbiAgcmV0dXJuIHQgPT09IG51bGwgJiYgKHFwLnRlc3QocykgPyB0ID0gSHcocywgZSkgOiBXcC50ZXN0KHMpICYmICh0ID0gcXcocywgZSkpKSwgdDtcbn1cbmZ1bmN0aW9uIEh3KHMsIGUpIHtcbiAgY29uc3QgdCA9IHFwLmV4ZWMocyksIHIgPSAodFs0XSB8IDApICsgKHRbNV0gfCAwKSAvIGUuc3ViRnJhbWVSYXRlO1xuICByZXR1cm4gKHRbMV0gfCAwKSAqIDM2MDAgKyAodFsyXSB8IDApICogNjAgKyAodFszXSB8IDApICsgciAvIGUuZnJhbWVSYXRlO1xufVxuZnVuY3Rpb24gcXcocywgZSkge1xuICBjb25zdCB0ID0gV3AuZXhlYyhzKSwgciA9IE51bWJlcih0WzFdKTtcbiAgc3dpdGNoICh0WzJdKSB7XG4gICAgY2FzZSBcImhcIjpcbiAgICAgIHJldHVybiByICogMzYwMDtcbiAgICBjYXNlIFwibVwiOlxuICAgICAgcmV0dXJuIHIgKiA2MDtcbiAgICBjYXNlIFwibXNcIjpcbiAgICAgIHJldHVybiByICogMWUzO1xuICAgIGNhc2UgXCJmXCI6XG4gICAgICByZXR1cm4gciAvIGUuZnJhbWVSYXRlO1xuICAgIGNhc2UgXCJ0XCI6XG4gICAgICByZXR1cm4gciAvIGUudGlja1JhdGU7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5jbGFzcyBybyB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICB0aGlzLnRpbWVsaW5lQ29udHJvbGxlciA9IHZvaWQgMCwgdGhpcy5jdWVSYW5nZXMgPSBbXSwgdGhpcy50cmFja05hbWUgPSB2b2lkIDAsIHRoaXMuc3RhcnRUaW1lID0gbnVsbCwgdGhpcy5lbmRUaW1lID0gbnVsbCwgdGhpcy5zY3JlZW4gPSBudWxsLCB0aGlzLnRpbWVsaW5lQ29udHJvbGxlciA9IGUsIHRoaXMudHJhY2tOYW1lID0gdDtcbiAgfVxuICBkaXNwYXRjaEN1ZSgpIHtcbiAgICB0aGlzLnN0YXJ0VGltZSAhPT0gbnVsbCAmJiAodGhpcy50aW1lbGluZUNvbnRyb2xsZXIuYWRkQ3Vlcyh0aGlzLnRyYWNrTmFtZSwgdGhpcy5zdGFydFRpbWUsIHRoaXMuZW5kVGltZSwgdGhpcy5zY3JlZW4sIHRoaXMuY3VlUmFuZ2VzKSwgdGhpcy5zdGFydFRpbWUgPSBudWxsKTtcbiAgfVxuICBuZXdDdWUoZSwgdCwgcikge1xuICAgICh0aGlzLnN0YXJ0VGltZSA9PT0gbnVsbCB8fCB0aGlzLnN0YXJ0VGltZSA+IGUpICYmICh0aGlzLnN0YXJ0VGltZSA9IGUpLCB0aGlzLmVuZFRpbWUgPSB0LCB0aGlzLnNjcmVlbiA9IHIsIHRoaXMudGltZWxpbmVDb250cm9sbGVyLmNyZWF0ZUNhcHRpb25zVHJhY2sodGhpcy50cmFja05hbWUpO1xuICB9XG4gIHJlc2V0KCkge1xuICAgIHRoaXMuY3VlUmFuZ2VzID0gW10sIHRoaXMuc3RhcnRUaW1lID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgV3cge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDAsIHRoaXMubWVkaWEgPSBudWxsLCB0aGlzLmNvbmZpZyA9IHZvaWQgMCwgdGhpcy5lbmFibGVkID0gITAsIHRoaXMuQ3VlcyA9IHZvaWQgMCwgdGhpcy50ZXh0VHJhY2tzID0gW10sIHRoaXMudHJhY2tzID0gW10sIHRoaXMuaW5pdFBUUyA9IFtdLCB0aGlzLnVucGFyc2VkVnR0RnJhZ3MgPSBbXSwgdGhpcy5jYXB0aW9uc1RyYWNrcyA9IHt9LCB0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzID0ge30sIHRoaXMuY2VhNjA4UGFyc2VyMSA9IHZvaWQgMCwgdGhpcy5jZWE2MDhQYXJzZXIyID0gdm9pZCAwLCB0aGlzLmxhc3RDYyA9IC0xLCB0aGlzLmxhc3RTbiA9IC0xLCB0aGlzLmxhc3RQYXJ0SW5kZXggPSAtMSwgdGhpcy5wcmV2Q0MgPSAtMSwgdGhpcy52dHRDQ3MgPSBhZigpLCB0aGlzLmNhcHRpb25zUHJvcGVydGllcyA9IHZvaWQgMCwgdGhpcy5obHMgPSBlLCB0aGlzLmNvbmZpZyA9IGUuY29uZmlnLCB0aGlzLkN1ZXMgPSBlLmNvbmZpZy5jdWVIYW5kbGVyLCB0aGlzLmNhcHRpb25zUHJvcGVydGllcyA9IHtcbiAgICAgIHRleHRUcmFjazE6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMUxhbmd1YWdlQ29kZVxuICAgICAgfSxcbiAgICAgIHRleHRUcmFjazI6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrMkxhbmd1YWdlQ29kZVxuICAgICAgfSxcbiAgICAgIHRleHRUcmFjazM6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrM0xhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrM0xhbmd1YWdlQ29kZVxuICAgICAgfSxcbiAgICAgIHRleHRUcmFjazQ6IHtcbiAgICAgICAgbGFiZWw6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrNExhYmVsLFxuICAgICAgICBsYW5ndWFnZUNvZGU6IHRoaXMuY29uZmlnLmNhcHRpb25zVGV4dFRyYWNrNExhbmd1YWdlQ29kZVxuICAgICAgfVxuICAgIH0sIGUub24oSS5NRURJQV9BVFRBQ0hJTkcsIHRoaXMub25NZWRpYUF0dGFjaGluZywgdGhpcyksIGUub24oSS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyksIGUub24oSS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKSwgZS5vbihJLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKSwgZS5vbihJLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkLCB0aGlzKSwgZS5vbihJLkZSQUdfTE9BRElORywgdGhpcy5vbkZyYWdMb2FkaW5nLCB0aGlzKSwgZS5vbihJLkZSQUdfTE9BREVELCB0aGlzLm9uRnJhZ0xvYWRlZCwgdGhpcyksIGUub24oSS5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIHRoaXMub25GcmFnUGFyc2luZ1VzZXJkYXRhLCB0aGlzKSwgZS5vbihJLkZSQUdfREVDUllQVEVELCB0aGlzLm9uRnJhZ0RlY3J5cHRlZCwgdGhpcyksIGUub24oSS5JTklUX1BUU19GT1VORCwgdGhpcy5vbkluaXRQdHNGb3VuZCwgdGhpcyksIGUub24oSS5TVUJUSVRMRV9UUkFDS1NfQ0xFQVJFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzQ2xlYXJlZCwgdGhpcyksIGUub24oSS5CVUZGRVJfRkxVU0hJTkcsIHRoaXMub25CdWZmZXJGbHVzaGluZywgdGhpcyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHM6IGVcbiAgICB9ID0gdGhpcztcbiAgICBlLm9mZihJLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKSwgZS5vZmYoSS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyksIGUub2ZmKEkuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyksIGUub2ZmKEkuTUFOSUZFU1RfTE9BREVELCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQsIHRoaXMpLCBlLm9mZihJLlNVQlRJVExFX1RSQUNLU19VUERBVEVELCB0aGlzLm9uU3VidGl0bGVUcmFja3NVcGRhdGVkLCB0aGlzKSwgZS5vZmYoSS5GUkFHX0xPQURJTkcsIHRoaXMub25GcmFnTG9hZGluZywgdGhpcyksIGUub2ZmKEkuRlJBR19MT0FERUQsIHRoaXMub25GcmFnTG9hZGVkLCB0aGlzKSwgZS5vZmYoSS5GUkFHX1BBUlNJTkdfVVNFUkRBVEEsIHRoaXMub25GcmFnUGFyc2luZ1VzZXJkYXRhLCB0aGlzKSwgZS5vZmYoSS5GUkFHX0RFQ1JZUFRFRCwgdGhpcy5vbkZyYWdEZWNyeXB0ZWQsIHRoaXMpLCBlLm9mZihJLklOSVRfUFRTX0ZPVU5ELCB0aGlzLm9uSW5pdFB0c0ZvdW5kLCB0aGlzKSwgZS5vZmYoSS5TVUJUSVRMRV9UUkFDS1NfQ0xFQVJFRCwgdGhpcy5vblN1YnRpdGxlVHJhY2tzQ2xlYXJlZCwgdGhpcyksIGUub2ZmKEkuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpLCB0aGlzLmhscyA9IHRoaXMuY29uZmlnID0gdGhpcy5tZWRpYSA9IG51bGwsIHRoaXMuY2VhNjA4UGFyc2VyMSA9IHRoaXMuY2VhNjA4UGFyc2VyMiA9IHZvaWQgMDtcbiAgfVxuICBpbml0Q2VhNjA4UGFyc2VycygpIHtcbiAgICBjb25zdCBlID0gbmV3IHJvKHRoaXMsIFwidGV4dFRyYWNrMVwiKSwgdCA9IG5ldyBybyh0aGlzLCBcInRleHRUcmFjazJcIiksIHIgPSBuZXcgcm8odGhpcywgXCJ0ZXh0VHJhY2szXCIpLCBuID0gbmV3IHJvKHRoaXMsIFwidGV4dFRyYWNrNFwiKTtcbiAgICB0aGlzLmNlYTYwOFBhcnNlcjEgPSBuZXcgdGYoMSwgZSwgdCksIHRoaXMuY2VhNjA4UGFyc2VyMiA9IG5ldyB0ZigzLCByLCBuKTtcbiAgfVxuICBhZGRDdWVzKGUsIHQsIHIsIG4sIGkpIHtcbiAgICBsZXQgbyA9ICExO1xuICAgIGZvciAobGV0IGEgPSBpLmxlbmd0aDsgYS0tOyApIHtcbiAgICAgIGNvbnN0IGwgPSBpW2FdLCBjID0gencobFswXSwgbFsxXSwgdCwgcik7XG4gICAgICBpZiAoYyA+PSAwICYmIChsWzBdID0gTWF0aC5taW4obFswXSwgdCksIGxbMV0gPSBNYXRoLm1heChsWzFdLCByKSwgbyA9ICEwLCBjIC8gKHIgLSB0KSA+IDAuNSkpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG8gfHwgaS5wdXNoKFt0LCByXSksIHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgY29uc3QgYSA9IHRoaXMuY2FwdGlvbnNUcmFja3NbZV07XG4gICAgICB0aGlzLkN1ZXMubmV3Q3VlKGEsIHQsIHIsIG4pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhID0gdGhpcy5DdWVzLm5ld0N1ZShudWxsLCB0LCByLCBuKTtcbiAgICAgIHRoaXMuaGxzLnRyaWdnZXIoSS5DVUVTX1BBUlNFRCwge1xuICAgICAgICB0eXBlOiBcImNhcHRpb25zXCIsXG4gICAgICAgIGN1ZXM6IGEsXG4gICAgICAgIHRyYWNrOiBlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLy8gVHJpZ2dlcmVkIHdoZW4gYW4gaW5pdGlhbCBQVFMgaXMgZm91bmQ7IHVzZWQgZm9yIHN5bmNocm9uaXNhdGlvbiBvZiBXZWJWVFQuXG4gIG9uSW5pdFB0c0ZvdW5kKGUsIHtcbiAgICBmcmFnOiB0LFxuICAgIGlkOiByLFxuICAgIGluaXRQVFM6IG4sXG4gICAgdGltZXNjYWxlOiBpLFxuICAgIHRyYWNrSWQ6IG9cbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHVucGFyc2VkVnR0RnJhZ3M6IGFcbiAgICB9ID0gdGhpcztcbiAgICByID09PSBwZS5NQUlOICYmICh0aGlzLmluaXRQVFNbdC5jY10gPSB7XG4gICAgICBiYXNlVGltZTogbixcbiAgICAgIHRpbWVzY2FsZTogaSxcbiAgICAgIHRyYWNrSWQ6IG9cbiAgICB9KSwgYS5sZW5ndGggJiYgKHRoaXMudW5wYXJzZWRWdHRGcmFncyA9IFtdLCBhLmZvckVhY2goKGwpID0+IHtcbiAgICAgIHRoaXMuaW5pdFBUU1tsLmZyYWcuY2NdID8gdGhpcy5vbkZyYWdMb2FkZWQoSS5GUkFHX0xPQURFRCwgbCkgOiB0aGlzLmhscy50cmlnZ2VyKEkuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgc3VjY2VzczogITEsXG4gICAgICAgIGZyYWc6IGwuZnJhZyxcbiAgICAgICAgZXJyb3I6IG5ldyBFcnJvcihcIlN1YnRpdGxlIGRpc2NvbnRpbnVpdHkgZG9tYWluIGRvZXMgbm90IG1hdGNoIG1haW5cIilcbiAgICAgIH0pO1xuICAgIH0pKTtcbiAgfVxuICBnZXRFeGlzdGluZ1RyYWNrKGUsIHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYTogclxuICAgIH0gPSB0aGlzO1xuICAgIGlmIChyKVxuICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCByLnRleHRUcmFja3MubGVuZ3RoOyBuKyspIHtcbiAgICAgICAgY29uc3QgaSA9IHIudGV4dFRyYWNrc1tuXTtcbiAgICAgICAgaWYgKG9mKGksIHtcbiAgICAgICAgICBuYW1lOiBlLFxuICAgICAgICAgIGxhbmc6IHQsXG4gICAgICAgICAgY2hhcmFjdGVyaXN0aWNzOiBcInRyYW5zY3JpYmVzLXNwb2tlbi1kaWFsb2csZGVzY3JpYmVzLW11c2ljLWFuZC1zb3VuZFwiXG4gICAgICAgIH0pKVxuICAgICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNyZWF0ZUNhcHRpb25zVHJhY2soZSkge1xuICAgIHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSA/IHRoaXMuY3JlYXRlTmF0aXZlVHJhY2soZSkgOiB0aGlzLmNyZWF0ZU5vbk5hdGl2ZVRyYWNrKGUpO1xuICB9XG4gIGNyZWF0ZU5hdGl2ZVRyYWNrKGUpIHtcbiAgICBpZiAodGhpcy5jYXB0aW9uc1RyYWNrc1tlXSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBjYXB0aW9uc1Byb3BlcnRpZXM6IHQsXG4gICAgICBjYXB0aW9uc1RyYWNrczogcixcbiAgICAgIG1lZGlhOiBuXG4gICAgfSA9IHRoaXMsIHtcbiAgICAgIGxhYmVsOiBpLFxuICAgICAgbGFuZ3VhZ2VDb2RlOiBvXG4gICAgfSA9IHRbZV0sIGEgPSB0aGlzLmdldEV4aXN0aW5nVHJhY2soaSwgbyk7XG4gICAgaWYgKGEpXG4gICAgICByW2VdID0gYSwgU24ocltlXSksIE5wKHJbZV0sIG4pO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgbCA9IHRoaXMuY3JlYXRlVGV4dFRyYWNrKFwiY2FwdGlvbnNcIiwgaSwgbyk7XG4gICAgICBsICYmIChsW2VdID0gITAsIHJbZV0gPSBsKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlTm9uTmF0aXZlVHJhY2soZSkge1xuICAgIGlmICh0aGlzLm5vbk5hdGl2ZUNhcHRpb25zVHJhY2tzW2VdKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSB0aGlzLmNhcHRpb25zUHJvcGVydGllc1tlXTtcbiAgICBpZiAoIXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IHQubGFiZWwsIG4gPSB7XG4gICAgICBfaWQ6IGUsXG4gICAgICBsYWJlbDogcixcbiAgICAgIGtpbmQ6IFwiY2FwdGlvbnNcIixcbiAgICAgIGRlZmF1bHQ6IHQubWVkaWEgPyAhIXQubWVkaWEuZGVmYXVsdCA6ICExLFxuICAgICAgY2xvc2VkQ2FwdGlvbnM6IHQubWVkaWFcbiAgICB9O1xuICAgIHRoaXMubm9uTmF0aXZlQ2FwdGlvbnNUcmFja3NbZV0gPSBuLCB0aGlzLmhscy50cmlnZ2VyKEkuTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORCwge1xuICAgICAgdHJhY2tzOiBbbl1cbiAgICB9KTtcbiAgfVxuICBjcmVhdGVUZXh0VHJhY2soZSwgdCwgcikge1xuICAgIGNvbnN0IG4gPSB0aGlzLm1lZGlhO1xuICAgIGlmIChuKVxuICAgICAgcmV0dXJuIG4uYWRkVGV4dFRyYWNrKGUsIHQsIHIpO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hpbmcoZSwgdCkge1xuICAgIHRoaXMubWVkaWEgPSB0Lm1lZGlhLCB0Lm1lZGlhU291cmNlIHx8IHRoaXMuX2NsZWFuVHJhY2tzKCk7XG4gIH1cbiAgb25NZWRpYURldGFjaGluZyhlLCB0KSB7XG4gICAgY29uc3QgciA9ICEhdC50cmFuc2Zlck1lZGlhO1xuICAgIGlmICh0aGlzLm1lZGlhID0gbnVsbCwgcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBjYXB0aW9uc1RyYWNrczogblxuICAgIH0gPSB0aGlzO1xuICAgIE9iamVjdC5rZXlzKG4pLmZvckVhY2goKGkpID0+IHtcbiAgICAgIFNuKG5baV0pLCBkZWxldGUgbltpXTtcbiAgICB9KSwgdGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrcyA9IHt9O1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMubGFzdENjID0gLTEsIHRoaXMubGFzdFNuID0gLTEsIHRoaXMubGFzdFBhcnRJbmRleCA9IC0xLCB0aGlzLnByZXZDQyA9IC0xLCB0aGlzLnZ0dENDcyA9IGFmKCksIHRoaXMuX2NsZWFuVHJhY2tzKCksIHRoaXMudHJhY2tzID0gW10sIHRoaXMuY2FwdGlvbnNUcmFja3MgPSB7fSwgdGhpcy5ub25OYXRpdmVDYXB0aW9uc1RyYWNrcyA9IHt9LCB0aGlzLnRleHRUcmFja3MgPSBbXSwgdGhpcy51bnBhcnNlZFZ0dEZyYWdzID0gW10sIHRoaXMuaW5pdFBUUyA9IFtdLCB0aGlzLmNlYTYwOFBhcnNlcjEgJiYgdGhpcy5jZWE2MDhQYXJzZXIyICYmICh0aGlzLmNlYTYwOFBhcnNlcjEucmVzZXQoKSwgdGhpcy5jZWE2MDhQYXJzZXIyLnJlc2V0KCkpO1xuICB9XG4gIF9jbGVhblRyYWNrcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYTogZVxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gZS50ZXh0VHJhY2tzO1xuICAgIGlmICh0KVxuICAgICAgZm9yIChsZXQgciA9IDA7IHIgPCB0Lmxlbmd0aDsgcisrKVxuICAgICAgICBTbih0W3JdKTtcbiAgfVxuICBvblN1YnRpdGxlVHJhY2tzVXBkYXRlZChlLCB0KSB7XG4gICAgY29uc3QgciA9IHQuc3VidGl0bGVUcmFja3MgfHwgW10sIG4gPSByLnNvbWUoKGkpID0+IGkudGV4dENvZGVjID09PSBJbCk7XG4gICAgaWYgKHRoaXMuY29uZmlnLmVuYWJsZVdlYlZUVCB8fCBuICYmIHRoaXMuY29uZmlnLmVuYWJsZUlNU0MxKSB7XG4gICAgICBpZiAoQXAodGhpcy50cmFja3MsIHIpKSB7XG4gICAgICAgIHRoaXMudHJhY2tzID0gcjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGV4dFRyYWNrcyA9IFtdLCB0aGlzLnRyYWNrcyA9IHIsIHRoaXMuY29uZmlnLnJlbmRlclRleHRUcmFja3NOYXRpdmVseSkge1xuICAgICAgICBjb25zdCBvID0gdGhpcy5tZWRpYSwgYSA9IG8gPyBFbyhvLnRleHRUcmFja3MpIDogbnVsbDtcbiAgICAgICAgaWYgKHRoaXMudHJhY2tzLmZvckVhY2goKGwsIGMpID0+IHtcbiAgICAgICAgICBsZXQgdTtcbiAgICAgICAgICBpZiAoYSkge1xuICAgICAgICAgICAgbGV0IGQgPSBudWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgaCA9IDA7IGggPCBhLmxlbmd0aDsgaCsrKVxuICAgICAgICAgICAgICBpZiAoYVtoXSAmJiBvZihhW2hdLCBsKSkge1xuICAgICAgICAgICAgICAgIGQgPSBhW2hdLCBhW2hdID0gbnVsbDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgZCAmJiAodSA9IGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodSlcbiAgICAgICAgICAgIFNuKHUpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZCA9IFlwKGwpO1xuICAgICAgICAgICAgdSA9IHRoaXMuY3JlYXRlVGV4dFRyYWNrKGQsIGwubmFtZSwgbC5sYW5nKSwgdSAmJiAodS5tb2RlID0gXCJkaXNhYmxlZFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdSAmJiB0aGlzLnRleHRUcmFja3MucHVzaCh1KTtcbiAgICAgICAgfSksIGEgIT0gbnVsbCAmJiBhLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGwgPSBhLmZpbHRlcigoYykgPT4gYyAhPT0gbnVsbCkubWFwKChjKSA9PiBjLmxhYmVsKTtcbiAgICAgICAgICBsLmxlbmd0aCAmJiB0aGlzLmhscy5sb2dnZXIud2FybihgTWVkaWEgZWxlbWVudCBjb250YWlucyB1bnVzZWQgc3VidGl0bGUgdHJhY2tzOiAke2wuam9pbihcIiwgXCIpfS4gUmVwbGFjZSBtZWRpYSBlbGVtZW50IGZvciBlYWNoIHNvdXJjZSB0byBjbGVhciBUZXh0VHJhY2tzIGFuZCBjYXB0aW9ucyBtZW51LmApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudHJhY2tzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBvID0gdGhpcy50cmFja3MubWFwKChhKSA9PiAoe1xuICAgICAgICAgIGxhYmVsOiBhLm5hbWUsXG4gICAgICAgICAga2luZDogYS50eXBlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgZGVmYXVsdDogYS5kZWZhdWx0LFxuICAgICAgICAgIHN1YnRpdGxlVHJhY2s6IGFcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEkuTk9OX05BVElWRV9URVhUX1RSQUNLU19GT1VORCwge1xuICAgICAgICAgIHRyYWNrczogb1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgb25NYW5pZmVzdExvYWRlZChlLCB0KSB7XG4gICAgdGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMgJiYgdC5jYXB0aW9ucyAmJiB0LmNhcHRpb25zLmZvckVhY2goKHIpID0+IHtcbiAgICAgIGNvbnN0IG4gPSAvKD86Q0N8U0VSVklDRSkoWzEtNF0pLy5leGVjKHIuaW5zdHJlYW1JZCk7XG4gICAgICBpZiAoIW4pXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGkgPSBgdGV4dFRyYWNrJHtuWzFdfWAsIG8gPSB0aGlzLmNhcHRpb25zUHJvcGVydGllc1tpXTtcbiAgICAgIG8gJiYgKG8ubGFiZWwgPSByLm5hbWUsIHIubGFuZyAmJiAoby5sYW5ndWFnZUNvZGUgPSByLmxhbmcpLCBvLm1lZGlhID0gcik7XG4gICAgfSk7XG4gIH1cbiAgY2xvc2VkQ2FwdGlvbnNGb3JMZXZlbChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuaGxzLmxldmVsc1tlLmxldmVsXTtcbiAgICByZXR1cm4gdCA9PSBudWxsID8gdm9pZCAwIDogdC5hdHRyc1tcIkNMT1NFRC1DQVBUSU9OU1wiXTtcbiAgfVxuICBvbkZyYWdMb2FkaW5nKGUsIHQpIHtcbiAgICBpZiAodGhpcy5lbmFibGVkICYmIHQuZnJhZy50eXBlID09PSBwZS5NQUlOKSB7XG4gICAgICB2YXIgciwgbjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2VhNjA4UGFyc2VyMTogaSxcbiAgICAgICAgY2VhNjA4UGFyc2VyMjogbyxcbiAgICAgICAgbGFzdFNuOiBhXG4gICAgICB9ID0gdGhpcywge1xuICAgICAgICBjYzogbCxcbiAgICAgICAgc246IGNcbiAgICAgIH0gPSB0LmZyYWcsIHUgPSAociA9IChuID0gdC5wYXJ0KSA9PSBudWxsID8gdm9pZCAwIDogbi5pbmRleCkgIT0gbnVsbCA/IHIgOiAtMTtcbiAgICAgIGkgJiYgbyAmJiAoYyAhPT0gYSArIDEgfHwgYyA9PT0gYSAmJiB1ICE9PSB0aGlzLmxhc3RQYXJ0SW5kZXggKyAxIHx8IGwgIT09IHRoaXMubGFzdENjKSAmJiAoaS5yZXNldCgpLCBvLnJlc2V0KCkpLCB0aGlzLmxhc3RDYyA9IGwsIHRoaXMubGFzdFNuID0gYywgdGhpcy5sYXN0UGFydEluZGV4ID0gdTtcbiAgICB9XG4gIH1cbiAgb25GcmFnTG9hZGVkKGUsIHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnOiByLFxuICAgICAgcGF5bG9hZDogblxuICAgIH0gPSB0O1xuICAgIGlmIChyLnR5cGUgPT09IHBlLlNVQlRJVExFKVxuICAgICAgaWYgKG4uYnl0ZUxlbmd0aCkge1xuICAgICAgICBjb25zdCBpID0gci5kZWNyeXB0ZGF0YSwgbyA9IFwic3RhdHNcIiBpbiB0O1xuICAgICAgICBpZiAoaSA9PSBudWxsIHx8ICFpLmVuY3J5cHRlZCB8fCBvKSB7XG4gICAgICAgICAgY29uc3QgYSA9IHRoaXMudHJhY2tzW3IubGV2ZWxdLCBsID0gdGhpcy52dHRDQ3M7XG4gICAgICAgICAgbFtyLmNjXSB8fCAobFtyLmNjXSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiByLnN0YXJ0LFxuICAgICAgICAgICAgcHJldkNDOiB0aGlzLnByZXZDQyxcbiAgICAgICAgICAgIG5ldzogITBcbiAgICAgICAgICB9LCB0aGlzLnByZXZDQyA9IHIuY2MpLCBhICYmIGEudGV4dENvZGVjID09PSBJbCA/IHRoaXMuX3BhcnNlSU1TQzEociwgbikgOiB0aGlzLl9wYXJzZVZUVHModCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICB0aGlzLmhscy50cmlnZ2VyKEkuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgICBzdWNjZXNzOiAhMSxcbiAgICAgICAgICBmcmFnOiByLFxuICAgICAgICAgIGVycm9yOiBuZXcgRXJyb3IoXCJFbXB0eSBzdWJ0aXRsZSBwYXlsb2FkXCIpXG4gICAgICAgIH0pO1xuICB9XG4gIF9wYXJzZUlNU0MxKGUsIHQpIHtcbiAgICBjb25zdCByID0gdGhpcy5obHM7XG4gICAgcmYodCwgdGhpcy5pbml0UFRTW2UuY2NdLCAobikgPT4ge1xuICAgICAgdGhpcy5fYXBwZW5kQ3VlcyhuLCBlLmxldmVsKSwgci50cmlnZ2VyKEkuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgc3VjY2VzczogITAsXG4gICAgICAgIGZyYWc6IGVcbiAgICAgIH0pO1xuICAgIH0sIChuKSA9PiB7XG4gICAgICByLmxvZ2dlci5sb2coYEZhaWxlZCB0byBwYXJzZSBJTVNDMTogJHtufWApLCByLnRyaWdnZXIoSS5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICBzdWNjZXNzOiAhMSxcbiAgICAgICAgZnJhZzogZSxcbiAgICAgICAgZXJyb3I6IG5cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIF9wYXJzZVZUVHMoZSkge1xuICAgIHZhciB0O1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWc6IHIsXG4gICAgICBwYXlsb2FkOiBuXG4gICAgfSA9IGUsIHtcbiAgICAgIGluaXRQVFM6IGksXG4gICAgICB1bnBhcnNlZFZ0dEZyYWdzOiBvXG4gICAgfSA9IHRoaXMsIGEgPSBpLmxlbmd0aCAtIDE7XG4gICAgaWYgKCFpW3IuY2NdICYmIGEgPT09IC0xKSB7XG4gICAgICBvLnB1c2goZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGwgPSB0aGlzLmhscywgYyA9ICh0ID0gci5pbml0U2VnbWVudCkgIT0gbnVsbCAmJiB0LmRhdGEgPyBfcihyLmluaXRTZWdtZW50LmRhdGEsIG5ldyBVaW50OEFycmF5KG4pKS5idWZmZXIgOiBuO1xuICAgIEd3KGMsIHRoaXMuaW5pdFBUU1tyLmNjXSwgdGhpcy52dHRDQ3MsIHIuY2MsIHIuc3RhcnQsICh1KSA9PiB7XG4gICAgICB0aGlzLl9hcHBlbmRDdWVzKHUsIHIubGV2ZWwpLCBsLnRyaWdnZXIoSS5TVUJUSVRMRV9GUkFHX1BST0NFU1NFRCwge1xuICAgICAgICBzdWNjZXNzOiAhMCxcbiAgICAgICAgZnJhZzogclxuICAgICAgfSk7XG4gICAgfSwgKHUpID0+IHtcbiAgICAgIGNvbnN0IGQgPSB1Lm1lc3NhZ2UgPT09IFwiTWlzc2luZyBpbml0UFRTIGZvciBWVFQgTVBFR1RTXCI7XG4gICAgICBkID8gby5wdXNoKGUpIDogdGhpcy5fZmFsbGJhY2tUb0lNU0MxKHIsIG4pLCBsLmxvZ2dlci5sb2coYEZhaWxlZCB0byBwYXJzZSBWVFQgY3VlOiAke3V9YCksICEoZCAmJiBhID4gci5jYykgJiYgbC50cmlnZ2VyKEkuU1VCVElUTEVfRlJBR19QUk9DRVNTRUQsIHtcbiAgICAgICAgc3VjY2VzczogITEsXG4gICAgICAgIGZyYWc6IHIsXG4gICAgICAgIGVycm9yOiB1XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBfZmFsbGJhY2tUb0lNU0MxKGUsIHQpIHtcbiAgICBjb25zdCByID0gdGhpcy50cmFja3NbZS5sZXZlbF07XG4gICAgci50ZXh0Q29kZWMgfHwgcmYodCwgdGhpcy5pbml0UFRTW2UuY2NdLCAoKSA9PiB7XG4gICAgICByLnRleHRDb2RlYyA9IElsLCB0aGlzLl9wYXJzZUlNU0MxKGUsIHQpO1xuICAgIH0sICgpID0+IHtcbiAgICAgIHIudGV4dENvZGVjID0gXCJ3dnR0XCI7XG4gICAgfSk7XG4gIH1cbiAgX2FwcGVuZEN1ZXMoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLmhscztcbiAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5KSB7XG4gICAgICBjb25zdCBuID0gdGhpcy50ZXh0VHJhY2tzW3RdO1xuICAgICAgaWYgKCFuIHx8IG4ubW9kZSA9PT0gXCJkaXNhYmxlZFwiKVxuICAgICAgICByZXR1cm47XG4gICAgICBlLmZvckVhY2goKGkpID0+IFVwKG4sIGkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbiA9IHRoaXMudHJhY2tzW3RdO1xuICAgICAgaWYgKCFuKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBpID0gbi5kZWZhdWx0ID8gXCJkZWZhdWx0XCIgOiBcInN1YnRpdGxlc1wiICsgdDtcbiAgICAgIHIudHJpZ2dlcihJLkNVRVNfUEFSU0VELCB7XG4gICAgICAgIHR5cGU6IFwic3VidGl0bGVzXCIsXG4gICAgICAgIGN1ZXM6IGUsXG4gICAgICAgIHRyYWNrOiBpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgb25GcmFnRGVjcnlwdGVkKGUsIHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBmcmFnOiByXG4gICAgfSA9IHQ7XG4gICAgci50eXBlID09PSBwZS5TVUJUSVRMRSAmJiB0aGlzLm9uRnJhZ0xvYWRlZChJLkZSQUdfTE9BREVELCB0KTtcbiAgfVxuICBvblN1YnRpdGxlVHJhY2tzQ2xlYXJlZCgpIHtcbiAgICB0aGlzLnRyYWNrcyA9IFtdLCB0aGlzLmNhcHRpb25zVHJhY2tzID0ge307XG4gIH1cbiAgb25GcmFnUGFyc2luZ1VzZXJkYXRhKGUsIHQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhdGhpcy5jb25maWcuZW5hYmxlQ0VBNzA4Q2FwdGlvbnMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgZnJhZzogcixcbiAgICAgIHNhbXBsZXM6IG5cbiAgICB9ID0gdDtcbiAgICBpZiAoIShyLnR5cGUgPT09IHBlLk1BSU4gJiYgdGhpcy5jbG9zZWRDYXB0aW9uc0ZvckxldmVsKHIpID09PSBcIk5PTkVcIikpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbyA9IG5baV0uYnl0ZXM7XG4gICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgdGhpcy5jZWE2MDhQYXJzZXIxIHx8IHRoaXMuaW5pdENlYTYwOFBhcnNlcnMoKTtcbiAgICAgICAgICBjb25zdCBhID0gdGhpcy5leHRyYWN0Q2VhNjA4RGF0YShvKTtcbiAgICAgICAgICB0aGlzLmNlYTYwOFBhcnNlcjEuYWRkRGF0YShuW2ldLnB0cywgYVswXSksIHRoaXMuY2VhNjA4UGFyc2VyMi5hZGREYXRhKG5baV0ucHRzLCBhWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG4gIG9uQnVmZmVyRmx1c2hpbmcoZSwge1xuICAgIHN0YXJ0T2Zmc2V0OiB0LFxuICAgIGVuZE9mZnNldDogcixcbiAgICBlbmRPZmZzZXRTdWJ0aXRsZXM6IG4sXG4gICAgdHlwZTogaVxuICB9KSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVkaWE6IG9cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoISghbyB8fCBvLmN1cnJlbnRUaW1lIDwgcikpIHtcbiAgICAgIGlmICghaSB8fCBpID09PSBcInZpZGVvXCIpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNhcHRpb25zVHJhY2tzOiBhXG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyhhKS5mb3JFYWNoKChsKSA9PiBTYyhhW2xdLCB0LCByKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb25maWcucmVuZGVyVGV4dFRyYWNrc05hdGl2ZWx5ICYmIHQgPT09IDAgJiYgbiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0ZXh0VHJhY2tzOiBhXG4gICAgICAgIH0gPSB0aGlzO1xuICAgICAgICBPYmplY3Qua2V5cyhhKS5mb3JFYWNoKChsKSA9PiBTYyhhW2xdLCB0LCBuKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGV4dHJhY3RDZWE2MDhEYXRhKGUpIHtcbiAgICBjb25zdCB0ID0gW1tdLCBbXV0sIHIgPSBlWzBdICYgMzE7XG4gICAgbGV0IG4gPSAyO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcjsgaSsrKSB7XG4gICAgICBjb25zdCBvID0gZVtuKytdLCBhID0gMTI3ICYgZVtuKytdLCBsID0gMTI3ICYgZVtuKytdO1xuICAgICAgaWYgKGEgPT09IDAgJiYgbCA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoKDQgJiBvKSAhPT0gMCkge1xuICAgICAgICBjb25zdCB1ID0gMyAmIG87XG4gICAgICAgICh1ID09PSAwIHx8IHUgPT09IDEpICYmICh0W3VdLnB1c2goYSksIHRbdV0ucHVzaChsKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG59XG5mdW5jdGlvbiBZcChzKSB7XG4gIHJldHVybiBzLmNoYXJhY3RlcmlzdGljcyAmJiAvdHJhbnNjcmliZXMtc3Bva2VuLWRpYWxvZy9naS50ZXN0KHMuY2hhcmFjdGVyaXN0aWNzKSAmJiAvZGVzY3JpYmVzLW11c2ljLWFuZC1zb3VuZC9naS50ZXN0KHMuY2hhcmFjdGVyaXN0aWNzKSA/IFwiY2FwdGlvbnNcIiA6IFwic3VidGl0bGVzXCI7XG59XG5mdW5jdGlvbiBvZihzLCBlKSB7XG4gIHJldHVybiAhIXMgJiYgcy5raW5kID09PSBZcChlKSAmJiB5YyhlLCBzKTtcbn1cbmZ1bmN0aW9uIHp3KHMsIGUsIHQsIHIpIHtcbiAgcmV0dXJuIE1hdGgubWluKGUsIHIpIC0gTWF0aC5tYXgocywgdCk7XG59XG5mdW5jdGlvbiBhZigpIHtcbiAgcmV0dXJuIHtcbiAgICBjY09mZnNldDogMCxcbiAgICBwcmVzZW50YXRpb25PZmZzZXQ6IDAsXG4gICAgMDoge1xuICAgICAgc3RhcnQ6IDAsXG4gICAgICBwcmV2Q0M6IC0xLFxuICAgICAgbmV3OiAhMFxuICAgIH1cbiAgfTtcbn1cbmNvbnN0IFl3ID0gL1xccy8sIFp3ID0ge1xuICBuZXdDdWUocywgZSwgdCwgcikge1xuICAgIGNvbnN0IG4gPSBbXTtcbiAgICBsZXQgaSwgbywgYSwgbCwgYztcbiAgICBjb25zdCB1ID0gc2VsZi5WVFRDdWUgfHwgc2VsZi5UZXh0VHJhY2tDdWU7XG4gICAgZm9yIChsZXQgaCA9IDA7IGggPCByLnJvd3MubGVuZ3RoOyBoKyspXG4gICAgICBpZiAoaSA9IHIucm93c1toXSwgYSA9ICEwLCBsID0gMCwgYyA9IFwiXCIsICFpLmlzRW1wdHkoKSkge1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBpLmNoYXJzLmxlbmd0aDsgeSsrKVxuICAgICAgICAgIFl3LnRlc3QoaS5jaGFyc1t5XS51Y2hhcikgJiYgYSA/IGwrKyA6IChjICs9IGkuY2hhcnNbeV0udWNoYXIsIGEgPSAhMSk7XG4gICAgICAgIGkuY3VlU3RhcnRUaW1lID0gZSwgZSA9PT0gdCAmJiAodCArPSAxZS00KSwgbCA+PSAxNiA/IGwtLSA6IGwrKztcbiAgICAgICAgY29uc3QgZiA9IEhwKGMudHJpbSgpKSwgcCA9IEJ1KGUsIHQsIGYpO1xuICAgICAgICBzICE9IG51bGwgJiYgKGQgPSBzLmN1ZXMpICE9IG51bGwgJiYgZC5nZXRDdWVCeUlkKHApIHx8IChvID0gbmV3IHUoZSwgdCwgZiksIG8uaWQgPSBwLCBvLmxpbmUgPSBoICsgMSwgby5hbGlnbiA9IFwibGVmdFwiLCBvLnBvc2l0aW9uID0gMTAgKyBNYXRoLm1pbig4MCwgTWF0aC5mbG9vcihsICogOCAvIDMyKSAqIDEwKSwgbi5wdXNoKG8pKTtcbiAgICAgIH1cbiAgICByZXR1cm4gcyAmJiBuLmxlbmd0aCAmJiAobi5zb3J0KChoLCBmKSA9PiBoLmxpbmUgPT09IFwiYXV0b1wiIHx8IGYubGluZSA9PT0gXCJhdXRvXCIgPyAwIDogaC5saW5lID4gOCAmJiBmLmxpbmUgPiA4ID8gZi5saW5lIC0gaC5saW5lIDogaC5saW5lIC0gZi5saW5lKSwgbi5mb3JFYWNoKChoKSA9PiBVcChzLCBoKSkpLCBuO1xuICB9XG59O1xuZnVuY3Rpb24gWHcoKSB7XG4gIGlmIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgc2VsZi5mZXRjaCAmJiBzZWxmLkFib3J0Q29udHJvbGxlciAmJiBzZWxmLlJlYWRhYmxlU3RyZWFtICYmIHNlbGYuUmVxdWVzdFxuICApXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgc2VsZi5SZWFkYWJsZVN0cmVhbSh7fSksICEwO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgcmV0dXJuICExO1xufVxuY29uc3QgSncgPSAvKFxcZCspLShcXGQrKVxcLyhcXGQrKS87XG5jbGFzcyBsZiB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLmZldGNoU2V0dXAgPSB2b2lkIDAsIHRoaXMucmVxdWVzdFRpbWVvdXQgPSB2b2lkIDAsIHRoaXMucmVxdWVzdCA9IG51bGwsIHRoaXMucmVzcG9uc2UgPSBudWxsLCB0aGlzLmNvbnRyb2xsZXIgPSB2b2lkIDAsIHRoaXMuY29udGV4dCA9IG51bGwsIHRoaXMuY29uZmlnID0gbnVsbCwgdGhpcy5jYWxsYmFja3MgPSBudWxsLCB0aGlzLnN0YXRzID0gdm9pZCAwLCB0aGlzLmxvYWRlciA9IG51bGwsIHRoaXMuZmV0Y2hTZXR1cCA9IGUuZmV0Y2hTZXR1cCB8fCByQSwgdGhpcy5jb250cm9sbGVyID0gbmV3IHNlbGYuQWJvcnRDb250cm9sbGVyKCksIHRoaXMuc3RhdHMgPSBuZXcgZnUoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMubG9hZGVyID0gdGhpcy5jYWxsYmFja3MgPSB0aGlzLmNvbnRleHQgPSB0aGlzLmNvbmZpZyA9IHRoaXMucmVxdWVzdCA9IG51bGwsIHRoaXMuYWJvcnRJbnRlcm5hbCgpLCB0aGlzLnJlc3BvbnNlID0gbnVsbCwgdGhpcy5mZXRjaFNldHVwID0gdGhpcy5jb250cm9sbGVyID0gdGhpcy5zdGF0cyA9IG51bGw7XG4gIH1cbiAgYWJvcnRJbnRlcm5hbCgpIHtcbiAgICB0aGlzLmNvbnRyb2xsZXIgJiYgIXRoaXMuc3RhdHMubG9hZGluZy5lbmQgJiYgKHRoaXMuc3RhdHMuYWJvcnRlZCA9ICEwLCB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoKSk7XG4gIH1cbiAgYWJvcnQoKSB7XG4gICAgdmFyIGU7XG4gICAgdGhpcy5hYm9ydEludGVybmFsKCksIChlID0gdGhpcy5jYWxsYmFja3MpICE9IG51bGwgJiYgZS5vbkFib3J0ICYmIHRoaXMuY2FsbGJhY2tzLm9uQWJvcnQodGhpcy5zdGF0cywgdGhpcy5jb250ZXh0LCB0aGlzLnJlc3BvbnNlKTtcbiAgfVxuICBsb2FkKGUsIHQsIHIpIHtcbiAgICBjb25zdCBuID0gdGhpcy5zdGF0cztcbiAgICBpZiAobi5sb2FkaW5nLnN0YXJ0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGVyIGNhbiBvbmx5IGJlIHVzZWQgb25jZS5cIik7XG4gICAgbi5sb2FkaW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCBpID0gUXcoZSwgdGhpcy5jb250cm9sbGVyLnNpZ25hbCksIG8gPSBlLnJlc3BvbnNlVHlwZSA9PT0gXCJhcnJheWJ1ZmZlclwiLCBhID0gbyA/IFwiYnl0ZUxlbmd0aFwiIDogXCJsZW5ndGhcIiwge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IGwsXG4gICAgICBtYXhMb2FkVGltZU1zOiBjXG4gICAgfSA9IHQubG9hZFBvbGljeTtcbiAgICB0aGlzLmNvbnRleHQgPSBlLCB0aGlzLmNvbmZpZyA9IHQsIHRoaXMuY2FsbGJhY2tzID0gciwgdGhpcy5yZXF1ZXN0ID0gdGhpcy5mZXRjaFNldHVwKGUsIGkpLCBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KSwgdC50aW1lb3V0ID0gbCAmJiB1ZShsKSA/IGwgOiBjLCB0aGlzLnJlcXVlc3RUaW1lb3V0ID0gc2VsZi5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuY2FsbGJhY2tzICYmICh0aGlzLmFib3J0SW50ZXJuYWwoKSwgdGhpcy5jYWxsYmFja3Mub25UaW1lb3V0KG4sIGUsIHRoaXMucmVzcG9uc2UpKTtcbiAgICB9LCB0LnRpbWVvdXQpLCAoeGkodGhpcy5yZXF1ZXN0KSA/IHRoaXMucmVxdWVzdC50aGVuKHNlbGYuZmV0Y2gpIDogc2VsZi5mZXRjaCh0aGlzLnJlcXVlc3QpKS50aGVuKChkKSA9PiB7XG4gICAgICB2YXIgaDtcbiAgICAgIHRoaXMucmVzcG9uc2UgPSB0aGlzLmxvYWRlciA9IGQ7XG4gICAgICBjb25zdCBmID0gTWF0aC5tYXgoc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgbi5sb2FkaW5nLnN0YXJ0KTtcbiAgICAgIGlmIChzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KSwgdC50aW1lb3V0ID0gYywgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzICYmICh0aGlzLmFib3J0SW50ZXJuYWwoKSwgdGhpcy5jYWxsYmFja3Mub25UaW1lb3V0KG4sIGUsIHRoaXMucmVzcG9uc2UpKTtcbiAgICAgIH0sIGMgLSAoZiAtIG4ubG9hZGluZy5zdGFydCkpLCAhZC5vaykge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc3RhdHVzOiB5LFxuICAgICAgICAgIHN0YXR1c1RleHQ6IEVcbiAgICAgICAgfSA9IGQ7XG4gICAgICAgIHRocm93IG5ldyBzQShFIHx8IFwiZmV0Y2gsIGJhZCBuZXR3b3JrIHJlc3BvbnNlXCIsIHksIGQpO1xuICAgICAgfVxuICAgICAgbi5sb2FkaW5nLmZpcnN0ID0gZiwgbi50b3RhbCA9IHRBKGQuaGVhZGVycykgfHwgbi50b3RhbDtcbiAgICAgIGNvbnN0IHAgPSAoaCA9IHRoaXMuY2FsbGJhY2tzKSA9PSBudWxsID8gdm9pZCAwIDogaC5vblByb2dyZXNzO1xuICAgICAgcmV0dXJuIHAgJiYgdWUodC5oaWdoV2F0ZXJNYXJrKSA/IHRoaXMubG9hZFByb2dyZXNzaXZlbHkoZCwgbiwgZSwgdC5oaWdoV2F0ZXJNYXJrLCBwKSA6IG8gPyBkLmFycmF5QnVmZmVyKCkgOiBlLnJlc3BvbnNlVHlwZSA9PT0gXCJqc29uXCIgPyBkLmpzb24oKSA6IGQudGV4dCgpO1xuICAgIH0pLnRoZW4oKGQpID0+IHtcbiAgICAgIHZhciBoLCBmO1xuICAgICAgY29uc3QgcCA9IHRoaXMucmVzcG9uc2U7XG4gICAgICBpZiAoIXApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImxvYWRlciBkZXN0cm95ZWRcIik7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KSwgbi5sb2FkaW5nLmVuZCA9IE1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksIG4ubG9hZGluZy5maXJzdCk7XG4gICAgICBjb25zdCB5ID0gZFthXTtcbiAgICAgIHkgJiYgKG4ubG9hZGVkID0gbi50b3RhbCA9IHkpO1xuICAgICAgY29uc3QgRSA9IHtcbiAgICAgICAgdXJsOiBwLnVybCxcbiAgICAgICAgZGF0YTogZCxcbiAgICAgICAgY29kZTogcC5zdGF0dXNcbiAgICAgIH0sIGIgPSAoaCA9IHRoaXMuY2FsbGJhY2tzKSA9PSBudWxsID8gdm9pZCAwIDogaC5vblByb2dyZXNzO1xuICAgICAgYiAmJiAhdWUodC5oaWdoV2F0ZXJNYXJrKSAmJiBiKG4sIGUsIGQsIHApLCAoZiA9IHRoaXMuY2FsbGJhY2tzKSA9PSBudWxsIHx8IGYub25TdWNjZXNzKEUsIG4sIGUsIHApO1xuICAgIH0pLmNhdGNoKChkKSA9PiB7XG4gICAgICB2YXIgaDtcbiAgICAgIGlmIChzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KSwgbi5hYm9ydGVkKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBmID0gZCAmJiBkLmNvZGUgfHwgMCwgcCA9IGQgPyBkLm1lc3NhZ2UgOiBudWxsO1xuICAgICAgKGggPSB0aGlzLmNhbGxiYWNrcykgPT0gbnVsbCB8fCBoLm9uRXJyb3Ioe1xuICAgICAgICBjb2RlOiBmLFxuICAgICAgICB0ZXh0OiBwXG4gICAgICB9LCBlLCBkID8gZC5kZXRhaWxzIDogbnVsbCwgbik7XG4gICAgfSk7XG4gIH1cbiAgZ2V0Q2FjaGVBZ2UoKSB7XG4gICAgbGV0IGUgPSBudWxsO1xuICAgIGlmICh0aGlzLnJlc3BvbnNlKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5yZXNwb25zZS5oZWFkZXJzLmdldChcImFnZVwiKTtcbiAgICAgIGUgPSB0ID8gcGFyc2VGbG9hdCh0KSA6IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9XG4gIGdldFJlc3BvbnNlSGVhZGVyKGUpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZSA/IHRoaXMucmVzcG9uc2UuaGVhZGVycy5nZXQoZSkgOiBudWxsO1xuICB9XG4gIGxvYWRQcm9ncmVzc2l2ZWx5KGUsIHQsIHIsIG4gPSAwLCBpKSB7XG4gICAgY29uc3QgbyA9IG5ldyBpcCgpLCBhID0gZS5ib2R5LmdldFJlYWRlcigpLCBsID0gKCkgPT4gYS5yZWFkKCkudGhlbigoYykgPT4ge1xuICAgICAgaWYgKGMuZG9uZSlcbiAgICAgICAgcmV0dXJuIG8uZGF0YUxlbmd0aCAmJiBpKHQsIHIsIG8uZmx1c2goKS5idWZmZXIsIGUpLCBQcm9taXNlLnJlc29sdmUobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgICAgIGNvbnN0IHUgPSBjLnZhbHVlLCBkID0gdS5sZW5ndGg7XG4gICAgICByZXR1cm4gdC5sb2FkZWQgKz0gZCwgZCA8IG4gfHwgby5kYXRhTGVuZ3RoID8gKG8ucHVzaCh1KSwgby5kYXRhTGVuZ3RoID49IG4gJiYgaSh0LCByLCBvLmZsdXNoKCkuYnVmZmVyLCBlKSkgOiBpKHQsIHIsIHUuYnVmZmVyLCBlKSwgbCgpO1xuICAgIH0pLmNhdGNoKCgpID0+IFByb21pc2UucmVqZWN0KCkpO1xuICAgIHJldHVybiBsKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIFF3KHMsIGUpIHtcbiAgY29uc3QgdCA9IHtcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgbW9kZTogXCJjb3JzXCIsXG4gICAgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIixcbiAgICBzaWduYWw6IGUsXG4gICAgaGVhZGVyczogbmV3IHNlbGYuSGVhZGVycyhudCh7fSwgcy5oZWFkZXJzKSlcbiAgfTtcbiAgcmV0dXJuIHMucmFuZ2VFbmQgJiYgdC5oZWFkZXJzLnNldChcIlJhbmdlXCIsIFwiYnl0ZXM9XCIgKyBzLnJhbmdlU3RhcnQgKyBcIi1cIiArIFN0cmluZyhzLnJhbmdlRW5kIC0gMSkpLCB0O1xufVxuZnVuY3Rpb24gZUEocykge1xuICBjb25zdCBlID0gSncuZXhlYyhzKTtcbiAgaWYgKGUpXG4gICAgcmV0dXJuIHBhcnNlSW50KGVbMl0pIC0gcGFyc2VJbnQoZVsxXSkgKyAxO1xufVxuZnVuY3Rpb24gdEEocykge1xuICBjb25zdCBlID0gcy5nZXQoXCJDb250ZW50LVJhbmdlXCIpO1xuICBpZiAoZSkge1xuICAgIGNvbnN0IHIgPSBlQShlKTtcbiAgICBpZiAodWUocikpXG4gICAgICByZXR1cm4gcjtcbiAgfVxuICBjb25zdCB0ID0gcy5nZXQoXCJDb250ZW50LUxlbmd0aFwiKTtcbiAgaWYgKHQpXG4gICAgcmV0dXJuIHBhcnNlSW50KHQpO1xufVxuZnVuY3Rpb24gckEocywgZSkge1xuICByZXR1cm4gbmV3IHNlbGYuUmVxdWVzdChzLnVybCwgZSk7XG59XG5jbGFzcyBzQSBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoZSwgdCwgcikge1xuICAgIHN1cGVyKGUpLCB0aGlzLmNvZGUgPSB2b2lkIDAsIHRoaXMuZGV0YWlscyA9IHZvaWQgMCwgdGhpcy5jb2RlID0gdCwgdGhpcy5kZXRhaWxzID0gcjtcbiAgfVxufVxuY29uc3QgbkEgPSAvXmFnZTpcXHMqW1xcZC5dK1xccyokL2ltO1xuY2xhc3MgWnAge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy54aHJTZXR1cCA9IHZvaWQgMCwgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHZvaWQgMCwgdGhpcy5yZXRyeVRpbWVvdXQgPSB2b2lkIDAsIHRoaXMucmV0cnlEZWxheSA9IHZvaWQgMCwgdGhpcy5jb25maWcgPSBudWxsLCB0aGlzLmNhbGxiYWNrcyA9IG51bGwsIHRoaXMuY29udGV4dCA9IG51bGwsIHRoaXMubG9hZGVyID0gbnVsbCwgdGhpcy5zdGF0cyA9IHZvaWQgMCwgdGhpcy54aHJTZXR1cCA9IGUgJiYgZS54aHJTZXR1cCB8fCBudWxsLCB0aGlzLnN0YXRzID0gbmV3IGZ1KCksIHRoaXMucmV0cnlEZWxheSA9IDA7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IG51bGwsIHRoaXMuYWJvcnRJbnRlcm5hbCgpLCB0aGlzLmxvYWRlciA9IG51bGwsIHRoaXMuY29uZmlnID0gbnVsbCwgdGhpcy5jb250ZXh0ID0gbnVsbCwgdGhpcy54aHJTZXR1cCA9IG51bGw7XG4gIH1cbiAgYWJvcnRJbnRlcm5hbCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5sb2FkZXI7XG4gICAgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXF1ZXN0VGltZW91dCksIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lb3V0KSwgZSAmJiAoZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsLCBlLm9ucHJvZ3Jlc3MgPSBudWxsLCBlLnJlYWR5U3RhdGUgIT09IDQgJiYgKHRoaXMuc3RhdHMuYWJvcnRlZCA9ICEwLCBlLmFib3J0KCkpKTtcbiAgfVxuICBhYm9ydCgpIHtcbiAgICB2YXIgZTtcbiAgICB0aGlzLmFib3J0SW50ZXJuYWwoKSwgKGUgPSB0aGlzLmNhbGxiYWNrcykgIT0gbnVsbCAmJiBlLm9uQWJvcnQgJiYgdGhpcy5jYWxsYmFja3Mub25BYm9ydCh0aGlzLnN0YXRzLCB0aGlzLmNvbnRleHQsIHRoaXMubG9hZGVyKTtcbiAgfVxuICBsb2FkKGUsIHQsIHIpIHtcbiAgICBpZiAodGhpcy5zdGF0cy5sb2FkaW5nLnN0YXJ0KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGVyIGNhbiBvbmx5IGJlIHVzZWQgb25jZS5cIik7XG4gICAgdGhpcy5zdGF0cy5sb2FkaW5nLnN0YXJ0ID0gc2VsZi5wZXJmb3JtYW5jZS5ub3coKSwgdGhpcy5jb250ZXh0ID0gZSwgdGhpcy5jb25maWcgPSB0LCB0aGlzLmNhbGxiYWNrcyA9IHIsIHRoaXMubG9hZEludGVybmFsKCk7XG4gIH1cbiAgbG9hZEludGVybmFsKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZzogZSxcbiAgICAgIGNvbnRleHQ6IHRcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWUgfHwgIXQpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgciA9IHRoaXMubG9hZGVyID0gbmV3IHNlbGYuWE1MSHR0cFJlcXVlc3QoKSwgbiA9IHRoaXMuc3RhdHM7XG4gICAgbi5sb2FkaW5nLmZpcnN0ID0gMCwgbi5sb2FkZWQgPSAwLCBuLmFib3J0ZWQgPSAhMTtcbiAgICBjb25zdCBpID0gdGhpcy54aHJTZXR1cDtcbiAgICBpID8gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICBpZiAoISh0aGlzLmxvYWRlciAhPT0gciB8fCB0aGlzLnN0YXRzLmFib3J0ZWQpKVxuICAgICAgICByZXR1cm4gaShyLCB0LnVybCk7XG4gICAgfSkuY2F0Y2goKG8pID0+IHtcbiAgICAgIGlmICghKHRoaXMubG9hZGVyICE9PSByIHx8IHRoaXMuc3RhdHMuYWJvcnRlZCkpXG4gICAgICAgIHJldHVybiByLm9wZW4oXCJHRVRcIiwgdC51cmwsICEwKSwgaShyLCB0LnVybCk7XG4gICAgfSkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLmxvYWRlciAhPT0gciB8fCB0aGlzLnN0YXRzLmFib3J0ZWQgfHwgdGhpcy5vcGVuQW5kU2VuZFhocihyLCB0LCBlKTtcbiAgICB9KS5jYXRjaCgobykgPT4ge1xuICAgICAgdmFyIGE7XG4gICAgICAoYSA9IHRoaXMuY2FsbGJhY2tzKSA9PSBudWxsIHx8IGEub25FcnJvcih7XG4gICAgICAgIGNvZGU6IHIuc3RhdHVzLFxuICAgICAgICB0ZXh0OiBvLm1lc3NhZ2VcbiAgICAgIH0sIHQsIHIsIG4pO1xuICAgIH0pIDogdGhpcy5vcGVuQW5kU2VuZFhocihyLCB0LCBlKTtcbiAgfVxuICBvcGVuQW5kU2VuZFhocihlLCB0LCByKSB7XG4gICAgZS5yZWFkeVN0YXRlIHx8IGUub3BlbihcIkdFVFwiLCB0LnVybCwgITApO1xuICAgIGNvbnN0IG4gPSB0LmhlYWRlcnMsIHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiBpLFxuICAgICAgbWF4TG9hZFRpbWVNczogb1xuICAgIH0gPSByLmxvYWRQb2xpY3k7XG4gICAgaWYgKG4pXG4gICAgICBmb3IgKGNvbnN0IGEgaW4gbilcbiAgICAgICAgZS5zZXRSZXF1ZXN0SGVhZGVyKGEsIG5bYV0pO1xuICAgIHQucmFuZ2VFbmQgJiYgZS5zZXRSZXF1ZXN0SGVhZGVyKFwiUmFuZ2VcIiwgXCJieXRlcz1cIiArIHQucmFuZ2VTdGFydCArIFwiLVwiICsgKHQucmFuZ2VFbmQgLSAxKSksIGUub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5yZWFkeXN0YXRlY2hhbmdlLmJpbmQodGhpcyksIGUub25wcm9ncmVzcyA9IHRoaXMubG9hZHByb2dyZXNzLmJpbmQodGhpcyksIGUucmVzcG9uc2VUeXBlID0gdC5yZXNwb25zZVR5cGUsIHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpLCByLnRpbWVvdXQgPSBpICYmIHVlKGkpID8gaSA6IG8sIHRoaXMucmVxdWVzdFRpbWVvdXQgPSBzZWxmLnNldFRpbWVvdXQodGhpcy5sb2FkdGltZW91dC5iaW5kKHRoaXMpLCByLnRpbWVvdXQpLCBlLnNlbmQoKTtcbiAgfVxuICByZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQ6IGUsXG4gICAgICBsb2FkZXI6IHQsXG4gICAgICBzdGF0czogclxuICAgIH0gPSB0aGlzO1xuICAgIGlmICghZSB8fCAhdClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuID0gdC5yZWFkeVN0YXRlLCBpID0gdGhpcy5jb25maWc7XG4gICAgaWYgKCFyLmFib3J0ZWQgJiYgbiA+PSAyICYmIChyLmxvYWRpbmcuZmlyc3QgPT09IDAgJiYgKHIubG9hZGluZy5maXJzdCA9IE1hdGgubWF4KHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHIubG9hZGluZy5zdGFydCksIGkudGltZW91dCAhPT0gaS5sb2FkUG9saWN5Lm1heExvYWRUaW1lTXMgJiYgKHNlbGYuY2xlYXJUaW1lb3V0KHRoaXMucmVxdWVzdFRpbWVvdXQpLCBpLnRpbWVvdXQgPSBpLmxvYWRQb2xpY3kubWF4TG9hZFRpbWVNcywgdGhpcy5yZXF1ZXN0VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCh0aGlzLmxvYWR0aW1lb3V0LmJpbmQodGhpcyksIGkubG9hZFBvbGljeS5tYXhMb2FkVGltZU1zIC0gKHIubG9hZGluZy5maXJzdCAtIHIubG9hZGluZy5zdGFydCkpKSksIG4gPT09IDQpKSB7XG4gICAgICBzZWxmLmNsZWFyVGltZW91dCh0aGlzLnJlcXVlc3RUaW1lb3V0KSwgdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsLCB0Lm9ucHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgY29uc3QgYyA9IHQuc3RhdHVzLCB1ID0gdC5yZXNwb25zZVR5cGUgPT09IFwidGV4dFwiID8gdC5yZXNwb25zZVRleHQgOiBudWxsO1xuICAgICAgaWYgKGMgPj0gMjAwICYmIGMgPCAzMDApIHtcbiAgICAgICAgY29uc3QgcCA9IHUgPz8gdC5yZXNwb25zZTtcbiAgICAgICAgaWYgKHAgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBvLCBhO1xuICAgICAgICAgIHIubG9hZGluZy5lbmQgPSBNYXRoLm1heChzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCByLmxvYWRpbmcuZmlyc3QpO1xuICAgICAgICAgIGNvbnN0IHkgPSB0LnJlc3BvbnNlVHlwZSA9PT0gXCJhcnJheWJ1ZmZlclwiID8gcC5ieXRlTGVuZ3RoIDogcC5sZW5ndGg7XG4gICAgICAgICAgci5sb2FkZWQgPSByLnRvdGFsID0geSwgci5id0VzdGltYXRlID0gci50b3RhbCAqIDhlMyAvIChyLmxvYWRpbmcuZW5kIC0gci5sb2FkaW5nLmZpcnN0KTtcbiAgICAgICAgICBjb25zdCBFID0gKG8gPSB0aGlzLmNhbGxiYWNrcykgPT0gbnVsbCA/IHZvaWQgMCA6IG8ub25Qcm9ncmVzcztcbiAgICAgICAgICBFICYmIEUociwgZSwgcCwgdCk7XG4gICAgICAgICAgY29uc3QgYiA9IHtcbiAgICAgICAgICAgIHVybDogdC5yZXNwb25zZVVSTCxcbiAgICAgICAgICAgIGRhdGE6IHAsXG4gICAgICAgICAgICBjb2RlOiBjXG4gICAgICAgICAgfTtcbiAgICAgICAgICAoYSA9IHRoaXMuY2FsbGJhY2tzKSA9PSBudWxsIHx8IGEub25TdWNjZXNzKGIsIHIsIGUsIHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZCA9IGkubG9hZFBvbGljeS5lcnJvclJldHJ5LCBoID0gci5yZXRyeSwgZiA9IHtcbiAgICAgICAgdXJsOiBlLnVybCxcbiAgICAgICAgZGF0YTogdm9pZCAwLFxuICAgICAgICBjb2RlOiBjXG4gICAgICB9O1xuICAgICAgaWYgKHRhKGQsIGgsICExLCBmKSlcbiAgICAgICAgdGhpcy5yZXRyeShkKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgbDtcbiAgICAgICAgcnQuZXJyb3IoYCR7Y30gd2hpbGUgbG9hZGluZyAke2UudXJsfWApLCAobCA9IHRoaXMuY2FsbGJhY2tzKSA9PSBudWxsIHx8IGwub25FcnJvcih7XG4gICAgICAgICAgY29kZTogYyxcbiAgICAgICAgICB0ZXh0OiB0LnN0YXR1c1RleHRcbiAgICAgICAgfSwgZSwgdCwgcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxvYWR0aW1lb3V0KCkge1xuICAgIGlmICghdGhpcy5jb25maWcpIHJldHVybjtcbiAgICBjb25zdCBlID0gdGhpcy5jb25maWcubG9hZFBvbGljeS50aW1lb3V0UmV0cnksIHQgPSB0aGlzLnN0YXRzLnJldHJ5O1xuICAgIGlmICh0YShlLCB0LCAhMCkpXG4gICAgICB0aGlzLnJldHJ5KGUpO1xuICAgIGVsc2Uge1xuICAgICAgdmFyIHI7XG4gICAgICBydC53YXJuKGB0aW1lb3V0IHdoaWxlIGxvYWRpbmcgJHsociA9IHRoaXMuY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IHIudXJsfWApO1xuICAgICAgY29uc3QgbiA9IHRoaXMuY2FsbGJhY2tzO1xuICAgICAgbiAmJiAodGhpcy5hYm9ydEludGVybmFsKCksIG4ub25UaW1lb3V0KHRoaXMuc3RhdHMsIHRoaXMuY29udGV4dCwgdGhpcy5sb2FkZXIpKTtcbiAgICB9XG4gIH1cbiAgcmV0cnkoZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQ6IHQsXG4gICAgICBzdGF0czogclxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMucmV0cnlEZWxheSA9IHl1KGUsIHIucmV0cnkpLCByLnJldHJ5KyssIHJ0Lndhcm4oYCR7c3RhdHVzID8gXCJIVFRQIFN0YXR1cyBcIiArIHN0YXR1cyA6IFwiVGltZW91dFwifSB3aGlsZSBsb2FkaW5nICR7dCA9PSBudWxsID8gdm9pZCAwIDogdC51cmx9LCByZXRyeWluZyAke3IucmV0cnl9LyR7ZS5tYXhOdW1SZXRyeX0gaW4gJHt0aGlzLnJldHJ5RGVsYXl9bXNgKSwgdGhpcy5hYm9ydEludGVybmFsKCksIHRoaXMubG9hZGVyID0gbnVsbCwgc2VsZi5jbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVvdXQpLCB0aGlzLnJldHJ5VGltZW91dCA9IHNlbGYuc2V0VGltZW91dCh0aGlzLmxvYWRJbnRlcm5hbC5iaW5kKHRoaXMpLCB0aGlzLnJldHJ5RGVsYXkpO1xuICB9XG4gIGxvYWRwcm9ncmVzcyhlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc3RhdHM7XG4gICAgdC5sb2FkZWQgPSBlLmxvYWRlZCwgZS5sZW5ndGhDb21wdXRhYmxlICYmICh0LnRvdGFsID0gZS50b3RhbCk7XG4gIH1cbiAgZ2V0Q2FjaGVBZ2UoKSB7XG4gICAgbGV0IGUgPSBudWxsO1xuICAgIGlmICh0aGlzLmxvYWRlciAmJiBuQS50ZXN0KHRoaXMubG9hZGVyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSkge1xuICAgICAgY29uc3QgdCA9IHRoaXMubG9hZGVyLmdldFJlc3BvbnNlSGVhZGVyKFwiYWdlXCIpO1xuICAgICAgZSA9IHQgPyBwYXJzZUZsb2F0KHQpIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH1cbiAgZ2V0UmVzcG9uc2VIZWFkZXIoZSkge1xuICAgIHJldHVybiB0aGlzLmxvYWRlciAmJiBuZXcgUmVnRXhwKGBeJHtlfTpcXFxccypbXFxcXGQuXStcXFxccyokYCwgXCJpbVwiKS50ZXN0KHRoaXMubG9hZGVyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA/IHRoaXMubG9hZGVyLmdldFJlc3BvbnNlSGVhZGVyKGUpIDogbnVsbDtcbiAgfVxufVxuY29uc3QgaUEgPSB7XG4gIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiA4ZTMsXG4gIG1heExvYWRUaW1lTXM6IDJlNCxcbiAgdGltZW91dFJldHJ5OiBudWxsLFxuICBlcnJvclJldHJ5OiBudWxsXG59LCBvQSA9IHR0KHR0KHtcbiAgYXV0b1N0YXJ0TG9hZDogITAsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgc3RhcnRQb3NpdGlvbjogLTEsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZGVmYXVsdEF1ZGlvQ29kZWM6IHZvaWQgMCxcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBkZWJ1ZzogITEsXG4gIC8vIHVzZWQgYnkgbG9nZ2VyXG4gIGNhcExldmVsT25GUFNEcm9wOiAhMSxcbiAgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICBjYXBMZXZlbFRvUGxheWVyU2l6ZTogITEsXG4gIC8vIHVzZWQgYnkgY2FwLWxldmVsLWNvbnRyb2xsZXJcbiAgaWdub3JlRGV2aWNlUGl4ZWxSYXRpbzogITEsXG4gIC8vIHVzZWQgYnkgY2FwLWxldmVsLWNvbnRyb2xsZXJcbiAgbWF4RGV2aWNlUGl4ZWxSYXRpbzogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAvLyB1c2VkIGJ5IGNhcC1sZXZlbC1jb250cm9sbGVyXG4gIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZTogITAsXG4gIGluaXRpYWxMaXZlTWFuaWZlc3RTaXplOiAxLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEJ1ZmZlckxlbmd0aDogMzAsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgYmFja0J1ZmZlckxlbmd0aDogMSAvIDAsXG4gIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgZnJvbnRCdWZmZXJGbHVzaFRocmVzaG9sZDogMSAvIDAsXG4gIHN0YXJ0T25TZWdtZW50Qm91bmRhcnk6ICExLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEJ1ZmZlclNpemU6IDYwICogMWUzICogMWUzLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIG1heEZyYWdMb29rVXBUb2xlcmFuY2U6IDAuMjUsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgbWF4QnVmZmVySG9sZTogMC4xLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyIGFuZCBnYXAtY29udHJvbGxlclxuICBkZXRlY3RTdGFsbFdpdGhDdXJyZW50VGltZU1zOiAxMjUwLFxuICAvLyB1c2VkIGJ5IGdhcC1jb250cm9sbGVyXG4gIGhpZ2hCdWZmZXJXYXRjaGRvZ1BlcmlvZDogMixcbiAgLy8gdXNlZCBieSBnYXAtY29udHJvbGxlclxuICBudWRnZU9mZnNldDogMC4xLFxuICAvLyB1c2VkIGJ5IGdhcC1jb250cm9sbGVyXG4gIG51ZGdlTWF4UmV0cnk6IDMsXG4gIC8vIHVzZWQgYnkgZ2FwLWNvbnRyb2xsZXJcbiAgbnVkZ2VPblZpZGVvSG9sZTogITAsXG4gIC8vIHVzZWQgYnkgZ2FwLWNvbnRyb2xsZXJcbiAgbGl2ZVN5bmNNb2RlOiBcImVkZ2VcIixcbiAgLy8gdXNlZCBieSBzdHJlYW0tY29udHJvbGxlclxuICBsaXZlU3luY0R1cmF0aW9uQ291bnQ6IDMsXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVTeW5jT25TdGFsbEluY3JlYXNlOiAxLFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQ6IDEgLyAwLFxuICAvLyB1c2VkIGJ5IGxhdGVuY3ktY29udHJvbGxlclxuICBsaXZlU3luY0R1cmF0aW9uOiB2b2lkIDAsXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVNYXhMYXRlbmN5RHVyYXRpb246IHZvaWQgMCxcbiAgLy8gdXNlZCBieSBsYXRlbmN5LWNvbnRyb2xsZXJcbiAgbWF4TGl2ZVN5bmNQbGF5YmFja1JhdGU6IDEsXG4gIC8vIHVzZWQgYnkgbGF0ZW5jeS1jb250cm9sbGVyXG4gIGxpdmVEdXJhdGlvbkluZmluaXR5OiAhMSxcbiAgLy8gdXNlZCBieSBidWZmZXItY29udHJvbGxlclxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGJhY2tCdWZmZXJMZW5ndGhcbiAgICovXG4gIGxpdmVCYWNrQnVmZmVyTGVuZ3RoOiBudWxsLFxuICAvLyB1c2VkIGJ5IGJ1ZmZlci1jb250cm9sbGVyXG4gIG1heE1heEJ1ZmZlckxlbmd0aDogNjAwLFxuICAvLyB1c2VkIGJ5IHN0cmVhbS1jb250cm9sbGVyXG4gIGVuYWJsZVdvcmtlcjogITAsXG4gIC8vIHVzZWQgYnkgdHJhbnNtdXhlclxuICB3b3JrZXJQYXRoOiBudWxsLFxuICAvLyB1c2VkIGJ5IHRyYW5zbXV4ZXJcbiAgZW5hYmxlU29mdHdhcmVBRVM6ICEwLFxuICAvLyB1c2VkIGJ5IGRlY3J5cHRlclxuICBzdGFydExldmVsOiB2b2lkIDAsXG4gIC8vIHVzZWQgYnkgbGV2ZWwtY29udHJvbGxlclxuICBzdGFydEZyYWdQcmVmZXRjaDogITEsXG4gIC8vIHVzZWQgYnkgc3RyZWFtLWNvbnRyb2xsZXJcbiAgZnBzRHJvcHBlZE1vbml0b3JpbmdQZXJpb2Q6IDVlMyxcbiAgLy8gdXNlZCBieSBmcHMtY29udHJvbGxlclxuICBmcHNEcm9wcGVkTW9uaXRvcmluZ1RocmVzaG9sZDogMC4yLFxuICAvLyB1c2VkIGJ5IGZwcy1jb250cm9sbGVyXG4gIGFwcGVuZEVycm9yTWF4UmV0cnk6IDMsXG4gIC8vIHVzZWQgYnkgYnVmZmVyLWNvbnRyb2xsZXJcbiAgaWdub3JlUGxheWxpc3RQYXJzaW5nRXJyb3JzOiAhMSxcbiAgbG9hZGVyOiBacCxcbiAgLy8gbG9hZGVyOiBGZXRjaExvYWRlcixcbiAgZkxvYWRlcjogdm9pZCAwLFxuICAvLyB1c2VkIGJ5IGZyYWdtZW50LWxvYWRlclxuICBwTG9hZGVyOiB2b2lkIDAsXG4gIC8vIHVzZWQgYnkgcGxheWxpc3QtbG9hZGVyXG4gIHhoclNldHVwOiB2b2lkIDAsXG4gIC8vIHVzZWQgYnkgeGhyLWxvYWRlclxuICBsaWNlbnNlWGhyU2V0dXA6IHZvaWQgMCxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBsaWNlbnNlUmVzcG9uc2VDYWxsYmFjazogdm9pZCAwLFxuICAvLyB1c2VkIGJ5IGVtZS1jb250cm9sbGVyXG4gIGFickNvbnRyb2xsZXI6IHliLFxuICBidWZmZXJDb250cm9sbGVyOiBsMixcbiAgY2FwTGV2ZWxDb250cm9sbGVyOiBEdSxcbiAgZXJyb3JDb250cm9sbGVyOiBiYixcbiAgZnBzQ29udHJvbGxlcjogY3csXG4gIHN0cmV0Y2hTaG9ydFZpZGVvVHJhY2s6ICExLFxuICAvLyB1c2VkIGJ5IG1wNC1yZW11eGVyXG4gIG1heEF1ZGlvRnJhbWVzRHJpZnQ6IDEsXG4gIC8vIHVzZWQgYnkgbXA0LXJlbXV4ZXJcbiAgZm9yY2VLZXlGcmFtZU9uRGlzY29udGludWl0eTogITAsXG4gIC8vIHVzZWQgYnkgdHMtZGVtdXhlclxuICBhYnJFd21hRmFzdExpdmU6IDMsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYVNsb3dMaXZlOiA5LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFGYXN0Vm9EOiAzLFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFTbG93Vm9EOiA5LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickV3bWFEZWZhdWx0RXN0aW1hdGU6IDVlNSxcbiAgLy8gNTAwIGticHMgIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyRXdtYURlZmF1bHRFc3RpbWF0ZU1heDogNWU2LFxuICAvLyA1IG1icHNcbiAgYWJyQmFuZFdpZHRoRmFjdG9yOiAwLjk1LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIGFickJhbmRXaWR0aFVwRmFjdG9yOiAwLjcsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgYWJyTWF4V2l0aFJlYWxCaXRyYXRlOiAhMSxcbiAgLy8gdXNlZCBieSBhYnItY29udHJvbGxlclxuICBtYXhTdGFydmF0aW9uRGVsYXk6IDQsXG4gIC8vIHVzZWQgYnkgYWJyLWNvbnRyb2xsZXJcbiAgbWF4TG9hZGluZ0RlbGF5OiA0LFxuICAvLyB1c2VkIGJ5IGFici1jb250cm9sbGVyXG4gIG1pbkF1dG9CaXRyYXRlOiAwLFxuICAvLyB1c2VkIGJ5IGhsc1xuICBlbWVFbmFibGVkOiAhMSxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICB3aWRldmluZUxpY2Vuc2VVcmw6IHZvaWQgMCxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBkcm1TeXN0ZW1zOiB7fSxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICBkcm1TeXN0ZW1PcHRpb25zOiB7fSxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICByZXF1ZXN0TWVkaWFLZXlTeXN0ZW1BY2Nlc3NGdW5jOiBZZyxcbiAgLy8gdXNlZCBieSBlbWUtY29udHJvbGxlclxuICByZXF1aXJlS2V5U3lzdGVtQWNjZXNzT25TdGFydDogITEsXG4gIC8vIHVzZWQgYnkgZW1lLWNvbnRyb2xsZXJcbiAgdGVzdEJhbmR3aWR0aDogITAsXG4gIHByb2dyZXNzaXZlOiAhMSxcbiAgbG93TGF0ZW5jeU1vZGU6ICEwLFxuICBjbWNkOiB2b2lkIDAsXG4gIGVuYWJsZURhdGVSYW5nZU1ldGFkYXRhQ3VlczogITAsXG4gIGVuYWJsZUVtc2dNZXRhZGF0YUN1ZXM6ICEwLFxuICBlbmFibGVFbXNnS0xWTWV0YWRhdGE6ICExLFxuICBlbmFibGVJRDNNZXRhZGF0YUN1ZXM6ICEwLFxuICBlbmFibGVJbnRlcnN0aXRpYWxQbGF5YmFjazogITAsXG4gIGludGVyc3RpdGlhbEFwcGVuZEluUGxhY2U6ICEwLFxuICBpbnRlcnN0aXRpYWxMaXZlTG9va0FoZWFkOiAxMCxcbiAgdXNlTWVkaWFDYXBhYmlsaXRpZXM6ICEwLFxuICBwcmVzZXJ2ZU1hbnVhbExldmVsT25FcnJvcjogITEsXG4gIGNlcnRMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDogaUFcbiAgfSxcbiAga2V5TG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiA4ZTMsXG4gICAgICBtYXhMb2FkVGltZU1zOiAyZTQsXG4gICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDEsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMWUzLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDJlNCxcbiAgICAgICAgYmFja29mZjogXCJsaW5lYXJcIlxuICAgICAgfSxcbiAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDgsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMWUzLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDJlNCxcbiAgICAgICAgYmFja29mZjogXCJsaW5lYXJcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbWFuaWZlc3RMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDEgLyAwLFxuICAgICAgbWF4TG9hZFRpbWVNczogMmU0LFxuICAgICAgdGltZW91dFJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICByZXRyeURlbGF5TXM6IDAsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogMFxuICAgICAgfSxcbiAgICAgIGVycm9yUmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDEsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMWUzLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDhlM1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcGxheWxpc3RMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDFlNCxcbiAgICAgIG1heExvYWRUaW1lTXM6IDJlNCxcbiAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMixcbiAgICAgICAgcmV0cnlEZWxheU1zOiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDBcbiAgICAgIH0sXG4gICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAyLFxuICAgICAgICByZXRyeURlbGF5TXM6IDFlMyxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiA4ZTNcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGZyYWdMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDFlNCxcbiAgICAgIG1heExvYWRUaW1lTXM6IDEyZTQsXG4gICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDQsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAwXG4gICAgICB9LFxuICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogNixcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxZTMsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogOGUzXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBzdGVlcmluZ01hbmlmZXN0TG9hZFBvbGljeToge1xuICAgIGRlZmF1bHQ6IHtcbiAgICAgIG1heFRpbWVUb0ZpcnN0Qnl0ZU1zOiAxZTQsXG4gICAgICBtYXhMb2FkVGltZU1zOiAyZTQsXG4gICAgICB0aW1lb3V0UmV0cnk6IHtcbiAgICAgICAgbWF4TnVtUmV0cnk6IDIsXG4gICAgICAgIHJldHJ5RGVsYXlNczogMCxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiAwXG4gICAgICB9LFxuICAgICAgZXJyb3JSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMSxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAxZTMsXG4gICAgICAgIG1heFJldHJ5RGVsYXlNczogOGUzXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBpbnRlcnN0aXRpYWxBc3NldExpc3RMb2FkUG9saWN5OiB7XG4gICAgZGVmYXVsdDoge1xuICAgICAgbWF4VGltZVRvRmlyc3RCeXRlTXM6IDFlNCxcbiAgICAgIG1heExvYWRUaW1lTXM6IDNlNCxcbiAgICAgIHRpbWVvdXRSZXRyeToge1xuICAgICAgICBtYXhOdW1SZXRyeTogMCxcbiAgICAgICAgcmV0cnlEZWxheU1zOiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5TXM6IDBcbiAgICAgIH0sXG4gICAgICBlcnJvclJldHJ5OiB7XG4gICAgICAgIG1heE51bVJldHJ5OiAwLFxuICAgICAgICByZXRyeURlbGF5TXM6IDFlMyxcbiAgICAgICAgbWF4UmV0cnlEZWxheU1zOiA4ZTNcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIFRoZXNlIGRlZmF1bHQgc2V0dGluZ3MgYXJlIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgdGhlIGFib3ZlIHBvbGljaWVzXG4gIC8vIGFuZCBhcmUgbWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgbWFuaWZlc3RMb2FkaW5nVGltZU91dDogMWU0LFxuICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeTogMSxcbiAgbWFuaWZlc3RMb2FkaW5nUmV0cnlEZWxheTogMWUzLFxuICBtYW5pZmVzdExvYWRpbmdNYXhSZXRyeVRpbWVvdXQ6IDY0ZTMsXG4gIGxldmVsTG9hZGluZ1RpbWVPdXQ6IDFlNCxcbiAgbGV2ZWxMb2FkaW5nTWF4UmV0cnk6IDQsXG4gIGxldmVsTG9hZGluZ1JldHJ5RGVsYXk6IDFlMyxcbiAgbGV2ZWxMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NGUzLFxuICBmcmFnTG9hZGluZ1RpbWVPdXQ6IDJlNCxcbiAgZnJhZ0xvYWRpbmdNYXhSZXRyeTogNixcbiAgZnJhZ0xvYWRpbmdSZXRyeURlbGF5OiAxZTMsXG4gIGZyYWdMb2FkaW5nTWF4UmV0cnlUaW1lb3V0OiA2NGUzXG59LCBhQSgpKSwge30sIHtcbiAgc3VidGl0bGVTdHJlYW1Db250cm9sbGVyOiBTdyxcbiAgc3VidGl0bGVUcmFja0NvbnRyb2xsZXI6IGh3LFxuICB0aW1lbGluZUNvbnRyb2xsZXI6IFd3LFxuICBhdWRpb1N0cmVhbUNvbnRyb2xsZXI6IG4yLFxuICBhdWRpb1RyYWNrQ29udHJvbGxlcjogaTIsXG4gIGVtZUNvbnRyb2xsZXI6IF9uLFxuICBjbWNkQ29udHJvbGxlcjogaXcsXG4gIGNvbnRlbnRTdGVlcmluZ0NvbnRyb2xsZXI6IGF3LFxuICBpbnRlcnN0aXRpYWxzQ29udHJvbGxlcjogeHdcbn0pO1xuZnVuY3Rpb24gYUEoKSB7XG4gIHJldHVybiB7XG4gICAgY3VlSGFuZGxlcjogWncsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgZW5hYmxlV2ViVlRUOiAhMCxcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBlbmFibGVJTVNDMTogITAsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgZW5hYmxlQ0VBNzA4Q2FwdGlvbnM6ICEwLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrMUxhYmVsOiBcIkVuZ2xpc2hcIixcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazFMYW5ndWFnZUNvZGU6IFwiZW5cIixcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazJMYWJlbDogXCJTcGFuaXNoXCIsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2syTGFuZ3VhZ2VDb2RlOiBcImVzXCIsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2szTGFiZWw6IFwiVW5rbm93biBDQ1wiLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIGNhcHRpb25zVGV4dFRyYWNrM0xhbmd1YWdlQ29kZTogXCJcIixcbiAgICAvLyB1c2VkIGJ5IHRpbWVsaW5lLWNvbnRyb2xsZXJcbiAgICBjYXB0aW9uc1RleHRUcmFjazRMYWJlbDogXCJVbmtub3duIENDXCIsXG4gICAgLy8gdXNlZCBieSB0aW1lbGluZS1jb250cm9sbGVyXG4gICAgY2FwdGlvbnNUZXh0VHJhY2s0TGFuZ3VhZ2VDb2RlOiBcIlwiLFxuICAgIC8vIHVzZWQgYnkgdGltZWxpbmUtY29udHJvbGxlclxuICAgIHJlbmRlclRleHRUcmFja3NOYXRpdmVseTogITBcbiAgfTtcbn1cbmZ1bmN0aW9uIGxBKHMsIGUsIHQpIHtcbiAgaWYgKChlLmxpdmVTeW5jRHVyYXRpb25Db3VudCB8fCBlLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCkgJiYgKGUubGl2ZVN5bmNEdXJhdGlvbiB8fCBlLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24pKVxuICAgIHRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgaGxzLmpzIGNvbmZpZzogZG9uJ3QgbWl4IHVwIGxpdmVTeW5jRHVyYXRpb25Db3VudC9saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgYW5kIGxpdmVTeW5jRHVyYXRpb24vbGl2ZU1heExhdGVuY3lEdXJhdGlvblwiKTtcbiAgaWYgKGUubGl2ZU1heExhdGVuY3lEdXJhdGlvbkNvdW50ICE9PSB2b2lkIDAgJiYgKGUubGl2ZVN5bmNEdXJhdGlvbkNvdW50ID09PSB2b2lkIDAgfHwgZS5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgPD0gZS5saXZlU3luY0R1cmF0aW9uQ291bnQpKVxuICAgIHRocm93IG5ldyBFcnJvcignSWxsZWdhbCBobHMuanMgY29uZmlnOiBcImxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudFwiIG11c3QgYmUgZ3JlYXRlciB0aGFuIFwibGl2ZVN5bmNEdXJhdGlvbkNvdW50XCInKTtcbiAgaWYgKGUubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdm9pZCAwICYmIChlLmxpdmVTeW5jRHVyYXRpb24gPT09IHZvaWQgMCB8fCBlLmxpdmVNYXhMYXRlbmN5RHVyYXRpb24gPD0gZS5saXZlU3luY0R1cmF0aW9uKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0lsbGVnYWwgaGxzLmpzIGNvbmZpZzogXCJsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uXCIgbXVzdCBiZSBncmVhdGVyIHRoYW4gXCJsaXZlU3luY0R1cmF0aW9uXCInKTtcbiAgY29uc3QgciA9IFRjKHMpLCBuID0gW1wibWFuaWZlc3RcIiwgXCJsZXZlbFwiLCBcImZyYWdcIl0sIGkgPSBbXCJUaW1lT3V0XCIsIFwiTWF4UmV0cnlcIiwgXCJSZXRyeURlbGF5XCIsIFwiTWF4UmV0cnlUaW1lb3V0XCJdO1xuICByZXR1cm4gbi5mb3JFYWNoKChvKSA9PiB7XG4gICAgY29uc3QgYSA9IGAke28gPT09IFwibGV2ZWxcIiA/IFwicGxheWxpc3RcIiA6IG99TG9hZFBvbGljeWAsIGwgPSBlW2FdID09PSB2b2lkIDAsIGMgPSBbXTtcbiAgICBpLmZvckVhY2goKHUpID0+IHtcbiAgICAgIGNvbnN0IGQgPSBgJHtvfUxvYWRpbmcke3V9YCwgaCA9IGVbZF07XG4gICAgICBpZiAoaCAhPT0gdm9pZCAwICYmIGwpIHtcbiAgICAgICAgYy5wdXNoKGQpO1xuICAgICAgICBjb25zdCBmID0gclthXS5kZWZhdWx0O1xuICAgICAgICBzd2l0Y2ggKGVbYV0gPSB7XG4gICAgICAgICAgZGVmYXVsdDogZlxuICAgICAgICB9LCB1KSB7XG4gICAgICAgICAgY2FzZSBcIlRpbWVPdXRcIjpcbiAgICAgICAgICAgIGYubWF4TG9hZFRpbWVNcyA9IGgsIGYubWF4VGltZVRvRmlyc3RCeXRlTXMgPSBoO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIk1heFJldHJ5XCI6XG4gICAgICAgICAgICBmLmVycm9yUmV0cnkubWF4TnVtUmV0cnkgPSBoLCBmLnRpbWVvdXRSZXRyeS5tYXhOdW1SZXRyeSA9IGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiUmV0cnlEZWxheVwiOlxuICAgICAgICAgICAgZi5lcnJvclJldHJ5LnJldHJ5RGVsYXlNcyA9IGgsIGYudGltZW91dFJldHJ5LnJldHJ5RGVsYXlNcyA9IGg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiTWF4UmV0cnlUaW1lb3V0XCI6XG4gICAgICAgICAgICBmLmVycm9yUmV0cnkubWF4UmV0cnlEZWxheU1zID0gaCwgZi50aW1lb3V0UmV0cnkubWF4UmV0cnlEZWxheU1zID0gaDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksIGMubGVuZ3RoICYmIHQud2FybihgaGxzLmpzIGNvbmZpZzogXCIke2Muam9pbignXCIsIFwiJyl9XCIgc2V0dGluZyhzKSBhcmUgZGVwcmVjYXRlZCwgdXNlIFwiJHthfVwiOiAke2F0KGVbYV0pfWApO1xuICB9KSwgdHQodHQoe30sIHIpLCBlKTtcbn1cbmZ1bmN0aW9uIFRjKHMpIHtcbiAgcmV0dXJuIHMgJiYgdHlwZW9mIHMgPT0gXCJvYmplY3RcIiA/IEFycmF5LmlzQXJyYXkocykgPyBzLm1hcChUYykgOiBPYmplY3Qua2V5cyhzKS5yZWR1Y2UoKGUsIHQpID0+IChlW3RdID0gVGMoc1t0XSksIGUpLCB7fSkgOiBzO1xufVxuZnVuY3Rpb24gY0EocywgZSkge1xuICBjb25zdCB0ID0gcy5sb2FkZXI7XG4gIHQgIT09IGxmICYmIHQgIT09IFpwID8gKGUubG9nKFwiW2NvbmZpZ106IEN1c3RvbSBsb2FkZXIgZGV0ZWN0ZWQsIGNhbm5vdCBlbmFibGUgcHJvZ3Jlc3NpdmUgc3RyZWFtaW5nXCIpLCBzLnByb2dyZXNzaXZlID0gITEpIDogWHcoKSAmJiAocy5sb2FkZXIgPSBsZiwgcy5wcm9ncmVzc2l2ZSA9ICEwLCBzLmVuYWJsZVNvZnR3YXJlQUVTID0gITAsIGUubG9nKFwiW2NvbmZpZ106IFByb2dyZXNzaXZlIHN0cmVhbWluZyBlbmFibGVkLCB1c2luZyBGZXRjaExvYWRlclwiKSk7XG59XG5jb25zdCB4byA9IDIsIHVBID0gMC4xLCBkQSA9IDAuMDUsIGhBID0gMTAwO1xuY2xhc3MgZkEgZXh0ZW5kcyBIZyB7XG4gIGNvbnN0cnVjdG9yKGUsIHQpIHtcbiAgICBzdXBlcihcImdhcC1jb250cm9sbGVyXCIsIGUubG9nZ2VyKSwgdGhpcy5obHMgPSB2b2lkIDAsIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gdm9pZCAwLCB0aGlzLm1lZGlhID0gbnVsbCwgdGhpcy5tZWRpYVNvdXJjZSA9IHZvaWQgMCwgdGhpcy5udWRnZVJldHJ5ID0gMCwgdGhpcy5zdGFsbFJlcG9ydGVkID0gITEsIHRoaXMuc3RhbGxlZCA9IG51bGwsIHRoaXMubW92ZWQgPSAhMSwgdGhpcy5zZWVraW5nID0gITEsIHRoaXMuYnVmZmVyZWQgPSB7fSwgdGhpcy5sYXN0Q3VycmVudFRpbWUgPSAwLCB0aGlzLmVuZGVkID0gMCwgdGhpcy53YWl0aW5nID0gMCwgdGhpcy5vbk1lZGlhUGxheWluZyA9ICgpID0+IHtcbiAgICAgIHRoaXMuZW5kZWQgPSAwLCB0aGlzLndhaXRpbmcgPSAwO1xuICAgIH0sIHRoaXMub25NZWRpYVdhaXRpbmcgPSAoKSA9PiB7XG4gICAgICB2YXIgcjtcbiAgICAgIChyID0gdGhpcy5tZWRpYSkgIT0gbnVsbCAmJiByLnNlZWtpbmcgfHwgKHRoaXMud2FpdGluZyA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCksIHRoaXMudGljaygpKTtcbiAgICB9LCB0aGlzLm9uTWVkaWFFbmRlZCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmhscykge1xuICAgICAgICB2YXIgcjtcbiAgICAgICAgdGhpcy5lbmRlZCA9ICgociA9IHRoaXMubWVkaWEpID09IG51bGwgPyB2b2lkIDAgOiByLmN1cnJlbnRUaW1lKSB8fCAxLCB0aGlzLmhscy50cmlnZ2VyKEkuTUVESUFfRU5ERUQsIHtcbiAgICAgICAgICBzdGFsbGVkOiAhMVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB0aGlzLmhscyA9IGUsIHRoaXMuZnJhZ21lbnRUcmFja2VyID0gdCwgdGhpcy5yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIHJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsczogZVxuICAgIH0gPSB0aGlzO1xuICAgIGUgJiYgKGUub24oSS5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpLCBlLm9uKEkuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpLCBlLm9uKEkuQlVGRkVSX0FQUEVOREVELCB0aGlzLm9uQnVmZmVyQXBwZW5kZWQsIHRoaXMpKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsczogZVxuICAgIH0gPSB0aGlzO1xuICAgIGUgJiYgKGUub2ZmKEkuTUVESUFfQVRUQUNIRUQsIHRoaXMub25NZWRpYUF0dGFjaGVkLCB0aGlzKSwgZS5vZmYoSS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyksIGUub2ZmKEkuQlVGRkVSX0FQUEVOREVELCB0aGlzLm9uQnVmZmVyQXBwZW5kZWQsIHRoaXMpKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKSwgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCksIHRoaXMubWVkaWEgPSB0aGlzLmhscyA9IHRoaXMuZnJhZ21lbnRUcmFja2VyID0gbnVsbCwgdGhpcy5tZWRpYVNvdXJjZSA9IHZvaWQgMDtcbiAgfVxuICBvbk1lZGlhQXR0YWNoZWQoZSwgdCkge1xuICAgIHRoaXMuc2V0SW50ZXJ2YWwoaEEpLCB0aGlzLm1lZGlhU291cmNlID0gdC5tZWRpYVNvdXJjZTtcbiAgICBjb25zdCByID0gdGhpcy5tZWRpYSA9IHQubWVkaWE7XG4gICAgY3IociwgXCJwbGF5aW5nXCIsIHRoaXMub25NZWRpYVBsYXlpbmcpLCBjcihyLCBcIndhaXRpbmdcIiwgdGhpcy5vbk1lZGlhV2FpdGluZyksIGNyKHIsIFwiZW5kZWRcIiwgdGhpcy5vbk1lZGlhRW5kZWQpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoZSwgdCkge1xuICAgIHRoaXMuY2xlYXJJbnRlcnZhbCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhOiByXG4gICAgfSA9IHRoaXM7XG4gICAgciAmJiAocHIociwgXCJwbGF5aW5nXCIsIHRoaXMub25NZWRpYVBsYXlpbmcpLCBwcihyLCBcIndhaXRpbmdcIiwgdGhpcy5vbk1lZGlhV2FpdGluZyksIHByKHIsIFwiZW5kZWRcIiwgdGhpcy5vbk1lZGlhRW5kZWQpLCB0aGlzLm1lZGlhID0gbnVsbCksIHRoaXMubWVkaWFTb3VyY2UgPSB2b2lkIDA7XG4gIH1cbiAgb25CdWZmZXJBcHBlbmRlZChlLCB0KSB7XG4gICAgdGhpcy5idWZmZXJlZCA9IHQudGltZVJhbmdlcztcbiAgfVxuICBnZXQgaGFzQnVmZmVyZWQoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuYnVmZmVyZWQpLmxlbmd0aCA+IDA7XG4gIH1cbiAgdGljaygpIHtcbiAgICB2YXIgZTtcbiAgICBpZiAoISgoZSA9IHRoaXMubWVkaWEpICE9IG51bGwgJiYgZS5yZWFkeVN0YXRlKSB8fCAhdGhpcy5oYXNCdWZmZXJlZClcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB0ID0gdGhpcy5tZWRpYS5jdXJyZW50VGltZTtcbiAgICB0aGlzLnBvbGwodCwgdGhpcy5sYXN0Q3VycmVudFRpbWUpLCB0aGlzLmxhc3RDdXJyZW50VGltZSA9IHQ7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgcGxheWhlYWQgaXMgc3R1Y2sgd2l0aGluIGEgZ2FwLCBhbmQgaWYgc28sIGF0dGVtcHRzIHRvIGZyZWUgaXQuXG4gICAqIEEgZ2FwIGlzIGFuIHVuYnVmZmVyZWQgcmFuZ2UgYmV0d2VlbiB0d28gYnVmZmVyZWQgcmFuZ2VzIChvciB0aGUgc3RhcnQgYW5kIHRoZSBmaXJzdCBidWZmZXJlZCByYW5nZSkuXG4gICAqXG4gICAqIEBwYXJhbSBsYXN0Q3VycmVudFRpbWUgLSBQcmV2aW91c2x5IHJlYWQgcGxheWhlYWQgcG9zaXRpb25cbiAgICovXG4gIHBvbGwoZSwgdCkge1xuICAgIHZhciByLCBuO1xuICAgIGNvbnN0IGkgPSAociA9IHRoaXMuaGxzKSA9PSBudWxsID8gdm9pZCAwIDogci5jb25maWc7XG4gICAgaWYgKCFpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSB0aGlzLm1lZGlhO1xuICAgIGlmICghbylcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBzZWVraW5nOiBhXG4gICAgfSA9IG8sIGwgPSB0aGlzLnNlZWtpbmcgJiYgIWEsIGMgPSAhdGhpcy5zZWVraW5nICYmIGEsIHUgPSBvLnBhdXNlZCAmJiAhYSB8fCBvLmVuZGVkIHx8IG8ucGxheWJhY2tSYXRlID09PSAwO1xuICAgIGlmICh0aGlzLnNlZWtpbmcgPSBhLCBlICE9PSB0KSB7XG4gICAgICB0ICYmICh0aGlzLmVuZGVkID0gMCksIHRoaXMubW92ZWQgPSAhMCwgYSB8fCAodGhpcy5udWRnZVJldHJ5ID0gMCwgaS5udWRnZU9uVmlkZW9Ib2xlICYmICF1ICYmIGUgPiB0ICYmIHRoaXMubnVkZ2VPblZpZGVvSG9sZShlLCB0KSksIHRoaXMud2FpdGluZyA9PT0gMCAmJiB0aGlzLnN0YWxsUmVzb2x2ZWQoZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjIHx8IGwpIHtcbiAgICAgIGwgJiYgdGhpcy5zdGFsbFJlc29sdmVkKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodSkge1xuICAgICAgdGhpcy5udWRnZVJldHJ5ID0gMCwgdGhpcy5zdGFsbFJlc29sdmVkKGUpLCAhdGhpcy5lbmRlZCAmJiBvLmVuZGVkICYmIHRoaXMuaGxzICYmICh0aGlzLmVuZGVkID0gZSB8fCAxLCB0aGlzLmhscy50cmlnZ2VyKEkuTUVESUFfRU5ERUQsIHtcbiAgICAgICAgc3RhbGxlZDogITFcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFDZS5nZXRCdWZmZXJlZChvKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMubnVkZ2VSZXRyeSA9IDA7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGQgPSBDZS5idWZmZXJJbmZvKG8sIGUsIDApLCBoID0gZC5uZXh0U3RhcnQgfHwgMCwgZiA9IHRoaXMuZnJhZ21lbnRUcmFja2VyO1xuICAgIGlmIChhICYmIGYgJiYgdGhpcy5obHMpIHtcbiAgICAgIGNvbnN0IEggPSBjZih0aGlzLmhscy5pbkZsaWdodEZyYWdtZW50cywgZSksIEsgPSBkLmxlbiA+IHhvLCBqID0gIWggfHwgSCB8fCBoIC0gZSA+IHhvICYmICFmLmdldFBhcnRpYWxGcmFnbWVudChlKTtcbiAgICAgIGlmIChLIHx8IGopXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMubW92ZWQgPSAhMTtcbiAgICB9XG4gICAgY29uc3QgcCA9IChuID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBuLmxhdGVzdExldmVsRGV0YWlscztcbiAgICBpZiAoIXRoaXMubW92ZWQgJiYgdGhpcy5zdGFsbGVkICE9PSBudWxsICYmIGYpIHtcbiAgICAgIGlmICghKGQubGVuID4gMCkgJiYgIWgpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IEsgPSBNYXRoLm1heChoLCBkLnN0YXJ0IHx8IDApIC0gZSwgQyA9ICEhKHAgIT0gbnVsbCAmJiBwLmxpdmUpID8gcC50YXJnZXRkdXJhdGlvbiAqIDIgOiB4bywgayA9IHNvKGUsIGYpO1xuICAgICAgaWYgKEsgPiAwICYmIChLIDw9IEMgfHwgaykpIHtcbiAgICAgICAgby5wYXVzZWQgfHwgdGhpcy5fdHJ5U2tpcEJ1ZmZlckhvbGUoayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgeSA9IGkuZGV0ZWN0U3RhbGxXaXRoQ3VycmVudFRpbWVNcywgRSA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCksIGIgPSB0aGlzLndhaXRpbmc7XG4gICAgbGV0IFIgPSB0aGlzLnN0YWxsZWQ7XG4gICAgaWYgKFIgPT09IG51bGwpXG4gICAgICBpZiAoYiA+IDAgJiYgRSAtIGIgPCB5KVxuICAgICAgICBSID0gdGhpcy5zdGFsbGVkID0gYjtcbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnN0YWxsZWQgPSBFO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgY29uc3QgQSA9IEUgLSBSO1xuICAgIGlmICghYSAmJiAoQSA+PSB5IHx8IGIpICYmIHRoaXMuaGxzKSB7XG4gICAgICB2YXIgRjtcbiAgICAgIGlmICgoKEYgPSB0aGlzLm1lZGlhU291cmNlKSA9PSBudWxsID8gdm9pZCAwIDogRi5yZWFkeVN0YXRlKSA9PT0gXCJlbmRlZFwiICYmICEocCAhPSBudWxsICYmIHAubGl2ZSkgJiYgTWF0aC5hYnMoZSAtICgocCA9PSBudWxsID8gdm9pZCAwIDogcC5lZGdlKSB8fCAwKSkgPCAxKSB7XG4gICAgICAgIGlmICh0aGlzLmVuZGVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5lbmRlZCA9IGUgfHwgMSwgdGhpcy5obHMudHJpZ2dlcihJLk1FRElBX0VOREVELCB7XG4gICAgICAgICAgc3RhbGxlZDogITBcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9yZXBvcnRTdGFsbChkKSwgIXRoaXMubWVkaWEgfHwgIXRoaXMuaGxzKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IE0gPSBDZS5idWZmZXJJbmZvKG8sIGUsIGkubWF4QnVmZmVySG9sZSk7XG4gICAgdGhpcy5fdHJ5Rml4QnVmZmVyU3RhbGwoTSwgQSwgZSk7XG4gIH1cbiAgc3RhbGxSZXNvbHZlZChlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc3RhbGxlZDtcbiAgICBpZiAodCAmJiB0aGlzLmhscyAmJiAodGhpcy5zdGFsbGVkID0gbnVsbCwgdGhpcy5zdGFsbFJlcG9ydGVkKSkge1xuICAgICAgY29uc3QgciA9IHNlbGYucGVyZm9ybWFuY2Uubm93KCkgLSB0O1xuICAgICAgdGhpcy5sb2coYHBsYXliYWNrIG5vdCBzdHVjayBhbnltb3JlIEAke2V9LCBhZnRlciAke01hdGgucm91bmQocil9bXNgKSwgdGhpcy5zdGFsbFJlcG9ydGVkID0gITEsIHRoaXMud2FpdGluZyA9IDAsIHRoaXMuaGxzLnRyaWdnZXIoSS5TVEFMTF9SRVNPTFZFRCwge30pO1xuICAgIH1cbiAgfVxuICBudWRnZU9uVmlkZW9Ib2xlKGUsIHQpIHtcbiAgICB2YXIgcjtcbiAgICBjb25zdCBuID0gdGhpcy5idWZmZXJlZC52aWRlbztcbiAgICBpZiAodGhpcy5obHMgJiYgdGhpcy5tZWRpYSAmJiB0aGlzLmZyYWdtZW50VHJhY2tlciAmJiAociA9IHRoaXMuYnVmZmVyZWQuYXVkaW8pICE9IG51bGwgJiYgci5sZW5ndGggJiYgbiAmJiBuLmxlbmd0aCA+IDEgJiYgZSA+IG4uZW5kKDApKSB7XG4gICAgICBjb25zdCBpID0gQ2UuYnVmZmVyZWRJbmZvKENlLnRpbWVSYW5nZXNUb0FycmF5KHRoaXMuYnVmZmVyZWQuYXVkaW8pLCBlLCAwKTtcbiAgICAgIGlmIChpLmxlbiA+IDEgJiYgdCA+PSBpLnN0YXJ0KSB7XG4gICAgICAgIGNvbnN0IG8gPSBDZS50aW1lUmFuZ2VzVG9BcnJheShuKSwgYSA9IENlLmJ1ZmZlcmVkSW5mbyhvLCB0LCAwKS5idWZmZXJlZEluZGV4O1xuICAgICAgICBpZiAoYSA+IC0xICYmIGEgPCBvLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjb25zdCBsID0gQ2UuYnVmZmVyZWRJbmZvKG8sIGUsIDApLmJ1ZmZlcmVkSW5kZXgsIGMgPSBvW2FdLmVuZCwgdSA9IG9bYSArIDFdLnN0YXJ0O1xuICAgICAgICAgIGlmICgobCA9PT0gLTEgfHwgbCA+IGEpICYmIHUgLSBjIDwgMSAmJiAvLyBgbWF4QnVmZmVySG9sZWAgbWF5IGJlIHRvbyBzbWFsbCBhbmQgc2V0dGluZyBpdCB0byAwIHNob3VsZCBub3QgZGlzYWJsZSB0aGlzIGZlYXR1cmVcbiAgICAgICAgICBlIC0gYyA8IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBuZXcgRXJyb3IoYG51ZGdpbmcgcGxheWhlYWQgdG8gZmx1c2ggcGlwZWxpbmUgYWZ0ZXIgdmlkZW8gaG9sZS4gY3VycmVudFRpbWU6ICR7ZX0gaG9sZTogJHtjfSAtPiAke3V9IGJ1ZmZlcmVkIGluZGV4OiAke2x9YCk7XG4gICAgICAgICAgICB0aGlzLndhcm4oZC5tZXNzYWdlKSwgdGhpcy5tZWRpYS5jdXJyZW50VGltZSArPSAxZS02O1xuICAgICAgICAgICAgbGV0IGggPSBzbyhlLCB0aGlzLmZyYWdtZW50VHJhY2tlcik7XG4gICAgICAgICAgICBoICYmIFwiZnJhZ21lbnRcIiBpbiBoID8gaCA9IGguZnJhZ21lbnQgOiBoIHx8IChoID0gdm9pZCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBDZS5idWZmZXJJbmZvKHRoaXMubWVkaWEsIGUsIDApO1xuICAgICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihJLkVSUk9SLCB7XG4gICAgICAgICAgICAgIHR5cGU6IHZlLk1FRElBX0VSUk9SLFxuICAgICAgICAgICAgICBkZXRhaWxzOiBKLkJVRkZFUl9TRUVLX09WRVJfSE9MRSxcbiAgICAgICAgICAgICAgZmF0YWw6ICExLFxuICAgICAgICAgICAgICBlcnJvcjogZCxcbiAgICAgICAgICAgICAgcmVhc29uOiBkLm1lc3NhZ2UsXG4gICAgICAgICAgICAgIGZyYWc6IGgsXG4gICAgICAgICAgICAgIGJ1ZmZlcjogZi5sZW4sXG4gICAgICAgICAgICAgIGJ1ZmZlckluZm86IGZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRGV0ZWN0cyBhbmQgYXR0ZW1wdHMgdG8gZml4IGtub3duIGJ1ZmZlciBzdGFsbGluZyBpc3N1ZXMuXG4gICAqIEBwYXJhbSBidWZmZXJJbmZvIC0gVGhlIHByb3BlcnRpZXMgb2YgdGhlIGN1cnJlbnQgYnVmZmVyLlxuICAgKiBAcGFyYW0gc3RhbGxlZER1cmF0aW9uTXMgLSBUaGUgYW1vdW50IG9mIHRpbWUgSGxzLmpzIGhhcyBiZWVuIHN0YWxsaW5nIGZvci5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90cnlGaXhCdWZmZXJTdGFsbChlLCB0LCByKSB7XG4gICAgdmFyIG4sIGk7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ21lbnRUcmFja2VyOiBvLFxuICAgICAgbWVkaWE6IGFcbiAgICB9ID0gdGhpcywgbCA9IChuID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBuLmNvbmZpZztcbiAgICBpZiAoIWEgfHwgIW8gfHwgIWwpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgYyA9IChpID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiBpLmxhdGVzdExldmVsRGV0YWlscywgdSA9IHNvKHIsIG8pO1xuICAgIGlmICgodSB8fCBjICE9IG51bGwgJiYgYy5saXZlICYmIHIgPCBjLmZyYWdtZW50U3RhcnQpICYmICh0aGlzLl90cnlTa2lwQnVmZmVySG9sZSh1KSB8fCAhdGhpcy5tZWRpYSkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgZCA9IGUuYnVmZmVyZWQsIGggPSB0aGlzLmFkamFjZW50VHJhdmVyc2FsKGUsIHIpO1xuICAgIChkICYmIGQubGVuZ3RoID4gMSAmJiBlLmxlbiA+IGwubWF4QnVmZmVySG9sZSB8fCBlLm5leHRTdGFydCAmJiAoZS5uZXh0U3RhcnQgLSByIDwgbC5tYXhCdWZmZXJIb2xlIHx8IGgpKSAmJiAodCA+IGwuaGlnaEJ1ZmZlcldhdGNoZG9nUGVyaW9kICogMWUzIHx8IHRoaXMud2FpdGluZykgJiYgKHRoaXMud2FybihcIlRyeWluZyB0byBudWRnZSBwbGF5aGVhZCBvdmVyIGJ1ZmZlci1ob2xlXCIpLCB0aGlzLl90cnlOdWRnZUJ1ZmZlcihlKSk7XG4gIH1cbiAgYWRqYWNlbnRUcmF2ZXJzYWwoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLmZyYWdtZW50VHJhY2tlciwgbiA9IGUubmV4dFN0YXJ0O1xuICAgIGlmIChyICYmIG4pIHtcbiAgICAgIGNvbnN0IGkgPSByLmdldEZyYWdBdFBvcyh0LCBwZS5NQUlOKSwgbyA9IHIuZ2V0RnJhZ0F0UG9zKG4sIHBlLk1BSU4pO1xuICAgICAgaWYgKGkgJiYgbylcbiAgICAgICAgcmV0dXJuIG8uc24gLSBpLnNuIDwgMjtcbiAgICB9XG4gICAgcmV0dXJuICExO1xuICB9XG4gIC8qKlxuICAgKiBUcmlnZ2VycyBhIEJVRkZFUl9TVEFMTEVEX0VSUk9SIGV2ZW50LCBidXQgb25seSBvbmNlIHBlciBzdGFsbCBwZXJpb2QuXG4gICAqIEBwYXJhbSBidWZmZXJMZW4gLSBUaGUgcGxheWhlYWQgZGlzdGFuY2UgZnJvbSB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IGJ1ZmZlciBzZWdtZW50LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3JlcG9ydFN0YWxsKGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHM6IHQsXG4gICAgICBtZWRpYTogcixcbiAgICAgIHN0YWxsUmVwb3J0ZWQ6IG4sXG4gICAgICBzdGFsbGVkOiBpXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFuICYmIGkgIT09IG51bGwgJiYgciAmJiB0KSB7XG4gICAgICB0aGlzLnN0YWxsUmVwb3J0ZWQgPSAhMDtcbiAgICAgIGNvbnN0IG8gPSBuZXcgRXJyb3IoYFBsYXliYWNrIHN0YWxsaW5nIGF0IEAke3IuY3VycmVudFRpbWV9IGR1ZSB0byBsb3cgYnVmZmVyICgke2F0KGUpfSlgKTtcbiAgICAgIHRoaXMud2FybihvLm1lc3NhZ2UpLCB0LnRyaWdnZXIoSS5FUlJPUiwge1xuICAgICAgICB0eXBlOiB2ZS5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogSi5CVUZGRVJfU1RBTExFRF9FUlJPUixcbiAgICAgICAgZmF0YWw6ICExLFxuICAgICAgICBlcnJvcjogbyxcbiAgICAgICAgYnVmZmVyOiBlLmxlbixcbiAgICAgICAgYnVmZmVySW5mbzogZSxcbiAgICAgICAgc3RhbGxlZDoge1xuICAgICAgICAgIHN0YXJ0OiBpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQXR0ZW1wdHMgdG8gZml4IGJ1ZmZlciBzdGFsbHMgYnkganVtcGluZyBvdmVyIGtub3duIGdhcHMgY2F1c2VkIGJ5IHBhcnRpYWwgZnJhZ21lbnRzXG4gICAqIEBwYXJhbSBhcHBlbmRlZCAtIFRoZSBmcmFnbWVudCBvciBwYXJ0IGZvdW5kIGF0IHRoZSBjdXJyZW50IHRpbWUgKHdoZXJlIHBsYXliYWNrIGlzIHN0YWxsaW5nKS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90cnlTa2lwQnVmZmVySG9sZShlKSB7XG4gICAgdmFyIHQ7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZ21lbnRUcmFja2VyOiByLFxuICAgICAgbWVkaWE6IG5cbiAgICB9ID0gdGhpcywgaSA9ICh0ID0gdGhpcy5obHMpID09IG51bGwgPyB2b2lkIDAgOiB0LmNvbmZpZztcbiAgICBpZiAoIW4gfHwgIXIgfHwgIWkpXG4gICAgICByZXR1cm4gMDtcbiAgICBjb25zdCBvID0gbi5jdXJyZW50VGltZSwgYSA9IENlLmJ1ZmZlckluZm8obiwgbywgMCksIGwgPSBvIDwgYS5zdGFydCA/IGEuc3RhcnQgOiBhLm5leHRTdGFydDtcbiAgICBpZiAobCAmJiB0aGlzLmhscykge1xuICAgICAgY29uc3QgdSA9IGEubGVuIDw9IGkubWF4QnVmZmVySG9sZSwgZCA9IGEubGVuID4gMCAmJiBhLmxlbiA8IDEgJiYgbi5yZWFkeVN0YXRlIDwgMywgaCA9IGwgLSBvO1xuICAgICAgaWYgKGggPiAwICYmICh1IHx8IGQpKSB7XG4gICAgICAgIGlmIChoID4gaS5tYXhCdWZmZXJIb2xlKSB7XG4gICAgICAgICAgbGV0IHAgPSAhMTtcbiAgICAgICAgICBpZiAobyA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgeSA9IHIuZ2V0QXBwZW5kZWRGcmFnKDAsIHBlLk1BSU4pO1xuICAgICAgICAgICAgeSAmJiBsIDwgeS5lbmQgJiYgKHAgPSAhMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcCAmJiBlKSB7XG4gICAgICAgICAgICB2YXIgYztcbiAgICAgICAgICAgIGlmICghKChjID0gdGhpcy5obHMubG9hZExldmVsT2JqKSAhPSBudWxsICYmIGMuZGV0YWlscykgfHwgY2YodGhpcy5obHMuaW5GbGlnaHRGcmFnbWVudHMsIGwpKVxuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGxldCBFID0gITEsIGIgPSBlLmVuZDtcbiAgICAgICAgICAgIGZvciAoOyBiIDwgbDsgKSB7XG4gICAgICAgICAgICAgIGNvbnN0IFIgPSBzbyhiLCByKTtcbiAgICAgICAgICAgICAgaWYgKFIpXG4gICAgICAgICAgICAgICAgYiArPSBSLmR1cmF0aW9uO1xuICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBFID0gITA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChFKVxuICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZiA9IE1hdGgubWF4KGwgKyBkQSwgbyArIHVBKTtcbiAgICAgICAgaWYgKHRoaXMud2Fybihgc2tpcHBpbmcgaG9sZSwgYWRqdXN0aW5nIGN1cnJlbnRUaW1lIGZyb20gJHtvfSB0byAke2Z9YCksIHRoaXMubW92ZWQgPSAhMCwgbi5jdXJyZW50VGltZSA9IGYsICEoZSAhPSBudWxsICYmIGUuZ2FwKSkge1xuICAgICAgICAgIGNvbnN0IHAgPSBuZXcgRXJyb3IoYGZyYWdtZW50IGxvYWRlZCB3aXRoIGJ1ZmZlciBob2xlcywgc2Vla2luZyBmcm9tICR7b30gdG8gJHtmfWApLCB5ID0ge1xuICAgICAgICAgICAgdHlwZTogdmUuTUVESUFfRVJST1IsXG4gICAgICAgICAgICBkZXRhaWxzOiBKLkJVRkZFUl9TRUVLX09WRVJfSE9MRSxcbiAgICAgICAgICAgIGZhdGFsOiAhMSxcbiAgICAgICAgICAgIGVycm9yOiBwLFxuICAgICAgICAgICAgcmVhc29uOiBwLm1lc3NhZ2UsXG4gICAgICAgICAgICBidWZmZXI6IGEubGVuLFxuICAgICAgICAgICAgYnVmZmVySW5mbzogYVxuICAgICAgICAgIH07XG4gICAgICAgICAgZSAmJiAoXCJmcmFnbWVudFwiIGluIGUgPyB5LnBhcnQgPSBlIDogeS5mcmFnID0gZSksIHRoaXMuaGxzLnRyaWdnZXIoSS5FUlJPUiwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGY7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG4gIC8qKlxuICAgKiBBdHRlbXB0cyB0byBmaXggYnVmZmVyIHN0YWxscyBieSBhZHZhbmNpbmcgdGhlIG1lZGlhRWxlbWVudCdzIGN1cnJlbnQgdGltZSBieSBhIHNtYWxsIGFtb3VudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90cnlOdWRnZUJ1ZmZlcihlKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzOiB0LFxuICAgICAgbWVkaWE6IHIsXG4gICAgICBudWRnZVJldHJ5OiBuXG4gICAgfSA9IHRoaXMsIGkgPSB0ID09IG51bGwgPyB2b2lkIDAgOiB0LmNvbmZpZztcbiAgICBpZiAoIXIgfHwgIWkpXG4gICAgICByZXR1cm4gMDtcbiAgICBjb25zdCBvID0gci5jdXJyZW50VGltZTtcbiAgICBpZiAodGhpcy5udWRnZVJldHJ5KyssIG4gPCBpLm51ZGdlTWF4UmV0cnkpIHtcbiAgICAgIGNvbnN0IGEgPSBvICsgKG4gKyAxKSAqIGkubnVkZ2VPZmZzZXQsIGwgPSBuZXcgRXJyb3IoYE51ZGdpbmcgJ2N1cnJlbnRUaW1lJyBmcm9tICR7b30gdG8gJHthfWApO1xuICAgICAgdGhpcy53YXJuKGwubWVzc2FnZSksIHIuY3VycmVudFRpbWUgPSBhLCB0LnRyaWdnZXIoSS5FUlJPUiwge1xuICAgICAgICB0eXBlOiB2ZS5NRURJQV9FUlJPUixcbiAgICAgICAgZGV0YWlsczogSi5CVUZGRVJfTlVER0VfT05fU1RBTEwsXG4gICAgICAgIGVycm9yOiBsLFxuICAgICAgICBmYXRhbDogITEsXG4gICAgICAgIGJ1ZmZlcjogZS5sZW4sXG4gICAgICAgIGJ1ZmZlckluZm86IGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBhID0gbmV3IEVycm9yKGBQbGF5aGVhZCBzdGlsbCBub3QgbW92aW5nIHdoaWxlIGVub3VnaCBkYXRhIGJ1ZmZlcmVkIEAke299IGFmdGVyICR7aS5udWRnZU1heFJldHJ5fSBudWRnZXNgKTtcbiAgICAgIHRoaXMuZXJyb3IoYS5tZXNzYWdlKSwgdC50cmlnZ2VyKEkuRVJST1IsIHtcbiAgICAgICAgdHlwZTogdmUuTUVESUFfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEouQlVGRkVSX1NUQUxMRURfRVJST1IsXG4gICAgICAgIGVycm9yOiBhLFxuICAgICAgICBmYXRhbDogITAsXG4gICAgICAgIGJ1ZmZlcjogZS5sZW4sXG4gICAgICAgIGJ1ZmZlckluZm86IGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY2YocywgZSkge1xuICBjb25zdCB0ID0gdWYocy5tYWluKTtcbiAgaWYgKHQgJiYgdC5zdGFydCA8PSBlKVxuICAgIHJldHVybiB0O1xuICBjb25zdCByID0gdWYocy5hdWRpbyk7XG4gIHJldHVybiByICYmIHIuc3RhcnQgPD0gZSA/IHIgOiBudWxsO1xufVxuZnVuY3Rpb24gdWYocykge1xuICBpZiAoIXMpXG4gICAgcmV0dXJuIG51bGw7XG4gIHN3aXRjaCAocy5zdGF0ZSkge1xuICAgIGNhc2UgbmUuSURMRTpcbiAgICBjYXNlIG5lLlNUT1BQRUQ6XG4gICAgY2FzZSBuZS5FTkRFRDpcbiAgICBjYXNlIG5lLkVSUk9SOlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHMuZnJhZztcbn1cbmZ1bmN0aW9uIHNvKHMsIGUpIHtcbiAgcmV0dXJuIGUuZ2V0QXBwZW5kZWRGcmFnKHMsIHBlLk1BSU4pIHx8IGUuZ2V0UGFydGlhbEZyYWdtZW50KHMpO1xufVxuY29uc3QgZ0EgPSAwLjI1O1xuZnVuY3Rpb24gd2MoKSB7XG4gIGlmICghKHR5cGVvZiBzZWxmID4gXCJ1XCIpKVxuICAgIHJldHVybiBzZWxmLlZUVEN1ZSB8fCBzZWxmLlRleHRUcmFja0N1ZTtcbn1cbmZ1bmN0aW9uIENsKHMsIGUsIHQsIHIsIG4pIHtcbiAgbGV0IGkgPSBuZXcgcyhlLCB0LCBcIlwiKTtcbiAgdHJ5IHtcbiAgICBpLnZhbHVlID0gciwgbiAmJiAoaS50eXBlID0gbik7XG4gIH0gY2F0Y2gge1xuICAgIGkgPSBuZXcgcyhlLCB0LCBhdChuID8gdHQoe1xuICAgICAgdHlwZTogblxuICAgIH0sIHIpIDogcikpO1xuICB9XG4gIHJldHVybiBpO1xufVxuY29uc3Qgbm8gPSAoKCkgPT4ge1xuICBjb25zdCBzID0gd2MoKTtcbiAgdHJ5IHtcbiAgICBzICYmIG5ldyBzKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgXCJcIik7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xuICB9XG4gIHJldHVybiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG59KSgpO1xuY2xhc3MgcEEge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDAsIHRoaXMuaWQzVHJhY2sgPSBudWxsLCB0aGlzLm1lZGlhID0gbnVsbCwgdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fSwgdGhpcy5yZW1vdmVDdWVzID0gITAsIHRoaXMuYXNzZXRDdWUgPSB2b2lkIDAsIHRoaXMub25FdmVudEN1ZUVudGVyID0gKCkgPT4ge1xuICAgICAgdGhpcy5obHMgJiYgdGhpcy5obHMudHJpZ2dlcihJLkVWRU5UX0NVRV9FTlRFUiwge30pO1xuICAgIH0sIHRoaXMuaGxzID0gZSwgdGhpcy5fcmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSwgdGhpcy5pZDNUcmFjayA9IG51bGwsIHRoaXMubWVkaWEgPSBudWxsLCB0aGlzLmRhdGVSYW5nZUN1ZXNBcHBlbmRlZCA9IHt9LCB0aGlzLmhscyA9IHRoaXMub25FdmVudEN1ZUVudGVyID0gbnVsbDtcbiAgfVxuICBfcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzOiBlXG4gICAgfSA9IHRoaXM7XG4gICAgZSAmJiAoZS5vbihJLk1FRElBX0FUVEFDSElORywgdGhpcy5vbk1lZGlhQXR0YWNoaW5nLCB0aGlzKSwgZS5vbihJLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyksIGUub24oSS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyksIGUub24oSS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKSwgZS5vbihJLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nTWV0YWRhdGEsIHRoaXMpLCBlLm9uKEkuQlVGRkVSX0ZMVVNISU5HLCB0aGlzLm9uQnVmZmVyRmx1c2hpbmcsIHRoaXMpLCBlLm9uKEkuTEVWRUxfVVBEQVRFRCwgdGhpcy5vbkxldmVsVXBkYXRlZCwgdGhpcyksIGUub24oSS5MRVZFTF9QVFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsUHRzVXBkYXRlZCwgdGhpcykpO1xuICB9XG4gIF91bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsczogZVxuICAgIH0gPSB0aGlzO1xuICAgIGUgJiYgKGUub2ZmKEkuTUVESUFfQVRUQUNISU5HLCB0aGlzLm9uTWVkaWFBdHRhY2hpbmcsIHRoaXMpLCBlLm9mZihJLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyksIGUub2ZmKEkuTUVESUFfREVUQUNISU5HLCB0aGlzLm9uTWVkaWFEZXRhY2hpbmcsIHRoaXMpLCBlLm9mZihJLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpLCBlLm9mZihJLkZSQUdfUEFSU0lOR19NRVRBREFUQSwgdGhpcy5vbkZyYWdQYXJzaW5nTWV0YWRhdGEsIHRoaXMpLCBlLm9mZihJLkJVRkZFUl9GTFVTSElORywgdGhpcy5vbkJ1ZmZlckZsdXNoaW5nLCB0aGlzKSwgZS5vZmYoSS5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKSwgZS5vZmYoSS5MRVZFTF9QVFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsUHRzVXBkYXRlZCwgdGhpcykpO1xuICB9XG4gIC8vIEFkZCBJRDMgbWV0YXRhZGF0YSB0ZXh0IHRyYWNrLlxuICBvbk1lZGlhQXR0YWNoaW5nKGUsIHQpIHtcbiAgICB2YXIgcjtcbiAgICB0aGlzLm1lZGlhID0gdC5tZWRpYSwgKChyID0gdC5vdmVycmlkZXMpID09IG51bGwgPyB2b2lkIDAgOiByLmN1ZVJlbW92YWwpID09PSAhMSAmJiAodGhpcy5yZW1vdmVDdWVzID0gITEpO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hlZCgpIHtcbiAgICB2YXIgZTtcbiAgICBjb25zdCB0ID0gKGUgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IGUubGF0ZXN0TGV2ZWxEZXRhaWxzO1xuICAgIHQgJiYgdGhpcy51cGRhdGVEYXRlUmFuZ2VDdWVzKHQpO1xuICB9XG4gIG9uTWVkaWFEZXRhY2hpbmcoZSwgdCkge1xuICAgIHRoaXMubWVkaWEgPSBudWxsLCAhdC50cmFuc2Zlck1lZGlhICYmICh0aGlzLmlkM1RyYWNrICYmICh0aGlzLnJlbW92ZUN1ZXMgJiYgU24odGhpcy5pZDNUcmFjaywgdGhpcy5vbkV2ZW50Q3VlRW50ZXIpLCB0aGlzLmlkM1RyYWNrID0gbnVsbCksIHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkID0ge30pO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMuZGF0ZVJhbmdlQ3Vlc0FwcGVuZGVkID0ge307XG4gIH1cbiAgY3JlYXRlVHJhY2soZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmdldElEM1RyYWNrKGUudGV4dFRyYWNrcyk7XG4gICAgcmV0dXJuIHQubW9kZSA9IFwiaGlkZGVuXCIsIHQ7XG4gIH1cbiAgZ2V0SUQzVHJhY2soZSkge1xuICAgIGlmICh0aGlzLm1lZGlhKSB7XG4gICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgY29uc3QgciA9IGVbdF07XG4gICAgICAgIGlmIChyLmtpbmQgPT09IFwibWV0YWRhdGFcIiAmJiByLmxhYmVsID09PSBcImlkM1wiKVxuICAgICAgICAgIHJldHVybiBOcChyLCB0aGlzLm1lZGlhKSwgcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLm1lZGlhLmFkZFRleHRUcmFjayhcIm1ldGFkYXRhXCIsIFwiaWQzXCIpO1xuICAgIH1cbiAgfVxuICBvbkZyYWdQYXJzaW5nTWV0YWRhdGEoZSwgdCkge1xuICAgIGlmICghdGhpcy5tZWRpYSB8fCAhdGhpcy5obHMpXG4gICAgICByZXR1cm47XG4gICAgY29uc3Qge1xuICAgICAgZW5hYmxlRW1zZ01ldGFkYXRhQ3VlczogcixcbiAgICAgIGVuYWJsZUlEM01ldGFkYXRhQ3VlczogblxuICAgIH0gPSB0aGlzLmhscy5jb25maWc7XG4gICAgaWYgKCFyICYmICFuKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIHNhbXBsZXM6IGlcbiAgICB9ID0gdDtcbiAgICB0aGlzLmlkM1RyYWNrIHx8ICh0aGlzLmlkM1RyYWNrID0gdGhpcy5jcmVhdGVUcmFjayh0aGlzLm1lZGlhKSk7XG4gICAgY29uc3QgbyA9IHdjKCk7XG4gICAgaWYgKG8pXG4gICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGkubGVuZ3RoOyBhKyspIHtcbiAgICAgICAgY29uc3QgbCA9IGlbYV0udHlwZTtcbiAgICAgICAgaWYgKGwgPT09IGJyLmVtc2cgJiYgIXIgfHwgIW4pXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGMgPSBocChpW2FdLmRhdGEpLCB1ID0gaVthXS5wdHM7XG4gICAgICAgIGxldCBkID0gdSArIGlbYV0uZHVyYXRpb247XG4gICAgICAgIGQgPiBubyAmJiAoZCA9IG5vKSwgZCAtIHUgPD0gMCAmJiAoZCA9IHUgKyBnQSk7XG4gICAgICAgIGZvciAobGV0IGYgPSAwOyBmIDwgYy5sZW5ndGg7IGYrKykge1xuICAgICAgICAgIGNvbnN0IHAgPSBjW2ZdO1xuICAgICAgICAgIGlmICghZnAocCkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlSWQzQ3VlRW5kcyh1LCBsKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSBDbChvLCB1LCBkLCBwLCBsKTtcbiAgICAgICAgICAgIHkgJiYgdGhpcy5pZDNUcmFjay5hZGRDdWUoeSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gIH1cbiAgdXBkYXRlSWQzQ3VlRW5kcyhlLCB0KSB7XG4gICAgdmFyIHI7XG4gICAgY29uc3QgbiA9IChyID0gdGhpcy5pZDNUcmFjaykgPT0gbnVsbCA/IHZvaWQgMCA6IHIuY3VlcztcbiAgICBpZiAobilcbiAgICAgIGZvciAobGV0IGkgPSBuLmxlbmd0aDsgaS0tOyApIHtcbiAgICAgICAgY29uc3QgbyA9IG5baV07XG4gICAgICAgIG8udHlwZSA9PT0gdCAmJiBvLnN0YXJ0VGltZSA8IGUgJiYgby5lbmRUaW1lID09PSBubyAmJiAoby5lbmRUaW1lID0gZSk7XG4gICAgICB9XG4gIH1cbiAgb25CdWZmZXJGbHVzaGluZyhlLCB7XG4gICAgc3RhcnRPZmZzZXQ6IHQsXG4gICAgZW5kT2Zmc2V0OiByLFxuICAgIHR5cGU6IG5cbiAgfSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkM1RyYWNrOiBpLFxuICAgICAgaGxzOiBvXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFvKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBlbmFibGVFbXNnTWV0YWRhdGFDdWVzOiBhLFxuICAgICAgICBlbmFibGVJRDNNZXRhZGF0YUN1ZXM6IGxcbiAgICAgIH1cbiAgICB9ID0gbztcbiAgICBpZiAoaSAmJiAoYSB8fCBsKSkge1xuICAgICAgbGV0IGM7XG4gICAgICBuID09PSBcImF1ZGlvXCIgPyBjID0gKHUpID0+IHUudHlwZSA9PT0gYnIuYXVkaW9JZDMgJiYgbCA6IG4gPT09IFwidmlkZW9cIiA/IGMgPSAodSkgPT4gdS50eXBlID09PSBici5lbXNnICYmIGEgOiBjID0gKHUpID0+IHUudHlwZSA9PT0gYnIuYXVkaW9JZDMgJiYgbCB8fCB1LnR5cGUgPT09IGJyLmVtc2cgJiYgYSwgU2MoaSwgdCwgciwgYyk7XG4gICAgfVxuICB9XG4gIG9uTGV2ZWxVcGRhdGVkKGUsIHtcbiAgICBkZXRhaWxzOiB0XG4gIH0pIHtcbiAgICB0aGlzLnVwZGF0ZURhdGVSYW5nZUN1ZXModCwgITApO1xuICB9XG4gIG9uTGV2ZWxQdHNVcGRhdGVkKGUsIHQpIHtcbiAgICBNYXRoLmFicyh0LmRyaWZ0KSA+IDAuMDEgJiYgdGhpcy51cGRhdGVEYXRlUmFuZ2VDdWVzKHQuZGV0YWlscyk7XG4gIH1cbiAgdXBkYXRlRGF0ZVJhbmdlQ3VlcyhlLCB0KSB7XG4gICAgaWYgKCF0aGlzLmhscyB8fCAhdGhpcy5tZWRpYSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7XG4gICAgICBhc3NldFBsYXllcklkOiByLFxuICAgICAgdGltZWxpbmVPZmZzZXQ6IG4sXG4gICAgICBlbmFibGVEYXRlUmFuZ2VNZXRhZGF0YUN1ZXM6IGksXG4gICAgICBpbnRlcnN0aXRpYWxzQ29udHJvbGxlcjogb1xuICAgIH0gPSB0aGlzLmhscy5jb25maWc7XG4gICAgaWYgKCFpKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGEgPSB3YygpO1xuICAgIGlmIChyICYmIG4gJiYgIW8pIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZnJhZ21lbnRTdGFydDogeSxcbiAgICAgICAgZnJhZ21lbnRFbmQ6IEVcbiAgICAgIH0gPSBlO1xuICAgICAgbGV0IGIgPSB0aGlzLmFzc2V0Q3VlO1xuICAgICAgYiA/IChiLnN0YXJ0VGltZSA9IHksIGIuZW5kVGltZSA9IEUpIDogYSAmJiAoYiA9IHRoaXMuYXNzZXRDdWUgPSBDbChhLCB5LCBFLCB7XG4gICAgICAgIGFzc2V0UGxheWVySWQ6IHRoaXMuaGxzLmNvbmZpZy5hc3NldFBsYXllcklkXG4gICAgICB9LCBcImhsc2pzLmludGVyc3RpdGlhbC5hc3NldFwiKSwgYiAmJiAoYi5pZCA9IHIsIHRoaXMuaWQzVHJhY2sgfHwgKHRoaXMuaWQzVHJhY2sgPSB0aGlzLmNyZWF0ZVRyYWNrKHRoaXMubWVkaWEpKSwgdGhpcy5pZDNUcmFjay5hZGRDdWUoYiksIGIuYWRkRXZlbnRMaXN0ZW5lcihcImVudGVyXCIsIHRoaXMub25FdmVudEN1ZUVudGVyKSkpO1xuICAgIH1cbiAgICBpZiAoIWUuaGFzUHJvZ3JhbURhdGVUaW1lKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGlkM1RyYWNrOiBsXG4gICAgfSA9IHRoaXMsIHtcbiAgICAgIGRhdGVSYW5nZXM6IGNcbiAgICB9ID0gZSwgdSA9IE9iamVjdC5rZXlzKGMpO1xuICAgIGxldCBkID0gdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQ7XG4gICAgaWYgKGwgJiYgdCkge1xuICAgICAgdmFyIGg7XG4gICAgICBpZiAoKGggPSBsLmN1ZXMpICE9IG51bGwgJiYgaC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgeSA9IE9iamVjdC5rZXlzKGQpLmZpbHRlcigoRSkgPT4gIXUuaW5jbHVkZXMoRSkpO1xuICAgICAgICBmb3IgKGxldCBFID0geS5sZW5ndGg7IEUtLTsgKSB7XG4gICAgICAgICAgdmFyIGY7XG4gICAgICAgICAgY29uc3QgYiA9IHlbRV0sIFIgPSAoZiA9IGRbYl0pID09IG51bGwgPyB2b2lkIDAgOiBmLmN1ZXM7XG4gICAgICAgICAgZGVsZXRlIGRbYl0sIFIgJiYgT2JqZWN0LmtleXMoUikuZm9yRWFjaCgoQSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgRiA9IFJbQV07XG4gICAgICAgICAgICBpZiAoRikge1xuICAgICAgICAgICAgICBGLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlbnRlclwiLCB0aGlzLm9uRXZlbnRDdWVFbnRlcik7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbC5yZW1vdmVDdWUoRik7XG4gICAgICAgICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZVxuICAgICAgICBkID0gdGhpcy5kYXRlUmFuZ2VDdWVzQXBwZW5kZWQgPSB7fTtcbiAgICB9XG4gICAgY29uc3QgcCA9IGUuZnJhZ21lbnRzW2UuZnJhZ21lbnRzLmxlbmd0aCAtIDFdO1xuICAgIGlmICghKHUubGVuZ3RoID09PSAwIHx8ICF1ZShwID09IG51bGwgPyB2b2lkIDAgOiBwLnByb2dyYW1EYXRlVGltZSkpKSB7XG4gICAgICB0aGlzLmlkM1RyYWNrIHx8ICh0aGlzLmlkM1RyYWNrID0gdGhpcy5jcmVhdGVUcmFjayh0aGlzLm1lZGlhKSk7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHUubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgY29uc3QgRSA9IHVbeV0sIGIgPSBjW0VdLCBSID0gYi5zdGFydFRpbWUsIEEgPSBkW0VdLCBGID0gKEEgPT0gbnVsbCA/IHZvaWQgMCA6IEEuY3VlcykgfHwge307XG4gICAgICAgIGxldCBNID0gKEEgPT0gbnVsbCA/IHZvaWQgMCA6IEEuZHVyYXRpb25Lbm93bikgfHwgITEsIEggPSBubztcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGR1cmF0aW9uOiBLLFxuICAgICAgICAgIGVuZERhdGU6IGpcbiAgICAgICAgfSA9IGI7XG4gICAgICAgIGlmIChqICYmIEsgIT09IG51bGwpXG4gICAgICAgICAgSCA9IFIgKyBLLCBNID0gITA7XG4gICAgICAgIGVsc2UgaWYgKGIuZW5kT25OZXh0ICYmICFNKSB7XG4gICAgICAgICAgY29uc3QgayA9IHUucmVkdWNlKCgkLCBXKSA9PiB7XG4gICAgICAgICAgICBpZiAoVyAhPT0gYi5pZCkge1xuICAgICAgICAgICAgICBjb25zdCBfID0gY1tXXTtcbiAgICAgICAgICAgICAgaWYgKF8uY2xhc3MgPT09IGIuY2xhc3MgJiYgXy5zdGFydERhdGUgPiBiLnN0YXJ0RGF0ZSAmJiAoISQgfHwgYi5zdGFydERhdGUgPCAkLnN0YXJ0RGF0ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIF87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJDtcbiAgICAgICAgICB9LCBudWxsKTtcbiAgICAgICAgICBrICYmIChIID0gay5zdGFydFRpbWUsIE0gPSAhMCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgQyA9IE9iamVjdC5rZXlzKGIuYXR0cik7XG4gICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgQy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIGNvbnN0ICQgPSBDW2tdO1xuICAgICAgICAgIGlmICghT2IoJCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBjb25zdCBXID0gRlskXTtcbiAgICAgICAgICBpZiAoVylcbiAgICAgICAgICAgIE0gJiYgIShBICE9IG51bGwgJiYgQS5kdXJhdGlvbktub3duKSA/IFcuZW5kVGltZSA9IEggOiBNYXRoLmFicyhXLnN0YXJ0VGltZSAtIFIpID4gMC4wMSAmJiAoVy5zdGFydFRpbWUgPSBSLCBXLmVuZFRpbWUgPSBIKTtcbiAgICAgICAgICBlbHNlIGlmIChhKSB7XG4gICAgICAgICAgICBsZXQgXyA9IGIuYXR0clskXTtcbiAgICAgICAgICAgIEJiKCQpICYmIChfID0gSWcoXykpO1xuICAgICAgICAgICAgY29uc3QgeCA9IENsKGEsIFIsIEgsIHtcbiAgICAgICAgICAgICAga2V5OiAkLFxuICAgICAgICAgICAgICBkYXRhOiBfXG4gICAgICAgICAgICB9LCBici5kYXRlUmFuZ2UpO1xuICAgICAgICAgICAgeCAmJiAoeC5pZCA9IEUsIHRoaXMuaWQzVHJhY2suYWRkQ3VlKHgpLCBGWyRdID0geCwgbyAmJiAoJCA9PT0gXCJYLUFTU0VULUxJU1RcIiB8fCAkID09PSBcIlgtQVNTRVQtVVJMXCIpICYmIHguYWRkRXZlbnRMaXN0ZW5lcihcImVudGVyXCIsIHRoaXMub25FdmVudEN1ZUVudGVyKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRbRV0gPSB7XG4gICAgICAgICAgY3VlczogRixcbiAgICAgICAgICBkYXRlUmFuZ2U6IGIsXG4gICAgICAgICAgZHVyYXRpb25Lbm93bjogTVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY2xhc3MgbUEge1xuICBjb25zdHJ1Y3RvcihlKSB7XG4gICAgdGhpcy5obHMgPSB2b2lkIDAsIHRoaXMuY29uZmlnID0gdm9pZCAwLCB0aGlzLm1lZGlhID0gbnVsbCwgdGhpcy5jdXJyZW50VGltZSA9IDAsIHRoaXMuc3RhbGxDb3VudCA9IDAsIHRoaXMuX2xhdGVuY3kgPSBudWxsLCB0aGlzLl90YXJnZXRMYXRlbmN5VXBkYXRlZCA9ICExLCB0aGlzLm9uVGltZXVwZGF0ZSA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbWVkaWE6IHRcbiAgICAgIH0gPSB0aGlzLCByID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgICBpZiAoIXQgfHwgIXIpXG4gICAgICAgIHJldHVybjtcbiAgICAgIHRoaXMuY3VycmVudFRpbWUgPSB0LmN1cnJlbnRUaW1lO1xuICAgICAgY29uc3QgbiA9IHRoaXMuY29tcHV0ZUxhdGVuY3koKTtcbiAgICAgIGlmIChuID09PSBudWxsKVxuICAgICAgICByZXR1cm47XG4gICAgICB0aGlzLl9sYXRlbmN5ID0gbjtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbG93TGF0ZW5jeU1vZGU6IGksXG4gICAgICAgIG1heExpdmVTeW5jUGxheWJhY2tSYXRlOiBvXG4gICAgICB9ID0gdGhpcy5jb25maWc7XG4gICAgICBpZiAoIWkgfHwgbyA9PT0gMSB8fCAhci5saXZlKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBhID0gdGhpcy50YXJnZXRMYXRlbmN5O1xuICAgICAgaWYgKGEgPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IGwgPSBuIC0gYSwgYyA9IE1hdGgubWluKHRoaXMubWF4TGF0ZW5jeSwgYSArIHIudGFyZ2V0ZHVyYXRpb24pO1xuICAgICAgaWYgKGwgPCBjICYmIGwgPiAwLjA1ICYmIHRoaXMuZm9yd2FyZEJ1ZmZlckxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3QgZCA9IE1hdGgubWluKDIsIE1hdGgubWF4KDEsIG8pKSwgaCA9IE1hdGgucm91bmQoMiAvICgxICsgTWF0aC5leHAoLTAuNzUgKiBsIC0gdGhpcy5lZGdlU3RhbGxlZCkpICogMjApIC8gMjAsIGYgPSBNYXRoLm1pbihkLCBNYXRoLm1heCgxLCBoKSk7XG4gICAgICAgIHRoaXMuY2hhbmdlTWVkaWFQbGF5YmFja1JhdGUodCwgZik7XG4gICAgICB9IGVsc2UgdC5wbGF5YmFja1JhdGUgIT09IDEgJiYgdC5wbGF5YmFja1JhdGUgIT09IDAgJiYgdGhpcy5jaGFuZ2VNZWRpYVBsYXliYWNrUmF0ZSh0LCAxKTtcbiAgICB9LCB0aGlzLmhscyA9IGUsIHRoaXMuY29uZmlnID0gZS5jb25maWcsIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICBnZXQgbGV2ZWxEZXRhaWxzKCkge1xuICAgIHZhciBlO1xuICAgIHJldHVybiAoKGUgPSB0aGlzLmhscykgPT0gbnVsbCA/IHZvaWQgMCA6IGUubGF0ZXN0TGV2ZWxEZXRhaWxzKSB8fCBudWxsO1xuICB9XG4gIGdldCBsYXRlbmN5KCkge1xuICAgIHJldHVybiB0aGlzLl9sYXRlbmN5IHx8IDA7XG4gIH1cbiAgZ2V0IG1heExhdGVuY3koKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29uZmlnOiBlXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKGUubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdm9pZCAwKVxuICAgICAgcmV0dXJuIGUubGl2ZU1heExhdGVuY3lEdXJhdGlvbjtcbiAgICBjb25zdCB0ID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgcmV0dXJuIHQgPyBlLmxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudCAqIHQudGFyZ2V0ZHVyYXRpb24gOiAwO1xuICB9XG4gIGdldCB0YXJnZXRMYXRlbmN5KCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmxldmVsRGV0YWlscztcbiAgICBpZiAoZSA9PT0gbnVsbCB8fCB0aGlzLmhscyA9PT0gbnVsbClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHtcbiAgICAgIGhvbGRCYWNrOiB0LFxuICAgICAgcGFydEhvbGRCYWNrOiByLFxuICAgICAgdGFyZ2V0ZHVyYXRpb246IG5cbiAgICB9ID0gZSwge1xuICAgICAgbGl2ZVN5bmNEdXJhdGlvbjogaSxcbiAgICAgIGxpdmVTeW5jRHVyYXRpb25Db3VudDogbyxcbiAgICAgIGxvd0xhdGVuY3lNb2RlOiBhXG4gICAgfSA9IHRoaXMuY29uZmlnLCBsID0gdGhpcy5obHMudXNlckNvbmZpZztcbiAgICBsZXQgYyA9IGEgJiYgciB8fCB0O1xuICAgICh0aGlzLl90YXJnZXRMYXRlbmN5VXBkYXRlZCB8fCBsLmxpdmVTeW5jRHVyYXRpb24gfHwgbC5saXZlU3luY0R1cmF0aW9uQ291bnQgfHwgYyA9PT0gMCkgJiYgKGMgPSBpICE9PSB2b2lkIDAgPyBpIDogbyAqIG4pO1xuICAgIGNvbnN0IHUgPSBuO1xuICAgIHJldHVybiBjICsgTWF0aC5taW4odGhpcy5zdGFsbENvdW50ICogdGhpcy5jb25maWcubGl2ZVN5bmNPblN0YWxsSW5jcmVhc2UsIHUpO1xuICB9XG4gIHNldCB0YXJnZXRMYXRlbmN5KGUpIHtcbiAgICB0aGlzLnN0YWxsQ291bnQgPSAwLCB0aGlzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uID0gZSwgdGhpcy5fdGFyZ2V0TGF0ZW5jeVVwZGF0ZWQgPSAhMDtcbiAgfVxuICBnZXQgbGl2ZVN5bmNQb3NpdGlvbigpIHtcbiAgICBjb25zdCBlID0gdGhpcy5lc3RpbWF0ZUxpdmVFZGdlKCksIHQgPSB0aGlzLnRhcmdldExhdGVuY3k7XG4gICAgaWYgKGUgPT09IG51bGwgfHwgdCA9PT0gbnVsbClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IHIgPSB0aGlzLmxldmVsRGV0YWlscztcbiAgICBpZiAociA9PT0gbnVsbClcbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IG4gPSByLmVkZ2UsIGkgPSBlIC0gdCAtIHRoaXMuZWRnZVN0YWxsZWQsIG8gPSBuIC0gci50b3RhbGR1cmF0aW9uLCBhID0gbiAtICh0aGlzLmNvbmZpZy5sb3dMYXRlbmN5TW9kZSAmJiByLnBhcnRUYXJnZXQgfHwgci50YXJnZXRkdXJhdGlvbik7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG8sIGkpLCBhKTtcbiAgfVxuICBnZXQgZHJpZnQoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMubGV2ZWxEZXRhaWxzO1xuICAgIHJldHVybiBlID09PSBudWxsID8gMSA6IGUuZHJpZnQ7XG4gIH1cbiAgZ2V0IGVkZ2VTdGFsbGVkKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmxldmVsRGV0YWlscztcbiAgICBpZiAoZSA9PT0gbnVsbClcbiAgICAgIHJldHVybiAwO1xuICAgIGNvbnN0IHQgPSAodGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgJiYgZS5wYXJ0VGFyZ2V0IHx8IGUudGFyZ2V0ZHVyYXRpb24pICogMztcbiAgICByZXR1cm4gTWF0aC5tYXgoZS5hZ2UgLSB0LCAwKTtcbiAgfVxuICBnZXQgZm9yd2FyZEJ1ZmZlckxlbmd0aCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYTogZVxuICAgIH0gPSB0aGlzLCB0ID0gdGhpcy5sZXZlbERldGFpbHM7XG4gICAgaWYgKCFlIHx8ICF0KVxuICAgICAgcmV0dXJuIDA7XG4gICAgY29uc3QgciA9IGUuYnVmZmVyZWQubGVuZ3RoO1xuICAgIHJldHVybiAociA/IGUuYnVmZmVyZWQuZW5kKHIgLSAxKSA6IHQuZWRnZSkgLSB0aGlzLmN1cnJlbnRUaW1lO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy51bnJlZ2lzdGVyTGlzdGVuZXJzKCksIHRoaXMub25NZWRpYURldGFjaGluZygpLCB0aGlzLmhscyA9IG51bGw7XG4gIH1cbiAgcmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzOiBlXG4gICAgfSA9IHRoaXM7XG4gICAgZSAmJiAoZS5vbihJLk1FRElBX0FUVEFDSEVELCB0aGlzLm9uTWVkaWFBdHRhY2hlZCwgdGhpcyksIGUub24oSS5NRURJQV9ERVRBQ0hJTkcsIHRoaXMub25NZWRpYURldGFjaGluZywgdGhpcyksIGUub24oSS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKSwgZS5vbihJLkxFVkVMX1VQREFURUQsIHRoaXMub25MZXZlbFVwZGF0ZWQsIHRoaXMpLCBlLm9uKEkuRVJST1IsIHRoaXMub25FcnJvciwgdGhpcykpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGxzOiBlXG4gICAgfSA9IHRoaXM7XG4gICAgZSAmJiAoZS5vZmYoSS5NRURJQV9BVFRBQ0hFRCwgdGhpcy5vbk1lZGlhQXR0YWNoZWQsIHRoaXMpLCBlLm9mZihJLk1FRElBX0RFVEFDSElORywgdGhpcy5vbk1lZGlhRGV0YWNoaW5nLCB0aGlzKSwgZS5vZmYoSS5NQU5JRkVTVF9MT0FESU5HLCB0aGlzLm9uTWFuaWZlc3RMb2FkaW5nLCB0aGlzKSwgZS5vZmYoSS5MRVZFTF9VUERBVEVELCB0aGlzLm9uTGV2ZWxVcGRhdGVkLCB0aGlzKSwgZS5vZmYoSS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKSk7XG4gIH1cbiAgb25NZWRpYUF0dGFjaGVkKGUsIHQpIHtcbiAgICB0aGlzLm1lZGlhID0gdC5tZWRpYSwgdGhpcy5tZWRpYS5hZGRFdmVudExpc3RlbmVyKFwidGltZXVwZGF0ZVwiLCB0aGlzLm9uVGltZXVwZGF0ZSk7XG4gIH1cbiAgb25NZWRpYURldGFjaGluZygpIHtcbiAgICB0aGlzLm1lZGlhICYmICh0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0aW1ldXBkYXRlXCIsIHRoaXMub25UaW1ldXBkYXRlKSwgdGhpcy5tZWRpYSA9IG51bGwpO1xuICB9XG4gIG9uTWFuaWZlc3RMb2FkaW5nKCkge1xuICAgIHRoaXMuX2xhdGVuY3kgPSBudWxsLCB0aGlzLnN0YWxsQ291bnQgPSAwO1xuICB9XG4gIG9uTGV2ZWxVcGRhdGVkKGUsIHtcbiAgICBkZXRhaWxzOiB0XG4gIH0pIHtcbiAgICB0LmFkdmFuY2VkICYmIHRoaXMub25UaW1ldXBkYXRlKCksICF0LmxpdmUgJiYgdGhpcy5tZWRpYSAmJiB0aGlzLm1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0aW1ldXBkYXRlXCIsIHRoaXMub25UaW1ldXBkYXRlKTtcbiAgfVxuICBvbkVycm9yKGUsIHQpIHtcbiAgICB2YXIgcjtcbiAgICB0LmRldGFpbHMgPT09IEouQlVGRkVSX1NUQUxMRURfRVJST1IgJiYgKHRoaXMuc3RhbGxDb3VudCsrLCB0aGlzLmhscyAmJiAociA9IHRoaXMubGV2ZWxEZXRhaWxzKSAhPSBudWxsICYmIHIubGl2ZSAmJiB0aGlzLmhscy5sb2dnZXIud2FybihcIltsYXRlbmN5LWNvbnRyb2xsZXJdOiBTdGFsbCBkZXRlY3RlZCwgYWRqdXN0aW5nIHRhcmdldCBsYXRlbmN5XCIpKTtcbiAgfVxuICBjaGFuZ2VNZWRpYVBsYXliYWNrUmF0ZShlLCB0KSB7XG4gICAgdmFyIHIsIG47XG4gICAgZS5wbGF5YmFja1JhdGUgIT09IHQgJiYgKChyID0gdGhpcy5obHMpID09IG51bGwgfHwgci5sb2dnZXIuZGVidWcoYFtsYXRlbmN5LWNvbnRyb2xsZXJdOiBsYXRlbmN5PSR7dGhpcy5sYXRlbmN5LnRvRml4ZWQoMyl9LCB0YXJnZXRMYXRlbmN5PSR7KG4gPSB0aGlzLnRhcmdldExhdGVuY3kpID09IG51bGwgPyB2b2lkIDAgOiBuLnRvRml4ZWQoMyl9LCBmb3J3YXJkQnVmZmVyTGVuZ3RoPSR7dGhpcy5mb3J3YXJkQnVmZmVyTGVuZ3RoLnRvRml4ZWQoMyl9OiBhZGp1c3RpbmcgcGxheWJhY2sgcmF0ZSBmcm9tICR7ZS5wbGF5YmFja1JhdGV9IHRvICR7dH1gKSwgZS5wbGF5YmFja1JhdGUgPSB0KTtcbiAgfVxuICBlc3RpbWF0ZUxpdmVFZGdlKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmxldmVsRGV0YWlscztcbiAgICByZXR1cm4gZSA9PT0gbnVsbCA/IG51bGwgOiBlLmVkZ2UgKyBlLmFnZTtcbiAgfVxuICBjb21wdXRlTGF0ZW5jeSgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5lc3RpbWF0ZUxpdmVFZGdlKCk7XG4gICAgcmV0dXJuIGUgPT09IG51bGwgPyBudWxsIDogZSAtIHRoaXMuY3VycmVudFRpbWU7XG4gIH1cbn1cbmNsYXNzIHlBIGV4dGVuZHMga3Uge1xuICBjb25zdHJ1Y3RvcihlLCB0KSB7XG4gICAgc3VwZXIoZSwgXCJsZXZlbC1jb250cm9sbGVyXCIpLCB0aGlzLl9sZXZlbHMgPSBbXSwgdGhpcy5fZmlyc3RMZXZlbCA9IC0xLCB0aGlzLl9tYXhBdXRvTGV2ZWwgPSAtMSwgdGhpcy5fc3RhcnRMZXZlbCA9IHZvaWQgMCwgdGhpcy5jdXJyZW50TGV2ZWwgPSBudWxsLCB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gLTEsIHRoaXMubWFudWFsTGV2ZWxJbmRleCA9IC0xLCB0aGlzLnN0ZWVyaW5nID0gdm9pZCAwLCB0aGlzLm9uUGFyc2VkQ29tcGxldGUgPSB2b2lkIDAsIHRoaXMuc3RlZXJpbmcgPSB0LCB0aGlzLl9yZWdpc3Rlckxpc3RlbmVycygpO1xuICB9XG4gIF9yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHM6IGVcbiAgICB9ID0gdGhpcztcbiAgICBlLm9uKEkuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyksIGUub24oSS5NQU5JRkVTVF9MT0FERUQsIHRoaXMub25NYW5pZmVzdExvYWRlZCwgdGhpcyksIGUub24oSS5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyksIGUub24oSS5MRVZFTFNfVVBEQVRFRCwgdGhpcy5vbkxldmVsc1VwZGF0ZWQsIHRoaXMpLCBlLm9uKEkuRlJBR19CVUZGRVJFRCwgdGhpcy5vbkZyYWdCdWZmZXJlZCwgdGhpcyksIGUub24oSS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICBfdW5yZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHM6IGVcbiAgICB9ID0gdGhpcztcbiAgICBlLm9mZihJLk1BTklGRVNUX0xPQURJTkcsIHRoaXMub25NYW5pZmVzdExvYWRpbmcsIHRoaXMpLCBlLm9mZihJLk1BTklGRVNUX0xPQURFRCwgdGhpcy5vbk1hbmlmZXN0TG9hZGVkLCB0aGlzKSwgZS5vZmYoSS5MRVZFTF9MT0FERUQsIHRoaXMub25MZXZlbExvYWRlZCwgdGhpcyksIGUub2ZmKEkuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKSwgZS5vZmYoSS5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKSwgZS5vZmYoSS5FUlJPUiwgdGhpcy5vbkVycm9yLCB0aGlzKTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuX3VucmVnaXN0ZXJMaXN0ZW5lcnMoKSwgdGhpcy5zdGVlcmluZyA9IG51bGwsIHRoaXMucmVzZXRMZXZlbHMoKSwgc3VwZXIuZGVzdHJveSgpO1xuICB9XG4gIHN0b3BMb2FkKCkge1xuICAgIHRoaXMuX2xldmVscy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0LmxvYWRFcnJvciA9IDAsIHQuZnJhZ21lbnRFcnJvciA9IDA7XG4gICAgfSksIHN1cGVyLnN0b3BMb2FkKCk7XG4gIH1cbiAgcmVzZXRMZXZlbHMoKSB7XG4gICAgdGhpcy5fc3RhcnRMZXZlbCA9IHZvaWQgMCwgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gLTEsIHRoaXMuY3VycmVudExldmVsSW5kZXggPSAtMSwgdGhpcy5jdXJyZW50TGV2ZWwgPSBudWxsLCB0aGlzLl9sZXZlbHMgPSBbXSwgdGhpcy5fbWF4QXV0b0xldmVsID0gLTE7XG4gIH1cbiAgb25NYW5pZmVzdExvYWRpbmcoZSwgdCkge1xuICAgIHRoaXMucmVzZXRMZXZlbHMoKTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGVkKGUsIHQpIHtcbiAgICBjb25zdCByID0gdGhpcy5obHMuY29uZmlnLnByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSwgbiA9IFtdLCBpID0ge30sIG8gPSB7fTtcbiAgICBsZXQgYSA9ICExLCBsID0gITEsIGMgPSAhMTtcbiAgICB0LmxldmVscy5mb3JFYWNoKCh1KSA9PiB7XG4gICAgICBjb25zdCBkID0gdS5hdHRycztcbiAgICAgIGxldCB7XG4gICAgICAgIGF1ZGlvQ29kZWM6IGgsXG4gICAgICAgIHZpZGVvQ29kZWM6IGZcbiAgICAgIH0gPSB1O1xuICAgICAgaCAmJiAodS5hdWRpb0NvZGVjID0gaCA9IFhvKGgsIHIpIHx8IHZvaWQgMCksIGYgJiYgKGYgPSB1LnZpZGVvQ29kZWMgPSBKUyhmKSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoOiBwLFxuICAgICAgICBoZWlnaHQ6IHksXG4gICAgICAgIHVua25vd25Db2RlY3M6IEVcbiAgICAgIH0gPSB1LCBiID0gKEUgPT0gbnVsbCA/IHZvaWQgMCA6IEUubGVuZ3RoKSB8fCAwO1xuICAgICAgaWYgKGEgfHwgKGEgPSAhIShwICYmIHkpKSwgbCB8fCAobCA9ICEhZiksIGMgfHwgKGMgPSAhIWgpLCBiIHx8IGggJiYgIXRoaXMuaXNBdWRpb1N1cHBvcnRlZChoKSB8fCBmICYmICF0aGlzLmlzVmlkZW9TdXBwb3J0ZWQoZikpIHtcbiAgICAgICAgdGhpcy5sb2coYFNvbWUgb3IgYWxsIENPREVDUyBub3Qgc3VwcG9ydGVkIFwiJHtkLkNPREVDU31cImApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB7XG4gICAgICAgIENPREVDUzogUixcbiAgICAgICAgXCJGUkFNRS1SQVRFXCI6IEEsXG4gICAgICAgIFwiSERDUC1MRVZFTFwiOiBGLFxuICAgICAgICBcIlBBVEhXQVktSURcIjogTSxcbiAgICAgICAgUkVTT0xVVElPTjogSCxcbiAgICAgICAgXCJWSURFTy1SQU5HRVwiOiBLXG4gICAgICB9ID0gZCwgQyA9IGAke2Ake00gfHwgXCIuXCJ9LWB9JHt1LmJpdHJhdGV9LSR7SH0tJHtBfS0ke1J9LSR7S30tJHtGfWA7XG4gICAgICBpZiAoaVtDXSlcbiAgICAgICAgaWYgKGlbQ10udXJpICE9PSB1LnVybCAmJiAhdS5hdHRyc1tcIlBBVEhXQVktSURcIl0pIHtcbiAgICAgICAgICBjb25zdCBrID0gb1tDXSArPSAxO1xuICAgICAgICAgIHUuYXR0cnNbXCJQQVRIV0FZLUlEXCJdID0gbmV3IEFycmF5KGsgKyAxKS5qb2luKFwiLlwiKTtcbiAgICAgICAgICBjb25zdCAkID0gdGhpcy5jcmVhdGVMZXZlbCh1KTtcbiAgICAgICAgICBpW0NdID0gJCwgbi5wdXNoKCQpO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBpW0NdLmFkZEdyb3VwSWQoXCJhdWRpb1wiLCBkLkFVRElPKSwgaVtDXS5hZGRHcm91cElkKFwidGV4dFwiLCBkLlNVQlRJVExFUyk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgayA9IHRoaXMuY3JlYXRlTGV2ZWwodSk7XG4gICAgICAgIGlbQ10gPSBrLCBvW0NdID0gMSwgbi5wdXNoKGspO1xuICAgICAgfVxuICAgIH0pLCB0aGlzLmZpbHRlckFuZFNvcnRNZWRpYU9wdGlvbnMobiwgdCwgYSwgbCwgYyk7XG4gIH1cbiAgY3JlYXRlTGV2ZWwoZSkge1xuICAgIGNvbnN0IHQgPSBuZXcgbWkoZSksIHIgPSBlLnN1cHBsZW1lbnRhbDtcbiAgICBpZiAociAhPSBudWxsICYmIHIudmlkZW9Db2RlYyAmJiAhdGhpcy5pc1ZpZGVvU3VwcG9ydGVkKHIudmlkZW9Db2RlYykpIHtcbiAgICAgIGNvbnN0IG4gPSBuZXcgRXJyb3IoYFNVUFBMRU1FTlRBTC1DT0RFQ1Mgbm90IHN1cHBvcnRlZCBcIiR7ci52aWRlb0NvZGVjfVwiYCk7XG4gICAgICB0aGlzLmxvZyhuLm1lc3NhZ2UpLCB0LnN1cHBvcnRlZFJlc3VsdCA9IEZnKG4sIFtdKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgaXNBdWRpb1N1cHBvcnRlZChlKSB7XG4gICAgcmV0dXJuIGdpKGUsIFwiYXVkaW9cIiwgdGhpcy5obHMuY29uZmlnLnByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSk7XG4gIH1cbiAgaXNWaWRlb1N1cHBvcnRlZChlKSB7XG4gICAgcmV0dXJuIGdpKGUsIFwidmlkZW9cIiwgdGhpcy5obHMuY29uZmlnLnByZWZlck1hbmFnZWRNZWRpYVNvdXJjZSk7XG4gIH1cbiAgZmlsdGVyQW5kU29ydE1lZGlhT3B0aW9ucyhlLCB0LCByLCBuLCBpKSB7XG4gICAgdmFyIG87XG4gICAgbGV0IGEgPSBbXSwgbCA9IFtdLCBjID0gZTtcbiAgICBjb25zdCB1ID0gKChvID0gdC5zdGF0cykgPT0gbnVsbCA/IHZvaWQgMCA6IG8ucGFyc2luZykgfHwge307XG4gICAgaWYgKChyIHx8IG4pICYmIGkgJiYgKGMgPSBjLmZpbHRlcigoe1xuICAgICAgdmlkZW9Db2RlYzogUixcbiAgICAgIHZpZGVvUmFuZ2U6IEEsXG4gICAgICB3aWR0aDogRixcbiAgICAgIGhlaWdodDogTVxuICAgIH0pID0+ICghIVIgfHwgISEoRiAmJiBNKSkgJiYgbGIoQSkpKSwgYy5sZW5ndGggPT09IDApIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5obHMpIHtcbiAgICAgICAgICBsZXQgUiA9IFwibm8gbGV2ZWwgd2l0aCBjb21wYXRpYmxlIGNvZGVjcyBmb3VuZCBpbiBtYW5pZmVzdFwiLCBBID0gUjtcbiAgICAgICAgICB0LmxldmVscy5sZW5ndGggJiYgKEEgPSBgb25lIG9yIG1vcmUgQ09ERUNTIGluIHZhcmlhbnQgbm90IHN1cHBvcnRlZDogJHthdCh0LmxldmVscy5tYXAoKE0pID0+IE0uYXR0cnMuQ09ERUNTKS5maWx0ZXIoKE0sIEgsIEspID0+IEsuaW5kZXhPZihNKSA9PT0gSCkpfWAsIHRoaXMud2FybihBKSwgUiArPSBgICgke0F9KWApO1xuICAgICAgICAgIGNvbnN0IEYgPSBuZXcgRXJyb3IoUik7XG4gICAgICAgICAgdGhpcy5obHMudHJpZ2dlcihJLkVSUk9SLCB7XG4gICAgICAgICAgICB0eXBlOiB2ZS5NRURJQV9FUlJPUixcbiAgICAgICAgICAgIGRldGFpbHM6IEouTUFOSUZFU1RfSU5DT01QQVRJQkxFX0NPREVDU19FUlJPUixcbiAgICAgICAgICAgIGZhdGFsOiAhMCxcbiAgICAgICAgICAgIHVybDogdC51cmwsXG4gICAgICAgICAgICBlcnJvcjogRixcbiAgICAgICAgICAgIHJlYXNvbjogQVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSwgdS5lbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdC5hdWRpb1RyYWNrcyAmJiAoYSA9IHQuYXVkaW9UcmFja3MuZmlsdGVyKChSKSA9PiAhUi5hdWRpb0NvZGVjIHx8IHRoaXMuaXNBdWRpb1N1cHBvcnRlZChSLmF1ZGlvQ29kZWMpKSwgZGYoYSkpLCB0LnN1YnRpdGxlcyAmJiAobCA9IHQuc3VidGl0bGVzLCBkZihsKSk7XG4gICAgY29uc3QgZCA9IGMuc2xpY2UoMCk7XG4gICAgYy5zb3J0KChSLCBBKSA9PiB7XG4gICAgICBpZiAoUi5hdHRyc1tcIkhEQ1AtTEVWRUxcIl0gIT09IEEuYXR0cnNbXCJIRENQLUxFVkVMXCJdKVxuICAgICAgICByZXR1cm4gKFIuYXR0cnNbXCJIRENQLUxFVkVMXCJdIHx8IFwiXCIpID4gKEEuYXR0cnNbXCJIRENQLUxFVkVMXCJdIHx8IFwiXCIpID8gMSA6IC0xO1xuICAgICAgaWYgKHIgJiYgUi5oZWlnaHQgIT09IEEuaGVpZ2h0KVxuICAgICAgICByZXR1cm4gUi5oZWlnaHQgLSBBLmhlaWdodDtcbiAgICAgIGlmIChSLmZyYW1lUmF0ZSAhPT0gQS5mcmFtZVJhdGUpXG4gICAgICAgIHJldHVybiBSLmZyYW1lUmF0ZSAtIEEuZnJhbWVSYXRlO1xuICAgICAgaWYgKFIudmlkZW9SYW5nZSAhPT0gQS52aWRlb1JhbmdlKVxuICAgICAgICByZXR1cm4gSm8uaW5kZXhPZihSLnZpZGVvUmFuZ2UpIC0gSm8uaW5kZXhPZihBLnZpZGVvUmFuZ2UpO1xuICAgICAgaWYgKFIudmlkZW9Db2RlYyAhPT0gQS52aWRlb0NvZGVjKSB7XG4gICAgICAgIGNvbnN0IEYgPSBzaChSLnZpZGVvQ29kZWMpLCBNID0gc2goQS52aWRlb0NvZGVjKTtcbiAgICAgICAgaWYgKEYgIT09IE0pXG4gICAgICAgICAgcmV0dXJuIE0gLSBGO1xuICAgICAgfVxuICAgICAgaWYgKFIudXJpID09PSBBLnVyaSAmJiBSLmNvZGVjU2V0ICE9PSBBLmNvZGVjU2V0KSB7XG4gICAgICAgIGNvbnN0IEYgPSBabyhSLmNvZGVjU2V0KSwgTSA9IFpvKEEuY29kZWNTZXQpO1xuICAgICAgICBpZiAoRiAhPT0gTSlcbiAgICAgICAgICByZXR1cm4gTSAtIEY7XG4gICAgICB9XG4gICAgICByZXR1cm4gUi5hdmVyYWdlQml0cmF0ZSAhPT0gQS5hdmVyYWdlQml0cmF0ZSA/IFIuYXZlcmFnZUJpdHJhdGUgLSBBLmF2ZXJhZ2VCaXRyYXRlIDogMDtcbiAgICB9KTtcbiAgICBsZXQgaCA9IGRbMF07XG4gICAgaWYgKHRoaXMuc3RlZXJpbmcgJiYgKGMgPSB0aGlzLnN0ZWVyaW5nLmZpbHRlclBhcnNlZExldmVscyhjKSwgYy5sZW5ndGggIT09IGQubGVuZ3RoKSkge1xuICAgICAgZm9yIChsZXQgUiA9IDA7IFIgPCBkLmxlbmd0aDsgUisrKVxuICAgICAgICBpZiAoZFtSXS5wYXRod2F5SWQgPT09IGNbMF0ucGF0aHdheUlkKSB7XG4gICAgICAgICAgaCA9IGRbUl07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbGV2ZWxzID0gYztcbiAgICBmb3IgKGxldCBSID0gMDsgUiA8IGMubGVuZ3RoOyBSKyspXG4gICAgICBpZiAoY1tSXSA9PT0gaCkge1xuICAgICAgICB2YXIgZjtcbiAgICAgICAgdGhpcy5fZmlyc3RMZXZlbCA9IFI7XG4gICAgICAgIGNvbnN0IEEgPSBoLmJpdHJhdGUsIEYgPSB0aGlzLmhscy5iYW5kd2lkdGhFc3RpbWF0ZTtcbiAgICAgICAgaWYgKHRoaXMubG9nKGBtYW5pZmVzdCBsb2FkZWQsICR7Yy5sZW5ndGh9IGxldmVsKHMpIGZvdW5kLCBmaXJzdCBiaXRyYXRlOiAke0F9YCksICgoZiA9IHRoaXMuaGxzLnVzZXJDb25maWcpID09IG51bGwgPyB2b2lkIDAgOiBmLmFickV3bWFEZWZhdWx0RXN0aW1hdGUpID09PSB2b2lkIDApIHtcbiAgICAgICAgICBjb25zdCBNID0gTWF0aC5taW4oQSwgdGhpcy5obHMuY29uZmlnLmFickV3bWFEZWZhdWx0RXN0aW1hdGVNYXgpO1xuICAgICAgICAgIE0gPiBGICYmIEYgPT09IHRoaXMuaGxzLmFickV3bWFEZWZhdWx0RXN0aW1hdGUgJiYgKHRoaXMuaGxzLmJhbmR3aWR0aEVzdGltYXRlID0gTSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgY29uc3QgcCA9IGkgJiYgIW4sIHkgPSB0aGlzLmhscy5jb25maWcsIEUgPSAhISh5LmF1ZGlvU3RyZWFtQ29udHJvbGxlciAmJiB5LmF1ZGlvVHJhY2tDb250cm9sbGVyKSwgYiA9IHtcbiAgICAgIGxldmVsczogYyxcbiAgICAgIGF1ZGlvVHJhY2tzOiBhLFxuICAgICAgc3VidGl0bGVUcmFja3M6IGwsXG4gICAgICBzZXNzaW9uRGF0YTogdC5zZXNzaW9uRGF0YSxcbiAgICAgIHNlc3Npb25LZXlzOiB0LnNlc3Npb25LZXlzLFxuICAgICAgZmlyc3RMZXZlbDogdGhpcy5fZmlyc3RMZXZlbCxcbiAgICAgIHN0YXRzOiB0LnN0YXRzLFxuICAgICAgYXVkaW86IGksXG4gICAgICB2aWRlbzogbixcbiAgICAgIGFsdEF1ZGlvOiBFICYmICFwICYmIGEuc29tZSgoUikgPT4gISFSLnVybClcbiAgICB9O1xuICAgIHUuZW5kID0gcGVyZm9ybWFuY2Uubm93KCksIHRoaXMuaGxzLnRyaWdnZXIoSS5NQU5JRkVTVF9QQVJTRUQsIGIpO1xuICB9XG4gIGdldCBsZXZlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xldmVscy5sZW5ndGggPT09IDAgPyBudWxsIDogdGhpcy5fbGV2ZWxzO1xuICB9XG4gIGdldCBsb2FkTGV2ZWxPYmooKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudExldmVsO1xuICB9XG4gIGdldCBsZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50TGV2ZWxJbmRleDtcbiAgfVxuICBzZXQgbGV2ZWwoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLl9sZXZlbHM7XG4gICAgaWYgKHQubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuO1xuICAgIGlmIChlIDwgMCB8fCBlID49IHQubGVuZ3RoKSB7XG4gICAgICBjb25zdCB1ID0gbmV3IEVycm9yKFwiaW52YWxpZCBsZXZlbCBpZHhcIiksIGQgPSBlIDwgMDtcbiAgICAgIGlmICh0aGlzLmhscy50cmlnZ2VyKEkuRVJST1IsIHtcbiAgICAgICAgdHlwZTogdmUuT1RIRVJfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEouTEVWRUxfU1dJVENIX0VSUk9SLFxuICAgICAgICBsZXZlbDogZSxcbiAgICAgICAgZmF0YWw6IGQsXG4gICAgICAgIGVycm9yOiB1LFxuICAgICAgICByZWFzb246IHUubWVzc2FnZVxuICAgICAgfSksIGQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGUgPSBNYXRoLm1pbihlLCB0Lmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBjb25zdCByID0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleCwgbiA9IHRoaXMuY3VycmVudExldmVsLCBpID0gbiA/IG4uYXR0cnNbXCJQQVRIV0FZLUlEXCJdIDogdm9pZCAwLCBvID0gdFtlXSwgYSA9IG8uYXR0cnNbXCJQQVRIV0FZLUlEXCJdO1xuICAgIGlmICh0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gZSwgdGhpcy5jdXJyZW50TGV2ZWwgPSBvLCByID09PSBlICYmIG4gJiYgaSA9PT0gYSlcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmxvZyhgU3dpdGNoaW5nIHRvIGxldmVsICR7ZX0gKCR7by5oZWlnaHQgPyBvLmhlaWdodCArIFwicCBcIiA6IFwiXCJ9JHtvLnZpZGVvUmFuZ2UgPyBvLnZpZGVvUmFuZ2UgKyBcIiBcIiA6IFwiXCJ9JHtvLmNvZGVjU2V0ID8gby5jb2RlY1NldCArIFwiIFwiIDogXCJcIn1AJHtvLmJpdHJhdGV9KSR7YSA/IFwiIHdpdGggUGF0aHdheSBcIiArIGEgOiBcIlwifSBmcm9tIGxldmVsICR7cn0ke2kgPyBcIiB3aXRoIFBhdGh3YXkgXCIgKyBpIDogXCJcIn1gKTtcbiAgICBjb25zdCBsID0ge1xuICAgICAgbGV2ZWw6IGUsXG4gICAgICBhdHRyczogby5hdHRycyxcbiAgICAgIGRldGFpbHM6IG8uZGV0YWlscyxcbiAgICAgIGJpdHJhdGU6IG8uYml0cmF0ZSxcbiAgICAgIGF2ZXJhZ2VCaXRyYXRlOiBvLmF2ZXJhZ2VCaXRyYXRlLFxuICAgICAgbWF4Qml0cmF0ZTogby5tYXhCaXRyYXRlLFxuICAgICAgcmVhbEJpdHJhdGU6IG8ucmVhbEJpdHJhdGUsXG4gICAgICB3aWR0aDogby53aWR0aCxcbiAgICAgIGhlaWdodDogby5oZWlnaHQsXG4gICAgICBjb2RlY1NldDogby5jb2RlY1NldCxcbiAgICAgIGF1ZGlvQ29kZWM6IG8uYXVkaW9Db2RlYyxcbiAgICAgIHZpZGVvQ29kZWM6IG8udmlkZW9Db2RlYyxcbiAgICAgIGF1ZGlvR3JvdXBzOiBvLmF1ZGlvR3JvdXBzLFxuICAgICAgc3VidGl0bGVHcm91cHM6IG8uc3VidGl0bGVHcm91cHMsXG4gICAgICBsb2FkZWQ6IG8ubG9hZGVkLFxuICAgICAgbG9hZEVycm9yOiBvLmxvYWRFcnJvcixcbiAgICAgIGZyYWdtZW50RXJyb3I6IG8uZnJhZ21lbnRFcnJvcixcbiAgICAgIG5hbWU6IG8ubmFtZSxcbiAgICAgIGlkOiBvLmlkLFxuICAgICAgdXJpOiBvLnVyaSxcbiAgICAgIHVybDogby51cmwsXG4gICAgICB1cmxJZDogMCxcbiAgICAgIGF1ZGlvR3JvdXBJZHM6IG8uYXVkaW9Hcm91cElkcyxcbiAgICAgIHRleHRHcm91cElkczogby50ZXh0R3JvdXBJZHNcbiAgICB9O1xuICAgIHRoaXMuaGxzLnRyaWdnZXIoSS5MRVZFTF9TV0lUQ0hJTkcsIGwpO1xuICAgIGNvbnN0IGMgPSBvLmRldGFpbHM7XG4gICAgaWYgKCFjIHx8IGMubGl2ZSkge1xuICAgICAgY29uc3QgdSA9IHRoaXMuc3dpdGNoUGFyYW1zKG8udXJpLCBuID09IG51bGwgPyB2b2lkIDAgOiBuLmRldGFpbHMsIGMpO1xuICAgICAgdGhpcy5sb2FkUGxheWxpc3QodSk7XG4gICAgfVxuICB9XG4gIGdldCBtYW51YWxMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4O1xuICB9XG4gIHNldCBtYW51YWxMZXZlbChlKSB7XG4gICAgdGhpcy5tYW51YWxMZXZlbEluZGV4ID0gZSwgdGhpcy5fc3RhcnRMZXZlbCA9PT0gdm9pZCAwICYmICh0aGlzLl9zdGFydExldmVsID0gZSksIGUgIT09IC0xICYmICh0aGlzLmxldmVsID0gZSk7XG4gIH1cbiAgZ2V0IGZpcnN0TGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpcnN0TGV2ZWw7XG4gIH1cbiAgc2V0IGZpcnN0TGV2ZWwoZSkge1xuICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBlO1xuICB9XG4gIGdldCBzdGFydExldmVsKCkge1xuICAgIGlmICh0aGlzLl9zdGFydExldmVsID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnN0IGUgPSB0aGlzLmhscy5jb25maWcuc3RhcnRMZXZlbDtcbiAgICAgIHJldHVybiBlICE9PSB2b2lkIDAgPyBlIDogdGhpcy5obHMuZmlyc3RBdXRvTGV2ZWw7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zdGFydExldmVsO1xuICB9XG4gIHNldCBzdGFydExldmVsKGUpIHtcbiAgICB0aGlzLl9zdGFydExldmVsID0gZTtcbiAgfVxuICBnZXQgcGF0aHdheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlZXJpbmcgPyB0aGlzLnN0ZWVyaW5nLnBhdGh3YXlzKCkgOiBbXTtcbiAgfVxuICBnZXQgcGF0aHdheVByaW9yaXR5KCkge1xuICAgIHJldHVybiB0aGlzLnN0ZWVyaW5nID8gdGhpcy5zdGVlcmluZy5wYXRod2F5UHJpb3JpdHkgOiBudWxsO1xuICB9XG4gIHNldCBwYXRod2F5UHJpb3JpdHkoZSkge1xuICAgIGlmICh0aGlzLnN0ZWVyaW5nKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5zdGVlcmluZy5wYXRod2F5cygpLCByID0gZS5maWx0ZXIoKG4pID0+IHQuaW5kZXhPZihuKSAhPT0gLTEpO1xuICAgICAgaWYgKGUubGVuZ3RoIDwgMSkge1xuICAgICAgICB0aGlzLndhcm4oYHBhdGh3YXlQcmlvcml0eSAke2V9IHNob3VsZCBjb250YWluIGF0IGxlYXN0IG9uZSBwYXRod2F5IGZyb20gbGlzdDogJHt0fWApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnN0ZWVyaW5nLnBhdGh3YXlQcmlvcml0eSA9IHI7XG4gICAgfVxuICB9XG4gIG9uRXJyb3IoZSwgdCkge1xuICAgIHQuZmF0YWwgfHwgIXQuY29udGV4dCB8fCB0LmNvbnRleHQudHlwZSA9PT0gS2UuTEVWRUwgJiYgdC5jb250ZXh0LmxldmVsID09PSB0aGlzLmxldmVsICYmIHRoaXMuY2hlY2tSZXRyeSh0KTtcbiAgfVxuICAvLyByZXNldCBlcnJvcnMgb24gdGhlIHN1Y2Nlc3NmdWwgbG9hZCBvZiBhIGZyYWdtZW50XG4gIG9uRnJhZ0J1ZmZlcmVkKGUsIHtcbiAgICBmcmFnOiB0XG4gIH0pIHtcbiAgICBpZiAodCAhPT0gdm9pZCAwICYmIHQudHlwZSA9PT0gcGUuTUFJTikge1xuICAgICAgY29uc3QgciA9IHQuZWxlbWVudGFyeVN0cmVhbXM7XG4gICAgICBpZiAoIU9iamVjdC5rZXlzKHIpLnNvbWUoKGkpID0+ICEhcltpXSkpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLl9sZXZlbHNbdC5sZXZlbF07XG4gICAgICBuICE9IG51bGwgJiYgbi5sb2FkRXJyb3IgJiYgKHRoaXMubG9nKGBSZXNldHRpbmcgbGV2ZWwgZXJyb3IgY291bnQgb2YgJHtuLmxvYWRFcnJvcn0gb24gZnJhZyBidWZmZXJlZGApLCBuLmxvYWRFcnJvciA9IDApO1xuICAgIH1cbiAgfVxuICBvbkxldmVsTG9hZGVkKGUsIHQpIHtcbiAgICB2YXIgcjtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbDogbixcbiAgICAgIGRldGFpbHM6IGlcbiAgICB9ID0gdCwgbyA9IHQubGV2ZWxJbmZvO1xuICAgIGlmICghbykge1xuICAgICAgdmFyIGE7XG4gICAgICB0aGlzLndhcm4oYEludmFsaWQgbGV2ZWwgaW5kZXggJHtufWApLCAoYSA9IHQuZGVsaXZlcnlEaXJlY3RpdmVzKSAhPSBudWxsICYmIGEuc2tpcCAmJiAoaS5kZWx0YVVwZGF0ZUZhaWxlZCA9ICEwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG8gPT09IHRoaXMuY3VycmVudExldmVsIHx8IHQud2l0aG91dE11bHRpVmFyaWFudCkge1xuICAgICAgby5mcmFnbWVudEVycm9yID09PSAwICYmIChvLmxvYWRFcnJvciA9IDApO1xuICAgICAgbGV0IGwgPSBvLmRldGFpbHM7XG4gICAgICBsID09PSB0LmRldGFpbHMgJiYgbC5hZHZhbmNlZCAmJiAobCA9IHZvaWQgMCksIHRoaXMucGxheWxpc3RMb2FkZWQobiwgdCwgbCk7XG4gICAgfSBlbHNlIChyID0gdC5kZWxpdmVyeURpcmVjdGl2ZXMpICE9IG51bGwgJiYgci5za2lwICYmIChpLmRlbHRhVXBkYXRlRmFpbGVkID0gITApO1xuICB9XG4gIGxvYWRQbGF5bGlzdChlKSB7XG4gICAgc3VwZXIubG9hZFBsYXlsaXN0KCksIHRoaXMuc2hvdWxkTG9hZFBsYXlsaXN0KHRoaXMuY3VycmVudExldmVsKSAmJiB0aGlzLnNjaGVkdWxlTG9hZGluZyh0aGlzLmN1cnJlbnRMZXZlbCwgZSk7XG4gIH1cbiAgbG9hZGluZ1BsYXlsaXN0KGUsIHQpIHtcbiAgICBzdXBlci5sb2FkaW5nUGxheWxpc3QoZSwgdCk7XG4gICAgY29uc3QgciA9IHRoaXMuZ2V0VXJsV2l0aERpcmVjdGl2ZXMoZS51cmksIHQpLCBuID0gdGhpcy5jdXJyZW50TGV2ZWxJbmRleCwgaSA9IGUuYXR0cnNbXCJQQVRIV0FZLUlEXCJdLCBvID0gZS5kZXRhaWxzLCBhID0gbyA9PSBudWxsID8gdm9pZCAwIDogby5hZ2U7XG4gICAgdGhpcy5sb2coYExvYWRpbmcgbGV2ZWwgaW5kZXggJHtufSR7KHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQubXNuKSAhPT0gdm9pZCAwID8gXCIgYXQgc24gXCIgKyB0Lm1zbiArIFwiIHBhcnQgXCIgKyB0LnBhcnQgOiBcIlwifSR7aSA/IFwiIFBhdGh3YXkgXCIgKyBpIDogXCJcIn0ke2EgJiYgby5saXZlID8gXCIgYWdlIFwiICsgYS50b0ZpeGVkKDEpICsgKG8udHlwZSAmJiBcIiBcIiArIG8udHlwZSB8fCBcIlwiKSA6IFwiXCJ9ICR7cn1gKSwgdGhpcy5obHMudHJpZ2dlcihJLkxFVkVMX0xPQURJTkcsIHtcbiAgICAgIHVybDogcixcbiAgICAgIGxldmVsOiBuLFxuICAgICAgbGV2ZWxJbmZvOiBlLFxuICAgICAgcGF0aHdheUlkOiBlLmF0dHJzW1wiUEFUSFdBWS1JRFwiXSxcbiAgICAgIGlkOiAwLFxuICAgICAgLy8gRGVwcmVjYXRlZCBMZXZlbCB1cmxJZFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiB0IHx8IG51bGxcbiAgICB9KTtcbiAgfVxuICBnZXQgbmV4dExvYWRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYW51YWxMZXZlbEluZGV4ICE9PSAtMSA/IHRoaXMubWFudWFsTGV2ZWxJbmRleCA6IHRoaXMuaGxzLm5leHRBdXRvTGV2ZWw7XG4gIH1cbiAgc2V0IG5leHRMb2FkTGV2ZWwoZSkge1xuICAgIHRoaXMubGV2ZWwgPSBlLCB0aGlzLm1hbnVhbExldmVsSW5kZXggPT09IC0xICYmICh0aGlzLmhscy5uZXh0QXV0b0xldmVsID0gZSk7XG4gIH1cbiAgcmVtb3ZlTGV2ZWwoZSkge1xuICAgIHZhciB0O1xuICAgIGlmICh0aGlzLl9sZXZlbHMubGVuZ3RoID09PSAxKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHIgPSB0aGlzLl9sZXZlbHMuZmlsdGVyKChpLCBvKSA9PiBvICE9PSBlID8gITAgOiAodGhpcy5zdGVlcmluZyAmJiB0aGlzLnN0ZWVyaW5nLnJlbW92ZUxldmVsKGkpLCBpID09PSB0aGlzLmN1cnJlbnRMZXZlbCAmJiAodGhpcy5jdXJyZW50TGV2ZWwgPSBudWxsLCB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID0gLTEsIGkuZGV0YWlscyAmJiBpLmRldGFpbHMuZnJhZ21lbnRzLmZvckVhY2goKGEpID0+IGEubGV2ZWwgPSAtMSkpLCAhMSkpO1xuICAgIHJwKHIpLCB0aGlzLl9sZXZlbHMgPSByLCB0aGlzLmN1cnJlbnRMZXZlbEluZGV4ID4gLTEgJiYgKHQgPSB0aGlzLmN1cnJlbnRMZXZlbCkgIT0gbnVsbCAmJiB0LmRldGFpbHMgJiYgKHRoaXMuY3VycmVudExldmVsSW5kZXggPSB0aGlzLmN1cnJlbnRMZXZlbC5kZXRhaWxzLmZyYWdtZW50c1swXS5sZXZlbCksIHRoaXMubWFudWFsTGV2ZWxJbmRleCA+IC0xICYmICh0aGlzLm1hbnVhbExldmVsSW5kZXggPSB0aGlzLmN1cnJlbnRMZXZlbEluZGV4KTtcbiAgICBjb25zdCBuID0gci5sZW5ndGggLSAxO1xuICAgIHRoaXMuX2ZpcnN0TGV2ZWwgPSBNYXRoLm1pbih0aGlzLl9maXJzdExldmVsLCBuKSwgdGhpcy5fc3RhcnRMZXZlbCAmJiAodGhpcy5fc3RhcnRMZXZlbCA9IE1hdGgubWluKHRoaXMuX3N0YXJ0TGV2ZWwsIG4pKSwgdGhpcy5obHMudHJpZ2dlcihJLkxFVkVMU19VUERBVEVELCB7XG4gICAgICBsZXZlbHM6IHJcbiAgICB9KTtcbiAgfVxuICBvbkxldmVsc1VwZGF0ZWQoZSwge1xuICAgIGxldmVsczogdFxuICB9KSB7XG4gICAgdGhpcy5fbGV2ZWxzID0gdDtcbiAgfVxuICBjaGVja01heEF1dG9VcGRhdGVkKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGF1dG9MZXZlbENhcHBpbmc6IGUsXG4gICAgICBtYXhBdXRvTGV2ZWw6IHQsXG4gICAgICBtYXhIZGNwTGV2ZWw6IHJcbiAgICB9ID0gdGhpcy5obHM7XG4gICAgdGhpcy5fbWF4QXV0b0xldmVsICE9PSB0ICYmICh0aGlzLl9tYXhBdXRvTGV2ZWwgPSB0LCB0aGlzLmhscy50cmlnZ2VyKEkuTUFYX0FVVE9fTEVWRUxfVVBEQVRFRCwge1xuICAgICAgYXV0b0xldmVsQ2FwcGluZzogZSxcbiAgICAgIGxldmVsczogdGhpcy5sZXZlbHMsXG4gICAgICBtYXhBdXRvTGV2ZWw6IHQsXG4gICAgICBtaW5BdXRvTGV2ZWw6IHRoaXMuaGxzLm1pbkF1dG9MZXZlbCxcbiAgICAgIG1heEhkY3BMZXZlbDogclxuICAgIH0pKTtcbiAgfVxufVxuZnVuY3Rpb24gZGYocykge1xuICBjb25zdCBlID0ge307XG4gIHMuZm9yRWFjaCgodCkgPT4ge1xuICAgIGNvbnN0IHIgPSB0Lmdyb3VwSWQgfHwgXCJcIjtcbiAgICB0LmlkID0gZVtyXSA9IGVbcl0gfHwgMCwgZVtyXSsrO1xuICB9KTtcbn1cbmZ1bmN0aW9uIFhwKCkge1xuICByZXR1cm4gc2VsZi5Tb3VyY2VCdWZmZXIgfHwgc2VsZi5XZWJLaXRTb3VyY2VCdWZmZXI7XG59XG5mdW5jdGlvbiBKcCgpIHtcbiAgaWYgKCFNcygpKVxuICAgIHJldHVybiAhMTtcbiAgY29uc3QgZSA9IFhwKCk7XG4gIHJldHVybiAhZSB8fCBlLnByb3RvdHlwZSAmJiB0eXBlb2YgZS5wcm90b3R5cGUuYXBwZW5kQnVmZmVyID09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZS5wcm90b3R5cGUucmVtb3ZlID09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIHZBKCkge1xuICBpZiAoIUpwKCkpXG4gICAgcmV0dXJuICExO1xuICBjb25zdCBzID0gTXMoKTtcbiAgcmV0dXJuIHR5cGVvZiAocyA9PSBudWxsID8gdm9pZCAwIDogcy5pc1R5cGVTdXBwb3J0ZWQpID09IFwiZnVuY3Rpb25cIiAmJiAoW1wiYXZjMS40MkUwMUUsbXA0YS40MC4yXCIsIFwiYXYwMS4wLjAxTS4wOFwiLCBcInZwMDkuMDAuNTAuMDhcIl0uc29tZSgoZSkgPT4gcy5pc1R5cGVTdXBwb3J0ZWQocGkoZSwgXCJ2aWRlb1wiKSkpIHx8IFtcIm1wNGEuNDAuMlwiLCBcImZMYUNcIl0uc29tZSgoZSkgPT4gcy5pc1R5cGVTdXBwb3J0ZWQocGkoZSwgXCJhdWRpb1wiKSkpKTtcbn1cbmZ1bmN0aW9uIEVBKCkge1xuICB2YXIgcztcbiAgY29uc3QgZSA9IFhwKCk7XG4gIHJldHVybiB0eXBlb2YgKGUgPT0gbnVsbCB8fCAocyA9IGUucHJvdG90eXBlKSA9PSBudWxsID8gdm9pZCAwIDogcy5jaGFuZ2VUeXBlKSA9PSBcImZ1bmN0aW9uXCI7XG59XG5jb25zdCB4QSA9IDEwMDtcbmNsYXNzIFNBIGV4dGVuZHMgVHUge1xuICBjb25zdHJ1Y3RvcihlLCB0LCByKSB7XG4gICAgc3VwZXIoZSwgdCwgciwgXCJzdHJlYW0tY29udHJvbGxlclwiLCBwZS5NQUlOKSwgdGhpcy5hdWRpb0NvZGVjU3dhcCA9ICExLCB0aGlzLmxldmVsID0gLTEsIHRoaXMuX2ZvcmNlU3RhcnRMb2FkID0gITEsIHRoaXMuX2hhc0Vub3VnaFRvU3RhcnQgPSAhMSwgdGhpcy5hbHRBdWRpbyA9IDAsIHRoaXMuYXVkaW9Pbmx5ID0gITEsIHRoaXMuZnJhZ1BsYXlpbmcgPSBudWxsLCB0aGlzLmZyYWdMYXN0S2JwcyA9IDAsIHRoaXMuY291bGRCYWNrdHJhY2sgPSAhMSwgdGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGwsIHRoaXMuYXVkaW9Db2RlY1N3aXRjaCA9ICExLCB0aGlzLnZpZGVvQnVmZmVyID0gbnVsbCwgdGhpcy5vbk1lZGlhUGxheWluZyA9ICgpID0+IHtcbiAgICAgIHRoaXMudGljaygpO1xuICAgIH0sIHRoaXMub25NZWRpYVNlZWtlZCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLm1lZGlhLCBpID0gbiA/IG4uY3VycmVudFRpbWUgOiBudWxsO1xuICAgICAgaWYgKGkgPT09IG51bGwgfHwgIXVlKGkpIHx8ICh0aGlzLmxvZyhgTWVkaWEgc2Vla2VkIHRvICR7aS50b0ZpeGVkKDMpfWApLCAhdGhpcy5nZXRCdWZmZXJlZEZyYWcoaSkpKVxuICAgICAgICByZXR1cm47XG4gICAgICBjb25zdCBvID0gdGhpcy5nZXRGd2RCdWZmZXJJbmZvQXRQb3MobiwgaSwgcGUuTUFJTiwgMCk7XG4gICAgICBpZiAobyA9PT0gbnVsbCB8fCBvLmxlbiA9PT0gMCkge1xuICAgICAgICB0aGlzLndhcm4oYE1haW4gZm9yd2FyZCBidWZmZXIgbGVuZ3RoIGF0ICR7aX0gb24gXCJzZWVrZWRcIiBldmVudCAke28gPyBvLmxlbiA6IFwiZW1wdHlcIn0pYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudGljaygpO1xuICAgIH0sIHRoaXMucmVnaXN0ZXJMaXN0ZW5lcnMoKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBzdXBlci5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGhsczogZVxuICAgIH0gPSB0aGlzO1xuICAgIGUub24oSS5NQU5JRkVTVF9QQVJTRUQsIHRoaXMub25NYW5pZmVzdFBhcnNlZCwgdGhpcyksIGUub24oSS5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKSwgZS5vbihJLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKSwgZS5vbihJLkZSQUdfTE9BRF9FTUVSR0VOQ1lfQUJPUlRFRCwgdGhpcy5vbkZyYWdMb2FkRW1lcmdlbmN5QWJvcnRlZCwgdGhpcyksIGUub24oSS5BVURJT19UUkFDS19TV0lUQ0hJTkcsIHRoaXMub25BdWRpb1RyYWNrU3dpdGNoaW5nLCB0aGlzKSwgZS5vbihJLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKSwgZS5vbihJLkJVRkZFUl9DUkVBVEVELCB0aGlzLm9uQnVmZmVyQ3JlYXRlZCwgdGhpcyksIGUub24oSS5CVUZGRVJfRkxVU0hFRCwgdGhpcy5vbkJ1ZmZlckZsdXNoZWQsIHRoaXMpLCBlLm9uKEkuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKSwgZS5vbihJLkZSQUdfQlVGRkVSRUQsIHRoaXMub25GcmFnQnVmZmVyZWQsIHRoaXMpO1xuICB9XG4gIHVucmVnaXN0ZXJMaXN0ZW5lcnMoKSB7XG4gICAgc3VwZXIudW5yZWdpc3Rlckxpc3RlbmVycygpO1xuICAgIGNvbnN0IHtcbiAgICAgIGhsczogZVxuICAgIH0gPSB0aGlzO1xuICAgIGUub2ZmKEkuTUFOSUZFU1RfUEFSU0VELCB0aGlzLm9uTWFuaWZlc3RQYXJzZWQsIHRoaXMpLCBlLm9mZihJLkxFVkVMX0xPQURFRCwgdGhpcy5vbkxldmVsTG9hZGVkLCB0aGlzKSwgZS5vZmYoSS5GUkFHX0xPQURfRU1FUkdFTkNZX0FCT1JURUQsIHRoaXMub25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQsIHRoaXMpLCBlLm9mZihJLkFVRElPX1RSQUNLX1NXSVRDSElORywgdGhpcy5vbkF1ZGlvVHJhY2tTd2l0Y2hpbmcsIHRoaXMpLCBlLm9mZihJLkFVRElPX1RSQUNLX1NXSVRDSEVELCB0aGlzLm9uQXVkaW9UcmFja1N3aXRjaGVkLCB0aGlzKSwgZS5vZmYoSS5CVUZGRVJfQ1JFQVRFRCwgdGhpcy5vbkJ1ZmZlckNyZWF0ZWQsIHRoaXMpLCBlLm9mZihJLkJVRkZFUl9GTFVTSEVELCB0aGlzLm9uQnVmZmVyRmx1c2hlZCwgdGhpcyksIGUub2ZmKEkuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKSwgZS5vZmYoSS5GUkFHX0JVRkZFUkVELCB0aGlzLm9uRnJhZ0J1ZmZlcmVkLCB0aGlzKTtcbiAgfVxuICBvbkhhbmRsZXJEZXN0cm95aW5nKCkge1xuICAgIHRoaXMub25NZWRpYVBsYXlpbmcgPSB0aGlzLm9uTWVkaWFTZWVrZWQgPSBudWxsLCB0aGlzLnVucmVnaXN0ZXJMaXN0ZW5lcnMoKSwgc3VwZXIub25IYW5kbGVyRGVzdHJveWluZygpO1xuICB9XG4gIHN0YXJ0TG9hZChlLCB0KSB7XG4gICAgaWYgKHRoaXMubGV2ZWxzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxhc3RDdXJyZW50VGltZTogcixcbiAgICAgICAgaGxzOiBuXG4gICAgICB9ID0gdGhpcztcbiAgICAgIGlmICh0aGlzLnN0b3BMb2FkKCksIHRoaXMuc2V0SW50ZXJ2YWwoeEEpLCB0aGlzLmxldmVsID0gLTEsICF0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCkge1xuICAgICAgICBsZXQgaSA9IG4uc3RhcnRMZXZlbDtcbiAgICAgICAgaSA9PT0gLTEgJiYgKG4uY29uZmlnLnRlc3RCYW5kd2lkdGggJiYgdGhpcy5sZXZlbHMubGVuZ3RoID4gMSA/IChpID0gMCwgdGhpcy5iaXRyYXRlVGVzdCA9ICEwKSA6IGkgPSBuLmZpcnN0QXV0b0xldmVsKSwgbi5uZXh0TG9hZExldmVsID0gaSwgdGhpcy5sZXZlbCA9IG4ubG9hZExldmVsLCB0aGlzLl9oYXNFbm91Z2hUb1N0YXJ0ID0gISF0O1xuICAgICAgfVxuICAgICAgciA+IDAgJiYgZSA9PT0gLTEgJiYgIXQgJiYgKHRoaXMubG9nKGBPdmVycmlkZSBzdGFydFBvc2l0aW9uIHdpdGggbGFzdEN1cnJlbnRUaW1lIEAke3IudG9GaXhlZCgzKX1gKSwgZSA9IHIpLCB0aGlzLnN0YXRlID0gbmUuSURMRSwgdGhpcy5uZXh0TG9hZFBvc2l0aW9uID0gdGhpcy5sYXN0Q3VycmVudFRpbWUgPSBlICsgdGhpcy50aW1lbGluZU9mZnNldCwgdGhpcy5zdGFydFBvc2l0aW9uID0gdCA/IC0xIDogZSwgdGhpcy50aWNrKCk7XG4gICAgfSBlbHNlXG4gICAgICB0aGlzLl9mb3JjZVN0YXJ0TG9hZCA9ICEwLCB0aGlzLnN0YXRlID0gbmUuU1RPUFBFRDtcbiAgfVxuICBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLl9mb3JjZVN0YXJ0TG9hZCA9ICExLCBzdXBlci5zdG9wTG9hZCgpO1xuICB9XG4gIGRvVGljaygpIHtcbiAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgIGNhc2UgbmUuV0FJVElOR19MRVZFTDoge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgbGV2ZWxzOiBlLFxuICAgICAgICAgIGxldmVsOiB0XG4gICAgICAgIH0gPSB0aGlzLCByID0gZSA9PSBudWxsID8gdm9pZCAwIDogZVt0XSwgbiA9IHIgPT0gbnVsbCA/IHZvaWQgMCA6IHIuZGV0YWlscztcbiAgICAgICAgaWYgKG4gJiYgKCFuLmxpdmUgfHwgdGhpcy5sZXZlbExhc3RMb2FkZWQgPT09IHIgJiYgIXRoaXMud2FpdEZvckxpdmUocikpKSB7XG4gICAgICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihuKSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIHRoaXMuc3RhdGUgPSBuZS5JRExFO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaGxzLm5leHRMb2FkTGV2ZWwgIT09IHRoaXMubGV2ZWwpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlID0gbmUuSURMRTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgbmUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlk6XG4gICAgICAgIHRoaXMuY2hlY2tSZXRyeURhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPT09IG5lLklETEUgJiYgdGhpcy5kb1RpY2tJZGxlKCksIHRoaXMub25UaWNrRW5kKCk7XG4gIH1cbiAgb25UaWNrRW5kKCkge1xuICAgIHZhciBlO1xuICAgIHN1cGVyLm9uVGlja0VuZCgpLCAoZSA9IHRoaXMubWVkaWEpICE9IG51bGwgJiYgZS5yZWFkeVN0YXRlICYmIHRoaXMubWVkaWEuc2Vla2luZyA9PT0gITEgJiYgKHRoaXMubGFzdEN1cnJlbnRUaW1lID0gdGhpcy5tZWRpYS5jdXJyZW50VGltZSksIHRoaXMuY2hlY2tGcmFnbWVudENoYW5nZWQoKTtcbiAgfVxuICBkb1RpY2tJZGxlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsczogZSxcbiAgICAgIGxldmVsTGFzdExvYWRlZDogdCxcbiAgICAgIGxldmVsczogcixcbiAgICAgIG1lZGlhOiBuXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKHQgPT09IG51bGwgfHwgIW4gJiYgIXRoaXMucHJpbWFyeVByZWZldGNoICYmICh0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCB8fCAhZS5jb25maWcuc3RhcnRGcmFnUHJlZmV0Y2gpIHx8IHRoaXMuYWx0QXVkaW8gJiYgdGhpcy5hdWRpb09ubHkpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgaSA9IHRoaXMuYnVmZmVyaW5nID8gZS5uZXh0TG9hZExldmVsIDogZS5sb2FkTGV2ZWw7XG4gICAgaWYgKCEociAhPSBudWxsICYmIHJbaV0pKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG8gPSByW2ldLCBhID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgIGlmIChhID09PSBudWxsKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGwgPSB0aGlzLmdldExldmVsRGV0YWlscygpO1xuICAgIGlmIChsICYmIHRoaXMuX3N0cmVhbUVuZGVkKGEsIGwpKSB7XG4gICAgICBjb25zdCB5ID0ge307XG4gICAgICB0aGlzLmFsdEF1ZGlvID09PSAyICYmICh5LnR5cGUgPSBcInZpZGVvXCIpLCB0aGlzLmhscy50cmlnZ2VyKEkuQlVGRkVSX0VPUywgeSksIHRoaXMuc3RhdGUgPSBuZS5FTkRFRDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmJ1ZmZlcmluZylcbiAgICAgIHJldHVybjtcbiAgICBlLmxvYWRMZXZlbCAhPT0gaSAmJiBlLm1hbnVhbExldmVsID09PSAtMSAmJiB0aGlzLmxvZyhgQWRhcHRpbmcgdG8gbGV2ZWwgJHtpfSBmcm9tIGxldmVsICR7dGhpcy5sZXZlbH1gKSwgdGhpcy5sZXZlbCA9IGUubmV4dExvYWRMZXZlbCA9IGk7XG4gICAgY29uc3QgYyA9IG8uZGV0YWlscztcbiAgICBpZiAoIWMgfHwgdGhpcy5zdGF0ZSA9PT0gbmUuV0FJVElOR19MRVZFTCB8fCB0aGlzLndhaXRGb3JMaXZlKG8pKSB7XG4gICAgICB0aGlzLmxldmVsID0gaSwgdGhpcy5zdGF0ZSA9IG5lLldBSVRJTkdfTEVWRUwsIHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gITE7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHUgPSBhLmxlbiwgZCA9IHRoaXMuZ2V0TWF4QnVmZmVyTGVuZ3RoKG8ubWF4Qml0cmF0ZSk7XG4gICAgaWYgKHUgPj0gZClcbiAgICAgIHJldHVybjtcbiAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ICYmIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQuc3RhcnQgPiBhLmVuZCAmJiAodGhpcy5iYWNrdHJhY2tGcmFnbWVudCA9IG51bGwpO1xuICAgIGNvbnN0IGggPSB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID8gdGhpcy5iYWNrdHJhY2tGcmFnbWVudC5zdGFydCA6IGEuZW5kO1xuICAgIGxldCBmID0gdGhpcy5nZXROZXh0RnJhZ21lbnQoaCwgYyk7XG4gICAgaWYgKHRoaXMuY291bGRCYWNrdHJhY2sgJiYgIXRoaXMuZnJhZ1ByZXZpb3VzICYmIGYgJiYgVnQoZikgJiYgdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0U3RhdGUoZikgIT09IEh0Lk9LKSB7XG4gICAgICB2YXIgcDtcbiAgICAgIGNvbnN0IEUgPSAoKHAgPSB0aGlzLmJhY2t0cmFja0ZyYWdtZW50KSAhPSBudWxsID8gcCA6IGYpLnNuIC0gYy5zdGFydFNOLCBiID0gYy5mcmFnbWVudHNbRSAtIDFdO1xuICAgICAgYiAmJiBmLmNjID09PSBiLmNjICYmIChmID0gYiwgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoYikpO1xuICAgIH0gZWxzZSB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ICYmIGEubGVuICYmICh0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbCk7XG4gICAgaWYgKGYgJiYgdGhpcy5pc0xvb3BMb2FkaW5nKGYsIGgpKSB7XG4gICAgICBpZiAoIWYuZ2FwKSB7XG4gICAgICAgIGNvbnN0IEUgPSB0aGlzLmF1ZGlvT25seSAmJiAhdGhpcy5hbHRBdWRpbyA/IG90LkFVRElPIDogb3QuVklERU8sIGIgPSAoRSA9PT0gb3QuVklERU8gPyB0aGlzLnZpZGVvQnVmZmVyIDogdGhpcy5tZWRpYUJ1ZmZlcikgfHwgdGhpcy5tZWRpYTtcbiAgICAgICAgYiAmJiB0aGlzLmFmdGVyQnVmZmVyRmx1c2hlZChiLCBFLCBwZS5NQUlOKTtcbiAgICAgIH1cbiAgICAgIGYgPSB0aGlzLmdldE5leHRGcmFnbWVudExvb3BMb2FkaW5nKGYsIGMsIGEsIHBlLk1BSU4sIGQpO1xuICAgIH1cbiAgICBmICYmIChmLmluaXRTZWdtZW50ICYmICFmLmluaXRTZWdtZW50LmRhdGEgJiYgIXRoaXMuYml0cmF0ZVRlc3QgJiYgKGYgPSBmLmluaXRTZWdtZW50KSwgdGhpcy5sb2FkRnJhZ21lbnQoZiwgbywgaCkpO1xuICB9XG4gIGxvYWRGcmFnbWVudChlLCB0LCByKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuZnJhZ21lbnRUcmFja2VyLmdldFN0YXRlKGUpO1xuICAgIG4gPT09IEh0Lk5PVF9MT0FERUQgfHwgbiA9PT0gSHQuUEFSVElBTCA/IFZ0KGUpID8gdGhpcy5iaXRyYXRlVGVzdCA/ICh0aGlzLmxvZyhgRnJhZ21lbnQgJHtlLnNufSBvZiBsZXZlbCAke2UubGV2ZWx9IGlzIGJlaW5nIGRvd25sb2FkZWQgdG8gdGVzdCBiaXRyYXRlIGFuZCB3aWxsIG5vdCBiZSBidWZmZXJlZGApLCB0aGlzLl9sb2FkQml0cmF0ZVRlc3RGcmFnKGUsIHQpKSA6IHN1cGVyLmxvYWRGcmFnbWVudChlLCB0LCByKSA6IHRoaXMuX2xvYWRJbml0U2VnbWVudChlLCB0KSA6IHRoaXMuY2xlYXJUcmFja2VySWZOZWVkZWQoZSk7XG4gIH1cbiAgZ2V0QnVmZmVyZWRGcmFnKGUpIHtcbiAgICByZXR1cm4gdGhpcy5mcmFnbWVudFRyYWNrZXIuZ2V0QnVmZmVyZWRGcmFnKGUsIHBlLk1BSU4pO1xuICB9XG4gIGZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhlKSB7XG4gICAgcmV0dXJuIGUgPyB0aGlzLmdldEJ1ZmZlcmVkRnJhZyhlLmVuZCArIDAuNSkgOiBudWxsO1xuICB9XG4gIC8qXG4gICAgb24gaW1tZWRpYXRlIGxldmVsIHN3aXRjaCA6XG4gICAgIC0gcGF1c2UgcGxheWJhY2sgaWYgcGxheWluZ1xuICAgICAtIGNhbmNlbCBhbnkgcGVuZGluZyBsb2FkIHJlcXVlc3RcbiAgICAgLSBhbmQgdHJpZ2dlciBhIGJ1ZmZlciBmbHVzaFxuICAqL1xuICBpbW1lZGlhdGVMZXZlbFN3aXRjaCgpIHtcbiAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKSwgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgfVxuICAvKipcbiAgICogdHJ5IHRvIHN3aXRjaCBBU0FQIHdpdGhvdXQgYnJlYWtpbmcgdmlkZW8gcGxheWJhY2s6XG4gICAqIGluIG9yZGVyIHRvIGVuc3VyZSBzbW9vdGggYnV0IHF1aWNrIGxldmVsIHN3aXRjaGluZyxcbiAgICogd2UgbmVlZCB0byBmaW5kIHRoZSBuZXh0IGZsdXNoYWJsZSBidWZmZXIgcmFuZ2VcbiAgICogd2Ugc2hvdWxkIHRha2UgaW50byBhY2NvdW50IG5ldyBzZWdtZW50IGZldGNoIHRpbWVcbiAgICovXG4gIG5leHRMZXZlbFN3aXRjaCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHM6IGUsXG4gICAgICBtZWRpYTogdFxuICAgIH0gPSB0aGlzO1xuICAgIGlmICh0ICE9IG51bGwgJiYgdC5yZWFkeVN0YXRlKSB7XG4gICAgICBsZXQgcjtcbiAgICAgIGNvbnN0IG4gPSB0aGlzLmdldEFwcGVuZGVkRnJhZyh0LmN1cnJlbnRUaW1lKTtcbiAgICAgIG4gJiYgbi5zdGFydCA+IDEgJiYgdGhpcy5mbHVzaE1haW5CdWZmZXIoMCwgbi5zdGFydCAtIDEpO1xuICAgICAgY29uc3QgaSA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCk7XG4gICAgICBpZiAoaSAhPSBudWxsICYmIGkubGl2ZSkge1xuICAgICAgICBjb25zdCBhID0gdGhpcy5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICAgICAgICBpZiAoIWEgfHwgYS5sZW4gPCBpLnRhcmdldGR1cmF0aW9uICogMilcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXQucGF1c2VkICYmIGUpIHtcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuaGxzLm5leHRMb2FkTGV2ZWwsIGwgPSBlW2FdLCBjID0gdGhpcy5mcmFnTGFzdEticHM7XG4gICAgICAgIGMgJiYgdGhpcy5mcmFnQ3VycmVudCA/IHIgPSB0aGlzLmZyYWdDdXJyZW50LmR1cmF0aW9uICogbC5tYXhCaXRyYXRlIC8gKDFlMyAqIGMpICsgMSA6IHIgPSAwO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHIgPSAwO1xuICAgICAgY29uc3QgbyA9IHRoaXMuZ2V0QnVmZmVyZWRGcmFnKHQuY3VycmVudFRpbWUgKyByKTtcbiAgICAgIGlmIChvKSB7XG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLmZvbGxvd2luZ0J1ZmZlcmVkRnJhZyhvKTtcbiAgICAgICAgaWYgKGEpIHtcbiAgICAgICAgICB0aGlzLmFib3J0Q3VycmVudEZyYWcoKTtcbiAgICAgICAgICBjb25zdCBsID0gYS5tYXhTdGFydFBUUyA/IGEubWF4U3RhcnRQVFMgOiBhLnN0YXJ0LCBjID0gYS5kdXJhdGlvbiwgdSA9IE1hdGgubWF4KG8uZW5kLCBsICsgTWF0aC5taW4oTWF0aC5tYXgoYyAtIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UsIGMgKiAodGhpcy5jb3VsZEJhY2t0cmFjayA/IDAuNSA6IDAuMTI1KSksIGMgKiAodGhpcy5jb3VsZEJhY2t0cmFjayA/IDAuNzUgOiAwLjI1KSkpO1xuICAgICAgICAgIHRoaXMuZmx1c2hNYWluQnVmZmVyKHUsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgYWJvcnRDdXJyZW50RnJhZygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICBzd2l0Y2ggKHRoaXMuZnJhZ0N1cnJlbnQgPSBudWxsLCB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbCwgZSAmJiAoZS5hYm9ydFJlcXVlc3RzKCksIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KGUpKSwgdGhpcy5zdGF0ZSkge1xuICAgICAgY2FzZSBuZS5LRVlfTE9BRElORzpcbiAgICAgIGNhc2UgbmUuRlJBR19MT0FESU5HOlxuICAgICAgY2FzZSBuZS5GUkFHX0xPQURJTkdfV0FJVElOR19SRVRSWTpcbiAgICAgIGNhc2UgbmUuUEFSU0lORzpcbiAgICAgIGNhc2UgbmUuUEFSU0VEOlxuICAgICAgICB0aGlzLnN0YXRlID0gbmUuSURMRTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMuZ2V0TG9hZFBvc2l0aW9uKCk7XG4gIH1cbiAgZmx1c2hNYWluQnVmZmVyKGUsIHQpIHtcbiAgICBzdXBlci5mbHVzaE1haW5CdWZmZXIoZSwgdCwgdGhpcy5hbHRBdWRpbyA9PT0gMiA/IFwidmlkZW9cIiA6IG51bGwpO1xuICB9XG4gIG9uTWVkaWFBdHRhY2hlZChlLCB0KSB7XG4gICAgc3VwZXIub25NZWRpYUF0dGFjaGVkKGUsIHQpO1xuICAgIGNvbnN0IHIgPSB0Lm1lZGlhO1xuICAgIGNyKHIsIFwicGxheWluZ1wiLCB0aGlzLm9uTWVkaWFQbGF5aW5nKSwgY3IociwgXCJzZWVrZWRcIiwgdGhpcy5vbk1lZGlhU2Vla2VkKTtcbiAgfVxuICBvbk1lZGlhRGV0YWNoaW5nKGUsIHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBtZWRpYTogclxuICAgIH0gPSB0aGlzO1xuICAgIHIgJiYgKHByKHIsIFwicGxheWluZ1wiLCB0aGlzLm9uTWVkaWFQbGF5aW5nKSwgcHIociwgXCJzZWVrZWRcIiwgdGhpcy5vbk1lZGlhU2Vla2VkKSksIHRoaXMudmlkZW9CdWZmZXIgPSBudWxsLCB0aGlzLmZyYWdQbGF5aW5nID0gbnVsbCwgc3VwZXIub25NZWRpYURldGFjaGluZyhlLCB0KSwgIXQudHJhbnNmZXJNZWRpYSAmJiAodGhpcy5faGFzRW5vdWdoVG9TdGFydCA9ICExKTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZygpIHtcbiAgICBzdXBlci5vbk1hbmlmZXN0TG9hZGluZygpLCB0aGlzLmxvZyhcIlRyaWdnZXIgQlVGRkVSX1JFU0VUXCIpLCB0aGlzLmhscy50cmlnZ2VyKEkuQlVGRkVSX1JFU0VULCB2b2lkIDApLCB0aGlzLmNvdWxkQmFja3RyYWNrID0gITEsIHRoaXMuZnJhZ0xhc3RLYnBzID0gMCwgdGhpcy5mcmFnUGxheWluZyA9IHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBudWxsLCB0aGlzLmFsdEF1ZGlvID0gMCwgdGhpcy5hdWRpb09ubHkgPSAhMTtcbiAgfVxuICBvbk1hbmlmZXN0UGFyc2VkKGUsIHQpIHtcbiAgICBsZXQgciA9ICExLCBuID0gITE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0LmxldmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbyA9IHQubGV2ZWxzW2ldLmF1ZGlvQ29kZWM7XG4gICAgICBvICYmIChyID0gciB8fCBvLmluZGV4T2YoXCJtcDRhLjQwLjJcIikgIT09IC0xLCBuID0gbiB8fCBvLmluZGV4T2YoXCJtcDRhLjQwLjVcIikgIT09IC0xKTtcbiAgICB9XG4gICAgdGhpcy5hdWRpb0NvZGVjU3dpdGNoID0gciAmJiBuICYmICFFQSgpLCB0aGlzLmF1ZGlvQ29kZWNTd2l0Y2ggJiYgdGhpcy5sb2coXCJCb3RoIEFBQy9IRS1BQUMgYXVkaW8gZm91bmQgaW4gbGV2ZWxzOyBkZWNsYXJpbmcgbGV2ZWwgY29kZWMgYXMgSEUtQUFDXCIpLCB0aGlzLmxldmVscyA9IHQubGV2ZWxzLCB0aGlzLnN0YXJ0RnJhZ1JlcXVlc3RlZCA9ICExO1xuICB9XG4gIG9uTGV2ZWxMb2FkaW5nKGUsIHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHM6IHJcbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIXIgfHwgdGhpcy5zdGF0ZSAhPT0gbmUuSURMRSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCBuID0gdC5sZXZlbEluZm87XG4gICAgKCFuLmRldGFpbHMgfHwgbi5kZXRhaWxzLmxpdmUgJiYgKHRoaXMubGV2ZWxMYXN0TG9hZGVkICE9PSBuIHx8IG4uZGV0YWlscy5leHBpcmVkKSB8fCB0aGlzLndhaXRGb3JDZG5UdW5lSW4obi5kZXRhaWxzKSkgJiYgKHRoaXMuc3RhdGUgPSBuZS5XQUlUSU5HX0xFVkVMKTtcbiAgfVxuICBvbkxldmVsTG9hZGVkKGUsIHQpIHtcbiAgICB2YXIgcjtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHM6IG4sXG4gICAgICBzdGFydEZyYWdSZXF1ZXN0ZWQ6IGlcbiAgICB9ID0gdGhpcywgbyA9IHQubGV2ZWwsIGEgPSB0LmRldGFpbHMsIGwgPSBhLnRvdGFsZHVyYXRpb247XG4gICAgaWYgKCFuKSB7XG4gICAgICB0aGlzLndhcm4oYExldmVscyB3ZXJlIHJlc2V0IHdoaWxlIGxvYWRpbmcgbGV2ZWwgJHtvfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZyhgTGV2ZWwgJHtvfSBsb2FkZWQgWyR7YS5zdGFydFNOfSwke2EuZW5kU059XSR7YS5sYXN0UGFydFNuID8gYFtwYXJ0LSR7YS5sYXN0UGFydFNufS0ke2EubGFzdFBhcnRJbmRleH1dYCA6IFwiXCJ9LCBjYyBbJHthLnN0YXJ0Q0N9LCAke2EuZW5kQ0N9XSBkdXJhdGlvbjoke2x9YCk7XG4gICAgY29uc3QgYyA9IHQubGV2ZWxJbmZvLCB1ID0gdGhpcy5mcmFnQ3VycmVudDtcbiAgICB1ICYmICh0aGlzLnN0YXRlID09PSBuZS5GUkFHX0xPQURJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gbmUuRlJBR19MT0FESU5HX1dBSVRJTkdfUkVUUlkpICYmIHUubGV2ZWwgIT09IHQubGV2ZWwgJiYgdS5sb2FkZXIgJiYgdGhpcy5hYm9ydEN1cnJlbnRGcmFnKCk7XG4gICAgbGV0IGQgPSAwO1xuICAgIGlmIChhLmxpdmUgfHwgKHIgPSBjLmRldGFpbHMpICE9IG51bGwgJiYgci5saXZlKSB7XG4gICAgICB2YXIgaDtcbiAgICAgIGlmICh0aGlzLmNoZWNrTGl2ZVVwZGF0ZShhKSwgYS5kZWx0YVVwZGF0ZUZhaWxlZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgZCA9IHRoaXMuYWxpZ25QbGF5bGlzdHMoYSwgYy5kZXRhaWxzLCAoaCA9IHRoaXMubGV2ZWxMYXN0TG9hZGVkKSA9PSBudWxsID8gdm9pZCAwIDogaC5kZXRhaWxzKTtcbiAgICB9XG4gICAgaWYgKGMuZGV0YWlscyA9IGEsIHRoaXMubGV2ZWxMYXN0TG9hZGVkID0gYywgaSB8fCB0aGlzLnNldFN0YXJ0UG9zaXRpb24oYSwgZCksIHRoaXMuaGxzLnRyaWdnZXIoSS5MRVZFTF9VUERBVEVELCB7XG4gICAgICBkZXRhaWxzOiBhLFxuICAgICAgbGV2ZWw6IG9cbiAgICB9KSwgdGhpcy5zdGF0ZSA9PT0gbmUuV0FJVElOR19MRVZFTCkge1xuICAgICAgaWYgKHRoaXMud2FpdEZvckNkblR1bmVJbihhKSlcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5zdGF0ZSA9IG5lLklETEU7XG4gICAgfVxuICAgIGkgJiYgYS5saXZlICYmIHRoaXMuc3luY2hyb25pemVUb0xpdmVFZGdlKGEpLCB0aGlzLnRpY2soKTtcbiAgfVxuICBzeW5jaHJvbml6ZVRvTGl2ZUVkZ2UoZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZzogdCxcbiAgICAgIG1lZGlhOiByXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFyKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IG4gPSB0aGlzLmhscy5saXZlU3luY1Bvc2l0aW9uLCBpID0gdGhpcy5nZXRMb2FkUG9zaXRpb24oKSwgbyA9IGUuZnJhZ21lbnRTdGFydCwgYSA9IGUuZWRnZSwgbCA9IGkgPj0gbyAtIHQubWF4RnJhZ0xvb2tVcFRvbGVyYW5jZSAmJiBpIDw9IGE7XG4gICAgaWYgKG4gIT09IG51bGwgJiYgci5kdXJhdGlvbiA+IG4gJiYgKGkgPCBuIHx8ICFsKSkge1xuICAgICAgY29uc3QgdSA9IHQubGl2ZU1heExhdGVuY3lEdXJhdGlvbiAhPT0gdm9pZCAwID8gdC5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uIDogdC5saXZlTWF4TGF0ZW5jeUR1cmF0aW9uQ291bnQgKiBlLnRhcmdldGR1cmF0aW9uO1xuICAgICAgaWYgKCghbCAmJiByLnJlYWR5U3RhdGUgPCA0IHx8IGkgPCBhIC0gdSkgJiYgKHRoaXMuX2hhc0Vub3VnaFRvU3RhcnQgfHwgKHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IG4pLCByLnJlYWR5U3RhdGUpKVxuICAgICAgICBpZiAodGhpcy53YXJuKGBQbGF5YmFjazogJHtpLnRvRml4ZWQoMyl9IGlzIGxvY2F0ZWQgdG9vIGZhciBmcm9tIHRoZSBlbmQgb2YgbGl2ZSBzbGlkaW5nIHBsYXlsaXN0OiAke2F9LCByZXNldCBjdXJyZW50VGltZSB0byA6ICR7bi50b0ZpeGVkKDMpfWApLCB0aGlzLmNvbmZpZy5saXZlU3luY01vZGUgPT09IFwiYnVmZmVyZWRcIikge1xuICAgICAgICAgIHZhciBjO1xuICAgICAgICAgIGNvbnN0IGQgPSBDZS5idWZmZXJJbmZvKHIsIG4sIDApO1xuICAgICAgICAgIGlmICghKChjID0gZC5idWZmZXJlZCkgIT0gbnVsbCAmJiBjLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHIuY3VycmVudFRpbWUgPSBuO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZC5zdGFydCA8PSBpKSB7XG4gICAgICAgICAgICByLmN1cnJlbnRUaW1lID0gbjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgbmV4dFN0YXJ0OiBmXG4gICAgICAgICAgfSA9IENlLmJ1ZmZlcmVkSW5mbyhkLmJ1ZmZlcmVkLCBpLCAwKTtcbiAgICAgICAgICBmICYmIChyLmN1cnJlbnRUaW1lID0gZik7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHIuY3VycmVudFRpbWUgPSBuO1xuICAgIH1cbiAgfVxuICBfaGFuZGxlRnJhZ21lbnRMb2FkUHJvZ3Jlc3MoZSkge1xuICAgIHZhciB0O1xuICAgIGNvbnN0IHIgPSBlLmZyYWcsIHtcbiAgICAgIHBhcnQ6IG4sXG4gICAgICBwYXlsb2FkOiBpXG4gICAgfSA9IGUsIHtcbiAgICAgIGxldmVsczogb1xuICAgIH0gPSB0aGlzO1xuICAgIGlmICghbykge1xuICAgICAgdGhpcy53YXJuKGBMZXZlbHMgd2VyZSByZXNldCB3aGlsZSBmcmFnbWVudCBsb2FkIHdhcyBpbiBwcm9ncmVzcy4gRnJhZ21lbnQgJHtyLnNufSBvZiBsZXZlbCAke3IubGV2ZWx9IHdpbGwgbm90IGJlIGJ1ZmZlcmVkYCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGEgPSBvW3IubGV2ZWxdO1xuICAgIGlmICghYSkge1xuICAgICAgdGhpcy53YXJuKGBMZXZlbCAke3IubGV2ZWx9IG5vdCBmb3VuZCBvbiBwcm9ncmVzc2ApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsID0gYS5kZXRhaWxzO1xuICAgIGlmICghbCkge1xuICAgICAgdGhpcy53YXJuKGBEcm9wcGluZyBmcmFnbWVudCAke3Iuc259IG9mIGxldmVsICR7ci5sZXZlbH0gYWZ0ZXIgbGV2ZWwgZGV0YWlscyB3ZXJlIHJlc2V0YCksIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUZyYWdtZW50KHIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjID0gYS52aWRlb0NvZGVjLCB1ID0gbC5QVFNLbm93biB8fCAhbC5saXZlLCBkID0gKHQgPSByLmluaXRTZWdtZW50KSA9PSBudWxsID8gdm9pZCAwIDogdC5kYXRhLCBoID0gdGhpcy5fZ2V0QXVkaW9Db2RlYyhhKSwgZiA9IHRoaXMudHJhbnNtdXhlciA9IHRoaXMudHJhbnNtdXhlciB8fCBuZXcgd3AodGhpcy5obHMsIHBlLk1BSU4sIHRoaXMuX2hhbmRsZVRyYW5zbXV4Q29tcGxldGUuYmluZCh0aGlzKSwgdGhpcy5faGFuZGxlVHJhbnNtdXhlckZsdXNoLmJpbmQodGhpcykpLCBwID0gbiA/IG4uaW5kZXggOiAtMSwgeSA9IHAgIT09IC0xLCBFID0gbmV3IEV1KHIubGV2ZWwsIHIuc24sIHIuc3RhdHMuY2h1bmtDb3VudCwgaS5ieXRlTGVuZ3RoLCBwLCB5KSwgYiA9IHRoaXMuaW5pdFBUU1tyLmNjXTtcbiAgICBmLnB1c2goaSwgZCwgaCwgYywgciwgbiwgbC50b3RhbGR1cmF0aW9uLCB1LCBFLCBiKTtcbiAgfVxuICBvbkF1ZGlvVHJhY2tTd2l0Y2hpbmcoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0aGlzLmhscywgbiA9IHRoaXMuYWx0QXVkaW8gPT09IDI7XG4gICAgaWYgKFFvKHQudXJsLCByKSlcbiAgICAgIHRoaXMuYWx0QXVkaW8gPSAxO1xuICAgIGVsc2Uge1xuICAgICAgaWYgKHRoaXMubWVkaWFCdWZmZXIgIT09IHRoaXMubWVkaWEpIHtcbiAgICAgICAgdGhpcy5sb2coXCJTd2l0Y2hpbmcgb24gbWFpbiBhdWRpbywgdXNlIG1lZGlhLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZ1wiKSwgdGhpcy5tZWRpYUJ1ZmZlciA9IHRoaXMubWVkaWE7XG4gICAgICAgIGNvbnN0IG8gPSB0aGlzLmZyYWdDdXJyZW50O1xuICAgICAgICBvICYmICh0aGlzLmxvZyhcIlN3aXRjaGluZyB0byBtYWluIGF1ZGlvIHRyYWNrLCBjYW5jZWwgbWFpbiBmcmFnbWVudCBsb2FkXCIpLCBvLmFib3J0UmVxdWVzdHMoKSwgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQobykpLCB0aGlzLnJlc2V0VHJhbnNtdXhlcigpLCB0aGlzLnJlc2V0TG9hZGluZ1N0YXRlKCk7XG4gICAgICB9IGVsc2UgdGhpcy5hdWRpb09ubHkgJiYgdGhpcy5yZXNldFRyYW5zbXV4ZXIoKTtcbiAgICAgIGlmIChuKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRUcmFja2VyLnJlbW92ZUFsbEZyYWdtZW50cygpLCByLm9uY2UoSS5CVUZGRVJfRkxVU0hFRCwgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGxzICYmIHRoaXMuaGxzLnRyaWdnZXIoSS5BVURJT19UUkFDS19TV0lUQ0hFRCwgdCk7XG4gICAgICAgIH0pLCByLnRyaWdnZXIoSS5CVUZGRVJfRkxVU0hJTkcsIHtcbiAgICAgICAgICBzdGFydE9mZnNldDogMCxcbiAgICAgICAgICBlbmRPZmZzZXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgICB0eXBlOiBudWxsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByLnRyaWdnZXIoSS5BVURJT19UUkFDS19TV0lUQ0hFRCwgdCk7XG4gICAgfVxuICB9XG4gIG9uQXVkaW9UcmFja1N3aXRjaGVkKGUsIHQpIHtcbiAgICBjb25zdCByID0gUW8odC51cmwsIHRoaXMuaGxzKTtcbiAgICBpZiAocikge1xuICAgICAgY29uc3QgbiA9IHRoaXMudmlkZW9CdWZmZXI7XG4gICAgICBuICYmIHRoaXMubWVkaWFCdWZmZXIgIT09IG4gJiYgKHRoaXMubG9nKFwiU3dpdGNoaW5nIG9uIGFsdGVybmF0ZSBhdWRpbywgdXNlIHZpZGVvLmJ1ZmZlcmVkIHRvIHNjaGVkdWxlIG1haW4gZnJhZ21lbnQgbG9hZGluZ1wiKSwgdGhpcy5tZWRpYUJ1ZmZlciA9IG4pO1xuICAgIH1cbiAgICB0aGlzLmFsdEF1ZGlvID0gciA/IDIgOiAwLCB0aGlzLnRpY2soKTtcbiAgfVxuICBvbkJ1ZmZlckNyZWF0ZWQoZSwgdCkge1xuICAgIGNvbnN0IHIgPSB0LnRyYWNrcztcbiAgICBsZXQgbiwgaSwgbyA9ICExO1xuICAgIGZvciAoY29uc3QgYSBpbiByKSB7XG4gICAgICBjb25zdCBsID0gclthXTtcbiAgICAgIGlmIChsLmlkID09PSBcIm1haW5cIikge1xuICAgICAgICBpZiAoaSA9IGEsIG4gPSBsLCBhID09PSBcInZpZGVvXCIpIHtcbiAgICAgICAgICBjb25zdCBjID0gclthXTtcbiAgICAgICAgICBjICYmICh0aGlzLnZpZGVvQnVmZmVyID0gYy5idWZmZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2VcbiAgICAgICAgbyA9ICEwO1xuICAgIH1cbiAgICBvICYmIG4gPyAodGhpcy5sb2coYEFsdGVybmF0ZSB0cmFjayBmb3VuZCwgdXNlICR7aX0uYnVmZmVyZWQgdG8gc2NoZWR1bGUgbWFpbiBmcmFnbWVudCBsb2FkaW5nYCksIHRoaXMubWVkaWFCdWZmZXIgPSBuLmJ1ZmZlcikgOiB0aGlzLm1lZGlhQnVmZmVyID0gdGhpcy5tZWRpYTtcbiAgfVxuICBvbkZyYWdCdWZmZXJlZChlLCB0KSB7XG4gICAgY29uc3Qge1xuICAgICAgZnJhZzogcixcbiAgICAgIHBhcnQ6IG5cbiAgICB9ID0gdCwgaSA9IHIudHlwZSA9PT0gcGUuTUFJTjtcbiAgICBpZiAoaSkge1xuICAgICAgaWYgKHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKHIpKSB7XG4gICAgICAgIHRoaXMud2FybihgRnJhZ21lbnQgJHtyLnNufSR7biA/IFwiIHA6IFwiICsgbi5pbmRleCA6IFwiXCJ9IG9mIGxldmVsICR7ci5sZXZlbH0gZmluaXNoZWQgYnVmZmVyaW5nLCBidXQgd2FzIGFib3J0ZWQuIHN0YXRlOiAke3RoaXMuc3RhdGV9YCksIHRoaXMuc3RhdGUgPT09IG5lLlBBUlNFRCAmJiAodGhpcy5zdGF0ZSA9IG5lLklETEUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhID0gbiA/IG4uc3RhdHMgOiByLnN0YXRzO1xuICAgICAgdGhpcy5mcmFnTGFzdEticHMgPSBNYXRoLnJvdW5kKDggKiBhLnRvdGFsIC8gKGEuYnVmZmVyaW5nLmVuZCAtIGEubG9hZGluZy5maXJzdCkpLCBWdChyKSAmJiAodGhpcy5mcmFnUHJldmlvdXMgPSByKSwgdGhpcy5mcmFnQnVmZmVyZWRDb21wbGV0ZShyLCBuKTtcbiAgICB9XG4gICAgY29uc3QgbyA9IHRoaXMubWVkaWE7XG4gICAgbyAmJiAoIXRoaXMuX2hhc0Vub3VnaFRvU3RhcnQgJiYgQ2UuZ2V0QnVmZmVyZWQobykubGVuZ3RoICYmICh0aGlzLl9oYXNFbm91Z2hUb1N0YXJ0ID0gITAsIHRoaXMuc2Vla1RvU3RhcnRQb3MoKSksIGkgJiYgdGhpcy50aWNrKCkpO1xuICB9XG4gIGdldCBoYXNFbm91Z2hUb1N0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLl9oYXNFbm91Z2hUb1N0YXJ0O1xuICB9XG4gIG9uRXJyb3IoZSwgdCkge1xuICAgIHZhciByO1xuICAgIGlmICh0LmZhdGFsKSB7XG4gICAgICB0aGlzLnN0YXRlID0gbmUuRVJST1I7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAodC5kZXRhaWxzKSB7XG4gICAgICBjYXNlIEouRlJBR19HQVA6XG4gICAgICBjYXNlIEouRlJBR19QQVJTSU5HX0VSUk9SOlxuICAgICAgY2FzZSBKLkZSQUdfREVDUllQVF9FUlJPUjpcbiAgICAgIGNhc2UgSi5GUkFHX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEouRlJBR19MT0FEX1RJTUVPVVQ6XG4gICAgICBjYXNlIEouS0VZX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEouS0VZX0xPQURfVElNRU9VVDpcbiAgICAgICAgdGhpcy5vbkZyYWdtZW50T3JLZXlMb2FkRXJyb3IocGUuTUFJTiwgdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBKLkxFVkVMX0xPQURfRVJST1I6XG4gICAgICBjYXNlIEouTEVWRUxfTE9BRF9USU1FT1VUOlxuICAgICAgY2FzZSBKLkxFVkVMX1BBUlNJTkdfRVJST1I6XG4gICAgICAgICF0LmxldmVsUmV0cnkgJiYgdGhpcy5zdGF0ZSA9PT0gbmUuV0FJVElOR19MRVZFTCAmJiAoKHIgPSB0LmNvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiByLnR5cGUpID09PSBLZS5MRVZFTCAmJiAodGhpcy5zdGF0ZSA9IG5lLklETEUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSi5CVUZGRVJfQUREX0NPREVDX0VSUk9SOlxuICAgICAgY2FzZSBKLkJVRkZFUl9BUFBFTkRfRVJST1I6XG4gICAgICAgIGlmICh0LnBhcmVudCAhPT0gXCJtYWluXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyKHQpICYmIHRoaXMucmVzZXRMb2FkaW5nU3RhdGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEouQlVGRkVSX0ZVTExfRVJST1I6XG4gICAgICAgIGlmICh0LnBhcmVudCAhPT0gXCJtYWluXCIpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlZHVjZUxlbmd0aEFuZEZsdXNoQnVmZmVyKHQpICYmICghdGhpcy5jb25maWcuaW50ZXJzdGl0aWFsc0NvbnRyb2xsZXIgJiYgdGhpcy5jb25maWcuYXNzZXRQbGF5ZXJJZCA/IHRoaXMuX2hhc0Vub3VnaFRvU3RhcnQgPSAhMCA6IHRoaXMuZmx1c2hNYWluQnVmZmVyKDAsIE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSi5JTlRFUk5BTF9FWENFUFRJT046XG4gICAgICAgIHRoaXMucmVjb3ZlcldvcmtlckVycm9yKHQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgb25GcmFnTG9hZEVtZXJnZW5jeUFib3J0ZWQoKSB7XG4gICAgdGhpcy5zdGF0ZSA9IG5lLklETEUsIHRoaXMuX2hhc0Vub3VnaFRvU3RhcnQgfHwgKHRoaXMuc3RhcnRGcmFnUmVxdWVzdGVkID0gITEsIHRoaXMubmV4dExvYWRQb3NpdGlvbiA9IHRoaXMubGFzdEN1cnJlbnRUaW1lKSwgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gIH1cbiAgb25CdWZmZXJGbHVzaGVkKGUsIHtcbiAgICB0eXBlOiB0XG4gIH0pIHtcbiAgICBpZiAodCAhPT0gb3QuQVVESU8gfHwgIXRoaXMuYWx0QXVkaW8pIHtcbiAgICAgIGNvbnN0IHIgPSAodCA9PT0gb3QuVklERU8gPyB0aGlzLnZpZGVvQnVmZmVyIDogdGhpcy5tZWRpYUJ1ZmZlcikgfHwgdGhpcy5tZWRpYTtcbiAgICAgIHIgJiYgKHRoaXMuYWZ0ZXJCdWZmZXJGbHVzaGVkKHIsIHQsIHBlLk1BSU4pLCB0aGlzLnRpY2soKSk7XG4gICAgfVxuICB9XG4gIG9uTGV2ZWxzVXBkYXRlZChlLCB0KSB7XG4gICAgdGhpcy5sZXZlbCA+IC0xICYmIHRoaXMuZnJhZ0N1cnJlbnQgJiYgKHRoaXMubGV2ZWwgPSB0aGlzLmZyYWdDdXJyZW50LmxldmVsLCB0aGlzLmxldmVsID09PSAtMSAmJiB0aGlzLnJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KHRoaXMuZnJhZ0N1cnJlbnQpKSwgdGhpcy5sZXZlbHMgPSB0LmxldmVscztcbiAgfVxuICBzd2FwQXVkaW9Db2RlYygpIHtcbiAgICB0aGlzLmF1ZGlvQ29kZWNTd2FwID0gIXRoaXMuYXVkaW9Db2RlY1N3YXA7XG4gIH1cbiAgLyoqXG4gICAqIFNlZWtzIHRvIHRoZSBzZXQgc3RhcnRQb3NpdGlvbiBpZiBub3QgZXF1YWwgdG8gdGhlIG1lZGlhRWxlbWVudCdzIGN1cnJlbnQgdGltZS5cbiAgICovXG4gIHNlZWtUb1N0YXJ0UG9zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG1lZGlhOiBlXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKCFlKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHQgPSBlLmN1cnJlbnRUaW1lO1xuICAgIGxldCByID0gdGhpcy5zdGFydFBvc2l0aW9uO1xuICAgIGlmIChyID49IDAgJiYgdCA8IHIpIHtcbiAgICAgIGlmIChlLnNlZWtpbmcpIHtcbiAgICAgICAgdGhpcy5sb2coYGNvdWxkIG5vdCBzZWVrIHRvICR7cn0sIGFscmVhZHkgc2Vla2luZyBhdCAke3R9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG4gPSB0aGlzLnRpbWVsaW5lT2Zmc2V0O1xuICAgICAgbiAmJiByICYmIChyICs9IG4pO1xuICAgICAgY29uc3QgaSA9IHRoaXMuZ2V0TGV2ZWxEZXRhaWxzKCksIG8gPSBDZS5nZXRCdWZmZXJlZChlKSwgYSA9IG8ubGVuZ3RoID8gby5zdGFydCgwKSA6IDAsIGwgPSBhIC0gciwgYyA9IE1hdGgubWF4KHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUsIHRoaXMuY29uZmlnLm1heEZyYWdMb29rVXBUb2xlcmFuY2UpO1xuICAgICAgKHRoaXMuY29uZmlnLnN0YXJ0T25TZWdtZW50Qm91bmRhcnkgfHwgbCA+IDAgJiYgKGwgPCBjIHx8IHRoaXMubG9hZGluZ1BhcnRzICYmIGwgPCAyICogKChpID09IG51bGwgPyB2b2lkIDAgOiBpLnBhcnRUYXJnZXQpIHx8IDApKSkgJiYgKHRoaXMubG9nKGBhZGp1c3Rpbmcgc3RhcnQgcG9zaXRpb24gYnkgJHtsfSB0byBtYXRjaCBidWZmZXIgc3RhcnRgKSwgciArPSBsLCB0aGlzLnN0YXJ0UG9zaXRpb24gPSByKSwgdCA8IHIgJiYgKHRoaXMubG9nKGBzZWVrIHRvIHRhcmdldCBzdGFydCBwb3NpdGlvbiAke3J9IGZyb20gY3VycmVudCB0aW1lICR7dH0gYnVmZmVyIHN0YXJ0ICR7YX1gKSwgZS5jdXJyZW50VGltZSA9IHIpO1xuICAgIH1cbiAgfVxuICBfZ2V0QXVkaW9Db2RlYyhlKSB7XG4gICAgbGV0IHQgPSB0aGlzLmNvbmZpZy5kZWZhdWx0QXVkaW9Db2RlYyB8fCBlLmF1ZGlvQ29kZWM7XG4gICAgcmV0dXJuIHRoaXMuYXVkaW9Db2RlY1N3YXAgJiYgdCAmJiAodGhpcy5sb2coXCJTd2FwcGluZyBhdWRpbyBjb2RlY1wiKSwgdC5pbmRleE9mKFwibXA0YS40MC41XCIpICE9PSAtMSA/IHQgPSBcIm1wNGEuNDAuMlwiIDogdCA9IFwibXA0YS40MC41XCIpLCB0O1xuICB9XG4gIF9sb2FkQml0cmF0ZVRlc3RGcmFnKGUsIHQpIHtcbiAgICBlLmJpdHJhdGVUZXN0ID0gITAsIHRoaXMuX2RvRnJhZ0xvYWQoZSwgdCkudGhlbigocikgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBobHM6IG5cbiAgICAgIH0gPSB0aGlzLCBpID0gciA9PSBudWxsID8gdm9pZCAwIDogci5mcmFnO1xuICAgICAgaWYgKCFpIHx8IHRoaXMuZnJhZ0NvbnRleHRDaGFuZ2VkKGkpKVxuICAgICAgICByZXR1cm47XG4gICAgICB0LmZyYWdtZW50RXJyb3IgPSAwLCB0aGlzLnN0YXRlID0gbmUuSURMRSwgdGhpcy5zdGFydEZyYWdSZXF1ZXN0ZWQgPSAhMSwgdGhpcy5iaXRyYXRlVGVzdCA9ICExO1xuICAgICAgY29uc3QgbyA9IGkuc3RhdHM7XG4gICAgICBvLnBhcnNpbmcuc3RhcnQgPSBvLnBhcnNpbmcuZW5kID0gby5idWZmZXJpbmcuc3RhcnQgPSBvLmJ1ZmZlcmluZy5lbmQgPSBzZWxmLnBlcmZvcm1hbmNlLm5vdygpLCBuLnRyaWdnZXIoSS5GUkFHX0xPQURFRCwgciksIGkuYml0cmF0ZVRlc3QgPSAhMTtcbiAgICB9KS5jYXRjaCgocikgPT4ge1xuICAgICAgdGhpcy5zdGF0ZSA9PT0gbmUuU1RPUFBFRCB8fCB0aGlzLnN0YXRlID09PSBuZS5FUlJPUiB8fCAodGhpcy53YXJuKHIpLCB0aGlzLnJlc2V0RnJhZ21lbnRMb2FkaW5nKGUpKTtcbiAgICB9KTtcbiAgfVxuICBfaGFuZGxlVHJhbnNtdXhDb21wbGV0ZShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMucGxheWxpc3RUeXBlLCB7XG4gICAgICBobHM6IHJcbiAgICB9ID0gdGhpcywge1xuICAgICAgcmVtdXhSZXN1bHQ6IG4sXG4gICAgICBjaHVua01ldGE6IGlcbiAgICB9ID0gZSwgbyA9IHRoaXMuZ2V0Q3VycmVudENvbnRleHQoaSk7XG4gICAgaWYgKCFvKSB7XG4gICAgICB0aGlzLnJlc2V0V2hlbk1pc3NpbmdDb250ZXh0KGkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBmcmFnOiBhLFxuICAgICAgcGFydDogbCxcbiAgICAgIGxldmVsOiBjXG4gICAgfSA9IG8sIHtcbiAgICAgIHZpZGVvOiB1LFxuICAgICAgdGV4dDogZCxcbiAgICAgIGlkMzogaCxcbiAgICAgIGluaXRTZWdtZW50OiBmXG4gICAgfSA9IG4sIHtcbiAgICAgIGRldGFpbHM6IHBcbiAgICB9ID0gYywgeSA9IHRoaXMuYWx0QXVkaW8gPyB2b2lkIDAgOiBuLmF1ZGlvO1xuICAgIGlmICh0aGlzLmZyYWdDb250ZXh0Q2hhbmdlZChhKSkge1xuICAgICAgdGhpcy5mcmFnbWVudFRyYWNrZXIucmVtb3ZlRnJhZ21lbnQoYSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID0gbmUuUEFSU0lORywgZikge1xuICAgICAgY29uc3QgRSA9IGYudHJhY2tzO1xuICAgICAgaWYgKEUpIHtcbiAgICAgICAgY29uc3QgRiA9IGEuaW5pdFNlZ21lbnQgfHwgYTtcbiAgICAgICAgaWYgKHRoaXMudW5oYW5kbGVkRW5jcnlwdGlvbkVycm9yKGYsIGEpKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fYnVmZmVySW5pdFNlZ21lbnQoYywgRSwgRiwgaSksIHIudHJpZ2dlcihJLkZSQUdfUEFSU0lOR19JTklUX1NFR01FTlQsIHtcbiAgICAgICAgICBmcmFnOiBGLFxuICAgICAgICAgIGlkOiB0LFxuICAgICAgICAgIHRyYWNrczogRVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGIgPSBmLmluaXRQVFMsIFIgPSBmLnRpbWVzY2FsZSwgQSA9IHRoaXMuaW5pdFBUU1thLmNjXTtcbiAgICAgIGlmICh1ZShiKSAmJiAoIUEgfHwgQS5iYXNlVGltZSAhPT0gYiB8fCBBLnRpbWVzY2FsZSAhPT0gUikpIHtcbiAgICAgICAgY29uc3QgRiA9IGYudHJhY2tJZDtcbiAgICAgICAgdGhpcy5pbml0UFRTW2EuY2NdID0ge1xuICAgICAgICAgIGJhc2VUaW1lOiBiLFxuICAgICAgICAgIHRpbWVzY2FsZTogUixcbiAgICAgICAgICB0cmFja0lkOiBGXG4gICAgICAgIH0sIHIudHJpZ2dlcihJLklOSVRfUFRTX0ZPVU5ELCB7XG4gICAgICAgICAgZnJhZzogYSxcbiAgICAgICAgICBpZDogdCxcbiAgICAgICAgICBpbml0UFRTOiBiLFxuICAgICAgICAgIHRpbWVzY2FsZTogUixcbiAgICAgICAgICB0cmFja0lkOiBGXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodSAmJiBwKSB7XG4gICAgICB5ICYmIHUudHlwZSA9PT0gXCJhdWRpb3ZpZGVvXCIgJiYgdGhpcy5sb2dNdXhlZEVycihhKTtcbiAgICAgIGNvbnN0IEUgPSBwLmZyYWdtZW50c1thLnNuIC0gMSAtIHAuc3RhcnRTTl0sIGIgPSBhLnNuID09PSBwLnN0YXJ0U04sIFIgPSAhRSB8fCBhLmNjID4gRS5jYztcbiAgICAgIGlmIChuLmluZGVwZW5kZW50ICE9PSAhMSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgc3RhcnRQVFM6IEEsXG4gICAgICAgICAgZW5kUFRTOiBGLFxuICAgICAgICAgIHN0YXJ0RFRTOiBNLFxuICAgICAgICAgIGVuZERUUzogSFxuICAgICAgICB9ID0gdTtcbiAgICAgICAgaWYgKGwpXG4gICAgICAgICAgbC5lbGVtZW50YXJ5U3RyZWFtc1t1LnR5cGVdID0ge1xuICAgICAgICAgICAgc3RhcnRQVFM6IEEsXG4gICAgICAgICAgICBlbmRQVFM6IEYsXG4gICAgICAgICAgICBzdGFydERUUzogTSxcbiAgICAgICAgICAgIGVuZERUUzogSFxuICAgICAgICAgIH07XG4gICAgICAgIGVsc2UgaWYgKHUuZmlyc3RLZXlGcmFtZSAmJiB1LmluZGVwZW5kZW50ICYmIGkuaWQgPT09IDEgJiYgIVIgJiYgKHRoaXMuY291bGRCYWNrdHJhY2sgPSAhMCksIHUuZHJvcHBlZCAmJiB1LmluZGVwZW5kZW50KSB7XG4gICAgICAgICAgY29uc3QgSyA9IHRoaXMuZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKSwgaiA9IChLID8gSy5lbmQgOiB0aGlzLmdldExvYWRQb3NpdGlvbigpKSArIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUsIEMgPSB1LmZpcnN0S2V5RnJhbWVQVFMgPyB1LmZpcnN0S2V5RnJhbWVQVFMgOiBBO1xuICAgICAgICAgIGlmICghYiAmJiBqIDwgQyAtIHRoaXMuY29uZmlnLm1heEJ1ZmZlckhvbGUgJiYgIVIpIHtcbiAgICAgICAgICAgIHRoaXMuYmFja3RyYWNrKGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gZWxzZSBSICYmIChhLmdhcCA9ICEwKTtcbiAgICAgICAgICBhLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKHUudHlwZSwgYS5zdGFydCwgRiwgYS5zdGFydCwgSCwgITApO1xuICAgICAgICB9IGVsc2UgYiAmJiBBIC0gKHAuYXBwbGllZFRpbWVsaW5lT2Zmc2V0IHx8IDApID4geG8gJiYgKGEuZ2FwID0gITApO1xuICAgICAgICBhLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKHUudHlwZSwgQSwgRiwgTSwgSCksIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgJiYgKHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBhKSwgdGhpcy5idWZmZXJGcmFnbWVudERhdGEodSwgYSwgbCwgaSwgYiB8fCBSKTtcbiAgICAgIH0gZWxzZSBpZiAoYiB8fCBSKVxuICAgICAgICBhLmdhcCA9ICEwO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuYmFja3RyYWNrKGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh5KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0YXJ0UFRTOiBFLFxuICAgICAgICBlbmRQVFM6IGIsXG4gICAgICAgIHN0YXJ0RFRTOiBSLFxuICAgICAgICBlbmREVFM6IEFcbiAgICAgIH0gPSB5O1xuICAgICAgbCAmJiAobC5lbGVtZW50YXJ5U3RyZWFtc1tvdC5BVURJT10gPSB7XG4gICAgICAgIHN0YXJ0UFRTOiBFLFxuICAgICAgICBlbmRQVFM6IGIsXG4gICAgICAgIHN0YXJ0RFRTOiBSLFxuICAgICAgICBlbmREVFM6IEFcbiAgICAgIH0pLCBhLnNldEVsZW1lbnRhcnlTdHJlYW1JbmZvKG90LkFVRElPLCBFLCBiLCBSLCBBKSwgdGhpcy5idWZmZXJGcmFnbWVudERhdGEoeSwgYSwgbCwgaSk7XG4gICAgfVxuICAgIGlmIChwICYmIGggIT0gbnVsbCAmJiBoLnNhbXBsZXMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBFID0ge1xuICAgICAgICBpZDogdCxcbiAgICAgICAgZnJhZzogYSxcbiAgICAgICAgZGV0YWlsczogcCxcbiAgICAgICAgc2FtcGxlczogaC5zYW1wbGVzXG4gICAgICB9O1xuICAgICAgci50cmlnZ2VyKEkuRlJBR19QQVJTSU5HX01FVEFEQVRBLCBFKTtcbiAgICB9XG4gICAgaWYgKHAgJiYgZCkge1xuICAgICAgY29uc3QgRSA9IHtcbiAgICAgICAgaWQ6IHQsXG4gICAgICAgIGZyYWc6IGEsXG4gICAgICAgIGRldGFpbHM6IHAsXG4gICAgICAgIHNhbXBsZXM6IGQuc2FtcGxlc1xuICAgICAgfTtcbiAgICAgIHIudHJpZ2dlcihJLkZSQUdfUEFSU0lOR19VU0VSREFUQSwgRSk7XG4gICAgfVxuICB9XG4gIGxvZ011eGVkRXJyKGUpIHtcbiAgICB0aGlzLndhcm4oYCR7VnQoZSkgPyBcIk1lZGlhXCIgOiBcIkluaXRcIn0gc2VnbWVudCB3aXRoIG11eGVkIGF1ZGlvdmlkZW8gd2hlcmUgb25seSB2aWRlbyBleHBlY3RlZDogJHtlLnVybH1gKTtcbiAgfVxuICBfYnVmZmVySW5pdFNlZ21lbnQoZSwgdCwgciwgbikge1xuICAgIGlmICh0aGlzLnN0YXRlICE9PSBuZS5QQVJTSU5HKVxuICAgICAgcmV0dXJuO1xuICAgIHRoaXMuYXVkaW9Pbmx5ID0gISF0LmF1ZGlvICYmICF0LnZpZGVvLCB0aGlzLmFsdEF1ZGlvICYmICF0aGlzLmF1ZGlvT25seSAmJiAoZGVsZXRlIHQuYXVkaW8sIHQuYXVkaW92aWRlbyAmJiB0aGlzLmxvZ011eGVkRXJyKHIpKTtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpbzogaSxcbiAgICAgIHZpZGVvOiBvLFxuICAgICAgYXVkaW92aWRlbzogYVxuICAgIH0gPSB0O1xuICAgIGlmIChpKSB7XG4gICAgICBjb25zdCBjID0gZS5hdWRpb0NvZGVjO1xuICAgICAgbGV0IHUgPSBmbyhpLmNvZGVjLCBjKTtcbiAgICAgIHUgPT09IFwibXA0YVwiICYmICh1ID0gXCJtcDRhLjQwLjVcIik7XG4gICAgICBjb25zdCBkID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKHRoaXMuYXVkaW9Db2RlY1N3aXRjaCkge1xuICAgICAgICB1ICYmICh1LmluZGV4T2YoXCJtcDRhLjQwLjVcIikgIT09IC0xID8gdSA9IFwibXA0YS40MC4yXCIgOiB1ID0gXCJtcDRhLjQwLjVcIik7XG4gICAgICAgIGNvbnN0IGggPSBpLm1ldGFkYXRhO1xuICAgICAgICBoICYmIFwiY2hhbm5lbENvdW50XCIgaW4gaCAmJiAoaC5jaGFubmVsQ291bnQgfHwgMSkgIT09IDEgJiYgZC5pbmRleE9mKFwiZmlyZWZveFwiKSA9PT0gLTEgJiYgKHUgPSBcIm1wNGEuNDAuNVwiKTtcbiAgICAgIH1cbiAgICAgIHUgJiYgdS5pbmRleE9mKFwibXA0YS40MC41XCIpICE9PSAtMSAmJiBkLmluZGV4T2YoXCJhbmRyb2lkXCIpICE9PSAtMSAmJiBpLmNvbnRhaW5lciAhPT0gXCJhdWRpby9tcGVnXCIgJiYgKHUgPSBcIm1wNGEuNDAuMlwiLCB0aGlzLmxvZyhgQW5kcm9pZDogZm9yY2UgYXVkaW8gY29kZWMgdG8gJHt1fWApKSwgYyAmJiBjICE9PSB1ICYmIHRoaXMubG9nKGBTd2FwcGluZyBtYW5pZmVzdCBhdWRpbyBjb2RlYyBcIiR7Y31cIiBmb3IgXCIke3V9XCJgKSwgaS5sZXZlbENvZGVjID0gdSwgaS5pZCA9IHBlLk1BSU4sIHRoaXMubG9nKGBJbml0IGF1ZGlvIGJ1ZmZlciwgY29udGFpbmVyOiR7aS5jb250YWluZXJ9LCBjb2RlY3Nbc2VsZWN0ZWQvbGV2ZWwvcGFyc2VkXT1bJHt1IHx8IFwiXCJ9LyR7YyB8fCBcIlwifS8ke2kuY29kZWN9XWApLCBkZWxldGUgdC5hdWRpb3ZpZGVvO1xuICAgIH1cbiAgICBpZiAobykge1xuICAgICAgby5sZXZlbENvZGVjID0gZS52aWRlb0NvZGVjLCBvLmlkID0gcGUuTUFJTjtcbiAgICAgIGNvbnN0IGMgPSBvLmNvZGVjO1xuICAgICAgaWYgKChjID09IG51bGwgPyB2b2lkIDAgOiBjLmxlbmd0aCkgPT09IDQpXG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgIGNhc2UgXCJodmMxXCI6XG4gICAgICAgICAgY2FzZSBcImhldjFcIjpcbiAgICAgICAgICAgIG8uY29kZWMgPSBcImh2YzEuMS42LkwxMjAuOTBcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJhdjAxXCI6XG4gICAgICAgICAgICBvLmNvZGVjID0gXCJhdjAxLjAuMDRNLjA4XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiYXZjMVwiOlxuICAgICAgICAgICAgby5jb2RlYyA9IFwiYXZjMS40MmUwMWVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB0aGlzLmxvZyhgSW5pdCB2aWRlbyBidWZmZXIsIGNvbnRhaW5lcjoke28uY29udGFpbmVyfSwgY29kZWNzW2xldmVsL3BhcnNlZF09WyR7ZS52aWRlb0NvZGVjIHx8IFwiXCJ9LyR7Y31dJHtvLmNvZGVjICE9PSBjID8gXCIgcGFyc2VkLWNvcnJlY3RlZD1cIiArIG8uY29kZWMgOiBcIlwifSR7by5zdXBwbGVtZW50YWwgPyBcIiBzdXBwbGVtZW50YWw9XCIgKyBvLnN1cHBsZW1lbnRhbCA6IFwiXCJ9YCksIGRlbGV0ZSB0LmF1ZGlvdmlkZW87XG4gICAgfVxuICAgIGEgJiYgKHRoaXMubG9nKGBJbml0IGF1ZGlvdmlkZW8gYnVmZmVyLCBjb250YWluZXI6JHthLmNvbnRhaW5lcn0sIGNvZGVjc1tsZXZlbC9wYXJzZWRdPVske2UuY29kZWNzfS8ke2EuY29kZWN9XWApLCBkZWxldGUgdC52aWRlbywgZGVsZXRlIHQuYXVkaW8pO1xuICAgIGNvbnN0IGwgPSBPYmplY3Qua2V5cyh0KTtcbiAgICBpZiAobC5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLmhscy50cmlnZ2VyKEkuQlVGRkVSX0NPREVDUywgdCksICF0aGlzLmhscylcbiAgICAgICAgcmV0dXJuO1xuICAgICAgbC5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgIGNvbnN0IGQgPSB0W2NdLmluaXRTZWdtZW50O1xuICAgICAgICBkICE9IG51bGwgJiYgZC5ieXRlTGVuZ3RoICYmIHRoaXMuaGxzLnRyaWdnZXIoSS5CVUZGRVJfQVBQRU5ESU5HLCB7XG4gICAgICAgICAgdHlwZTogYyxcbiAgICAgICAgICBkYXRhOiBkLFxuICAgICAgICAgIGZyYWc6IHIsXG4gICAgICAgICAgcGFydDogbnVsbCxcbiAgICAgICAgICBjaHVua01ldGE6IG4sXG4gICAgICAgICAgcGFyZW50OiByLnR5cGVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy50aWNrSW1tZWRpYXRlKCk7XG4gIH1cbiAgZ2V0TWFpbkZ3ZEJ1ZmZlckluZm8oKSB7XG4gICAgY29uc3QgZSA9IHRoaXMubWVkaWFCdWZmZXIgJiYgdGhpcy5hbHRBdWRpbyA9PT0gMiA/IHRoaXMubWVkaWFCdWZmZXIgOiB0aGlzLm1lZGlhO1xuICAgIHJldHVybiB0aGlzLmdldEZ3ZEJ1ZmZlckluZm8oZSwgcGUuTUFJTik7XG4gIH1cbiAgZ2V0IG1heEJ1ZmZlckxlbmd0aCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHM6IGUsXG4gICAgICBsZXZlbDogdFxuICAgIH0gPSB0aGlzLCByID0gZSA9PSBudWxsID8gdm9pZCAwIDogZVt0XTtcbiAgICByZXR1cm4gciA/IHRoaXMuZ2V0TWF4QnVmZmVyTGVuZ3RoKHIubWF4Qml0cmF0ZSkgOiB0aGlzLmNvbmZpZy5tYXhCdWZmZXJMZW5ndGg7XG4gIH1cbiAgYmFja3RyYWNrKGUpIHtcbiAgICB0aGlzLmNvdWxkQmFja3RyYWNrID0gITAsIHRoaXMuYmFja3RyYWNrRnJhZ21lbnQgPSBlLCB0aGlzLnJlc2V0VHJhbnNtdXhlcigpLCB0aGlzLmZsdXNoQnVmZmVyR2FwKGUpLCB0aGlzLmZyYWdtZW50VHJhY2tlci5yZW1vdmVGcmFnbWVudChlKSwgdGhpcy5mcmFnUHJldmlvdXMgPSBudWxsLCB0aGlzLm5leHRMb2FkUG9zaXRpb24gPSBlLnN0YXJ0LCB0aGlzLnN0YXRlID0gbmUuSURMRTtcbiAgfVxuICBjaGVja0ZyYWdtZW50Q2hhbmdlZCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5tZWRpYTtcbiAgICBsZXQgdCA9IG51bGw7XG4gICAgaWYgKGUgJiYgZS5yZWFkeVN0YXRlID4gMSAmJiBlLnNlZWtpbmcgPT09ICExKSB7XG4gICAgICBjb25zdCByID0gZS5jdXJyZW50VGltZTtcbiAgICAgIGlmIChDZS5pc0J1ZmZlcmVkKGUsIHIpID8gdCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKHIpIDogQ2UuaXNCdWZmZXJlZChlLCByICsgMC4xKSAmJiAodCA9IHRoaXMuZ2V0QXBwZW5kZWRGcmFnKHIgKyAwLjEpKSwgdCkge1xuICAgICAgICB0aGlzLmJhY2t0cmFja0ZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgY29uc3QgbiA9IHRoaXMuZnJhZ1BsYXlpbmcsIGkgPSB0LmxldmVsO1xuICAgICAgICAoIW4gfHwgdC5zbiAhPT0gbi5zbiB8fCBuLmxldmVsICE9PSBpKSAmJiAodGhpcy5mcmFnUGxheWluZyA9IHQsIHRoaXMuaGxzLnRyaWdnZXIoSS5GUkFHX0NIQU5HRUQsIHtcbiAgICAgICAgICBmcmFnOiB0XG4gICAgICAgIH0pLCAoIW4gfHwgbi5sZXZlbCAhPT0gaSkgJiYgdGhpcy5obHMudHJpZ2dlcihJLkxFVkVMX1NXSVRDSEVELCB7XG4gICAgICAgICAgbGV2ZWw6IGlcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXQgbmV4dExldmVsKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLm5leHRCdWZmZXJlZEZyYWc7XG4gICAgcmV0dXJuIGUgPyBlLmxldmVsIDogLTE7XG4gIH1cbiAgZ2V0IGN1cnJlbnRGcmFnKCkge1xuICAgIHZhciBlO1xuICAgIGlmICh0aGlzLmZyYWdQbGF5aW5nKVxuICAgICAgcmV0dXJuIHRoaXMuZnJhZ1BsYXlpbmc7XG4gICAgY29uc3QgdCA9ICgoZSA9IHRoaXMubWVkaWEpID09IG51bGwgPyB2b2lkIDAgOiBlLmN1cnJlbnRUaW1lKSB8fCB0aGlzLmxhc3RDdXJyZW50VGltZTtcbiAgICByZXR1cm4gdWUodCkgPyB0aGlzLmdldEFwcGVuZGVkRnJhZyh0KSA6IG51bGw7XG4gIH1cbiAgZ2V0IGN1cnJlbnRQcm9ncmFtRGF0ZVRpbWUoKSB7XG4gICAgdmFyIGU7XG4gICAgY29uc3QgdCA9ICgoZSA9IHRoaXMubWVkaWEpID09IG51bGwgPyB2b2lkIDAgOiBlLmN1cnJlbnRUaW1lKSB8fCB0aGlzLmxhc3RDdXJyZW50VGltZTtcbiAgICBpZiAodWUodCkpIHtcbiAgICAgIGNvbnN0IHIgPSB0aGlzLmdldExldmVsRGV0YWlscygpLCBuID0gdGhpcy5jdXJyZW50RnJhZyB8fCAociA/IEpzKG51bGwsIHIuZnJhZ21lbnRzLCB0KSA6IG51bGwpO1xuICAgICAgaWYgKG4pIHtcbiAgICAgICAgY29uc3QgaSA9IG4ucHJvZ3JhbURhdGVUaW1lO1xuICAgICAgICBpZiAoaSAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IG8gPSBpICsgKHQgLSBuLnN0YXJ0KSAqIDFlMztcbiAgICAgICAgICByZXR1cm4gbmV3IERhdGUobyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZ2V0IGN1cnJlbnRMZXZlbCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jdXJyZW50RnJhZztcbiAgICByZXR1cm4gZSA/IGUubGV2ZWwgOiAtMTtcbiAgfVxuICBnZXQgbmV4dEJ1ZmZlcmVkRnJhZygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5jdXJyZW50RnJhZztcbiAgICByZXR1cm4gZSA/IHRoaXMuZm9sbG93aW5nQnVmZmVyZWRGcmFnKGUpIDogbnVsbDtcbiAgfVxuICBnZXQgZm9yY2VTdGFydExvYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlU3RhcnRMb2FkO1xuICB9XG59XG5jbGFzcyBiQSBleHRlbmRzIExyIHtcbiAgY29uc3RydWN0b3IoZSwgdCkge1xuICAgIHN1cGVyKFwia2V5LWxvYWRlclwiLCB0KSwgdGhpcy5jb25maWcgPSB2b2lkIDAsIHRoaXMua2V5SWRUb0tleUluZm8gPSB7fSwgdGhpcy5lbWVDb250cm9sbGVyID0gbnVsbCwgdGhpcy5jb25maWcgPSBlO1xuICB9XG4gIGFib3J0KGUpIHtcbiAgICBmb3IgKGNvbnN0IHIgaW4gdGhpcy5rZXlJZFRvS2V5SW5mbykge1xuICAgICAgY29uc3QgbiA9IHRoaXMua2V5SWRUb0tleUluZm9bcl0ubG9hZGVyO1xuICAgICAgaWYgKG4pIHtcbiAgICAgICAgdmFyIHQ7XG4gICAgICAgIGlmIChlICYmIGUgIT09ICgodCA9IG4uY29udGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IHQuZnJhZy50eXBlKSlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIG4uYWJvcnQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZGV0YWNoKCkge1xuICAgIGZvciAoY29uc3QgZSBpbiB0aGlzLmtleUlkVG9LZXlJbmZvKSB7XG4gICAgICBjb25zdCB0ID0gdGhpcy5rZXlJZFRvS2V5SW5mb1tlXTtcbiAgICAgICh0Lm1lZGlhS2V5U2Vzc2lvbkNvbnRleHQgfHwgdC5kZWNyeXB0ZGF0YS5pc0NvbW1vbkVuY3J5cHRpb24pICYmIGRlbGV0ZSB0aGlzLmtleUlkVG9LZXlJbmZvW2VdO1xuICAgIH1cbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgZm9yIChjb25zdCBlIGluIHRoaXMua2V5SWRUb0tleUluZm8pIHtcbiAgICAgIGNvbnN0IHQgPSB0aGlzLmtleUlkVG9LZXlJbmZvW2VdLmxvYWRlcjtcbiAgICAgIHQgJiYgdC5kZXN0cm95KCk7XG4gICAgfVxuICAgIHRoaXMua2V5SWRUb0tleUluZm8gPSB7fTtcbiAgfVxuICBjcmVhdGVLZXlMb2FkRXJyb3IoZSwgdCA9IEouS0VZX0xPQURfRVJST1IsIHIsIG4sIGkpIHtcbiAgICByZXR1cm4gbmV3IGFzKHtcbiAgICAgIHR5cGU6IHZlLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzOiB0LFxuICAgICAgZmF0YWw6ICExLFxuICAgICAgZnJhZzogZSxcbiAgICAgIHJlc3BvbnNlOiBpLFxuICAgICAgZXJyb3I6IHIsXG4gICAgICBuZXR3b3JrRGV0YWlsczogblxuICAgIH0pO1xuICB9XG4gIGxvYWRDbGVhcihlLCB0LCByKSB7XG4gICAgaWYgKHRoaXMuZW1lQ29udHJvbGxlciAmJiB0aGlzLmNvbmZpZy5lbWVFbmFibGVkICYmICF0aGlzLmVtZUNvbnRyb2xsZXIuZ2V0U2VsZWN0ZWRLZXlTeXN0ZW1Gb3JtYXRzKCkubGVuZ3RoKSB7XG4gICAgICBpZiAodC5sZW5ndGgpXG4gICAgICAgIGZvciAobGV0IG4gPSAwLCBpID0gdC5sZW5ndGg7IG4gPCBpOyBuKyspIHtcbiAgICAgICAgICBjb25zdCBvID0gdFtuXTtcbiAgICAgICAgICBpZiAoZS5jYyA8PSBvLmNjICYmICghVnQoZSkgfHwgIVZ0KG8pIHx8IGUuc24gPCBvLnNuKSB8fCAhciAmJiBuID09IGkgLSAxKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW1lQ29udHJvbGxlci5zZWxlY3RLZXlTeXN0ZW1Gb3JtYXQobykudGhlbigoYSkgPT4ge1xuICAgICAgICAgICAgICBpZiAoIXRoaXMuZW1lQ29udHJvbGxlcilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIG8uc2V0S2V5Rm9ybWF0KGEpO1xuICAgICAgICAgICAgICBjb25zdCBsID0gcG8oYSk7XG4gICAgICAgICAgICAgIGlmIChsKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVtZUNvbnRyb2xsZXIuZ2V0S2V5U3lzdGVtQWNjZXNzKFtsXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29uZmlnLnJlcXVpcmVLZXlTeXN0ZW1BY2Nlc3NPblN0YXJ0KSB7XG4gICAgICAgIGNvbnN0IG4gPSB6bih0aGlzLmNvbmZpZyk7XG4gICAgICAgIGlmIChuLmxlbmd0aClcbiAgICAgICAgICByZXR1cm4gdGhpcy5lbWVDb250cm9sbGVyLmdldEtleVN5c3RlbUFjY2VzcyhuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbG9hZChlKSB7XG4gICAgcmV0dXJuICFlLmRlY3J5cHRkYXRhICYmIGUuZW5jcnlwdGVkICYmIHRoaXMuZW1lQ29udHJvbGxlciAmJiB0aGlzLmNvbmZpZy5lbWVFbmFibGVkID8gdGhpcy5lbWVDb250cm9sbGVyLnNlbGVjdEtleVN5c3RlbUZvcm1hdChlKS50aGVuKCh0KSA9PiB0aGlzLmxvYWRJbnRlcm5hbChlLCB0KSkgOiB0aGlzLmxvYWRJbnRlcm5hbChlKTtcbiAgfVxuICBsb2FkSW50ZXJuYWwoZSwgdCkge1xuICAgIHZhciByLCBuO1xuICAgIHQgJiYgZS5zZXRLZXlGb3JtYXQodCk7XG4gICAgY29uc3QgaSA9IGUuZGVjcnlwdGRhdGE7XG4gICAgaWYgKCFpKSB7XG4gICAgICBjb25zdCBjID0gbmV3IEVycm9yKHQgPyBgRXhwZWN0ZWQgZnJhZy5kZWNyeXB0ZGF0YSB0byBiZSBkZWZpbmVkIGFmdGVyIHNldHRpbmcgZm9ybWF0ICR7dH1gIDogYE1pc3NpbmcgZGVjcnlwdGlvbiBkYXRhIG9uIGZyYWdtZW50IGluIG9uS2V5TG9hZGluZyAoZW1lRW5hYmxlZCB3aXRoIGNvbnRyb2xsZXI6ICR7dGhpcy5lbWVDb250cm9sbGVyICYmIHRoaXMuY29uZmlnLmVtZUVuYWJsZWR9KWApO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGUsIEouS0VZX0xPQURfRVJST1IsIGMpKTtcbiAgICB9XG4gICAgY29uc3QgbyA9IGkudXJpO1xuICAgIGlmICghbylcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcihlLCBKLktFWV9MT0FEX0VSUk9SLCBuZXcgRXJyb3IoYEludmFsaWQga2V5IFVSSTogXCIke299XCJgKSkpO1xuICAgIGNvbnN0IGEgPSBrbChpKTtcbiAgICBsZXQgbCA9IHRoaXMua2V5SWRUb0tleUluZm9bYV07XG4gICAgaWYgKChyID0gbCkgIT0gbnVsbCAmJiByLmRlY3J5cHRkYXRhLmtleSlcbiAgICAgIHJldHVybiBpLmtleSA9IGwuZGVjcnlwdGRhdGEua2V5LCBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICBmcmFnOiBlLFxuICAgICAgICBrZXlJbmZvOiBsXG4gICAgICB9KTtcbiAgICBpZiAodGhpcy5lbWVDb250cm9sbGVyICYmIChuID0gbCkgIT0gbnVsbCAmJiBuLmtleUxvYWRQcm9taXNlKVxuICAgICAgc3dpdGNoICh0aGlzLmVtZUNvbnRyb2xsZXIuZ2V0S2V5U3RhdHVzKGwuZGVjcnlwdGRhdGEpKSB7XG4gICAgICAgIGNhc2UgXCJ1c2FibGVcIjpcbiAgICAgICAgY2FzZSBcInVzYWJsZS1pbi1mdXR1cmVcIjpcbiAgICAgICAgICByZXR1cm4gbC5rZXlMb2FkUHJvbWlzZS50aGVuKCh1KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGtleUluZm86IGRcbiAgICAgICAgICAgIH0gPSB1O1xuICAgICAgICAgICAgcmV0dXJuIGkua2V5ID0gZC5kZWNyeXB0ZGF0YS5rZXksIHtcbiAgICAgICAgICAgICAgZnJhZzogZSxcbiAgICAgICAgICAgICAga2V5SW5mbzogZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KTtcbiAgICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMubG9nKGAke3RoaXMua2V5SWRUb0tleUluZm9bYV0gPyBcIlJlbFwiIDogXCJMXCJ9b2FkaW5nJHtpLmtleUlkID8gXCIga2V5SWQ6IFwiICsgZnIoaS5rZXlJZCkgOiBcIlwifSBVUkk6ICR7aS51cml9IGZyb20gJHtlLnR5cGV9ICR7ZS5sZXZlbH1gKSwgbCA9IHRoaXMua2V5SWRUb0tleUluZm9bYV0gPSB7XG4gICAgICBkZWNyeXB0ZGF0YTogaSxcbiAgICAgIGtleUxvYWRQcm9taXNlOiBudWxsLFxuICAgICAgbG9hZGVyOiBudWxsLFxuICAgICAgbWVkaWFLZXlTZXNzaW9uQ29udGV4dDogbnVsbFxuICAgIH0sIGkubWV0aG9kKSB7XG4gICAgICBjYXNlIFwiU0FNUExFLUFFU1wiOlxuICAgICAgY2FzZSBcIlNBTVBMRS1BRVMtQ0VOQ1wiOlxuICAgICAgY2FzZSBcIlNBTVBMRS1BRVMtQ1RSXCI6XG4gICAgICAgIHJldHVybiBpLmtleUZvcm1hdCA9PT0gXCJpZGVudGl0eVwiID8gdGhpcy5sb2FkS2V5SFRUUChsLCBlKSA6IHRoaXMubG9hZEtleUVNRShsLCBlKTtcbiAgICAgIGNhc2UgXCJBRVMtMTI4XCI6XG4gICAgICBjYXNlIFwiQUVTLTI1NlwiOlxuICAgICAgY2FzZSBcIkFFUy0yNTYtQ1RSXCI6XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRLZXlIVFRQKGwsIGUpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKGUsIEouS0VZX0xPQURfRVJST1IsIG5ldyBFcnJvcihgS2V5IHN1cHBsaWVkIHdpdGggdW5zdXBwb3J0ZWQgTUVUSE9EOiBcIiR7aS5tZXRob2R9XCJgKSkpO1xuICAgIH1cbiAgfVxuICBsb2FkS2V5RU1FKGUsIHQpIHtcbiAgICBjb25zdCByID0ge1xuICAgICAgZnJhZzogdCxcbiAgICAgIGtleUluZm86IGVcbiAgICB9O1xuICAgIGlmICh0aGlzLmVtZUNvbnRyb2xsZXIgJiYgdGhpcy5jb25maWcuZW1lRW5hYmxlZCkge1xuICAgICAgY29uc3QgbiA9IHRoaXMuZW1lQ29udHJvbGxlci5sb2FkS2V5KHIpO1xuICAgICAgcmV0dXJuIChlLmtleUxvYWRQcm9taXNlID0gbi50aGVuKChpKSA9PiAoZS5tZWRpYUtleVNlc3Npb25Db250ZXh0ID0gaSwgcikpKS5jYXRjaCgoaSkgPT4ge1xuICAgICAgICB0aHJvdyBlLmtleUxvYWRQcm9taXNlID0gbnVsbCwgXCJkYXRhXCIgaW4gaSAmJiAoaS5kYXRhLmZyYWcgPSB0KSwgaTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHIpO1xuICB9XG4gIGxvYWRLZXlIVFRQKGUsIHQpIHtcbiAgICBjb25zdCByID0gdGhpcy5jb25maWcsIG4gPSByLmxvYWRlciwgaSA9IG5ldyBuKHIpO1xuICAgIHJldHVybiB0LmtleUxvYWRlciA9IGUubG9hZGVyID0gaSwgZS5rZXlMb2FkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChvLCBhKSA9PiB7XG4gICAgICBjb25zdCBsID0ge1xuICAgICAgICBrZXlJbmZvOiBlLFxuICAgICAgICBmcmFnOiB0LFxuICAgICAgICByZXNwb25zZVR5cGU6IFwiYXJyYXlidWZmZXJcIixcbiAgICAgICAgdXJsOiBlLmRlY3J5cHRkYXRhLnVyaVxuICAgICAgfSwgYyA9IHIua2V5TG9hZFBvbGljeS5kZWZhdWx0LCB1ID0ge1xuICAgICAgICBsb2FkUG9saWN5OiBjLFxuICAgICAgICB0aW1lb3V0OiBjLm1heExvYWRUaW1lTXMsXG4gICAgICAgIG1heFJldHJ5OiAwLFxuICAgICAgICByZXRyeURlbGF5OiAwLFxuICAgICAgICBtYXhSZXRyeURlbGF5OiAwXG4gICAgICB9LCBkID0ge1xuICAgICAgICBvblN1Y2Nlc3M6IChoLCBmLCBwLCB5KSA9PiB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZnJhZzogRSxcbiAgICAgICAgICAgIGtleUluZm86IGJcbiAgICAgICAgICB9ID0gcCwgUiA9IGtsKGIuZGVjcnlwdGRhdGEpO1xuICAgICAgICAgIGlmICghRS5kZWNyeXB0ZGF0YSB8fCBiICE9PSB0aGlzLmtleUlkVG9LZXlJbmZvW1JdKVxuICAgICAgICAgICAgcmV0dXJuIGEodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IoRSwgSi5LRVlfTE9BRF9FUlJPUiwgbmV3IEVycm9yKFwiYWZ0ZXIga2V5IGxvYWQsIGRlY3J5cHRkYXRhIHVuc2V0IG9yIGNoYW5nZWRcIiksIHkpKTtcbiAgICAgICAgICBiLmRlY3J5cHRkYXRhLmtleSA9IEUuZGVjcnlwdGRhdGEua2V5ID0gbmV3IFVpbnQ4QXJyYXkoaC5kYXRhKSwgRS5rZXlMb2FkZXIgPSBudWxsLCBiLmxvYWRlciA9IG51bGwsIG8oe1xuICAgICAgICAgICAgZnJhZzogRSxcbiAgICAgICAgICAgIGtleUluZm86IGJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FcnJvcjogKGgsIGYsIHAsIHkpID0+IHtcbiAgICAgICAgICB0aGlzLnJlc2V0TG9hZGVyKGYpLCBhKHRoaXMuY3JlYXRlS2V5TG9hZEVycm9yKHQsIEouS0VZX0xPQURfRVJST1IsIG5ldyBFcnJvcihgSFRUUCBFcnJvciAke2guY29kZX0gbG9hZGluZyBrZXkgJHtoLnRleHR9YCksIHAsIHR0KHtcbiAgICAgICAgICAgIHVybDogbC51cmwsXG4gICAgICAgICAgICBkYXRhOiB2b2lkIDBcbiAgICAgICAgICB9LCBoKSkpO1xuICAgICAgICB9LFxuICAgICAgICBvblRpbWVvdXQ6IChoLCBmLCBwKSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXNldExvYWRlcihmKSwgYSh0aGlzLmNyZWF0ZUtleUxvYWRFcnJvcih0LCBKLktFWV9MT0FEX1RJTUVPVVQsIG5ldyBFcnJvcihcImtleSBsb2FkaW5nIHRpbWVkIG91dFwiKSwgcCkpO1xuICAgICAgICB9LFxuICAgICAgICBvbkFib3J0OiAoaCwgZiwgcCkgPT4ge1xuICAgICAgICAgIHRoaXMucmVzZXRMb2FkZXIoZiksIGEodGhpcy5jcmVhdGVLZXlMb2FkRXJyb3IodCwgSi5JTlRFUk5BTF9BQk9SVEVELCBuZXcgRXJyb3IoXCJrZXkgbG9hZGluZyBhYm9ydGVkXCIpLCBwKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpLmxvYWQobCwgdSwgZCk7XG4gICAgfSk7XG4gIH1cbiAgcmVzZXRMb2FkZXIoZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGZyYWc6IHQsXG4gICAgICBrZXlJbmZvOiByLFxuICAgICAgdXJsOiBuXG4gICAgfSA9IGUsIGkgPSByLmxvYWRlcjtcbiAgICB0LmtleUxvYWRlciA9PT0gaSAmJiAodC5rZXlMb2FkZXIgPSBudWxsLCByLmxvYWRlciA9IG51bGwpO1xuICAgIGNvbnN0IG8gPSBrbChyLmRlY3J5cHRkYXRhKSB8fCBuO1xuICAgIGRlbGV0ZSB0aGlzLmtleUlkVG9LZXlJbmZvW29dLCBpICYmIGkuZGVzdHJveSgpO1xuICB9XG59XG5mdW5jdGlvbiBrbChzKSB7XG4gIGlmIChzLmtleUZvcm1hdCAhPT0gbHIuRkFJUlBMQVkpIHtcbiAgICBjb25zdCBlID0gcy5rZXlJZDtcbiAgICBpZiAoZSlcbiAgICAgIHJldHVybiBmcihlKTtcbiAgfVxuICByZXR1cm4gcy51cmk7XG59XG5mdW5jdGlvbiBoZihzKSB7XG4gIGNvbnN0IHtcbiAgICB0eXBlOiBlXG4gIH0gPSBzO1xuICBzd2l0Y2ggKGUpIHtcbiAgICBjYXNlIEtlLkFVRElPX1RSQUNLOlxuICAgICAgcmV0dXJuIHBlLkFVRElPO1xuICAgIGNhc2UgS2UuU1VCVElUTEVfVFJBQ0s6XG4gICAgICByZXR1cm4gcGUuU1VCVElUTEU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBwZS5NQUlOO1xuICB9XG59XG5mdW5jdGlvbiBEbChzLCBlKSB7XG4gIGxldCB0ID0gcy51cmw7XG4gIHJldHVybiAodCA9PT0gdm9pZCAwIHx8IHQuaW5kZXhPZihcImRhdGE6XCIpID09PSAwKSAmJiAodCA9IGUudXJsKSwgdDtcbn1cbmNsYXNzIFRBIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuaGxzID0gdm9pZCAwLCB0aGlzLmxvYWRlcnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgdGhpcy52YXJpYWJsZUxpc3QgPSBudWxsLCB0aGlzLm9uTWFuaWZlc3RMb2FkZWQgPSB0aGlzLmNoZWNrQXV0b3N0YXJ0TG9hZCwgdGhpcy5obHMgPSBlLCB0aGlzLnJlZ2lzdGVyTGlzdGVuZXJzKCk7XG4gIH1cbiAgc3RhcnRMb2FkKGUpIHtcbiAgfVxuICBzdG9wTG9hZCgpIHtcbiAgICB0aGlzLmRlc3Ryb3lJbnRlcm5hbExvYWRlcnMoKTtcbiAgfVxuICByZWdpc3Rlckxpc3RlbmVycygpIHtcbiAgICBjb25zdCB7XG4gICAgICBobHM6IGVcbiAgICB9ID0gdGhpcztcbiAgICBlLm9uKEkuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyksIGUub24oSS5MRVZFTF9MT0FESU5HLCB0aGlzLm9uTGV2ZWxMb2FkaW5nLCB0aGlzKSwgZS5vbihJLkFVRElPX1RSQUNLX0xPQURJTkcsIHRoaXMub25BdWRpb1RyYWNrTG9hZGluZywgdGhpcyksIGUub24oSS5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRpbmcsIHRoaXMpLCBlLm9uKEkuTEVWRUxTX1VQREFURUQsIHRoaXMub25MZXZlbHNVcGRhdGVkLCB0aGlzKTtcbiAgfVxuICB1bnJlZ2lzdGVyTGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGhsczogZVxuICAgIH0gPSB0aGlzO1xuICAgIGUub2ZmKEkuTUFOSUZFU1RfTE9BRElORywgdGhpcy5vbk1hbmlmZXN0TG9hZGluZywgdGhpcyksIGUub2ZmKEkuTEVWRUxfTE9BRElORywgdGhpcy5vbkxldmVsTG9hZGluZywgdGhpcyksIGUub2ZmKEkuQVVESU9fVFJBQ0tfTE9BRElORywgdGhpcy5vbkF1ZGlvVHJhY2tMb2FkaW5nLCB0aGlzKSwgZS5vZmYoSS5TVUJUSVRMRV9UUkFDS19MT0FESU5HLCB0aGlzLm9uU3VidGl0bGVUcmFja0xvYWRpbmcsIHRoaXMpLCBlLm9mZihJLkxFVkVMU19VUERBVEVELCB0aGlzLm9uTGV2ZWxzVXBkYXRlZCwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgZGVmYXVsdHMgb3IgY29uZmlndXJlZCBsb2FkZXItdHlwZSBvdmVybG9hZHMgKHBMb2FkZXIgYW5kIGxvYWRlciBjb25maWcgcGFyYW1zKVxuICAgKi9cbiAgY3JlYXRlSW50ZXJuYWxMb2FkZXIoZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmhscy5jb25maWcsIHIgPSB0LnBMb2FkZXIsIG4gPSB0LmxvYWRlciwgaSA9IHIgfHwgbiwgbyA9IG5ldyBpKHQpO1xuICAgIHJldHVybiB0aGlzLmxvYWRlcnNbZS50eXBlXSA9IG8sIG87XG4gIH1cbiAgZ2V0SW50ZXJuYWxMb2FkZXIoZSkge1xuICAgIHJldHVybiB0aGlzLmxvYWRlcnNbZS50eXBlXTtcbiAgfVxuICByZXNldEludGVybmFsTG9hZGVyKGUpIHtcbiAgICB0aGlzLmxvYWRlcnNbZV0gJiYgZGVsZXRlIHRoaXMubG9hZGVyc1tlXTtcbiAgfVxuICAvKipcbiAgICogQ2FsbCBgZGVzdHJveWAgb24gYWxsIGludGVybmFsIGxvYWRlciBpbnN0YW5jZXMgbWFwcGVkIChvbmUgcGVyIGNvbnRleHQgdHlwZSlcbiAgICovXG4gIGRlc3Ryb3lJbnRlcm5hbExvYWRlcnMoKSB7XG4gICAgZm9yIChjb25zdCBlIGluIHRoaXMubG9hZGVycykge1xuICAgICAgY29uc3QgdCA9IHRoaXMubG9hZGVyc1tlXTtcbiAgICAgIHQgJiYgdC5kZXN0cm95KCksIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihlKTtcbiAgICB9XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLnZhcmlhYmxlTGlzdCA9IG51bGwsIHRoaXMudW5yZWdpc3Rlckxpc3RlbmVycygpLCB0aGlzLmRlc3Ryb3lJbnRlcm5hbExvYWRlcnMoKTtcbiAgfVxuICBvbk1hbmlmZXN0TG9hZGluZyhlLCB0KSB7XG4gICAgY29uc3Qge1xuICAgICAgdXJsOiByXG4gICAgfSA9IHQ7XG4gICAgdGhpcy52YXJpYWJsZUxpc3QgPSBudWxsLCB0aGlzLmxvYWQoe1xuICAgICAgaWQ6IG51bGwsXG4gICAgICBsZXZlbDogMCxcbiAgICAgIHJlc3BvbnNlVHlwZTogXCJ0ZXh0XCIsXG4gICAgICB0eXBlOiBLZS5NQU5JRkVTVCxcbiAgICAgIHVybDogcixcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogbnVsbCxcbiAgICAgIGxldmVsT3JUcmFjazogbnVsbFxuICAgIH0pO1xuICB9XG4gIG9uTGV2ZWxMb2FkaW5nKGUsIHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZDogcixcbiAgICAgIGxldmVsOiBuLFxuICAgICAgcGF0aHdheUlkOiBpLFxuICAgICAgdXJsOiBvLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBhLFxuICAgICAgbGV2ZWxJbmZvOiBsXG4gICAgfSA9IHQ7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkOiByLFxuICAgICAgbGV2ZWw6IG4sXG4gICAgICBwYXRod2F5SWQ6IGksXG4gICAgICByZXNwb25zZVR5cGU6IFwidGV4dFwiLFxuICAgICAgdHlwZTogS2UuTEVWRUwsXG4gICAgICB1cmw6IG8sXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGEsXG4gICAgICBsZXZlbE9yVHJhY2s6IGxcbiAgICB9KTtcbiAgfVxuICBvbkF1ZGlvVHJhY2tMb2FkaW5nKGUsIHQpIHtcbiAgICBjb25zdCB7XG4gICAgICBpZDogcixcbiAgICAgIGdyb3VwSWQ6IG4sXG4gICAgICB1cmw6IGksXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IG8sXG4gICAgICB0cmFjazogYVxuICAgIH0gPSB0O1xuICAgIHRoaXMubG9hZCh7XG4gICAgICBpZDogcixcbiAgICAgIGdyb3VwSWQ6IG4sXG4gICAgICBsZXZlbDogbnVsbCxcbiAgICAgIHJlc3BvbnNlVHlwZTogXCJ0ZXh0XCIsXG4gICAgICB0eXBlOiBLZS5BVURJT19UUkFDSyxcbiAgICAgIHVybDogaSxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogbyxcbiAgICAgIGxldmVsT3JUcmFjazogYVxuICAgIH0pO1xuICB9XG4gIG9uU3VidGl0bGVUcmFja0xvYWRpbmcoZSwgdCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlkOiByLFxuICAgICAgZ3JvdXBJZDogbixcbiAgICAgIHVybDogaSxcbiAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogbyxcbiAgICAgIHRyYWNrOiBhXG4gICAgfSA9IHQ7XG4gICAgdGhpcy5sb2FkKHtcbiAgICAgIGlkOiByLFxuICAgICAgZ3JvdXBJZDogbixcbiAgICAgIGxldmVsOiBudWxsLFxuICAgICAgcmVzcG9uc2VUeXBlOiBcInRleHRcIixcbiAgICAgIHR5cGU6IEtlLlNVQlRJVExFX1RSQUNLLFxuICAgICAgdXJsOiBpLFxuICAgICAgZGVsaXZlcnlEaXJlY3RpdmVzOiBvLFxuICAgICAgbGV2ZWxPclRyYWNrOiBhXG4gICAgfSk7XG4gIH1cbiAgb25MZXZlbHNVcGRhdGVkKGUsIHQpIHtcbiAgICBjb25zdCByID0gdGhpcy5sb2FkZXJzW0tlLkxFVkVMXTtcbiAgICBpZiAocikge1xuICAgICAgY29uc3QgbiA9IHIuY29udGV4dDtcbiAgICAgIG4gJiYgIXQubGV2ZWxzLnNvbWUoKGkpID0+IGkgPT09IG4ubGV2ZWxPclRyYWNrKSAmJiAoci5hYm9ydCgpLCBkZWxldGUgdGhpcy5sb2FkZXJzW0tlLkxFVkVMXSk7XG4gICAgfVxuICB9XG4gIGxvYWQoZSkge1xuICAgIHZhciB0O1xuICAgIGNvbnN0IHIgPSB0aGlzLmhscy5jb25maWc7XG4gICAgbGV0IG4gPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGUpO1xuICAgIGlmIChuKSB7XG4gICAgICBjb25zdCBjID0gdGhpcy5obHMubG9nZ2VyLCB1ID0gbi5jb250ZXh0O1xuICAgICAgaWYgKHUgJiYgdS5sZXZlbE9yVHJhY2sgPT09IGUubGV2ZWxPclRyYWNrICYmICh1LnVybCA9PT0gZS51cmwgfHwgdS5kZWxpdmVyeURpcmVjdGl2ZXMgJiYgIWUuZGVsaXZlcnlEaXJlY3RpdmVzKSkge1xuICAgICAgICB1LnVybCA9PT0gZS51cmwgPyBjLmxvZyhgW3BsYXlsaXN0LWxvYWRlcl06IGlnbm9yZSAke2UudXJsfSBvbmdvaW5nIHJlcXVlc3RgKSA6IGMubG9nKGBbcGxheWxpc3QtbG9hZGVyXTogaWdub3JlICR7ZS51cmx9IGluIGZhdm9yIG9mICR7dS51cmx9YCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGMubG9nKGBbcGxheWxpc3QtbG9hZGVyXTogYWJvcnRpbmcgcHJldmlvdXMgbG9hZGVyIGZvciB0eXBlOiAke2UudHlwZX1gKSwgbi5hYm9ydCgpO1xuICAgIH1cbiAgICBsZXQgaTtcbiAgICBpZiAoZS50eXBlID09PSBLZS5NQU5JRkVTVCA/IGkgPSByLm1hbmlmZXN0TG9hZFBvbGljeS5kZWZhdWx0IDogaSA9IG50KHt9LCByLnBsYXlsaXN0TG9hZFBvbGljeS5kZWZhdWx0LCB7XG4gICAgICB0aW1lb3V0UmV0cnk6IG51bGwsXG4gICAgICBlcnJvclJldHJ5OiBudWxsXG4gICAgfSksIG4gPSB0aGlzLmNyZWF0ZUludGVybmFsTG9hZGVyKGUpLCB1ZSgodCA9IGUuZGVsaXZlcnlEaXJlY3RpdmVzKSA9PSBudWxsID8gdm9pZCAwIDogdC5wYXJ0KSkge1xuICAgICAgbGV0IGM7XG4gICAgICBpZiAoZS50eXBlID09PSBLZS5MRVZFTCAmJiBlLmxldmVsICE9PSBudWxsID8gYyA9IHRoaXMuaGxzLmxldmVsc1tlLmxldmVsXS5kZXRhaWxzIDogZS50eXBlID09PSBLZS5BVURJT19UUkFDSyAmJiBlLmlkICE9PSBudWxsID8gYyA9IHRoaXMuaGxzLmF1ZGlvVHJhY2tzW2UuaWRdLmRldGFpbHMgOiBlLnR5cGUgPT09IEtlLlNVQlRJVExFX1RSQUNLICYmIGUuaWQgIT09IG51bGwgJiYgKGMgPSB0aGlzLmhscy5zdWJ0aXRsZVRyYWNrc1tlLmlkXS5kZXRhaWxzKSwgYykge1xuICAgICAgICBjb25zdCB1ID0gYy5wYXJ0VGFyZ2V0LCBkID0gYy50YXJnZXRkdXJhdGlvbjtcbiAgICAgICAgaWYgKHUgJiYgZCkge1xuICAgICAgICAgIGNvbnN0IGggPSBNYXRoLm1heCh1ICogMywgZCAqIDAuOCkgKiAxZTM7XG4gICAgICAgICAgaSA9IG50KHt9LCBpLCB7XG4gICAgICAgICAgICBtYXhUaW1lVG9GaXJzdEJ5dGVNczogTWF0aC5taW4oaCwgaS5tYXhUaW1lVG9GaXJzdEJ5dGVNcyksXG4gICAgICAgICAgICBtYXhMb2FkVGltZU1zOiBNYXRoLm1pbihoLCBpLm1heFRpbWVUb0ZpcnN0Qnl0ZU1zKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG8gPSBpLmVycm9yUmV0cnkgfHwgaS50aW1lb3V0UmV0cnkgfHwge30sIGEgPSB7XG4gICAgICBsb2FkUG9saWN5OiBpLFxuICAgICAgdGltZW91dDogaS5tYXhMb2FkVGltZU1zLFxuICAgICAgbWF4UmV0cnk6IG8ubWF4TnVtUmV0cnkgfHwgMCxcbiAgICAgIHJldHJ5RGVsYXk6IG8ucmV0cnlEZWxheU1zIHx8IDAsXG4gICAgICBtYXhSZXRyeURlbGF5OiBvLm1heFJldHJ5RGVsYXlNcyB8fCAwXG4gICAgfSwgbCA9IHtcbiAgICAgIG9uU3VjY2VzczogKGMsIHUsIGQsIGgpID0+IHtcbiAgICAgICAgY29uc3QgZiA9IHRoaXMuZ2V0SW50ZXJuYWxMb2FkZXIoZCk7XG4gICAgICAgIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihkLnR5cGUpO1xuICAgICAgICBjb25zdCBwID0gYy5kYXRhO1xuICAgICAgICB1LnBhcnNpbmcuc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKSwgenIuaXNNZWRpYVBsYXlsaXN0KHApIHx8IGQudHlwZSAhPT0gS2UuTUFOSUZFU1QgPyB0aGlzLmhhbmRsZVRyYWNrT3JMZXZlbFBsYXlsaXN0KGMsIHUsIGQsIGggfHwgbnVsbCwgZikgOiB0aGlzLmhhbmRsZU1hc3RlclBsYXlsaXN0KGMsIHUsIGQsIGgpO1xuICAgICAgfSxcbiAgICAgIG9uRXJyb3I6IChjLCB1LCBkLCBoKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlTmV0d29ya0Vycm9yKHUsIGQsICExLCBjLCBoKTtcbiAgICAgIH0sXG4gICAgICBvblRpbWVvdXQ6IChjLCB1LCBkKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlTmV0d29ya0Vycm9yKHUsIGQsICEwLCB2b2lkIDAsIGMpO1xuICAgICAgfVxuICAgIH07XG4gICAgbi5sb2FkKGUsIGEsIGwpO1xuICB9XG4gIGNoZWNrQXV0b3N0YXJ0TG9hZCgpIHtcbiAgICBpZiAoIXRoaXMuaGxzKVxuICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbmZpZzoge1xuICAgICAgICBhdXRvU3RhcnRMb2FkOiBlLFxuICAgICAgICBzdGFydFBvc2l0aW9uOiB0XG4gICAgICB9LFxuICAgICAgZm9yY2VTdGFydExvYWQ6IHJcbiAgICB9ID0gdGhpcy5obHM7XG4gICAgKGUgfHwgcikgJiYgKHRoaXMuaGxzLmxvZ2dlci5sb2coYCR7ZSA/IFwiYXV0b1wiIDogXCJmb3JjZVwifSBzdGFydExvYWQgd2l0aCBjb25maWd1cmVkIHN0YXJ0UG9zaXRpb24gJHt0fWApLCB0aGlzLmhscy5zdGFydExvYWQodCkpO1xuICB9XG4gIGhhbmRsZU1hc3RlclBsYXlsaXN0KGUsIHQsIHIsIG4pIHtcbiAgICBjb25zdCBpID0gdGhpcy5obHMsIG8gPSBlLmRhdGEsIGEgPSBEbChlLCByKSwgbCA9IHpyLnBhcnNlTWFzdGVyUGxheWxpc3QobywgYSk7XG4gICAgaWYgKGwucGxheWxpc3RQYXJzaW5nRXJyb3IpIHtcbiAgICAgIHQucGFyc2luZy5lbmQgPSBwZXJmb3JtYW5jZS5ub3coKSwgdGhpcy5oYW5kbGVNYW5pZmVzdFBhcnNpbmdFcnJvcihlLCByLCBsLnBsYXlsaXN0UGFyc2luZ0Vycm9yLCBuLCB0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgY29udGVudFN0ZWVyaW5nOiBjLFxuICAgICAgbGV2ZWxzOiB1LFxuICAgICAgc2Vzc2lvbkRhdGE6IGQsXG4gICAgICBzZXNzaW9uS2V5czogaCxcbiAgICAgIHN0YXJ0VGltZU9mZnNldDogZixcbiAgICAgIHZhcmlhYmxlTGlzdDogcFxuICAgIH0gPSBsO1xuICAgIHRoaXMudmFyaWFibGVMaXN0ID0gcCwgdS5mb3JFYWNoKChSKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHVua25vd25Db2RlY3M6IEFcbiAgICAgIH0gPSBSO1xuICAgICAgaWYgKEEpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHByZWZlck1hbmFnZWRNZWRpYVNvdXJjZTogRlxuICAgICAgICB9ID0gdGhpcy5obHMuY29uZmlnO1xuICAgICAgICBsZXQge1xuICAgICAgICAgIGF1ZGlvQ29kZWM6IE0sXG4gICAgICAgICAgdmlkZW9Db2RlYzogSFxuICAgICAgICB9ID0gUjtcbiAgICAgICAgZm9yIChsZXQgSyA9IEEubGVuZ3RoOyBLLS07ICkge1xuICAgICAgICAgIGNvbnN0IGogPSBBW0tdO1xuICAgICAgICAgIGdpKGosIFwiYXVkaW9cIiwgRikgPyAoUi5hdWRpb0NvZGVjID0gTSA9IE0gPyBgJHtNfSwke2p9YCA6IGosIEZuLmF1ZGlvW00uc3Vic3RyaW5nKDAsIDQpXSA9IDIsIEEuc3BsaWNlKEssIDEpKSA6IGdpKGosIFwidmlkZW9cIiwgRikgJiYgKFIudmlkZW9Db2RlYyA9IEggPSBIID8gYCR7SH0sJHtqfWAgOiBqLCBGbi52aWRlb1tILnN1YnN0cmluZygwLCA0KV0gPSAyLCBBLnNwbGljZShLLCAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBBVURJTzogeSA9IFtdLFxuICAgICAgU1VCVElUTEVTOiBFLFxuICAgICAgXCJDTE9TRUQtQ0FQVElPTlNcIjogYlxuICAgIH0gPSB6ci5wYXJzZU1hc3RlclBsYXlsaXN0TWVkaWEobywgYSwgbCk7XG4gICAgeS5sZW5ndGggJiYgIXkuc29tZSgoQSkgPT4gIUEudXJsKSAmJiB1WzBdLmF1ZGlvQ29kZWMgJiYgIXVbMF0uYXR0cnMuQVVESU8gJiYgKHRoaXMuaGxzLmxvZ2dlci5sb2coXCJbcGxheWxpc3QtbG9hZGVyXTogYXVkaW8gY29kZWMgc2lnbmFsZWQgaW4gcXVhbGl0eSBsZXZlbCwgYnV0IG5vIGVtYmVkZGVkIGF1ZGlvIHRyYWNrIHNpZ25hbGVkLCBjcmVhdGUgb25lXCIpLCB5LnVuc2hpZnQoe1xuICAgICAgdHlwZTogXCJtYWluXCIsXG4gICAgICBuYW1lOiBcIm1haW5cIixcbiAgICAgIGdyb3VwSWQ6IFwibWFpblwiLFxuICAgICAgZGVmYXVsdDogITEsXG4gICAgICBhdXRvc2VsZWN0OiAhMSxcbiAgICAgIGZvcmNlZDogITEsXG4gICAgICBpZDogLTEsXG4gICAgICBhdHRyczogbmV3IGd0KHt9KSxcbiAgICAgIGJpdHJhdGU6IDAsXG4gICAgICB1cmw6IFwiXCJcbiAgICB9KSksIGkudHJpZ2dlcihJLk1BTklGRVNUX0xPQURFRCwge1xuICAgICAgbGV2ZWxzOiB1LFxuICAgICAgYXVkaW9UcmFja3M6IHksXG4gICAgICBzdWJ0aXRsZXM6IEUsXG4gICAgICBjYXB0aW9uczogYixcbiAgICAgIGNvbnRlbnRTdGVlcmluZzogYyxcbiAgICAgIHVybDogYSxcbiAgICAgIHN0YXRzOiB0LFxuICAgICAgbmV0d29ya0RldGFpbHM6IG4sXG4gICAgICBzZXNzaW9uRGF0YTogZCxcbiAgICAgIHNlc3Npb25LZXlzOiBoLFxuICAgICAgc3RhcnRUaW1lT2Zmc2V0OiBmLFxuICAgICAgdmFyaWFibGVMaXN0OiBwXG4gICAgfSk7XG4gIH1cbiAgaGFuZGxlVHJhY2tPckxldmVsUGxheWxpc3QoZSwgdCwgciwgbiwgaSkge1xuICAgIGNvbnN0IG8gPSB0aGlzLmhscywge1xuICAgICAgaWQ6IGEsXG4gICAgICBsZXZlbDogbCxcbiAgICAgIHR5cGU6IGNcbiAgICB9ID0gciwgdSA9IERsKGUsIHIpLCBkID0gdWUobCkgPyBsIDogdWUoYSkgPyBhIDogMCwgaCA9IGhmKHIpLCBmID0genIucGFyc2VMZXZlbFBsYXlsaXN0KGUuZGF0YSwgdSwgZCwgaCwgMCwgdGhpcy52YXJpYWJsZUxpc3QpO1xuICAgIGlmIChjID09PSBLZS5NQU5JRkVTVCkge1xuICAgICAgY29uc3QgcCA9IHtcbiAgICAgICAgYXR0cnM6IG5ldyBndCh7fSksXG4gICAgICAgIGJpdHJhdGU6IDAsXG4gICAgICAgIGRldGFpbHM6IGYsXG4gICAgICAgIG5hbWU6IFwiXCIsXG4gICAgICAgIHVybDogdVxuICAgICAgfTtcbiAgICAgIGYucmVxdWVzdFNjaGVkdWxlZCA9IHQubG9hZGluZy5zdGFydCArIFFnKGYsIDApLCBvLnRyaWdnZXIoSS5NQU5JRkVTVF9MT0FERUQsIHtcbiAgICAgICAgbGV2ZWxzOiBbcF0sXG4gICAgICAgIGF1ZGlvVHJhY2tzOiBbXSxcbiAgICAgICAgdXJsOiB1LFxuICAgICAgICBzdGF0czogdCxcbiAgICAgICAgbmV0d29ya0RldGFpbHM6IG4sXG4gICAgICAgIHNlc3Npb25EYXRhOiBudWxsLFxuICAgICAgICBzZXNzaW9uS2V5czogbnVsbCxcbiAgICAgICAgY29udGVudFN0ZWVyaW5nOiBudWxsLFxuICAgICAgICBzdGFydFRpbWVPZmZzZXQ6IG51bGwsXG4gICAgICAgIHZhcmlhYmxlTGlzdDogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICAgIHQucGFyc2luZy5lbmQgPSBwZXJmb3JtYW5jZS5ub3coKSwgci5sZXZlbERldGFpbHMgPSBmLCB0aGlzLmhhbmRsZVBsYXlsaXN0TG9hZGVkKGYsIGUsIHQsIHIsIG4sIGkpO1xuICB9XG4gIGhhbmRsZU1hbmlmZXN0UGFyc2luZ0Vycm9yKGUsIHQsIHIsIG4sIGkpIHtcbiAgICB0aGlzLmhscy50cmlnZ2VyKEkuRVJST1IsIHtcbiAgICAgIHR5cGU6IHZlLk5FVFdPUktfRVJST1IsXG4gICAgICBkZXRhaWxzOiBKLk1BTklGRVNUX1BBUlNJTkdfRVJST1IsXG4gICAgICBmYXRhbDogdC50eXBlID09PSBLZS5NQU5JRkVTVCxcbiAgICAgIHVybDogZS51cmwsXG4gICAgICBlcnI6IHIsXG4gICAgICBlcnJvcjogcixcbiAgICAgIHJlYXNvbjogci5tZXNzYWdlLFxuICAgICAgcmVzcG9uc2U6IGUsXG4gICAgICBjb250ZXh0OiB0LFxuICAgICAgbmV0d29ya0RldGFpbHM6IG4sXG4gICAgICBzdGF0czogaVxuICAgIH0pO1xuICB9XG4gIGhhbmRsZU5ldHdvcmtFcnJvcihlLCB0LCByID0gITEsIG4sIGkpIHtcbiAgICBsZXQgbyA9IGBBIG5ldHdvcmsgJHtyID8gXCJ0aW1lb3V0XCIgOiBcImVycm9yXCIgKyAobiA/IFwiIChzdGF0dXMgXCIgKyBuLmNvZGUgKyBcIilcIiA6IFwiXCIpfSBvY2N1cnJlZCB3aGlsZSBsb2FkaW5nICR7ZS50eXBlfWA7XG4gICAgZS50eXBlID09PSBLZS5MRVZFTCA/IG8gKz0gYDogJHtlLmxldmVsfSBpZDogJHtlLmlkfWAgOiAoZS50eXBlID09PSBLZS5BVURJT19UUkFDSyB8fCBlLnR5cGUgPT09IEtlLlNVQlRJVExFX1RSQUNLKSAmJiAobyArPSBgIGlkOiAke2UuaWR9IGdyb3VwLWlkOiBcIiR7ZS5ncm91cElkfVwiYCk7XG4gICAgY29uc3QgYSA9IG5ldyBFcnJvcihvKTtcbiAgICB0aGlzLmhscy5sb2dnZXIud2FybihgW3BsYXlsaXN0LWxvYWRlcl06ICR7b31gKTtcbiAgICBsZXQgbCA9IEouVU5LTk9XTiwgYyA9ICExO1xuICAgIGNvbnN0IHUgPSB0aGlzLmdldEludGVybmFsTG9hZGVyKGUpO1xuICAgIHN3aXRjaCAoZS50eXBlKSB7XG4gICAgICBjYXNlIEtlLk1BTklGRVNUOlxuICAgICAgICBsID0gciA/IEouTUFOSUZFU1RfTE9BRF9USU1FT1VUIDogSi5NQU5JRkVTVF9MT0FEX0VSUk9SLCBjID0gITA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBLZS5MRVZFTDpcbiAgICAgICAgbCA9IHIgPyBKLkxFVkVMX0xPQURfVElNRU9VVCA6IEouTEVWRUxfTE9BRF9FUlJPUiwgYyA9ICExO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgS2UuQVVESU9fVFJBQ0s6XG4gICAgICAgIGwgPSByID8gSi5BVURJT19UUkFDS19MT0FEX1RJTUVPVVQgOiBKLkFVRElPX1RSQUNLX0xPQURfRVJST1IsIGMgPSAhMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgICBsID0gciA/IEouU1VCVElUTEVfVFJBQ0tfTE9BRF9USU1FT1VUIDogSi5TVUJUSVRMRV9MT0FEX0VSUk9SLCBjID0gITE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB1ICYmIHRoaXMucmVzZXRJbnRlcm5hbExvYWRlcihlLnR5cGUpO1xuICAgIGNvbnN0IGQgPSB7XG4gICAgICB0eXBlOiB2ZS5ORVRXT1JLX0VSUk9SLFxuICAgICAgZGV0YWlsczogbCxcbiAgICAgIGZhdGFsOiBjLFxuICAgICAgdXJsOiBlLnVybCxcbiAgICAgIGxvYWRlcjogdSxcbiAgICAgIGNvbnRleHQ6IGUsXG4gICAgICBlcnJvcjogYSxcbiAgICAgIG5ldHdvcmtEZXRhaWxzOiB0LFxuICAgICAgc3RhdHM6IGlcbiAgICB9O1xuICAgIGlmIChuKSB7XG4gICAgICBjb25zdCBoID0gKHQgPT0gbnVsbCA/IHZvaWQgMCA6IHQudXJsKSB8fCBlLnVybDtcbiAgICAgIGQucmVzcG9uc2UgPSB0dCh7XG4gICAgICAgIHVybDogaCxcbiAgICAgICAgZGF0YTogdm9pZCAwXG4gICAgICB9LCBuKTtcbiAgICB9XG4gICAgdGhpcy5obHMudHJpZ2dlcihJLkVSUk9SLCBkKTtcbiAgfVxuICBoYW5kbGVQbGF5bGlzdExvYWRlZChlLCB0LCByLCBuLCBpLCBvKSB7XG4gICAgY29uc3QgYSA9IHRoaXMuaGxzLCB7XG4gICAgICB0eXBlOiBsLFxuICAgICAgbGV2ZWw6IGMsXG4gICAgICBsZXZlbE9yVHJhY2s6IHUsXG4gICAgICBpZDogZCxcbiAgICAgIGdyb3VwSWQ6IGgsXG4gICAgICBkZWxpdmVyeURpcmVjdGl2ZXM6IGZcbiAgICB9ID0gbiwgcCA9IERsKHQsIG4pLCB5ID0gaGYobik7XG4gICAgbGV0IEUgPSB0eXBlb2Ygbi5sZXZlbCA9PSBcIm51bWJlclwiICYmIHkgPT09IHBlLk1BSU4gPyBjIDogdm9pZCAwO1xuICAgIGNvbnN0IGIgPSBlLnBsYXlsaXN0UGFyc2luZ0Vycm9yO1xuICAgIGlmIChiKSB7XG4gICAgICBpZiAodGhpcy5obHMubG9nZ2VyLndhcm4oYCR7Yn0gJHtlLnVybH1gKSwgIWEuY29uZmlnLmlnbm9yZVBsYXlsaXN0UGFyc2luZ0Vycm9ycykge1xuICAgICAgICBhLnRyaWdnZXIoSS5FUlJPUiwge1xuICAgICAgICAgIHR5cGU6IHZlLk5FVFdPUktfRVJST1IsXG4gICAgICAgICAgZGV0YWlsczogSi5MRVZFTF9QQVJTSU5HX0VSUk9SLFxuICAgICAgICAgIGZhdGFsOiAhMSxcbiAgICAgICAgICB1cmw6IHAsXG4gICAgICAgICAgZXJyb3I6IGIsXG4gICAgICAgICAgcmVhc29uOiBiLm1lc3NhZ2UsXG4gICAgICAgICAgcmVzcG9uc2U6IHQsXG4gICAgICAgICAgY29udGV4dDogbixcbiAgICAgICAgICBsZXZlbDogRSxcbiAgICAgICAgICBwYXJlbnQ6IHksXG4gICAgICAgICAgbmV0d29ya0RldGFpbHM6IGksXG4gICAgICAgICAgc3RhdHM6IHJcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGUucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoIWUuZnJhZ21lbnRzLmxlbmd0aCkge1xuICAgICAgY29uc3QgUiA9IGUucGxheWxpc3RQYXJzaW5nRXJyb3IgPSBuZXcgRXJyb3IoXCJObyBTZWdtZW50cyBmb3VuZCBpbiBQbGF5bGlzdFwiKTtcbiAgICAgIGEudHJpZ2dlcihJLkVSUk9SLCB7XG4gICAgICAgIHR5cGU6IHZlLk5FVFdPUktfRVJST1IsXG4gICAgICAgIGRldGFpbHM6IEouTEVWRUxfRU1QVFlfRVJST1IsXG4gICAgICAgIGZhdGFsOiAhMSxcbiAgICAgICAgdXJsOiBwLFxuICAgICAgICBlcnJvcjogUixcbiAgICAgICAgcmVhc29uOiBSLm1lc3NhZ2UsXG4gICAgICAgIHJlc3BvbnNlOiB0LFxuICAgICAgICBjb250ZXh0OiBuLFxuICAgICAgICBsZXZlbDogRSxcbiAgICAgICAgcGFyZW50OiB5LFxuICAgICAgICBuZXR3b3JrRGV0YWlsczogaSxcbiAgICAgICAgc3RhdHM6IHJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzd2l0Y2ggKGUubGl2ZSAmJiBvICYmIChvLmdldENhY2hlQWdlICYmIChlLmFnZUhlYWRlciA9IG8uZ2V0Q2FjaGVBZ2UoKSB8fCAwKSwgKCFvLmdldENhY2hlQWdlIHx8IGlzTmFOKGUuYWdlSGVhZGVyKSkgJiYgKGUuYWdlSGVhZGVyID0gMCkpLCBsKSB7XG4gICAgICBjYXNlIEtlLk1BTklGRVNUOlxuICAgICAgY2FzZSBLZS5MRVZFTDpcbiAgICAgICAgaWYgKEUpIHtcbiAgICAgICAgICBpZiAoIXUpXG4gICAgICAgICAgICBFID0gMDtcbiAgICAgICAgICBlbHNlIGlmICh1ICE9PSBhLmxldmVsc1tFXSkge1xuICAgICAgICAgICAgY29uc3QgUiA9IGEubGV2ZWxzLmluZGV4T2YodSk7XG4gICAgICAgICAgICBSID4gLTEgJiYgKEUgPSBSKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYS50cmlnZ2VyKEkuTEVWRUxfTE9BREVELCB7XG4gICAgICAgICAgZGV0YWlsczogZSxcbiAgICAgICAgICBsZXZlbEluZm86IHUgfHwgYS5sZXZlbHNbMF0sXG4gICAgICAgICAgbGV2ZWw6IEUgfHwgMCxcbiAgICAgICAgICBpZDogZCB8fCAwLFxuICAgICAgICAgIHN0YXRzOiByLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBpLFxuICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogZixcbiAgICAgICAgICB3aXRob3V0TXVsdGlWYXJpYW50OiBsID09PSBLZS5NQU5JRkVTVFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtlLkFVRElPX1RSQUNLOlxuICAgICAgICBhLnRyaWdnZXIoSS5BVURJT19UUkFDS19MT0FERUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBlLFxuICAgICAgICAgIHRyYWNrOiB1LFxuICAgICAgICAgIGlkOiBkIHx8IDAsXG4gICAgICAgICAgZ3JvdXBJZDogaCB8fCBcIlwiLFxuICAgICAgICAgIHN0YXRzOiByLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBpLFxuICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogZlxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEtlLlNVQlRJVExFX1RSQUNLOlxuICAgICAgICBhLnRyaWdnZXIoSS5TVUJUSVRMRV9UUkFDS19MT0FERUQsIHtcbiAgICAgICAgICBkZXRhaWxzOiBlLFxuICAgICAgICAgIHRyYWNrOiB1LFxuICAgICAgICAgIGlkOiBkIHx8IDAsXG4gICAgICAgICAgZ3JvdXBJZDogaCB8fCBcIlwiLFxuICAgICAgICAgIHN0YXRzOiByLFxuICAgICAgICAgIG5ldHdvcmtEZXRhaWxzOiBpLFxuICAgICAgICAgIGRlbGl2ZXJ5RGlyZWN0aXZlczogZlxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5jbGFzcyBIciB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIHZpZGVvLWRldi9obHMuanMgcGFja2FnZSB2ZXJzaW9uLlxuICAgKi9cbiAgc3RhdGljIGdldCB2ZXJzaW9uKCkge1xuICAgIHJldHVybiB2aTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgdGhlIHJlcXVpcmVkIE1lZGlhU291cmNlIEV4dGVuc2lvbnMgYXJlIGF2YWlsYWJsZS5cbiAgICovXG4gIHN0YXRpYyBpc01TRVN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gSnAoKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgTWVkaWFTb3VyY2UgRXh0ZW5zaW9ucyBhcmUgYXZhaWxhYmxlIGFuZCBpc1R5cGVTdXBwb3J0ZWQgY2hlY2tzIHBhc3MgZm9yIGFueSBiYXNlbGluZSBjb2RlY3MuXG4gICAqL1xuICBzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHZBKCk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgTWVkaWFTb3VyY2UgZ2xvYmFsIHVzZWQgZm9yIE1TRSBwbGF5YmFjayAoTWFuYWdlZE1lZGlhU291cmNlLCBNZWRpYVNvdXJjZSwgb3IgV2ViS2l0TWVkaWFTb3VyY2UpLlxuICAgKi9cbiAgc3RhdGljIGdldE1lZGlhU291cmNlKCkge1xuICAgIHJldHVybiBNcygpO1xuICB9XG4gIHN0YXRpYyBnZXQgRXZlbnRzKCkge1xuICAgIHJldHVybiBJO1xuICB9XG4gIHN0YXRpYyBnZXQgTWV0YWRhdGFTY2hlbWEoKSB7XG4gICAgcmV0dXJuIGJyO1xuICB9XG4gIHN0YXRpYyBnZXQgRXJyb3JUeXBlcygpIHtcbiAgICByZXR1cm4gdmU7XG4gIH1cbiAgc3RhdGljIGdldCBFcnJvckRldGFpbHMoKSB7XG4gICAgcmV0dXJuIEo7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGFwcGxpZWQgdG8gbmV3IGluc3RhbmNlcy5cbiAgICovXG4gIHN0YXRpYyBnZXQgRGVmYXVsdENvbmZpZygpIHtcbiAgICByZXR1cm4gSHIuZGVmYXVsdENvbmZpZyA/IEhyLmRlZmF1bHRDb25maWcgOiBvQTtcbiAgfVxuICAvKipcbiAgICogUmVwbGFjZSB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGFwcGxpZWQgdG8gbmV3IGluc3RhbmNlcy5cbiAgICovXG4gIHN0YXRpYyBzZXQgRGVmYXVsdENvbmZpZyhlKSB7XG4gICAgSHIuZGVmYXVsdENvbmZpZyA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYW4gSExTIGNsaWVudCB0aGF0IGNhbiBhdHRhY2ggdG8gZXhhY3RseSBvbmUgYEhUTUxNZWRpYUVsZW1lbnRgLlxuICAgKiBAcGFyYW0gdXNlckNvbmZpZyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBhcHBsaWVkIG92ZXIgYEhscy5EZWZhdWx0Q29uZmlnYFxuICAgKi9cbiAgY29uc3RydWN0b3IoZSA9IHt9KSB7XG4gICAgdGhpcy5jb25maWcgPSB2b2lkIDAsIHRoaXMudXNlckNvbmZpZyA9IHZvaWQgMCwgdGhpcy5sb2dnZXIgPSB2b2lkIDAsIHRoaXMuY29yZUNvbXBvbmVudHMgPSB2b2lkIDAsIHRoaXMubmV0d29ya0NvbnRyb2xsZXJzID0gdm9pZCAwLCB0aGlzLl9lbWl0dGVyID0gbmV3IHd1KCksIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMSwgdGhpcy5fbWF4SGRjcExldmVsID0gbnVsbCwgdGhpcy5hYnJDb250cm9sbGVyID0gdm9pZCAwLCB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIgPSB2b2lkIDAsIHRoaXMuY2FwTGV2ZWxDb250cm9sbGVyID0gdm9pZCAwLCB0aGlzLmxhdGVuY3lDb250cm9sbGVyID0gdm9pZCAwLCB0aGlzLmxldmVsQ29udHJvbGxlciA9IHZvaWQgMCwgdGhpcy5zdHJlYW1Db250cm9sbGVyID0gdm9pZCAwLCB0aGlzLmF1ZGlvU3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMCwgdGhpcy5zdWJ0aXRpdGxlU3RyZWFtQ29udHJvbGxlciA9IHZvaWQgMCwgdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlciA9IHZvaWQgMCwgdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHZvaWQgMCwgdGhpcy5pbnRlcnN0aXRpYWxzQ29udHJvbGxlciA9IHZvaWQgMCwgdGhpcy5nYXBDb250cm9sbGVyID0gdm9pZCAwLCB0aGlzLmVtZUNvbnRyb2xsZXIgPSB2b2lkIDAsIHRoaXMuY21jZENvbnRyb2xsZXIgPSB2b2lkIDAsIHRoaXMuX21lZGlhID0gbnVsbCwgdGhpcy5fdXJsID0gbnVsbCwgdGhpcy5fc2Vzc2lvbklkID0gdm9pZCAwLCB0aGlzLnRyaWdnZXJpbmdFeGNlcHRpb24gPSB2b2lkIDAsIHRoaXMuc3RhcnRlZCA9ICExO1xuICAgIGNvbnN0IHQgPSB0aGlzLmxvZ2dlciA9IExTKGUuZGVidWcgfHwgITEsIFwiSGxzIGluc3RhbmNlXCIsIGUuYXNzZXRQbGF5ZXJJZCksIHIgPSB0aGlzLmNvbmZpZyA9IGxBKEhyLkRlZmF1bHRDb25maWcsIGUsIHQpO1xuICAgIHRoaXMudXNlckNvbmZpZyA9IGUsIHIucHJvZ3Jlc3NpdmUgJiYgY0EociwgdCk7XG4gICAgY29uc3Qge1xuICAgICAgYWJyQ29udHJvbGxlcjogbixcbiAgICAgIGJ1ZmZlckNvbnRyb2xsZXI6IGksXG4gICAgICBjYXBMZXZlbENvbnRyb2xsZXI6IG8sXG4gICAgICBlcnJvckNvbnRyb2xsZXI6IGEsXG4gICAgICBmcHNDb250cm9sbGVyOiBsXG4gICAgfSA9IHIsIGMgPSBuZXcgYSh0aGlzKSwgdSA9IHRoaXMuYWJyQ29udHJvbGxlciA9IG5ldyBuKHRoaXMpLCBkID0gbmV3IFRiKHRoaXMpLCBoID0gci5pbnRlcnN0aXRpYWxzQ29udHJvbGxlciwgZiA9IGggPyB0aGlzLmludGVyc3RpdGlhbHNDb250cm9sbGVyID0gbmV3IGgodGhpcywgSHIpIDogbnVsbCwgcCA9IHRoaXMuYnVmZmVyQ29udHJvbGxlciA9IG5ldyBpKHRoaXMsIGQpLCB5ID0gdGhpcy5jYXBMZXZlbENvbnRyb2xsZXIgPSBuZXcgbyh0aGlzKSwgRSA9IG5ldyBsKHRoaXMpLCBiID0gbmV3IFRBKHRoaXMpLCBSID0gci5jb250ZW50U3RlZXJpbmdDb250cm9sbGVyLCBBID0gUiA/IG5ldyBSKHRoaXMpIDogbnVsbCwgRiA9IHRoaXMubGV2ZWxDb250cm9sbGVyID0gbmV3IHlBKHRoaXMsIEEpLCBNID0gbmV3IHBBKHRoaXMpLCBIID0gbmV3IGJBKHRoaXMuY29uZmlnLCB0aGlzLmxvZ2dlciksIEsgPSB0aGlzLnN0cmVhbUNvbnRyb2xsZXIgPSBuZXcgU0EodGhpcywgZCwgSCksIGogPSB0aGlzLmdhcENvbnRyb2xsZXIgPSBuZXcgZkEodGhpcywgZCk7XG4gICAgeS5zZXRTdHJlYW1Db250cm9sbGVyKEspLCBFLnNldFN0cmVhbUNvbnRyb2xsZXIoSyk7XG4gICAgY29uc3QgQyA9IFtiLCBGLCBLXTtcbiAgICBmICYmIEMuc3BsaWNlKDEsIDAsIGYpLCBBICYmIEMuc3BsaWNlKDEsIDAsIEEpLCB0aGlzLm5ldHdvcmtDb250cm9sbGVycyA9IEM7XG4gICAgY29uc3QgayA9IFt1LCBwLCBqLCB5LCBFLCBNLCBkXTtcbiAgICB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKHIuYXVkaW9UcmFja0NvbnRyb2xsZXIsIEMpO1xuICAgIGNvbnN0ICQgPSByLmF1ZGlvU3RyZWFtQ29udHJvbGxlcjtcbiAgICAkICYmIEMucHVzaCh0aGlzLmF1ZGlvU3RyZWFtQ29udHJvbGxlciA9IG5ldyAkKHRoaXMsIGQsIEgpKSwgdGhpcy5zdWJ0aXRsZVRyYWNrQ29udHJvbGxlciA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihyLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyLCBDKTtcbiAgICBjb25zdCBXID0gci5zdWJ0aXRsZVN0cmVhbUNvbnRyb2xsZXI7XG4gICAgVyAmJiBDLnB1c2godGhpcy5zdWJ0aXRpdGxlU3RyZWFtQ29udHJvbGxlciA9IG5ldyBXKHRoaXMsIGQsIEgpKSwgdGhpcy5jcmVhdGVDb250cm9sbGVyKHIudGltZWxpbmVDb250cm9sbGVyLCBrKSwgSC5lbWVDb250cm9sbGVyID0gdGhpcy5lbWVDb250cm9sbGVyID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKHIuZW1lQ29udHJvbGxlciwgayksIHRoaXMuY21jZENvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIoci5jbWNkQ29udHJvbGxlciwgayksIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xsZXIobUEsIGspLCB0aGlzLmNvcmVDb21wb25lbnRzID0gaywgQy5wdXNoKGMpO1xuICAgIGNvbnN0IF8gPSBjLm9uRXJyb3JPdXQ7XG4gICAgdHlwZW9mIF8gPT0gXCJmdW5jdGlvblwiICYmIHRoaXMub24oSS5FUlJPUiwgXywgYyksIHRoaXMub24oSS5NQU5JRkVTVF9MT0FERUQsIGIub25NYW5pZmVzdExvYWRlZCwgYik7XG4gIH1cbiAgY3JlYXRlQ29udHJvbGxlcihlLCB0KSB7XG4gICAgaWYgKGUpIHtcbiAgICAgIGNvbnN0IHIgPSBuZXcgZSh0aGlzKTtcbiAgICAgIHJldHVybiB0ICYmIHQucHVzaChyKSwgcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLy8gRGVsZWdhdGUgdGhlIEV2ZW50RW1pdHRlciB0aHJvdWdoIHRoZSBwdWJsaWMgQVBJIG9mIEhscy5qc1xuICBvbihlLCB0LCByID0gdGhpcykge1xuICAgIHRoaXMuX2VtaXR0ZXIub24oZSwgdCwgcik7XG4gIH1cbiAgb25jZShlLCB0LCByID0gdGhpcykge1xuICAgIHRoaXMuX2VtaXR0ZXIub25jZShlLCB0LCByKTtcbiAgfVxuICByZW1vdmVBbGxMaXN0ZW5lcnMoZSkge1xuICAgIHRoaXMuX2VtaXR0ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKGUpO1xuICB9XG4gIG9mZihlLCB0LCByID0gdGhpcywgbikge1xuICAgIHRoaXMuX2VtaXR0ZXIub2ZmKGUsIHQsIHIsIG4pO1xuICB9XG4gIGxpc3RlbmVycyhlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VtaXR0ZXIubGlzdGVuZXJzKGUpO1xuICB9XG4gIGVtaXQoZSwgdCwgcikge1xuICAgIHJldHVybiB0aGlzLl9lbWl0dGVyLmVtaXQoZSwgdCwgcik7XG4gIH1cbiAgdHJpZ2dlcihlLCB0KSB7XG4gICAgaWYgKHRoaXMuY29uZmlnLmRlYnVnKVxuICAgICAgcmV0dXJuIHRoaXMuZW1pdChlLCBlLCB0KTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdChlLCBlLCB0KTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBpZiAodGhpcy5sb2dnZXIuZXJyb3IoXCJBbiBpbnRlcm5hbCBlcnJvciBoYXBwZW5lZCB3aGlsZSBoYW5kbGluZyBldmVudCBcIiArIGUgKyAnLiBFcnJvciBtZXNzYWdlOiBcIicgKyByLm1lc3NhZ2UgKyAnXCIuIEhlcmUgaXMgYSBzdGFja3RyYWNlOicsIHIpLCAhdGhpcy50cmlnZ2VyaW5nRXhjZXB0aW9uKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcmluZ0V4Y2VwdGlvbiA9ICEwO1xuICAgICAgICBjb25zdCBuID0gZSA9PT0gSS5FUlJPUjtcbiAgICAgICAgdGhpcy50cmlnZ2VyKEkuRVJST1IsIHtcbiAgICAgICAgICB0eXBlOiB2ZS5PVEhFUl9FUlJPUixcbiAgICAgICAgICBkZXRhaWxzOiBKLklOVEVSTkFMX0VYQ0VQVElPTixcbiAgICAgICAgICBmYXRhbDogbixcbiAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICBlcnJvcjogclxuICAgICAgICB9KSwgdGhpcy50cmlnZ2VyaW5nRXhjZXB0aW9uID0gITE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAhMTtcbiAgfVxuICBsaXN0ZW5lckNvdW50KGUpIHtcbiAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5saXN0ZW5lckNvdW50KGUpO1xuICB9XG4gIC8qKlxuICAgKiBEaXNwb3NlIG9mIHRoZSBpbnN0YW5jZVxuICAgKi9cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coXCJkZXN0cm95XCIpLCB0aGlzLnRyaWdnZXIoSS5ERVNUUk9ZSU5HLCB2b2lkIDApLCB0aGlzLmRldGFjaE1lZGlhKCksIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCksIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMSwgdGhpcy5fdXJsID0gbnVsbCwgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaCgodCkgPT4gdC5kZXN0cm95KCkpLCB0aGlzLm5ldHdvcmtDb250cm9sbGVycy5sZW5ndGggPSAwLCB0aGlzLmNvcmVDb21wb25lbnRzLmZvckVhY2goKHQpID0+IHQuZGVzdHJveSgpKSwgdGhpcy5jb3JlQ29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgIGNvbnN0IGUgPSB0aGlzLmNvbmZpZztcbiAgICBlLnhoclNldHVwID0gZS5mZXRjaFNldHVwID0gdm9pZCAwLCB0aGlzLnVzZXJDb25maWcgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBBdHRhY2hlcyBIbHMuanMgdG8gYSBtZWRpYSBlbGVtZW50XG4gICAqL1xuICBhdHRhY2hNZWRpYShlKSB7XG4gICAgaWYgKCFlIHx8IFwibWVkaWFcIiBpbiBlICYmICFlLm1lZGlhKSB7XG4gICAgICBjb25zdCBpID0gbmV3IEVycm9yKGBhdHRhY2hNZWRpYSBmYWlsZWQ6IGludmFsaWQgYXJndW1lbnQgKCR7ZX0pYCk7XG4gICAgICB0aGlzLnRyaWdnZXIoSS5FUlJPUiwge1xuICAgICAgICB0eXBlOiB2ZS5PVEhFUl9FUlJPUixcbiAgICAgICAgZGV0YWlsczogSi5BVFRBQ0hfTUVESUFfRVJST1IsXG4gICAgICAgIGZhdGFsOiAhMCxcbiAgICAgICAgZXJyb3I6IGlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxvZ2dlci5sb2coXCJhdHRhY2hNZWRpYVwiKSwgdGhpcy5fbWVkaWEgJiYgKHRoaXMubG9nZ2VyLndhcm4oXCJtZWRpYSBtdXN0IGJlIGRldGFjaGVkIGJlZm9yZSBhdHRhY2hpbmdcIiksIHRoaXMuZGV0YWNoTWVkaWEoKSk7XG4gICAgY29uc3QgdCA9IFwibWVkaWFcIiBpbiBlLCByID0gdCA/IGUubWVkaWEgOiBlLCBuID0gdCA/IGUgOiB7XG4gICAgICBtZWRpYTogclxuICAgIH07XG4gICAgdGhpcy5fbWVkaWEgPSByLCB0aGlzLnRyaWdnZXIoSS5NRURJQV9BVFRBQ0hJTkcsIG4pO1xuICB9XG4gIC8qKlxuICAgKiBEZXRhY2ggSGxzLmpzIGZyb20gdGhlIG1lZGlhXG4gICAqL1xuICBkZXRhY2hNZWRpYSgpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coXCJkZXRhY2hNZWRpYVwiKSwgdGhpcy50cmlnZ2VyKEkuTUVESUFfREVUQUNISU5HLCB7fSksIHRoaXMuX21lZGlhID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogRGV0YWNoIEhUTUxNZWRpYUVsZW1lbnQsIE1lZGlhU291cmNlLCBhbmQgU291cmNlQnVmZmVycyB3aXRob3V0IHJlc2V0LCBmb3IgYXR0YWNoaW5nIHRvIGFub3RoZXIgaW5zdGFuY2VcbiAgICovXG4gIHRyYW5zZmVyTWVkaWEoKSB7XG4gICAgdGhpcy5fbWVkaWEgPSBudWxsO1xuICAgIGNvbnN0IGUgPSB0aGlzLmJ1ZmZlckNvbnRyb2xsZXIudHJhbnNmZXJNZWRpYSgpO1xuICAgIHJldHVybiB0aGlzLnRyaWdnZXIoSS5NRURJQV9ERVRBQ0hJTkcsIHtcbiAgICAgIHRyYW5zZmVyTWVkaWE6IGVcbiAgICB9KSwgZTtcbiAgfVxuICAvKipcbiAgICogU2V0IHRoZSBzb3VyY2UgVVJMLiBDYW4gYmUgcmVsYXRpdmUgb3IgYWJzb2x1dGUuXG4gICAqL1xuICBsb2FkU291cmNlKGUpIHtcbiAgICB0aGlzLnN0b3BMb2FkKCk7XG4gICAgY29uc3QgdCA9IHRoaXMubWVkaWEsIHIgPSB0aGlzLl91cmwsIG4gPSB0aGlzLl91cmwgPSBodS5idWlsZEFic29sdXRlVVJMKHNlbGYubG9jYXRpb24uaHJlZiwgZSwge1xuICAgICAgYWx3YXlzTm9ybWFsaXplOiAhMFxuICAgIH0pO1xuICAgIHRoaXMuX2F1dG9MZXZlbENhcHBpbmcgPSAtMSwgdGhpcy5fbWF4SGRjcExldmVsID0gbnVsbCwgdGhpcy5sb2dnZXIubG9nKGBsb2FkU291cmNlOiR7bn1gKSwgdCAmJiByICYmIChyICE9PSBuIHx8IHRoaXMuYnVmZmVyQ29udHJvbGxlci5oYXNTb3VyY2VUeXBlcygpKSAmJiAodGhpcy5kZXRhY2hNZWRpYSgpLCB0aGlzLmF0dGFjaE1lZGlhKHQpKSwgdGhpcy50cmlnZ2VyKEkuTUFOSUZFU1RfTE9BRElORywge1xuICAgICAgdXJsOiBlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnRseSBsb2FkZWQgVVJMXG4gICAqL1xuICBnZXQgdXJsKCkge1xuICAgIHJldHVybiB0aGlzLl91cmw7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IGVub3VnaCBoYXMgYmVlbiBidWZmZXJlZCB0byBzZWVrIHRvIHN0YXJ0IHBvc2l0aW9uIG9yIHVzZSBgbWVkaWEuY3VycmVudFRpbWVgIHRvIGRldGVybWluZSBuZXh0IGxvYWQgcG9zaXRpb25cbiAgICovXG4gIGdldCBoYXNFbm91Z2hUb1N0YXJ0KCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuaGFzRW5vdWdoVG9TdGFydDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBzdGFydFBvc2l0aW9uIHNldCBvbiBzdGFydExvYWQocG9zaXRpb24pIG9yIG9uIGF1dG9zdGFydCB3aXRoIGNvbmZpZy5zdGFydFBvc2l0aW9uXG4gICAqL1xuICBnZXQgc3RhcnRQb3NpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLnN0YXJ0UG9zaXRpb25WYWx1ZTtcbiAgfVxuICAvKipcbiAgICogU3RhcnQgbG9hZGluZyBkYXRhIGZyb20gdGhlIHN0cmVhbSBzb3VyY2UuXG4gICAqIERlcGVuZGluZyBvbiBkZWZhdWx0IGNvbmZpZywgY2xpZW50IHN0YXJ0cyBsb2FkaW5nIGF1dG9tYXRpY2FsbHkgd2hlbiBhIHNvdXJjZSBpcyBzZXQuXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydFBvc2l0aW9uIC0gU2V0IHRoZSBzdGFydCBwb3NpdGlvbiB0byBzdHJlYW0gZnJvbS5cbiAgICogRGVmYXVsdHMgdG8gLTEgKE5vbmU6IHN0YXJ0cyBmcm9tIGVhcmxpZXN0IHBvaW50KVxuICAgKi9cbiAgc3RhcnRMb2FkKGUgPSAtMSwgdCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgc3RhcnRMb2FkKCR7ZSArICh0ID8gXCIsIDxza2lwIHNlZWsgdG8gc3RhcnQ+XCIgOiBcIlwiKX0pYCksIHRoaXMuc3RhcnRlZCA9ICEwLCB0aGlzLnJlc3VtZUJ1ZmZlcmluZygpO1xuICAgIGZvciAobGV0IHIgPSAwOyByIDwgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMubGVuZ3RoICYmICh0aGlzLm5ldHdvcmtDb250cm9sbGVyc1tyXS5zdGFydExvYWQoZSwgdCksICEoIXRoaXMuc3RhcnRlZCB8fCAhdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMpKTsgcisrKVxuICAgICAgO1xuICB9XG4gIC8qKlxuICAgKiBTdG9wIGxvYWRpbmcgb2YgYW55IHN0cmVhbSBkYXRhLlxuICAgKi9cbiAgc3RvcExvYWQoKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwic3RvcExvYWRcIiksIHRoaXMuc3RhcnRlZCA9ICExO1xuICAgIGZvciAobGV0IGUgPSAwOyBlIDwgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMubGVuZ3RoICYmICh0aGlzLm5ldHdvcmtDb250cm9sbGVyc1tlXS5zdG9wTG9hZCgpLCAhKHRoaXMuc3RhcnRlZCB8fCAhdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMpKTsgZSsrKVxuICAgICAgO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgbG9hZGluZywgdG9nZ2xlZCB3aXRoIGBzdGFydExvYWQoKWAgYW5kIGBzdG9wTG9hZCgpYCwgaXMgYWN0aXZlIG9yIG5vdGAuXG4gICAqL1xuICBnZXQgbG9hZGluZ0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhcnRlZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBzdGF0ZSBvZiBmcmFnbWVudCBsb2FkaW5nIHRvZ2dsZWQgYnkgY2FsbGluZyBgcGF1c2VCdWZmZXJpbmcoKWAgYW5kIGByZXN1bWVCdWZmZXJpbmcoKWAuXG4gICAqL1xuICBnZXQgYnVmZmVyaW5nRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmJ1ZmZlcmluZ0VuYWJsZWQ7XG4gIH1cbiAgLyoqXG4gICAqIFJlc3VtZXMgc3RyZWFtIGNvbnRyb2xsZXIgc2VnbWVudCBsb2FkaW5nIGFmdGVyIGBwYXVzZUJ1ZmZlcmluZ2AgaGFzIGJlZW4gY2FsbGVkLlxuICAgKi9cbiAgcmVzdW1lQnVmZmVyaW5nKCkge1xuICAgIHRoaXMuYnVmZmVyaW5nRW5hYmxlZCB8fCAodGhpcy5sb2dnZXIubG9nKFwicmVzdW1lIGJ1ZmZlcmluZ1wiKSwgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5yZXN1bWVCdWZmZXJpbmcgJiYgZS5yZXN1bWVCdWZmZXJpbmcoKTtcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIFByZXZlbnRzIHN0cmVhbSBjb250cm9sbGVyIGZyb20gbG9hZGluZyBuZXcgc2VnbWVudHMgdW50aWwgYHJlc3VtZUJ1ZmZlcmluZ2AgaXMgY2FsbGVkLlxuICAgKiBUaGlzIGFsbG93cyBmb3IgbWVkaWEgYnVmZmVyaW5nIHRvIGJlIHBhdXNlZCB3aXRob3V0IGludGVydXB0aW5nIHBsYXlsaXN0IGxvYWRpbmcuXG4gICAqL1xuICBwYXVzZUJ1ZmZlcmluZygpIHtcbiAgICB0aGlzLmJ1ZmZlcmluZ0VuYWJsZWQgJiYgKHRoaXMubG9nZ2VyLmxvZyhcInBhdXNlIGJ1ZmZlcmluZ1wiKSwgdGhpcy5uZXR3b3JrQ29udHJvbGxlcnMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZS5wYXVzZUJ1ZmZlcmluZyAmJiBlLnBhdXNlQnVmZmVyaW5nKCk7XG4gICAgfSkpO1xuICB9XG4gIGdldCBpbkZsaWdodEZyYWdtZW50cygpIHtcbiAgICBjb25zdCBlID0ge1xuICAgICAgW3BlLk1BSU5dOiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuaW5GbGlnaHRGcmFnXG4gICAgfTtcbiAgICByZXR1cm4gdGhpcy5hdWRpb1N0cmVhbUNvbnRyb2xsZXIgJiYgKGVbcGUuQVVESU9dID0gdGhpcy5hdWRpb1N0cmVhbUNvbnRyb2xsZXIuaW5GbGlnaHRGcmFnKSwgdGhpcy5zdWJ0aXRpdGxlU3RyZWFtQ29udHJvbGxlciAmJiAoZVtwZS5TVUJUSVRMRV0gPSB0aGlzLnN1YnRpdGl0bGVTdHJlYW1Db250cm9sbGVyLmluRmxpZ2h0RnJhZyksIGU7XG4gIH1cbiAgLyoqXG4gICAqIFN3YXAgdGhyb3VnaCBwb3NzaWJsZSBhdWRpbyBjb2RlY3MgaW4gdGhlIHN0cmVhbSAoZm9yIGV4YW1wbGUgdG8gc3dpdGNoIGZyb20gc3RlcmVvIHRvIDUuMSlcbiAgICovXG4gIHN3YXBBdWRpb0NvZGVjKCkge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhcInN3YXBBdWRpb0NvZGVjXCIpLCB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuc3dhcEF1ZGlvQ29kZWMoKTtcbiAgfVxuICAvKipcbiAgICogV2hlbiB0aGUgbWVkaWEtZWxlbWVudCBmYWlscywgdGhpcyBhbGxvd3MgdG8gZGV0YWNoIGFuZCB0aGVuIHJlLWF0dGFjaCBpdFxuICAgKiBhcyBvbmUgY2FsbCAoY29udmVuaWVuY2UgbWV0aG9kKS5cbiAgICpcbiAgICogQXV0b21hdGljIHJlY292ZXJ5IG9mIG1lZGlhLWVycm9ycyBieSB0aGlzIHByb2Nlc3MgaXMgY29uZmlndXJhYmxlLlxuICAgKi9cbiAgcmVjb3Zlck1lZGlhRXJyb3IoKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKFwicmVjb3Zlck1lZGlhRXJyb3JcIik7XG4gICAgY29uc3QgZSA9IHRoaXMuX21lZGlhLCB0ID0gZSA9PSBudWxsID8gdm9pZCAwIDogZS5jdXJyZW50VGltZTtcbiAgICB0aGlzLmRldGFjaE1lZGlhKCksIGUgJiYgKHRoaXMuYXR0YWNoTWVkaWEoZSksIHQgJiYgdGhpcy5zdGFydExvYWQodCkpO1xuICB9XG4gIHJlbW92ZUxldmVsKGUpIHtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5yZW1vdmVMZXZlbChlKTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgYSBVVUlEIGZvciB0aGlzIHBsYXllciBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0IHNlc3Npb25JZCgpIHtcbiAgICBsZXQgZSA9IHRoaXMuX3Nlc3Npb25JZDtcbiAgICByZXR1cm4gZSB8fCAoZSA9IHRoaXMuX3Nlc3Npb25JZCA9IGZ3KCkpLCBlO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiBsZXZlbHMgKHZhcmlhbnRzKSBzb3J0ZWQgYnkgSERDUC1MRVZFTCwgUkVTT0xVVElPTiAoaGVpZ2h0KSwgRlJBTUUtUkFURSwgQ09ERUNTLCBWSURFTy1SQU5HRSwgYW5kIEJBTkRXSURUSFxuICAgKi9cbiAgZ2V0IGxldmVscygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5sZXZlbENvbnRyb2xsZXIubGV2ZWxzO1xuICAgIHJldHVybiBlIHx8IFtdO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyBMZXZlbERldGFpbHMgb2YgbGFzdCBsb2FkZWQgbGV2ZWwgKHZhcmlhbnQpIG9yIGBudWxsYCBwcmlvciB0byBsb2FkaW5nIGEgbWVkaWEgcGxheWxpc3QuXG4gICAqL1xuICBnZXQgbGF0ZXN0TGV2ZWxEZXRhaWxzKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmVhbUNvbnRyb2xsZXIuZ2V0TGV2ZWxEZXRhaWxzKCkgfHwgbnVsbDtcbiAgfVxuICAvKipcbiAgICogQHJldHVybnMgTGV2ZWwgb2JqZWN0IG9mIHNlbGVjdGVkIGxldmVsICh2YXJpYW50KSBvciBgbnVsbGAgcHJpb3IgdG8gc2VsZWN0aW5nIGEgbGV2ZWwgb3Igb25jZSB0aGUgbGV2ZWwgaXMgcmVtb3ZlZC5cbiAgICovXG4gIGdldCBsb2FkTGV2ZWxPYmooKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxvYWRMZXZlbE9iajtcbiAgfVxuICAvKipcbiAgICogSW5kZXggb2YgcXVhbGl0eSBsZXZlbCAodmFyaWFudCkgY3VycmVudGx5IHBsYXllZFxuICAgKi9cbiAgZ2V0IGN1cnJlbnRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmN1cnJlbnRMZXZlbDtcbiAgfVxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggaW1tZWRpYXRlbHkuIFRoaXMgd2lsbCBmbHVzaCB0aGUgY3VycmVudCBidWZmZXIgdG8gcmVwbGFjZSB0aGUgcXVhbGl0eSBhc2FwLiBUaGF0IG1lYW5zIHBsYXliYWNrIHdpbGwgaW50ZXJydXB0IGF0IGxlYXN0IHNob3J0bHkgdG8gcmUtYnVmZmVyIGFuZCByZS1zeW5jIGV2ZW50dWFsbHkuIFNldCB0byAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbi5cbiAgICovXG4gIHNldCBjdXJyZW50TGV2ZWwoZSkge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgc2V0IGN1cnJlbnRMZXZlbDoke2V9YCksIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gZSwgdGhpcy5zdHJlYW1Db250cm9sbGVyLmltbWVkaWF0ZUxldmVsU3dpdGNoKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluZGV4IG9mIG5leHQgcXVhbGl0eSBsZXZlbCBsb2FkZWQgYXMgc2NoZWR1bGVkIGJ5IHN0cmVhbSBjb250cm9sbGVyLlxuICAgKi9cbiAgZ2V0IG5leHRMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbDtcbiAgfVxuICAvKipcbiAgICogU2V0IHF1YWxpdHkgbGV2ZWwgaW5kZXggZm9yIG5leHQgbG9hZGVkIGRhdGEuXG4gICAqIFRoaXMgd2lsbCBzd2l0Y2ggdGhlIHZpZGVvIHF1YWxpdHkgYXNhcCwgd2l0aG91dCBpbnRlcnJ1cHRpbmcgcGxheWJhY2suXG4gICAqIE1heSBhYm9ydCBjdXJyZW50IGxvYWRpbmcgb2YgZGF0YSwgYW5kIGZsdXNoIHBhcnRzIG9mIGJ1ZmZlciAob3V0c2lkZSBjdXJyZW50bHkgcGxheWVkIGZyYWdtZW50IHJlZ2lvbikuXG4gICAqIEBwYXJhbSBuZXdMZXZlbCAtIFBhc3MgLTEgZm9yIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb25cbiAgICovXG4gIHNldCBuZXh0TGV2ZWwoZSkge1xuICAgIHRoaXMubG9nZ2VyLmxvZyhgc2V0IG5leHRMZXZlbDoke2V9YCksIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID0gZSwgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHF1YWxpdHkgbGV2ZWwgb2YgdGhlIGN1cnJlbnRseSBvciBsYXN0IChvZiBub25lIGlzIGxvYWRlZCBjdXJyZW50bHkpIHNlZ21lbnRcbiAgICovXG4gIGdldCBsb2FkTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLmxldmVsO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgcXVhbGl0eSBsZXZlbCBpbmRleCBmb3IgbmV4dCBsb2FkZWQgZGF0YSBpbiBhIGNvbnNlcnZhdGl2ZSB3YXkuXG4gICAqIFRoaXMgd2lsbCBzd2l0Y2ggdGhlIHF1YWxpdHkgd2l0aG91dCBmbHVzaGluZywgYnV0IGludGVycnVwdCBjdXJyZW50IGxvYWRpbmcuXG4gICAqIFRodXMgdGhlIG1vbWVudCB3aGVuIHRoZSBxdWFsaXR5IHN3aXRjaCB3aWxsIGFwcGVhciBpbiBlZmZlY3Qgd2lsbCBvbmx5IGJlIGFmdGVyIHRoZSBhbHJlYWR5IGV4aXN0aW5nIGJ1ZmZlci5cbiAgICogQHBhcmFtIG5ld0xldmVsIC0gUGFzcyAtMSBmb3IgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvblxuICAgKi9cbiAgc2V0IGxvYWRMZXZlbChlKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBzZXQgbG9hZExldmVsOiR7ZX1gKSwgdGhpcy5sZXZlbENvbnRyb2xsZXIubWFudWFsTGV2ZWwgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgbmV4dCBxdWFsaXR5IGxldmVsIGxvYWRlZFxuICAgKi9cbiAgZ2V0IG5leHRMb2FkTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWw7XG4gIH1cbiAgLyoqXG4gICAqIFNldCBxdWFsaXR5IGxldmVsIG9mIG5leHQgbG9hZGVkIHNlZ21lbnQgaW4gYSBmdWxseSBcIm5vbi1kZXN0cnVjdGl2ZVwiIHdheS5cbiAgICogU2FtZSBhcyBgbG9hZExldmVsYCBidXQgd2lsbCB3YWl0IGZvciBuZXh0IHN3aXRjaCAodW50aWwgY3VycmVudCBsb2FkaW5nIGlzIGRvbmUpLlxuICAgKi9cbiAgc2V0IG5leHRMb2FkTGV2ZWwoZSkge1xuICAgIHRoaXMubGV2ZWxDb250cm9sbGVyLm5leHRMb2FkTGV2ZWwgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm4gXCJmaXJzdCBsZXZlbFwiOiBsaWtlIGEgZGVmYXVsdCBsZXZlbCwgaWYgbm90IHNldCxcbiAgICogZmFsbHMgYmFjayB0byBpbmRleCBvZiBmaXJzdCBsZXZlbCByZWZlcmVuY2VkIGluIG1hbmlmZXN0XG4gICAqL1xuICBnZXQgZmlyc3RMZXZlbCgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgodGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbCwgdGhpcy5taW5BdXRvTGV2ZWwpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIFwiZmlyc3QtbGV2ZWxcIiwgc2VlIGdldHRlci5cbiAgICovXG4gIHNldCBmaXJzdExldmVsKGUpIHtcbiAgICB0aGlzLmxvZ2dlci5sb2coYHNldCBmaXJzdExldmVsOiR7ZX1gKSwgdGhpcy5sZXZlbENvbnRyb2xsZXIuZmlyc3RMZXZlbCA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgZGVzaXJlZCBzdGFydCBsZXZlbCBmb3IgdGhlIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBsb2FkZWQuXG4gICAqIFRoZSBkZWZhdWx0IHZhbHVlIG9mIC0xIGluZGljYXRlcyBhdXRvbWF0aWMgc3RhcnQgbGV2ZWwgc2VsZWN0aW9uLlxuICAgKiBTZXR0aW5nIGhscy5uZXh0QXV0b0xldmVsIHdpdGhvdXQgc2V0dGluZyBhIHN0YXJ0TGV2ZWwgd2lsbCByZXN1bHQgaW5cbiAgICogdGhlIG5leHRBdXRvTGV2ZWwgdmFsdWUgYmVpbmcgdXNlZCBmb3Igb25lIGZyYWdtZW50IGxvYWQuXG4gICAqL1xuICBnZXQgc3RhcnRMZXZlbCgpIHtcbiAgICBjb25zdCBlID0gdGhpcy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbDtcbiAgICByZXR1cm4gZSA9PT0gLTEgJiYgdGhpcy5hYnJDb250cm9sbGVyLmZvcmNlZEF1dG9MZXZlbCA+IC0xID8gdGhpcy5hYnJDb250cm9sbGVyLmZvcmNlZEF1dG9MZXZlbCA6IGU7XG4gIH1cbiAgLyoqXG4gICAqIHNldCAgc3RhcnQgbGV2ZWwgKGxldmVsIG9mIGZpcnN0IGZyYWdtZW50IHRoYXQgd2lsbCBiZSBwbGF5ZWQgYmFjaylcbiAgICogaWYgbm90IG92ZXJyaWRlZCBieSB1c2VyLCBmaXJzdCBsZXZlbCBhcHBlYXJpbmcgaW4gbWFuaWZlc3Qgd2lsbCBiZSB1c2VkIGFzIHN0YXJ0IGxldmVsXG4gICAqIGlmIC0xIDogYXV0b21hdGljIHN0YXJ0IGxldmVsIHNlbGVjdGlvbiwgcGxheWJhY2sgd2lsbCBzdGFydCBmcm9tIGxldmVsIG1hdGNoaW5nIGRvd25sb2FkIGJhbmR3aWR0aFxuICAgKiAoZGV0ZXJtaW5lZCBmcm9tIGRvd25sb2FkIG9mIGZpcnN0IHNlZ21lbnQpXG4gICAqL1xuICBzZXQgc3RhcnRMZXZlbChlKSB7XG4gICAgdGhpcy5sb2dnZXIubG9nKGBzZXQgc3RhcnRMZXZlbDoke2V9YCksIGUgIT09IC0xICYmIChlID0gTWF0aC5tYXgoZSwgdGhpcy5taW5BdXRvTGV2ZWwpKSwgdGhpcy5sZXZlbENvbnRyb2xsZXIuc3RhcnRMZXZlbCA9IGU7XG4gIH1cbiAgLyoqXG4gICAqIFdoZXRoZXIgbGV2ZWwgY2FwcGluZyBpcyBlbmFibGVkLlxuICAgKiBEZWZhdWx0IHZhbHVlIGlzIHNldCB2aWEgYGNvbmZpZy5jYXBMZXZlbFRvUGxheWVyU2l6ZWAuXG4gICAqL1xuICBnZXQgY2FwTGV2ZWxUb1BsYXllclNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmNhcExldmVsVG9QbGF5ZXJTaXplO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGVzIG9yIGRpc2FibGVzIGxldmVsIGNhcHBpbmcuIElmIGRpc2FibGVkIGFmdGVyIHByZXZpb3VzbHkgZW5hYmxlZCwgYG5leHRMZXZlbFN3aXRjaGAgd2lsbCBiZSBpbW1lZGlhdGVseSBjYWxsZWQuXG4gICAqL1xuICBzZXQgY2FwTGV2ZWxUb1BsYXllclNpemUoZSkge1xuICAgIGNvbnN0IHQgPSAhIWU7XG4gICAgdCAhPT0gdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgJiYgKHQgPyB0aGlzLmNhcExldmVsQ29udHJvbGxlci5zdGFydENhcHBpbmcoKSA6ICh0aGlzLmNhcExldmVsQ29udHJvbGxlci5zdG9wQ2FwcGluZygpLCB0aGlzLmF1dG9MZXZlbENhcHBpbmcgPSAtMSwgdGhpcy5zdHJlYW1Db250cm9sbGVyLm5leHRMZXZlbFN3aXRjaCgpKSwgdGhpcy5jb25maWcuY2FwTGV2ZWxUb1BsYXllclNpemUgPSB0KTtcbiAgfVxuICAvKipcbiAgICogQ2FwcGluZy9tYXggbGV2ZWwgdmFsdWUgdGhhdCBzaG91bGQgYmUgdXNlZCBieSBhdXRvbWF0aWMgbGV2ZWwgc2VsZWN0aW9uIGFsZ29yaXRobSAoYEFCUkNvbnRyb2xsZXJgKVxuICAgKi9cbiAgZ2V0IGF1dG9MZXZlbENhcHBpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dG9MZXZlbENhcHBpbmc7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgYmFuZHdpZHRoIGVzdGltYXRlIGluIGJpdHMgcGVyIHNlY29uZCwgd2hlbiBhdmFpbGFibGUuIE90aGVyd2lzZSwgYE5hTmAgaXMgcmV0dXJuZWQuXG4gICAqL1xuICBnZXQgYmFuZHdpZHRoRXN0aW1hdGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYndFc3RpbWF0b3I6IGVcbiAgICB9ID0gdGhpcy5hYnJDb250cm9sbGVyO1xuICAgIHJldHVybiBlID8gZS5nZXRFc3RpbWF0ZSgpIDogTmFOO1xuICB9XG4gIHNldCBiYW5kd2lkdGhFc3RpbWF0ZShlKSB7XG4gICAgdGhpcy5hYnJDb250cm9sbGVyLnJlc2V0RXN0aW1hdG9yKGUpO1xuICB9XG4gIGdldCBhYnJFd21hRGVmYXVsdEVzdGltYXRlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJ3RXN0aW1hdG9yOiBlXG4gICAgfSA9IHRoaXMuYWJyQ29udHJvbGxlcjtcbiAgICByZXR1cm4gZSA/IGUuZGVmYXVsdEVzdGltYXRlIDogTmFOO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgdGltZSB0byBmaXJzdCBieXRlIGVzdGltYXRlXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgdHRmYkVzdGltYXRlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGJ3RXN0aW1hdG9yOiBlXG4gICAgfSA9IHRoaXMuYWJyQ29udHJvbGxlcjtcbiAgICByZXR1cm4gZSA/IGUuZ2V0RXN0aW1hdGVUVEZCKCkgOiBOYU47XG4gIH1cbiAgLyoqXG4gICAqIENhcHBpbmcvbWF4IGxldmVsIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHVzZWQgYnkgYXV0b21hdGljIGxldmVsIHNlbGVjdGlvbiBhbGdvcml0aG0gKGBBQlJDb250cm9sbGVyYClcbiAgICovXG4gIHNldCBhdXRvTGV2ZWxDYXBwaW5nKGUpIHtcbiAgICB0aGlzLl9hdXRvTGV2ZWxDYXBwaW5nICE9PSBlICYmICh0aGlzLmxvZ2dlci5sb2coYHNldCBhdXRvTGV2ZWxDYXBwaW5nOiR7ZX1gKSwgdGhpcy5fYXV0b0xldmVsQ2FwcGluZyA9IGUsIHRoaXMubGV2ZWxDb250cm9sbGVyLmNoZWNrTWF4QXV0b1VwZGF0ZWQoKSk7XG4gIH1cbiAgZ2V0IG1heEhkY3BMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWF4SGRjcExldmVsO1xuICB9XG4gIHNldCBtYXhIZGNwTGV2ZWwoZSkge1xuICAgIGFiKGUpICYmIHRoaXMuX21heEhkY3BMZXZlbCAhPT0gZSAmJiAodGhpcy5fbWF4SGRjcExldmVsID0gZSwgdGhpcy5sZXZlbENvbnRyb2xsZXIuY2hlY2tNYXhBdXRvVXBkYXRlZCgpKTtcbiAgfVxuICAvKipcbiAgICogVHJ1ZSB3aGVuIGF1dG9tYXRpYyBsZXZlbCBzZWxlY3Rpb24gZW5hYmxlZFxuICAgKi9cbiAgZ2V0IGF1dG9MZXZlbEVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsID09PSAtMTtcbiAgfVxuICAvKipcbiAgICogTGV2ZWwgc2V0IG1hbnVhbGx5IChpZiBhbnkpXG4gICAqL1xuICBnZXQgbWFudWFsTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLm1hbnVhbExldmVsO1xuICB9XG4gIC8qKlxuICAgKiBtaW4gbGV2ZWwgc2VsZWN0YWJsZSBpbiBhdXRvIG1vZGUgYWNjb3JkaW5nIHRvIGNvbmZpZy5taW5BdXRvQml0cmF0ZVxuICAgKi9cbiAgZ2V0IG1pbkF1dG9MZXZlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHM6IGUsXG4gICAgICBjb25maWc6IHtcbiAgICAgICAgbWluQXV0b0JpdHJhdGU6IHRcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBpZiAoIWUpIHJldHVybiAwO1xuICAgIGNvbnN0IHIgPSBlLmxlbmd0aDtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IHI7IG4rKylcbiAgICAgIGlmIChlW25dLm1heEJpdHJhdGUgPj0gdClcbiAgICAgICAgcmV0dXJuIG47XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLyoqXG4gICAqIG1heCBsZXZlbCBzZWxlY3RhYmxlIGluIGF1dG8gbW9kZSBhY2NvcmRpbmcgdG8gYXV0b0xldmVsQ2FwcGluZ1xuICAgKi9cbiAgZ2V0IG1heEF1dG9MZXZlbCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBsZXZlbHM6IGUsXG4gICAgICBhdXRvTGV2ZWxDYXBwaW5nOiB0LFxuICAgICAgbWF4SGRjcExldmVsOiByXG4gICAgfSA9IHRoaXM7XG4gICAgbGV0IG47XG4gICAgaWYgKHQgPT09IC0xICYmIGUgIT0gbnVsbCAmJiBlLmxlbmd0aCA/IG4gPSBlLmxlbmd0aCAtIDEgOiBuID0gdCwgcilcbiAgICAgIGZvciAobGV0IGkgPSBuOyBpLS07ICkge1xuICAgICAgICBjb25zdCBvID0gZVtpXS5hdHRyc1tcIkhEQ1AtTEVWRUxcIl07XG4gICAgICAgIGlmIChvICYmIG8gPD0gcilcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICByZXR1cm4gbjtcbiAgfVxuICBnZXQgZmlyc3RBdXRvTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWJyQ29udHJvbGxlci5maXJzdEF1dG9MZXZlbDtcbiAgfVxuICAvKipcbiAgICogbmV4dCBhdXRvbWF0aWNhbGx5IHNlbGVjdGVkIHF1YWxpdHkgbGV2ZWxcbiAgICovXG4gIGdldCBuZXh0QXV0b0xldmVsKCkge1xuICAgIHJldHVybiB0aGlzLmFickNvbnRyb2xsZXIubmV4dEF1dG9MZXZlbDtcbiAgfVxuICAvKipcbiAgICogdGhpcyBzZXR0ZXIgaXMgdXNlZCB0byBmb3JjZSBuZXh0IGF1dG8gbGV2ZWwuXG4gICAqIHRoaXMgaXMgdXNlZnVsIHRvIGZvcmNlIGEgc3dpdGNoIGRvd24gaW4gYXV0byBtb2RlOlxuICAgKiBpbiBjYXNlIG9mIGxvYWQgZXJyb3Igb24gbGV2ZWwgTiwgaGxzLmpzIGNhbiBzZXQgbmV4dEF1dG9MZXZlbCB0byBOLTEgZm9yIGV4YW1wbGUpXG4gICAqIGZvcmNlZCB2YWx1ZSBpcyB2YWxpZCBmb3Igb25lIGZyYWdtZW50LiB1cG9uIHN1Y2Nlc3NmdWwgZnJhZyBsb2FkaW5nIGF0IGZvcmNlZCBsZXZlbCxcbiAgICogdGhpcyB2YWx1ZSB3aWxsIGJlIHJlc2V0dGVkIHRvIC0xIGJ5IEFCUiBjb250cm9sbGVyLlxuICAgKi9cbiAgc2V0IG5leHRBdXRvTGV2ZWwoZSkge1xuICAgIHRoaXMuYWJyQ29udHJvbGxlci5uZXh0QXV0b0xldmVsID0gZTtcbiAgfVxuICAvKipcbiAgICogZ2V0IHRoZSBkYXRldGltZSB2YWx1ZSByZWxhdGl2ZSB0byBtZWRpYS5jdXJyZW50VGltZSBmb3IgdGhlIGFjdGl2ZSBsZXZlbCBQcm9ncmFtIERhdGUgVGltZSBpZiBwcmVzZW50XG4gICAqL1xuICBnZXQgcGxheWluZ0RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5jdXJyZW50UHJvZ3JhbURhdGVUaW1lO1xuICB9XG4gIGdldCBtYWluRm9yd2FyZEJ1ZmZlckluZm8oKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5nZXRNYWluRndkQnVmZmVySW5mbygpO1xuICB9XG4gIGdldCBtYXhCdWZmZXJMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RyZWFtQ29udHJvbGxlci5tYXhCdWZmZXJMZW5ndGg7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgYW5kIHNlbGVjdCB0aGUgYmVzdCBtYXRjaGluZyBhdWRpbyB0cmFjaywgbWFraW5nIGEgbGV2ZWwgc3dpdGNoIHdoZW4gYSBHcm91cCBjaGFuZ2UgaXMgbmVjZXNzYXJ5LlxuICAgKiBVcGRhdGVzIGBobHMuY29uZmlnLmF1ZGlvUHJlZmVyZW5jZWAuIFJldHVybnMgdGhlIHNlbGVjdGVkIHRyYWNrLCBvciBudWxsIHdoZW4gbm8gbWF0Y2hpbmcgdHJhY2sgaXMgZm91bmQuXG4gICAqL1xuICBzZXRBdWRpb09wdGlvbihlKSB7XG4gICAgdmFyIHQ7XG4gICAgcmV0dXJuICgodCA9IHRoaXMuYXVkaW9UcmFja0NvbnRyb2xsZXIpID09IG51bGwgPyB2b2lkIDAgOiB0LnNldEF1ZGlvT3B0aW9uKGUpKSB8fCBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kIGFuZCBzZWxlY3QgdGhlIGJlc3QgbWF0Y2hpbmcgc3VidGl0bGUgdHJhY2ssIG1ha2luZyBhIGxldmVsIHN3aXRjaCB3aGVuIGEgR3JvdXAgY2hhbmdlIGlzIG5lY2Vzc2FyeS5cbiAgICogVXBkYXRlcyBgaGxzLmNvbmZpZy5zdWJ0aXRsZVByZWZlcmVuY2VgLiBSZXR1cm5zIHRoZSBzZWxlY3RlZCB0cmFjaywgb3IgbnVsbCB3aGVuIG5vIG1hdGNoaW5nIHRyYWNrIGlzIGZvdW5kLlxuICAgKi9cbiAgc2V0U3VidGl0bGVPcHRpb24oZSkge1xuICAgIHZhciB0O1xuICAgIHJldHVybiAoKHQgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyKSA9PSBudWxsID8gdm9pZCAwIDogdC5zZXRTdWJ0aXRsZU9wdGlvbihlKSkgfHwgbnVsbDtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBjb21wbGV0ZSBsaXN0IG9mIGF1ZGlvIHRyYWNrcyBhY3Jvc3MgYWxsIG1lZGlhIGdyb3Vwc1xuICAgKi9cbiAgZ2V0IGFsbEF1ZGlvVHJhY2tzKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBlID8gZS5hbGxBdWRpb1RyYWNrcyA6IFtdO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgdGhlIGxpc3Qgb2Ygc2VsZWN0YWJsZSBhdWRpbyB0cmFja3NcbiAgICovXG4gIGdldCBhdWRpb1RyYWNrcygpIHtcbiAgICBjb25zdCBlID0gdGhpcy5hdWRpb1RyYWNrQ29udHJvbGxlcjtcbiAgICByZXR1cm4gZSA/IGUuYXVkaW9UcmFja3MgOiBbXTtcbiAgfVxuICAvKipcbiAgICogaW5kZXggb2YgdGhlIHNlbGVjdGVkIGF1ZGlvIHRyYWNrIChpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0cylcbiAgICovXG4gIGdldCBhdWRpb1RyYWNrKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBlID8gZS5hdWRpb1RyYWNrIDogLTE7XG4gIH1cbiAgLyoqXG4gICAqIHNlbGVjdHMgYW4gYXVkaW8gdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBhdWRpbyB0cmFjayBsaXN0c1xuICAgKi9cbiAgc2V0IGF1ZGlvVHJhY2soZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmF1ZGlvVHJhY2tDb250cm9sbGVyO1xuICAgIHQgJiYgKHQuYXVkaW9UcmFjayA9IGUpO1xuICB9XG4gIC8qKlxuICAgKiBnZXQgdGhlIGNvbXBsZXRlIGxpc3Qgb2Ygc3VidGl0bGUgdHJhY2tzIGFjcm9zcyBhbGwgbWVkaWEgZ3JvdXBzXG4gICAqL1xuICBnZXQgYWxsU3VidGl0bGVUcmFja3MoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIGUgPyBlLmFsbFN1YnRpdGxlVHJhY2tzIDogW107XG4gIH1cbiAgLyoqXG4gICAqIGdldCBhbHRlcm5hdGUgc3VidGl0bGUgdHJhY2tzIGxpc3QgZnJvbSBwbGF5bGlzdFxuICAgKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2tzKCkge1xuICAgIGNvbnN0IGUgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHJldHVybiBlID8gZS5zdWJ0aXRsZVRyYWNrcyA6IFtdO1xuICB9XG4gIC8qKlxuICAgKiBpbmRleCBvZiB0aGUgc2VsZWN0ZWQgc3VidGl0bGUgdHJhY2sgKGluZGV4IGluIHN1YnRpdGxlIHRyYWNrIGxpc3RzKVxuICAgKi9cbiAgZ2V0IHN1YnRpdGxlVHJhY2soKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIGUgPyBlLnN1YnRpdGxlVHJhY2sgOiAtMTtcbiAgfVxuICBnZXQgbWVkaWEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhO1xuICB9XG4gIC8qKlxuICAgKiBzZWxlY3QgYW4gc3VidGl0bGUgdHJhY2ssIGJhc2VkIG9uIGl0cyBpbmRleCBpbiBzdWJ0aXRsZSB0cmFjayBsaXN0c1xuICAgKi9cbiAgc2V0IHN1YnRpdGxlVHJhY2soZSkge1xuICAgIGNvbnN0IHQgPSB0aGlzLnN1YnRpdGxlVHJhY2tDb250cm9sbGVyO1xuICAgIHQgJiYgKHQuc3VidGl0bGVUcmFjayA9IGUpO1xuICB9XG4gIC8qKlxuICAgKiBXaGV0aGVyIHN1YnRpdGxlIGRpc3BsYXkgaXMgZW5hYmxlZCBvciBub3RcbiAgICovXG4gIGdldCBzdWJ0aXRsZURpc3BsYXkoKSB7XG4gICAgY29uc3QgZSA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgcmV0dXJuIGUgPyBlLnN1YnRpdGxlRGlzcGxheSA6ICExO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGUvZGlzYWJsZSBzdWJ0aXRsZSBkaXNwbGF5IHJlbmRlcmluZ1xuICAgKi9cbiAgc2V0IHN1YnRpdGxlRGlzcGxheShlKSB7XG4gICAgY29uc3QgdCA9IHRoaXMuc3VidGl0bGVUcmFja0NvbnRyb2xsZXI7XG4gICAgdCAmJiAodC5zdWJ0aXRsZURpc3BsYXkgPSBlKTtcbiAgfVxuICAvKipcbiAgICogZ2V0IG1vZGUgZm9yIExvdy1MYXRlbmN5IEhMUyBsb2FkaW5nXG4gICAqL1xuICBnZXQgbG93TGF0ZW5jeU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnLmxvd0xhdGVuY3lNb2RlO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGUvZGlzYWJsZSBMb3ctTGF0ZW5jeSBITFMgcGFydCBwbGF5bGlzdCBhbmQgc2VnbWVudCBsb2FkaW5nLCBhbmQgc3RhcnQgbGl2ZSBzdHJlYW1zIGF0IHBsYXlsaXN0IFBBUlQtSE9MRC1CQUNLIHJhdGhlciB0aGFuIEhPTEQtQkFDSy5cbiAgICovXG4gIHNldCBsb3dMYXRlbmN5TW9kZShlKSB7XG4gICAgdGhpcy5jb25maWcubG93TGF0ZW5jeU1vZGUgPSBlO1xuICB9XG4gIC8qKlxuICAgKiBQb3NpdGlvbiAoaW4gc2Vjb25kcykgb2YgbGl2ZSBzeW5jIHBvaW50IChpZSBlZGdlIG9mIGxpdmUgcG9zaXRpb24gbWludXMgc2FmZXR5IGRlbGF5IGRlZmluZWQgYnkgYGBgaGxzLmNvbmZpZy5saXZlU3luY0R1cmF0aW9uYGBgKVxuICAgKiBAcmV0dXJucyBudWxsIHByaW9yIHRvIGxvYWRpbmcgbGl2ZSBQbGF5bGlzdFxuICAgKi9cbiAgZ2V0IGxpdmVTeW5jUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubGl2ZVN5bmNQb3NpdGlvbjtcbiAgfVxuICAvKipcbiAgICogRXN0aW1hdGVkIHBvc2l0aW9uIChpbiBzZWNvbmRzKSBvZiBsaXZlIGVkZ2UgKGllIGVkZ2Ugb2YgbGl2ZSBwbGF5bGlzdCBwbHVzIHRpbWUgc3luYyBwbGF5bGlzdCBhZHZhbmNlZClcbiAgICogQHJldHVybnMgMCBiZWZvcmUgZmlyc3QgcGxheWxpc3QgaXMgbG9hZGVkXG4gICAqL1xuICBnZXQgbGF0ZW5jeSgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5sYXRlbmN5O1xuICB9XG4gIC8qKlxuICAgKiBtYXhpbXVtIGRpc3RhbmNlIGZyb20gdGhlIGVkZ2UgYmVmb3JlIHRoZSBwbGF5ZXIgc2Vla3MgZm9yd2FyZCB0byBgYGBobHMubGl2ZVN5bmNQb3NpdGlvbmBgYFxuICAgKiBjb25maWd1cmVkIHVzaW5nIGBgYGxpdmVNYXhMYXRlbmN5RHVyYXRpb25Db3VudGBgYCAobXVsdGlwbGUgb2YgdGFyZ2V0IGR1cmF0aW9uKSBvciBgYGBsaXZlTWF4TGF0ZW5jeUR1cmF0aW9uYGBgXG4gICAqIEByZXR1cm5zIDAgYmVmb3JlIGZpcnN0IHBsYXlsaXN0IGlzIGxvYWRlZFxuICAgKi9cbiAgZ2V0IG1heExhdGVuY3koKSB7XG4gICAgcmV0dXJuIHRoaXMubGF0ZW5jeUNvbnRyb2xsZXIubWF4TGF0ZW5jeTtcbiAgfVxuICAvKipcbiAgICogdGFyZ2V0IGRpc3RhbmNlIGZyb20gdGhlIGVkZ2UgYXMgY2FsY3VsYXRlZCBieSB0aGUgbGF0ZW5jeSBjb250cm9sbGVyXG4gICAqL1xuICBnZXQgdGFyZ2V0TGF0ZW5jeSgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci50YXJnZXRMYXRlbmN5O1xuICB9XG4gIHNldCB0YXJnZXRMYXRlbmN5KGUpIHtcbiAgICB0aGlzLmxhdGVuY3lDb250cm9sbGVyLnRhcmdldExhdGVuY3kgPSBlO1xuICB9XG4gIC8qKlxuICAgKiB0aGUgcmF0ZSBhdCB3aGljaCB0aGUgZWRnZSBvZiB0aGUgY3VycmVudCBsaXZlIHBsYXlsaXN0IGlzIGFkdmFuY2luZyBvciAxIGlmIHRoZXJlIGlzIG5vbmVcbiAgICovXG4gIGdldCBkcmlmdCgpIHtcbiAgICByZXR1cm4gdGhpcy5sYXRlbmN5Q29udHJvbGxlci5kcmlmdDtcbiAgfVxuICAvKipcbiAgICogc2V0IHRvIHRydWUgd2hlbiBzdGFydExvYWQgaXMgY2FsbGVkIGJlZm9yZSBNQU5JRkVTVF9QQVJTRUQgZXZlbnRcbiAgICovXG4gIGdldCBmb3JjZVN0YXJ0TG9hZCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHJlYW1Db250cm9sbGVyLmZvcmNlU3RhcnRMb2FkO1xuICB9XG4gIC8qKlxuICAgKiBDb250ZW50U3RlZXJpbmcgcGF0aHdheXMgZ2V0dGVyXG4gICAqL1xuICBnZXQgcGF0aHdheXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLnBhdGh3YXlzO1xuICB9XG4gIC8qKlxuICAgKiBDb250ZW50U3RlZXJpbmcgcGF0aHdheVByaW9yaXR5IGdldHRlci9zZXR0ZXJcbiAgICovXG4gIGdldCBwYXRod2F5UHJpb3JpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMubGV2ZWxDb250cm9sbGVyLnBhdGh3YXlQcmlvcml0eTtcbiAgfVxuICBzZXQgcGF0aHdheVByaW9yaXR5KGUpIHtcbiAgICB0aGlzLmxldmVsQ29udHJvbGxlci5wYXRod2F5UHJpb3JpdHkgPSBlO1xuICB9XG4gIC8qKlxuICAgKiByZXR1cm5zIHRydWUgd2hlbiBhbGwgU291cmNlQnVmZmVycyBhcmUgYnVmZmVyZWQgdG8gdGhlIGVuZFxuICAgKi9cbiAgZ2V0IGJ1ZmZlcmVkVG9FbmQoKSB7XG4gICAgdmFyIGU7XG4gICAgcmV0dXJuICEhKChlID0gdGhpcy5idWZmZXJDb250cm9sbGVyKSAhPSBudWxsICYmIGUuYnVmZmVyZWRUb0VuZCk7XG4gIH1cbiAgLyoqXG4gICAqIHJldHVybnMgSW50ZXJzdGl0aWFscyBQcm9ncmFtIE1hbmFnZXJcbiAgICovXG4gIGdldCBpbnRlcnN0aXRpYWxzTWFuYWdlcigpIHtcbiAgICB2YXIgZTtcbiAgICByZXR1cm4gKChlID0gdGhpcy5pbnRlcnN0aXRpYWxzQ29udHJvbGxlcikgPT0gbnVsbCA/IHZvaWQgMCA6IGUuaW50ZXJzdGl0aWFsc01hbmFnZXIpIHx8IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIHJldHVybnMgbWVkaWFDYXBhYmlsaXRpZXMuZGVjb2RpbmdJbmZvIGZvciBhIHZhcmlhbnQvcmVuZGl0aW9uXG4gICAqL1xuICBnZXRNZWRpYURlY29kaW5nSW5mbyhlLCB0ID0gdGhpcy5hbGxBdWRpb1RyYWNrcykge1xuICAgIGNvbnN0IHIgPSAkZyh0KTtcbiAgICByZXR1cm4gTmcoZSwgciwgbmF2aWdhdG9yLm1lZGlhQ2FwYWJpbGl0aWVzKTtcbiAgfVxufVxuSHIuZGVmYXVsdENvbmZpZyA9IHZvaWQgMDtcbmNvbnN0IG9uID0gXCJodHRwczovL3Nkay1hcGkubmV5bmFyLmNvbVwiLCB3QSA9IFwiaHR0cHM6Ly9hcGkuYWxsb3JpZ2lucy53aW4vZ2V0XCIsIGJpID0gXCJodHRwczovL2kuaW1ndXIuY29tL2d4SDhhenkucG5nXCI7XG52YXIgQUEgPSB7XG4gIFNES19WRVJTSU9OOiAnXCIxLjIuMTVcIidcbn07XG5jb25zdCBJQSA9IEFBLlNES19WRVJTSU9OLCBhbiA9IGFzeW5jIChzLCBlID0ge30pID0+IChlLmhlYWRlcnMgPSB7XG4gIC4uLmUuaGVhZGVycyxcbiAgXCJ4LXNka1wiOiBcInJlYWN0XCIsXG4gIFwieC1zZGstdmVyc2lvblwiOiBJQVxufSwgZmV0Y2gocywgZSkpO1xuYXN5bmMgZnVuY3Rpb24gX0Eoe1xuICB0eXBlOiBzLFxuICBpZGVudGlmaWVyOiBlLFxuICB2aWV3ZXJGaWQ6IHQsXG4gIGNsaWVudF9pZDogclxufSkge1xuICB0cnkge1xuICAgIGxldCBuID0gYCR7b259L3YyL2ZhcmNhc3Rlci9jYXN0P3R5cGU9JHtzfSZpZGVudGlmaWVyPSR7ZX0ke3QgPyBgJnZpZXdlcl9maWQ9JHt0fWAgOiBcIlwifSZjbGllbnRfaWQ9JHtyfWA7XG4gICAgY29uc3QgbyA9IGF3YWl0IChhd2FpdCBhbihuKSkuanNvbigpO1xuICAgIHJldHVybiAobyA9PSBudWxsID8gdm9pZCAwIDogby5jYXN0KSB8fCBudWxsO1xuICB9IGNhdGNoIChuKSB7XG4gICAgcmV0dXJuIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBmZXRjaGluZyBjYXN0IGJ5IGlkZW50aWZpZXJcIiwgbiksIG51bGw7XG4gIH1cbn1cbmNvbnN0IFJBID0gKHtcbiAgdHlwZTogcyxcbiAgaWRlbnRpZmllcjogZSxcbiAgdmlld2VyRmlkOiB0LFxuICBhbGxvd1JlYWN0aW9uczogciA9ICExLFxuICByZW5kZXJFbWJlZHM6IG4gPSAhMCxcbiAgcmVuZGVyRnJhbWVzOiBpID0gITEsXG4gIG9uTGlrZUJ0blByZXNzOiBvLFxuICBvblJlY2FzdEJ0blByZXNzOiBhLFxuICBvbkNvbW1lbnRCdG5QcmVzczogbCxcbiAgb25GcmFtZUJ0blByZXNzOiBjLFxuICBjb250YWluZXJTdHlsZXM6IHUsXG4gIHRleHRTdHlsZXM6IGRcbn0pID0+IHtcbiAgdmFyIEY7XG4gIGNvbnN0IHtcbiAgICBjbGllbnRfaWQ6IGhcbiAgfSA9IHRzKCksIFtmLCBwXSA9IHN0LnVzZVN0YXRlKG51bGwpLCBbeSwgRV0gPSBzdC51c2VTdGF0ZSghMCksIFtiLCBSXSA9IHN0LnVzZVN0YXRlKG51bGwpLCBBID0gKGYgPT0gbnVsbCA/IHZvaWQgMCA6IGYuYXV0aG9yLmZpZCkgPT09IHQ7XG4gIHJldHVybiBzdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIHMgJiYgZSAmJiAoRSghMCksIFIobnVsbCksIF9BKHtcbiAgICAgIHR5cGU6IHMsXG4gICAgICBpZGVudGlmaWVyOiBlLFxuICAgICAgdmlld2VyRmlkOiB0LFxuICAgICAgY2xpZW50X2lkOiBoXG4gICAgfSkudGhlbigoTSkgPT4ge1xuICAgICAgcChNKTtcbiAgICB9KS5jYXRjaCgoTSkgPT4ge1xuICAgICAgUihNKTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIEUoITEpO1xuICAgIH0pKTtcbiAgfSwgW3MsIGUsIHQsIGhdKSwgeSA/IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChcImRpdlwiLCB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHBhZGRpbmc6IFwiMjBweFwiXG4gICAgfSxcbiAgICBjaGlsZHJlbjogXCJMb2FkaW5nLi4uXCJcbiAgfSkgOiAhZiB8fCBiID8gLyogQF9fUFVSRV9fICovIHEuanN4KFwiZGl2XCIsIHtcbiAgICBjaGlsZHJlbjogXCJFcnJvcjogY291bGQgbm90IGZldGNoIGNhc3QgZGF0YVwiXG4gIH0pIDogaSAmJiAhYyA/IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChcImRpdlwiLCB7XG4gICAgY2hpbGRyZW46IFwiRXJyb3I6IG9uRnJhbWVCdG5QcmVzcyBtdXN0IGJlIHByb3ZpZGVkIHdoZW4gcmVuZGVyRW1iZWRzIGlzIHRydWUuXCJcbiAgfSkgOiAvKiBAX19QVVJFX18gKi8gcS5qc3gob2EsIHtcbiAgICB1c2VybmFtZTogZi5hdXRob3IudXNlcm5hbWUsXG4gICAgZGlzcGxheU5hbWU6IGYuYXV0aG9yLmRpc3BsYXlfbmFtZSxcbiAgICBhdmF0YXJJbWdVcmw6IGYuYXV0aG9yLnBmcF91cmwsXG4gICAgdGV4dDogZi50ZXh0LFxuICAgIGhhc2g6IGYuaGFzaCxcbiAgICByZWFjdGlvbnM6IGYucmVhY3Rpb25zLFxuICAgIHJlcGxpZXM6IGYucmVwbGllcy5jb3VudCxcbiAgICBlbWJlZHM6IGYuZW1iZWRzID8/IFtdLFxuICAgIGZyYW1lczogZi5mcmFtZXMgPz8gW10sXG4gICAgcmVuZGVyRW1iZWRzOiBuLFxuICAgIHJlbmRlckZyYW1lczogaSxcbiAgICBjaGFubmVsOiBmLmNoYW5uZWwgPyB7XG4gICAgICBpZDogZi5jaGFubmVsLmlkLFxuICAgICAgbmFtZTogZi5jaGFubmVsLm5hbWUsXG4gICAgICB1cmw6IGYucGFyZW50X3VybFxuICAgIH0gOiB2b2lkIDAsXG4gICAgdmlld2VyRmlkOiB0LFxuICAgIGFsbG93UmVhY3Rpb25zOiByLFxuICAgIGhhc1Bvd2VyQmFkZ2U6IGYuYXV0aG9yLnBvd2VyX2JhZGdlLFxuICAgIGFwcEF2YXRhckltZ1VybDogKChGID0gZi5hcHApID09IG51bGwgPyB2b2lkIDAgOiBGLnBmcF91cmwpIHx8IG51bGwsXG4gICAgaXNPd25Qcm9maWxlOiBBLFxuICAgIGNvbnRhaW5lclN0eWxlczogdSxcbiAgICB0ZXh0U3R5bGVzOiBkLFxuICAgIG9uTGlrZUJ0blByZXNzOiBvLFxuICAgIG9uUmVjYXN0QnRuUHJlc3M6IGEsXG4gICAgb25Db21tZW50QnRuUHJlc3M6IGwsXG4gICAgb25GcmFtZUJ0blByZXNzOiBjLFxuICAgIHRpbWVzdGFtcDogZi50aW1lc3RhbXBcbiAgfSk7XG59LCBMQSA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImFcIikoe1xuICBjbGFzc2VzOiBbXCJzMXVvNGx4NFwiXVxufSksIFBsID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgaW8gPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpLCBmZiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCksIGdmID0gKHMpID0+IG5ldyBQcm9taXNlKChlKSA9PiBzZXRUaW1lb3V0KGUsIHMpKSwgUXAgPSBhc3luYyAocywgZSA9IDApID0+IHtcbiAgY29uc3QgdCA9IG5ldyBVUkwocykuaG9zdG5hbWU7XG4gIGlmIChmZi5nZXQodCkpXG4gICAgcmV0dXJuIHtcbiAgICAgIG9nSW1hZ2U6IFwiXCIsXG4gICAgICBvZ1RpdGxlOiBcIlwiLFxuICAgICAgb2dEZXNjcmlwdGlvbjogXCJcIlxuICAgIH07XG4gIGlmIChQbC5oYXMocykpXG4gICAgcmV0dXJuIFBsLmdldChzKTtcbiAgaWYgKGlvLmhhcyhzKSlcbiAgICByZXR1cm4gaW8uZ2V0KHMpO1xuICBjb25zdCByID0gKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZ2YoMTAwKTtcbiAgICAgIGNvbnN0IG4gPSBhd2FpdCBmZXRjaChgJHt3QX0/dXJsPSR7ZW5jb2RlVVJJQ29tcG9uZW50KHMpfWAsIHtcbiAgICAgICAgbWV0aG9kOiBcIkdFVFwiXG4gICAgICB9KTtcbiAgICAgIGlmICghbi5vaykge1xuICAgICAgICBpZiAobi5zdGF0dXMgPT09IDQyOSAmJiBlIDwgNSkge1xuICAgICAgICAgIGNvbnN0IEUgPSBNYXRoLnBvdygyLCBlKSAqIDFlMztcbiAgICAgICAgICByZXR1cm4gYXdhaXQgZ2YoRSksIFFwKHMsIGUgKyAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBmZi5zZXQodCwgITApLCBuZXcgRXJyb3IoYEZhaWxlZCB0byBmZXRjaCBPcGVuIEdyYXBoIGRhdGE6ICR7bi5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuICAgICAgY29uc3QgaSA9IGF3YWl0IG4uanNvbigpLCBhID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhpLmNvbnRlbnRzLCBcInRleHQvaHRtbFwiKSwgbCA9IGEucXVlcnlTZWxlY3RvcignbWV0YVtwcm9wZXJ0eT1cIm9nOmltYWdlXCJdJyksIGMgPSBhLnF1ZXJ5U2VsZWN0b3IoJ21ldGFbcHJvcGVydHk9XCJvZzp0aXRsZVwiXScpLCB1ID0gYS5xdWVyeVNlbGVjdG9yKCdtZXRhW3Byb3BlcnR5PVwib2c6ZGVzY3JpcHRpb25cIl0nKSwgZCA9IGEucXVlcnlTZWxlY3RvcihcInRpdGxlXCIpLCBoID0gbCAmJiBsLmdldEF0dHJpYnV0ZShcImNvbnRlbnRcIikgfHwgXCJcIiwgZiA9IGMgPyBjLmdldEF0dHJpYnV0ZShcImNvbnRlbnRcIikgfHwgXCJcIiA6IGQgPyBkLmlubmVyVGV4dCA6IFwiXCIsIHAgPSB1ICYmIHUuZ2V0QXR0cmlidXRlKFwiY29udGVudFwiKSB8fCBcIlwiLCB5ID0ge1xuICAgICAgICBvZ0ltYWdlOiBoLFxuICAgICAgICBvZ1RpdGxlOiBmLFxuICAgICAgICBvZ0Rlc2NyaXB0aW9uOiBwXG4gICAgICB9O1xuICAgICAgcmV0dXJuIFBsLnNldChzLCB5KSwgeTtcbiAgICB9IGNhdGNoIChuKSB7XG4gICAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIE9wZW4gR3JhcGggZGF0YVwiLCBuKSwge1xuICAgICAgICBvZ0ltYWdlOiBcIlwiLFxuICAgICAgICBvZ1RpdGxlOiBcIlwiLFxuICAgICAgICBvZ0Rlc2NyaXB0aW9uOiBcIlwiXG4gICAgICB9O1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpby5kZWxldGUocyk7XG4gICAgfVxuICB9KSgpO1xuICByZXR1cm4gaW8uc2V0KHMsIHIpLCByO1xufSwgQWMgPSBbXTtcbmxldCBNbCA9IDA7XG5jb25zdCBDQSA9IDUsIGtBID0gKHMpID0+IHtcbiAgQWMucHVzaChzKSwgZW0oKTtcbn0sIGVtID0gYXN5bmMgKCkgPT4ge1xuICBpZiAoTWwgPj0gQ0EgfHwgQWMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybjtcbiAgTWwrKztcbiAgY29uc3QgcyA9IEFjLnNoaWZ0KCk7XG4gIHMgJiYgYXdhaXQgcygpLCBNbC0tLCBlbSgpO1xufSwgREEgPSAoe1xuICBzcmM6IHMsXG4gIGFsdDogZSxcbiAgc3R5bGU6IHRcbn0pID0+IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChcImltZ1wiLCB7XG4gIHNyYzogcyxcbiAgYWx0OiBlLFxuICBzdHlsZToge1xuICAgIGRpc3BsYXk6IFwiYmxvY2tcIixcbiAgICBoZWlnaHQ6IFwiYXV0b1wiLFxuICAgIG1heEhlaWdodDogXCIxNTBweFwiLFxuICAgIHdpZHRoOiBcImF1dG9cIixcbiAgICBtYXhXaWR0aDogXCIxMDAlXCIsXG4gICAgb2JqZWN0Rml0OiBcImNvdmVyXCIsXG4gICAgYm9yZGVyOiBcIjFweCBzb2xpZCBncmV5XCIsXG4gICAgYm9yZGVyUmFkaXVzOiBcIjEwcHhcIixcbiAgICBtYXJnaW46IFwiNHB4IDBcIixcbiAgICAuLi50XG4gIH1cbn0pLCBQQSA9ICh7XG4gIHVybDogc1xufSkgPT4ge1xuICBjb25zdCBlID0gc3QudXNlUmVmKG51bGwpO1xuICByZXR1cm4gc3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZS5jdXJyZW50KVxuICAgICAgaWYgKEhyLmlzU3VwcG9ydGVkKCkgJiYgcy5lbmRzV2l0aChcIi5tM3U4XCIpKSB7XG4gICAgICAgIGNvbnN0IHQgPSBuZXcgSHIoKTtcbiAgICAgICAgdC5sb2FkU291cmNlKHMpLCB0LmF0dGFjaE1lZGlhKGUuY3VycmVudCksIHQub24oSHIuRXZlbnRzLk1BTklGRVNUX1BBUlNFRCwgKCkgPT4ge1xuICAgICAgICAgIGUuY3VycmVudC5wbGF5KCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlXG4gICAgICAgIGUuY3VycmVudC5zcmMgPSBzLCBlLmN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRlZG1ldGFkYXRhXCIsICgpID0+IHtcbiAgICAgICAgICBlLmN1cnJlbnQucGxheSgpO1xuICAgICAgICB9KTtcbiAgfSwgW3NdKSwgLyogQF9fUFVSRV9fICovIHEuanN4KFwidmlkZW9cIiwge1xuICAgIHJlZjogZSxcbiAgICBjb250cm9sczogITAsXG4gICAgbXV0ZWQ6ICEwLFxuICAgIHN0eWxlOiB7XG4gICAgICB3aWR0aDogXCJhdXRvXCIsXG4gICAgICBtYXhXaWR0aDogXCIxMDAlXCIsXG4gICAgICBtYXhIZWlnaHQ6IFwiNDAwcHhcIixcbiAgICAgIGJvcmRlclJhZGl1czogXCIxMHB4XCIsXG4gICAgICBtYXJnaW46IFwiMTBweCAwXCIsXG4gICAgICBvYmplY3RGaXQ6IFwiY29udGFpblwiXG4gICAgfVxuICB9KTtcbn0sIE1BID0gKHMpID0+IC9cXC4oanBlZ3xqcGd8Z2lmfHBuZ3x3ZWJwfGJtcHxzdmcpJC8udGVzdChzKSB8fCBzLnN0YXJ0c1dpdGgoXCJodHRwczovL2ltYWdlZGVsaXZlcnkubmV0XCIpLCBPQSA9IChzLCBlLCB0KSA9PiB7XG4gIGNvbnN0IFtyLCBuXSA9IHN0LnVzZVN0YXRlKFtdKSwgaSA9IHN0LnVzZUNhbGxiYWNrKGFzeW5jIChvKSA9PiAoYXdhaXQgUHJvbWlzZS5hbGwoby5tYXAoYXN5bmMgKGwpID0+IHtcbiAgICBpZiAobC51cmwpIHtcbiAgICAgIGNvbnN0IGMgPSBsLnVybDtcbiAgICAgIHJldHVybiBNQShjKSA/IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChEQSwge1xuICAgICAgICBzcmM6IGMsXG4gICAgICAgIGFsdDogXCJFbWJlZGRlZCBpbWFnZVwiXG4gICAgICB9LCBjKSA6IGMuZW5kc1dpdGgoXCIubTN1OFwiKSB8fCBjLmVuZHNXaXRoKFwiLm1wNFwiKSA/IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChQQSwge1xuICAgICAgICB1cmw6IGNcbiAgICAgIH0sIGMpIDogbmV3IFByb21pc2UoKHUpID0+IHtcbiAgICAgICAga0EoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIG9nSW1hZ2U6IGQsXG4gICAgICAgICAgICBvZ1RpdGxlOiBoXG4gICAgICAgICAgfSA9IGF3YWl0IFFwKGMpLCBmID0gbmV3IFVSTChjKS5ob3N0bmFtZS5yZXBsYWNlKFwid3d3LlwiLCBcIlwiKTtcbiAgICAgICAgICB1KC8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoTEEsIHtcbiAgICAgICAgICAgIGhyZWY6IGMsXG4gICAgICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgICAgICByZWw6IFwibm9yZWZlcnJlclwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFtkICYmIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChcImltZ1wiLCB7XG4gICAgICAgICAgICAgIHNyYzogZCxcbiAgICAgICAgICAgICAgYWx0OiBoLFxuICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBcIjUwcHhcIixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiNTBweFwiLFxuICAgICAgICAgICAgICAgIG9iamVjdEZpdDogXCJjb3ZlclwiLFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogXCI1cHhcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgLyogQF9fUFVSRV9fICovIHEuanN4cyhcImRpdlwiLCB7XG4gICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgICAgZmxleERpcmVjdGlvbjogXCJjb2x1bW5cIlxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBxLmpzeChcInBcIiwge1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICBtYXJnaW46IDBcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBoIHx8IGNcbiAgICAgICAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChcInBcIiwge1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICBtYXJnaW46IDAsXG4gICAgICAgICAgICAgICAgICBjb2xvcjogXCJncmV5XCIsXG4gICAgICAgICAgICAgICAgICBmb250U2l6ZTogXCIxMnB4XCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBmXG4gICAgICAgICAgICAgIH0pXVxuICAgICAgICAgICAgfSldXG4gICAgICAgICAgfSwgYykpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobC5jYXN0X2lkKVxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChcImRpdlwiLCB7XG4gICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgbWF4V2lkdGg6IFwiODUlXCJcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChSQSwge1xuICAgICAgICAgIHR5cGU6IFwiaGFzaFwiLFxuICAgICAgICAgIGlkZW50aWZpZXI6IGwuY2FzdF9pZC5oYXNoLFxuICAgICAgICAgIHZpZXdlckZpZDogdCxcbiAgICAgICAgICBhbGxvd1JlYWN0aW9uczogZSxcbiAgICAgICAgICByZW5kZXJFbWJlZHM6ICExXG4gICAgICAgIH0sIGwuY2FzdF9pZC5maWQpXG4gICAgICB9LCBgY2FzdC0ke2wuY2FzdF9pZC5oYXNofWApO1xuICAgIHJldHVybiBudWxsO1xuICB9KSkpLmZpbHRlcigobCkgPT4gbCAhPT0gbnVsbCksIFtlLCB0XSk7XG4gIHJldHVybiBzdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGkocykudGhlbihuKTtcbiAgfSwgW3MsIGldKSwgcjtcbn0sIHRtID0gKHtcbiAgb25DbGljazogc1xufSkgPT4gLyogQF9fUFVSRV9fICovIHEuanN4KFwic3ZnXCIsIHtcbiAgd2lkdGg6IFwiMThcIixcbiAgaGVpZ2h0OiBcIjE3XCIsXG4gIHZpZXdCb3g6IFwiMCAwIDE4IDE3XCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICBvbkNsaWNrOiAoZSkgPT4gcyA/IHMoZSkgOiB2b2lkIDAsXG4gIHN0eWxlOiB7XG4gICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICB9LFxuICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHEuanN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNNi4yMjg1NyAxMi42ODI4SDcuMDEyODVDNy4wMTI4NSAxMi4yNDk2IDYuNjYxNzIgMTEuODk4NSA2LjIyODU3IDExLjg5ODVWMTIuNjgyOFpNNi4yMjg1NyAxNS44MTk5SDUuNDQ0M0M1LjQ0NDMgMTYuMTEzNyA1LjYwODQ4IDE2LjM4MjggNS44Njk3IDE2LjUxNzJDNi4xMzA5MiAxNi42NTE3IDYuNDQ1MzcgMTYuNjI4OCA2LjY4NDQzIDE2LjQ1ODFMNi4yMjg1NyAxNS44MTk5Wk0xMC42MjA1IDEyLjY4MjhWMTEuODk4NUMxMC40NTcxIDExLjg5ODUgMTAuMjk3NyAxMS45NDk2IDEwLjE2NDcgMTIuMDQ0NkwxMC42MjA1IDEyLjY4MjhaTTEuNzg0MjggMy4yNzE0NkMxLjc4NDI4IDIuNTQ5NTUgMi4zNjk1IDEuOTY0MzMgMy4wOTE0MSAxLjk2NDMzVjAuMzk1Nzc3QzEuNTAzMjEgMC4zOTU3NzcgMC4yMTU3MjMgMS42ODMyNyAwLjIxNTcyMyAzLjI3MTQ2SDEuNzg0MjhaTTEuNzg0MjggMTAuNTkxNFYzLjI3MTQ2SDAuMjE1NzIzVjEwLjU5MTRIMS43ODQyOFpNMy4wOTE0IDExLjg5ODVDMi4zNjk1IDExLjg5ODUgMS43ODQyOCAxMS4zMTMzIDEuNzg0MjggMTAuNTkxNEgwLjIxNTcyM0MwLjIxNTcyMyAxMi4xNzk2IDEuNTAzMjEgMTMuNDY3MSAzLjA5MTQgMTMuNDY3MVYxMS44OTg1Wk02LjIyODU3IDExLjg5ODVIMy4wOTE0VjEzLjQ2NzFINi4yMjg1N1YxMS44OTg1Wk03LjAxMjg1IDE1LjgxOTlWMTIuNjgyOEg1LjQ0NDNWMTUuODE5OUg3LjAxMjg1Wk0xMC4xNjQ3IDEyLjA0NDZMNS43NzI3MiAxNS4xODE3TDYuNjg0NDMgMTYuNDU4MUwxMS4wNzY0IDEzLjMyMUwxMC4xNjQ3IDEyLjA0NDZaTTE0LjU5NDEgMTEuODk4NUgxMC42MjA1VjEzLjQ2NzFIMTQuNTk0MVYxMS44OTg1Wk0xNS45MDEzIDEwLjU5MTRDMTUuOTAxMyAxMS4zMTMzIDE1LjMxNiAxMS44OTg1IDE0LjU5NDEgMTEuODk4NVYxMy40NjcxQzE2LjE4MjMgMTMuNDY3MSAxNy40Njk4IDEyLjE3OTYgMTcuNDY5OCAxMC41OTE0SDE1LjkwMTNaTTE1LjkwMTMgMy4yNzE0NlYxMC41OTE0SDE3LjQ2OThWMy4yNzE0NkgxNS45MDEzWk0xNC41OTQxIDEuOTY0MzNDMTUuMzE2IDEuOTY0MzMgMTUuOTAxMyAyLjU0OTU1IDE1LjkwMTMgMy4yNzE0NkgxNy40Njk4QzE3LjQ2OTggMS42ODMyNiAxNi4xODIzIDAuMzk1Nzc3IDE0LjU5NDEgMC4zOTU3NzdWMS45NjQzM1pNMy4wOTE0MSAxLjk2NDMzSDE0LjU5NDFWMC4zOTU3NzdIMy4wOTE0MVYxLjk2NDMzWlwiLFxuICAgIGZpbGw6IFwiI0EwQTNBRFwiXG4gIH0pXG59KSwgQkEgPSAoe1xuICBmaWxsOiBzLFxuICBvbkNsaWNrOiBlXG59KSA9PiAvKiBAX19QVVJFX18gKi8gcS5qc3hzKFwic3ZnXCIsIHtcbiAgd2lkdGg6IFwiMTZcIixcbiAgaGVpZ2h0OiBcIjE1XCIsXG4gIHZpZXdCb3g6IFwiMCAwIDE2IDE1XCIsXG4gIGZpbGw6IHMgfHwgXCJub25lXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIG9uQ2xpY2s6ICh0KSA9PiBlID8gZSh0KSA6IHZvaWQgMCxcbiAgc3R5bGU6IHtcbiAgICBjdXJzb3I6IFwicG9pbnRlclwiXG4gIH0sXG4gIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIHEuanN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNMTQuOTI0NSAxNC4yNTA2QzE0LjcyNTggMTQuMjUwNiAxNC41MzUyIDE0LjE3MTYgMTQuMzk0NiAxNC4wMzExQzE0LjI1NDEgMTMuODkwNSAxNC4xNzUxIDEzLjY5OTkgMTQuMTc1MSAxMy41MDExVjEwLjUwMzRIMTEuMTc3NEMxMC45Nzg3IDEwLjUwMzQgMTAuNzg4MSAxMC40MjQ1IDEwLjY0NzUgMTAuMjgzOUMxMC41MDcgMTAuMTQzNCAxMC40MjggOS45NTI3OSAxMC40MjggOS43NTQwM0MxMC40MjggOS41NTUyNyAxMC41MDcgOS4zNjQ2NSAxMC42NDc1IDkuMjI0MTFDMTAuNzg4MSA5LjA4MzU3IDEwLjk3ODcgOS4wMDQ2MSAxMS4xNzc0IDkuMDA0NjFIMTQuOTI0NUMxNS4xMjMzIDkuMDA0NjEgMTUuMzEzOSA5LjA4MzU3IDE1LjQ1NDUgOS4yMjQxMUMxNS41OTUgOS4zNjQ2NSAxNS42NzQgOS41NTUyNyAxNS42NzQgOS43NTQwM1YxMy41MDExQzE1LjY3NCAxMy42OTk5IDE1LjU5NSAxMy44OTA1IDE1LjQ1NDUgMTQuMDMxMUMxNS4zMTM5IDE0LjE3MTYgMTUuMTIzMyAxNC4yNTA2IDE0LjkyNDUgMTQuMjUwNlpNNS4xODIwNyA2LjAwNjkzSDEuNDM0OTdDMS4yMzYyMSA2LjAwNjkzIDEuMDQ1NTkgNS45Mjc5NyAwLjkwNTA0NyA1Ljc4NzQzQzAuNzY0NTAzIDUuNjQ2ODggMC42ODU1NDcgNS40NTYyNyAwLjY4NTU0NyA1LjI1NzUxVjEuNTEwNDFDMC42ODU1NDcgMS4zMTE2NSAwLjc2NDUwMyAxLjEyMTAzIDAuOTA1MDQ3IDAuOTgwNDg2QzEuMDQ1NTkgMC44Mzk5NDMgMS4yMzYyMSAwLjc2MDk4NiAxLjQzNDk3IDAuNzYwOTg2QzEuNjMzNzMgMC43NjA5ODYgMS44MjQzNCAwLjgzOTk0MyAxLjk2NDg5IDAuOTgwNDg2QzIuMTA1NDMgMS4xMjEwMyAyLjE4NDM5IDEuMzExNjUgMi4xODQzOSAxLjUxMDQxVjQuNTA4MDlINS4xODIwN0M1LjM4MDgzIDQuNTA4MDkgNS41NzE0NSA0LjU4NzA0IDUuNzExOTkgNC43Mjc1OUM1Ljg1MjUzIDQuODY4MTMgNS45MzE0OSA1LjA1ODc1IDUuOTMxNDkgNS4yNTc1MUM1LjkzMTQ5IDUuNDU2MjcgNS44NTI1MyA1LjY0Njg4IDUuNzExOTkgNS43ODc0M0M1LjU3MTQ1IDUuOTI3OTcgNS4zODA4MyA2LjAwNjkzIDUuMTgyMDcgNi4wMDY5M1pcIixcbiAgICBmaWxsOiBzIHx8IFwiI0EwQTNBRFwiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gcS5qc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk04LjE3OTM0IDE1QzYuMzM1NTYgMTUuMDAwMyA0LjU1NjM3IDE0LjMyMDkgMy4xODIwNSAxMy4wOTE4QzEuODA3NzQgMTEuODYyNyAwLjkzNDc2NiAxMC4xNyAwLjczMDEwNiA4LjMzNzY1QzAuNzE5MjgxIDguMjM5MjMgMC43Mjc5NDUgOC4xMzk2NSAwLjc1NTYwNiA4LjA0NDU4QzAuNzgzMjY2IDcuOTQ5NTEgMC44MjkzOCA3Ljg2MDgzIDAuODkxMzE1IDcuNzgzNThDMS4wMTY0IDcuNjI3NTggMS4xOTgzMyA3LjUyNzY1IDEuMzk3MDkgNy41MDU3OUMxLjU5NTg1IDcuNDgzOTMgMS43OTUxNSA3LjU0MTkxIDEuOTUxMTYgNy42NjdDMi4xMDcxNiA3Ljc5MjA4IDIuMjA3MDggNy45NzQwMSAyLjIyODk1IDguMTcyNzdDMi4zNzcwOCA5LjUyMzc2IDIuOTc5ODMgMTAuNzg0MyAzLjkzODM4IDExLjc0NzhDNC44OTY5MiAxMi43MTEzIDYuMTU0MzggMTMuMzIwNSA3LjUwNDU5IDEzLjQ3NTVDOC44NTQ3OSAxMy42MzA2IDEwLjIxNzYgMTMuMzIyMyAxMS4zNjk2IDEyLjYwMTJDMTIuNTIxNiAxMS44ODAxIDEzLjM5NDQgMTAuNzg5IDEzLjg0NSA5LjUwNjc0QzEzLjg3MzEgOS40MDgxNyAxMy45MjExIDkuMzE2NDIgMTMuOTg2IDkuMjM3MTRDMTQuMDUxIDkuMTU3ODcgMTQuMTMxNiA5LjA5Mjc3IDE0LjIyMjcgOS4wNDU4NkMxNC4zMTM4IDguOTk4OTUgMTQuNDEzNiA4Ljk3MTIzIDE0LjUxNTkgOC45NjQ0MkMxNC42MTgxIDguOTU3NjEgMTQuNzIwNyA4Ljk3MTg1IDE0LjgxNzMgOS4wMDYyNUMxNC45MTM4IDkuMDQwNjYgMTUuMDAyMyA5LjA5NDUxIDE1LjA3NzIgOS4xNjQ0NkMxNS4xNTIxIDkuMjM0NDIgMTUuMjExOCA5LjMxODk5IDE1LjI1MjggOS40MTI5NkMxNS4yOTM3IDkuNTA2OTMgMTUuMzE0OSA5LjYwODMgMTUuMzE1MSA5LjcxMDc5QzE1LjMxNTMgOS44MTMyOSAxNS4yOTQ0IDkuOTE0NzMgMTUuMjUzOSAxMC4wMDg5QzE0LjczNTkgMTEuNDcwNSAxMy43Nzc0IDEyLjczNTUgMTIuNTEwMyAxMy42Mjk0QzExLjI0MzIgMTQuNTIzMyA5LjczMDAyIDE1LjAwMjIgOC4xNzkzNCAxNVpNMTQuODc5MiA3LjUwNTc5QzE0LjY5MzkgNy41MDY5MSAxNC41MTQ4IDcuNDM5MzcgMTQuMzc2NCA3LjMxNjJDMTQuMjM4IDcuMTkzMDIgMTQuMTUwMSA3LjAyMjk1IDE0LjEyOTcgNi44Mzg4QzEzLjk3NSA1LjQ5NDI5IDEzLjM2OTkgNC4yNDE2OSAxMi40MTI4IDMuMjg0NzZDMTEuNDU1OCAyLjMyNzgyIDEwLjIwMzEgMS43MjI4NSA4Ljg1ODU4IDEuNTY4MjRDNy41MTQwNSAxLjQxMzY0IDYuMTU2NzYgMS43MTg1IDUuMDA3NSAyLjQzMzI0QzMuODU4MjMgMy4xNDc5OCAyLjk4NDYgNC4yMzA1NCAyLjUyODcyIDUuNTA0ODRDMi41MDA2MiA1LjYwMzQgMi40NTI2IDUuNjk1MTYgMi4zODc2MyA1Ljc3NDQzQzIuMzIyNjYgNS44NTM3MSAyLjI0MjEyIDUuOTE4ODEgMi4xNTA5OSA1Ljk2NTcyQzIuMDU5ODcgNi4wMTI2MyAxLjk2MDA4IDYuMDQwMzUgMS44NTc4MSA2LjA0NzE2QzEuNzU1NTUgNi4wNTM5NyAxLjY1Mjk3IDYuMDM5NzMgMS41NTY0MiA2LjAwNTMyQzEuNDU5ODggNS45NzA5MiAxLjM3MTQxIDUuOTE3MDcgMS4yOTY1MSA1Ljg0NzEyQzEuMjIxNiA1Ljc3NzE2IDEuMTYxODMgNS42OTI1OCAxLjEyMDkxIDUuNTk4NjFDMS4wNzk5OSA1LjUwNDY0IDEuMDU4NzggNS40MDMyOCAxLjA1ODU5IDUuMzAwNzhDMS4wNTg0IDUuMTk4MjkgMS4wNzkyMyA1LjA5Njg1IDEuMTE5OCA1LjAwMjczQzEuNjg0MDYgMy40MDIwMiAyLjc3NDk3IDIuMDQwMjUgNC4yMTM5NyAxLjE0MDI5QzUuNjUyOTcgMC4yNDAzMzcgNy4zNTQ4NSAtMC4xNDQ1MDUgOS4wNDEwNiAwLjA0ODc1MjJDMTAuNzI3MyAwLjI0MjAwOSAxMi4yOTc5IDEuMDAxOTIgMTMuNDk2IDIuMjA0MTFDMTQuNjk0MSAzLjQwNjMgMTUuNDQ4NiA0Ljk3OTU4IDE1LjYzNjEgNi42NjY0NEMxNS42NTcxIDYuODYzMDYgMTUuNTk5NyA3LjA2MDA0IDE1LjQ3NjEgNy4yMTQ0NUMxNS4zNTI2IDcuMzY4ODcgMTUuMTczIDcuNDY4MiAxNC45NzY2IDcuNDkwOEwxNC44NzkyIDcuNTA1NzlaXCIsXG4gICAgZmlsbDogcyB8fCBcIiNBMEEzQURcIlxuICB9KV1cbn0pLCBybSA9ICh7XG4gIGZpbGw6IHMsXG4gIG9uQ2xpY2s6IGVcbn0pID0+IC8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoXCJzdmdcIiwge1xuICB3aWR0aDogXCIxN1wiLFxuICBoZWlnaHQ6IFwiMTVcIixcbiAgdmlld0JveDogXCIwIDAgMTcgMTVcIixcbiAgZmlsbDogcyA/IFwicmVkXCIgOiBcIm5vbmVcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgb25DbGljazogKHQpID0+IGUgPyBlKHQpIDogdm9pZCAwLFxuICBzdHlsZToge1xuICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgfSxcbiAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0xMy44NzE5IDIuMjUwNDJMMTQuMjk0NyAxLjU4OTg0TDEzLjg3MTkgMi4yNTA0MkMxNS4yNDY3IDMuMTMwMjIgMTUuNzY3NiA1LjIyMjA2IDE0Ljg4NTYgNy42MTMxN0MxNC4wNDM2IDkuODk1ODMgMTEuOTU1NSAxMi4yMzc0IDguNTE1NzMgMTMuMzY0OEM1LjA3NjA2IDEyLjIzNzQgMi45ODc5OSA5Ljg5NTg0IDIuMTQ1OTYgNy42MTMxNkMxLjI2MzkyIDUuMjIyMDMgMS43ODQ4IDMuMTMwMjIgMy4xNTk1MSAyLjI1MDQyTDMuMTU5NTEgMi4yNTA0MkM0LjU4NTQyIDEuMzM3ODMgNS42NDk5NyAxLjUyOTgzIDYuMzk5NDUgMS45MjUwM0M3LjIxMjcyIDIuMzUzODggNy43MzEwOCAzLjA3MTE0IDcuODYxNDMgMy4yNjgzOEw4LjUxNTczIDQuMjU4MzhMOS4xNzAwMiAzLjI2ODM4QzkuMzAwMzggMy4wNzExMyA5LjgxODczIDIuMzUzODggMTAuNjMyIDEuOTI1MDNDMTEuMzgxNSAxLjUyOTgzIDEyLjQ0NiAxLjMzNzgzIDEzLjg3MTkgMi4yNTA0MlpcIixcbiAgICBzdHJva2U6IHMgfHwgXCIjQTBBM0FEXCIsXG4gICAgc3Ryb2tlV2lkdGg6IFwiMS41Njg1NVwiXG4gIH0pLCAvKiBAX19QVVJFX18gKi8gcS5qc3goXCJtYXNrXCIsIHtcbiAgICBpZDogXCJwYXRoLTItaW5zaWRlLTFfMTg3XzEwNTFcIixcbiAgICBmaWxsOiBcIndoaXRlXCIsXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChcInBhdGhcIiwge1xuICAgICAgZDogXCJNOC41ODQ0NCAxMy45Mzk3QzcuNzYxMzkgMTMuNjg2NCA3LjA1MzM0IDEzLjM5MzcgNi4yOTk3NiAxMi45ODI1QzUuOTU2MzMgMTIuNzk1MSA1LjYyMjg1IDEyLjU4OTUgNS4zMDAzIDEyLjM2ODFDNS4xNDQxNiAxMi4yNjA5IDQuOTkxMDggMTIuMTQ5MyA0Ljg0MDYzIDEyLjAzNDNDNC43ODEzMiAxMS45ODg5IDQuODgwMzggMTIuMDY1MiA0LjgyMTU2IDEyLjAxOTVDNC44MDM4OCAxMi4wMDU4IDQuNzg2MyAxMS45OTE5IDQuNzY4NjkgMTEuOTc4MUM0LjczMzY0IDExLjk1MDUgNC42OTg4NCAxMS45MjI1IDQuNjY0MTMgMTEuODk0NUM0LjU4OTQ4IDExLjgzNDIgNC41MTU4MiAxMS43NzI3IDQuNDQyOCAxMS43MTA1QzMuOTA0OTkgMTEuMjUyIDMuNDEzODEgMTAuNzM4OSAyLjk4MDE2IDEwLjE4MDlDMy4wMTg1NiAxMC4yMzAzIDIuOTc2NTEgMTAuMTc2IDIuOTcwNjQgMTAuMTY4M0MyLjk1ODMgMTAuMTUyMiAyLjk0NjA0IDEwLjEzNTkgMi45MzM4IDEwLjExOTdDMi45MDkzOSAxMC4wODc0IDIuODg1MjcgMTAuMDU0OCAyLjg2MTI2IDEwLjAyMjFDMi44MDk2MSA5Ljk1MTg5IDIuNzU5MDggOS44ODA4IDIuNzA5MzIgOS44MDkyQzIuNjE0OTIgOS42NzM0NSAyLjUyNDQxIDkuNTM1IDIuNDM3MSA5LjM5NDU3QzIuMjY3MyA5LjEyMTQ1IDIuMTEyMTMgOC44MzkyNiAxLjk3MTQ3IDguNTUwMDZDMS45Mzg0OSA4LjQ4MjI4IDEuOTA2NTcgOC40MTM5NiAxLjg3NTMxIDguMzQ1MzdDMS44NTk3OCA4LjMxMTMgMS44NDQ1OSA4LjI3NzA5IDEuODI5NDggOC4yNDI4NEMxLjgyMTk1IDguMjI1NzUgMS44MTQ1NiA4LjIwODY0IDEuODA3MTQgOC4xOTE1MkMxLjgwMTY3IDguMTc4ODkgMS43Njg1NiA4LjEwMDYxIDEuNzk2NjQgOC4xNjczNkMxLjczNzI4IDguMDI2MiAxLjY4MjA1IDcuODgzMjkgMS42MzAyOSA3LjczOTE2QzEuNTI5ODIgNy40NTk0MiAxLjQ0NDk4IDcuMTc0MDcgMS4zNzU3NSA2Ljg4NTAyQzEuMzQyMTggNi43NDQ5MiAxLjMxMzAxIDYuNjAzNzkgMS4yODc0NiA2LjQ2MjAyQzEuMjc1NCA2LjM5NTAyIDEuMjY0NSA2LjMyNzgyIDEuMjU0MyA2LjI2MDUyQzEuMjQ5MjUgNi4yMjcxMyAxLjI0NDUzIDYuMTkzNjkgMS4yMzk5NCA2LjE2MDIzQzEuMjUxMzYgNi4yNDM1OCAxLjIzNDk1IDYuMTE3NzIgMS4yMzIzMSA2LjA5NTMyQzEuMjAwNDIgNS44MjQ0NCAxLjE4NTM1IDUuNTUxNTggMS4xODcyMSA1LjI3ODg1QzEuMTg4MTEgNS4xNDY5MSAxLjE5Mzc0IDUuMDE1MDEgMS4yMDMzNCA0Ljg4MzQzQzEuMjA3ODggNC44MjEyOCAxLjIxMzY4IDQuNzU5MjIgMS4yMjAyMyA0LjY5NzI2QzEuMjIzNSA0LjY2NjUxIDEuMjI3MTMgNC42MzU4IDEuMjMwODkgNC42MDUxMUMxLjIzMjc4IDQuNTg5ODIgMS4yMzQ3NyA0LjU3NDU3IDEuMjM2NzggNC41NTkzQzEuMjI1NjIgNC42NDQyNSAxLjIzNTYzIDQuNTY5NTYgMS4yMzgyMyA0LjU1MTYzQzEuMjc0MjggNC4zMDQxOSAxLjMyODYxIDQuMDU5NDMgMS40MDA5NyAzLjgyMDA2QzEuNDM2MTQgMy43MDM3NSAxLjQ3NjM1IDMuNTg4OTkgMS41MjA3MiAzLjQ3NTg3QzEuNTMxMjUgMy40NDkgMS41NDIxOSAzLjQyMjI5IDEuNTUzMjYgMy4zOTU2NEMxLjUxOTQxIDMuNDc3MTYgMS41NTg4OSAzLjM4MzM0IDEuNTY3MTcgMy4zNjQ2NEMxLjU5MjI2IDMuMzA4MDMgMS42MTg4NiAzLjI1MjA5IDEuNjQ2NDMgMy4xOTY2NEMxLjc1MTAxIDIuOTg2MjQgMS44NzQ3NiAyLjc4NTQ5IDIuMDE1MzQgMi41OTcyNEMyLjAyMzcxIDIuNTg2MDMgMi4wMzIyMSAyLjU3NDkyIDIuMDQwNzEgMi41NjM4QzEuOTkyNzUgMi42MjY1NiAyLjAyNDQ2IDIuNTg0OTYgMi4wMzQ5MyAyLjU3MTY5QzIuMDUyMjMgMi41NDk3NCAyLjA2OTkzIDIuNTI4MDggMi4wODc3MyAyLjUwNjUzQzIuMTI2MzEgMi40NTk4NCAyLjE2NjI5IDIuNDE0MzQgMi4yMDcxMyAyLjM2OTYyQzIuMjg1ODcgMi4yODM0MSAyLjM2OTI2IDIuMjAxNTEgMi40NTYgMi4xMjMzOUMyLjQ5Nzg3IDIuMDg1NjggMi41NDA4NCAyLjA0OTIgMi41ODQ0MyAyLjAxMzUyQzIuNjA2MzEgMS45OTU2MSAyLjYyODUyIDEuOTc4MDggMi42NTA4NCAxLjk2MDdDMi41ODE2NCAyLjAxNDY2IDIuNjcxOTEgMS45NDU1NyAyLjY4OTYyIDEuOTMyNjVDMi44MzMzOCAxLjgyNzcgMi45ODU4NyAxLjczNDggMy4xNDAxMyAxLjY0NjNDMy41NDM5MyAxLjQxNDU5IDMuOTI0MzcgMS4yNTU2NyA0LjM4MzEgMS4xNTA3MkM0LjQ3NzE2IDEuMTI5MjEgNC41NzIxOSAxLjExMjA0IDQuNjY3NiAxLjA5NzcxQzQuNzQ0ODMgMS4wODYxMSA0LjYxNTI3IDEuMTAzOTkgNC42OTIxNyAxLjA5NDQ0QzQuNzE1MTMgMS4wOTE2IDQuNzM4MTcgMS4wODkxNyA0Ljc2MTE5IDEuMDg2NzdDNC44MTQwMyAxLjA4MTI0IDQuODY3MDQgMS4wNzczOSA0LjkyMDA3IDEuMDc0MjNDNS4xMDA4NCAxLjA2MzQ4IDUuMjgyMzcgMS4wNjg1MSA1LjQ2MjUyIDEuMDg2NEM1LjQ4MzM2IDEuMDg4NDYgNS41MDQxNyAxLjA5MDkyIDUuNTI0OTUgMS4wOTMzOEM1LjU5NTA4IDEuMTAxNjcgNS40Njk0MyAxLjA4NTI2IDUuNTM4OTkgMS4wOTUyMUM1LjU3OTY1IDEuMTAxMDMgNS42MjAxNiAxLjEwNzk1IDUuNjYwNTkgMS4xMTUyNEM1Ljc0NjQ3IDEuMTMwNzMgNS44MzE1OSAxLjE1MDMgNS45MTYwNCAxLjE3MjI3QzYuMDcyOCAxLjIxMzExIDYuMjI2MjEgMS4yNjYyMSA2LjM3NTk1IDEuMzI3ODZDNi4zMTExMSAxLjMwMTE1IDYuNDE4NzcgMS4zNDcwMiA2LjQzNTg0IDEuMzU0NzdDNi40Njk4NyAxLjM3MDIgNi41MDM1NiAxLjM4NjM5IDYuNTM3MTQgMS40MDI4QzYuNjA4NjUgMS40Mzc3OSA2LjY3ODg2IDEuNDc1NDMgNi43NDgxNyAxLjUxNDYyQzYuODc2NjIgMS41ODcyMyA3LjAwMDYyIDEuNjY3NTMgNy4xMjA5MiAxLjc1MjlDNy4xNDg4MiAxLjc3MjcxIDcuMTc2MzcgMS43OTI5NyA3LjIwMzgzIDEuODEzMzhDNy4yMTczOSAxLjgyMzQ4IDcuMjMwODcgMS44MzM3IDcuMjQ0MzIgMS44NDM5NkM3LjI5MTU4IDEuODc5OTIgNy4xOTg4IDEuODA4MzkgNy4yNDUyOSAxLjg0NDgyQzcuMzAxMDkgMS44ODg1MyA3LjM1NTY4IDEuOTMzNzUgNy40MDk0OSAxLjk3OTgyQzcuNTA2NTIgMi4wNjI4OCA3LjU5OTk0IDIuMTUwMDggNy42OTA1MyAyLjI0MDExQzcuODQwMDggMi4zODg3OSA3Ljk4MDQ0IDIuNTQ2NzcgOC4xMTE0OSAyLjcxMTk0QzguMTI1NzIgMi43Mjk4NyA4LjE3NTMzIDIuNzk0MTQgOC4xMTQ4NSAyLjcxNTdDOC4xMjYzNiAyLjczMDY1IDguMTM3NzYgMi43NDU2OCA4LjE0OTEgMi43NjA3NUM4LjE2OTQgMi43ODc2OSA4LjE4OTM0IDIuODE0OTEgOC4yMDkwNSAyLjg0MjNDOC4yMzgyNSAyLjg4Mjg2IDguMjY2NyAyLjkyMzk4IDguMjk0MjkgMi45NjU2NkM4LjQwMzc0IDMuMTMxIDguNjI4NiAzLjEzMSA4LjczODA1IDIuOTY1NjZDOC43NjcwNyAyLjkyMTgxIDguNzk3MTIgMi44Nzg2NiA4LjgyNzg1IDIuODM1OThDOC44NDc4MyAyLjgwODIzIDguODY4MTkgMi43ODA3NSA4Ljg4ODc1IDIuNzUzNDRDOC45MDI0MiAyLjczNTI5IDguOTQ5MjggMi42NzQ3NCA4Ljg4OTM1IDIuNzUyMTRDOC45MDQwOSAyLjczMzEyIDguOTE5IDIuNzE0MjQgOC45MzM5OSAyLjY5NTQyQzkuMDY3MSAyLjUyODM0IDkuMjEwNzEgMi4zNjk2OCA5LjM2MjYxIDIuMjE5NTRDOS40NTQxMSAyLjEyOTA3IDkuNTQ5MyAyLjA0MjM0IDkuNjQ3MzIgMS45NTg5N0M5LjY5NzM3IDEuOTE2NDEgOS43NDg0NyAxLjg3NTA3IDkuODAwMTcgMS44MzQ1NkM5LjczODggMS44ODI2MyA5LjgyNjk0IDEuODE0NTcgOS44NDIxMyAxLjgwMzI3QzkuODc0MjcgMS43NzkzNyA5LjkwNjgzIDEuNzU2MDYgOS45Mzk2IDEuNzMzMDFDMTAuMDYwOCAxLjY0NzczIDEwLjE4NjYgMS41NjkxNSAxMC4zMTU5IDEuNDk2ODJDMTAuMzgwMiAxLjQ2MDg0IDEwLjQ0NTcgMS40MjcwMyAxMC41MTE5IDEuMzk0NjdDMTAuNTQ1NSAxLjM3ODIzIDEwLjU3OTUgMS4zNjI1MSAxMC42MTM2IDEuMzQ3MDRDMTAuNjMwOCAxLjMzOTI2IDEwLjY0ODEgMS4zMzE3MSAxMC42NjU0IDEuMzI0MTdDMTAuNjkxNSAxLjMxMjk2IDEwLjY4ODUgMS4zMTQyIDEwLjY1NjQgMS4zMjc5QzEwLjY2ODEgMS4zMjMwMyAxMC42Nzk4IDEuMzE4MjIgMTAuNjkxNiAxLjMxMzQ5QzEwLjg0MjMgMS4yNTIzNSAxMC45OTczIDEuMjAyNDYgMTEuMTU0OCAxLjE2MjM5QzExLjIzMzIgMS4xNDI0OCAxMS4zMTIzIDEuMTI1OTkgMTEuMzkxOCAxLjExMTY2QzExLjQzMjMgMS4xMDQzNSAxMS40NzMgMS4wOTgxNSAxMS41MTM4IDEuMDkyMzFDMTEuNDQ3MSAxLjEwMTg2IDExLjUxNzEgMS4wOTIyNiAxMS41MjgxIDEuMDkwOTVDMTEuNTU1OSAxLjA4NzY3IDExLjU4MzggMS4wODQ5OSAxMS42MTE3IDEuMDgyNEMxMS43OTMgMS4wNjU1MyAxMS45NzU3IDEuMDY1MTMgMTIuMTU3MyAxLjA3NzFDMTIuMjAzIDEuMDgwMTEgMTIuMjQ4NSAxLjA4NDQ0IDEyLjI5NCAxLjA4OTIxQzEyLjMxNzIgMS4wOTE2MyAxMi4zNDAyIDEuMDk0NSAxMi4zNjMzIDEuMDk3MzRDMTIuMzAzNiAxLjA4OTk0IDEyLjM4MTMgMS4xMDAyMiAxMi4zODgxIDEuMTAxMjNDMTIuNDkyMSAxLjExNjg1IDEyLjU5NTIgMS4xMzc4NSAxMi42OTc1IDEuMTYxOTNDMTMuMTU4NiAxLjI3MDQ4IDEzLjUzNzggMS40NDAzNyAxMy45NDY0IDEuNjc3NjFDMTQuMDkwNCAxLjc2MTI5IDE0LjIzMTQgMS44NTA3IDE0LjM2NTYgMS45NDk1QzE0LjM3NyAxLjk1NzkxIDE0LjM4ODQgMS45NjY0OCAxNC4zOTk3IDEuOTc1MDNDMTQuNDQxOSAyLjAwNjg4IDE0LjM1MSAxLjkzNjk2IDE0LjM5MjYgMS45Njk0NUMxNC40MTQ5IDEuOTg2ODMgMTQuNDM2OSAyLjAwNDYyIDE0LjQ1ODggMi4wMjI1MkMxNC41MDU5IDIuMDYxMTUgMTQuNTUxOSAyLjEwMTMgMTQuNTk3MSAyLjE0MjI4QzE0LjY4MzUgMi4yMjA3MyAxNC43NjU2IDIuMzAzODggMTQuODQzOSAyLjM5MDM1QzE0Ljg4MTUgMi40MzE3NiAxNC45MTc4IDIuNDc0MjcgMTQuOTUzNCAyLjUxNzM2QzE0Ljk3MTIgMi41Mzg5MSAxNC45ODg3IDIuNTYwNzcgMTUuMDA2IDIuNTgyNzRDMTUuMDM4NCAyLjYyMzg4IDE0Ljk2ODIgMi41MzMzNSAxNSAyLjU3NUMxNS4wMTE0IDIuNTg5ODMgMTUuMDIyNSAyLjYwNDc5IDE1LjAzMzYgMi42MTk3OEMxNS4xNzM2IDIuODA4NzEgMTUuMjk0NiAzLjAxMTQyIDE1LjM5ODUgMy4yMjIyNEMxNS40MjM4IDMuMjczNTYgMTUuNDQ3NyAzLjMyNTUzIDE1LjQ3MDkgMy4zNzc4MkMxNS40NzY3IDMuMzkwOTYgMTUuNDgyNCAzLjQwNDE0IDE1LjQ4ODEgMy40MTczNEMxNS41MDkzIDMuNDY2NTYgMTUuNDY0IDMuMzU5NDUgMTUuNDg0NSAzLjQwOTAyQzE1LjQ5NzUgMy40NDAxMyAxNS41MDk5IDMuNDcxNDggMTUuNTIyMSAzLjUwMjg5QzE1LjU2NjEgMy42MTYzMiAxNS42MDQ5IDMuNzMxNzUgMTUuNjM5OCAzLjg0ODMzQzE1LjcxMTUgNC4wODgzMiAxNS43NjMgNC4zMzQxNiAxNS43OTg0IDQuNTgyMDRDMTUuODA2NCA0LjYzODA2IDE1Ljc5MDEgNC41MTg0MiAxNS43OTc1IDQuNTc0NjNDMTUuNzk5NSA0LjU4OTkyIDE1LjgwMTQgNC42MDUyMSAxNS44MDMzIDQuNjIwNUMxNS44MDcgNC42NTEyIDE1LjgxMDQgNC42ODE5NyAxNS44MTM3IDQuNzEyNzNDMTUuODIwOCA0Ljc3OTk0IDE1LjgyNjQgNC44NDczMiAxNS44MzEyIDQuOTE0NzRDMTUuODQwNCA1LjA0NjU4IDE1Ljg0NDcgNS4xNzg3NiAxNS44NDUzIDUuMzEwOTNDMTUuODQ2NCA1LjU4NDE4IDE1LjgyODcgNS44NTczNyAxNS43OTYxIDYuMTI4NjJDMTUuNzk0MSA2LjE0NTI5IDE1Ljc5MTkgNi4xNjE5MiAxNS43ODk4IDYuMTc4NTZDMTUuNzgyMiA2LjIzODI3IDE1Ljc5ODMgNi4xMTcyMiAxNS43OTAxIDYuMTc2OTdDMTUuNzg1NSA2LjIxMDQ0IDE1Ljc4MDYgNi4yNDM4OSAxNS43NzU1IDYuMjc3MzFDMTUuNzY0NCA2LjM1MDMxIDE1Ljc1MiA2LjQyMzEgMTUuNzM4OCA2LjQ5NTczQzE1LjcxMjkgNi42Mzc2OSAxNS42ODIzIDYuNzc4OCAxNS42NDg0IDYuOTE5MDVDMTUuNTc4NCA3LjIwODQzIDE1LjQ5MDkgNy40OTM0OCAxNS4zODk3IDcuNzczNDNDMTUuMzY0OCA3Ljg0MjMyIDE1LjMzODggNy45MTA4IDE1LjMxMjEgNy45NzkwMkMxNS4yOTg3IDguMDEzMzggMTUuMjg0OSA4LjA0NzYgMTUuMjcxMSA4LjA4MTc5QzE1LjI2NDEgOC4wOTg5NiAxNS4yNTcgOC4xMTYwNCAxNS4yNSA4LjEzMzE1QzE1LjI0NTIgOC4xNDQ1OCAxNS4yNDA1IDguMTU1OTggMTUuMjM1NyA4LjE2NzM4QzE1LjI0OTYgOC4xMzQ1MyAxNS4yNTEgOC4xMzExNyAxNS4yMzk5IDguMTU3MzRDMTUuMTc4NiA4LjMwMTM3IDE1LjExMzEgOC40NDM1NSAxNS4wNDQzIDguNTg0MTZDMTQuOTAyOCA4Ljg3MzUxIDE0Ljc0NTEgOS4xNTQ4MyAxNC41NzQ1IDkuNDI3OTlDMTQuNDg2OCA5LjU2ODQ0IDE0LjM5NSA5LjcwNjM0IDE0LjMwMDIgOS44NDIxM0MxNC4yNTQgOS45MDgyMSAxNC4yMDY5IDkuOTczNTUgMTQuMTU5MiAxMC4wMzg1QzE0LjEzNTEgMTAuMDcxMSAxNC4xMTA4IDEwLjEwMzYgMTQuMDg2NCAxMC4xMzZDMTQuMDc0MSAxMC4xNTIyIDE0LjA2MTcgMTAuMTY4NCAxNC4wNDk0IDEwLjE4NDVDMTQuMDMxOSAxMC4yMDczIDE0LjAzMjkgMTAuMjA2MSAxNC4wNTIyIDEwLjE4MUMxNC4wNDM5IDEwLjE5MTggMTQuMDM1NSAxMC4yMDI1IDE0LjAyNzEgMTAuMjEzMkMxMy44MTM1IDEwLjQ4NjkgMTMuNTg0OSAxMC43NDg4IDEzLjM0NDUgMTAuOTk5MkMxMy4wOTQ4IDExLjI1OTQgMTIuODMwOSAxMS41MDU4IDEyLjU1NiAxMS43MzkxQzEyLjQ4ODQgMTEuNzk2NSAxMi40MTk5IDExLjg1MjggMTIuMzUwOSAxMS45MDg2QzEyLjMxNjIgMTEuOTM2NiAxMi4yODEyIDExLjk2NDMgMTIuMjQ2MSAxMS45OTJDMTIuMjI4NSAxMi4wMDU4IDEyLjIxMDggMTIuMDE5NiAxMi4xOTMxIDEyLjAzMzNDMTIuMjM3NyAxMS45OTg3IDEyLjE2MzYgMTIuMDU1OCAxMi4xNTYgMTIuMDYxNkMxMi4wMDUgMTIuMTc2NSAxMS44NTA4IDEyLjI4NzEgMTEuNjk0MiAxMi4zOTQxQzExLjM3MDYgMTIuNjE1MyAxMS4wMzQ4IDEyLjgxODUgMTAuNjkwNCAxMy4wMDU1QzEwLjUxMjIgMTMuMTAyMyAxMC4zMzEzIDEzLjE5MzkgMTAuMTQ4NCAxMy4yODE1QzEwLjA1OSAxMy4zMjQzIDkuOTY5MDQgMTMuMzY1OCA5Ljg3ODY4IDEzLjQwNjRDOS44MzMxIDEzLjQyNjkgOS43ODczMyAxMy40NDY5IDkuNzQxNTEgMTMuNDY2OUM5LjcxODUgMTMuNDc2OSA5LjY5NTQxIDEzLjQ4NjggOS42NzIzMyAxMy40OTY2QzkuNjQ0MiAxMy41MDg2IDkuNjQxNDYgMTMuNTA5OCA5LjY2NDE3IDEzLjUwMDJDOS42NDg2NCAxMy41MDY3IDkuNjMzMTMgMTMuNTEzMiA5LjYxNzU4IDEzLjUxOTZDOS4yMzQ5IDEzLjY3ODggOC44NDM5OCAxMy44MTc5IDguNDQ3ODYgMTMuOTM5OEM4LjMxNDA5IDEzLjk4MDkgOC4yMzA0IDE0LjExNzggOC4yNjgzOSAxNC4yNTU5QzguMzA0NyAxNC4zODc4IDguNDUwNjQgMTQuNDc2NSA4LjU4NDUgMTQuNDM1M0MxMC4xNTM0IDEzLjk1MjUgMTEuNjI2IDEzLjE4NzEgMTIuODg1NyAxMi4xMzFDMTMuOTQyNSAxMS4yNDUgMTQuODM0OSAxMC4xNDU2IDE1LjQ1NDMgOC45MTE2NUMxNS45OTQyIDcuODM2MDggMTYuMzM1NyA2LjY0NzQ0IDE2LjM1ODMgNS40Mzk2N0MxNi4zNzc0IDQuNDE2MjggMTYuMTQ5IDMuMzU3MDQgMTUuNTc0MiAyLjQ5Nzg5QzE1LjI5MjkgMi4wNzczMiAxNC45MzcxIDEuNzE4MTYgMTQuNTIwNSAxLjQzMTM0QzEzLjc5NTYgMC45MzIyOTUgMTIuOTI5NCAwLjU5MjgyMiAxMi4wNDUgMC41NTcyMTRDMTAuNzcxNyAwLjUwNTk0OSA5LjYwMTI2IDEuMTcxNTcgOC43Njk3IDIuMDk2ODVDOC41OTc3OSAyLjI4ODEzIDguNDM2MzQgMi40OTE3MiA4LjI5NDMxIDIuNzA2MjlDOC40NDIyMyAyLjcwNjI5IDguNTkwMTUgMi43MDYyOSA4LjczODA3IDIuNzA2MjlDOC4yMjQzNCAxLjkzMDIzIDcuNDgyNTUgMS4yNTMzOCA2LjYyNjQgMC44ODA0MjRDNS45MzA1IDAuNTc3MjU4IDUuMTg1NTUgMC40OTAxNjQgNC40MzcyMSAwLjYxNzE3OUMzLjk4NzY2IDAuNjkzNDggMy41NTU0NiAwLjg1NjUwOCAzLjE0ODQ5IDEuMDU5MTVDMi44MTk0NSAxLjIyMjk2IDIuNTA2NTMgMS40MTg0MiAyLjIyMTE1IDEuNjUwMTdDMS40NDkwNCAyLjI3NzEzIDAuOTczMDI2IDMuMjA5OTUgMC43ODM3MzIgNC4xNzUxOUMwLjU2NTA5IDUuMjkwMDQgMC42ODczNyA2LjQ1MzgxIDEuMDIwNTEgNy41MzMzOUMxLjQxMDg0IDguNzk4MjcgMi4wOTQwNyA5Ljk1OTE2IDIuOTU2NDEgMTAuOTU4OUMzLjk0NzU3IDEyLjEwODEgNS4xOTYxNCAxMy4wMzA2IDYuNTU4MiAxMy42OTMzQzcuMTY3MTIgMTMuOTg5NiA3LjgwMDggMTQuMjM2MiA4LjQ0Nzg4IDE0LjQzNTNDOC41ODE3NCAxNC40NzY1IDguNzI3NjggMTQuMzg3OCA4Ljc2Mzk5IDE0LjI1NTlDOC44MDE4OSAxNC4xMTc3IDguNzE4MjEgMTMuOTgwOSA4LjU4NDQ0IDEzLjkzOTdaXCJcbiAgICB9KVxuICB9KSwgLyogQF9fUFVSRV9fICovIHEuanN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJNOC41ODQ0NCAxMy45Mzk3QzcuNzYxMzkgMTMuNjg2NCA3LjA1MzM0IDEzLjM5MzcgNi4yOTk3NiAxMi45ODI1QzUuOTU2MzMgMTIuNzk1MSA1LjYyMjg1IDEyLjU4OTUgNS4zMDAzIDEyLjM2ODFDNS4xNDQxNiAxMi4yNjA5IDQuOTkxMDggMTIuMTQ5MyA0Ljg0MDYzIDEyLjAzNDNDNC43ODEzMiAxMS45ODg5IDQuODgwMzggMTIuMDY1MiA0LjgyMTU2IDEyLjAxOTVDNC44MDM4OCAxMi4wMDU4IDQuNzg2MyAxMS45OTE5IDQuNzY4NjkgMTEuOTc4MUM0LjczMzY0IDExLjk1MDUgNC42OTg4NCAxMS45MjI1IDQuNjY0MTMgMTEuODk0NUM0LjU4OTQ4IDExLjgzNDIgNC41MTU4MiAxMS43NzI3IDQuNDQyOCAxMS43MTA1QzMuOTA0OTkgMTEuMjUyIDMuNDEzODEgMTAuNzM4OSAyLjk4MDE2IDEwLjE4MDlDMy4wMTg1NiAxMC4yMzAzIDIuOTc2NTEgMTAuMTc2IDIuOTcwNjQgMTAuMTY4M0MyLjk1ODMgMTAuMTUyMiAyLjk0NjA0IDEwLjEzNTkgMi45MzM4IDEwLjExOTdDMi45MDkzOSAxMC4wODc0IDIuODg1MjcgMTAuMDU0OCAyLjg2MTI2IDEwLjAyMjFDMi44MDk2MSA5Ljk1MTg5IDIuNzU5MDggOS44ODA4IDIuNzA5MzIgOS44MDkyQzIuNjE0OTIgOS42NzM0NSAyLjUyNDQxIDkuNTM1IDIuNDM3MSA5LjM5NDU3QzIuMjY3MyA5LjEyMTQ1IDIuMTEyMTMgOC44MzkyNiAxLjk3MTQ3IDguNTUwMDZDMS45Mzg0OSA4LjQ4MjI4IDEuOTA2NTcgOC40MTM5NiAxLjg3NTMxIDguMzQ1MzdDMS44NTk3OCA4LjMxMTMgMS44NDQ1OSA4LjI3NzA5IDEuODI5NDggOC4yNDI4NEMxLjgyMTk1IDguMjI1NzUgMS44MTQ1NiA4LjIwODY0IDEuODA3MTQgOC4xOTE1MkMxLjgwMTY3IDguMTc4ODkgMS43Njg1NiA4LjEwMDYxIDEuNzk2NjQgOC4xNjczNkMxLjczNzI4IDguMDI2MiAxLjY4MjA1IDcuODgzMjkgMS42MzAyOSA3LjczOTE2QzEuNTI5ODIgNy40NTk0MiAxLjQ0NDk4IDcuMTc0MDcgMS4zNzU3NSA2Ljg4NTAyQzEuMzQyMTggNi43NDQ5MiAxLjMxMzAxIDYuNjAzNzkgMS4yODc0NiA2LjQ2MjAyQzEuMjc1NCA2LjM5NTAyIDEuMjY0NSA2LjMyNzgyIDEuMjU0MyA2LjI2MDUyQzEuMjQ5MjUgNi4yMjcxMyAxLjI0NDUzIDYuMTkzNjkgMS4yMzk5NCA2LjE2MDIzQzEuMjUxMzYgNi4yNDM1OCAxLjIzNDk1IDYuMTE3NzIgMS4yMzIzMSA2LjA5NTMyQzEuMjAwNDIgNS44MjQ0NCAxLjE4NTM1IDUuNTUxNTggMS4xODcyMSA1LjI3ODg1QzEuMTg4MTEgNS4xNDY5MSAxLjE5Mzc0IDUuMDE1MDEgMS4yMDMzNCA0Ljg4MzQzQzEuMjA3ODggNC44MjEyOCAxLjIxMzY4IDQuNzU5MjIgMS4yMjAyMyA0LjY5NzI2QzEuMjIzNSA0LjY2NjUxIDEuMjI3MTMgNC42MzU4IDEuMjMwODkgNC42MDUxMUMxLjIzMjc4IDQuNTg5ODIgMS4yMzQ3NyA0LjU3NDU3IDEuMjM2NzggNC41NTkzQzEuMjI1NjIgNC42NDQyNSAxLjIzNTYzIDQuNTY5NTYgMS4yMzgyMyA0LjU1MTYzQzEuMjc0MjggNC4zMDQxOSAxLjMyODYxIDQuMDU5NDMgMS40MDA5NyAzLjgyMDA2QzEuNDM2MTQgMy43MDM3NSAxLjQ3NjM1IDMuNTg4OTkgMS41MjA3MiAzLjQ3NTg3QzEuNTMxMjUgMy40NDkgMS41NDIxOSAzLjQyMjI5IDEuNTUzMjYgMy4zOTU2NEMxLjUxOTQxIDMuNDc3MTYgMS41NTg4OSAzLjM4MzM0IDEuNTY3MTcgMy4zNjQ2NEMxLjU5MjI2IDMuMzA4MDMgMS42MTg4NiAzLjI1MjA5IDEuNjQ2NDMgMy4xOTY2NEMxLjc1MTAxIDIuOTg2MjQgMS44NzQ3NiAyLjc4NTQ5IDIuMDE1MzQgMi41OTcyNEMyLjAyMzcxIDIuNTg2MDMgMi4wMzIyMSAyLjU3NDkyIDIuMDQwNzEgMi41NjM4QzEuOTkyNzUgMi42MjY1NiAyLjAyNDQ2IDIuNTg0OTYgMi4wMzQ5MyAyLjU3MTY5QzIuMDUyMjMgMi41NDk3NCAyLjA2OTkzIDIuNTI4MDggMi4wODc3MyAyLjUwNjUzQzIuMTI2MzEgMi40NTk4NCAyLjE2NjI5IDIuNDE0MzQgMi4yMDcxMyAyLjM2OTYyQzIuMjg1ODcgMi4yODM0MSAyLjM2OTI2IDIuMjAxNTEgMi40NTYgMi4xMjMzOUMyLjQ5Nzg3IDIuMDg1NjggMi41NDA4NCAyLjA0OTIgMi41ODQ0MyAyLjAxMzUyQzIuNjA2MzEgMS45OTU2MSAyLjYyODUyIDEuOTc4MDggMi42NTA4NCAxLjk2MDdDMi41ODE2NCAyLjAxNDY2IDIuNjcxOTEgMS45NDU1NyAyLjY4OTYyIDEuOTMyNjVDMi44MzMzOCAxLjgyNzcgMi45ODU4NyAxLjczNDggMy4xNDAxMyAxLjY0NjNDMy41NDM5MyAxLjQxNDU5IDMuOTI0MzcgMS4yNTU2NyA0LjM4MzEgMS4xNTA3MkM0LjQ3NzE2IDEuMTI5MjEgNC41NzIxOSAxLjExMjA0IDQuNjY3NiAxLjA5NzcxQzQuNzQ0ODMgMS4wODYxMSA0LjYxNTI3IDEuMTAzOTkgNC42OTIxNyAxLjA5NDQ0QzQuNzE1MTMgMS4wOTE2IDQuNzM4MTcgMS4wODkxNyA0Ljc2MTE5IDEuMDg2NzdDNC44MTQwMyAxLjA4MTI0IDQuODY3MDQgMS4wNzczOSA0LjkyMDA3IDEuMDc0MjNDNS4xMDA4NCAxLjA2MzQ4IDUuMjgyMzcgMS4wNjg1MSA1LjQ2MjUyIDEuMDg2NEM1LjQ4MzM2IDEuMDg4NDYgNS41MDQxNyAxLjA5MDkyIDUuNTI0OTUgMS4wOTMzOEM1LjU5NTA4IDEuMTAxNjcgNS40Njk0MyAxLjA4NTI2IDUuNTM4OTkgMS4wOTUyMUM1LjU3OTY1IDEuMTAxMDMgNS42MjAxNiAxLjEwNzk1IDUuNjYwNTkgMS4xMTUyNEM1Ljc0NjQ3IDEuMTMwNzMgNS44MzE1OSAxLjE1MDMgNS45MTYwNCAxLjE3MjI3QzYuMDcyOCAxLjIxMzExIDYuMjI2MjEgMS4yNjYyMSA2LjM3NTk1IDEuMzI3ODZDNi4zMTExMSAxLjMwMTE1IDYuNDE4NzcgMS4zNDcwMiA2LjQzNTg0IDEuMzU0NzdDNi40Njk4NyAxLjM3MDIgNi41MDM1NiAxLjM4NjM5IDYuNTM3MTQgMS40MDI4QzYuNjA4NjUgMS40Mzc3OSA2LjY3ODg2IDEuNDc1NDMgNi43NDgxNyAxLjUxNDYyQzYuODc2NjIgMS41ODcyMyA3LjAwMDYyIDEuNjY3NTMgNy4xMjA5MiAxLjc1MjlDNy4xNDg4MiAxLjc3MjcxIDcuMTc2MzcgMS43OTI5NyA3LjIwMzgzIDEuODEzMzhDNy4yMTczOSAxLjgyMzQ4IDcuMjMwODcgMS44MzM3IDcuMjQ0MzIgMS44NDM5NkM3LjI5MTU4IDEuODc5OTIgNy4xOTg4IDEuODA4MzkgNy4yNDUyOSAxLjg0NDgyQzcuMzAxMDkgMS44ODg1MyA3LjM1NTY4IDEuOTMzNzUgNy40MDk0OSAxLjk3OTgyQzcuNTA2NTIgMi4wNjI4OCA3LjU5OTk0IDIuMTUwMDggNy42OTA1MyAyLjI0MDExQzcuODQwMDggMi4zODg3OSA3Ljk4MDQ0IDIuNTQ2NzcgOC4xMTE0OSAyLjcxMTk0QzguMTI1NzIgMi43Mjk4NyA4LjE3NTMzIDIuNzk0MTQgOC4xMTQ4NSAyLjcxNTdDOC4xMjYzNiAyLjczMDY1IDguMTM3NzYgMi43NDU2OCA4LjE0OTEgMi43NjA3NUM4LjE2OTQgMi43ODc2OSA4LjE4OTM0IDIuODE0OTEgOC4yMDkwNSAyLjg0MjNDOC4yMzgyNSAyLjg4Mjg2IDguMjY2NyAyLjkyMzk4IDguMjk0MjkgMi45NjU2NkM4LjQwMzc0IDMuMTMxIDguNjI4NiAzLjEzMSA4LjczODA1IDIuOTY1NjZDOC43NjcwNyAyLjkyMTgxIDguNzk3MTIgMi44Nzg2NiA4LjgyNzg1IDIuODM1OThDOC44NDc4MyAyLjgwODIzIDguODY4MTkgMi43ODA3NSA4Ljg4ODc1IDIuNzUzNDRDOC45MDI0MiAyLjczNTI5IDguOTQ5MjggMi42NzQ3NCA4Ljg4OTM1IDIuNzUyMTRDOC45MDQwOSAyLjczMzEyIDguOTE5IDIuNzE0MjQgOC45MzM5OSAyLjY5NTQyQzkuMDY3MSAyLjUyODM0IDkuMjEwNzEgMi4zNjk2OCA5LjM2MjYxIDIuMjE5NTRDOS40NTQxMSAyLjEyOTA3IDkuNTQ5MyAyLjA0MjM0IDkuNjQ3MzIgMS45NTg5N0M5LjY5NzM3IDEuOTE2NDEgOS43NDg0NyAxLjg3NTA3IDkuODAwMTcgMS44MzQ1NkM5LjczODggMS44ODI2MyA5LjgyNjk0IDEuODE0NTcgOS44NDIxMyAxLjgwMzI3QzkuODc0MjcgMS43NzkzNyA5LjkwNjgzIDEuNzU2MDYgOS45Mzk2IDEuNzMzMDFDMTAuMDYwOCAxLjY0NzczIDEwLjE4NjYgMS41NjkxNSAxMC4zMTU5IDEuNDk2ODJDMTAuMzgwMiAxLjQ2MDg0IDEwLjQ0NTcgMS40MjcwMyAxMC41MTE5IDEuMzk0NjdDMTAuNTQ1NSAxLjM3ODIzIDEwLjU3OTUgMS4zNjI1MSAxMC42MTM2IDEuMzQ3MDRDMTAuNjMwOCAxLjMzOTI2IDEwLjY0ODEgMS4zMzE3MSAxMC42NjU0IDEuMzI0MTdDMTAuNjkxNSAxLjMxMjk2IDEwLjY4ODUgMS4zMTQyIDEwLjY1NjQgMS4zMjc5QzEwLjY2ODEgMS4zMjMwMyAxMC42Nzk4IDEuMzE4MjIgMTAuNjkxNiAxLjMxMzQ5QzEwLjg0MjMgMS4yNTIzNSAxMC45OTczIDEuMjAyNDYgMTEuMTU0OCAxLjE2MjM5QzExLjIzMzIgMS4xNDI0OCAxMS4zMTIzIDEuMTI1OTkgMTEuMzkxOCAxLjExMTY2QzExLjQzMjMgMS4xMDQzNSAxMS40NzMgMS4wOTgxNSAxMS41MTM4IDEuMDkyMzFDMTEuNDQ3MSAxLjEwMTg2IDExLjUxNzEgMS4wOTIyNiAxMS41MjgxIDEuMDkwOTVDMTEuNTU1OSAxLjA4NzY3IDExLjU4MzggMS4wODQ5OSAxMS42MTE3IDEuMDgyNEMxMS43OTMgMS4wNjU1MyAxMS45NzU3IDEuMDY1MTMgMTIuMTU3MyAxLjA3NzFDMTIuMjAzIDEuMDgwMTEgMTIuMjQ4NSAxLjA4NDQ0IDEyLjI5NCAxLjA4OTIxQzEyLjMxNzIgMS4wOTE2MyAxMi4zNDAyIDEuMDk0NSAxMi4zNjMzIDEuMDk3MzRDMTIuMzAzNiAxLjA4OTk0IDEyLjM4MTMgMS4xMDAyMiAxMi4zODgxIDEuMTAxMjNDMTIuNDkyMSAxLjExNjg1IDEyLjU5NTIgMS4xMzc4NSAxMi42OTc1IDEuMTYxOTNDMTMuMTU4NiAxLjI3MDQ4IDEzLjUzNzggMS40NDAzNyAxMy45NDY0IDEuNjc3NjFDMTQuMDkwNCAxLjc2MTI5IDE0LjIzMTQgMS44NTA3IDE0LjM2NTYgMS45NDk1QzE0LjM3NyAxLjk1NzkxIDE0LjM4ODQgMS45NjY0OCAxNC4zOTk3IDEuOTc1MDNDMTQuNDQxOSAyLjAwNjg4IDE0LjM1MSAxLjkzNjk2IDE0LjM5MjYgMS45Njk0NUMxNC40MTQ5IDEuOTg2ODMgMTQuNDM2OSAyLjAwNDYyIDE0LjQ1ODggMi4wMjI1MkMxNC41MDU5IDIuMDYxMTUgMTQuNTUxOSAyLjEwMTMgMTQuNTk3MSAyLjE0MjI4QzE0LjY4MzUgMi4yMjA3MyAxNC43NjU2IDIuMzAzODggMTQuODQzOSAyLjM5MDM1QzE0Ljg4MTUgMi40MzE3NiAxNC45MTc4IDIuNDc0MjcgMTQuOTUzNCAyLjUxNzM2QzE0Ljk3MTIgMi41Mzg5MSAxNC45ODg3IDIuNTYwNzcgMTUuMDA2IDIuNTgyNzRDMTUuMDM4NCAyLjYyMzg4IDE0Ljk2ODIgMi41MzMzNSAxNSAyLjU3NUMxNS4wMTE0IDIuNTg5ODMgMTUuMDIyNSAyLjYwNDc5IDE1LjAzMzYgMi42MTk3OEMxNS4xNzM2IDIuODA4NzEgMTUuMjk0NiAzLjAxMTQyIDE1LjM5ODUgMy4yMjIyNEMxNS40MjM4IDMuMjczNTYgMTUuNDQ3NyAzLjMyNTUzIDE1LjQ3MDkgMy4zNzc4MkMxNS40NzY3IDMuMzkwOTYgMTUuNDgyNCAzLjQwNDE0IDE1LjQ4ODEgMy40MTczNEMxNS41MDkzIDMuNDY2NTYgMTUuNDY0IDMuMzU5NDUgMTUuNDg0NSAzLjQwOTAyQzE1LjQ5NzUgMy40NDAxMyAxNS41MDk5IDMuNDcxNDggMTUuNTIyMSAzLjUwMjg5QzE1LjU2NjEgMy42MTYzMiAxNS42MDQ5IDMuNzMxNzUgMTUuNjM5OCAzLjg0ODMzQzE1LjcxMTUgNC4wODgzMiAxNS43NjMgNC4zMzQxNiAxNS43OTg0IDQuNTgyMDRDMTUuODA2NCA0LjYzODA2IDE1Ljc5MDEgNC41MTg0MiAxNS43OTc1IDQuNTc0NjNDMTUuNzk5NSA0LjU4OTkyIDE1LjgwMTQgNC42MDUyMSAxNS44MDMzIDQuNjIwNUMxNS44MDcgNC42NTEyIDE1LjgxMDQgNC42ODE5NyAxNS44MTM3IDQuNzEyNzNDMTUuODIwOCA0Ljc3OTk0IDE1LjgyNjQgNC44NDczMiAxNS44MzEyIDQuOTE0NzRDMTUuODQwNCA1LjA0NjU4IDE1Ljg0NDcgNS4xNzg3NiAxNS44NDUzIDUuMzEwOTNDMTUuODQ2NCA1LjU4NDE4IDE1LjgyODcgNS44NTczNyAxNS43OTYxIDYuMTI4NjJDMTUuNzk0MSA2LjE0NTI5IDE1Ljc5MTkgNi4xNjE5MiAxNS43ODk4IDYuMTc4NTZDMTUuNzgyMiA2LjIzODI3IDE1Ljc5ODMgNi4xMTcyMiAxNS43OTAxIDYuMTc2OTdDMTUuNzg1NSA2LjIxMDQ0IDE1Ljc4MDYgNi4yNDM4OSAxNS43NzU1IDYuMjc3MzFDMTUuNzY0NCA2LjM1MDMxIDE1Ljc1MiA2LjQyMzEgMTUuNzM4OCA2LjQ5NTczQzE1LjcxMjkgNi42Mzc2OSAxNS42ODIzIDYuNzc4OCAxNS42NDg0IDYuOTE5MDVDMTUuNTc4NCA3LjIwODQzIDE1LjQ5MDkgNy40OTM0OCAxNS4zODk3IDcuNzczNDNDMTUuMzY0OCA3Ljg0MjMyIDE1LjMzODggNy45MTA4IDE1LjMxMjEgNy45NzkwMkMxNS4yOTg3IDguMDEzMzggMTUuMjg0OSA4LjA0NzYgMTUuMjcxMSA4LjA4MTc5QzE1LjI2NDEgOC4wOTg5NiAxNS4yNTcgOC4xMTYwNCAxNS4yNSA4LjEzMzE1QzE1LjI0NTIgOC4xNDQ1OCAxNS4yNDA1IDguMTU1OTggMTUuMjM1NyA4LjE2NzM4QzE1LjI0OTYgOC4xMzQ1MyAxNS4yNTEgOC4xMzExNyAxNS4yMzk5IDguMTU3MzRDMTUuMTc4NiA4LjMwMTM3IDE1LjExMzEgOC40NDM1NSAxNS4wNDQzIDguNTg0MTZDMTQuOTAyOCA4Ljg3MzUxIDE0Ljc0NTEgOS4xNTQ4MyAxNC41NzQ1IDkuNDI3OTlDMTQuNDg2OCA5LjU2ODQ0IDE0LjM5NSA5LjcwNjM0IDE0LjMwMDIgOS44NDIxM0MxNC4yNTQgOS45MDgyMSAxNC4yMDY5IDkuOTczNTUgMTQuMTU5MiAxMC4wMzg1QzE0LjEzNTEgMTAuMDcxMSAxNC4xMTA4IDEwLjEwMzYgMTQuMDg2NCAxMC4xMzZDMTQuMDc0MSAxMC4xNTIyIDE0LjA2MTcgMTAuMTY4NCAxNC4wNDk0IDEwLjE4NDVDMTQuMDMxOSAxMC4yMDczIDE0LjAzMjkgMTAuMjA2MSAxNC4wNTIyIDEwLjE4MUMxNC4wNDM5IDEwLjE5MTggMTQuMDM1NSAxMC4yMDI1IDE0LjAyNzEgMTAuMjEzMkMxMy44MTM1IDEwLjQ4NjkgMTMuNTg0OSAxMC43NDg4IDEzLjM0NDUgMTAuOTk5MkMxMy4wOTQ4IDExLjI1OTQgMTIuODMwOSAxMS41MDU4IDEyLjU1NiAxMS43MzkxQzEyLjQ4ODQgMTEuNzk2NSAxMi40MTk5IDExLjg1MjggMTIuMzUwOSAxMS45MDg2QzEyLjMxNjIgMTEuOTM2NiAxMi4yODEyIDExLjk2NDMgMTIuMjQ2MSAxMS45OTJDMTIuMjI4NSAxMi4wMDU4IDEyLjIxMDggMTIuMDE5NiAxMi4xOTMxIDEyLjAzMzNDMTIuMjM3NyAxMS45OTg3IDEyLjE2MzYgMTIuMDU1OCAxMi4xNTYgMTIuMDYxNkMxMi4wMDUgMTIuMTc2NSAxMS44NTA4IDEyLjI4NzEgMTEuNjk0MiAxMi4zOTQxQzExLjM3MDYgMTIuNjE1MyAxMS4wMzQ4IDEyLjgxODUgMTAuNjkwNCAxMy4wMDU1QzEwLjUxMjIgMTMuMTAyMyAxMC4zMzEzIDEzLjE5MzkgMTAuMTQ4NCAxMy4yODE1QzEwLjA1OSAxMy4zMjQzIDkuOTY5MDQgMTMuMzY1OCA5Ljg3ODY4IDEzLjQwNjRDOS44MzMxIDEzLjQyNjkgOS43ODczMyAxMy40NDY5IDkuNzQxNTEgMTMuNDY2OUM5LjcxODUgMTMuNDc2OSA5LjY5NTQxIDEzLjQ4NjggOS42NzIzMyAxMy40OTY2QzkuNjQ0MiAxMy41MDg2IDkuNjQxNDYgMTMuNTA5OCA5LjY2NDE3IDEzLjUwMDJDOS42NDg2NCAxMy41MDY3IDkuNjMzMTMgMTMuNTEzMiA5LjYxNzU4IDEzLjUxOTZDOS4yMzQ5IDEzLjY3ODggOC44NDM5OCAxMy44MTc5IDguNDQ3ODYgMTMuOTM5OEM4LjMxNDA5IDEzLjk4MDkgOC4yMzA0IDE0LjExNzggOC4yNjgzOSAxNC4yNTU5QzguMzA0NyAxNC4zODc4IDguNDUwNjQgMTQuNDc2NSA4LjU4NDUgMTQuNDM1M0MxMC4xNTM0IDEzLjk1MjUgMTEuNjI2IDEzLjE4NzEgMTIuODg1NyAxMi4xMzFDMTMuOTQyNSAxMS4yNDUgMTQuODM0OSAxMC4xNDU2IDE1LjQ1NDMgOC45MTE2NUMxNS45OTQyIDcuODM2MDggMTYuMzM1NyA2LjY0NzQ0IDE2LjM1ODMgNS40Mzk2N0MxNi4zNzc0IDQuNDE2MjggMTYuMTQ5IDMuMzU3MDQgMTUuNTc0MiAyLjQ5Nzg5QzE1LjI5MjkgMi4wNzczMiAxNC45MzcxIDEuNzE4MTYgMTQuNTIwNSAxLjQzMTM0QzEzLjc5NTYgMC45MzIyOTUgMTIuOTI5NCAwLjU5MjgyMiAxMi4wNDUgMC41NTcyMTRDMTAuNzcxNyAwLjUwNTk0OSA5LjYwMTI2IDEuMTcxNTcgOC43Njk3IDIuMDk2ODVDOC41OTc3OSAyLjI4ODEzIDguNDM2MzQgMi40OTE3MiA4LjI5NDMxIDIuNzA2MjlDOC40NDIyMyAyLjcwNjI5IDguNTkwMTUgMi43MDYyOSA4LjczODA3IDIuNzA2MjlDOC4yMjQzNCAxLjkzMDIzIDcuNDgyNTUgMS4yNTMzOCA2LjYyNjQgMC44ODA0MjRDNS45MzA1IDAuNTc3MjU4IDUuMTg1NTUgMC40OTAxNjQgNC40MzcyMSAwLjYxNzE3OUMzLjk4NzY2IDAuNjkzNDggMy41NTU0NiAwLjg1NjUwOCAzLjE0ODQ5IDEuMDU5MTVDMi44MTk0NSAxLjIyMjk2IDIuNTA2NTMgMS40MTg0MiAyLjIyMTE1IDEuNjUwMTdDMS40NDkwNCAyLjI3NzEzIDAuOTczMDI2IDMuMjA5OTUgMC43ODM3MzIgNC4xNzUxOUMwLjU2NTA5IDUuMjkwMDQgMC42ODczNyA2LjQ1MzgxIDEuMDIwNTEgNy41MzMzOUMxLjQxMDg0IDguNzk4MjcgMi4wOTQwNyA5Ljk1OTE2IDIuOTU2NDEgMTAuOTU4OUMzLjk0NzU3IDEyLjEwODEgNS4xOTYxNCAxMy4wMzA2IDYuNTU4MiAxMy42OTMzQzcuMTY3MTIgMTMuOTg5NiA3LjgwMDggMTQuMjM2MiA4LjQ0Nzg4IDE0LjQzNTNDOC41ODE3NCAxNC40NzY1IDguNzI3NjggMTQuMzg3OCA4Ljc2Mzk5IDE0LjI1NTlDOC44MDE4OSAxNC4xMTc3IDguNzE4MjEgMTMuOTgwOSA4LjU4NDQ0IDEzLjkzOTdaXCIsXG4gICAgc3Ryb2tlOiBzIHx8IFwiI0EwQTNBRFwiLFxuICAgIHN0cm9rZVdpZHRoOiBcIjMuMTM3MTFcIixcbiAgICBtYXNrOiBcInVybCgjcGF0aC0yLWluc2lkZS0xXzE4N18xMDUxKVwiXG4gIH0pXVxufSk7XG5mdW5jdGlvbiBzbSh7XG4gIG9uQ2xpY2s6IHMsXG4gIHNpemU6IGUgPSAyNFxufSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIHEuanN4KFwic3ZnXCIsIHtcbiAgICBcImFyaWEtaGlkZGVuXCI6IFwidHJ1ZVwiLFxuICAgIGZvY3VzYWJsZTogXCJmYWxzZVwiLFxuICAgIHJvbGU6IFwiaW1nXCIsXG4gICAgdmlld0JveDogXCIwIDAgMTYgMTZcIixcbiAgICB3aWR0aDogZSxcbiAgICBoZWlnaHQ6IGUsXG4gICAgZmlsbDogXCIjNEE0QTRBXCIsXG4gICAgc3R5bGU6IHtcbiAgICAgIGRpc3BsYXk6IFwiaW5saW5lLWJsb2NrXCIsXG4gICAgICB1c2VyU2VsZWN0OiBcIm5vbmVcIixcbiAgICAgIHZlcnRpY2FsQWxpZ246IFwidGV4dC1ib3R0b21cIixcbiAgICAgIG92ZXJmbG93OiBcInZpc2libGVcIixcbiAgICAgIGN1cnNvcjogXCJwb2ludGVyXCIsXG4gICAgICBwYWRkaW5nOiBcIjRweFwiXG4gICAgfSxcbiAgICBvbkNsaWNrOiBzLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gcS5qc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTMuNzIgMy43MmEuNzUuNzUgMCAwIDEgMS4wNiAwTDggNi45NGwzLjIyLTMuMjJhLjc0OS43NDkgMCAwIDEgMS4yNzUuMzI2Ljc0OS43NDkgMCAwIDEtLjIxNS43MzRMOS4wNiA4bDMuMjIgMy4yMmEuNzQ5Ljc0OSAwIDAgMS0uMzI2IDEuMjc1Ljc0OS43NDkgMCAwIDEtLjczNC0uMjE1TDggOS4wNmwtMy4yMiAzLjIyYS43NTEuNzUxIDAgMCAxLTEuMDQyLS4wMTguNzUxLjc1MSAwIDAgMS0uMDE4LTEuMDQyTDYuOTQgOCAzLjcyIDQuNzhhLjc1Ljc1IDAgMCAxIDAtMS4wNlpcIlxuICAgIH0pXG4gIH0pO1xufVxuY29uc3QgRkEgPSAoKSA9PiBJciwgTkEgPSAvKiBAX19QVVJFX18gKi8gZGUoRkEoKSkoe1xuICBjbGFzc2VzOiBbXCJyZWN0N2U1XCJdXG59KSwgVUEgPSAoKSA9PiBJciwgJEEgPSAvKiBAX19QVVJFX18gKi8gZGUoVUEoKSkoe1xuICBjbGFzc2VzOiBbXCJwMTNtcW50dFwiXVxufSksIEdBID0gKCkgPT4gSXIsIFZBID0gLyogQF9fUFVSRV9fICovIGRlKEdBKCkpKHtcbiAgY2xhc3NlczogW1wicDFyNDdkejJcIl1cbn0pLCBqQSA9ICgpID0+IElyLCBLQSA9IC8qIEBfX1BVUkVfXyAqLyBkZShqQSgpKSh7XG4gIGNsYXNzZXM6IFtcImNub2pwcXZcIl1cbn0pLCBIQSA9ICh7XG4gIGhhc2g6IHMsXG4gIHJlYWN0aW9uczogZSxcbiAgb25Db21tZW50OiB0LFxuICBvblJlY2FzdDogcixcbiAgb25MaWtlOiBuLFxuICBpc0xpa2VkOiBpXG59KSA9PiB7XG4gIGNvbnN0IHtcbiAgICBjbGllbnRfaWQ6IG8sXG4gICAgdXNlcjogYSxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IGxcbiAgfSA9IHRzKCksIFtjLCB1XSA9IHN0LnVzZVN0YXRlKCExKSwgW2QsIGhdID0gc3QudXNlU3RhdGUoe1xuICAgIHRvcDogMCxcbiAgICBsZWZ0OiAwXG4gIH0pLCBbZiwgcF0gPSBzdC51c2VTdGF0ZShudWxsKSwgW3ksIEVdID0gc3QudXNlU3RhdGUoaSksIFtiLCBSXSA9IHN0LnVzZVN0YXRlKCExKSwgQSA9IHN0LnVzZVJlZihudWxsKSwgRiA9IHN0LnVzZVJlZih7XG4gICAgY29tbWVudDogbnVsbCxcbiAgICByZWNhc3Q6IG51bGwsXG4gICAgbGlrZTogbnVsbFxuICB9KTtcbiAgZnQoKCkgPT4ge1xuICAgIEUoZS5saWtlcy5zb21lKChIKSA9PiBILmZpZCA9PT0gKGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEuZmlkKSkpLCBSKGUucmVjYXN0cy5zb21lKChIKSA9PiBILmZpZCA9PT0gKGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEuZmlkKSkpO1xuICB9LCBbZSwgYV0pLCBmdCgoKSA9PiB7XG4gICAgY29uc3QgSCA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGpuLk5FWU5BUl9BVVRIRU5USUNBVEVEX1VTRVIpO1xuICAgIGlmIChIKVxuICAgICAgdHJ5IHtcbiAgICAgICAgcChKU09OLnBhcnNlKEgpLnNpZ25lcl91dWlkKTtcbiAgICAgIH0gY2F0Y2ggKEspIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHBhcnNpbmcgSlNPTiBmcm9tIGxvY2FsIHN0b3JhZ2U6XCIsIEspLCBwKG51bGwpO1xuICAgICAgfVxuICAgIGVsc2VcbiAgICAgIGNvbnNvbGUud2FybihcIk5vIE5FWU5BUl9BVVRIRU5USUNBVEVEX1VTRVIgZm91bmQgaW4gbG9jYWwgc3RvcmFnZS5cIik7XG4gIH0sIFtsXSksIGZ0KCgpID0+IHtcbiAgICAoZiB8fCBsKSAmJiBjICYmIHUoITEpO1xuICB9LCBbZiwgbCwgY10pO1xuICBjb25zdCBNID0gYXN5bmMgKEgsIEspID0+IHtcbiAgICBpZiAoZilcbiAgICAgIHN3aXRjaCAoSykge1xuICAgICAgICBjYXNlIFwiY29tbWVudFwiOlxuICAgICAgICAgIGlmICh0KVxuICAgICAgICAgICAgdCgpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNvbW1lbnQgaGFuZGxlciBmdW5jdGlvbiBwcm92aWRlZFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInJlY2FzdFwiOlxuICAgICAgICAgIGlmIChyKVxuICAgICAgICAgICAgUihyKCkpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIHJlY2FzdCBoYW5kbGVyIGZ1bmN0aW9uIHByb3ZpZGVkXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwibGlrZVwiOlxuICAgICAgICAgIGlmIChuKVxuICAgICAgICAgICAgRShuKCkpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGxpa2UgaGFuZGxlciBmdW5jdGlvbiBwcm92aWRlZFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICBjb25zdCBqID0gRi5jdXJyZW50W0tdO1xuICAgIGlmIChqKSB7XG4gICAgICBjb25zdCBDID0gai5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgayA9IEEuY3VycmVudDtcbiAgICAgIGlmIChrKSB7XG4gICAgICAgIGNvbnN0ICQgPSBrLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBoKHtcbiAgICAgICAgICB0b3A6IEMudG9wIC0gJC5oZWlnaHQgLSAxMCxcbiAgICAgICAgICBsZWZ0OiBDLmxlZnQgKyBDLndpZHRoIC8gMiAtICQud2lkdGggLyAyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoTkEsIHtcbiAgICBjaGlsZHJlbjogW2MgJiYgLyogQF9fUFVSRV9fICovIHEuanN4cygkQSwge1xuICAgICAgcmVmOiBBLFxuICAgICAgc3R5bGU6IHtcbiAgICAgICAgdG9wOiBkLnRvcCxcbiAgICAgICAgbGVmdDogZC5sZWZ0XG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3goVkEsIHtcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChwUywge1xuICAgICAgICAgIHZhcmlhbnQ6IGdzLk5FWU5BUlxuICAgICAgICB9KVxuICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChLQSwge1xuICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHEuanN4KHNtLCB7XG4gICAgICAgICAgb25DbGljazogKCkgPT4gdSghMSksXG4gICAgICAgICAgc2l6ZTogMTZcbiAgICAgICAgfSlcbiAgICAgIH0pXVxuICAgIH0pLCAvKiBAX19QVVJFX18gKi8gcS5qc3goSXIsIHtcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICBqdXN0aWZ5Q29udGVudDogXCJzcGFjZS1iZXR3ZWVuXCIsXG4gICAgICAgIGFsaWduSXRlbXM6IFwiY2VudGVyXCJcbiAgICAgIH0sXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHEuanN4cyhJciwge1xuICAgICAgICBzcGFjaW5nVmVydGljYWw6IFwiMTVweFwiLFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgICAgIGdhcDogXCI0MnB4XCJcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3goXCJkaXZcIiwge1xuICAgICAgICAgIHJlZjogKEgpID0+IEYuY3VycmVudC5jb21tZW50ID0gSCxcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHEuanN4KHRtLCB7XG4gICAgICAgICAgICBvbkNsaWNrOiAoSCkgPT4gTShILCBcImNvbW1lbnRcIilcbiAgICAgICAgICB9KVxuICAgICAgICB9KSwgLyogQF9fUFVSRV9fICovIHEuanN4KFwiZGl2XCIsIHtcbiAgICAgICAgICByZWY6IChIKSA9PiBGLmN1cnJlbnQucmVjYXN0ID0gSCxcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHEuanN4KEJBLCB7XG4gICAgICAgICAgICBmaWxsOiBiID8gXCJncmVlblwiIDogdm9pZCAwLFxuICAgICAgICAgICAgb25DbGljazogKEgpID0+IE0oSCwgXCJyZWNhc3RcIilcbiAgICAgICAgICB9KVxuICAgICAgICB9KSwgLyogQF9fUFVSRV9fICovIHEuanN4KFwiZGl2XCIsIHtcbiAgICAgICAgICByZWY6IChIKSA9PiBGLmN1cnJlbnQubGlrZSA9IEgsXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChybSwge1xuICAgICAgICAgICAgZmlsbDogeSA/IFwicmVkXCIgOiB2b2lkIDAsXG4gICAgICAgICAgICBvbkNsaWNrOiAoSCkgPT4gTShILCBcImxpa2VcIilcbiAgICAgICAgICB9KVxuICAgICAgICB9KV1cbiAgICAgIH0pXG4gICAgfSldXG4gIH0pO1xufTtcbmZ1bmN0aW9uIHFBKHtcbiAgb25DbGljazogc1xufSkge1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIHEuanN4KFwic3ZnXCIsIHtcbiAgICBzdHlsZToge1xuICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH0sXG4gICAgd2lkdGg6IFwiMTZcIixcbiAgICBoZWlnaHQ6IFwiMTVcIixcbiAgICB2aWV3Qm94OiBcIjAgMCAxNiAxNVwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgb25DbGljazogKGUpID0+IHMgPyBzKGUpIDogdm9pZCAwLFxuICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gcS5qc3goXCJwYXRoXCIsIHtcbiAgICAgIGQ6IFwiTTE1LjIwMDMgNy40OTA2M0MxNC43NTA0IDcuNDkwNjMgMTQuNDUwNCA3Ljc5MDU3IDE0LjQ1MDQgOC4yNDA0OFYxMi43Mzk2QzE0LjQ1MDQgMTMuMTg5NSAxNC4xNTA1IDEzLjQ4OTQgMTMuNzAwNiAxMy40ODk0SDMuMjAyNjhDMi43NTI3NyAxMy40ODk0IDIuNDUyODMgMTMuMTg5NSAyLjQ1MjgzIDEyLjczOTZWOC4yNDA0OEMyLjQ1MjgzIDcuNzkwNTcgMi4xNTI4OSA3LjQ5MDYzIDEuNzAyOTggNy40OTA2M0MxLjI1MzA3IDcuNDkwNjMgMC45NTMxMjUgNy43OTA1NyAwLjk1MzEyNSA4LjI0MDQ4VjEyLjczOTZDMC45NTMxMjUgMTQuMDE0MyAxLjkyNzkzIDE0Ljk4OTEgMy4yMDI2OCAxNC45ODkxSDEzLjcwMDZDMTQuOTc1MyAxNC45ODkxIDE1Ljk1MDEgMTQuMDE0MyAxNS45NTAxIDEyLjczOTZWOC4yNDA0OEMxNS45NTAxIDcuNzkwNTcgMTUuNjUwMiA3LjQ5MDYzIDE1LjIwMDMgNy40OTA2M1pNNS45NzcxMyA0LjI2NjI3TDcuNzAxNzggMi41NDE2MVY5Ljc0MDE4QzcuNzAxNzggMTAuMTkwMSA4LjAwMTcyIDEwLjQ5IDguNDUxNjMgMTAuNDlDOC45MDE1NSAxMC40OSA5LjIwMTQ5IDEwLjE5MDEgOS4yMDE0OSA5Ljc0MDE4VjIuNTQxNjFMMTAuOTI2MSA0LjI2NjI3QzExLjIyNjEgNC41NjYyMSAxMS42NzYgNC41NjYyMSAxMS45NzU5IDQuMjY2MjdDMTIuMjc1OSAzLjk2NjMzIDEyLjI3NTkgMy41MTY0MiAxMS45NzU5IDMuMjE2NDhMOC45NzY1MyAwLjIxNzA3M0M4LjkwMTU1IDAuMTQyMDg4IDguODI2NTYgMC4wNjcxMDMxIDguNzUxNTcgMC4wNjcxMDMxQzguNjAxNiAtMC4wMDc4ODIwMiA4LjM3NjY1IC0wLjAwNzg4MjAyIDguMTUxNjkgMC4wNjcxMDMxQzguMDc2NzEgMC4wNjcxMDMxIDguMDAxNzIgMC4xNDIwODggNy45MjY3NCAwLjIxNzA3M0w0LjkyNzM0IDMuMjE2NDhDNC42MjczOSAzLjUxNjQyIDQuNjI3MzkgMy45NjYzMyA0LjkyNzM0IDQuMjY2MjdDNS4yMjcyOCA0LjU2NjIxIDUuNjc3MTkgNC41NjYyMSA1Ljk3NzEzIDQuMjY2MjdaXCIsXG4gICAgICBmaWxsOiBcIiNBMEEzQURcIlxuICAgIH0pXG4gIH0pO1xufVxuY29uc3QgSWMgPSAoe1xuICB1cmw6IHNcbn0pID0+IHtcbiAgY29uc3QgW2UsIHRdID0gc3QudXNlU3RhdGUoITEpLCByID0gYXN5bmMgKG4pID0+IHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQocyksIHQoITApLCBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdCghMSk7XG4gICAgICB9LCAyZTMpO1xuICAgIH0gY2F0Y2ggKGkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJGYWlsZWQgdG8gY29weSB0aGUgdGV4dCB0byBjbGlwYm9hcmQ6XCIsIGkpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChcImRpdlwiLCB7XG4gICAgY2hpbGRyZW46IGUgPyAvKiBAX19QVVJFX18gKi8gcS5qc3goXCJzdmdcIiwge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIixcbiAgICAgICAgZmlsbDogXCJncmVlblwiXG4gICAgICB9LFxuICAgICAgd2lkdGg6IFwiMTZcIixcbiAgICAgIGhlaWdodDogXCIxNVwiLFxuICAgICAgdmlld0JveDogXCIwIDAgMTYgMTVcIixcbiAgICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHEuanN4KFwicGF0aFwiLCB7XG4gICAgICAgIGQ6IFwiTTUuOTk5NjcgMTIuODEzNkwxLjcxOTY3IDguNTMzNjRMMC41NTk2NzMgOS42OTM2NEw1Ljk5OTY3IDE1LjEzMzZMMTYuNDM5NyA0LjY5MzY0TDE1LjI3OTcgMy41MzM2NEw1Ljk5OTY3IDEyLjgxMzZaXCJcbiAgICAgIH0pXG4gICAgfSkgOiAvKiBAX19QVVJFX18gKi8gcS5qc3gocUEsIHtcbiAgICAgIG9uQ2xpY2s6IHJcbiAgICB9KVxuICB9KTtcbn0sIFdBID0gKCkgPT4gLyogQF9fUFVSRV9fICovIHEuanN4cyhcInN2Z1wiLCB7XG4gIHdpZHRoOiBcIjEwXCIsXG4gIGhlaWdodDogXCIxMFwiLFxuICB2aWV3Qm94OiBcIjAgMCAxMCAxMFwiLFxuICBmaWxsOiBcIm5vbmVcIixcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk01Ljg1ODU1IDAuNTU1NjY0SDguMzEyODFNOC4zMTI4MSAwLjU1NTY2NFYyLjczNzU0TTguMzEyODEgMC41NTU2NjRMNC4zMTQ0NSA0LjExMTIyXCIsXG4gICAgc3Ryb2tlOiBcIiNGRkZGRkZcIixcbiAgICBcInN0cm9rZS1saW5lY2FwXCI6IFwicm91bmRcIixcbiAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInJvdW5kXCJcbiAgfSksIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChcInBhdGhcIiwge1xuICAgIFwiZmlsbC1ydWxlXCI6IFwiZXZlbm9kZFwiLFxuICAgIFwiY2xpcC1ydWxlXCI6IFwiZXZlbm9kZFwiLFxuICAgIGQ6IFwiTTMuMzE0NDUgMUgxLjMxNDQ1QzAuNzYyMTY4IDEgMC4zMTQ0NTMgMS40NDc3MiAwLjMxNDQ1MyAyVjhDMC4zMTQ0NTMgOC41NTIyOCAwLjc2MjE2OCA5IDEuMzE0NDUgOUg3LjMxNDQ1QzcuODY2NzQgOSA4LjMxNDQ1IDguNTUyMjggOC4zMTQ0NSA4VjZINy4zMTQ0NVY4SDEuMzE0NDVWMkgzLjMxNDQ1VjFaXCIsXG4gICAgZmlsbDogXCIjRkZGRkZGXCJcbiAgfSldXG59KSwgekEgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gcS5qc3goXCJzdmdcIiwge1xuICB3aWR0aDogXCIxMFwiLFxuICBoZWlnaHQ6IFwiMTRcIixcbiAgdmlld0JveDogXCIwIDAgMTAgMTRcIixcbiAgZmlsbDogXCJub25lXCIsXG4gIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gcS5qc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk01LjAxNDUxIDEyLjUxODdMNC45NjgzMyAxMi41MTc0TDQuOTM5MTQgMTIuNTIyQzQuOTMxMTMgMTIuNTE2IDQuOTI0MDIgMTIuNTA4NyA0LjkxODA4IDEyLjUwMDVMNC41MTIzMSAxMi43OTI2TDQuOTE4MDggMTIuNTAwNUM0LjkwNDkgMTIuNDgyMiA0Ljg5ODI0IDEyLjQ2IDQuODk5MTMgMTIuNDM3NUw0Ljg5OTUzIDEyLjQyNzVWMTIuNDE3NlY4LjgxMTk0VjguMzExOTRINC4zOTk1M0gxLjg4NzZIMS44ODc1M0MxLjc2MTg4IDguMzExOTYgMS42Mzg1MyA4LjI3ODI1IDEuNTMwMzYgOC4yMTQzM0MxLjQyMjE4IDguMTUwNCAxLjMzMzE1IDguMDU4NjIgMS4yNzI1NiA3Ljk0ODU0QzEuMjExOTYgNy44Mzg0NyAxLjE4MjAzIDcuNzE0MTUgMS4xODU4OCA3LjU4ODU2QzEuMTg5NzMgNy40NjMwMSAxLjIyNzIgNy4zNDA3OSAxLjI5NDM4IDcuMjM0NjZDMS4yOTQ0IDcuMjM0NjMgMS4yOTQ0MiA3LjIzNDU5IDEuMjk0NDQgNy4yMzQ1Nkw0LjkwMDAxIDEuNTQzNzdMNC45MDU2NyAxLjUzNDgzTDQuOTEwOTUgMS41MjU2N0M0LjkyMjI3IDEuNTA2MDEgNC45Mzk4OCAxLjQ5MDc0IDQuOTYwOTQgMS40ODIzMkM0Ljk4MiAxLjQ3Mzg5IDUuMDA1MjggMS40NzI4MSA1LjAyNzAzIDEuNDc5MjRMNS4wMjkxMiAxLjQ3OTg1QzUuMDUwNzcgMS40ODYxNCA1LjA2OTY5IDEuNDk5NSA1LjA4Mjg2IDEuNTE3OEM1LjA5NjAzIDEuNTM2MDkgNS4xMDI3IDEuNTU4MjcgNS4xMDE4IDEuNTgwNzlMNS4xMDE0MSAxLjU5MDczVjEuNjAwNjdWNS4yMDYzMVY1LjcwNjMxSDUuNjAxNDFIOC4xMTMzM0g4LjExMzRDOC4yMzkwNSA1LjcwNjI5IDguMzYyNCA1Ljc0IDguNDcwNTggNS44MDM5MkM4LjU3ODc1IDUuODY3ODQgOC42Njc3OCA1Ljk1OTYzIDguNzI4MzggNi4wNjk3MUM4Ljc4ODk3IDYuMTc5NzggOC44MTg5MSA2LjMwNDEgOC44MTUwNiA2LjQyOTY5QzguODExMjEgNi41NTUyOCA4Ljc3MzcxIDYuNjc3NTMgOC43MDY0OSA2Ljc4MzY5TDUuMTAyMzIgMTIuNDcyM0M1LjEwMjE5IDEyLjQ3MjUgNS4xMDIwNSAxMi40NzI3IDUuMTAxOTEgMTIuNDcyOUM1LjA5MjU1IDEyLjQ4NzMgNS4wNzk2OSAxMi40OTkgNS4wNjQ1MiAxMi41MDdDNS4wNDkxNCAxMi41MTUyIDUuMDMxOTEgMTIuNTE5MiA1LjAxNDUxIDEyLjUxODdaXCIsXG4gICAgc3Ryb2tlOiBcIiNGRkZGRkZcIlxuICB9KVxufSksIFlBID0gLyogQF9fUFVSRV9fICovIGRlKFwiYnV0dG9uXCIpKHtcbiAgY2xhc3NlczogW1wiZjFobWNycmZcIl1cbn0pLCBaQSA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcImYxa2k0aWw2XCJdXG59KSwgWEEgPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJiZ256MHVkXCJdXG59KSwgSkEgPSAvKiBAX19QVVJFX18gKi8gZGUoXCJpbWdcIikoe1xuICBjbGFzc2VzOiBbXCJmMWdiZ2V0OVwiXVxufSksIFFBID0gLyogQF9fUFVSRV9fICovIGRlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wiZjRyd2U0aVwiXVxufSksIGVJID0gLyogQF9fUFVSRV9fICovIGRlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wiZjFxZWxsZ3dcIl1cbn0pLCB0SSA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImlucHV0XCIpKHtcbiAgY2xhc3NlczogW1wiaTFoZ3h3aGlcIl1cbn0pLCBySSA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInMxYWhjZmF4XCJdXG59KSwgc0kgPSAoKSA9PiB7XG4gIGNvbnN0IHMgPSBidChudWxsKTtcbiAgcmV0dXJuIGZ0KCgpID0+IHtcbiAgICBpZiAocy5jdXJyZW50KSB7XG4gICAgICBsZXQgZSA9IDA7XG4gICAgICBjb25zdCB0ID0gKCkgPT4ge1xuICAgICAgICBlICs9IDYsIHMuY3VycmVudCAmJiAocy5jdXJyZW50LnN0eWxlLnRyYW5zZm9ybSA9IGByb3RhdGUoJHtlfWRlZylgKSwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHQpO1xuICAgICAgfTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSh0KTtcbiAgICB9XG4gIH0sIFtdKSwgLyogQF9fUFVSRV9fICovIHEuanN4KFwic3ZnXCIsIHtcbiAgICByZWY6IHMsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICAgIHN0cm9rZVdpZHRoOiBcIjEuNVwiLFxuICAgIHN0cm9rZTogXCJjdXJyZW50Q29sb3JcIixcbiAgICBjbGFzc05hbWU6IFwic2l6ZS02IHRleHQtd2hpdGVcIixcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6IFwiMjRweFwiLFxuICAgICAgaGVpZ2h0OiBcIjI0cHhcIlxuICAgIH0sXG4gICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChcInBhdGhcIiwge1xuICAgICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgICAgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIixcbiAgICAgIGQ6IFwiTTE2LjAyMyA5LjM0OGg0Ljk5MnYtLjAwMU0yLjk4NSAxOS42NDR2LTQuOTkybTAgMGg0Ljk5Mm0tNC45OTMgMCAzLjE4MSAzLjE4M2E4LjI1IDguMjUgMCAwIDAgMTMuODAzLTMuN000LjAzMSA5Ljg2NWE4LjI1IDguMjUgMCAwIDEgMTMuODAzLTMuN2wzLjE4MSAzLjE4Mm0wLTQuOTkxdjQuOTlcIlxuICAgIH0pXG4gIH0pO1xufTtcbmZ1bmN0aW9uIG5JKHtcbiAgbnVtYmVyOiBzLFxuICB0ZXh0OiBlLFxuICBhY3Rpb25UeXBlOiB0LFxuICB0YXJnZXQ6IHIsXG4gIGZyYW1lVXJsOiBuLFxuICBoYW5kbGVPbkNsaWNrOiBpXG59KSB7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gcS5qc3hzKFlBLCB7XG4gICAgb25DbGljazogKCkgPT4gaShzKSxcbiAgICBjaGlsZHJlbjogW2UsICh0ID09PSBcImxpbmtcIiB8fCB0ID09PSBcInBvc3RfcmVkaXJlY3RcIiB8fCB0ID09PSBcIm1pbnRcIikgJiYgLyogQF9fUFVSRV9fICovIHEuanN4KFdBLCB7fSksIHQgPT09IFwidHhcIiAmJiAvKiBAX19QVVJFX18gKi8gcS5qc3goekEsIHt9KV1cbiAgfSk7XG59XG5mdW5jdGlvbiBpSSh7XG4gIGZyYW1lOiBzLFxuICBvbkZyYW1lQnRuUHJlc3M6IGVcbn0pIHtcbiAgdmFyIGg7XG4gIGNvbnN0IFt0LCByXSA9IHFlKHMpLCBbbiwgaV0gPSBxZShcIlwiKSwgW28sIGFdID0gcWUoITEpLCBsID0gKCkgPT4ge1xuICAgIGNvbnN0IGYgPSB0LmJ1dHRvbnMubWFwKChwKSA9PiAvKiBAX19QVVJFX18gKi8gcS5qc3gobkksIHtcbiAgICAgIG51bWJlcjogcC5pbmRleCxcbiAgICAgIHRleHQ6IHAudGl0bGUsXG4gICAgICBhY3Rpb25UeXBlOiBwLmFjdGlvbl90eXBlLFxuICAgICAgdGFyZ2V0OiBwLnRhcmdldCxcbiAgICAgIGZyYW1lVXJsOiBzLmZyYW1lc191cmwsXG4gICAgICBoYW5kbGVPbkNsaWNrOiAoeSkgPT4ge1xuICAgICAgICBhKCEwKSwgZSh5LCB0LCByLCBuKS5maW5hbGx5KCgpID0+IGEoITEpKTtcbiAgICAgIH1cbiAgICB9LCBwLmluZGV4KSk7XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChYQSwge1xuICAgICAgY2hpbGRyZW46IGZcbiAgICB9KTtcbiAgfSwgYyA9IChmKSA9PiB7XG4gICAgaShmKTtcbiAgfSwgdSA9IChmKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgVVJMKGYpLmhvc3RuYW1lLnJlcGxhY2UoXCJ3d3cuXCIsIFwiXCIpO1xuICAgIH0gY2F0Y2gge1xuICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICB9LCBkID0gKCkgPT4ge1xuICAgIHN3aXRjaCAodC5pbWFnZV9hc3BlY3RfcmF0aW8pIHtcbiAgICAgIGNhc2UgXCIxOjFcIjpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhc3BlY3RSYXRpbzogXCIxIC8gMVwiXG4gICAgICAgIH07XG4gICAgICBjYXNlIFwiMS45MToxXCI6XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgYXNwZWN0UmF0aW86IFwiMS45MSAvIDFcIlxuICAgICAgICB9O1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBhc3BlY3RSYXRpbzogXCIxLjkxIC8gMVwiXG4gICAgICAgIH07XG4gICAgfVxuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIHEuanN4cyhxLkZyYWdtZW50LCB7XG4gICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3hzKFpBLCB7XG4gICAgICBjaGlsZHJlbjogW28gJiYgLyogQF9fUFVSRV9fICovIHEuanN4KHJJLCB7XG4gICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gcS5qc3goc0ksIHt9KVxuICAgICAgfSksIHQuZnJhbWVzX3VybCAmJiAvKiBAX19QVVJFX18gKi8gcS5qc3hzKHEuRnJhZ21lbnQsIHtcbiAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3goXCJhXCIsIHtcbiAgICAgICAgICBocmVmOiB0LmZyYW1lc191cmwsXG4gICAgICAgICAgdGFyZ2V0OiBcIl9ibGFua1wiLFxuICAgICAgICAgIHJlbDogXCJub29wZW5lciBub3JlZmVycmVyXCIsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChKQSwge1xuICAgICAgICAgICAgc3JjOiB0LmltYWdlLFxuICAgICAgICAgICAgYWx0OiBgRnJhbWUgaW1hZ2UgZm9yICR7dC5mcmFtZXNfdXJsfWAsXG4gICAgICAgICAgICBzdHlsZTogZCgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSksICgoaCA9IHQuaW5wdXQpID09IG51bGwgPyB2b2lkIDAgOiBoLnRleHQpICYmIC8qIEBfX1BVUkVfXyAqLyBxLmpzeCh0SSwge1xuICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgIHBsYWNlaG9sZGVyOiB0LmlucHV0LnRleHQsXG4gICAgICAgICAgdmFsdWU6IG4sXG4gICAgICAgICAgb25DaGFuZ2U6IChmKSA9PiBjKGYudGFyZ2V0LnZhbHVlKVxuICAgICAgICB9KSwgbCgpXVxuICAgICAgfSldXG4gICAgfSksIHQuZnJhbWVzX3VybCAmJiAvKiBAX19QVVJFX18gKi8gcS5qc3goUUEsIHtcbiAgICAgIGNoaWxkcmVuOiB1KHQuZnJhbWVzX3VybClcbiAgICB9KV1cbiAgfSk7XG59XG5jb25zdCBvSSA9ICh7XG4gIGZyYW1lOiBzLFxuICBvbkZyYW1lQnRuUHJlc3M6IGVcbn0pID0+IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChlSSwge1xuICBjaGlsZHJlbjogcyA/IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChpSSwge1xuICAgIGZyYW1lOiBzLFxuICAgIG9uRnJhbWVCdG5QcmVzczogZVxuICB9KSA6IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChxLkZyYWdtZW50LCB7fSlcbn0pLCBhSSA9ICh7XG4gIHVybDogcyxcbiAgb25GcmFtZUJ0blByZXNzOiBlLFxuICBpbml0aWFsRnJhbWU6IHRcbn0pID0+IHtcbiAgY29uc3Qge1xuICAgIGNsaWVudF9pZDogcixcbiAgICBzaG93VG9hc3Q6IG5cbiAgfSA9IHRzKCksIFtpXSA9IGR1KGpuLk5FWU5BUl9BVVRIRU5USUNBVEVEX1VTRVIsIG51bGwpLCBbbywgYV0gPSBxZShudWxsKSwgW2wsIGNdID0gcWUodCB8fCBudWxsKSwgW3UsIGRdID0gcWUobnVsbCk7XG4gIGZ0KCgpID0+IHtcbiAgICBpID8gYShpLnNpZ25lcl91dWlkKSA6IGNvbnNvbGUud2FybihcIk5vIE5FWU5BUl9BVVRIRU5USUNBVEVEX1VTRVIgZm91bmQgaW4gbG9jYWwgc3RvcmFnZS5cIik7XG4gIH0sIFtpXSksIGZ0KCgpID0+IHtcbiAgICB0IHx8IChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB5ID0gYXdhaXQgbEkoYCR7b259L3YyL2ZhcmNhc3Rlci9mcmFtZS9jcmF3bD91cmw9JHtzfSZjbGllbnRfaWQ9JHtyfWAsIHtcbiAgICAgICAgICBtZXRob2Q6IFwiR0VUXCJcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh5Lm9rKSB7XG4gICAgICAgICAgY29uc3QgYiA9IChhd2FpdCB5Lmpzb24oKSkuZnJhbWU7XG4gICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGIpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGZyYW1lIGRhdGEgYXZhaWxhYmxlXCIpO1xuICAgICAgICAgIGMoYiksIGQobnVsbCk7XG4gICAgICAgIH0gZWxzZVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3kuc3RhdHVzfWApO1xuICAgICAgfSBjYXRjaCAoeSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBBbiBlcnJvciBvY2N1cnJlZDogJHt5fWApLCBkKGBGYWlsZWQgdG8gZmV0Y2g6ICR7eS5tZXNzYWdlfWApO1xuICAgICAgfVxuICAgIH0pKCk7XG4gIH0sIFtzLCBuLCB0XSk7XG4gIGNvbnN0IGggPSAocCkgPT4ge1xuICAgIGlmICh0eXBlb2YgcCAhPSBcIm9iamVjdFwiIHx8IHAgPT09IG51bGwpIHJldHVybiAhMTtcbiAgICBjb25zdCB5ID0gW1widmVyc2lvblwiLCBcImltYWdlXCIsIFwiYnV0dG9uc1wiLCBcImZyYW1lc191cmxcIl07XG4gICAgZm9yIChjb25zdCBFIG9mIHkpXG4gICAgICBpZiAoIShFIGluIHApKSByZXR1cm4gITE7XG4gICAgcmV0dXJuICEoIUFycmF5LmlzQXJyYXkocC5idXR0b25zKSB8fCBwLmJ1dHRvbnMuc29tZSgoRSkgPT4gdHlwZW9mIEUuaW5kZXggIT0gXCJudW1iZXJcIikpO1xuICB9LCBmID0gYXN5bmMgKHAsIHksIEUsIGIpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgUiA9IGF3YWl0IGUocCwgeSwgRSwgYik7XG4gICAgICBpZiAoIWgoUikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZnJhbWUgZGF0YSByZWNlaXZlZFwiKTtcbiAgICAgIEUoUik7XG4gICAgfSBjYXRjaCAoUikge1xuICAgICAgbih4Zy5FcnJvciwgYEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHByb2Nlc3NpbmcgdGhlIGJ1dHRvbiBwcmVzczogJHtSfWApO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHUgPyAvKiBAX19QVVJFX18gKi8gcS5qc3goXCJkaXZcIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBjb2xvcjogXCJyZWRcIixcbiAgICAgIHBhZGRpbmc6IFwiMTBweFwiLFxuICAgICAgYm9yZGVyOiBcIjFweCBzb2xpZCByZWRcIixcbiAgICAgIGJvcmRlclJhZGl1czogXCI1cHhcIlxuICAgIH0sXG4gICAgY2hpbGRyZW46IHVcbiAgfSkgOiAvKiBAX19QVVJFX18gKi8gcS5qc3gob0ksIHtcbiAgICBmcmFtZTogbCxcbiAgICBvbkZyYW1lQnRuUHJlc3M6IGZcbiAgfSk7XG59O1xuZnVuY3Rpb24gbEkocywgZSwgdCA9IDhlMykge1xuICByZXR1cm4gUHJvbWlzZS5yYWNlKFthbihzLCBlKSwgbmV3IFByb21pc2UoKHIsIG4pID0+IHNldFRpbWVvdXQoKCkgPT4gbihuZXcgRXJyb3IoXCJSZXF1ZXN0IHRpbWVkIG91dFwiKSksIHQpKV0pO1xufVxuZnVuY3Rpb24gcGYocykge1xuICBjb25zdCBlID0gTWF0aC5taW4ocywgMWU5KTtcbiAgcmV0dXJuIGUgPj0gMWU5ID8gTWF0aC5mbG9vcihlIC8gMWU4KSAvIDEwICsgXCJCXCIgOiBlID49IDFlNiA/IE1hdGguZmxvb3IoZSAvIDFlNSkgLyAxMCArIFwiTVwiIDogZSA+PSAxZTMgPyBNYXRoLmZsb29yKGUgLyAxMDApIC8gMTAgKyBcIktcIiA6IGUudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGNJKHMpIHtcbiAgaWYgKCFzKVxuICAgIHJldHVybiBjb25zb2xlLmVycm9yKFwiRXJyb3I6IFRpbWVzdGFtcCBpcyB1bmRlZmluZWQgb3IgZW1wdHkuXCIpLCBcIkludmFsaWQgdGltZXN0YW1wXCI7XG4gIGNvbnN0IGUgPSBuZXcgRGF0ZShzKTtcbiAgaWYgKGlzTmFOKGUuZ2V0VGltZSgpKSlcbiAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkVycm9yOiBJbnZhbGlkIHRpbWVzdGFtcCBwcm92aWRlZDpcIiwgcyksIFwiSW52YWxpZCB0aW1lc3RhbXBcIjtcbiAgY29uc3QgdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLCBuID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQodm9pZCAwLCB7XG4gICAgaG91cjogXCJudW1lcmljXCIsXG4gICAgbWludXRlOiBcIjItZGlnaXRcIixcbiAgICBob3VyMTI6ICEwXG4gIH0pLmZvcm1hdChlKS5yZXBsYWNlKFwiIFwiLCBcIlwiKSwgaSA9IHQudG9EYXRlU3RyaW5nKCkgPT09IGUudG9EYXRlU3RyaW5nKCksIG8gPSBuZXcgRGF0ZSh0LnNldERhdGUodC5nZXREYXRlKCkgLSAxKSkudG9EYXRlU3RyaW5nKCkgPT09IGUudG9EYXRlU3RyaW5nKCk7XG4gIGlmIChpKVxuICAgIHJldHVybiBgJHtufSwgdG9kYXlgO1xuICBpZiAobylcbiAgICByZXR1cm4gYCR7bn0sIHllc3RlcmRheWA7XG4gIGNvbnN0IGEgPSBbXCJKYW5cIiwgXCJGZWJcIiwgXCJNYXJcIiwgXCJBcHJcIiwgXCJNYXlcIiwgXCJKdW5cIiwgXCJKdWxcIiwgXCJBdWdcIiwgXCJTZXBcIiwgXCJPY3RcIiwgXCJOb3ZcIiwgXCJEZWNcIl0sIGwgPSBlLmdldERhdGUoKSwgYyA9IGFbZS5nZXRNb250aCgpXSwgdSA9IGUuZ2V0RnVsbFllYXIoKSwgaCA9IGAke2N9ICR7KChmKSA9PiB7XG4gICAgaWYgKGYgPiAzICYmIGYgPCAyMSkgcmV0dXJuIGAke2Z9dGhgO1xuICAgIGNvbnN0IHAgPSBbXCJzdFwiLCBcIm5kXCIsIFwicmRcIl0sIHkgPSBmICUgMTA7XG4gICAgcmV0dXJuIGAke2Z9JHtwW3kgLSAxXSB8fCBcInRoXCJ9YDtcbiAgfSkobCl9ICR7dX1gO1xuICByZXR1cm4gYCR7bn0sICR7aH1gO1xufVxuY29uc3QgdUkgPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJzeHF2eHZxXCJdXG59KSwgZEkgPSAvKiBAX19QVVJFX18gKi8gZGUoXCJhXCIpKHtcbiAgY2xhc3NlczogW1wiczNrYW1vdlwiXVxufSksIGhJID0gLyogQF9fUFVSRV9fICovIGRlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wibTF3cnZ2aGtcIl1cbn0pLCBmSSA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInQxbGNhcTI3XCJdXG59KSwgZ0kgPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJ1Z3RwMXdoXCJdXG59KSwgcEkgPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJsMWRxcG40ZVwiXVxufSksIG1JID0gLyogQF9fUFVSRV9fICovIGRlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wibDFiam52MnRcIl1cbn0pLCBtZiA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcImUxNXlmMTIzXCJdXG59KSwgeUkgPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJyeHJhOTRnXCJdXG59KSwgeWYgPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJzMXdoZ3Fyc1wiXVxufSksIHZJID0gLyogQF9fUFVSRV9fICovIGRlKFwicFwiKSh7XG4gIGNsYXNzZXM6IFtcImR6OG1hcmZcIl1cbn0pLCBvYSA9IHN0Lm1lbW8oKHtcbiAgdXNlcm5hbWU6IHMsXG4gIGRpc3BsYXlOYW1lOiBlLFxuICBhdmF0YXJJbWdVcmw6IHQsXG4gIHRleHQ6IHIgPSBcIlwiLFxuICBoYXNoOiBuLFxuICByZWFjdGlvbnM6IGksXG4gIHJlcGxpZXM6IG8sXG4gIGVtYmVkczogYSA9IFtdLFxuICBmcmFtZXM6IGwgPSBbXSxcbiAgY2hhbm5lbDogYyxcbiAgdmlld2VyRmlkOiB1LFxuICBoYXNQb3dlckJhZGdlOiBkLFxuICBpc0VtYmVkOiBoID0gITAsXG4gIGFsbG93UmVhY3Rpb25zOiBmLFxuICByZW5kZXJFbWJlZHM6IHAsXG4gIHJlbmRlckZyYW1lczogeSxcbiAgb25MaWtlQnRuUHJlc3M6IEUsXG4gIG9uUmVjYXN0QnRuUHJlc3M6IGIsXG4gIG9uQ29tbWVudEJ0blByZXNzOiBSLFxuICBvbkZyYW1lQnRuUHJlc3M6IEEsXG4gIGRpcmVjdF9yZXBsaWVzOiBGLFxuICBjb250YWluZXJTdHlsZXM6IE0sXG4gIHRleHRTdHlsZXM6IEgsXG4gIHRpbWVzdGFtcDogSyxcbiAgYXBwQXZhdGFySW1nVXJsOiBqXG59KSA9PiB7XG4gIGNvbnN0IFtDLCBrXSA9IHFlKGkubGlrZXNfY291bnQpLCBbJCwgV10gPSBxZShpLmxpa2VzLnNvbWUoKFYpID0+IFYuZmlkID09PSB1KSksIF8gPSAvKiBAX19QVVJFX18gKi8gcS5qc3gobUksIHtcbiAgICBjaGlsZHJlbjogRVMociwgYSlcbiAgfSksIGcgPSAoYSA9PSBudWxsID8gdm9pZCAwIDogYS5sZW5ndGgpID09PSAxLCB4ID0gWnIoKCkgPT4gbC5tYXAoKFYpID0+IFYuZnJhbWVzX3VybCksIFtsXSksIHcgPSBacigoKSA9PiBhLmZpbHRlcigoVikgPT4gIXguaW5jbHVkZXMoVi51cmwpKSwgW2EsIHhdKSwgRCA9IHV0KChWKSA9PiB7XG4gICAgVi5jdXJyZW50VGFyZ2V0LnNyYyA9IGJpO1xuICB9LCBbXSk7XG4gIGZ0KCgpID0+IHtcbiAgICBXKGkubGlrZXMuc29tZSgoVikgPT4gVi5maWQgPT09IHUpKTtcbiAgfSwgW2kubGlrZXMsIHVdKTtcbiAgY29uc3QgTyA9IHV0KCgpID0+IEUgJiYgRSgpID8gKGsoKEwpID0+IEwgKyAxKSwgVyghJCksICEwKSA6ICExLCBbRV0pLCBVID0gT0EodywgZiwgdSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gcS5qc3godUksIHtcbiAgICBzdHlsZToge1xuICAgICAgLi4uTSxcbiAgICAgIGJvcmRlcldpZHRoOiBoID8gXCIxcHhcIiA6IFwiMFwiXG4gICAgfSxcbiAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHEuanN4cyhQciwge1xuICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3goSXIsIHtcbiAgICAgICAgc3BhY2luZ1JpZ2h0OiBcIjEwcHhcIixcbiAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChZbywge1xuICAgICAgICAgIHNyYzogdCAmJiB0Lmxlbmd0aCA+IDAgPyB0IDogYmksXG4gICAgICAgICAgd2lkdGg6IFwiMjBweFwiLFxuICAgICAgICAgIGhlaWdodDogXCIyMHB4XCIsXG4gICAgICAgICAgb25FcnJvcjogRCxcbiAgICAgICAgICBsb2FkaW5nOiBcImxhenlcIixcbiAgICAgICAgICBhbHQ6IGAke2UgPz8gXCJTa2VsZXRvblwifSBBdmF0YXJgXG4gICAgICAgIH0pXG4gICAgICB9KSwgLyogQF9fUFVSRV9fICovIHEuanN4cyhoSSwge1xuICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoUHIsIHtcbiAgICAgICAgICBmbGV4R3JvdzogMSxcbiAgICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIHEuanN4cyhQciwge1xuICAgICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3godkksIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IGVcbiAgICAgICAgICAgIH0pLCBcIiBcIiwgaiAmJiAvKiBAX19QVVJFX18gKi8gcS5qc3goSXIsIHtcbiAgICAgICAgICAgICAgc3BhY2luZ0xlZnQ6IFwiNXB4XCIsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gcS5qc3goXCJpbWdcIiwge1xuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICBwYWRkaW5nOiBcIjJweFwiLFxuICAgICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IFwiMC41cHhcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImJvcmRlci13aGl0ZSByb3VuZGVkLWZ1bGxcIixcbiAgICAgICAgICAgICAgICBzcmM6IGosXG4gICAgICAgICAgICAgICAgd2lkdGg6IFwiMThcIixcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiMThcIixcbiAgICAgICAgICAgICAgICBvbkVycm9yOiAoVikgPT4ge1xuICAgICAgICAgICAgICAgICAgVi5jdXJyZW50VGFyZ2V0LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KV1cbiAgICAgICAgICB9KSwgLyogQF9fUFVSRV9fICovIHEuanN4cyhQciwge1xuICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIHEuanN4cyhnSSwge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogW1wiQFwiLCBzLCBcIiDCt1wiXVxuICAgICAgICAgICAgfSksIFwiIFwiLCAvKiBAX19QVVJFX18gKi8gcS5qc3goZkksIHtcbiAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogXCIjOTk5OTk5XCIsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IFwiMTRweFwiLFxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6IFwiV29yayBTYW5zXCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IGNJKEspXG4gICAgICAgICAgICB9KV1cbiAgICAgICAgICB9KV1cbiAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChJciwge1xuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBtYXJnaW5Ub3A6IFwiMTBweFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHEuanN4KHBJLCB7XG4gICAgICAgICAgICBzdHlsZTogSCxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBfXG4gICAgICAgICAgfSlcbiAgICAgICAgfSksIHAgJiYgdyAmJiB3Lmxlbmd0aCA+IDAgPyAvKiBAX19QVVJFX18gKi8gcS5qc3gobWYsIHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgbWFyZ2luOiBnID8gXCI0cHggMFwiIDogXCIwXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIGNoaWxkcmVuOiBVLm1hcCgoViwgTCkgPT4gLyogQF9fUFVSRV9fICovIHEuanN4KFwiZGl2XCIsIHtcbiAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgIHdpZHRoOiBcIjEwMCVcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBWXG4gICAgICAgICAgfSwgTCkpXG4gICAgICAgIH0pIDogLyogQF9fUFVSRV9fICovIHEuanN4KHEuRnJhZ21lbnQsIHt9KSwgeSAmJiBsICYmIGwubGVuZ3RoID4gMCA/IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChtZiwge1xuICAgICAgICAgIGNoaWxkcmVuOiBsLm1hcCgoVikgPT4gLyogQF9fUFVSRV9fICovIHEuanN4KGFJLCB7XG4gICAgICAgICAgICB1cmw6IFYuZnJhbWVzX3VybCxcbiAgICAgICAgICAgIGluaXRpYWxGcmFtZTogVixcbiAgICAgICAgICAgIG9uRnJhbWVCdG5QcmVzczogQVxuICAgICAgICAgIH0sIFYuZnJhbWVzX3VybCkpXG4gICAgICAgIH0pIDogbnVsbCwgLyogQF9fUFVSRV9fICovIHEuanN4cyh5SSwge1xuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogZiA/IFwic3BhY2UtYmV0d2VlblwiIDogXCJmbGV4LWVuZFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlbjogW2YgJiYgLyogQF9fUFVSRV9fICovIHEuanN4KEhBLCB7XG4gICAgICAgICAgICBoYXNoOiBuLFxuICAgICAgICAgICAgcmVhY3Rpb25zOiBpLFxuICAgICAgICAgICAgb25Db21tZW50OiBSLFxuICAgICAgICAgICAgb25SZWNhc3Q6IGIsXG4gICAgICAgICAgICBvbkxpa2U6IE8sXG4gICAgICAgICAgICBpc0xpa2VkOiAkXG4gICAgICAgICAgfSksIGYgJiYgcyAmJiBuICYmIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChJYywge1xuICAgICAgICAgICAgdXJsOiBgaHR0cHM6Ly9mYXJjYXN0ZXIueHl6LyR7c30vJHtuLnNsaWNlKDAsIDEwKX1gXG4gICAgICAgICAgfSldXG4gICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gcS5qc3hzKHlmLCB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiBmID8gXCJcIiA6IFwic3BhY2UtYmV0d2VlblwiLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiBcIjEwcHhcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3hzKHlmLCB7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogZiA/IFwiXCIgOiBcInNwYWNlLWJldHdlZW5cIixcbiAgICAgICAgICAgICAgZ2FwOiA2XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3hzKFwiZGl2XCIsIHtcbiAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgICAgICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgICAgIGdhcDogXCI0cHhcIixcbiAgICAgICAgICAgICAgICBjb2xvcjogXCIjOTk5OTk5XCJcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3godG0sIHt9KSwgb11cbiAgICAgICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gcS5qc3goXCJkaXZcIiwge1xuICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIHBhZGRpbmc6IFwiMHB4IDEwcHhcIlxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgLyogQF9fUFVSRV9fICovIHEuanN4cyhcImRpdlwiLCB7XG4gICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICAgICAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAgICAgICAgICAgICAgICBnYXA6IFwiNHB4XCIsXG4gICAgICAgICAgICAgICAgY29sb3I6IFwiIzk5OTk5OVwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIHEuanN4KHJtLCB7fSksIFwiIFwiLCBDXVxuICAgICAgICAgICAgfSksIGMgJiYgLyogQF9fUFVSRV9fICovIHEuanN4cyhxLkZyYWdtZW50LCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIHEuanN4KFwiZGl2XCIsIHt9KSwgLyogQF9fUFVSRV9fICovIHEuanN4cyhkSSwge1xuICAgICAgICAgICAgICAgIGhyZWY6IGBodHRwczovL2ZhcmNhc3Rlci54eXovfi9jaGFubmVsLyR7Yy5pZH1gLFxuICAgICAgICAgICAgICAgIHRhcmdldDogXCJfYmxhbmtcIixcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW1wiL1wiLCBjLmlkXVxuICAgICAgICAgICAgICB9KV1cbiAgICAgICAgICAgIH0pXVxuICAgICAgICAgIH0pLCAhZiAmJiBzICYmIG4gJiYgLyogQF9fUFVSRV9fICovIHEuanN4KEljLCB7XG4gICAgICAgICAgICB1cmw6IGBodHRwczovL2ZhcmNhc3Rlci54eXovJHtzfS8ke24uc2xpY2UoMCwgMTApfWBcbiAgICAgICAgICB9KV1cbiAgICAgICAgfSldXG4gICAgICB9KV1cbiAgICB9KVxuICB9KTtcbn0pLCBFSSA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInMxbTZvYjFhXCJdXG59KSwgdmYgPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJyMWVzZXZjN1wiXVxufSksIEVmID0gLyogQF9fUFVSRV9fICovIGRlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1widnhiMWYwMFwiXVxufSksIHhJID0gLyogQF9fUFVSRV9fICovIGRlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wiaHR2MHF6N1wiXVxufSksIHhmID0gLyogQF9fUFVSRV9fICovIGRlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wicnprc3kyXCJdXG59KTtcbmZ1bmN0aW9uIFNJKHMpIHtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChFSSwge1xuICAgIGNoaWxkcmVuOiBzLmNhc3RzLm1hcCgoZSwgdCkgPT4gLyogQF9fUFVSRV9fICovIHEuanN4cyh2Ziwge1xuICAgICAgY2hpbGRyZW46IFt0ICE9PSAwICYmIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChFZiwge1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGxlZnQ6IFwiNDJweFwiXG4gICAgICAgIH1cbiAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gcS5qc3hzKHhmLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIHEuanN4KG9hLCB7XG4gICAgICAgICAgaXNFbWJlZDogITEsXG4gICAgICAgICAgLi4uZVxuICAgICAgICB9KSwgdCA9PT0gMCAmJiAvKiBAX19QVVJFX18gKi8gcS5qc3goeEksIHt9KSwgZS5kaXJlY3RfcmVwbGllcyAmJiBlLmRpcmVjdF9yZXBsaWVzLmxlbmd0aCA+IDAgJiYgZS5kaXJlY3RfcmVwbGllcy5tYXAoKHIsIG4pID0+IC8qIEBfX1BVUkVfXyAqLyBxLmpzeHModmYsIHtcbiAgICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBxLmpzeChFZiwge1xuICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgbGVmdDogXCI0MnB4XCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgLyogQF9fUFVSRV9fICovIHEuanN4KHhmLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHEuanN4KG9hLCB7XG4gICAgICAgICAgICAgIGlzRW1iZWQ6ICExLFxuICAgICAgICAgICAgICAuLi5yXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXVxuICAgICAgICB9LCBuKSldXG4gICAgICB9KV1cbiAgICB9LCB0KSlcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBiSSh7XG4gIHR5cGU6IHMsXG4gIGlkZW50aWZpZXI6IGUsXG4gIHJlcGx5RGVwdGg6IHQgPSAyLFxuICBpbmNsdWRlQ2hyb25vbG9naWNhbFBhcmVudENhc3RzOiByID0gITEsXG4gIGxpbWl0OiBuID0gMjAsXG4gIHZpZXdlckZpZDogaSxcbiAgY2xpZW50SWQ6IG9cbn0pIHtcbiAgdHJ5IHtcbiAgICBsZXQgYSA9IGAke29ufS92Mi9mYXJjYXN0ZXIvY2FzdC9jb252ZXJzYXRpb24/aWRlbnRpZmllcj0ke2VuY29kZVVSSUNvbXBvbmVudChlKX0mdHlwZT0ke3N9JnJlcGx5X2RlcHRoPSR7dH0maW5jbHVkZV9jaHJvbm9sb2dpY2FsX3BhcmVudF9jYXN0cz0ke3J9JmxpbWl0PSR7bn0mY2xpZW50X2lkPSR7b31gO1xuICAgIHJldHVybiBpICYmIChhICs9IGAmdmlld2VyX2ZpZD0ke2l9YCksIGF3YWl0IChhd2FpdCBhbihhLCB7XG4gICAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIGFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgIH1cbiAgICB9KSkuanNvbigpIHx8IG51bGw7XG4gIH0gY2F0Y2ggKGEpIHtcbiAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGNvbnZlcnNhdGlvblwiLCBhKSwgbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gbm0ocykge1xuICByZXR1cm4ge1xuICAgIHVzZXJuYW1lOiBzLmF1dGhvci51c2VybmFtZSxcbiAgICBkaXNwbGF5TmFtZTogcy5hdXRob3IuZGlzcGxheV9uYW1lLFxuICAgIGF2YXRhckltZ1VybDogcy5hdXRob3IucGZwX3VybCxcbiAgICB0ZXh0OiBzLnRleHQsXG4gICAgaGFzaDogcy5oYXNoLFxuICAgIHJlYWN0aW9uczogcy5yZWFjdGlvbnMsXG4gICAgcmVwbGllczogcy5yZXBsaWVzLmNvdW50LFxuICAgIGVtYmVkczogcy5lbWJlZHMsXG4gICAgZnJhbWVzOiBzLmZyYW1lcyxcbiAgICByZW5kZXJFbWJlZHM6IHMucmVuZGVyRW1iZWRzLFxuICAgIGNoYW5uZWw6IHMuY2hhbm5lbCxcbiAgICB2aWV3ZXJGaWQ6IDIsXG4gICAgaGFzUG93ZXJCYWRnZTogcy5hdXRob3IucG93ZXJfYmFkZ2UsXG4gICAgYXBwQXZhdGFySW1nVXJsOiBzLmFwcC5wZnBfdXJsLFxuICAgIGlzT3duUHJvZmlsZTogITEsXG4gICAgYWxsb3dSZWFjdGlvbnM6ICEwLFxuICAgIHJlbmRlckZyYW1lczogITEsXG4gICAgZGlyZWN0X3JlcGxpZXM6IHMuZGlyZWN0X3JlcGxpZXMgPyBzLmRpcmVjdF9yZXBsaWVzLm1hcChubSkgOiBbXSxcbiAgICB0aW1lc3RhbXA6IHMudGltZXN0YW1wXG4gIH07XG59XG5mdW5jdGlvbiBUSShzKSB7XG4gIGNvbnN0IGUgPSBbXTtcbiAgcmV0dXJuIHMuY2FzdCAmJiBlLnB1c2gobm0ocy5jYXN0KSksIGU7XG59XG5jb25zdCBtUiA9ICh7XG4gIHR5cGU6IHMsXG4gIGlkZW50aWZpZXI6IGUsXG4gIHJlcGx5RGVwdGg6IHQgPSAyLFxuICBpbmNsdWRlQ2hyb25vbG9naWNhbFBhcmVudENhc3RzOiByID0gITEsXG4gIGxpbWl0OiBuID0gMjAsXG4gIHZpZXdlckZpZDogaVxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgY2xpZW50X2lkOiBvXG4gIH0gPSB0cygpLCBbYSwgbF0gPSBzdC51c2VTdGF0ZShudWxsKSwgW2MsIHVdID0gc3QudXNlU3RhdGUoITApLCBbZCwgaF0gPSBzdC51c2VTdGF0ZShudWxsKTtcbiAgcmV0dXJuIHN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdSghMCksIGgobnVsbCksIGJJKHtcbiAgICAgIHR5cGU6IHMsXG4gICAgICBpZGVudGlmaWVyOiBlLFxuICAgICAgcmVwbHlEZXB0aDogdCxcbiAgICAgIGluY2x1ZGVDaHJvbm9sb2dpY2FsUGFyZW50Q2FzdHM6IHIsXG4gICAgICBsaW1pdDogbixcbiAgICAgIHZpZXdlckZpZDogaSxcbiAgICAgIGNsaWVudElkOiBvXG4gICAgfSkudGhlbigoZikgPT4ge1xuICAgICAgbChmKTtcbiAgICB9KS5jYXRjaCgoZikgPT4ge1xuICAgICAgaChmKTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHUoITEpO1xuICAgIH0pO1xuICB9LCBbcywgZSwgdCwgciwgbiwgaSwgb10pLCBjID8gLyogQF9fUFVSRV9fICovIHEuanN4KHEuRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogXCIgXCJcbiAgfSkgOiBkID8gLyogQF9fUFVSRV9fICovIHEuanN4KHEuRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogXCIgXCJcbiAgfSkgOiAvKiBAX19QVVJFX18gKi8gcS5qc3goU0ksIHtcbiAgICBjYXN0czogVEkoYS5jb252ZXJzYXRpb24pXG4gIH0pO1xufTtcbnZhciBPbCA9IHsgZXhwb3J0czoge30gfSwgQmwgPSB7fTtcbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0ucHJvZHVjdGlvbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbnZhciBTZjtcbmZ1bmN0aW9uIHdJKCkge1xuICBpZiAoU2YpIHJldHVybiBCbDtcbiAgU2YgPSAxO1xuICB2YXIgcyA9IHN0O1xuICBmdW5jdGlvbiBlKGQsIGgpIHtcbiAgICByZXR1cm4gZCA9PT0gaCAmJiAoZCAhPT0gMCB8fCAxIC8gZCA9PT0gMSAvIGgpIHx8IGQgIT09IGQgJiYgaCAhPT0gaDtcbiAgfVxuICB2YXIgdCA9IHR5cGVvZiBPYmplY3QuaXMgPT0gXCJmdW5jdGlvblwiID8gT2JqZWN0LmlzIDogZSwgciA9IHMudXNlU3RhdGUsIG4gPSBzLnVzZUVmZmVjdCwgaSA9IHMudXNlTGF5b3V0RWZmZWN0LCBvID0gcy51c2VEZWJ1Z1ZhbHVlO1xuICBmdW5jdGlvbiBhKGQsIGgpIHtcbiAgICB2YXIgZiA9IGgoKSwgcCA9IHIoeyBpbnN0OiB7IHZhbHVlOiBmLCBnZXRTbmFwc2hvdDogaCB9IH0pLCB5ID0gcFswXS5pbnN0LCBFID0gcFsxXTtcbiAgICByZXR1cm4gaShcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICB5LnZhbHVlID0gZiwgeS5nZXRTbmFwc2hvdCA9IGgsIGwoeSkgJiYgRSh7IGluc3Q6IHkgfSk7XG4gICAgICB9LFxuICAgICAgW2QsIGYsIGhdXG4gICAgKSwgbihcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbCh5KSAmJiBFKHsgaW5zdDogeSB9KSwgZChmdW5jdGlvbigpIHtcbiAgICAgICAgICBsKHkpICYmIEUoeyBpbnN0OiB5IH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBbZF1cbiAgICApLCBvKGYpLCBmO1xuICB9XG4gIGZ1bmN0aW9uIGwoZCkge1xuICAgIHZhciBoID0gZC5nZXRTbmFwc2hvdDtcbiAgICBkID0gZC52YWx1ZTtcbiAgICB0cnkge1xuICAgICAgdmFyIGYgPSBoKCk7XG4gICAgICByZXR1cm4gIXQoZCwgZik7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gITA7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGMoZCwgaCkge1xuICAgIHJldHVybiBoKCk7XG4gIH1cbiAgdmFyIHUgPSB0eXBlb2Ygd2luZG93ID4gXCJ1XCIgfHwgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCA+IFwidVwiIHx8IHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCA+IFwidVwiID8gYyA6IGE7XG4gIHJldHVybiBCbC51c2VTeW5jRXh0ZXJuYWxTdG9yZSA9IHMudXNlU3luY0V4dGVybmFsU3RvcmUgIT09IHZvaWQgMCA/IHMudXNlU3luY0V4dGVybmFsU3RvcmUgOiB1LCBCbDtcbn1cbnZhciBiZjtcbmZ1bmN0aW9uIEFJKCkge1xuICByZXR1cm4gYmYgfHwgKGJmID0gMSwgT2wuZXhwb3J0cyA9IHdJKCkpLCBPbC5leHBvcnRzO1xufVxudmFyIGltID0gQUkoKTtcbmNvbnN0IG9tID0gMCwgYW0gPSAxLCBsbSA9IDIsIFRmID0gMztcbnZhciB3ZiA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5mdW5jdGlvbiBfYyhzLCBlKSB7XG4gIHZhciB0LCByO1xuICBpZiAocyA9PT0gZSkgcmV0dXJuICEwO1xuICBpZiAocyAmJiBlICYmICh0ID0gcy5jb25zdHJ1Y3RvcikgPT09IGUuY29uc3RydWN0b3IpIHtcbiAgICBpZiAodCA9PT0gRGF0ZSkgcmV0dXJuIHMuZ2V0VGltZSgpID09PSBlLmdldFRpbWUoKTtcbiAgICBpZiAodCA9PT0gUmVnRXhwKSByZXR1cm4gcy50b1N0cmluZygpID09PSBlLnRvU3RyaW5nKCk7XG4gICAgaWYgKHQgPT09IEFycmF5KSB7XG4gICAgICBpZiAoKHIgPSBzLmxlbmd0aCkgPT09IGUubGVuZ3RoKVxuICAgICAgICBmb3IgKDsgci0tICYmIF9jKHNbcl0sIGVbcl0pOyApIDtcbiAgICAgIHJldHVybiByID09PSAtMTtcbiAgICB9XG4gICAgaWYgKCF0IHx8IHR5cGVvZiBzID09IFwib2JqZWN0XCIpIHtcbiAgICAgIHIgPSAwO1xuICAgICAgZm9yICh0IGluIHMpXG4gICAgICAgIGlmICh3Zi5jYWxsKHMsIHQpICYmICsrciAmJiAhd2YuY2FsbChlLCB0KSB8fCAhKHQgaW4gZSkgfHwgIV9jKHNbdF0sIGVbdF0pKSByZXR1cm4gITE7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoZSkubGVuZ3RoID09PSByO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcyAhPT0gcyAmJiBlICE9PSBlO1xufVxuY29uc3QgcXIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgQ3MgPSAoKSA9PiB7XG59LCBxdCA9IChcbiAgLyojX19OT0lOTElORV9fKi9cbiAgQ3MoKVxuKSwgUmMgPSBPYmplY3QsICRlID0gKHMpID0+IHMgPT09IHF0LCBNciA9IChzKSA9PiB0eXBlb2YgcyA9PSBcImZ1bmN0aW9uXCIsIEJzID0gKHMsIGUpID0+ICh7XG4gIC4uLnMsXG4gIC4uLmVcbn0pLCBjbSA9IChzKSA9PiBNcihzLnRoZW4pLCBGbCA9IHt9LCBvbyA9IHt9LCBGdSA9IFwidW5kZWZpbmVkXCIsIFBpID0gdHlwZW9mIHdpbmRvdyAhPSBGdSwgTGMgPSB0eXBlb2YgZG9jdW1lbnQgIT0gRnUsIElJID0gUGkgJiYgXCJEZW5vXCIgaW4gd2luZG93LCBfSSA9ICgpID0+IFBpICYmIHR5cGVvZiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9IEZ1LCBfcyA9IChzLCBlKSA9PiB7XG4gIGNvbnN0IHQgPSBxci5nZXQocyk7XG4gIHJldHVybiBbXG4gICAgLy8gR2V0dGVyXG4gICAgKCkgPT4gISRlKGUpICYmIHMuZ2V0KGUpIHx8IEZsLFxuICAgIC8vIFNldHRlclxuICAgIChyKSA9PiB7XG4gICAgICBpZiAoISRlKGUpKSB7XG4gICAgICAgIGNvbnN0IG4gPSBzLmdldChlKTtcbiAgICAgICAgZSBpbiBvbyB8fCAob29bZV0gPSBuKSwgdFs1XShlLCBCcyhuLCByKSwgbiB8fCBGbCk7XG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBTdWJzY3JpYmVyXG4gICAgdFs2XSxcbiAgICAvLyBHZXQgc2VydmVyIGNhY2hlIHNuYXBzaG90XG4gICAgKCkgPT4gISRlKGUpICYmIGUgaW4gb28gPyBvb1tlXSA6ICEkZShlKSAmJiBzLmdldChlKSB8fCBGbFxuICBdO1xufTtcbmxldCBDYyA9ICEwO1xuY29uc3QgUkkgPSAoKSA9PiBDYywgW2tjLCBEY10gPSBQaSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciA/IFtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIuYmluZCh3aW5kb3cpLFxuICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKHdpbmRvdylcbl0gOiBbXG4gIENzLFxuICBDc1xuXSwgTEkgPSAoKSA9PiB7XG4gIGNvbnN0IHMgPSBMYyAmJiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGU7XG4gIHJldHVybiAkZShzKSB8fCBzICE9PSBcImhpZGRlblwiO1xufSwgQ0kgPSAocykgPT4gKExjICYmIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHMpLCBrYyhcImZvY3VzXCIsIHMpLCAoKSA9PiB7XG4gIExjICYmIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHMpLCBEYyhcImZvY3VzXCIsIHMpO1xufSksIGtJID0gKHMpID0+IHtcbiAgY29uc3QgZSA9ICgpID0+IHtcbiAgICBDYyA9ICEwLCBzKCk7XG4gIH0sIHQgPSAoKSA9PiB7XG4gICAgQ2MgPSAhMTtcbiAgfTtcbiAgcmV0dXJuIGtjKFwib25saW5lXCIsIGUpLCBrYyhcIm9mZmxpbmVcIiwgdCksICgpID0+IHtcbiAgICBEYyhcIm9ubGluZVwiLCBlKSwgRGMoXCJvZmZsaW5lXCIsIHQpO1xuICB9O1xufSwgREkgPSB7XG4gIGlzT25saW5lOiBSSSxcbiAgaXNWaXNpYmxlOiBMSVxufSwgUEkgPSB7XG4gIGluaXRGb2N1czogQ0ksXG4gIGluaXRSZWNvbm5lY3Q6IGtJXG59LCBBZiA9ICFzdC51c2VJZCwgVGkgPSAhUGkgfHwgSUksIE1JID0gKHMpID0+IF9JKCkgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHMpIDogc2V0VGltZW91dChzLCAxKSwgU28gPSBUaSA/IGZ0IDogRW0sIE5sID0gdHlwZW9mIG5hdmlnYXRvciA8IFwidVwiICYmIG5hdmlnYXRvci5jb25uZWN0aW9uLCBJZiA9ICFUaSAmJiBObCAmJiAoW1xuICBcInNsb3ctMmdcIixcbiAgXCIyZ1wiXG5dLmluY2x1ZGVzKE5sLmVmZmVjdGl2ZVR5cGUpIHx8IE5sLnNhdmVEYXRhKSwgYW8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgT0kgPSAocykgPT4gUmMucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocyksIFVsID0gKHMsIGUpID0+IHMgPT09IGBbb2JqZWN0ICR7ZX1dYDtcbmxldCBCSSA9IDA7XG5jb25zdCBQYyA9IChzKSA9PiB7XG4gIGNvbnN0IGUgPSB0eXBlb2YgcywgdCA9IE9JKHMpLCByID0gVWwodCwgXCJEYXRlXCIpLCBuID0gVWwodCwgXCJSZWdFeHBcIiksIGkgPSBVbCh0LCBcIk9iamVjdFwiKTtcbiAgbGV0IG8sIGE7XG4gIGlmIChSYyhzKSA9PT0gcyAmJiAhciAmJiAhbikge1xuICAgIGlmIChvID0gYW8uZ2V0KHMpLCBvKSByZXR1cm4gbztcbiAgICBpZiAobyA9ICsrQkkgKyBcIn5cIiwgYW8uc2V0KHMsIG8pLCBBcnJheS5pc0FycmF5KHMpKSB7XG4gICAgICBmb3IgKG8gPSBcIkBcIiwgYSA9IDA7IGEgPCBzLmxlbmd0aDsgYSsrKVxuICAgICAgICBvICs9IFBjKHNbYV0pICsgXCIsXCI7XG4gICAgICBhby5zZXQocywgbyk7XG4gICAgfVxuICAgIGlmIChpKSB7XG4gICAgICBvID0gXCIjXCI7XG4gICAgICBjb25zdCBsID0gUmMua2V5cyhzKS5zb3J0KCk7XG4gICAgICBmb3IgKDsgISRlKGEgPSBsLnBvcCgpKTsgKVxuICAgICAgICAkZShzW2FdKSB8fCAobyArPSBhICsgXCI6XCIgKyBQYyhzW2FdKSArIFwiLFwiKTtcbiAgICAgIGFvLnNldChzLCBvKTtcbiAgICB9XG4gIH0gZWxzZVxuICAgIG8gPSByID8gcy50b0pTT04oKSA6IGUgPT0gXCJzeW1ib2xcIiA/IHMudG9TdHJpbmcoKSA6IGUgPT0gXCJzdHJpbmdcIiA/IEpTT04uc3RyaW5naWZ5KHMpIDogXCJcIiArIHM7XG4gIHJldHVybiBvO1xufSwgd2kgPSAocykgPT4ge1xuICBpZiAoTXIocykpXG4gICAgdHJ5IHtcbiAgICAgIHMgPSBzKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBzID0gXCJcIjtcbiAgICB9XG4gIGNvbnN0IGUgPSBzO1xuICByZXR1cm4gcyA9IHR5cGVvZiBzID09IFwic3RyaW5nXCIgPyBzIDogKEFycmF5LmlzQXJyYXkocykgPyBzLmxlbmd0aCA6IHMpID8gUGMocykgOiBcIlwiLCBbXG4gICAgcyxcbiAgICBlXG4gIF07XG59O1xubGV0IEZJID0gMDtcbmNvbnN0IE1jID0gKCkgPT4gKytGSTtcbmFzeW5jIGZ1bmN0aW9uIHVtKC4uLnMpIHtcbiAgY29uc3QgW2UsIHQsIHIsIG5dID0gcywgaSA9IEJzKHtcbiAgICBwb3B1bGF0ZUNhY2hlOiAhMCxcbiAgICB0aHJvd09uRXJyb3I6ICEwXG4gIH0sIHR5cGVvZiBuID09IFwiYm9vbGVhblwiID8ge1xuICAgIHJldmFsaWRhdGU6IG5cbiAgfSA6IG4gfHwge30pO1xuICBsZXQgbyA9IGkucG9wdWxhdGVDYWNoZTtcbiAgY29uc3QgYSA9IGkucm9sbGJhY2tPbkVycm9yO1xuICBsZXQgbCA9IGkub3B0aW1pc3RpY0RhdGE7XG4gIGNvbnN0IGMgPSAoaCkgPT4gdHlwZW9mIGEgPT0gXCJmdW5jdGlvblwiID8gYShoKSA6IGEgIT09ICExLCB1ID0gaS50aHJvd09uRXJyb3I7XG4gIGlmIChNcih0KSkge1xuICAgIGNvbnN0IGggPSB0LCBmID0gW10sIHAgPSBlLmtleXMoKTtcbiAgICBmb3IgKGNvbnN0IHkgb2YgcClcbiAgICAgIC8vIFNraXAgdGhlIHNwZWNpYWwgdXNlU1dSSW5maW5pdGUgYW5kIHVzZVNXUlN1YnNjcmlwdGlvbiBrZXlzLlxuICAgICAgIS9eXFwkKGluZnxzdWIpXFwkLy50ZXN0KHkpICYmIGgoZS5nZXQoeSkuX2spICYmIGYucHVzaCh5KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoZi5tYXAoZCkpO1xuICB9XG4gIHJldHVybiBkKHQpO1xuICBhc3luYyBmdW5jdGlvbiBkKGgpIHtcbiAgICBjb25zdCBbZl0gPSB3aShoKTtcbiAgICBpZiAoIWYpIHJldHVybjtcbiAgICBjb25zdCBbcCwgeV0gPSBfcyhlLCBmKSwgW0UsIGIsIFIsIEFdID0gcXIuZ2V0KGUpLCBGID0gKCkgPT4ge1xuICAgICAgY29uc3QgZyA9IEVbZl07XG4gICAgICByZXR1cm4gKE1yKGkucmV2YWxpZGF0ZSkgPyBpLnJldmFsaWRhdGUocCgpLmRhdGEsIGgpIDogaS5yZXZhbGlkYXRlICE9PSAhMSkgJiYgKGRlbGV0ZSBSW2ZdLCBkZWxldGUgQVtmXSwgZyAmJiBnWzBdKSA/IGdbMF0obG0pLnRoZW4oKCkgPT4gcCgpLmRhdGEpIDogcCgpLmRhdGE7XG4gICAgfTtcbiAgICBpZiAocy5sZW5ndGggPCAzKVxuICAgICAgcmV0dXJuIEYoKTtcbiAgICBsZXQgTSA9IHIsIEgsIEsgPSAhMTtcbiAgICBjb25zdCBqID0gTWMoKTtcbiAgICBiW2ZdID0gW1xuICAgICAgaixcbiAgICAgIDBcbiAgICBdO1xuICAgIGNvbnN0IEMgPSAhJGUobCksIGsgPSBwKCksICQgPSBrLmRhdGEsIFcgPSBrLl9jLCBfID0gJGUoVykgPyAkIDogVztcbiAgICBpZiAoQyAmJiAobCA9IE1yKGwpID8gbChfLCAkKSA6IGwsIHkoe1xuICAgICAgZGF0YTogbCxcbiAgICAgIF9jOiBfXG4gICAgfSkpLCBNcihNKSlcbiAgICAgIHRyeSB7XG4gICAgICAgIE0gPSBNKF8pO1xuICAgICAgfSBjYXRjaCAoZykge1xuICAgICAgICBIID0gZywgSyA9ICEwO1xuICAgICAgfVxuICAgIGlmIChNICYmIGNtKE0pKVxuICAgICAgaWYgKE0gPSBhd2FpdCBNLmNhdGNoKChnKSA9PiB7XG4gICAgICAgIEggPSBnLCBLID0gITA7XG4gICAgICB9KSwgaiAhPT0gYltmXVswXSkge1xuICAgICAgICBpZiAoSykgdGhyb3cgSDtcbiAgICAgICAgcmV0dXJuIE07XG4gICAgICB9IGVsc2UgSyAmJiBDICYmIGMoSCkgJiYgKG8gPSAhMCwgeSh7XG4gICAgICAgIGRhdGE6IF8sXG4gICAgICAgIF9jOiBxdFxuICAgICAgfSkpO1xuICAgIGlmIChvICYmICFLKVxuICAgICAgaWYgKE1yKG8pKSB7XG4gICAgICAgIGNvbnN0IGcgPSBvKE0sIF8pO1xuICAgICAgICB5KHtcbiAgICAgICAgICBkYXRhOiBnLFxuICAgICAgICAgIGVycm9yOiBxdCxcbiAgICAgICAgICBfYzogcXRcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgeSh7XG4gICAgICAgICAgZGF0YTogTSxcbiAgICAgICAgICBlcnJvcjogcXQsXG4gICAgICAgICAgX2M6IHF0XG4gICAgICAgIH0pO1xuICAgIGlmIChiW2ZdWzFdID0gTWMoKSwgUHJvbWlzZS5yZXNvbHZlKEYoKSkudGhlbigoKSA9PiB7XG4gICAgICB5KHtcbiAgICAgICAgX2M6IHF0XG4gICAgICB9KTtcbiAgICB9KSwgSykge1xuICAgICAgaWYgKHUpIHRocm93IEg7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBNO1xuICB9XG59XG5jb25zdCBfZiA9IChzLCBlKSA9PiB7XG4gIGZvciAoY29uc3QgdCBpbiBzKVxuICAgIHNbdF1bMF0gJiYgc1t0XVswXShlKTtcbn0sIE5JID0gKHMsIGUpID0+IHtcbiAgaWYgKCFxci5oYXMocykpIHtcbiAgICBjb25zdCB0ID0gQnMoUEksIGUpLCByID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIG4gPSB1bS5iaW5kKHF0LCBzKTtcbiAgICBsZXQgaSA9IENzO1xuICAgIGNvbnN0IG8gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwgYSA9ICh1LCBkKSA9PiB7XG4gICAgICBjb25zdCBoID0gb1t1XSB8fCBbXTtcbiAgICAgIHJldHVybiBvW3VdID0gaCwgaC5wdXNoKGQpLCAoKSA9PiBoLnNwbGljZShoLmluZGV4T2YoZCksIDEpO1xuICAgIH0sIGwgPSAodSwgZCwgaCkgPT4ge1xuICAgICAgcy5zZXQodSwgZCk7XG4gICAgICBjb25zdCBmID0gb1t1XTtcbiAgICAgIGlmIChmKVxuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgZilcbiAgICAgICAgICBwKGQsIGgpO1xuICAgIH0sIGMgPSAoKSA9PiB7XG4gICAgICBpZiAoIXFyLmhhcyhzKSAmJiAocXIuc2V0KHMsIFtcbiAgICAgICAgcixcbiAgICAgICAgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgbixcbiAgICAgICAgbCxcbiAgICAgICAgYVxuICAgICAgXSksICFUaSkpIHtcbiAgICAgICAgY29uc3QgdSA9IHQuaW5pdEZvY3VzKHNldFRpbWVvdXQuYmluZChxdCwgX2YuYmluZChxdCwgciwgb20pKSksIGQgPSB0LmluaXRSZWNvbm5lY3Qoc2V0VGltZW91dC5iaW5kKHF0LCBfZi5iaW5kKHF0LCByLCBhbSkpKTtcbiAgICAgICAgaSA9ICgpID0+IHtcbiAgICAgICAgICB1ICYmIHUoKSwgZCAmJiBkKCksIHFyLmRlbGV0ZShzKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBjKCksIFtcbiAgICAgIHMsXG4gICAgICBuLFxuICAgICAgYyxcbiAgICAgIGlcbiAgICBdO1xuICB9XG4gIHJldHVybiBbXG4gICAgcyxcbiAgICBxci5nZXQocylbNF1cbiAgXTtcbn0sIFVJID0gKHMsIGUsIHQsIHIsIG4pID0+IHtcbiAgY29uc3QgaSA9IHQuZXJyb3JSZXRyeUNvdW50LCBvID0gbi5yZXRyeUNvdW50LCBhID0gfn4oKE1hdGgucmFuZG9tKCkgKyAwLjUpICogKDEgPDwgKG8gPCA4ID8gbyA6IDgpKSkgKiB0LmVycm9yUmV0cnlJbnRlcnZhbDtcbiAgISRlKGkpICYmIG8gPiBpIHx8IHNldFRpbWVvdXQociwgYSwgbik7XG59LCAkSSA9IF9jLCBbTnUsIEdJXSA9IE5JKC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpLCBWSSA9IEJzKFxuICB7XG4gICAgLy8gZXZlbnRzXG4gICAgb25Mb2FkaW5nU2xvdzogQ3MsXG4gICAgb25TdWNjZXNzOiBDcyxcbiAgICBvbkVycm9yOiBDcyxcbiAgICBvbkVycm9yUmV0cnk6IFVJLFxuICAgIG9uRGlzY2FyZGVkOiBDcyxcbiAgICAvLyBzd2l0Y2hlc1xuICAgIHJldmFsaWRhdGVPbkZvY3VzOiAhMCxcbiAgICByZXZhbGlkYXRlT25SZWNvbm5lY3Q6ICEwLFxuICAgIHJldmFsaWRhdGVJZlN0YWxlOiAhMCxcbiAgICBzaG91bGRSZXRyeU9uRXJyb3I6ICEwLFxuICAgIC8vIHRpbWVvdXRzXG4gICAgZXJyb3JSZXRyeUludGVydmFsOiBJZiA/IDFlNCA6IDVlMyxcbiAgICBmb2N1c1Rocm90dGxlSW50ZXJ2YWw6IDUgKiAxZTMsXG4gICAgZGVkdXBpbmdJbnRlcnZhbDogMiAqIDFlMyxcbiAgICBsb2FkaW5nVGltZW91dDogSWYgPyA1ZTMgOiAzZTMsXG4gICAgLy8gcHJvdmlkZXJzXG4gICAgY29tcGFyZTogJEksXG4gICAgaXNQYXVzZWQ6ICgpID0+ICExLFxuICAgIGNhY2hlOiBOdSxcbiAgICBtdXRhdGU6IEdJLFxuICAgIGZhbGxiYWNrOiB7fVxuICB9LFxuICAvLyB1c2Ugd2ViIHByZXNldCBieSBkZWZhdWx0XG4gIERJXG4pLCBqSSA9IChzLCBlKSA9PiB7XG4gIGNvbnN0IHQgPSBCcyhzLCBlKTtcbiAgaWYgKGUpIHtcbiAgICBjb25zdCB7IHVzZTogciwgZmFsbGJhY2s6IG4gfSA9IHMsIHsgdXNlOiBpLCBmYWxsYmFjazogbyB9ID0gZTtcbiAgICByICYmIGkgJiYgKHQudXNlID0gci5jb25jYXQoaSkpLCBuICYmIG8gJiYgKHQuZmFsbGJhY2sgPSBCcyhuLCBvKSk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59LCBLSSA9IGFhKHt9KSwgZG0gPSBcIiRpbmYkXCIsIGhtID0gUGkgJiYgd2luZG93Ll9fU1dSX0RFVlRPT0xTX1VTRV9fLCBISSA9IGhtID8gd2luZG93Ll9fU1dSX0RFVlRPT0xTX1VTRV9fIDogW10sIHFJID0gKCkgPT4ge1xuICBobSAmJiAod2luZG93Ll9fU1dSX0RFVlRPT0xTX1JFQUNUX18gPSBzdCk7XG59LCBmbSA9IChzKSA9PiBNcihzWzFdKSA/IFtcbiAgc1swXSxcbiAgc1sxXSxcbiAgc1syXSB8fCB7fVxuXSA6IFtcbiAgc1swXSxcbiAgbnVsbCxcbiAgKHNbMV0gPT09IG51bGwgPyBzWzJdIDogc1sxXSkgfHwge31cbl0sIFdJID0gKCkgPT4ge1xuICBjb25zdCBzID0gQWkoS0kpO1xuICByZXR1cm4gWnIoKCkgPT4gQnMoVkksIHMpLCBbXG4gICAgc1xuICBdKTtcbn0sIHpJID0gKHMpID0+IChlLCB0LCByKSA9PiBzKGUsIHQgJiYgKCguLi5pKSA9PiB7XG4gIGNvbnN0IFtvXSA9IHdpKGUpLCBbLCAsICwgYV0gPSBxci5nZXQoTnUpO1xuICBpZiAoby5zdGFydHNXaXRoKGRtKSlcbiAgICByZXR1cm4gdCguLi5pKTtcbiAgY29uc3QgbCA9IGFbb107XG4gIHJldHVybiAkZShsKSA/IHQoLi4uaSkgOiAoZGVsZXRlIGFbb10sIGwpO1xufSksIHIpLCBZSSA9IEhJLmNvbmNhdCh6SSksIFpJID0gKHMpID0+IGZ1bmN0aW9uKC4uLnQpIHtcbiAgY29uc3QgciA9IFdJKCksIFtuLCBpLCBvXSA9IGZtKHQpLCBhID0gakkociwgbyk7XG4gIGxldCBsID0gcztcbiAgY29uc3QgeyB1c2U6IGMgfSA9IGEsIHUgPSAoYyB8fCBbXSkuY29uY2F0KFlJKTtcbiAgZm9yIChsZXQgZCA9IHUubGVuZ3RoOyBkLS07IClcbiAgICBsID0gdVtkXShsKTtcbiAgcmV0dXJuIGwobiwgaSB8fCBhLmZldGNoZXIgfHwgbnVsbCwgYSk7XG59LCBYSSA9IChzLCBlLCB0KSA9PiB7XG4gIGNvbnN0IHIgPSBlW3NdIHx8IChlW3NdID0gW10pO1xuICByZXR1cm4gci5wdXNoKHQpLCAoKSA9PiB7XG4gICAgY29uc3QgbiA9IHIuaW5kZXhPZih0KTtcbiAgICBuID49IDAgJiYgKHJbbl0gPSByW3IubGVuZ3RoIC0gMV0sIHIucG9wKCkpO1xuICB9O1xufSwgSkkgPSAocywgZSkgPT4gKC4uLnQpID0+IHtcbiAgY29uc3QgW3IsIG4sIGldID0gZm0odCksIG8gPSAoaS51c2UgfHwgW10pLmNvbmNhdChlKTtcbiAgcmV0dXJuIHMociwgbiwge1xuICAgIC4uLmksXG4gICAgdXNlOiBvXG4gIH0pO1xufTtcbnFJKCk7XG5jb25zdCAkbCA9IHN0LnVzZSB8fCAvLyBUaGlzIGV4dHJhIGdlbmVyaWMgaXMgdG8gYXZvaWQgVHlwZVNjcmlwdCBtaXhpbmcgdXAgdGhlIGdlbmVyaWMgYW5kIEpTWCBzeXRheFxuLy8gYW5kIGVtaXR0aW5nIGFuIGVycm9yLlxuLy8gV2UgYXNzdW1lIHRoYXQgdGhpcyBpcyBvbmx5IGZvciB0aGUgYHVzZSh0aGVuYWJsZSlgIGNhc2UsIG5vdCBgdXNlKGNvbnRleHQpYC5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9ibG9iL2FlZDAwZGFjZmI3OWQxN2M1MzIxODQwNGM1MmIxYzdhYTU5YzRhODkvcGFja2FnZXMvcmVhY3Qtc2VydmVyL3NyYy9SZWFjdEZpenpUaGVuYWJsZS5qcyNMNDVcbigocykgPT4ge1xuICBzd2l0Y2ggKHMuc3RhdHVzKSB7XG4gICAgY2FzZSBcInBlbmRpbmdcIjpcbiAgICAgIHRocm93IHM7XG4gICAgY2FzZSBcImZ1bGZpbGxlZFwiOlxuICAgICAgcmV0dXJuIHMudmFsdWU7XG4gICAgY2FzZSBcInJlamVjdGVkXCI6XG4gICAgICB0aHJvdyBzLnJlYXNvbjtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgcy5zdGF0dXMgPSBcInBlbmRpbmdcIiwgcy50aGVuKChlKSA9PiB7XG4gICAgICAgIHMuc3RhdHVzID0gXCJmdWxmaWxsZWRcIiwgcy52YWx1ZSA9IGU7XG4gICAgICB9LCAoZSkgPT4ge1xuICAgICAgICBzLnN0YXR1cyA9IFwicmVqZWN0ZWRcIiwgcy5yZWFzb24gPSBlO1xuICAgICAgfSksIHM7XG4gIH1cbn0pLCBHbCA9IHtcbiAgZGVkdXBlOiAhMFxufSwgUmYgPSBQcm9taXNlLnJlc29sdmUocXQpLCBRSSA9IChzLCBlLCB0KSA9PiB7XG4gIGNvbnN0IHsgY2FjaGU6IHIsIGNvbXBhcmU6IG4sIHN1c3BlbnNlOiBpLCBmYWxsYmFja0RhdGE6IG8sIHJldmFsaWRhdGVPbk1vdW50OiBhLCByZXZhbGlkYXRlSWZTdGFsZTogbCwgcmVmcmVzaEludGVydmFsOiBjLCByZWZyZXNoV2hlbkhpZGRlbjogdSwgcmVmcmVzaFdoZW5PZmZsaW5lOiBkLCBrZWVwUHJldmlvdXNEYXRhOiBoIH0gPSB0LCBbZiwgcCwgeSwgRV0gPSBxci5nZXQociksIFtiLCBSXSA9IHdpKHMpLCBBID0gYnQoITEpLCBGID0gYnQoITEpLCBNID0gYnQoYiksIEggPSBidChlKSwgSyA9IGJ0KHQpLCBqID0gKCkgPT4gSy5jdXJyZW50LCBDID0gKCkgPT4gaigpLmlzVmlzaWJsZSgpICYmIGooKS5pc09ubGluZSgpLCBbaywgJCwgVywgX10gPSBfcyhyLCBiKSwgZyA9IGJ0KHt9KS5jdXJyZW50LCB4ID0gJGUobykgPyAkZSh0LmZhbGxiYWNrKSA/IHF0IDogdC5mYWxsYmFja1tiXSA6IG8sIHcgPSAoX2UsIHhlKSA9PiB7XG4gICAgZm9yIChjb25zdCBCZSBpbiBnKSB7XG4gICAgICBjb25zdCB5ZSA9IEJlO1xuICAgICAgaWYgKHllID09PSBcImRhdGFcIikge1xuICAgICAgICBpZiAoIW4oX2VbeWVdLCB4ZVt5ZV0pICYmICghJGUoX2VbeWVdKSB8fCAhbihOLCB4ZVt5ZV0pKSlcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICB9IGVsc2UgaWYgKHhlW3llXSAhPT0gX2VbeWVdKVxuICAgICAgICByZXR1cm4gITE7XG4gICAgfVxuICAgIHJldHVybiAhMDtcbiAgfSwgRCA9IFpyKCgpID0+IHtcbiAgICBjb25zdCBfZSA9ICFiIHx8ICFlID8gITEgOiAkZShhKSA/IGooKS5pc1BhdXNlZCgpIHx8IGkgPyAhMSA6IGwgIT09ICExIDogYSwgeGUgPSAod2UpID0+IHtcbiAgICAgIGNvbnN0IE5lID0gQnMod2UpO1xuICAgICAgcmV0dXJuIGRlbGV0ZSBOZS5faywgX2UgPyB7XG4gICAgICAgIGlzVmFsaWRhdGluZzogITAsXG4gICAgICAgIGlzTG9hZGluZzogITAsXG4gICAgICAgIC4uLk5lXG4gICAgICB9IDogTmU7XG4gICAgfSwgQmUgPSBrKCksIHllID0gXygpLCBiZSA9IHhlKEJlKSwgRmUgPSBCZSA9PT0geWUgPyBiZSA6IHhlKHllKTtcbiAgICBsZXQgWGUgPSBiZTtcbiAgICByZXR1cm4gW1xuICAgICAgKCkgPT4ge1xuICAgICAgICBjb25zdCB3ZSA9IHhlKGsoKSk7XG4gICAgICAgIHJldHVybiB3KHdlLCBYZSkgPyAoWGUuZGF0YSA9IHdlLmRhdGEsIFhlLmlzTG9hZGluZyA9IHdlLmlzTG9hZGluZywgWGUuaXNWYWxpZGF0aW5nID0gd2UuaXNWYWxpZGF0aW5nLCBYZS5lcnJvciA9IHdlLmVycm9yLCBYZSkgOiAoWGUgPSB3ZSwgd2UpO1xuICAgICAgfSxcbiAgICAgICgpID0+IEZlXG4gICAgXTtcbiAgfSwgW1xuICAgIHIsXG4gICAgYlxuICBdKSwgTyA9IGltLnVzZVN5bmNFeHRlcm5hbFN0b3JlKHV0KFxuICAgIChfZSkgPT4gVyhiLCAoeGUsIEJlKSA9PiB7XG4gICAgICB3KEJlLCB4ZSkgfHwgX2UoKTtcbiAgICB9KSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW1xuICAgICAgcixcbiAgICAgIGJcbiAgICBdXG4gICksIERbMF0sIERbMV0pLCBVID0gIUEuY3VycmVudCwgViA9IGZbYl0gJiYgZltiXS5sZW5ndGggPiAwLCBMID0gTy5kYXRhLCBtID0gJGUoTCkgPyB4ICYmIGNtKHgpID8gJGwoeCkgOiB4IDogTCwgdiA9IE8uZXJyb3IsIFAgPSBidChtKSwgTiA9IGggPyAkZShMKSA/ICRlKFAuY3VycmVudCkgPyBtIDogUC5jdXJyZW50IDogTCA6IG0sIFkgPSBWICYmICEkZSh2KSA/ICExIDogVSAmJiAhJGUoYSkgPyBhIDogaigpLmlzUGF1c2VkKCkgPyAhMSA6IGkgPyAkZShtKSA/ICExIDogbCA6ICRlKG0pIHx8IGwsIGVlID0gISEoYiAmJiBlICYmIFUgJiYgWSksIGllID0gJGUoTy5pc1ZhbGlkYXRpbmcpID8gZWUgOiBPLmlzVmFsaWRhdGluZywgbGUgPSAkZShPLmlzTG9hZGluZykgPyBlZSA6IE8uaXNMb2FkaW5nLCBUZSA9IHV0KFxuICAgIGFzeW5jIChfZSkgPT4ge1xuICAgICAgY29uc3QgeGUgPSBILmN1cnJlbnQ7XG4gICAgICBpZiAoIWIgfHwgIXhlIHx8IEYuY3VycmVudCB8fCBqKCkuaXNQYXVzZWQoKSlcbiAgICAgICAgcmV0dXJuICExO1xuICAgICAgbGV0IEJlLCB5ZSwgYmUgPSAhMDtcbiAgICAgIGNvbnN0IEZlID0gX2UgfHwge30sIFhlID0gIXlbYl0gfHwgIUZlLmRlZHVwZSwgd2UgPSAoKSA9PiBBZiA/ICFGLmN1cnJlbnQgJiYgYiA9PT0gTS5jdXJyZW50ICYmIEEuY3VycmVudCA6IGIgPT09IE0uY3VycmVudCwgTmUgPSB7XG4gICAgICAgIGlzVmFsaWRhdGluZzogITEsXG4gICAgICAgIGlzTG9hZGluZzogITFcbiAgICAgIH0sIGR0ID0gKCkgPT4ge1xuICAgICAgICAkKE5lKTtcbiAgICAgIH0sIEplID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBpdCA9IHlbYl07XG4gICAgICAgIGl0ICYmIGl0WzFdID09PSB5ZSAmJiBkZWxldGUgeVtiXTtcbiAgICAgIH0sIFFlID0ge1xuICAgICAgICBpc1ZhbGlkYXRpbmc6ICEwXG4gICAgICB9O1xuICAgICAgJGUoaygpLmRhdGEpICYmIChRZS5pc0xvYWRpbmcgPSAhMCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoWGUgJiYgKCQoUWUpLCB0LmxvYWRpbmdUaW1lb3V0ICYmICRlKGsoKS5kYXRhKSAmJiBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBiZSAmJiB3ZSgpICYmIGooKS5vbkxvYWRpbmdTbG93KGIsIHQpO1xuICAgICAgICB9LCB0LmxvYWRpbmdUaW1lb3V0KSwgeVtiXSA9IFtcbiAgICAgICAgICB4ZShSKSxcbiAgICAgICAgICBNYygpXG4gICAgICAgIF0pLCBbQmUsIHllXSA9IHlbYl0sIEJlID0gYXdhaXQgQmUsIFhlICYmIHNldFRpbWVvdXQoSmUsIHQuZGVkdXBpbmdJbnRlcnZhbCksICF5W2JdIHx8IHlbYl1bMV0gIT09IHllKVxuICAgICAgICAgIHJldHVybiBYZSAmJiB3ZSgpICYmIGooKS5vbkRpc2NhcmRlZChiKSwgITE7XG4gICAgICAgIE5lLmVycm9yID0gcXQ7XG4gICAgICAgIGNvbnN0IGl0ID0gcFtiXTtcbiAgICAgICAgaWYgKCEkZShpdCkgJiYgLy8gY2FzZSAxXG4gICAgICAgICh5ZSA8PSBpdFswXSB8fCAvLyBjYXNlIDJcbiAgICAgICAgeWUgPD0gaXRbMV0gfHwgLy8gY2FzZSAzXG4gICAgICAgIGl0WzFdID09PSAwKSlcbiAgICAgICAgICByZXR1cm4gZHQoKSwgWGUgJiYgd2UoKSAmJiBqKCkub25EaXNjYXJkZWQoYiksICExO1xuICAgICAgICBjb25zdCBqZSA9IGsoKS5kYXRhO1xuICAgICAgICBOZS5kYXRhID0gbihqZSwgQmUpID8gamUgOiBCZSwgWGUgJiYgd2UoKSAmJiBqKCkub25TdWNjZXNzKEJlLCBiLCB0KTtcbiAgICAgIH0gY2F0Y2ggKGl0KSB7XG4gICAgICAgIEplKCk7XG4gICAgICAgIGNvbnN0IGplID0gaigpLCB7IHNob3VsZFJldHJ5T25FcnJvcjogQiB9ID0gamU7XG4gICAgICAgIGplLmlzUGF1c2VkKCkgfHwgKE5lLmVycm9yID0gaXQsIFhlICYmIHdlKCkgJiYgKGplLm9uRXJyb3IoaXQsIGIsIGplKSwgKEIgPT09ICEwIHx8IE1yKEIpICYmIEIoaXQpKSAmJiAoIWooKS5yZXZhbGlkYXRlT25Gb2N1cyB8fCAhaigpLnJldmFsaWRhdGVPblJlY29ubmVjdCB8fCBDKCkpICYmIGplLm9uRXJyb3JSZXRyeShpdCwgYiwgamUsIChTKSA9PiB7XG4gICAgICAgICAgY29uc3QgVCA9IGZbYl07XG4gICAgICAgICAgVCAmJiBUWzBdICYmIFRbMF0oVGYsIFMpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgcmV0cnlDb3VudDogKEZlLnJldHJ5Q291bnQgfHwgMCkgKyAxLFxuICAgICAgICAgIGRlZHVwZTogITBcbiAgICAgICAgfSkpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiZSA9ICExLCBkdCgpLCAhMDtcbiAgICB9LFxuICAgIC8vIGBzZXRTdGF0ZWAgaXMgaW1tdXRhYmxlLCBhbmQgYGV2ZW50c0NhbGxiYWNrYCwgYGZuQXJnYCwgYW5kXG4gICAgLy8gYGtleVZhbGlkYXRpbmdgIGFyZSBkZXBlbmRpbmcgb24gYGtleWAsIHNvIHdlIGNhbiBleGNsdWRlIHRoZW0gZnJvbVxuICAgIC8vIHRoZSBkZXBzIGFycmF5LlxuICAgIC8vXG4gICAgLy8gRklYTUU6XG4gICAgLy8gYGZuYCBhbmQgYGNvbmZpZ2AgbWlnaHQgYmUgY2hhbmdlZCBkdXJpbmcgdGhlIGxpZmVjeWNsZSxcbiAgICAvLyBidXQgdGhleSBtaWdodCBiZSBjaGFuZ2VkIGV2ZXJ5IHJlbmRlciBsaWtlIHRoaXMuXG4gICAgLy8gYHVzZVNXUigna2V5JywgKCkgPT4gZmV0Y2goJy9hcGkvJyksIHsgc3VzcGVuc2U6IHRydWUgfSlgXG4gICAgLy8gU28gd2Ugb21pdCB0aGUgdmFsdWVzIGZyb20gdGhlIGRlcHMgYXJyYXlcbiAgICAvLyBldmVuIHRob3VnaCBpdCBtaWdodCBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW9ycy5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW1xuICAgICAgYixcbiAgICAgIHJcbiAgICBdXG4gICksIERlID0gdXQoXG4gICAgLy8gVXNlIGNhbGxiYWNrIHRvIG1ha2Ugc3VyZSBga2V5UmVmLmN1cnJlbnRgIHJldHVybnMgbGF0ZXN0IHJlc3VsdCBldmVyeSB0aW1lXG4gICAgKC4uLl9lKSA9PiB1bShyLCBNLmN1cnJlbnQsIC4uLl9lKSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW11cbiAgKTtcbiAgaWYgKFNvKCgpID0+IHtcbiAgICBILmN1cnJlbnQgPSBlLCBLLmN1cnJlbnQgPSB0LCAkZShMKSB8fCAoUC5jdXJyZW50ID0gTCk7XG4gIH0pLCBTbygoKSA9PiB7XG4gICAgaWYgKCFiKSByZXR1cm47XG4gICAgY29uc3QgX2UgPSBUZS5iaW5kKHF0LCBHbCk7XG4gICAgbGV0IHhlID0gMDtcbiAgICBqKCkucmV2YWxpZGF0ZU9uRm9jdXMgJiYgKHhlID0gRGF0ZS5ub3coKSArIGooKS5mb2N1c1Rocm90dGxlSW50ZXJ2YWwpO1xuICAgIGNvbnN0IHllID0gWEkoYiwgZiwgKGJlLCBGZSA9IHt9KSA9PiB7XG4gICAgICBpZiAoYmUgPT0gb20pIHtcbiAgICAgICAgY29uc3QgWGUgPSBEYXRlLm5vdygpO1xuICAgICAgICBqKCkucmV2YWxpZGF0ZU9uRm9jdXMgJiYgWGUgPiB4ZSAmJiBDKCkgJiYgKHhlID0gWGUgKyBqKCkuZm9jdXNUaHJvdHRsZUludGVydmFsLCBfZSgpKTtcbiAgICAgIH0gZWxzZSBpZiAoYmUgPT0gYW0pXG4gICAgICAgIGooKS5yZXZhbGlkYXRlT25SZWNvbm5lY3QgJiYgQygpICYmIF9lKCk7XG4gICAgICBlbHNlIHtcbiAgICAgICAgaWYgKGJlID09IGxtKVxuICAgICAgICAgIHJldHVybiBUZSgpO1xuICAgICAgICBpZiAoYmUgPT0gVGYpXG4gICAgICAgICAgcmV0dXJuIFRlKEZlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gRi5jdXJyZW50ID0gITEsIE0uY3VycmVudCA9IGIsIEEuY3VycmVudCA9ICEwLCAkKHtcbiAgICAgIF9rOiBSXG4gICAgfSksIFkgJiYgKHlbYl0gfHwgKCRlKG0pIHx8IFRpID8gX2UoKSA6IE1JKF9lKSkpLCAoKSA9PiB7XG4gICAgICBGLmN1cnJlbnQgPSAhMCwgeWUoKTtcbiAgICB9O1xuICB9LCBbXG4gICAgYlxuICBdKSwgU28oKCkgPT4ge1xuICAgIGxldCBfZTtcbiAgICBmdW5jdGlvbiB4ZSgpIHtcbiAgICAgIGNvbnN0IHllID0gTXIoYykgPyBjKGsoKS5kYXRhKSA6IGM7XG4gICAgICB5ZSAmJiBfZSAhPT0gLTEgJiYgKF9lID0gc2V0VGltZW91dChCZSwgeWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQmUoKSB7XG4gICAgICAhaygpLmVycm9yICYmICh1IHx8IGooKS5pc1Zpc2libGUoKSkgJiYgKGQgfHwgaigpLmlzT25saW5lKCkpID8gVGUoR2wpLnRoZW4oeGUpIDogeGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHhlKCksICgpID0+IHtcbiAgICAgIF9lICYmIChjbGVhclRpbWVvdXQoX2UpLCBfZSA9IC0xKTtcbiAgICB9O1xuICB9LCBbXG4gICAgYyxcbiAgICB1LFxuICAgIGQsXG4gICAgYlxuICBdKSwgeG0oTiksIGkpIHtcbiAgICBjb25zdCBfZSA9IGIgJiYgJGUobSk7XG4gICAgaWYgKCFBZiAmJiBUaSAmJiBfZSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhbGxiYWNrIGRhdGEgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyBTdXNwZW5zZSBpbiBTU1IuXCIpO1xuICAgIF9lICYmIChILmN1cnJlbnQgPSBlLCBLLmN1cnJlbnQgPSB0LCBGLmN1cnJlbnQgPSAhMSk7XG4gICAgY29uc3QgeGUgPSBFW2JdLCBCZSA9ICEkZSh4ZSkgJiYgX2UgPyBEZSh4ZSkgOiBSZjtcbiAgICBpZiAoJGwoQmUpLCAhJGUodikgJiYgX2UpXG4gICAgICB0aHJvdyB2O1xuICAgIGNvbnN0IHllID0gX2UgPyBUZShHbCkgOiBSZjtcbiAgICAhJGUoTikgJiYgX2UgJiYgKHllLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCIsIHllLnZhbHVlID0gITApLCAkbCh5ZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtdXRhdGU6IERlLFxuICAgIGdldCBkYXRhKCkge1xuICAgICAgcmV0dXJuIGcuZGF0YSA9ICEwLCBOO1xuICAgIH0sXG4gICAgZ2V0IGVycm9yKCkge1xuICAgICAgcmV0dXJuIGcuZXJyb3IgPSAhMCwgdjtcbiAgICB9LFxuICAgIGdldCBpc1ZhbGlkYXRpbmcoKSB7XG4gICAgICByZXR1cm4gZy5pc1ZhbGlkYXRpbmcgPSAhMCwgaWU7XG4gICAgfSxcbiAgICBnZXQgaXNMb2FkaW5nKCkge1xuICAgICAgcmV0dXJuIGcuaXNMb2FkaW5nID0gITAsIGxlO1xuICAgIH1cbiAgfTtcbn0sIGVfID0gWkkoUUkpLCB0XyA9ICgpID0+IHtcbn0sIHJfID0gKFxuICAvKiNfX05PSU5MSU5FX18qL1xuICB0XygpXG4pLCBPYyA9IE9iamVjdCwgTGYgPSAocykgPT4gcyA9PT0gcl8sIHNfID0gKHMpID0+IHR5cGVvZiBzID09IFwiZnVuY3Rpb25cIiwgbG8gPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKSwgbl8gPSAocykgPT4gT2MucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocyksIFZsID0gKHMsIGUpID0+IHMgPT09IGBbb2JqZWN0ICR7ZX1dYDtcbmxldCBpXyA9IDA7XG5jb25zdCBCYyA9IChzKSA9PiB7XG4gIGNvbnN0IGUgPSB0eXBlb2YgcywgdCA9IG5fKHMpLCByID0gVmwodCwgXCJEYXRlXCIpLCBuID0gVmwodCwgXCJSZWdFeHBcIiksIGkgPSBWbCh0LCBcIk9iamVjdFwiKTtcbiAgbGV0IG8sIGE7XG4gIGlmIChPYyhzKSA9PT0gcyAmJiAhciAmJiAhbikge1xuICAgIGlmIChvID0gbG8uZ2V0KHMpLCBvKSByZXR1cm4gbztcbiAgICBpZiAobyA9ICsraV8gKyBcIn5cIiwgbG8uc2V0KHMsIG8pLCBBcnJheS5pc0FycmF5KHMpKSB7XG4gICAgICBmb3IgKG8gPSBcIkBcIiwgYSA9IDA7IGEgPCBzLmxlbmd0aDsgYSsrKVxuICAgICAgICBvICs9IEJjKHNbYV0pICsgXCIsXCI7XG4gICAgICBsby5zZXQocywgbyk7XG4gICAgfVxuICAgIGlmIChpKSB7XG4gICAgICBvID0gXCIjXCI7XG4gICAgICBjb25zdCBsID0gT2Mua2V5cyhzKS5zb3J0KCk7XG4gICAgICBmb3IgKDsgIUxmKGEgPSBsLnBvcCgpKTsgKVxuICAgICAgICBMZihzW2FdKSB8fCAobyArPSBhICsgXCI6XCIgKyBCYyhzW2FdKSArIFwiLFwiKTtcbiAgICAgIGxvLnNldChzLCBvKTtcbiAgICB9XG4gIH0gZWxzZVxuICAgIG8gPSByID8gcy50b0pTT04oKSA6IGUgPT0gXCJzeW1ib2xcIiA/IHMudG9TdHJpbmcoKSA6IGUgPT0gXCJzdHJpbmdcIiA/IEpTT04uc3RyaW5naWZ5KHMpIDogXCJcIiArIHM7XG4gIHJldHVybiBvO1xufSwgb18gPSAocykgPT4ge1xuICBpZiAoc18ocykpXG4gICAgdHJ5IHtcbiAgICAgIHMgPSBzKCk7XG4gICAgfSBjYXRjaCB7XG4gICAgICBzID0gXCJcIjtcbiAgICB9XG4gIGNvbnN0IGUgPSBzO1xuICByZXR1cm4gcyA9IHR5cGVvZiBzID09IFwic3RyaW5nXCIgPyBzIDogKEFycmF5LmlzQXJyYXkocykgPyBzLmxlbmd0aCA6IHMpID8gQmMocykgOiBcIlwiLCBbXG4gICAgcyxcbiAgICBlXG4gIF07XG59LCBhXyA9IChzKSA9PiBvXyhzID8gcygwLCBudWxsKSA6IG51bGwpWzBdLCBqbCA9IFByb21pc2UucmVzb2x2ZSgpLCBsXyA9IChzKSA9PiAoZSwgdCwgcikgPT4ge1xuICBjb25zdCBuID0gYnQoITEpLCB7IGNhY2hlOiBpLCBpbml0aWFsU2l6ZTogbyA9IDEsIHJldmFsaWRhdGVBbGw6IGEgPSAhMSwgcGVyc2lzdFNpemU6IGwgPSAhMSwgcmV2YWxpZGF0ZUZpcnN0UGFnZTogYyA9ICEwLCByZXZhbGlkYXRlT25Nb3VudDogdSA9ICExLCBwYXJhbGxlbDogZCA9ICExIH0gPSByLCBbLCAsICwgaF0gPSBxci5nZXQoTnUpO1xuICBsZXQgZjtcbiAgdHJ5IHtcbiAgICBmID0gYV8oZSksIGYgJiYgKGYgPSBkbSArIGYpO1xuICB9IGNhdGNoIHtcbiAgfVxuICBjb25zdCBbcCwgeSwgRV0gPSBfcyhpLCBmKSwgYiA9IHV0KCgpID0+ICRlKHAoKS5fbCkgPyBvIDogcCgpLl9sLCBbXG4gICAgaSxcbiAgICBmLFxuICAgIG9cbiAgXSk7XG4gIGltLnVzZVN5bmNFeHRlcm5hbFN0b3JlKHV0KFxuICAgIChqKSA9PiBmID8gRShmLCAoKSA9PiB7XG4gICAgICBqKCk7XG4gICAgfSkgOiAoKSA9PiB7XG4gICAgfSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW1xuICAgICAgaSxcbiAgICAgIGZcbiAgICBdXG4gICksIGIsIGIpO1xuICBjb25zdCBSID0gdXQoKCkgPT4ge1xuICAgIGNvbnN0IGogPSBwKCkuX2w7XG4gICAgcmV0dXJuICRlKGopID8gbyA6IGo7XG4gIH0sIFtcbiAgICBmLFxuICAgIG9cbiAgXSksIEEgPSBidChSKCkpO1xuICBTbygoKSA9PiB7XG4gICAgaWYgKCFuLmN1cnJlbnQpIHtcbiAgICAgIG4uY3VycmVudCA9ICEwO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmICYmIHkoe1xuICAgICAgX2w6IGwgPyBBLmN1cnJlbnQgOiBSKClcbiAgICB9KTtcbiAgfSwgW1xuICAgIGYsXG4gICAgaVxuICBdKTtcbiAgY29uc3QgRiA9IHUgJiYgIW4uY3VycmVudCwgTSA9IHMoZiwgYXN5bmMgKGopID0+IHtcbiAgICBjb25zdCBDID0gcCgpLl9pLCBrID0gcCgpLl9yO1xuICAgIHkoe1xuICAgICAgX3I6IHF0XG4gICAgfSk7XG4gICAgY29uc3QgJCA9IFtdLCBXID0gUigpLCBbX10gPSBfcyhpLCBqKSwgZyA9IF8oKS5kYXRhLCB4ID0gW107XG4gICAgbGV0IHcgPSBudWxsO1xuICAgIGZvciAobGV0IEQgPSAwOyBEIDwgVzsgKytEKSB7XG4gICAgICBjb25zdCBbTywgVV0gPSB3aShlKEQsIGQgPyBudWxsIDogdykpO1xuICAgICAgaWYgKCFPKVxuICAgICAgICBicmVhaztcbiAgICAgIGNvbnN0IFtWLCBMXSA9IF9zKGksIE8pO1xuICAgICAgbGV0IG0gPSBWKCkuZGF0YTtcbiAgICAgIGNvbnN0IHYgPSBhIHx8IEMgfHwgJGUobSkgfHwgYyAmJiAhRCAmJiAhJGUoZykgfHwgRiB8fCBnICYmICEkZShnW0RdKSAmJiAhci5jb21wYXJlKGdbRF0sIG0pO1xuICAgICAgaWYgKHQgJiYgKHR5cGVvZiBrID09IFwiZnVuY3Rpb25cIiA/IGsobSwgVSkgOiB2KSkge1xuICAgICAgICBjb25zdCBQID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGlmICghKE8gaW4gaCkpXG4gICAgICAgICAgICBtID0gYXdhaXQgdChVKTtcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IFkgPSBoW09dO1xuICAgICAgICAgICAgZGVsZXRlIGhbT10sIG0gPSBhd2FpdCBZO1xuICAgICAgICAgIH1cbiAgICAgICAgICBMKHtcbiAgICAgICAgICAgIGRhdGE6IG0sXG4gICAgICAgICAgICBfazogVVxuICAgICAgICAgIH0pLCAkW0RdID0gbTtcbiAgICAgICAgfTtcbiAgICAgICAgZCA/IHgucHVzaChQKSA6IGF3YWl0IFAoKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICAkW0RdID0gbTtcbiAgICAgIGQgfHwgKHcgPSBtKTtcbiAgICB9XG4gICAgcmV0dXJuIGQgJiYgYXdhaXQgUHJvbWlzZS5hbGwoeC5tYXAoKEQpID0+IEQoKSkpLCB5KHtcbiAgICAgIF9pOiBxdFxuICAgIH0pLCAkO1xuICB9LCByKSwgSCA9IHV0KFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgZnVuY3Rpb24oaiwgQykge1xuICAgICAgY29uc3QgayA9IHR5cGVvZiBDID09IFwiYm9vbGVhblwiID8ge1xuICAgICAgICByZXZhbGlkYXRlOiBDXG4gICAgICB9IDogQyB8fCB7fSwgJCA9IGsucmV2YWxpZGF0ZSAhPT0gITE7XG4gICAgICByZXR1cm4gZiA/ICgkICYmICgkZShqKSA/IHkoe1xuICAgICAgICBfaTogITAsXG4gICAgICAgIF9yOiBrLnJldmFsaWRhdGVcbiAgICAgIH0pIDogeSh7XG4gICAgICAgIF9pOiAhMSxcbiAgICAgICAgX3I6IGsucmV2YWxpZGF0ZVxuICAgICAgfSkpLCBhcmd1bWVudHMubGVuZ3RoID8gTS5tdXRhdGUoaiwge1xuICAgICAgICAuLi5rLFxuICAgICAgICByZXZhbGlkYXRlOiAkXG4gICAgICB9KSA6IE0ubXV0YXRlKCkpIDogamw7XG4gICAgfSxcbiAgICAvLyBzd3IubXV0YXRlIGlzIGFsd2F5cyB0aGUgc2FtZSByZWZlcmVuY2VcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgW1xuICAgICAgZixcbiAgICAgIGlcbiAgICBdXG4gICksIEsgPSB1dChcbiAgICAoaikgPT4ge1xuICAgICAgaWYgKCFmKSByZXR1cm4gamw7XG4gICAgICBjb25zdCBbLCBDXSA9IF9zKGksIGYpO1xuICAgICAgbGV0IGs7XG4gICAgICBpZiAoTXIoaikgPyBrID0gaihSKCkpIDogdHlwZW9mIGogPT0gXCJudW1iZXJcIiAmJiAoayA9IGopLCB0eXBlb2YgayAhPSBcIm51bWJlclwiKSByZXR1cm4gamw7XG4gICAgICBDKHtcbiAgICAgICAgX2w6IGtcbiAgICAgIH0pLCBBLmN1cnJlbnQgPSBrO1xuICAgICAgY29uc3QgJCA9IFtdLCBbV10gPSBfcyhpLCBmKTtcbiAgICAgIGxldCBfID0gbnVsbDtcbiAgICAgIGZvciAobGV0IGcgPSAwOyBnIDwgazsgKytnKSB7XG4gICAgICAgIGNvbnN0IFt4XSA9IHdpKGUoZywgXykpLCBbd10gPSBfcyhpLCB4KSwgRCA9IHggPyB3KCkuZGF0YSA6IHF0O1xuICAgICAgICBpZiAoJGUoRCkpXG4gICAgICAgICAgcmV0dXJuIEgoVygpLmRhdGEpO1xuICAgICAgICAkLnB1c2goRCksIF8gPSBEO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEgoJCk7XG4gICAgfSxcbiAgICAvLyBleGNsdWRlIGdldEtleSBmcm9tIHRoZSBkZXBlbmRlbmNpZXMsIHdoaWNoIGlzbid0IGFsbG93ZWQgdG8gY2hhbmdlIGR1cmluZyB0aGUgbGlmZWN5Y2xlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtcbiAgICAgIGYsXG4gICAgICBpLFxuICAgICAgSCxcbiAgICAgIFJcbiAgICBdXG4gICk7XG4gIHJldHVybiB7XG4gICAgc2l6ZTogUigpLFxuICAgIHNldFNpemU6IEssXG4gICAgbXV0YXRlOiBILFxuICAgIGdldCBkYXRhKCkge1xuICAgICAgcmV0dXJuIE0uZGF0YTtcbiAgICB9LFxuICAgIGdldCBlcnJvcigpIHtcbiAgICAgIHJldHVybiBNLmVycm9yO1xuICAgIH0sXG4gICAgZ2V0IGlzVmFsaWRhdGluZygpIHtcbiAgICAgIHJldHVybiBNLmlzVmFsaWRhdGluZztcbiAgICB9LFxuICAgIGdldCBpc0xvYWRpbmcoKSB7XG4gICAgICByZXR1cm4gTS5pc0xvYWRpbmc7XG4gICAgfVxuICB9O1xufSwgY18gPSBKSShlXywgbF8pLCB1XyA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInNmbWtxY3JcIl1cbn0pLCBkXyA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcImhybGR0aW9cIl1cbn0pLCBoXyA9IE1mKCh7XG4gIGNhc3RzOiBzLFxuICBjdXJzb3I6IGVcbn0pID0+IC8qIEBfX1BVUkVfXyAqLyBxLmpzeCh1Xywge1xuICBjaGlsZHJlbjogcy5tYXAoKHQsIHIpID0+IC8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoc3QuRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBxLmpzeChvYSwge1xuICAgICAgaXNFbWJlZDogITEsXG4gICAgICAuLi50XG4gICAgfSksIHIgPCBzLmxlbmd0aCAtIDEgJiYgLyogQF9fUFVSRV9fICovIHEuanN4KGRfLCB7fSldXG4gIH0sIHQuaGFzaCkpXG59KSk7XG5mdW5jdGlvbiBmXyhzKSB7XG4gIHJldHVybiBzID8gcy5tYXAoKGUpID0+IHtcbiAgICB2YXIgciwgbiwgaSwgbywgYTtcbiAgICBjb25zdCB0ID0gZSAhPSBudWxsICYmIGUucmVwbGllcyAmJiB0eXBlb2YgZS5yZXBsaWVzID09IFwib2JqZWN0XCIgPyBOdW1iZXIoZS5yZXBsaWVzLmNvdW50KSB8fCAwIDogTnVtYmVyKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUucmVwbGllcykgfHwgMDtcbiAgICByZXR1cm4ge1xuICAgICAgdXNlcm5hbWU6ICgociA9IGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuYXV0aG9yKSA9PSBudWxsID8gdm9pZCAwIDogci51c2VybmFtZSkgPz8gXCJcIixcbiAgICAgIGRpc3BsYXlOYW1lOiAoKG4gPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLmF1dGhvcikgPT0gbnVsbCA/IHZvaWQgMCA6IG4uZGlzcGxheV9uYW1lKSA/PyBcIlwiLFxuICAgICAgYXZhdGFySW1nVXJsOiAoKGkgPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLmF1dGhvcikgPT0gbnVsbCA/IHZvaWQgMCA6IGkucGZwX3VybCkgPz8gXCJcIixcbiAgICAgIHRleHQ6IChlID09IG51bGwgPyB2b2lkIDAgOiBlLnRleHQpID8/IFwiXCIsXG4gICAgICBoYXNoOiAoZSA9PSBudWxsID8gdm9pZCAwIDogZS5oYXNoKSA/PyBcIlwiLFxuICAgICAgcmVhY3Rpb25zOiAoZSA9PSBudWxsID8gdm9pZCAwIDogZS5yZWFjdGlvbnMpID8/IFtdLFxuICAgICAgcmVwbGllczogdCxcbiAgICAgIGVtYmVkczogKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuZW1iZWRzKSA/PyBbXSxcbiAgICAgIGZyYW1lczogKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUuZnJhbWVzKSA/PyBbXSxcbiAgICAgIHJlbmRlckVtYmVkczogKGUgPT0gbnVsbCA/IHZvaWQgMCA6IGUucmVuZGVyRW1iZWRzKSA/PyAhMCxcbiAgICAgIGNoYW5uZWw6IChlID09IG51bGwgPyB2b2lkIDAgOiBlLmNoYW5uZWwpID8/IFwiXCIsXG4gICAgICB2aWV3ZXJGaWQ6IDIsXG4gICAgICBoYXNQb3dlckJhZGdlOiAoKG8gPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLmF1dGhvcikgPT0gbnVsbCA/IHZvaWQgMCA6IG8ucG93ZXJfYmFkZ2UpID8/ICExLFxuICAgICAgYXBwQXZhdGFySW1nVXJsOiAoKGEgPSBlID09IG51bGwgPyB2b2lkIDAgOiBlLmFwcCkgPT0gbnVsbCA/IHZvaWQgMCA6IGEucGZwX3VybCkgPz8gXCJcIixcbiAgICAgIGlzT3duUHJvZmlsZTogITEsXG4gICAgICBhbGxvd1JlYWN0aW9uczogITAsXG4gICAgICByZW5kZXJGcmFtZXM6ICExLFxuICAgICAgdGltZXN0YW1wOiBlLnRpbWVzdGFtcCA/PyBcIlwiXG4gICAgfTtcbiAgfSkgOiBbXTtcbn1cbmNvbnN0IGdfID0gKHMpID0+IGFuKHMpLnRoZW4oYXN5bmMgKGUpID0+IGF3YWl0IGUuanNvbigpKSwgcF8gPSAocywgZSwgdCwgciwgbikgPT4ge1xuICBpZiAoZSAmJiAoIWUuY2FzdHMgfHwgIWUuY2FzdHMubGVuZ3RoKSkgcmV0dXJuIG51bGw7XG4gIGxldCBpID0gYCR7b259L3YyL2ZhcmNhc3Rlci9mZWVkJHt0ID8gXCJcIiA6IFwiP1wifWA7XG4gIGNvbnN0IG8gPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gIHQgJiYgKGkgKz0gYCR7dH0/YCksIG4gJiYgKGkgKz0gYGNsaWVudF9pZD0ke259YCksIGUgJiYgKGkgKz0gYCZjdXJzb3I9JHtlLm5leHQuY3Vyc29yfWApO1xuICBjb25zdCBhID0gKGwsIGMpID0+IHtcbiAgICBjICE9IG51bGwgJiYgIWkuaW5jbHVkZXMoYCR7bH09YCkgJiYgby5hcHBlbmQobCwgU3RyaW5nKGMpKTtcbiAgfTtcbiAgaWYgKHIpIHtcbiAgICBPYmplY3QuZW50cmllcyhyKS5mb3JFYWNoKChbYywgdV0pID0+IHtcbiAgICAgIGNvbnN0IGQgPSBjLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csIFwiJDFfJDJcIikudG9Mb3dlckNhc2UoKTtcbiAgICAgIGEoZCwgdSk7XG4gICAgfSk7XG4gICAgY29uc3QgbCA9IG8udG9TdHJpbmcoKTtcbiAgICBsICYmIChpICs9IGkuaW5jbHVkZXMoXCI/XCIpID8gYCYke2x9YCA6IGA/JHtsfWApO1xuICB9XG4gIGlmIChPYmplY3Qua2V5cyhyKS5sZW5ndGggPiAxKVxuICAgIHJldHVybiBpO1xufSwgeVIgPSAoe1xuICBwYXRoOiBzLFxuICAuLi5lXG59KSA9PiB7XG4gIHZhciBmO1xuICBjb25zdCB7XG4gICAgY2xpZW50X2lkOiB0XG4gIH0gPSB0cygpLCByID0gYnQobnVsbCksIFtuLCBpXSA9IHFlKCExKSwgbyA9IGJ0KG51bGwpLCB7XG4gICAgZGF0YTogYSxcbiAgICBlcnJvcjogbCxcbiAgICBzaXplOiBjLFxuICAgIHNldFNpemU6IHUsXG4gICAgaXNWYWxpZGF0aW5nOiBkXG4gIH0gPSBjXygocCwgeSkgPT4gcF8ocCwgeSwgcywgZSwgdCksIGdfKSwgaCA9IFpyKCgpID0+IHtcbiAgICBpZiAoIWEpIHJldHVybiBbXTtcbiAgICBjb25zdCBwID0gYS5mbGF0TWFwKChFKSA9PiAoRSA9PSBudWxsID8gdm9pZCAwIDogRS5jYXN0cykgPz8gW10pLCB5ID0gQXJyYXkuZnJvbShuZXcgU2V0KHAubWFwKChFKSA9PiBFLmhhc2gpKSkubWFwKChFKSA9PiBwLmZpbmQoKGIpID0+IGIuaGFzaCA9PT0gRSkpO1xuICAgIHJldHVybiBmXyh5KTtcbiAgfSwgW2FdKTtcbiAgcmV0dXJuIGZ0KCgpID0+IChvLmN1cnJlbnQgJiYgby5jdXJyZW50LmRpc2Nvbm5lY3QoKSwgby5jdXJyZW50ID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChwKSA9PiB7XG4gICAgdmFyIEUsIGI7XG4gICAgY29uc3QgW3ldID0gcDtcbiAgICB5LmlzSW50ZXJzZWN0aW5nICYmICFuICYmICFkICYmIGEgJiYgKChiID0gKEUgPSBhW2EubGVuZ3RoIC0gMV0pID09IG51bGwgPyB2b2lkIDAgOiBFLm5leHQpICE9IG51bGwgJiYgYi5jdXJzb3IpICYmIChpKCEwKSwgdShjICsgMSkudGhlbigoKSA9PiBpKCExKSkpO1xuICB9LCB7XG4gICAgcm9vdE1hcmdpbjogXCIxMDBweFwiXG4gIH0pLCByLmN1cnJlbnQgJiYgby5jdXJyZW50Lm9ic2VydmUoci5jdXJyZW50KSwgKCkgPT4ge1xuICAgIG8uY3VycmVudCAmJiBvLmN1cnJlbnQuZGlzY29ubmVjdCgpO1xuICB9KSwgW3IuY3VycmVudCwgbiwgZCwgYSwgY10pLCBsID8gLyogQF9fUFVSRV9fICovIHEuanN4KFwiZGl2XCIsIHtcbiAgICBjaGlsZHJlbjogXCJFcnJvciBmZXRjaGluZyBmZWVkIGRhdGFcIlxuICB9KSA6IC8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoXCJkaXZcIiwge1xuICAgIGNoaWxkcmVuOiBbaC5sZW5ndGggIT09IDAgPyAvKiBAX19QVVJFX18gKi8gcS5qc3goaF8sIHtcbiAgICAgIGNhc3RzOiBoLFxuICAgICAgY3Vyc29yOiBcIlwiXG4gICAgfSkgOiAvKiBAX19QVVJFX18gKi8gcS5qc3goXCJkaXZcIiwge1xuICAgICAgY2hpbGRyZW46IChmID0gYSA9PSBudWxsID8gdm9pZCAwIDogYVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IGYubWVzc2FnZVxuICAgIH0pLCBkICYmIC8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoXCJkaXZcIiwge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgIGp1c3RpZnlDb250ZW50OiBcImNlbnRlclwiLFxuICAgICAgICBwYWRkaW5nOiBcIjEwcHhcIlxuICAgICAgfSxcbiAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIHEuanN4cyhcInNwYW5cIiwge1xuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIGFuaW1hdGlvbjogXCJibGluayAxLjVzIGluZmluaXRlXCJcbiAgICAgICAgfSxcbiAgICAgICAgY2hpbGRyZW46IFtcIkxvYWRpbmdcIiwgLyogQF9fUFVSRV9fICovIHEuanN4KFwic3BhblwiLCB7XG4gICAgICAgICAgY2xhc3NOYW1lOiBcImRvdHNcIixcbiAgICAgICAgICBjaGlsZHJlbjogXCIuLi5cIlxuICAgICAgICB9KV1cbiAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gcS5qc3goXCJzdHlsZVwiLCB7XG4gICAgICAgIGNoaWxkcmVuOiBgXG4gICAgICAgICAgICAgICAgICAgICAgICBAa2V5ZnJhbWVzIGJsaW5rIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwJSB7IG9wYWNpdHk6IDE7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA1MCUgeyBvcGFjaXR5OiAwOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMTAwJSB7IG9wYWNpdHk6IDE7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYFxuICAgICAgfSldXG4gICAgfSksIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChcImRpdlwiLCB7XG4gICAgICByZWY6IHJcbiAgICB9KV1cbiAgfSk7XG59LCBtXyA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImJ1dHRvblwiKSh7XG4gIGNsYXNzZXM6IFtcImIxYnF1ZzhyXCJdXG59KSwgeV8gPSAvKiBAX19QVVJFX18gKi8gZGUoXCJidXR0b25cIikoe1xuICBjbGFzc2VzOiBbXCJiMW1yYTQ1d1wiXVxufSksIENmID0gXCJodHRwczovL2ZhcmNhc3Rlci54eXpcIiwgZ20gPSAvKF58XFxzKVxcL1xcdysvZywgcG0gPSAvQFxcdysvZywgbW0gPSAvKChodHRwcz86XFwvXFwvKT8oW2EtekEtWjAtOS4tXStcXC5bYS16QS1aXXsyLH0pKFxcL1teXFxzXSopPykvZywga2YgPSBuZXcgUmVnRXhwKGAoJHtnbS5zb3VyY2V9KXwoJHtwbS5zb3VyY2V9KXwoJHttbS5zb3VyY2V9KWAsIFwiZ1wiKSwgdl8gPSAocykgPT4gZ20udGVzdChzKSA/IGAke0NmfS9+L2NoYW5uZWwke3MudHJpbSgpfWAgOiBwbS50ZXN0KHMpID8gYCR7Q2Z9LyR7cy5zdWJzdHJpbmcoMSl9YCA6IG1tLnRlc3QocykgPyBzLnN0YXJ0c1dpdGgoXCJodHRwXCIpID8gcyA6IGBodHRwOi8vJHtzfWAgOiBcIlwiLCBFXyA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImFcIikoe1xuICBjbGFzc2VzOiBbXCJzYnk5d2EyXCJdXG59KSwgeF8gPSAocykgPT4ge1xuICBpZiAoIXMpIHJldHVybiBbXTtcbiAgY29uc3QgZSA9IFtdO1xuICBsZXQgdCA9IDAsIHI7XG4gIGZvciAoOyAociA9IGtmLmV4ZWMocykpICE9PSBudWxsOyApIHtcbiAgICBjb25zdCBuID0gci5pbmRleDtcbiAgICB0IDwgbiAmJiBlLnB1c2gocy5zbGljZSh0LCBuKSk7XG4gICAgY29uc3QgaSA9IHZfKHJbMF0pLCBvID0gclswXS50cmltKCkuc3RhcnRzV2l0aChcIi9cIik7XG4gICAgZS5wdXNoKC8qIEBfX1BVUkVfXyAqLyBxLmpzeChcInNwYW5cIiwge1xuICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChFXywge1xuICAgICAgICBocmVmOiBpLFxuICAgICAgICB0YXJnZXQ6IFwiX2JsYW5rXCIsXG4gICAgICAgIHN0eWxlOiBvID8ge1xuICAgICAgICAgIG1hcmdpbkxlZnQ6IDMuNVxuICAgICAgICB9IDoge30sXG4gICAgICAgIGNoaWxkcmVuOiByWzBdXG4gICAgICB9LCBuKVxuICAgIH0pKSwgdCA9IGtmLmxhc3RJbmRleDtcbiAgfVxuICByZXR1cm4gdCA8IHMubGVuZ3RoICYmIGUucHVzaChzLnNsaWNlKHQpKSwgZTtcbn0sIFNfID0gLyogQF9fUFVSRV9fICovIGRlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wic2RhaG01OFwiXVxufSksIGJfID0gLyogQF9fUFVSRV9fICovIGRlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wibXppcXl4cFwiXVxufSksIFRfID0gLyogQF9fUFVSRV9fICovIGRlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1widXo3dHBtZlwiXVxufSksIHdfID0gLyogQF9fUFVSRV9fICovIGRlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wiZDFyeGx3YWNcIl1cbn0pLCBBXyA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInVnYzZ5cXBcIl1cbn0pLCBEZiA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInBvcmpmOWFcIl1cbn0pLCBJXyA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInR0dDd4OXhcIl1cbn0pLCBQZiA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcImIxd2JlOW82XCJdXG59KSwgX18gPSBNZigoe1xuICBmaWQ6IHMsXG4gIHVzZXJuYW1lOiBlLFxuICBkaXNwbGF5TmFtZTogdCxcbiAgYXZhdGFySW1nVXJsOiByLFxuICBiaW86IG4sXG4gIGZvbGxvd2VyczogaSxcbiAgZm9sbG93aW5nOiBvLFxuICBoYXNQb3dlckJhZGdlOiBhLFxuICBpc0ZvbGxvd2luZzogbCxcbiAgaXNPd25Qcm9maWxlOiBjLFxuICBvbkNhc3Q6IHUsXG4gIGNvbnRhaW5lclN0eWxlczogZFxufSkgPT4ge1xuICBjb25zdCBoID0geF8obiksIGYgPSBacigoKSA9PiBwZihvKSwgW29dKSwgcCA9IFpyKCgpID0+IHBmKGkpLCBbaV0pLCB5ID0gKCkgPT4ge1xuICAgIHdpbmRvdy5vcGVuKFwiaHR0cHM6Ly9mYXJjYXN0ZXIueHl6L34vc2V0dGluZ3NcIiwgXCJfYmxhbmtcIik7XG4gIH0sIEUgPSB7XG4gICAgY29sb3I6IGQgPT0gbnVsbCA/IHZvaWQgMCA6IGQuY29sb3JcbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoU18sIHtcbiAgICBzdHlsZTogZCxcbiAgICBjaGlsZHJlbjogW2MgJiYgdSAmJiAvKiBAX19QVVJFX18gKi8gcS5qc3hzKFByLCB7XG4gICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAganVzdGlmeUNvbnRlbnQ6IFwic3BhY2UtYmV0d2VlblwiLFxuICAgICAgc3BhY2luZ0JvdHRvbTogXCIyMHB4XCIsXG4gICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoQV8sIHtcbiAgICAgICAgY2hpbGRyZW46IFtcIkBcIiwgZV1cbiAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gcS5qc3gobV8sIHtcbiAgICAgICAgb25DbGljazogdSxcbiAgICAgICAgY2hpbGRyZW46IFwiQ2FzdFwiXG4gICAgICB9KV1cbiAgICB9KSwgLyogQF9fUFVSRV9fICovIHEuanN4KFByLCB7XG4gICAgICBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIHEuanN4cyhiXywge1xuICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoUHIsIHtcbiAgICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAgICAgIGZsZXhHcm93OiAxLFxuICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICBnYXA6IFwiMTBweFwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBxLmpzeChJciwge1xuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChZbywge1xuICAgICAgICAgICAgICB3aWR0aDogXCIyMHB4XCIsXG4gICAgICAgICAgICAgIGhlaWdodDogXCIyMHB4XCIsXG4gICAgICAgICAgICAgIHNyYzogciA/PyBiaSxcbiAgICAgICAgICAgICAgbG9hZGluZzogXCJsYXp5XCIsXG4gICAgICAgICAgICAgIGFsdDogYCR7dCA/PyBcIlNrZWxldG9uXCJ9IEF2YXRhcmBcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChQciwge1xuICAgICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBxLmpzeCh3Xywge1xuICAgICAgICAgICAgICBjaGlsZHJlbjogdCB8fCBgISR7c31gXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gcS5qc3hzKFByLCB7XG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiLFxuICAgICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3hzKFRfLCB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBbXCJAXCIsIGVdXG4gICAgICAgICAgICB9KSwgbCAmJiAvKiBAX19QVVJFX18gKi8gcS5qc3goSV8sIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiRm9sbG93cyB5b3VcIlxuICAgICAgICAgICAgfSldXG4gICAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChQciwge1xuICAgICAgICAgICAgY2hpbGRyZW46IGMgJiYgLyogQF9fUFVSRV9fICovIHEuanN4KHlfLCB7XG4gICAgICAgICAgICAgIG9uQ2xpY2s6IHksXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkVkaXQgUHJvZmlsZVwiXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXVxuICAgICAgICB9KSwgKGggPT0gbnVsbCA/IHZvaWQgMCA6IGgubGVuZ3RoKSAhPT0gMCA/IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChQZiwge1xuICAgICAgICAgIGNoaWxkcmVuOiBoXG4gICAgICAgIH0pIDogLyogQF9fUFVSRV9fICovIHEuanN4KFBmLCB7XG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHBhZGRpbmc6IFwiMjZweCAwcHhcIlxuICAgICAgICAgIH1cbiAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoUHIsIHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6IFwic3BhY2UtYmV0d2VlblwiLFxuICAgICAgICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiBcImNlbnRlclwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoRGYsIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIHEuanN4KFwic3Ryb25nXCIsIHtcbiAgICAgICAgICAgICAgc3R5bGU6IEUsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBmXG4gICAgICAgICAgICB9KSwgXCIgXCIsIFwiRm9sbG93aW5nXCJdXG4gICAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoRGYsIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIHEuanN4KFwic3Ryb25nXCIsIHtcbiAgICAgICAgICAgICAgc3R5bGU6IEUsXG4gICAgICAgICAgICAgIGNoaWxkcmVuOiBwXG4gICAgICAgICAgICB9KSwgXCIgXCIsIFwiRm9sbG93ZXJzXCJdXG4gICAgICAgICAgfSksIGUgJiYgLyogQF9fUFVSRV9fICovIHEuanN4KElyLCB7XG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiBcImF1dG9cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gcS5qc3goSWMsIHtcbiAgICAgICAgICAgICAgdXJsOiBgaHR0cHM6Ly9mYXJjYXN0ZXIueHl6LyR7ZX1gXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH0pXVxuICAgICAgICB9KV1cbiAgICAgIH0pXG4gICAgfSldXG4gIH0pO1xufSk7XG5hc3luYyBmdW5jdGlvbiBSXyh7XG4gIGZpZDogcyxcbiAgdmlld2VyRmlkOiBlLFxuICBjbGllbnRJZDogdFxufSkge1xuICB2YXIgcjtcbiAgdHJ5IHtcbiAgICBsZXQgbiA9IGAke29ufS92Mi9mYXJjYXN0ZXIvdXNlci9idWxrP2NsaWVudF9pZD0ke3R9JmZpZHM9JHtzfWA7XG4gICAgZSAmJiAobiArPSBgJnZpZXdlcl9maWQ9JHtlfWApO1xuICAgIGNvbnN0IG8gPSBhd2FpdCAoYXdhaXQgYW4obikpLmpzb24oKTtcbiAgICByZXR1cm4gKChyID0gbyA9PSBudWxsID8gdm9pZCAwIDogby51c2VycykgPT0gbnVsbCA/IHZvaWQgMCA6IHJbMF0pID8/IG51bGw7XG4gIH0gY2F0Y2ggKG4pIHtcbiAgICByZXR1cm4gY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIHVzZXIgYnkgZmlkXCIsIG4pLCBudWxsO1xuICB9XG59XG5jb25zdCB2UiA9ICh7XG4gIGZpZDogcyxcbiAgdmlld2VyRmlkOiBlLFxuICBjb250YWluZXJTdHlsZXM6IHRcbn0pID0+IHtcbiAgdmFyIGg7XG4gIGNvbnN0IHtcbiAgICBjbGllbnRfaWQ6IHJcbiAgfSA9IHRzKCksIFtuLCBpXSA9IHFlKG51bGwpLCBbbywgYV0gPSBxZSghMCksIFtsLCBjXSA9IHFlKG51bGwpLCB1ID0gKG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uZmlkKSA9PT0gZTtcbiAgZnQoKCkgPT4ge1xuICAgIHMgJiYgKGEoITApLCBjKG51bGwpLCBSXyh7XG4gICAgICBmaWQ6IHMsXG4gICAgICB2aWV3ZXJGaWQ6IGUsXG4gICAgICBjbGllbnRJZDogclxuICAgIH0pLnRoZW4oKGYpID0+IHtcbiAgICAgIGkoZik7XG4gICAgfSkuY2F0Y2goKGYpID0+IHtcbiAgICAgIGMoZik7XG4gICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICBhKCExKTtcbiAgICB9KSk7XG4gIH0sIFtzLCBlXSk7XG4gIGNvbnN0IGQgPSB1dCgoKSA9PiB7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIG8gPyAvKiBAX19QVVJFX18gKi8gcS5qc3goXCJkaXZcIiwge1xuICAgIHN0eWxlOiB7XG4gICAgICBwYWRkaW5nOiBcIjIwcHhcIlxuICAgIH0sXG4gICAgY2hpbGRyZW46IFwiTG9hZGluZy4uLlwiXG4gIH0pIDogIW4gfHwgbCA/IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChcImRpdlwiLCB7XG4gICAgY2hpbGRyZW46IFwiRXJyb3IgZmV0Y2hpbmcgdXNlciBkYXRhXCJcbiAgfSkgOiAvKiBAX19QVVJFX18gKi8gcS5qc3goX18sIHtcbiAgICBmaWQ6IHMsXG4gICAgdXNlcm5hbWU6IG4udXNlcm5hbWUsXG4gICAgZGlzcGxheU5hbWU6IG4uZGlzcGxheV9uYW1lLFxuICAgIGF2YXRhckltZ1VybDogbi5wZnBfdXJsLFxuICAgIGJpbzogbi5wcm9maWxlLmJpby50ZXh0LFxuICAgIGZvbGxvd2Vyczogbi5mb2xsb3dlcl9jb3VudCxcbiAgICBmb2xsb3dpbmc6IG4uZm9sbG93aW5nX2NvdW50LFxuICAgIGhhc1Bvd2VyQmFkZ2U6IG4ucG93ZXJfYmFkZ2UsXG4gICAgaXNPd25Qcm9maWxlOiB1LFxuICAgIGlzRm9sbG93aW5nOiAoaCA9IG4udmlld2VyX2NvbnRleHQpID09IG51bGwgPyB2b2lkIDAgOiBoLmZvbGxvd2VkX2J5LFxuICAgIG9uQ2FzdDogZCxcbiAgICBjb250YWluZXJTdHlsZXM6IHRcbiAgfSk7XG59LCBMXyA9IC8qIEBfX1BVUkVfXyAqLyBkZShcInVsXCIpKHtcbiAgY2xhc3NlczogW1wiZDEycng0b21cIl1cbn0pLCBDXyA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImxpXCIpKHtcbiAgY2xhc3NlczogW1wibHJwbTZscFwiXVxufSksIGtfID0gLyogQF9fUFVSRV9fICovIGRlKFwiaW1nXCIpKHtcbiAgY2xhc3NlczogW1wiYTFlOWhnM2JcIl1cbn0pLCBEXyA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInUxYXFheTFpXCJdXG59KSwgUF8gPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJkMW0wbmpxXCJdXG59KSwgTV8gPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJ1MWx2bGJ1b1wiXVxufSksIE9fID0gKHtcbiAgdXNlcnM6IHMsXG4gIG9uU2VsZWN0OiBlLFxuICBjdXN0b21TdHlsZXM6IHQgPSB7fVxufSkgPT4gLyogQF9fUFVSRV9fICovIHEuanN4KExfLCB7XG4gIHN0eWxlOiB7XG4gICAgLi4udCA9PSBudWxsID8gdm9pZCAwIDogdC5kcm9wZG93blxuICB9LFxuICBjaGlsZHJlbjogcy5tYXAoKHIpID0+IC8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoQ18sIHtcbiAgICBzdHlsZToge1xuICAgICAgLi4udCA9PSBudWxsID8gdm9pZCAwIDogdC5saXN0SXRlbVxuICAgIH0sXG4gICAgb25DbGljazogKCkgPT4gZShyKSxcbiAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBxLmpzeChrXywge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgLi4udCA9PSBudWxsID8gdm9pZCAwIDogdC5hdmF0YXJcbiAgICAgIH0sXG4gICAgICBzcmM6IHIucGZwX3VybCxcbiAgICAgIGFsdDogci51c2VybmFtZVxuICAgIH0pLCAvKiBAX19QVVJFX18gKi8gcS5qc3hzKERfLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICAuLi50LnVzZXJJbmZvXG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3goUF8sIHtcbiAgICAgICAgY2hpbGRyZW46IHIuZGlzcGxheV9uYW1lXG4gICAgICB9KSwgLyogQF9fUFVSRV9fICovIHEuanN4cyhNXywge1xuICAgICAgICBjaGlsZHJlbjogW1wiQFwiLCByLnVzZXJuYW1lXVxuICAgICAgfSldXG4gICAgfSldXG4gIH0sIHIuZmlkKSlcbn0pLCBCXyA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcImM5aG0yMHRcIl1cbn0pLCBGXyA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImlucHV0XCIpKHtcbiAgY2xhc3NlczogW1wiaTgwc2Q4aFwiXVxufSk7XG5hc3luYyBmdW5jdGlvbiBOXyh7XG4gIHE6IHMsXG4gIHZpZXdlckZpZDogZSxcbiAgY2xpZW50X2lkOiB0XG59KSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIGxldCBuID0gYCR7b259L3YyL2ZhcmNhc3Rlci91c2VyL3NlYXJjaD9xPSR7c30mbGltaXQ9NSR7ZSA/IGAmdmlld2VyX2ZpZD0ke2V9YCA6IFwiXCJ9JmNsaWVudF9pZD0ke3R9YDtcbiAgICBjb25zdCBvID0gYXdhaXQgKGF3YWl0IGFuKG4pKS5qc29uKCk7XG4gICAgcmV0dXJuICgociA9IG8gPT0gbnVsbCA/IHZvaWQgMCA6IG8ucmVzdWx0KSA9PSBudWxsID8gdm9pZCAwIDogci51c2VycykgfHwgW107XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5jb25zdCBFUiA9ICh7XG4gIHZhbHVlOiBzLFxuICBvbkNoYW5nZTogZSxcbiAgc3R5bGU6IHQgPSB7fSxcbiAgcGxhY2Vob2xkZXI6IHIgPSBcIkVudGVyIHVzZXJuYW1lXCIsXG4gIGRpc2FibGVkOiBuID0gITEsXG4gIHZpZXdlckZpZDogaSxcbiAgY3VzdG9tU3R5bGVzOiBvID0ge30sXG4gIGxpbWl0OiBhID0gbnVsbFxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgY2xpZW50X2lkOiBsXG4gIH0gPSB0cygpLCBbYywgdV0gPSBxZShcIlwiKSwgW2QsIGhdID0gcWUoITEpLCBbZiwgcF0gPSBxZShbXSksIHkgPSBidChudWxsKTtcbiAgZnQoKCkgPT4ge1xuICAgIGNvbnN0IE0gPSAocyA9PSBudWxsID8gdm9pZCAwIDogcy5zcGxpdChcIixcIikpIHx8IFtdO1xuICAgIGlmICghTVtNLmxlbmd0aCAtIDFdKSB7XG4gICAgICB1KFwiXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1KE1bTS5sZW5ndGggLSAxXS50cmltKCkpO1xuICB9LCBbc10pLCBmdCgoKSA9PiB7XG4gICAgYyAhPT0gXCJcIiAmJiAhL15cXGQrJC8udGVzdChjKSA/IEUoYykgOiBoKCExKTtcbiAgfSwgW2NdKTtcbiAgY29uc3QgRSA9IGFzeW5jIChNKSA9PiB7XG4gICAgY29uc3QgSCA9IGF3YWl0IE5fKHtcbiAgICAgIHE6IE0sXG4gICAgICB2aWV3ZXJGaWQ6IGksXG4gICAgICBjbGllbnRfaWQ6IGxcbiAgICB9KTtcbiAgICBIICYmIChwKEgpLCBoKCEwKSk7XG4gIH0sIGIgPSAoTSkgPT4ge1xuICAgIGNvbnN0IEggPSBNLnRhcmdldC52YWx1ZTtcbiAgICBlKEgpO1xuICB9LCBSID0gKE0pID0+IHtcbiAgICBsZXQgSCA9IHMuc3BsaXQoXCIsXCIpO1xuICAgIGEgIT09IG51bGwgJiYgSC5sZW5ndGggPj0gYSA/IEhbSC5sZW5ndGggLSAxXSA9IE0uZmlkLnRvU3RyaW5nKCkgOiBILnB1c2goTS5maWQudG9TdHJpbmcoKSk7XG4gICAgY29uc3QgSyA9IEguam9pbihcIixcIik7XG4gICAgZShLKSwgdShcIlwiKSwgaCghMSk7XG4gIH0sIEEgPSAoKSA9PiB7XG4gICAgYyAmJiBpc05hTihOdW1iZXIoYykpICYmIGgoITApO1xuICB9LCBGID0gKCkgPT4ge1xuICAgIHNldFRpbWVvdXQoKCkgPT4gaCghMSksIDIwMCk7XG4gIH07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gcS5qc3hzKEJfLCB7XG4gICAgc3R5bGU6IHQsXG4gICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3goRl8sIHtcbiAgICAgIHJlZjogeSxcbiAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgdmFsdWU6IHMsXG4gICAgICBvbkNoYW5nZTogYixcbiAgICAgIG9uRm9jdXM6IEEsXG4gICAgICBvbkJsdXI6IEYsXG4gICAgICBwbGFjZWhvbGRlcjogcixcbiAgICAgIGRpc2FibGVkOiBuXG4gICAgfSksIGQgJiYgLyogQF9fUFVSRV9fICovIHEuanN4KE9fLCB7XG4gICAgICB1c2VyczogZixcbiAgICAgIG9uU2VsZWN0OiBSLFxuICAgICAgY3VzdG9tU3R5bGVzOiBvXG4gICAgfSldXG4gIH0pO1xufSwgVV8gPSAoe1xuICBjb2xvcjogcyA9IFwiIzg1NURDRFwiXG59KSA9PiAvKiBAX19QVVJFX18gKi8gcS5qc3hzKFwic3ZnXCIsIHtcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgd2lkdGg6IFwiMjRcIixcbiAgaGVpZ2h0OiBcIjI0XCIsXG4gIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICBzdHJva2U6IHMsXG4gIFwic3Ryb2tlLXdpZHRoXCI6IFwiMlwiLFxuICBcInN0cm9rZS1saW5lY2FwXCI6IFwicm91bmRcIixcbiAgXCJzdHJva2UtbGluZWpvaW5cIjogXCJyb3VuZFwiLFxuICBjbGFzc05hbWU6IFwibHVjaWRlIGx1Y2lkZS1zZWFyY2hcIixcbiAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3goXCJjaXJjbGVcIiwge1xuICAgIGN4OiBcIjExXCIsXG4gICAgY3k6IFwiMTFcIixcbiAgICByOiBcIjhcIlxuICB9KSwgLyogQF9fUFVSRV9fICovIHEuanN4KFwicGF0aFwiLCB7XG4gICAgZDogXCJtMjEgMjEtNC4zLTQuM1wiXG4gIH0pXVxufSksICRfID0gKHtcbiAgY29sb3I6IHMgPSBcIiM4NTVEQ0RcIlxufSkgPT4gLyogQF9fUFVSRV9fICovIHEuanN4KFwic3ZnXCIsIHtcbiAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgd2lkdGg6IFwiMjRcIixcbiAgaGVpZ2h0OiBcIjI0XCIsXG4gIHZpZXdCb3g6IFwiMCAwIDI0IDI0XCIsXG4gIGZpbGw6IFwibm9uZVwiLFxuICBzdHJva2U6IHMsXG4gIFwic3Ryb2tlLXdpZHRoXCI6IFwiMlwiLFxuICBcInN0cm9rZS1saW5lY2FwXCI6IFwicm91bmRcIixcbiAgXCJzdHJva2UtbGluZWpvaW5cIjogXCJyb3VuZFwiLFxuICBjbGFzc05hbWU6IFwibHVjaWRlIGx1Y2lkZS1sb2FkZXItY2lyY2xlXCIsXG4gIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gcS5qc3goXCJwYXRoXCIsIHtcbiAgICBkOiBcIk0yMSAxMmE5IDkgMCAxIDEtNi4yMTktOC41NlwiXG4gIH0pXG59KSwgR18gPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJpZzdrY3VjXCJdXG59KSwgVl8gPSAvKiBAX19QVVJFX18gKi8gZGUoXCJpbnB1dFwiKSh7XG4gIGNsYXNzZXM6IFtcInNoN3o3azZcIl1cbn0pLCBqXyA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInMxNGFpMjAzXCJdXG59KSwgS18gPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJpZjE4bmQ2XCJdXG59KSwgSF8gPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJzZDgzM2xiXCJdXG59KSwgcV8gPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJ1Z281ODZtXCJdXG59KSwgV18gPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJ1a3d0eTFkXCJdXG59KSwgel8gPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJ1NzdvbG15XCJdXG59KSwgWV8gPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJzMXh2a3h3d1wiXVxufSksIFpfID0gLyogQF9fUFVSRV9fICovIGRlKFwiZGl2XCIpKHtcbiAgY2xhc3NlczogW1wiczFmNmIxamFcIl1cbn0pLCBYXyA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcInVkaXVmZDhcIl1cbn0pLCBKXyA9IC8qIEBfX1BVUkVfXyAqLyBkZShcImRpdlwiKSh7XG4gIGNsYXNzZXM6IFtcImYxYjhhMmgwXCJdXG59KSwgUV8gPSAvKiBAX19QVVJFX18gKi8gZGUoXCJkaXZcIikoe1xuICBjbGFzc2VzOiBbXCJsMXlxMjZqMFwiXVxufSksIGVSID0gLyogQF9fUFVSRV9fICovIGRlKFwibGlcIikoe1xuICBjbGFzc2VzOiBbXCJzMThtazQ3a1wiXVxufSksIHhSID0gKHtcbiAgd2lkdGg6IHMsXG4gIGhlaWdodDogZSxcbiAgc2VsZWN0ZWRVc2VyczogdCxcbiAgb25TZWxlY3RVc2VyczogcixcbiAgLi4ublxufSkgPT4ge1xuICBjb25zdCB7XG4gICAgY2xpZW50X2lkOiBpXG4gIH0gPSB0cygpLCB7XG4gICAgdXNlcjogbyxcbiAgICBpc0F1dGhlbnRpY2F0ZWQ6IGFcbiAgfSA9IEVnKCksIFtsLCBjXSA9IHFlKFwiXCIpLCBbdSwgZF0gPSBxZShbXSksIFtoLCBmXSA9IHFlKCExKSwgcCA9IGJ0KG51bGwpO1xuICBmdCgoKSA9PiB7XG4gICAgZnVuY3Rpb24gTShIKSB7XG4gICAgICBwLmN1cnJlbnQgJiYgIXAuY3VycmVudC5jb250YWlucyhILnRhcmdldCkgJiYgKGQoW10pLCBjKFwiXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgTSksICgpID0+IHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgTSk7XG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCBiID0gdXQoKChNLCBIKSA9PiB7XG4gICAgbGV0IEs7XG4gICAgcmV0dXJuICguLi5qKSA9PiB7XG4gICAgICBjbGVhclRpbWVvdXQoSyksIEsgPSBzZXRUaW1lb3V0KCgpID0+IE0oLi4uaiksIEgpO1xuICAgIH07XG4gIH0pKGFzeW5jIChNLCBIKSA9PiB7XG4gICAgdmFyIEs7XG4gICAgaWYgKCFNKSB7XG4gICAgICBkKFtdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZighMCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IEMgPSBhd2FpdCAoYXdhaXQgYW4oSCkpLmpzb24oKTtcbiAgICAgIGQoKChLID0gQyA9PSBudWxsID8gdm9pZCAwIDogQy5yZXN1bHQpID09IG51bGwgPyB2b2lkIDAgOiBLLnVzZXJzKSB8fCBbXSk7XG4gICAgfSBjYXRjaCAoaikge1xuICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGZldGNoaW5nIGRhdGE6XCIsIGopO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBmKCExKTtcbiAgICB9XG4gIH0sIDUwMCksIFtdKSwgUiA9IChNKSA9PiB7XG4gICAgY29uc3QgSCA9IGAke29ufS92Mi9mYXJjYXN0ZXIvdXNlci9zZWFyY2g/cT0ke00udGFyZ2V0LnZhbHVlfSZjbGllbnRfaWQ9JHtpfSR7YSA/IGAmdmlld2VyX2ZpZD0ke28gPT0gbnVsbCA/IHZvaWQgMCA6IG8uZmlkfWAgOiBcIlwifSlgO1xuICAgIGMoTS50YXJnZXQudmFsdWUpLCBiKE0udGFyZ2V0LnZhbHVlLCBIKTtcbiAgfSwgQSA9IChNKSA9PiB7XG4gICAgdC5zb21lKChIKSA9PiBILnVzZXJuYW1lID09PSBNLnVzZXJuYW1lKSB8fCAocihbLi4udCwgTV0pLCBjKFwiXCIpLCBkKFtdKSk7XG4gIH0sIEYgPSAoTSkgPT4ge1xuICAgIHIodC5maWx0ZXIoKEgpID0+IEgudXNlcm5hbWUgIT09IE0pKTtcbiAgfTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoR18sIHtcbiAgICByZWY6IHAsXG4gICAgc3R5bGU6IHtcbiAgICAgIHdpZHRoOiBzXG4gICAgfSxcbiAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoS18sIHtcbiAgICAgIGNoaWxkcmVuOiBbdC5tYXAoKE0pID0+IC8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoSF8sIHtcbiAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3goWW8sIHtcbiAgICAgICAgICBzcmM6IE0ucGZwX3VybCA/PyBiaSxcbiAgICAgICAgICBhbHQ6IGAke00udXNlcm5hbWV9IEF2YXRhcmAsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiBcIjI0cHhcIixcbiAgICAgICAgICAgIGhlaWdodDogXCIyNHB4XCIsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiNTAlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gcS5qc3goXCJzcGFuXCIsIHtcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgbWFyZ2luTGVmdDogXCI4cHhcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2hpbGRyZW46IE0uZGlzcGxheV9uYW1lXG4gICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gcS5qc3goc20sIHtcbiAgICAgICAgICBzaXplOiAyMCxcbiAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBGKE0udXNlcm5hbWUpXG4gICAgICAgIH0pXVxuICAgICAgfSwgTS51c2VybmFtZSkpLCAvKiBAX19QVVJFX18gKi8gcS5qc3hzKFlfLCB7XG4gICAgICAgIGNoaWxkcmVuOiBbLyogQF9fUFVSRV9fICovIHEuanN4KFpfLCB7XG4gICAgICAgICAgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBxLmpzeChVXywge1xuICAgICAgICAgICAgY29sb3I6IFwiIzg1NURDRFwiXG4gICAgICAgICAgfSlcbiAgICAgICAgfSksIC8qIEBfX1BVUkVfXyAqLyBxLmpzeChWXywge1xuICAgICAgICAgIC4uLm4sXG4gICAgICAgICAgdmFsdWU6IGwsXG4gICAgICAgICAgb25DaGFuZ2U6IFIsXG4gICAgICAgICAgcGxhY2Vob2xkZXI6IFwiVHlwZSB0byBzZWFyY2ggdXNlcnNcIixcbiAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgd2lkdGg6IHMgfHwgXCIxMDAlXCIsXG4gICAgICAgICAgICBoZWlnaHQ6IGUgfHwgXCI0MHB4XCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pXVxuICAgICAgfSldXG4gICAgfSksIGggPyAvKiBAX19QVVJFX18gKi8gcS5qc3goUV8sIHtcbiAgICAgIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8gcS5qc3goJF8sIHtcbiAgICAgICAgY29sb3I6IFwiIzg1NURDRFwiXG4gICAgICB9KVxuICAgIH0pIDogdS5sZW5ndGggIT09IDAgJiYgLyogQF9fUFVSRV9fICovIHEuanN4KGpfLCB7XG4gICAgICBjaGlsZHJlbjogdS5tYXAoKE0pID0+IC8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoZVIsIHtcbiAgICAgICAgb25DbGljazogKCkgPT4gQShNKSxcbiAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3goWW8sIHtcbiAgICAgICAgICBzcmM6IE0ucGZwX3VybCA/PyBiaSxcbiAgICAgICAgICBhbHQ6IGAke00udXNlcm5hbWV9IEF2YXRhcmAsXG4gICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiBcIjQwcHhcIixcbiAgICAgICAgICAgIGhlaWdodDogXCI0MHB4XCIsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IFwiNTAlXCJcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gcS5qc3hzKHFfLCB7XG4gICAgICAgICAgY2hpbGRyZW46IFsvKiBAX19QVVJFX18gKi8gcS5qc3goV18sIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBNLmRpc3BsYXlfbmFtZVxuICAgICAgICAgIH0pLCAvKiBAX19QVVJFX18gKi8gcS5qc3hzKFhfLCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogWy8qIEBfX1BVUkVfXyAqLyBxLmpzeHMoel8sIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFtcIkBcIiwgTS51c2VybmFtZV1cbiAgICAgICAgICAgIH0pLCBNLnZpZXdlcl9jb250ZXh0ICYmIChNLnZpZXdlcl9jb250ZXh0LmZvbGxvd2luZyB8fCBNLnZpZXdlcl9jb250ZXh0LmZvbGxvd2VkX2J5KSAmJiAvKiBAX19QVVJFX18gKi8gcS5qc3goSl8sIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IE0udmlld2VyX2NvbnRleHQuZm9sbG93aW5nICYmIE0udmlld2VyX2NvbnRleHQuZm9sbG93ZWRfYnkgPyBcIkZvbGxvd2luZyBlYWNoIG90aGVyXCIgOiBNLnZpZXdlcl9jb250ZXh0LmZvbGxvd2luZyA/IFwiRm9sbG93aW5nXCIgOiBNLnZpZXdlcl9jb250ZXh0LmZvbGxvd2VkX2J5ID8gXCJGb2xsb3dzIHlvdVwiIDogbnVsbFxuICAgICAgICAgICAgfSldXG4gICAgICAgICAgfSldXG4gICAgICAgIH0pXVxuICAgICAgfSwgTS51c2VybmFtZSkpXG4gICAgfSldXG4gIH0pO1xufTtcbmV4cG9ydCB7XG4gIG9hIGFzIENhc3RDYXJkLFxuICBkUiBhcyBNaW5pQXBwUHJvdmlkZXIsXG4gIHBTIGFzIE5leW5hckF1dGhCdXR0b24sXG4gIHhSIGFzIE5leW5hckF1dG9Db21wbGV0ZVVzZXIsXG4gIFJBIGFzIE5leW5hckNhc3RDYXJkLFxuICBmUiBhcyBOZXluYXJDb250ZXh0UHJvdmlkZXIsXG4gIG1SIGFzIE5leW5hckNvbnZlcnNhdGlvbkxpc3QsXG4gIHlSIGFzIE5leW5hckZlZWRMaXN0LFxuICBhSSBhcyBOZXluYXJGcmFtZUNhcmQsXG4gIHZSIGFzIE5leW5hclByb2ZpbGVDYXJkLFxuICBFUiBhcyBOZXluYXJVc2VyRHJvcGRvd24sXG4gIGdzIGFzIFNJV05fdmFyaWFudCxcbiAgeWcgYXMgVGhlbWUsXG4gIGR1IGFzIHVzZUxvY2FsU3RvcmFnZSxcbiAgaFIgYXMgdXNlTWluaUFwcCxcbiAgdHMgYXMgdXNlTmV5bmFyQ29udGV4dFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@neynar/react/dist/bundle.es.js\n");</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >/***/ })</span>
&nbsp;
<span class="cstat-no" title="statement not covered" >};</span>
<span class="cstat-no" title="statement not covered" >;</span></pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-10-19T07:19:20.045Z
            </div>
        <script src="../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../sorter.js"></script>
        <script src="../../../../block-navigation.js"></script>
    </body>
</html>
    